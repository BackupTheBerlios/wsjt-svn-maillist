<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r3542 - in branches/wsjtx: . lib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2013-August/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r3542%20-%20in%20branches/wsjtx%3A%20.%20lib&In-Reply-To=%3C20130810152956.36E8C55B0C%40scm.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003233.html">
   <LINK REL="Next"  HREF="003235.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r3542 - in branches/wsjtx: . lib</H1>
    <B>bsomervi at scm.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r3542%20-%20in%20branches/wsjtx%3A%20.%20lib&In-Reply-To=%3C20130810152956.36E8C55B0C%40scm.berlios.de%3E"
       TITLE="[WSJT-SVN] r3542 - in branches/wsjtx: . lib">bsomervi at scm.berlios.de
       </A><BR>
    <I>Sat Aug 10 17:29:55 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="003233.html">[WSJT-SVN] r3541 - in branches/wsjtx: . lib
</A></li>
        <LI>Next message: <A HREF="003235.html">[WSJT-SVN] r3543 - branches/wsjtx
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3234">[ date ]</a>
              <a href="thread.html#3234">[ thread ]</a>
              <a href="subject.html#3234">[ subject ]</a>
              <a href="author.html#3234">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bsomervi
Date: 2013-08-10 17:29:55 +0200 (Sat, 10 Aug 2013)
New Revision: 3542

Added:
   branches/wsjtx/AudioDevice.hpp
Modified:
   branches/wsjtx/Detector.cpp
   branches/wsjtx/Detector.hpp
   branches/wsjtx/Modulator.cpp
   branches/wsjtx/Modulator.hpp
   branches/wsjtx/PSKReporter.h
   branches/wsjtx/devsetup.cpp
   branches/wsjtx/devsetup.h
   branches/wsjtx/devsetup.ui
   branches/wsjtx/killbyname.cpp
   branches/wsjtx/lib/afc65b.f90
   branches/wsjtx/lib/afc9.f90
   branches/wsjtx/lib/gran.c
   branches/wsjtx/lib/usleep.c
   branches/wsjtx/lib/wrapkarn.c
   branches/wsjtx/logqso.cpp
   branches/wsjtx/logqso.h
   branches/wsjtx/main.cpp
   branches/wsjtx/mainwindow.cpp
   branches/wsjtx/mainwindow.h
   branches/wsjtx/mainwindow.ui
   branches/wsjtx/meterwidget.cpp
   branches/wsjtx/meterwidget.h
   branches/wsjtx/psk_reporter.cpp
   branches/wsjtx/psk_reporter.h
   branches/wsjtx/rigclass.cpp
   branches/wsjtx/rigclass.h
   branches/wsjtx/signalmeter.cpp
   branches/wsjtx/signalmeter.h
   branches/wsjtx/soundin.cpp
   branches/wsjtx/soundin.h
   branches/wsjtx/soundout.cpp
   branches/wsjtx/soundout.h
   branches/wsjtx/widegraph.cpp
   branches/wsjtx/widegraph.h
   branches/wsjtx/wsjtx.pro
Log:
Added audio channel support.

Audio input can be mono, left of stereo pair or, right of stereo
pair. Audio output can be mono, left of stereo pair, right of stereo
pair or, both of stereo pair (the same output goes to both channels in
both mode). Settings are remembered between sessions.

Stream channel suport is implemented mainly in the new AudioDevice
class which is now the base class of Modulator and Detector.

Audio channels are selected on the configuration screen. Only
supported channel configurations per device can be selected.

Audio output volume (actually attenuation) is now possible from the
GUI. I have added a slider control to the main window; I don't
necessarily propose this as a final release location for the widget as
I understand that changes to the main screen are sensitive. This
location is just a starting suggestion for a trial. The volume
(attenuation) setting is remembered between sessions and is not device
dependent. This addresses all issues of volume setting on *nix
versions since there is no need to use pavucontrol to set audio
levels. The volume (attenuation) action is logarithmic.

Shaped CW keying has been implemented in Modulator although it is
currently disabled as I am not 100% happy wth the implementation. If
you want to try it define the C++ preprocessor macro WSJT_SOFT_KEYING
in your build.

The Modulator instance has been moved to the same thread as the
SoundOutput instance as it should have been since the output callback
already operates in that thread. Cross thread slots are now correctly
called in a thread safe way as a result.

A number of files where in the SVN repository with DOS line endings
which I have removed. SVN users on Windows need set the config for
native line endings so that DOS line endings are automatically
stripped on checkin.

The DevSetup class now holds it's UI o the heap to reduce imapact on
build dependencies.

The application settings are now passed to objects from the main.cpp
file. Management of settings are moved to the responsible classes (top
level windows). This has involved a few settings moving groups so
users will see some settings reverting to default values on the first
run of an update.

Persistance of top level windows geometry and position is now handled
in the recommened manner (constructor for load, closeEvent for store
in modal windows and, hideEvent for store in modeless dialogs).

The MainWindow class now holds its children as members rather than
global variables.

The LogQSO class now hides its implementation and takes responsibility
for its own settings and widows rendering parameters. A new settings
file group is implemented to persist the LogQSO class settings.

The WideGraph class now hides its implementation and manages its own
settings and window rendering parameters.

  --This line, and those below, will be ignored--

M    Modulator.cpp
M    rigclass.cpp
M    widegraph.cpp
M    signalmeter.cpp
M    soundin.cpp
M    soundout.cpp
M    mainwindow.h
M    main.cpp
M    meterwidget.h
M    devsetup.cpp
M    mainwindow.ui
M    Detector.cpp
M    logqso.h
M    rigclass.h
M    mainwindow.cpp
M    meterwidget.cpp
M    soundin.h
M    devsetup.ui
M    wsjtx.pro
M    devsetup.h
M    logqso.cpp
M    Modulator.hpp
M    psk_reporter.cpp
M    killbyname.cpp
M    Detector.hpp
M    signalmeter.h
M    widegraph.h
M    psk_reporter.h
M    soundout.h
M    PSKReporter.h
M    lib/afc65b.f90
M    lib/gran.c
M    lib/usleep.c
M    lib/afc9.f90
M    lib/wrapkarn.c
A    AudioDevice.hpp


Added: branches/wsjtx/AudioDevice.hpp
===================================================================
--- branches/wsjtx/AudioDevice.hpp	                        (rev 0)
+++ branches/wsjtx/AudioDevice.hpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -0,0 +1,105 @@
+#ifndef AUDIODEVICE_HPP__
+#define AUDIODEVICE_HPP__
+
+#include &lt;QIODevice&gt;
+
+class QDataStream;
+
+//
+// abstract base class for audio devices
+//
+class AudioDevice : public QIODevice
+{
+public:
+  enum Channel {Mono, Left, Right, Both}; // these are mapped to combobox index so don't change
+
+  static char const * toString (Channel c)
+  {
+    return Mono == c ? &quot;Mono&quot; : Left == c ? &quot;Left&quot; : Right == c ? &quot;Right&quot; : &quot;Both&quot;;
+  }
+
+  static Channel fromString (QString const&amp; str)
+  {
+    QString s (str.toCaseFolded ().trimmed ().toLatin1 ());
+    return &quot;both&quot; == s ? Both : &quot;right&quot; == s ? Right : &quot;left&quot; == s ? Left : Mono;
+  }
+
+  bool open (OpenMode mode, Channel channel)
+  {
+    m_channel = channel;
+
+    // ensure we are unbuffered
+    return QIODevice::open (mode | QIODevice::Unbuffered);
+  }
+
+  bool isSequential () const {return true;}
+
+  size_t bytesPerFrame () const {return sizeof (qint16) * (Mono == m_channel ? 1 : 2);}
+
+  Channel channel () const {return m_channel;}
+  void channel (Channel newChannel) {m_channel = newChannel;}
+
+protected:
+  AudioDevice (QObject * parent = 0)
+    : QIODevice (parent)
+  {
+  }
+
+  void store (char const * source, qint64 numFrames, qint16 * dest)
+  {
+    qint16 const * begin (reinterpret_cast&lt;qint16 const *&gt; (source));
+    for ( qint16 const * i = begin; i != begin + numFrames * (bytesPerFrame () / sizeof (qint16)); i += bytesPerFrame () / sizeof (qint16))
+      {
+	switch (m_channel)
+	  {
+	  case Mono:
+	    *dest++ = *i;
+	    break;
+
+	  case Right:
+	    *dest++ = *(i + 1);
+	    break;
+
+	  case Both:		// should be able to happen but if it
+				// does we'll take left
+	    Q_ASSERT (Both == m_channel);
+	  case Left:
+	    *dest++ = *i;
+	    break;
+	  }
+      }
+  }
+
+  qint16 * load (qint16 const sample, qint16 * dest)
+  {
+    switch (m_channel)
+      {
+      case Mono:
+	*dest++ = sample;
+	break;
+
+      case Left:
+	*dest++ = sample;
+	*dest++ = 0;
+	break;
+
+      case Right:
+	*dest++ = 0;
+	*dest++ = sample;
+	break;
+
+      case Both:
+	*dest++ = sample;
+	*dest++ = sample;
+	break;
+      }
+    return dest;
+  }
+
+private:
+  Channel m_channel;
+};
+
+Q_DECLARE_METATYPE (AudioDevice::Channel);
+
+#endif

Modified: branches/wsjtx/Detector.cpp
===================================================================
--- branches/wsjtx/Detector.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/Detector.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -6,11 +6,11 @@
 
 #include &quot;commons.h&quot;
 
-Detector::Detector (unsigned frameRate, unsigned periodLengthInSeconds, unsigned bytesPerSignal, QObject * parent)
-  : QIODevice (parent)
+Detector::Detector (unsigned frameRate, unsigned periodLengthInSeconds, unsigned framesPerSignal, QObject * parent)
+  : AudioDevice (parent)
   , m_frameRate (frameRate)
   , m_period (periodLengthInSeconds)
-  , m_bytesPerSignal (bytesPerSignal)
+  , m_framesPerSignal (framesPerSignal)
   , m_monitoring (false)
   , m_starting (false)
 {
@@ -37,28 +37,25 @@
 
 qint64 Detector::writeData (char const * data, qint64 maxSize)
 {
-  Q_ASSERT (!(maxSize % static_cast&lt;qint64&gt; (sizeof (frame_t)))); // no torn frames
-  Q_ASSERT (!(reinterpret_cast&lt;size_t&gt; (data) % __alignof__ (frame_t))); // data is aligned as frame_t would be
+  Q_ASSERT (!(maxSize % static_cast&lt;qint64&gt; (bytesPerFrame ()))); // no torn frames
 
-  frame_t const * frames (reinterpret_cast&lt;frame_t const *&gt; (data));
-
   qint64 framesAcceptable (sizeof (jt9com_.d2) / sizeof (jt9com_.d2[0]) - jt9com_.kin);
-  qint64 framesAccepted (qMin (static_cast&lt;qint64&gt; (maxSize / sizeof (jt9com_.d2[0])), framesAcceptable));
+  qint64 framesAccepted (qMin (static_cast&lt;qint64&gt; (maxSize / bytesPerFrame ()), framesAcceptable));
   
-  if (framesAccepted &lt; static_cast&lt;qint64&gt; (maxSize / sizeof (jt9com_.d2[0])))
+  if (framesAccepted &lt; static_cast&lt;qint64&gt; (maxSize / bytesPerFrame ()))
     {
       qDebug () &lt;&lt; &quot;dropped &quot; &lt;&lt; maxSize / sizeof (jt9com_.d2[0]) - framesAccepted &lt;&lt; &quot; frames of data on the floor!&quot;;
     }
 
-  qCopy (frames, frames + framesAccepted, &amp;jt9com_.d2[jt9com_.kin]);
+  store (data, framesAccepted, &amp;jt9com_.d2[jt9com_.kin]);
 
-  unsigned lastSignalIndex (jt9com_.kin * sizeof (jt9com_.d2[0]) / m_bytesPerSignal);
+  unsigned lastSignalIndex (jt9com_.kin / m_framesPerSignal);
   jt9com_.kin += framesAccepted;
-  unsigned currentSignalIndex (jt9com_.kin * sizeof (jt9com_.d2[0]) / m_bytesPerSignal);
+  unsigned currentSignalIndex (jt9com_.kin / m_framesPerSignal);
 
   if (currentSignalIndex != lastSignalIndex &amp;&amp; m_monitoring)
     {
-      Q_EMIT bytesWritten (currentSignalIndex * m_bytesPerSignal);
+      Q_EMIT framesWritten (currentSignalIndex * m_framesPerSignal);
     }
 
   if (!secondInPeriod ())

Modified: branches/wsjtx/Detector.hpp
===================================================================
--- branches/wsjtx/Detector.hpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/Detector.hpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,48 +1,36 @@
 #ifndef DETECTOR_HPP__
 #define DETECTOR_HPP__
 
-#include &lt;stdint.h&gt;
+#include &quot;AudioDevice.hpp&quot;
 
-#include &lt;QIODevice&gt;
-
 //
 // output device that distributes data in predefined chunks via a signal
 //
 // the underlying device for this abstraction is just the buffer that
 // stores samples throughout a receiving period
 //
-class Detector : public QIODevice
+class Detector : public AudioDevice
 {
   Q_OBJECT;
 
   Q_PROPERTY (bool monitoring READ isMonitoring WRITE setMonitoring);
 
-private:
-  Q_DISABLE_COPY (Detector);
-
 public:
   //
   // if the data buffer were not global storage and fixed size then we
   // might want maximum size passed as constructor arguments
   //
-  Detector (unsigned frameRate, unsigned periodLengthInSeconds, unsigned bytesPerSignal, QObject * parent = 0);
+  Detector (unsigned frameRate, unsigned periodLengthInSeconds, unsigned framesPerSignal, QObject * parent = 0);
 
-  bool open ()
-  {
-    // we only support data consumption and want it as fast as possible
-    return QIODevice::open (QIODevice::WriteOnly | QIODevice::Unbuffered);
-  }
+  bool open (Channel channel = Mono) {return AudioDevice::open (QIODevice::WriteOnly, channel);}
 
-  bool isSequential () const
-  {
-    return true;
-  }
-
   bool isMonitoring () const {return m_monitoring;}
   void setMonitoring (bool newState) {m_monitoring = newState;}
 
   bool reset ();
 
+  Q_SIGNAL void framesWritten (qint64);
+
 protected:
   qint64 readData (char * /* data */, qint64 /* maxSize */)
   {
@@ -52,14 +40,12 @@
   qint64 writeData (char const * data, qint64 maxSize);
 
 private:
-  typedef qint16 frame_t;
-
   void clear ();		// discard buffer contents
   unsigned secondInPeriod () const;
 
   unsigned m_frameRate;
   unsigned m_period;
-  unsigned m_bytesPerSignal;
+  unsigned m_framesPerSignal;
   bool m_monitoring;
   bool m_starting;
 };

Modified: branches/wsjtx/Modulator.cpp
===================================================================
--- branches/wsjtx/Modulator.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/Modulator.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -10,6 +10,15 @@
 
 extern float gran();		// Noise generator (for tests only)
 
+// MUST be an integral factor of 2^16
+#define RAMP_INCREMENT 64
+
+#if defined (WSJT_SOFT_KEYING)
+# define SOFT_KEYING true
+#else
+# define SOFT_KEYING false
+#endif
+
 double const Modulator::m_twoPi = 2.0 * 3.141592653589793238462;
 
 //    float wpm=20.0;
@@ -18,7 +27,7 @@
 unsigned const Modulator::m_nspd = 2048 + 512; // 22.5 WPM
 
 Modulator::Modulator (unsigned frameRate, unsigned periodLengthInSeconds, QObject * parent)
-  : QIODevice (parent)
+  : AudioDevice (parent)
   , m_frameRate (frameRate)
   , m_period (periodLengthInSeconds)
   , m_framesSent (0)
@@ -30,11 +39,13 @@
   qsrand (QDateTime::currentMSecsSinceEpoch()); // Initialize random seed
 }
 
-void Modulator::send (unsigned symbolsLength, double framesPerSymbol, unsigned frequency, bool synchronize, double dBSNR)
+void Modulator::open (unsigned symbolsLength, double framesPerSymbol, unsigned frequency, Channel channel, bool synchronize, double dBSNR)
 {
   // Time according to this computer which becomes our base time
   qint64 ms0 = QDateTime::currentMSecsSinceEpoch() % 86400000;
 
+  qDebug () &lt;&lt; &quot;Modulator: Using soft keying for CW is &quot; &lt;&lt; SOFT_KEYING;;
+
   m_symbolsLength = symbolsLength;
 
   m_framesSent = 0;
@@ -67,16 +78,19 @@
     }
 
 //  qDebug () &lt;&lt; &quot;Modulator: starting at &quot; &lt;&lt; m_ic / m_frameRate &lt;&lt; &quot; sec, sending &quot; &lt;&lt; m_silentFrames &lt;&lt; &quot; silent frames&quot;;
+
+  AudioDevice::open (QIODevice::ReadOnly, channel);
   Q_EMIT stateChanged ((m_state = (synchronize &amp;&amp; m_silentFrames) ? Synchronizing : Active));
 }
 
 qint64 Modulator::readData (char * data, qint64 maxSize)
 {
-  Q_ASSERT (!(maxSize % static_cast&lt;qint64&gt; (sizeof (frame_t)))); // no torn frames
-  Q_ASSERT (!(reinterpret_cast&lt;size_t&gt; (data) % __alignof__ (frame_t))); // data is aligned as frame_t would be
+  Q_ASSERT (!(maxSize % static_cast&lt;qint64&gt; (bytesPerFrame ()))); // no torn frames
+  Q_ASSERT (isOpen ());
 
-  frame_t * frames (reinterpret_cast&lt;frame_t *&gt; (data));
-  qint64 numFrames (maxSize / sizeof (frame_t));
+  qint64 numFrames (maxSize / bytesPerFrame ());
+  qint16 * samples (reinterpret_cast&lt;qint16 *&gt; (data));
+  qint16 * end (samples + numFrames * (bytesPerFrame () / sizeof (qint16)));
 
 //  qDebug () &lt;&lt; &quot;Modulator: &quot; &lt;&lt; numFrames &lt;&lt; &quot; requested, m_ic = &quot; &lt;&lt; m_ic &lt;&lt; &quot;, tune mode is &quot; &lt;&lt; m_tuning;
 
@@ -86,19 +100,16 @@
       {
 	if (m_silentFrames)	// send silence up to first second
 	  {
-	    frame_t frame;
-	    for (unsigned c = 0; c &lt; NUM_CHANNELS; ++c)
+	    numFrames = qMin (m_silentFrames, numFrames);
+	    for ( ; samples != end; samples = load (0, samples)) // silence
 	      {
-		frame.channel[c] = 0; // silence
 	      }
-
-	    numFrames = qMin (m_silentFrames, numFrames);
-	    qFill (frames, frames + numFrames, frame);
 	    m_silentFrames -= numFrames;
-	    return numFrames * sizeof (frame_t);
+	    return numFrames * bytesPerFrame ();
 	  }
 
 	Q_EMIT stateChanged ((m_state = Active));
+	m_ramp = 0;		// prepare for CW wave shaping
       }
       // fall through
 
@@ -114,7 +125,8 @@
 	    unsigned const ic0 = m_symbolsLength * 4 * m_nsps;
 	    unsigned j (0);
 	    qint64 framesGenerated (0);
-	    for (unsigned i = 0; i &lt; numFrames; ++i)
+
+	    while (samples != end)
 	      {
 		m_phi += m_dphi;
 		if (m_phi &gt; m_twoPi)
@@ -122,28 +134,31 @@
 		    m_phi -= m_twoPi;
 		  }
 
-		frame_t frame;
-		for (unsigned c = 0; c &lt; NUM_CHANNELS; ++c)
-		  {
-		    frame.channel[c] = std::numeric_limits&lt;qint16&gt;::max () * qSin (m_phi);
-		  }
+		qint16 sample ((SOFT_KEYING ? qAbs (m_ramp - 1) : (m_ramp ? 32767 : 0)) * qSin (m_phi));
 
+		j = (m_ic - ic0 - 1) / m_nspd + 1;
+		bool l0 (icw[j] &amp;&amp; icw[j] &lt;= 1); // first element treated specially as it's a count
 		j = (m_ic - ic0) / m_nspd + 1;
-		if (j &lt; NUM_CW_SYMBOLS) // stop condition
+
+		if ((m_ramp != 0 &amp;&amp; m_ramp != std::numeric_limits&lt;qint16&gt;::min ()) || !!icw[j] != l0)
 		  {
-		    if (!icw[j])
+		    if (!!icw[j] != l0)
 		      {
-			for (unsigned c = 0; c &lt; NUM_CHANNELS; ++c)
-			  {
-			    frame.channel[c] = 0;
-			  }
+			Q_ASSERT (m_ramp == 0 || m_ramp == std::numeric_limits&lt;qint16&gt;::min ());
 		      }
+		    m_ramp += RAMP_INCREMENT; // ramp
+		  }
 
-		    frame = postProcessFrame (frame);
+		if (j &lt; NUM_CW_SYMBOLS) // stop condition
+		  {
+		    // if (!m_ramp &amp;&amp; !icw[j])
+		    //   {
+		    // 	sample = 0;
+		    //   }
 
-		    *frames++ = frame;
-		    ++framesGenerated;
+		    samples = load (postProcessSample (sample), samples);
 
+		    ++framesGenerated;
 		    ++m_ic;
 		  }
 	      }
@@ -154,7 +169,7 @@
 	      }
 
 	    m_framesSent += framesGenerated;
-	    return framesGenerated * sizeof (frame_t);
+	    return framesGenerated * bytesPerFrame ();
 	  }
 
 	double const baud (12000.0 / m_nsps);
@@ -186,16 +201,8 @@
 		m_amp = 0.0;
 	      }
 
-	    frame_t frame;
-	    for (unsigned c = 0; c &lt; NUM_CHANNELS; ++c)
-	      {
-		frame.channel[c] = m_amp * qSin (m_phi);
-	      }
+	    samples = load (postProcessSample (m_amp * qSin (m_phi)), samples);
 
-	    frame = postProcessFrame (frame);
-
-	    *frames++ = frame;
-
 	    ++m_ic;
 	  }
 
@@ -206,7 +213,7 @@
 		// no CW ID to send
 		Q_EMIT stateChanged ((m_state = Idle));
 		m_framesSent += numFrames;
-		return numFrames * sizeof (frame_t);
+		return numFrames * bytesPerFrame ();
 	      }
 
 	    m_phi = 0.0;
@@ -214,7 +221,7 @@
 
 	// done for this chunk - continue on next call
 	m_framesSent += numFrames;
-	return numFrames * sizeof (frame_t);
+	return numFrames * bytesPerFrame ();
       }
       Q_EMIT stateChanged ((m_state = Idle));
       // fall through
@@ -227,35 +234,24 @@
   return 0;
 }
 
-Modulator::frame_t Modulator::postProcessFrame (frame_t frame) const
+qint16 Modulator::postProcessSample (qint16 sample) const
 {
   if (m_muted)			// silent frame
     {
-      for (unsigned c = 0; c &lt; NUM_CHANNELS; ++c)
-	{
-	  frame.channel[c] = 0;
-	}
+      sample = 0;
     }
   else if (m_addNoise)
     {
-      qint32 f[NUM_CHANNELS];
-      for (unsigned c = 0; c &lt; NUM_CHANNELS; ++c)
+      qint32 s = m_fac * (gran () + sample * m_snr / 32768.0);
+      if (s &gt; std::numeric_limits&lt;qint16&gt;::max ())
 	{
-	  f[c] = m_fac * (gran () + frame.channel[c] * m_snr / 32768.0);
-	  if (f[c] &gt; std::numeric_limits&lt;qint16&gt;::max ())
-	    {
-	      f[c] = std::numeric_limits&lt;qint16&gt;::max ();
-	    }
-	  if (f[c] &lt; std::numeric_limits&lt;qint16&gt;::min ())
-	    {
-	      f[c] = std::numeric_limits&lt;qint16&gt;::min ();
-	    }
+	  s = std::numeric_limits&lt;qint16&gt;::max ();
 	}
-      
-      for (unsigned c = 0; c &lt; NUM_CHANNELS; ++c)
+      if (s &lt; std::numeric_limits&lt;qint16&gt;::min ())
 	{
-	  frame.channel[c] = f[c];
+	  s = std::numeric_limits&lt;qint16&gt;::min ();
 	}
+      sample = s;
     }
-  return frame;
+  return sample;
 }

Modified: branches/wsjtx/Modulator.hpp
===================================================================
--- branches/wsjtx/Modulator.hpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/Modulator.hpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,7 +1,7 @@
 #ifndef MODULATOR_HPP__
 #define MODULATOR_HPP__
 
-#include &lt;QIODevice&gt;
+#include &quot;AudioDevice.hpp&quot;
 
 #ifdef UNIX
 # define NUM_CHANNELS 2
@@ -16,7 +16,7 @@
 // Output can be muted while underway, preserving waveform timing when
 // transmission is resumed.
 //
-class Modulator : public QIODevice
+class Modulator : public AudioDevice
 {
   Q_OBJECT;
 
@@ -24,33 +24,18 @@
   Q_PROPERTY (bool tuning READ isTuning WRITE tune);
   Q_PROPERTY (bool muted READ isMuted WRITE mute);
 
-private:
-  Q_DISABLE_COPY (Modulator);
-
 public:
+  enum ModulatorState {Synchronizing, Active, Idle};
+
   Modulator (unsigned frameRate, unsigned periodLengthInSeconds, QObject * parent = 0);
 
-  bool open () {return QIODevice::open (QIODevice::ReadOnly | QIODevice::Unbuffered);}
+  Q_SLOT void open (unsigned symbolsLength, double framesPerSymbol, unsigned frequency, AudioDevice::Channel, bool synchronize = true, double dBSNR = 99.);
 
-  Q_SLOT void send (unsigned symbolsLength, double framesPerSymbol, unsigned frequency, bool synchronize = true, double dBSNR = 99.);
-
-  Q_SLOT void stop () {Q_EMIT stateChanged ((m_state = Idle));}
-
   bool isTuning () const {return m_tuning;}
-  Q_SLOT void tune (bool newState = true) {m_tuning = newState;}
-
   bool isMuted () const {return m_muted;}
-  Q_SLOT void mute (bool newState = true) {m_muted = newState;}
-
   unsigned frequency () const {return m_frequency;}
-  Q_SLOT void setFrequency (unsigned newFrequency) {m_frequency = newFrequency;}
-
-  enum ModulatorState {Synchronizing, Active, Idle};
-  Q_SIGNAL void stateChanged (ModulatorState);
   bool isActive () const {return m_state != Idle;}
 
-  bool isSequential () const {return true;}
-
 protected:
   qint64 readData (char * data, qint64 maxSize);
   qint64 writeData (char const * /* data */, qint64 /* maxSize */)
@@ -59,13 +44,23 @@
   }
 
 private:
-  typedef struct
+  /* private because we epect to run in a thread and don't want direct
+     C++ calls made, instead they must be invoked via the Qt
+     signal/slot mechanism which is thread safe */
+  Q_SLOT void close ()
   {
-    qint16 channel[NUM_CHANNELS];
-  } frame_t;
+    Q_EMIT stateChanged ((m_state = Idle));
+    AudioDevice::close ();
+  }
 
-  frame_t postProcessFrame (frame_t frame) const;
+  Q_SLOT void tune (bool newState = true) {m_tuning = newState;}
+  Q_SLOT void mute (bool newState = true) {m_muted = newState;}
+  Q_SLOT void setFrequency (unsigned newFrequency) {m_frequency = newFrequency;}
+  Q_SIGNAL void stateChanged (ModulatorState);
 
+private:
+  qint16 postProcessSample (qint16 sample) const;
+
   unsigned m_symbolsLength;
 
   static double const m_twoPi;
@@ -88,6 +83,7 @@
   unsigned m_ic;
   double m_fac;
   unsigned m_isym0;
+  qint16 m_ramp;
 };
 
 #endif

Modified: branches/wsjtx/PSKReporter.h
===================================================================
--- branches/wsjtx/PSKReporter.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/PSKReporter.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,127 +1,127 @@
-#pragma once
-
-// Main header file for the external interface to the PSK Reporter API
-// For documentation see <A HREF="http://psk.gladstonefamily.net/PSKReporterAPI.pdf">http://psk.gladstonefamily.net/PSKReporterAPI.pdf</A>
-
-/*
-
-Copyright (c) 2008 Philip Gladstone
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the &quot;Software&quot;), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-
- */
-
-
-#ifdef _DLL_OPTION_PSKREPORTER_EXPORT
-#define DllImportExport __declspec ( dllexport )
-#else
-#define DllImportExport __declspec ( dllimport )
-#endif
-
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif 
-
-#define REPORTER_SOURCE_MASK		0x07
-#define REPORTER_SOURCE_AUTOMATIC	0x01
-#define REPORTER_SOURCE_LOG			0x02
-#define REPORTER_SOURCE_MANUAL		0x03
-#define REPORTER_SOURCE_TENTATIVE	0x40 
-#define REPORTER_SOURCE_TEST		0x80 
-
-typedef struct {
-	wchar_t 	  hostname[256];
-	wchar_t 	  port[32];
-	bool	  	  connected;
-	unsigned int  callsigns_sent;
-	unsigned int  callsigns_buffered;
-	unsigned int  callsigns_discarded;
-	unsigned int  last_send_time;
-	unsigned int  next_send_time;
-	wchar_t	      last_callsign_queued[24];
-	unsigned int  bytes_sent;
-	unsigned int  bytes_sent_total;
-	unsigned int  packets_sent;
-	unsigned int  packets_sent_total;
-} REPORTER_STATISTICS;
-
-
-
-
-unsigned long DllImportExport __cdecl ReporterInitialize(
-	const wchar_t *hostname,
-	const wchar_t *port
-);
-
-unsigned long DllImportExport __cdecl ReporterSeenCallsign(
-	const wchar_t *remoteInformation,
-	const wchar_t *localInformation,
-	unsigned long flags
-);
-
-unsigned long DllImportExport __cdecl ReporterTickle(
-);
-
-unsigned long DllImportExport __cdecl ReporterGetInformation(
-	wchar_t *buffer,
-	unsigned long maxlen
-);
-
-unsigned long DllImportExport __cdecl ReporterGetStatistics(
-	REPORTER_STATISTICS *buffer,
-	unsigned long maxlen
-);
-
-unsigned long DllImportExport __cdecl ReporterUninitialize(
-);
-
-
-unsigned long DllImportExport __stdcall ReporterInitializeSTD(
-	const char *hostname,
-	const char *port
-);
-
-unsigned long DllImportExport __stdcall ReporterSeenCallsignSTD(
-	const char *remoteInformation,
-	const char *localInformation,
-	unsigned long flags
-);
-
-unsigned long DllImportExport __stdcall ReporterTickleSTD(
-);
-
-unsigned long DllImportExport __stdcall ReporterGetInformationSTD(
-	char *buffer,
-	unsigned long maxlen
-);
-
-unsigned long DllImportExport __stdcall ReporterGetStatisticsSTD(
-	REPORTER_STATISTICS *buffer,
-	unsigned long maxlen
-);
-
-unsigned long DllImportExport __stdcall ReporterUninitializeSTD(
-);
-
-#ifdef __cplusplus
-}
-#endif 
-
-
+#pragma once
+
+// Main header file for the external interface to the PSK Reporter API
+// For documentation see <A HREF="http://psk.gladstonefamily.net/PSKReporterAPI.pdf">http://psk.gladstonefamily.net/PSKReporterAPI.pdf</A>
+
+/*
+
+Copyright (c) 2008 Philip Gladstone
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the &quot;Software&quot;), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+ */
+
+
+#ifdef _DLL_OPTION_PSKREPORTER_EXPORT
+#define DllImportExport __declspec ( dllexport )
+#else
+#define DllImportExport __declspec ( dllimport )
+#endif
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif 
+
+#define REPORTER_SOURCE_MASK		0x07
+#define REPORTER_SOURCE_AUTOMATIC	0x01
+#define REPORTER_SOURCE_LOG			0x02
+#define REPORTER_SOURCE_MANUAL		0x03
+#define REPORTER_SOURCE_TENTATIVE	0x40 
+#define REPORTER_SOURCE_TEST		0x80 
+
+typedef struct {
+	wchar_t 	  hostname[256];
+	wchar_t 	  port[32];
+	bool	  	  connected;
+	unsigned int  callsigns_sent;
+	unsigned int  callsigns_buffered;
+	unsigned int  callsigns_discarded;
+	unsigned int  last_send_time;
+	unsigned int  next_send_time;
+	wchar_t	      last_callsign_queued[24];
+	unsigned int  bytes_sent;
+	unsigned int  bytes_sent_total;
+	unsigned int  packets_sent;
+	unsigned int  packets_sent_total;
+} REPORTER_STATISTICS;
+
+
+
+
+unsigned long DllImportExport __cdecl ReporterInitialize(
+	const wchar_t *hostname,
+	const wchar_t *port
+);
+
+unsigned long DllImportExport __cdecl ReporterSeenCallsign(
+	const wchar_t *remoteInformation,
+	const wchar_t *localInformation,
+	unsigned long flags
+);
+
+unsigned long DllImportExport __cdecl ReporterTickle(
+);
+
+unsigned long DllImportExport __cdecl ReporterGetInformation(
+	wchar_t *buffer,
+	unsigned long maxlen
+);
+
+unsigned long DllImportExport __cdecl ReporterGetStatistics(
+	REPORTER_STATISTICS *buffer,
+	unsigned long maxlen
+);
+
+unsigned long DllImportExport __cdecl ReporterUninitialize(
+);
+
+
+unsigned long DllImportExport __stdcall ReporterInitializeSTD(
+	const char *hostname,
+	const char *port
+);
+
+unsigned long DllImportExport __stdcall ReporterSeenCallsignSTD(
+	const char *remoteInformation,
+	const char *localInformation,
+	unsigned long flags
+);
+
+unsigned long DllImportExport __stdcall ReporterTickleSTD(
+);
+
+unsigned long DllImportExport __stdcall ReporterGetInformationSTD(
+	char *buffer,
+	unsigned long maxlen
+);
+
+unsigned long DllImportExport __stdcall ReporterGetStatisticsSTD(
+	REPORTER_STATISTICS *buffer,
+	unsigned long maxlen
+);
+
+unsigned long DllImportExport __stdcall ReporterUninitializeSTD(
+);
+
+#ifdef __cplusplus
+}
+#endif 
+
+

Modified: branches/wsjtx/devsetup.cpp
===================================================================
--- branches/wsjtx/devsetup.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/devsetup.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,13 +1,17 @@
 #include &quot;devsetup.h&quot;
 
+#include &quot;ui_devsetup.h&quot;
+
+#include &lt;iterator&gt;
+#include &lt;algorithm&gt;
+#include &lt;tr1/functional&gt;
+
 #include &lt;QDebug&gt;
 #include &lt;QSettings&gt;
 #include &lt;QAudioDeviceInfo&gt;
 #include &lt;QAudioInput&gt;
 #include &lt;QMap&gt;
 
-#define MAXDEVICES 100
-
 extern double dFreq[16];
 qint32  g2_iptt;
 qint32  g2_COMportOpen;
@@ -15,10 +19,11 @@
 //----------------------------------------------------------- DevSetup()
 DevSetup::DevSetup(QWidget *parent)
   : QDialog(parent)
+  , ui (new Ui::DevSetup)
   , m_audioInputDevices (QAudioDeviceInfo::availableDevices (QAudio::AudioInput))
   , m_audioOutputDevices (QAudioDeviceInfo::availableDevices (QAudio::AudioOutput))
 {
-  ui.setupUi(this);	                              //setup the dialog form
+  ui-&gt;setupUi(this);	                              //setup the dialog form
   m_restartSoundIn=false;
   m_restartSoundOut=false;
   m_firstCall=true;
@@ -42,182 +47,165 @@
   settings.endGroup();
 
   //
-  // load combo boxes with setup choices
+  // load combo boxes with audio setup choices
   //
+  loadAudioDevices (m_audioInputDevices, ui-&gt;comboBoxSndIn);
+  loadAudioDevices (m_audioOutputDevices, ui-&gt;comboBoxSndOut);
+
   {
-    int currentIndex = -1;
-    int defaultIndex = 0;
-    for (AudioDevices::const_iterator p = m_audioInputDevices.begin (); p != m_audioInputDevices.end (); ++p)
-      {
-	ui.comboBoxSndIn-&gt;addItem (p-&gt;deviceName ());
-	if (*p == m_audioInputDevice)
-	  {
-	    currentIndex = p - m_audioInputDevices.begin ();
-	  }
-	else if (*p == QAudioDeviceInfo::defaultInputDevice ())
-	  {
-	    defaultIndex = p - m_audioInputDevices.begin ();
-	  }
-      }
-    ui.comboBoxSndIn-&gt;setCurrentIndex (currentIndex != -1 ? currentIndex : defaultIndex);
-  }
+    using namespace std::tr1;
+    using namespace std::tr1::placeholders;
 
-  {
-    int currentIndex = -1;
-    int defaultIndex = 0;
-    for (AudioDevices::const_iterator p = m_audioOutputDevices.begin (); p != m_audioOutputDevices.end (); ++p)
-      {
-	ui.comboBoxSndOut-&gt;addItem (p-&gt;deviceName ());
-	if (*p == m_audioOutputDevice)
-	  {
-	    currentIndex = p - m_audioOutputDevices.begin ();
-	  }
-	else if (*p == QAudioDeviceInfo::defaultOutputDevice ())
-	  {
-	    defaultIndex = p - m_audioOutputDevices.begin ();
-	  }
-      }
-    ui.comboBoxSndOut-&gt;setCurrentIndex (currentIndex != -1 ? currentIndex : defaultIndex);
+    function&lt;void (int)&gt; cb (bind (&amp;DevSetup::updateAudioChannels, this, ui-&gt;comboBoxSndIn, _1, ui-&gt;audioInputChannel, false));
+    connect (ui-&gt;comboBoxSndIn, static_cast&lt;void (QComboBox::*)(int)&gt; (&amp;QComboBox::currentIndexChanged), cb);
+    cb = bind (&amp;DevSetup::updateAudioChannels, this, ui-&gt;comboBoxSndOut, _1, ui-&gt;audioOutputChannel, true);
+    connect (ui-&gt;comboBoxSndOut, static_cast&lt;void (QComboBox::*)(int)&gt; (&amp;QComboBox::currentIndexChanged), cb);
+
+    updateAudioChannels (ui-&gt;comboBoxSndIn, ui-&gt;comboBoxSndIn-&gt;currentIndex (), ui-&gt;audioInputChannel, false);
+    updateAudioChannels (ui-&gt;comboBoxSndOut, ui-&gt;comboBoxSndOut-&gt;currentIndex (), ui-&gt;audioOutputChannel, true);
+
+    ui-&gt;audioInputChannel-&gt;setCurrentIndex (m_audioInputChannel);
+    ui-&gt;audioOutputChannel-&gt;setCurrentIndex (m_audioOutputChannel);
   }
 
   enumerateRigs ();
 
-  QPalette pal(ui.myCallEntry-&gt;palette());
+  QPalette pal(ui-&gt;myCallEntry-&gt;palette());
   if(m_myCall==&quot;&quot;) {
     pal.setColor(QPalette::Base,&quot;#ffccff&quot;);
   } else {
     pal.setColor(QPalette::Base,Qt::white);
   }
-  ui.myCallEntry-&gt;setPalette(pal);
-  ui.myGridEntry-&gt;setPalette(pal);
-  ui.myCallEntry-&gt;setText(m_myCall);
-  ui.myGridEntry-&gt;setText(m_myGrid);
+  ui-&gt;myCallEntry-&gt;setPalette(pal);
+  ui-&gt;myGridEntry-&gt;setPalette(pal);
+  ui-&gt;myCallEntry-&gt;setText(m_myCall);
+  ui-&gt;myGridEntry-&gt;setText(m_myGrid);
 
-  ui.idIntSpinBox-&gt;setValue(m_idInt);
-  ui.pttMethodComboBox-&gt;setCurrentIndex(m_pttMethodIndex);
-  ui.saveDirEntry-&gt;setText(m_saveDir);
-  ui.cbID73-&gt;setChecked(m_After73);
-  ui.cbPSKReporter-&gt;setChecked(m_pskReporter);
-  ui.cbSplit-&gt;setChecked(m_bSplit and m_catEnabled);
-  ui.cbXIT-&gt;setChecked(m_bXIT);
-  ui.cbXIT-&gt;setVisible(false);
+  ui-&gt;idIntSpinBox-&gt;setValue(m_idInt);
+  ui-&gt;pttMethodComboBox-&gt;setCurrentIndex(m_pttMethodIndex);
+  ui-&gt;saveDirEntry-&gt;setText(m_saveDir);
+  ui-&gt;cbID73-&gt;setChecked(m_After73);
+  ui-&gt;cbPSKReporter-&gt;setChecked(m_pskReporter);
+  ui-&gt;cbSplit-&gt;setChecked(m_bSplit and m_catEnabled);
+  ui-&gt;cbXIT-&gt;setChecked(m_bXIT);
+  ui-&gt;cbXIT-&gt;setVisible(false);
 
   enableWidgets();
 
-  ui.catPortComboBox-&gt;setCurrentIndex(m_catPortIndex);
-  ui.serialRateComboBox-&gt;setCurrentIndex(m_serialRateIndex);
-  ui.dataBitsComboBox-&gt;setCurrentIndex(m_dataBitsIndex);
-  ui.stopBitsComboBox-&gt;setCurrentIndex(m_stopBitsIndex);
-  ui.handshakeComboBox-&gt;setCurrentIndex(m_handshakeIndex);
-  ui.rbData-&gt;setChecked(m_pttData);
-  ui.pollSpinBox-&gt;setValue(m_poll);
+  ui-&gt;catPortComboBox-&gt;setCurrentIndex(m_catPortIndex);
+  ui-&gt;serialRateComboBox-&gt;setCurrentIndex(m_serialRateIndex);
+  ui-&gt;dataBitsComboBox-&gt;setCurrentIndex(m_dataBitsIndex);
+  ui-&gt;stopBitsComboBox-&gt;setCurrentIndex(m_stopBitsIndex);
+  ui-&gt;handshakeComboBox-&gt;setCurrentIndex(m_handshakeIndex);
+  ui-&gt;rbData-&gt;setChecked(m_pttData);
+  ui-&gt;pollSpinBox-&gt;setValue(m_poll);
 
   // PY2SDR -- Per OS serial port names
   m_tmp=m_pttPort;
-  ui.pttComboBox-&gt;clear();
-  ui.catPortComboBox-&gt;clear();
-  ui.pttComboBox-&gt;addItem(&quot;None&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;None&quot;);
+  ui-&gt;pttComboBox-&gt;clear();
+  ui-&gt;catPortComboBox-&gt;clear();
+  ui-&gt;pttComboBox-&gt;addItem(&quot;None&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;None&quot;);
 #ifdef WIN32
   for ( int i = 1; i &lt; 100; i++ ) {
-    ui.pttComboBox-&gt;addItem(&quot;COM&quot; + QString::number(i));
-    ui.catPortComboBox-&gt;addItem(&quot;COM&quot; + QString::number(i));
+    ui-&gt;pttComboBox-&gt;addItem(&quot;COM&quot; + QString::number(i));
+    ui-&gt;catPortComboBox-&gt;addItem(&quot;COM&quot; + QString::number(i));
   }
-  ui.pttComboBox-&gt;addItem(&quot;USB&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;USB&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;USB&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;USB&quot;);
 #else
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyS0&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyS1&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyS2&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyS3&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyS4&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyS5&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyS6&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyS7&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyUSB0&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyUSB1&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyUSB2&quot;);
-  ui.catPortComboBox-&gt;addItem(&quot;/dev/ttyUSB3&quot;);
-  ui.catPortComboBox-&gt;addItem(catPortDriver);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyS0&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyS1&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyS2&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyS3&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyS4&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyS5&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyS6&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyS7&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyUSB0&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyUSB1&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyUSB2&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(&quot;/dev/ttyUSB3&quot;);
+  ui-&gt;catPortComboBox-&gt;addItem(catPortDriver);
 
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyS0&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyS1&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyS2&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyS3&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyS4&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyS5&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyS6&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyS7&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyUSB0&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyUSB1&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyUSB2&quot;);
-  ui.pttComboBox-&gt;addItem(&quot;/dev/ttyUSB3&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyS0&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyS1&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyS2&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyS3&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyS4&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyS5&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyS6&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyS7&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyUSB0&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyUSB1&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyUSB2&quot;);
+  ui-&gt;pttComboBox-&gt;addItem(&quot;/dev/ttyUSB3&quot;);
 #endif
-  ui.pttComboBox-&gt;setCurrentIndex(m_tmp);
-  ui.catPortComboBox-&gt;setCurrentIndex(m_catPortIndex);
+  ui-&gt;pttComboBox-&gt;setCurrentIndex(m_tmp);
+  ui-&gt;catPortComboBox-&gt;setCurrentIndex(m_catPortIndex);
 
   int n=m_macro.length();
-  if(n&gt;=1) ui.macro1-&gt;setText(m_macro[0].toUpper());
-  if(n&gt;=2) ui.macro2-&gt;setText(m_macro[1].toUpper());
-  if(n&gt;=3) ui.macro3-&gt;setText(m_macro[2].toUpper());
-  if(n&gt;=4) ui.macro4-&gt;setText(m_macro[3].toUpper());
-  if(n&gt;=5) ui.macro5-&gt;setText(m_macro[4].toUpper());
-  if(n&gt;=6) ui.macro6-&gt;setText(m_macro[5].toUpper());
-  if(n&gt;=7) ui.macro7-&gt;setText(m_macro[6].toUpper());
-  if(n&gt;=8) ui.macro8-&gt;setText(m_macro[7].toUpper());
-  if(n&gt;=8) ui.macro9-&gt;setText(m_macro[8].toUpper());
-  if(n&gt;=10) ui.macro10-&gt;setText(m_macro[9].toUpper());
+  if(n&gt;=1) ui-&gt;macro1-&gt;setText(m_macro[0].toUpper());
+  if(n&gt;=2) ui-&gt;macro2-&gt;setText(m_macro[1].toUpper());
+  if(n&gt;=3) ui-&gt;macro3-&gt;setText(m_macro[2].toUpper());
+  if(n&gt;=4) ui-&gt;macro4-&gt;setText(m_macro[3].toUpper());
+  if(n&gt;=5) ui-&gt;macro5-&gt;setText(m_macro[4].toUpper());
+  if(n&gt;=6) ui-&gt;macro6-&gt;setText(m_macro[5].toUpper());
+  if(n&gt;=7) ui-&gt;macro7-&gt;setText(m_macro[6].toUpper());
+  if(n&gt;=8) ui-&gt;macro8-&gt;setText(m_macro[7].toUpper());
+  if(n&gt;=8) ui-&gt;macro9-&gt;setText(m_macro[8].toUpper());
+  if(n&gt;=10) ui-&gt;macro10-&gt;setText(m_macro[9].toUpper());
 
-  ui.f1-&gt;setText(m_dFreq[0]);
-  ui.f2-&gt;setText(m_dFreq[1]);
-  ui.f3-&gt;setText(m_dFreq[2]);
-  ui.f4-&gt;setText(m_dFreq[3]);
-  ui.f5-&gt;setText(m_dFreq[4]);
-  ui.f6-&gt;setText(m_dFreq[5]);
-  ui.f7-&gt;setText(m_dFreq[6]);
-  ui.f8-&gt;setText(m_dFreq[7]);
-  ui.f9-&gt;setText(m_dFreq[8]);
-  ui.f10-&gt;setText(m_dFreq[9]);
-  ui.f11-&gt;setText(m_dFreq[10]);
-  ui.f12-&gt;setText(m_dFreq[11]);
-  ui.f13-&gt;setText(m_dFreq[12]);
-  ui.f14-&gt;setText(m_dFreq[13]);
-  ui.f15-&gt;setText(m_dFreq[14]);
-  ui.f16-&gt;setText(m_dFreq[15]);
+  ui-&gt;f1-&gt;setText(m_dFreq[0]);
+  ui-&gt;f2-&gt;setText(m_dFreq[1]);
+  ui-&gt;f3-&gt;setText(m_dFreq[2]);
+  ui-&gt;f4-&gt;setText(m_dFreq[3]);
+  ui-&gt;f5-&gt;setText(m_dFreq[4]);
+  ui-&gt;f6-&gt;setText(m_dFreq[5]);
+  ui-&gt;f7-&gt;setText(m_dFreq[6]);
+  ui-&gt;f8-&gt;setText(m_dFreq[7]);
+  ui-&gt;f9-&gt;setText(m_dFreq[8]);
+  ui-&gt;f10-&gt;setText(m_dFreq[9]);
+  ui-&gt;f11-&gt;setText(m_dFreq[10]);
+  ui-&gt;f12-&gt;setText(m_dFreq[11]);
+  ui-&gt;f13-&gt;setText(m_dFreq[12]);
+  ui-&gt;f14-&gt;setText(m_dFreq[13]);
+  ui-&gt;f15-&gt;setText(m_dFreq[14]);
+  ui-&gt;f16-&gt;setText(m_dFreq[15]);
 
-  ui.AntDescription1-&gt;setText(m_antDescription[0]);
-  ui.AntDescription2-&gt;setText(m_antDescription[1]);
-  ui.AntDescription3-&gt;setText(m_antDescription[2]);
-  ui.AntDescription4-&gt;setText(m_antDescription[3]);
-  ui.AntDescription5-&gt;setText(m_antDescription[4]);
-  ui.AntDescription6-&gt;setText(m_antDescription[5]);
-  ui.AntDescription7-&gt;setText(m_antDescription[6]);
-  ui.AntDescription8-&gt;setText(m_antDescription[7]);
-  ui.AntDescription9-&gt;setText(m_antDescription[8]);
-  ui.AntDescription10-&gt;setText(m_antDescription[9]);
-  ui.AntDescription11-&gt;setText(m_antDescription[10]);
-  ui.AntDescription12-&gt;setText(m_antDescription[11]);
-  ui.AntDescription13-&gt;setText(m_antDescription[12]);
-  ui.AntDescription14-&gt;setText(m_antDescription[13]);
-  ui.AntDescription15-&gt;setText(m_antDescription[14]);
-  ui.AntDescription16-&gt;setText(m_antDescription[15]);
+  ui-&gt;AntDescription1-&gt;setText(m_antDescription[0]);
+  ui-&gt;AntDescription2-&gt;setText(m_antDescription[1]);
+  ui-&gt;AntDescription3-&gt;setText(m_antDescription[2]);
+  ui-&gt;AntDescription4-&gt;setText(m_antDescription[3]);
+  ui-&gt;AntDescription5-&gt;setText(m_antDescription[4]);
+  ui-&gt;AntDescription6-&gt;setText(m_antDescription[5]);
+  ui-&gt;AntDescription7-&gt;setText(m_antDescription[6]);
+  ui-&gt;AntDescription8-&gt;setText(m_antDescription[7]);
+  ui-&gt;AntDescription9-&gt;setText(m_antDescription[8]);
+  ui-&gt;AntDescription10-&gt;setText(m_antDescription[9]);
+  ui-&gt;AntDescription11-&gt;setText(m_antDescription[10]);
+  ui-&gt;AntDescription12-&gt;setText(m_antDescription[11]);
+  ui-&gt;AntDescription13-&gt;setText(m_antDescription[12]);
+  ui-&gt;AntDescription14-&gt;setText(m_antDescription[13]);
+  ui-&gt;AntDescription15-&gt;setText(m_antDescription[14]);
+  ui-&gt;AntDescription16-&gt;setText(m_antDescription[15]);
 
-  ui.Band1-&gt;setText(m_bandDescription[0]);
-  ui.Band2-&gt;setText(m_bandDescription[1]);
-  ui.Band3-&gt;setText(m_bandDescription[2]);
-  ui.Band4-&gt;setText(m_bandDescription[3]);
-  ui.Band5-&gt;setText(m_bandDescription[4]);
-  ui.Band6-&gt;setText(m_bandDescription[5]);
-  ui.Band7-&gt;setText(m_bandDescription[6]);
-  ui.Band8-&gt;setText(m_bandDescription[7]);
-  ui.Band9-&gt;setText(m_bandDescription[8]);
-  ui.Band10-&gt;setText(m_bandDescription[9]);
-  ui.Band11-&gt;setText(m_bandDescription[10]);
-  ui.Band12-&gt;setText(m_bandDescription[11]);
-  ui.Band13-&gt;setText(m_bandDescription[12]);
-  ui.Band14-&gt;setText(m_bandDescription[13]);
-  ui.Band15-&gt;setText(m_bandDescription[14]);
-  ui.Band16-&gt;setText(m_bandDescription[15]);
+  ui-&gt;Band1-&gt;setText(m_bandDescription[0]);
+  ui-&gt;Band2-&gt;setText(m_bandDescription[1]);
+  ui-&gt;Band3-&gt;setText(m_bandDescription[2]);
+  ui-&gt;Band4-&gt;setText(m_bandDescription[3]);
+  ui-&gt;Band5-&gt;setText(m_bandDescription[4]);
+  ui-&gt;Band6-&gt;setText(m_bandDescription[5]);
+  ui-&gt;Band7-&gt;setText(m_bandDescription[6]);
+  ui-&gt;Band8-&gt;setText(m_bandDescription[7]);
+  ui-&gt;Band9-&gt;setText(m_bandDescription[8]);
+  ui-&gt;Band10-&gt;setText(m_bandDescription[9]);
+  ui-&gt;Band11-&gt;setText(m_bandDescription[10]);
+  ui-&gt;Band12-&gt;setText(m_bandDescription[11]);
+  ui-&gt;Band13-&gt;setText(m_bandDescription[12]);
+  ui-&gt;Band14-&gt;setText(m_bandDescription[13]);
+  ui-&gt;Band15-&gt;setText(m_bandDescription[14]);
+  ui-&gt;Band16-&gt;setText(m_bandDescription[15]);
 
 }
 
@@ -228,90 +216,106 @@
   // Check to see whether SoundInThread must be restarted,
   // and save user parameters.
 
-  if (m_audioInputDevice != m_audioInputDevices[ui.comboBoxSndIn-&gt;currentIndex ()])
+  m_restartSoundIn = m_restartSoundOut = false;
+
+  if (m_audioInputDevice != m_audioInputDevices[ui-&gt;comboBoxSndIn-&gt;currentIndex ()])
     {
-      m_audioInputDevice = m_audioInputDevices[ui.comboBoxSndIn-&gt;currentIndex ()];
+      m_audioInputDevice = m_audioInputDevices[ui-&gt;comboBoxSndIn-&gt;currentIndex ()];
       m_restartSoundIn = true;
     }
 
-  if (m_audioOutputDevice != m_audioOutputDevices[ui.comboBoxSndOut-&gt;currentIndex ()])
+  if (m_audioOutputDevice != m_audioOutputDevices[ui-&gt;comboBoxSndOut-&gt;currentIndex ()])
     {
-      m_audioOutputDevice = m_audioOutputDevices[ui.comboBoxSndOut-&gt;currentIndex ()];
+      m_audioOutputDevice = m_audioOutputDevices[ui-&gt;comboBoxSndOut-&gt;currentIndex ()];
       m_restartSoundOut = true;
     }
 
-  m_myCall=ui.myCallEntry-&gt;text();
-  m_myGrid=ui.myGridEntry-&gt;text();
-  m_idInt=ui.idIntSpinBox-&gt;value();
-  m_pttMethodIndex=ui.pttMethodComboBox-&gt;currentIndex();
-  m_pttPort=ui.pttComboBox-&gt;currentIndex();
-  m_saveDir=ui.saveDirEntry-&gt;text();
+  if (m_audioInputChannel != static_cast&lt;AudioDevice::Channel&gt; (ui-&gt;audioInputChannel-&gt;currentIndex ()))
+    {
+      m_audioInputChannel = static_cast&lt;AudioDevice::Channel&gt; (ui-&gt;audioInputChannel-&gt;currentIndex ());
+      m_restartSoundIn = true;
+    }
+  Q_ASSERT (m_audioInputChannel &lt;= AudioDevice::Right);
 
+  if (m_audioOutputChannel != static_cast&lt;AudioDevice::Channel&gt; (ui-&gt;audioOutputChannel-&gt;currentIndex ()))
+    {
+      m_audioOutputChannel = static_cast&lt;AudioDevice::Channel&gt; (ui-&gt;audioOutputChannel-&gt;currentIndex ());
+      m_restartSoundOut = true;
+    }
+  Q_ASSERT (m_audioOutputChannel &lt;= AudioDevice::Both);
+
+  m_myCall=ui-&gt;myCallEntry-&gt;text();
+  m_myGrid=ui-&gt;myGridEntry-&gt;text();
+  m_idInt=ui-&gt;idIntSpinBox-&gt;value();
+  m_pttMethodIndex=ui-&gt;pttMethodComboBox-&gt;currentIndex();
+  m_pttPort=ui-&gt;pttComboBox-&gt;currentIndex();
+  m_saveDir=ui-&gt;saveDirEntry-&gt;text();
+
   m_macro.clear();
-  m_macro.append(ui.macro1-&gt;text());
-  m_macro.append(ui.macro2-&gt;text());
-  m_macro.append(ui.macro3-&gt;text());
-  m_macro.append(ui.macro4-&gt;text());
-  m_macro.append(ui.macro5-&gt;text());
-  m_macro.append(ui.macro6-&gt;text());
-  m_macro.append(ui.macro7-&gt;text());
-  m_macro.append(ui.macro8-&gt;text());
-  m_macro.append(ui.macro9-&gt;text());
-  m_macro.append(ui.macro10-&gt;text());
+  m_macro.append(ui-&gt;macro1-&gt;text());
+  m_macro.append(ui-&gt;macro2-&gt;text());
+  m_macro.append(ui-&gt;macro3-&gt;text());
+  m_macro.append(ui-&gt;macro4-&gt;text());
+  m_macro.append(ui-&gt;macro5-&gt;text());
+  m_macro.append(ui-&gt;macro6-&gt;text());
+  m_macro.append(ui-&gt;macro7-&gt;text());
+  m_macro.append(ui-&gt;macro8-&gt;text());
+  m_macro.append(ui-&gt;macro9-&gt;text());
+  m_macro.append(ui-&gt;macro10-&gt;text());
 
   m_dFreq.clear();
-  m_dFreq.append(ui.f1-&gt;text());
-  m_dFreq.append(ui.f2-&gt;text());
-  m_dFreq.append(ui.f3-&gt;text());
-  m_dFreq.append(ui.f4-&gt;text());
-  m_dFreq.append(ui.f5-&gt;text());
-  m_dFreq.append(ui.f6-&gt;text());
-  m_dFreq.append(ui.f7-&gt;text());
-  m_dFreq.append(ui.f8-&gt;text());
-  m_dFreq.append(ui.f9-&gt;text());
-  m_dFreq.append(ui.f10-&gt;text());
-  m_dFreq.append(ui.f11-&gt;text());
-  m_dFreq.append(ui.f12-&gt;text());
-  m_dFreq.append(ui.f13-&gt;text());
-  m_dFreq.append(ui.f14-&gt;text());
-  m_dFreq.append(ui.f15-&gt;text());
-  m_dFreq.append(ui.f16-&gt;text());
+  m_dFreq.append(ui-&gt;f1-&gt;text());
+  m_dFreq.append(ui-&gt;f2-&gt;text());
+  m_dFreq.append(ui-&gt;f3-&gt;text());
+  m_dFreq.append(ui-&gt;f4-&gt;text());
+  m_dFreq.append(ui-&gt;f5-&gt;text());
+  m_dFreq.append(ui-&gt;f6-&gt;text());
+  m_dFreq.append(ui-&gt;f7-&gt;text());
+  m_dFreq.append(ui-&gt;f8-&gt;text());
+  m_dFreq.append(ui-&gt;f9-&gt;text());
+  m_dFreq.append(ui-&gt;f10-&gt;text());
+  m_dFreq.append(ui-&gt;f11-&gt;text());
+  m_dFreq.append(ui-&gt;f12-&gt;text());
+  m_dFreq.append(ui-&gt;f13-&gt;text());
+  m_dFreq.append(ui-&gt;f14-&gt;text());
+  m_dFreq.append(ui-&gt;f15-&gt;text());
+  m_dFreq.append(ui-&gt;f16-&gt;text());
 
   m_antDescription.clear();
-  m_antDescription.append(ui.AntDescription1-&gt;text());
-  m_antDescription.append(ui.AntDescription2-&gt;text());
-  m_antDescription.append(ui.AntDescription3-&gt;text());
-  m_antDescription.append(ui.AntDescription4-&gt;text());
-  m_antDescription.append(ui.AntDescription5-&gt;text());
-  m_antDescription.append(ui.AntDescription6-&gt;text());
-  m_antDescription.append(ui.AntDescription7-&gt;text());
-  m_antDescription.append(ui.AntDescription8-&gt;text());
-  m_antDescription.append(ui.AntDescription9-&gt;text());
-  m_antDescription.append(ui.AntDescription10-&gt;text());
-  m_antDescription.append(ui.AntDescription11-&gt;text());
-  m_antDescription.append(ui.AntDescription12-&gt;text());
-  m_antDescription.append(ui.AntDescription13-&gt;text());
-  m_antDescription.append(ui.AntDescription14-&gt;text());
-  m_antDescription.append(ui.AntDescription15-&gt;text());
-  m_antDescription.append(ui.AntDescription16-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription1-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription2-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription3-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription4-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription5-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription6-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription7-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription8-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription9-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription10-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription11-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription12-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription13-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription14-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription15-&gt;text());
+  m_antDescription.append(ui-&gt;AntDescription16-&gt;text());
 
   m_bandDescription.clear();
-  m_bandDescription.append(ui.Band1-&gt;text());
-  m_bandDescription.append(ui.Band2-&gt;text());
-  m_bandDescription.append(ui.Band3-&gt;text());
-  m_bandDescription.append(ui.Band4-&gt;text());
-  m_bandDescription.append(ui.Band5-&gt;text());
-  m_bandDescription.append(ui.Band6-&gt;text());
-  m_bandDescription.append(ui.Band7-&gt;text());
-  m_bandDescription.append(ui.Band8-&gt;text());
-  m_bandDescription.append(ui.Band9-&gt;text());
-  m_bandDescription.append(ui.Band10-&gt;text());
-  m_bandDescription.append(ui.Band11-&gt;text());
-  m_bandDescription.append(ui.Band12-&gt;text());
-  m_bandDescription.append(ui.Band13-&gt;text());
-  m_bandDescription.append(ui.Band14-&gt;text());
-  m_bandDescription.append(ui.Band15-&gt;text());
-  m_bandDescription.append(ui.Band16-&gt;text());
+  m_bandDescription.append(ui-&gt;Band1-&gt;text());
+  m_bandDescription.append(ui-&gt;Band2-&gt;text());
+  m_bandDescription.append(ui-&gt;Band3-&gt;text());
+  m_bandDescription.append(ui-&gt;Band4-&gt;text());
+  m_bandDescription.append(ui-&gt;Band5-&gt;text());
+  m_bandDescription.append(ui-&gt;Band6-&gt;text());
+  m_bandDescription.append(ui-&gt;Band7-&gt;text());
+  m_bandDescription.append(ui-&gt;Band8-&gt;text());
+  m_bandDescription.append(ui-&gt;Band9-&gt;text());
+  m_bandDescription.append(ui-&gt;Band10-&gt;text());
+  m_bandDescription.append(ui-&gt;Band11-&gt;text());
+  m_bandDescription.append(ui-&gt;Band12-&gt;text());
+  m_bandDescription.append(ui-&gt;Band13-&gt;text());
+  m_bandDescription.append(ui-&gt;Band14-&gt;text());
+  m_bandDescription.append(ui-&gt;Band15-&gt;text());
+  m_bandDescription.append(ui-&gt;Band16-&gt;text());
 
 
   if(m_bRigOpen) {
@@ -338,39 +342,39 @@
 
 void DevSetup::on_myCallEntry_editingFinished()
 {
-  QString t=ui.myCallEntry-&gt;text();
-  ui.myCallEntry-&gt;setText(t.toUpper());
+  QString t=ui-&gt;myCallEntry-&gt;text();
+  ui-&gt;myCallEntry-&gt;setText(t.toUpper());
 }
 
 void DevSetup::on_myGridEntry_editingFinished()
 {
-  QString t=ui.myGridEntry-&gt;text();
+  QString t=ui-&gt;myGridEntry-&gt;text();
   t=t.mid(0,4).toUpper()+t.mid(4,2).toLower();
-  ui.myGridEntry-&gt;setText(t);
+  ui-&gt;myGridEntry-&gt;setText(t);
 }
 
 void DevSetup::setEnableAntennaDescriptions(bool enable)
 {
-    ui.AntDescription1-&gt;setEnabled(enable);
-    ui.AntDescription2-&gt;setEnabled(enable);
-    ui.AntDescription3-&gt;setEnabled(enable);
-    ui.AntDescription4-&gt;setEnabled(enable);
-    ui.AntDescription5-&gt;setEnabled(enable);
-    ui.AntDescription6-&gt;setEnabled(enable);
-    ui.AntDescription7-&gt;setEnabled(enable);
-    ui.AntDescription8-&gt;setEnabled(enable);
-    ui.AntDescription9-&gt;setEnabled(enable);
-    ui.AntDescription10-&gt;setEnabled(enable);
-    ui.AntDescription11-&gt;setEnabled(enable);
-    ui.AntDescription12-&gt;setEnabled(enable);
-    ui.AntDescription13-&gt;setEnabled(enable);
-    ui.AntDescription14-&gt;setEnabled(enable);
-    ui.AntDescription15-&gt;setEnabled(enable);
-    ui.AntDescription16-&gt;setEnabled(enable);
+    ui-&gt;AntDescription1-&gt;setEnabled(enable);
+    ui-&gt;AntDescription2-&gt;setEnabled(enable);
+    ui-&gt;AntDescription3-&gt;setEnabled(enable);
+    ui-&gt;AntDescription4-&gt;setEnabled(enable);
+    ui-&gt;AntDescription5-&gt;setEnabled(enable);
+    ui-&gt;AntDescription6-&gt;setEnabled(enable);
+    ui-&gt;AntDescription7-&gt;setEnabled(enable);
+    ui-&gt;AntDescription8-&gt;setEnabled(enable);
+    ui-&gt;AntDescription9-&gt;setEnabled(enable);
+    ui-&gt;AntDescription10-&gt;setEnabled(enable);
+    ui-&gt;AntDescription11-&gt;setEnabled(enable);
+    ui-&gt;AntDescription12-&gt;setEnabled(enable);
+    ui-&gt;AntDescription13-&gt;setEnabled(enable);
+    ui-&gt;AntDescription14-&gt;setEnabled(enable);
+    ui-&gt;AntDescription15-&gt;setEnabled(enable);
+    ui-&gt;AntDescription16-&gt;setEnabled(enable);
     if (enable)
-        ui.AntDescriptionColumnLabel-&gt;setText(&quot;Antenna description&quot;);
+        ui-&gt;AntDescriptionColumnLabel-&gt;setText(&quot;Antenna description&quot;);
     else
-        ui.AntDescriptionColumnLabel-&gt;setText(&quot;Antenna description (enable PSK Reporter)&quot;);
+        ui-&gt;AntDescriptionColumnLabel-&gt;setText(&quot;Antenna description (enable PSK Reporter)&quot;);
 }
 
 void DevSetup::on_cbPSKReporter_clicked(bool b)
@@ -388,48 +392,48 @@
 void DevSetup::on_catPortComboBox_activated(int index)
 {
   m_catPortIndex=index;
-  m_catPort=ui.catPortComboBox-&gt;itemText(index);
+  m_catPort=ui-&gt;catPortComboBox-&gt;itemText(index);
 }
 
 void DevSetup::on_cbEnableCAT_toggled(bool b)
 {
   m_catEnabled=b;
   enableWidgets();
-  ui.cbSplit-&gt;setChecked(m_bSplit and m_catEnabled);
+  ui-&gt;cbSplit-&gt;setChecked(m_bSplit and m_catEnabled);
 }
 
 void DevSetup::on_serialRateComboBox_activated(int index)
 {
   m_serialRateIndex=index;
-  m_serialRate=ui.serialRateComboBox-&gt;itemText(index).toInt();
+  m_serialRate=ui-&gt;serialRateComboBox-&gt;itemText(index).toInt();
 }
 
 void DevSetup::on_handshakeComboBox_activated(int index)
 {
   m_handshakeIndex=index;
-  m_handshake=ui.handshakeComboBox-&gt;itemText(index);
+  m_handshake=ui-&gt;handshakeComboBox-&gt;itemText(index);
 }
 
 void DevSetup::on_handshakeComboBox_currentIndexChanged(int index)
 {
-  ui.RTSCheckBox-&gt;setEnabled(index != 2);
+  ui-&gt;RTSCheckBox-&gt;setEnabled(index != 2);
 }
 
 void DevSetup::on_dataBitsComboBox_activated(int index)
 {
   m_dataBitsIndex=index;
-  m_dataBits=ui.dataBitsComboBox-&gt;itemText(index).toInt();
+  m_dataBits=ui-&gt;dataBitsComboBox-&gt;itemText(index).toInt();
 }
 
 void DevSetup::on_stopBitsComboBox_activated(int index)
 {
   m_stopBitsIndex=index;
-  m_stopBits=ui.stopBitsComboBox-&gt;itemText(index).toInt();
+  m_stopBits=ui-&gt;stopBitsComboBox-&gt;itemText(index).toInt();
 }
 
 void DevSetup::on_rigComboBox_activated(int index)
 {
-  m_rig = ui.rigComboBox-&gt;itemData (index).toInt ();
+  m_rig = ui-&gt;rigComboBox-&gt;itemData (index).toInt ();
   enableWidgets();
 }
 
@@ -452,7 +456,7 @@
               int(1000000.0*fMHz));
     if(m_poll&gt;0) {
       m_catEnabled=false;
-      ui.cbEnableCAT-&gt;setChecked(false);
+      ui-&gt;cbEnableCAT-&gt;setChecked(false);
     }
   }
   msgBox(t);
@@ -492,7 +496,7 @@
     rig-&gt;setConf(&quot;stop_bits&quot;,buf);
     rig-&gt;setConf(&quot;serial_handshake&quot;,m_handshake.toLatin1().data());
     rig-&gt;setConf(&quot;dtr_state&quot;,m_bDTR ? &quot;ON&quot; : &quot;OFF&quot;);
-    if(ui.RTSCheckBox-&gt;isEnabled()) {
+    if(ui-&gt;RTSCheckBox-&gt;isEnabled()) {
       rig-&gt;setConf(&quot;rts_state&quot;,m_bRTS ? &quot;ON&quot; : &quot;OFF&quot;);
     }
   }
@@ -504,7 +508,7 @@
     t=&quot;Open rig failed&quot;;
     msgBox(t);
     m_catEnabled=false;
-    ui.cbEnableCAT-&gt;setChecked(false);
+    ui-&gt;cbEnableCAT-&gt;setChecked(false);
     return;
   }
 }
@@ -558,64 +562,119 @@
 {
   m_pttMethodIndex=index;
   bool b=m_pttMethodIndex==1 or m_pttMethodIndex==2;
-  ui.pttComboBox-&gt;setEnabled(b);
+  ui-&gt;pttComboBox-&gt;setEnabled(b);
 }
 
 void DevSetup::enableWidgets()
 {
-  ui.cbEnableCAT-&gt;setChecked(m_catEnabled);
-  ui.rigComboBox-&gt;setEnabled(m_catEnabled);
-  ui.testCATButton-&gt;setEnabled(m_catEnabled);
-  ui.label_4-&gt;setEnabled(m_catEnabled);
-  ui.label_47-&gt;setEnabled(m_catEnabled);
-  ui.cbSplit-&gt;setEnabled(m_catEnabled);
+  ui-&gt;cbEnableCAT-&gt;setChecked(m_catEnabled);
+  ui-&gt;rigComboBox-&gt;setEnabled(m_catEnabled);
+  ui-&gt;testCATButton-&gt;setEnabled(m_catEnabled);
+  ui-&gt;label_4-&gt;setEnabled(m_catEnabled);
+  ui-&gt;label_47-&gt;setEnabled(m_catEnabled);
+  ui-&gt;cbSplit-&gt;setEnabled(m_catEnabled);
   if(m_rig==9999) {                    //No Split Tx with HRD
-    ui.cbSplit-&gt;setChecked(false);
-    ui.cbSplit-&gt;setEnabled(false);
+    ui-&gt;cbSplit-&gt;setChecked(false);
+    ui-&gt;cbSplit-&gt;setEnabled(false);
   }
-  ui.cbXIT-&gt;setEnabled(m_catEnabled);
+  ui-&gt;cbXIT-&gt;setEnabled(m_catEnabled);
 
   bool bSerial=m_catEnabled and (m_rig&lt;9900);
-  ui.catPortComboBox-&gt;setEnabled(bSerial);
-  ui.serialRateComboBox-&gt;setEnabled(bSerial);
-  ui.dataBitsComboBox-&gt;setEnabled(bSerial);
-  ui.stopBitsComboBox-&gt;setEnabled(bSerial);
-  ui.handshakeComboBox-&gt;setEnabled(bSerial);
-  ui.DTRCheckBox-&gt;setEnabled(bSerial);
-  ui.DTRCheckBox-&gt;setChecked(m_bDTR);
-  ui.RTSCheckBox-&gt;setEnabled(bSerial &amp;&amp; m_handshakeIndex != 2);
-  ui.RTSCheckBox-&gt;setChecked(m_bRTS);
-  ui.rbData-&gt;setEnabled(bSerial);
-  ui.rbMic-&gt;setEnabled(bSerial);
-  ui.label_21-&gt;setEnabled(bSerial);
-  ui.label_22-&gt;setEnabled(bSerial);
-  ui.label_23-&gt;setEnabled(bSerial);
-  ui.label_24-&gt;setEnabled(bSerial);
-  ui.label_25-&gt;setEnabled(bSerial);
+  ui-&gt;catPortComboBox-&gt;setEnabled(bSerial);
+  ui-&gt;serialRateComboBox-&gt;setEnabled(bSerial);
+  ui-&gt;dataBitsComboBox-&gt;setEnabled(bSerial);
+  ui-&gt;stopBitsComboBox-&gt;setEnabled(bSerial);
+  ui-&gt;handshakeComboBox-&gt;setEnabled(bSerial);
+  ui-&gt;DTRCheckBox-&gt;setEnabled(bSerial);
+  ui-&gt;DTRCheckBox-&gt;setChecked(m_bDTR);
+  ui-&gt;RTSCheckBox-&gt;setEnabled(bSerial &amp;&amp; m_handshakeIndex != 2);
+  ui-&gt;RTSCheckBox-&gt;setChecked(m_bRTS);
+  ui-&gt;rbData-&gt;setEnabled(bSerial);
+  ui-&gt;rbMic-&gt;setEnabled(bSerial);
+  ui-&gt;label_21-&gt;setEnabled(bSerial);
+  ui-&gt;label_22-&gt;setEnabled(bSerial);
+  ui-&gt;label_23-&gt;setEnabled(bSerial);
+  ui-&gt;label_24-&gt;setEnabled(bSerial);
+  ui-&gt;label_25-&gt;setEnabled(bSerial);
 
-  ui.pollSpinBox-&gt;setEnabled(m_catEnabled);
+  ui-&gt;pollSpinBox-&gt;setEnabled(m_catEnabled);
   bool b1=(m_pttMethodIndex==1 or m_pttMethodIndex==2);
-  ui.pttComboBox-&gt;setEnabled(b1);
+  ui-&gt;pttComboBox-&gt;setEnabled(b1);
   b1=b1 and (m_pttPort!=0);
   bool b2 = (m_catEnabled and m_pttMethodIndex==1 and m_rig&lt;9900) or
             (m_catEnabled and m_pttMethodIndex==2 and m_rig&lt;9900);
   bool b3 = (m_catEnabled and m_pttMethodIndex==0);
-  ui.testPTTButton-&gt;setEnabled(b1 or b2 or b3);  //Include PTT via HRD or Commander
+  ui-&gt;testPTTButton-&gt;setEnabled(b1 or b2 or b3);  //Include PTT via HRD or Commander
   setEnableAntennaDescriptions(m_pskReporter);
 }
 
 void DevSetup::on_cbSplit_toggled(bool checked)
 {
   m_bSplit=checked;
-  if(m_bSplit and m_bXIT) ui.cbXIT-&gt;setChecked(false);
+  if(m_bSplit and m_bXIT) ui-&gt;cbXIT-&gt;setChecked(false);
 }
 
 void DevSetup::on_cbXIT_toggled(bool checked)
 {
   m_bXIT=checked;
-  if(m_bSplit and m_bXIT) ui.cbSplit-&gt;setChecked(false);
+  if(m_bSplit and m_bXIT) ui-&gt;cbSplit-&gt;setChecked(false);
 }
 
+void DevSetup::loadAudioDevices (AudioDevices const&amp; d, QComboBox * cb)
+{
+  using std::copy;
+  using std::back_inserter;
+
+  int currentIndex = -1;
+  int defaultIndex = 0;
+  for (AudioDevices::const_iterator p = d.cbegin (); p != d.cend (); ++p)
+    {
+      // convert supported channel counts into something we can store in the item model
+      QList&lt;QVariant&gt; channelCounts;
+      QList&lt;int&gt; scc (p-&gt;supportedChannelCounts ());
+      copy (scc.cbegin (), scc.cend (), back_inserter (channelCounts));
+
+      cb-&gt;addItem (p-&gt;deviceName (), channelCounts);
+      if (*p == m_audioInputDevice)
+	{
+	  currentIndex = p - d.cbegin ();
+	}
+      else if (*p == QAudioDeviceInfo::defaultInputDevice ())
+	{
+	  defaultIndex = p - d.cbegin ();
+	}
+    }
+  cb-&gt;setCurrentIndex (currentIndex != -1 ? currentIndex : defaultIndex);
+}
+
+void DevSetup::updateAudioChannels (QComboBox const * srcCb, int index, QComboBox * cb, bool allowBoth)
+{
+  // disable all items
+  for (int i (0); i &lt; cb-&gt;count (); ++i)
+    {
+      cb-&gt;setItemData (i, 0, Qt::UserRole - 1); // undocumented model internals allows disable
+    }
+
+  Q_FOREACH (QVariant const&amp; v, srcCb-&gt;itemData (index).toList ())
+    {
+      // enable valid options
+      int n (v.toInt ());
+      if (2 == n)
+	{
+	  cb-&gt;setItemData (AudioDevice::Left, 32 | 1, Qt::UserRole - 1); // undocumented model internals allows enable
+	  cb-&gt;setItemData (AudioDevice::Right, 32 | 1, Qt::UserRole - 1);
+	  if (allowBoth)
+	    {
+	      cb-&gt;setItemData (AudioDevice::Both, 32 | 1, Qt::UserRole - 1);
+	    }
+	}
+      else if (1 == n)
+	{
+	  cb-&gt;setItemData (AudioDevice::Mono, 32 | 1, Qt::UserRole - 1);
+	}
+    }
+}
+
 typedef QMap&lt;QString, int&gt; RigList;
 
 int rigCallback (rig_caps const * caps, void * cbData)
@@ -641,10 +700,10 @@
 
   for (RigList::const_iterator r = rigs.cbegin (); r != rigs.cend (); ++r)
     {
-      ui.rigComboBox-&gt;addItem (r.key (), r.value ());
+      ui-&gt;rigComboBox-&gt;addItem (r.key (), r.value ());
     }
 
-  ui.rigComboBox-&gt;addItem (&quot;DX Lab Suite Commander&quot;, 9998);
-  ui.rigComboBox-&gt;addItem (&quot;Ham Radio Deluxe&quot;, 9999);
-  ui.rigComboBox-&gt;setCurrentIndex (ui.rigComboBox-&gt;findData (m_rig));
+  ui-&gt;rigComboBox-&gt;addItem (&quot;DX Lab Suite Commander&quot;, 9998);
+  ui-&gt;rigComboBox-&gt;addItem (&quot;Ham Radio Deluxe&quot;, 9999);
+  ui-&gt;rigComboBox-&gt;setCurrentIndex (ui-&gt;rigComboBox-&gt;findData (m_rig));
 }

Modified: branches/wsjtx/devsetup.h
===================================================================
--- branches/wsjtx/devsetup.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/devsetup.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,8 +1,6 @@
 #ifndef DEVSETUP_H
 #define DEVSETUP_H
 
-#include &quot;ui_devsetup.h&quot;
-
 #include &lt;QDialog&gt;
 #include &lt;QProcess&gt;
 #include &lt;QMessageBox&gt;
@@ -11,12 +9,23 @@
 #include &lt;hamlib/rig.h&gt;
 
 #include &quot;rigclass.h&quot;
+#include &quot;AudioDevice.hpp&quot;
 
 int rigCallback (rig_caps const *, void *);
 
+namespace Ui {
+    class DevSetup;
+}
+
+class QComboBox;
+
 class DevSetup : public QDialog
 {
-  Q_OBJECT
+  Q_OBJECT;
+
+ private:
+  Ui::DevSetup * ui;
+
 public:
   DevSetup(QWidget *parent=0);
   ~DevSetup();
@@ -47,6 +56,8 @@
   QAudioDeviceInfo m_audioOutputDevice; /* selected output device */
   bool    m_restartSoundIn;
   bool    m_restartSoundOut;
+  AudioDevice::Channel m_audioInputChannel;
+  AudioDevice::Channel m_audioOutputChannel;
 
   bool    m_pskReporter;
   bool    m_firstCall;
@@ -99,19 +110,18 @@
   void on_pollSpinBox_valueChanged(int n);
   void on_pttComboBox_currentIndexChanged(int index);
   void on_pttMethodComboBox_currentIndexChanged(int index);
-
   void on_cbSplit_toggled(bool checked);
-
   void on_cbXIT_toggled(bool checked);
 
 private:
+  void loadAudioDevices (AudioDevices const&amp;, QComboBox *);
+  void updateAudioChannels (QComboBox const *, int, QComboBox *, bool);
   void enumerateRigs ();
   Rig* rig;
   void msgBox(QString t);
   void setEnableAntennaDescriptions(bool enable);
   void enableWidgets();
   void openRig();
-  Ui::DialogSndCard ui;
 
   friend int rigCallback (rig_caps const *, void *);
 };

Modified: branches/wsjtx/devsetup.ui
===================================================================
--- branches/wsjtx/devsetup.ui	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/devsetup.ui	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;ui version=&quot;4.0&quot;&gt;
- &lt;class&gt;DialogSndCard&lt;/class&gt;
- &lt;widget class=&quot;QDialog&quot; name=&quot;DialogSndCard&quot;&gt;
+ &lt;class&gt;DevSetup&lt;/class&gt;
+ &lt;widget class=&quot;QDialog&quot; name=&quot;DevSetup&quot;&gt;
   &lt;property name=&quot;geometry&quot;&gt;
    &lt;rect&gt;
     &lt;x&gt;0&lt;/x&gt;
@@ -1137,8 +1137,41 @@
         &lt;/spacer&gt;
        &lt;/item&gt;
        &lt;item&gt;
-        &lt;layout class=&quot;QVBoxLayout&quot; name=&quot;verticalLayout_6&quot;&gt;
-         &lt;item&gt;
+        &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_3&quot;&gt;
+         &lt;item row=&quot;2&quot; column=&quot;0&quot;&gt;
+          &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout&quot;&gt;
+           &lt;item&gt;
+            &lt;widget class=&quot;QLabel&quot; name=&quot;label_10&quot;&gt;
+             &lt;property name=&quot;sizePolicy&quot;&gt;
+              &lt;sizepolicy hsizetype=&quot;Preferred&quot; vsizetype=&quot;Fixed&quot;&gt;
+               &lt;horstretch&gt;0&lt;/horstretch&gt;
+               &lt;verstretch&gt;0&lt;/verstretch&gt;
+              &lt;/sizepolicy&gt;
+             &lt;/property&gt;
+             &lt;property name=&quot;minimumSize&quot;&gt;
+              &lt;size&gt;
+               &lt;width&gt;90&lt;/width&gt;
+               &lt;height&gt;20&lt;/height&gt;
+              &lt;/size&gt;
+             &lt;/property&gt;
+             &lt;property name=&quot;text&quot;&gt;
+              &lt;string&gt;Save Directory:&lt;/string&gt;
+             &lt;/property&gt;
+            &lt;/widget&gt;
+           &lt;/item&gt;
+           &lt;item&gt;
+            &lt;widget class=&quot;QLineEdit&quot; name=&quot;saveDirEntry&quot;&gt;
+             &lt;property name=&quot;toolTip&quot;&gt;
+              &lt;string&gt;Directory for saved audio files&lt;/string&gt;
+             &lt;/property&gt;
+             &lt;property name=&quot;text&quot;&gt;
+              &lt;string&gt;C:\Users\joe\wsjt\map65\save&lt;/string&gt;
+             &lt;/property&gt;
+            &lt;/widget&gt;
+           &lt;/item&gt;
+          &lt;/layout&gt;
+         &lt;/item&gt;
+         &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt;
           &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout_3&quot;&gt;
            &lt;item&gt;
             &lt;widget class=&quot;QLabel&quot; name=&quot;label_6&quot;&gt;
@@ -1164,14 +1197,39 @@
              &lt;property name=&quot;enabled&quot;&gt;
               &lt;bool&gt;true&lt;/bool&gt;
              &lt;/property&gt;
+             &lt;property name=&quot;sizePolicy&quot;&gt;
+              &lt;sizepolicy hsizetype=&quot;Expanding&quot; vsizetype=&quot;Fixed&quot;&gt;
+               &lt;horstretch&gt;0&lt;/horstretch&gt;
+               &lt;verstretch&gt;0&lt;/verstretch&gt;
+              &lt;/sizepolicy&gt;
+             &lt;/property&gt;
              &lt;property name=&quot;toolTip&quot;&gt;
               &lt;string&gt;Select audio input device and driver API&lt;/string&gt;
              &lt;/property&gt;
             &lt;/widget&gt;
            &lt;/item&gt;
+           &lt;item alignment=&quot;Qt::AlignRight&quot;&gt;
+            &lt;widget class=&quot;QComboBox&quot; name=&quot;audioInputChannel&quot;&gt;
+             &lt;item&gt;
+              &lt;property name=&quot;text&quot;&gt;
+               &lt;string&gt;Mono&lt;/string&gt;
+              &lt;/property&gt;
+             &lt;/item&gt;
+             &lt;item&gt;
+              &lt;property name=&quot;text&quot;&gt;
+               &lt;string&gt;Left&lt;/string&gt;
+              &lt;/property&gt;
+             &lt;/item&gt;
+             &lt;item&gt;
+              &lt;property name=&quot;text&quot;&gt;
+               &lt;string&gt;Right&lt;/string&gt;
+              &lt;/property&gt;
+             &lt;/item&gt;
+            &lt;/widget&gt;
+           &lt;/item&gt;
           &lt;/layout&gt;
          &lt;/item&gt;
-         &lt;item&gt;
+         &lt;item row=&quot;1&quot; column=&quot;0&quot;&gt;
           &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout_4&quot;&gt;
            &lt;item&gt;
             &lt;widget class=&quot;QLabel&quot; name=&quot;label_7&quot;&gt;
@@ -1200,44 +1258,47 @@
            &lt;/item&gt;
            &lt;item&gt;
             &lt;widget class=&quot;QComboBox&quot; name=&quot;comboBoxSndOut&quot;&gt;
+             &lt;property name=&quot;sizePolicy&quot;&gt;
+              &lt;sizepolicy hsizetype=&quot;Expanding&quot; vsizetype=&quot;Fixed&quot;&gt;
+               &lt;horstretch&gt;0&lt;/horstretch&gt;
+               &lt;verstretch&gt;0&lt;/verstretch&gt;
+              &lt;/sizepolicy&gt;
+             &lt;/property&gt;
              &lt;property name=&quot;toolTip&quot;&gt;
               &lt;string&gt;select audio output device and driver API&lt;/string&gt;
              &lt;/property&gt;
             &lt;/widget&gt;
            &lt;/item&gt;
-          &lt;/layout&gt;
-         &lt;/item&gt;
-         &lt;item&gt;
-          &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout&quot;&gt;
-           &lt;item&gt;
-            &lt;widget class=&quot;QLabel&quot; name=&quot;label_10&quot;&gt;
+           &lt;item alignment=&quot;Qt::AlignRight&quot;&gt;
+            &lt;widget class=&quot;QComboBox&quot; name=&quot;audioOutputChannel&quot;&gt;
              &lt;property name=&quot;sizePolicy&quot;&gt;
-              &lt;sizepolicy hsizetype=&quot;Preferred&quot; vsizetype=&quot;Fixed&quot;&gt;
+              &lt;sizepolicy hsizetype=&quot;Minimum&quot; vsizetype=&quot;Fixed&quot;&gt;
                &lt;horstretch&gt;0&lt;/horstretch&gt;
                &lt;verstretch&gt;0&lt;/verstretch&gt;
               &lt;/sizepolicy&gt;
              &lt;/property&gt;
-             &lt;property name=&quot;minimumSize&quot;&gt;
-              &lt;size&gt;
-               &lt;width&gt;90&lt;/width&gt;
-               &lt;height&gt;20&lt;/height&gt;
-              &lt;/size&gt;
-             &lt;/property&gt;
-             &lt;property name=&quot;text&quot;&gt;
-              &lt;string&gt;Save Directory:&lt;/string&gt;
-             &lt;/property&gt;
+             &lt;item&gt;
+              &lt;property name=&quot;text&quot;&gt;
+               &lt;string&gt;Mono&lt;/string&gt;
+              &lt;/property&gt;
+             &lt;/item&gt;
+             &lt;item&gt;
+              &lt;property name=&quot;text&quot;&gt;
+               &lt;string&gt;Left&lt;/string&gt;
+              &lt;/property&gt;
+             &lt;/item&gt;
+             &lt;item&gt;
+              &lt;property name=&quot;text&quot;&gt;
+               &lt;string&gt;Right&lt;/string&gt;
+              &lt;/property&gt;
+             &lt;/item&gt;
+             &lt;item&gt;
+              &lt;property name=&quot;text&quot;&gt;
+               &lt;string&gt;Both&lt;/string&gt;
+              &lt;/property&gt;
+             &lt;/item&gt;
             &lt;/widget&gt;
            &lt;/item&gt;
-           &lt;item&gt;
-            &lt;widget class=&quot;QLineEdit&quot; name=&quot;saveDirEntry&quot;&gt;
-             &lt;property name=&quot;toolTip&quot;&gt;
-              &lt;string&gt;Directory for saved audio files&lt;/string&gt;
-             &lt;/property&gt;
-             &lt;property name=&quot;text&quot;&gt;
-              &lt;string&gt;C:\Users\joe\wsjt\map65\save&lt;/string&gt;
-             &lt;/property&gt;
-            &lt;/widget&gt;
-           &lt;/item&gt;
           &lt;/layout&gt;
          &lt;/item&gt;
         &lt;/layout&gt;
@@ -1807,7 +1868,7 @@
            &lt;rect&gt;
             &lt;x&gt;0&lt;/x&gt;
             &lt;y&gt;0&lt;/y&gt;
-            &lt;width&gt;510&lt;/width&gt;
+            &lt;width&gt;308&lt;/width&gt;
             &lt;height&gt;449&lt;/height&gt;
            &lt;/rect&gt;
           &lt;/property&gt;
@@ -2519,7 +2580,7 @@
   &lt;connection&gt;
    &lt;sender&gt;buttonBox&lt;/sender&gt;
    &lt;signal&gt;accepted()&lt;/signal&gt;
-   &lt;receiver&gt;DialogSndCard&lt;/receiver&gt;
+   &lt;receiver&gt;DevSetup&lt;/receiver&gt;
    &lt;slot&gt;accept()&lt;/slot&gt;
    &lt;hints&gt;
     &lt;hint type=&quot;sourcelabel&quot;&gt;
@@ -2535,7 +2596,7 @@
   &lt;connection&gt;
    &lt;sender&gt;buttonBox&lt;/sender&gt;
    &lt;signal&gt;rejected()&lt;/signal&gt;
-   &lt;receiver&gt;DialogSndCard&lt;/receiver&gt;
+   &lt;receiver&gt;DevSetup&lt;/receiver&gt;
    &lt;slot&gt;reject()&lt;/slot&gt;
    &lt;hints&gt;
     &lt;hint type=&quot;sourcelabel&quot;&gt;

Modified: branches/wsjtx/killbyname.cpp
===================================================================
--- branches/wsjtx/killbyname.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/killbyname.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,284 +1,284 @@
-#include &lt;windows.h&gt;
-#include &lt;tlhelp32.h&gt;
-#include &lt;iostream&gt;
-
-int killbyname(const char *szToTerminate)
-// Created: 6/23/2000  (Ravi Kochhar)
-// Last modified: 3/10/2002  (RK)
-// Please report any problems or bugs to <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">kochhar at physiology.wisc.edu</A>
-// The latest version of this routine can be found at:
-//     <A HREF="http://www.neurophys.wisc.edu/ravi/software/killproc/">http://www.neurophys.wisc.edu/ravi/software/killproc/</A>
-// Terminate the process &quot;szToTerminate&quot; if it is currently running
-// This works for Win/95/98/ME and also Win/NT/2000/XP
-// The process name is case-insensitive, i.e. &quot;notepad.exe&quot; and &quot;NOTEPAD.EXE&quot;
-// will both work (for szToTerminate)
-// Return codes are as follows:
-//   0   = Process was successfully terminated
-//   602 = Unable to terminate process for some other reason
-//   603 = Process was not currently running
-//   604 = No permission to terminate process
-//   605 = Unable to load PSAPI.DLL
-//   606 = Unable to identify system type
-//   607 = Unsupported OS
-//   632 = Invalid process name
-//   700 = Unable to get procedure address from PSAPI.DLL
-//   701 = Unable to get process list, EnumProcesses failed
-//   702 = Unable to load KERNEL32.DLL
-//   703 = Unable to get procedure address from KERNEL32.DLL
-//   704 = CreateToolhelp32Snapshot failed
-
-{
-  BOOL bResult,bResultm;
-  DWORD aiPID[1000],iCb=1000,iNumProc;  //,iV2000=0;
-  DWORD iCbneeded,i,iFound=0;
-  char szName[MAX_PATH],szToTermUpper[MAX_PATH];
-  HANDLE hProc,hSnapShot,hSnapShotm;
-  OSVERSIONINFO osvi;
-  HINSTANCE hInstLib;
-//  int iLen,iLenP,indx;
-  int iLenP,indx;
-  HMODULE hMod;
-  PROCESSENTRY32 procentry;
-  MODULEENTRY32 modentry;
-
-  // Transfer Process name into &quot;szToTermUpper&quot; and convert to upper case
-  iLenP=strlen(szToTerminate);
-  if(iLenP&lt;1 || iLenP&gt;MAX_PATH) return 632;
-  for(indx=0;indx&lt;iLenP;indx++)
-    szToTermUpper[indx]=toupper(szToTerminate[indx]);
-  szToTermUpper[iLenP]=0;
-
-  // PSAPI Function Pointers.
-  BOOL (WINAPI *lpfEnumProcesses)( DWORD *, DWORD cb, DWORD * );
-  BOOL (WINAPI *lpfEnumProcessModules)( HANDLE, HMODULE *,
-                                        DWORD, LPDWORD );
-  DWORD (WINAPI *lpfGetModuleBaseName)( HANDLE, HMODULE,
-                                        LPTSTR, DWORD );
-
-  // ToolHelp Function Pointers.
-  HANDLE (WINAPI *lpfCreateToolhelp32Snapshot)(DWORD,DWORD) ;
-  BOOL (WINAPI *lpfProcess32First)(HANDLE,LPPROCESSENTRY32) ;
-  BOOL (WINAPI *lpfProcess32Next)(HANDLE,LPPROCESSENTRY32) ;
-  BOOL (WINAPI *lpfModule32First)(HANDLE,LPMODULEENTRY32) ;
-  BOOL (WINAPI *lpfModule32Next)(HANDLE,LPMODULEENTRY32) ;
-
-  // First check what version of Windows we're in
-  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
-  bResult=GetVersionEx(&amp;osvi);
-  if(!bResult) return 606;    // Unable to identify system version
-
-  // At Present we only support Win/NT/2000/XP or Win/9x/ME
-  // Seems to work OK in Win7
-  if((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) &amp;&amp;
-     (osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)) return 607;
-
-  if(osvi.dwPlatformId==VER_PLATFORM_WIN32_NT)
-  {
-    // Win/NT or 2000 or XP
-
-    // Load library and get the procedures explicitly. We do
-    // this so that we don't have to worry about modules using
-    // this code failing to load under Windows 9x, because
-    // it can't resolve references to the PSAPI.DLL.
-    hInstLib = LoadLibraryA(&quot;PSAPI.DLL&quot;);
-    if(hInstLib == NULL) return 605;
-
-    // Get procedure addresses.
-    lpfEnumProcesses = (BOOL(WINAPI *)(DWORD *,DWORD,DWORD*))
-        GetProcAddress( hInstLib, &quot;EnumProcesses&quot; ) ;
-    lpfEnumProcessModules = (BOOL(WINAPI *)(HANDLE, HMODULE *,
-        DWORD, LPDWORD)) GetProcAddress( hInstLib,                                                                     &quot;EnumProcessModules&quot; ) ;
-        lpfGetModuleBaseName =(DWORD (WINAPI *)(HANDLE, HMODULE, LPTSTR,
-        DWORD )) GetProcAddress( hInstLib, &quot;GetModuleBaseNameA&quot; ) ;
-
-    if(lpfEnumProcesses == NULL || lpfEnumProcessModules == NULL ||
-         lpfGetModuleBaseName == NULL) {
-      FreeLibrary(hInstLib);
-      return 700;
-    }
-
-    bResult=lpfEnumProcesses(aiPID,iCb,&amp;iCbneeded);
-    if(!bResult) {
-      // Unable to get process list, EnumProcesses failed
-      FreeLibrary(hInstLib);
-      return 701;
-    }
-
-    // How many processes are there?
-    iNumProc=iCbneeded/sizeof(DWORD);
-
-    // Get and match the name of each process
-    for(i=0;i&lt;iNumProc;i++) {
-      // Get the (module) name for this process
-      strcpy(szName,&quot;Unknown&quot;);
-      // First, get a handle to the process
-      hProc=OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,
-                        aiPID[i]);
-      // Now, get the process name
-      if(hProc) {
-        if(lpfEnumProcessModules(hProc,&amp;hMod,sizeof(hMod),&amp;iCbneeded) ) {
-//          iLen=lpfGetModuleBaseName(hProc,hMod,szName,MAX_PATH);
-          lpfGetModuleBaseName(hProc,hMod,szName,MAX_PATH);
-        }
-      }
-      CloseHandle(hProc);
-      // We will match regardless of lower or upper case
-      if(strcmp(_strupr(szName),szToTermUpper)==0) {
-        // Process found, now terminate it
-        iFound=1;
-        // First open for termination
-        hProc=OpenProcess(PROCESS_TERMINATE,FALSE,aiPID[i]);
-        if(hProc) {
-          if(TerminateProcess(hProc,0)) {
-            // process terminated
-            CloseHandle(hProc);
-            FreeLibrary(hInstLib);
-            return 0;
-          } else {
-            // Unable to terminate process
-            CloseHandle(hProc);
-            FreeLibrary(hInstLib);
-            return 602;
-          }
-        } else {
-          // Unable to open process for termination
-          FreeLibrary(hInstLib);
-          return 604;
-        }
-      }
-    }
-  }
-
-  if(osvi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)
-  {
-    // Win/95 or 98 or ME
-
-    hInstLib = LoadLibraryA(&quot;Kernel32.DLL&quot;);
-    if( hInstLib == NULL )
-      return 702;
-
-    // Get procedure addresses.
-    // We are linking to these functions of Kernel32
-    // explicitly, because otherwise a module using
-    // this code would fail to load under Windows NT,
-    // which does not have the Toolhelp32
-    // functions in the Kernel 32.
-    lpfCreateToolhelp32Snapshot=
-        (HANDLE(WINAPI *)(DWORD,DWORD))
-        GetProcAddress( hInstLib,
-                        &quot;CreateToolhelp32Snapshot&quot; ) ;
-    lpfProcess32First=
-        (BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32))
-        GetProcAddress( hInstLib, &quot;Process32First&quot; ) ;
-    lpfProcess32Next=
-        (BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32))
-        GetProcAddress( hInstLib, &quot;Process32Next&quot; ) ;
-    lpfModule32First=
-        (BOOL(WINAPI *)(HANDLE,LPMODULEENTRY32))
-        GetProcAddress( hInstLib, &quot;Module32First&quot; ) ;
-    lpfModule32Next=
-        (BOOL(WINAPI *)(HANDLE,LPMODULEENTRY32))
-        GetProcAddress( hInstLib, &quot;Module32Next&quot; ) ;
-    if( lpfProcess32Next == NULL ||
-        lpfProcess32First == NULL ||
-        lpfModule32Next == NULL ||
-        lpfModule32First == NULL ||
-        lpfCreateToolhelp32Snapshot == NULL )
-    {
-      FreeLibrary(hInstLib);
-      return 703;
-    }
-
-    // The Process32.. and Module32.. routines return names in all uppercase
-
-    // Get a handle to a Toolhelp snapshot of all the systems processes.
-
-    hSnapShot = lpfCreateToolhelp32Snapshot(
-          TH32CS_SNAPPROCESS, 0 ) ;
-    if( hSnapShot == INVALID_HANDLE_VALUE )
-    {
-      FreeLibrary(hInstLib);
-      return 704;
-    }
-
-    // Get the first process' information.
-    procentry.dwSize = sizeof(PROCESSENTRY32);
-    bResult=lpfProcess32First(hSnapShot,&amp;procentry);
-
-    // While there are processes, keep looping and checking.
-    while(bResult)
-    {
-      // Get a handle to a Toolhelp snapshot of this process.
-      hSnapShotm = lpfCreateToolhelp32Snapshot(
-            TH32CS_SNAPMODULE, procentry.th32ProcessID) ;
-      if( hSnapShotm == INVALID_HANDLE_VALUE )
-      {
-        CloseHandle(hSnapShot);
-        FreeLibrary(hInstLib);
-        return 704;
-      }
-      // Get the module list for this process
-      modentry.dwSize=sizeof(MODULEENTRY32);
-      bResultm=lpfModule32First(hSnapShotm,&amp;modentry);
-
-      // While there are modules, keep looping and checking
-      while(bResultm)
-      {
-        if(strcmp(modentry.szModule,szToTermUpper)==0)
-        {
-          // Process found, now terminate it
-          iFound=1;
-          // First open for termination
-          hProc=OpenProcess(PROCESS_TERMINATE,FALSE,procentry.th32ProcessID);
-          if(hProc)
-          {
-            if(TerminateProcess(hProc,0))
-            {
-              // process terminated
-              CloseHandle(hSnapShotm);
-              CloseHandle(hSnapShot);
-              CloseHandle(hProc);
-              FreeLibrary(hInstLib);
-              return 0;
-            }
-            else
-            {
-              // Unable to terminate process
-              CloseHandle(hSnapShotm);
-              CloseHandle(hSnapShot);
-              CloseHandle(hProc);
-              FreeLibrary(hInstLib);
-              return 602;
-            }
-          }
-          else
-          {
-            // Unable to open process for termination
-            CloseHandle(hSnapShotm);
-            CloseHandle(hSnapShot);
-            FreeLibrary(hInstLib);
-            return 604;
-          }
-        }
-        else
-        {  // Look for next modules for this process
-          modentry.dwSize=sizeof(MODULEENTRY32);
-          bResultm=lpfModule32Next(hSnapShotm,&amp;modentry);
-        }
-      }
-
-      //Keep looking
-      CloseHandle(hSnapShotm);
-      procentry.dwSize = sizeof(PROCESSENTRY32);
-      bResult = lpfProcess32Next(hSnapShot,&amp;procentry);
-    }
-    CloseHandle(hSnapShot);
-  }
-  if(iFound==0)
-  {
-    FreeLibrary(hInstLib);
-    return 603;
-  }
-  FreeLibrary(hInstLib);
-  return 0;
-}
+#include &lt;windows.h&gt;
+#include &lt;tlhelp32.h&gt;
+#include &lt;iostream&gt;
+
+int killbyname(const char *szToTerminate)
+// Created: 6/23/2000  (Ravi Kochhar)
+// Last modified: 3/10/2002  (RK)
+// Please report any problems or bugs to <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">kochhar at physiology.wisc.edu</A>
+// The latest version of this routine can be found at:
+//     <A HREF="http://www.neurophys.wisc.edu/ravi/software/killproc/">http://www.neurophys.wisc.edu/ravi/software/killproc/</A>
+// Terminate the process &quot;szToTerminate&quot; if it is currently running
+// This works for Win/95/98/ME and also Win/NT/2000/XP
+// The process name is case-insensitive, i.e. &quot;notepad.exe&quot; and &quot;NOTEPAD.EXE&quot;
+// will both work (for szToTerminate)
+// Return codes are as follows:
+//   0   = Process was successfully terminated
+//   602 = Unable to terminate process for some other reason
+//   603 = Process was not currently running
+//   604 = No permission to terminate process
+//   605 = Unable to load PSAPI.DLL
+//   606 = Unable to identify system type
+//   607 = Unsupported OS
+//   632 = Invalid process name
+//   700 = Unable to get procedure address from PSAPI.DLL
+//   701 = Unable to get process list, EnumProcesses failed
+//   702 = Unable to load KERNEL32.DLL
+//   703 = Unable to get procedure address from KERNEL32.DLL
+//   704 = CreateToolhelp32Snapshot failed
+
+{
+  BOOL bResult,bResultm;
+  DWORD aiPID[1000],iCb=1000,iNumProc;  //,iV2000=0;
+  DWORD iCbneeded,i,iFound=0;
+  char szName[MAX_PATH],szToTermUpper[MAX_PATH];
+  HANDLE hProc,hSnapShot,hSnapShotm;
+  OSVERSIONINFO osvi;
+  HINSTANCE hInstLib;
+//  int iLen,iLenP,indx;
+  int iLenP,indx;
+  HMODULE hMod;
+  PROCESSENTRY32 procentry;
+  MODULEENTRY32 modentry;
+
+  // Transfer Process name into &quot;szToTermUpper&quot; and convert to upper case
+  iLenP=strlen(szToTerminate);
+  if(iLenP&lt;1 || iLenP&gt;MAX_PATH) return 632;
+  for(indx=0;indx&lt;iLenP;indx++)
+    szToTermUpper[indx]=toupper(szToTerminate[indx]);
+  szToTermUpper[iLenP]=0;
+
+  // PSAPI Function Pointers.
+  BOOL (WINAPI *lpfEnumProcesses)( DWORD *, DWORD cb, DWORD * );
+  BOOL (WINAPI *lpfEnumProcessModules)( HANDLE, HMODULE *,
+                                        DWORD, LPDWORD );
+  DWORD (WINAPI *lpfGetModuleBaseName)( HANDLE, HMODULE,
+                                        LPTSTR, DWORD );
+
+  // ToolHelp Function Pointers.
+  HANDLE (WINAPI *lpfCreateToolhelp32Snapshot)(DWORD,DWORD) ;
+  BOOL (WINAPI *lpfProcess32First)(HANDLE,LPPROCESSENTRY32) ;
+  BOOL (WINAPI *lpfProcess32Next)(HANDLE,LPPROCESSENTRY32) ;
+  BOOL (WINAPI *lpfModule32First)(HANDLE,LPMODULEENTRY32) ;
+  BOOL (WINAPI *lpfModule32Next)(HANDLE,LPMODULEENTRY32) ;
+
+  // First check what version of Windows we're in
+  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+  bResult=GetVersionEx(&amp;osvi);
+  if(!bResult) return 606;    // Unable to identify system version
+
+  // At Present we only support Win/NT/2000/XP or Win/9x/ME
+  // Seems to work OK in Win7
+  if((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) &amp;&amp;
+     (osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)) return 607;
+
+  if(osvi.dwPlatformId==VER_PLATFORM_WIN32_NT)
+  {
+    // Win/NT or 2000 or XP
+
+    // Load library and get the procedures explicitly. We do
+    // this so that we don't have to worry about modules using
+    // this code failing to load under Windows 9x, because
+    // it can't resolve references to the PSAPI.DLL.
+    hInstLib = LoadLibraryA(&quot;PSAPI.DLL&quot;);
+    if(hInstLib == NULL) return 605;
+
+    // Get procedure addresses.
+    lpfEnumProcesses = (BOOL(WINAPI *)(DWORD *,DWORD,DWORD*))
+        GetProcAddress( hInstLib, &quot;EnumProcesses&quot; ) ;
+    lpfEnumProcessModules = (BOOL(WINAPI *)(HANDLE, HMODULE *,
+        DWORD, LPDWORD)) GetProcAddress( hInstLib,                                                                     &quot;EnumProcessModules&quot; ) ;
+        lpfGetModuleBaseName =(DWORD (WINAPI *)(HANDLE, HMODULE, LPTSTR,
+        DWORD )) GetProcAddress( hInstLib, &quot;GetModuleBaseNameA&quot; ) ;
+
+    if(lpfEnumProcesses == NULL || lpfEnumProcessModules == NULL ||
+         lpfGetModuleBaseName == NULL) {
+      FreeLibrary(hInstLib);
+      return 700;
+    }
+
+    bResult=lpfEnumProcesses(aiPID,iCb,&amp;iCbneeded);
+    if(!bResult) {
+      // Unable to get process list, EnumProcesses failed
+      FreeLibrary(hInstLib);
+      return 701;
+    }
+
+    // How many processes are there?
+    iNumProc=iCbneeded/sizeof(DWORD);
+
+    // Get and match the name of each process
+    for(i=0;i&lt;iNumProc;i++) {
+      // Get the (module) name for this process
+      strcpy(szName,&quot;Unknown&quot;);
+      // First, get a handle to the process
+      hProc=OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,
+                        aiPID[i]);
+      // Now, get the process name
+      if(hProc) {
+        if(lpfEnumProcessModules(hProc,&amp;hMod,sizeof(hMod),&amp;iCbneeded) ) {
+//          iLen=lpfGetModuleBaseName(hProc,hMod,szName,MAX_PATH);
+          lpfGetModuleBaseName(hProc,hMod,szName,MAX_PATH);
+        }
+      }
+      CloseHandle(hProc);
+      // We will match regardless of lower or upper case
+      if(strcmp(_strupr(szName),szToTermUpper)==0) {
+        // Process found, now terminate it
+        iFound=1;
+        // First open for termination
+        hProc=OpenProcess(PROCESS_TERMINATE,FALSE,aiPID[i]);
+        if(hProc) {
+          if(TerminateProcess(hProc,0)) {
+            // process terminated
+            CloseHandle(hProc);
+            FreeLibrary(hInstLib);
+            return 0;
+          } else {
+            // Unable to terminate process
+            CloseHandle(hProc);
+            FreeLibrary(hInstLib);
+            return 602;
+          }
+        } else {
+          // Unable to open process for termination
+          FreeLibrary(hInstLib);
+          return 604;
+        }
+      }
+    }
+  }
+
+  if(osvi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)
+  {
+    // Win/95 or 98 or ME
+
+    hInstLib = LoadLibraryA(&quot;Kernel32.DLL&quot;);
+    if( hInstLib == NULL )
+      return 702;
+
+    // Get procedure addresses.
+    // We are linking to these functions of Kernel32
+    // explicitly, because otherwise a module using
+    // this code would fail to load under Windows NT,
+    // which does not have the Toolhelp32
+    // functions in the Kernel 32.
+    lpfCreateToolhelp32Snapshot=
+        (HANDLE(WINAPI *)(DWORD,DWORD))
+        GetProcAddress( hInstLib,
+                        &quot;CreateToolhelp32Snapshot&quot; ) ;
+    lpfProcess32First=
+        (BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32))
+        GetProcAddress( hInstLib, &quot;Process32First&quot; ) ;
+    lpfProcess32Next=
+        (BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32))
+        GetProcAddress( hInstLib, &quot;Process32Next&quot; ) ;
+    lpfModule32First=
+        (BOOL(WINAPI *)(HANDLE,LPMODULEENTRY32))
+        GetProcAddress( hInstLib, &quot;Module32First&quot; ) ;
+    lpfModule32Next=
+        (BOOL(WINAPI *)(HANDLE,LPMODULEENTRY32))
+        GetProcAddress( hInstLib, &quot;Module32Next&quot; ) ;
+    if( lpfProcess32Next == NULL ||
+        lpfProcess32First == NULL ||
+        lpfModule32Next == NULL ||
+        lpfModule32First == NULL ||
+        lpfCreateToolhelp32Snapshot == NULL )
+    {
+      FreeLibrary(hInstLib);
+      return 703;
+    }
+
+    // The Process32.. and Module32.. routines return names in all uppercase
+
+    // Get a handle to a Toolhelp snapshot of all the systems processes.
+
+    hSnapShot = lpfCreateToolhelp32Snapshot(
+          TH32CS_SNAPPROCESS, 0 ) ;
+    if( hSnapShot == INVALID_HANDLE_VALUE )
+    {
+      FreeLibrary(hInstLib);
+      return 704;
+    }
+
+    // Get the first process' information.
+    procentry.dwSize = sizeof(PROCESSENTRY32);
+    bResult=lpfProcess32First(hSnapShot,&amp;procentry);
+
+    // While there are processes, keep looping and checking.
+    while(bResult)
+    {
+      // Get a handle to a Toolhelp snapshot of this process.
+      hSnapShotm = lpfCreateToolhelp32Snapshot(
+            TH32CS_SNAPMODULE, procentry.th32ProcessID) ;
+      if( hSnapShotm == INVALID_HANDLE_VALUE )
+      {
+        CloseHandle(hSnapShot);
+        FreeLibrary(hInstLib);
+        return 704;
+      }
+      // Get the module list for this process
+      modentry.dwSize=sizeof(MODULEENTRY32);
+      bResultm=lpfModule32First(hSnapShotm,&amp;modentry);
+
+      // While there are modules, keep looping and checking
+      while(bResultm)
+      {
+        if(strcmp(modentry.szModule,szToTermUpper)==0)
+        {
+          // Process found, now terminate it
+          iFound=1;
+          // First open for termination
+          hProc=OpenProcess(PROCESS_TERMINATE,FALSE,procentry.th32ProcessID);
+          if(hProc)
+          {
+            if(TerminateProcess(hProc,0))
+            {
+              // process terminated
+              CloseHandle(hSnapShotm);
+              CloseHandle(hSnapShot);
+              CloseHandle(hProc);
+              FreeLibrary(hInstLib);
+              return 0;
+            }
+            else
+            {
+              // Unable to terminate process
+              CloseHandle(hSnapShotm);
+              CloseHandle(hSnapShot);
+              CloseHandle(hProc);
+              FreeLibrary(hInstLib);
+              return 602;
+            }
+          }
+          else
+          {
+            // Unable to open process for termination
+            CloseHandle(hSnapShotm);
+            CloseHandle(hSnapShot);
+            FreeLibrary(hInstLib);
+            return 604;
+          }
+        }
+        else
+        {  // Look for next modules for this process
+          modentry.dwSize=sizeof(MODULEENTRY32);
+          bResultm=lpfModule32Next(hSnapShotm,&amp;modentry);
+        }
+      }
+
+      //Keep looking
+      CloseHandle(hSnapShotm);
+      procentry.dwSize = sizeof(PROCESSENTRY32);
+      bResult = lpfProcess32Next(hSnapShot,&amp;procentry);
+    }
+    CloseHandle(hSnapShot);
+  }
+  if(iFound==0)
+  {
+    FreeLibrary(hInstLib);
+    return 603;
+  }
+  FreeLibrary(hInstLib);
+  return 0;
+}

Modified: branches/wsjtx/lib/afc65b.f90
===================================================================
--- branches/wsjtx/lib/afc65b.f90	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/lib/afc65b.f90	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,59 +1,59 @@
-subroutine afc65b(cx,npts,fsample,nflip,a,ccfbest,dtbest)
-
-! Find delta f, f1, f2 ==&gt; a(1:3)
-
-  complex cx(npts)
-  real a(5),deltaa(5)
-
-  a(1)=0.
-  a(2)=0.
-  a(3)=0.
-  a(4)=0.
-  deltaa(1)=2.0
-  deltaa(2)=2.0
-  deltaa(3)=2.0
-  deltaa(4)=0.05
-  nterms=3                                  !Maybe 2 is enough?
-
-!  Start the iteration
-  chisqr=0.
-  chisqr0=1.e6
-  do iter=1,3                               !One iteration is enough?
-     do j=1,nterms
-        chisq1=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
-        fn=0.
-        delta=deltaa(j)
-10      a(j)=a(j)+delta
-        chisq2=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
-        if(chisq2.eq.chisq1) go to 10
-        if(chisq2.gt.chisq1) then
-           delta=-delta                      !Reverse direction
-           a(j)=a(j)+delta
-           tmp=chisq1
-           chisq1=chisq2
-           chisq2=tmp
-        endif
-20      fn=fn+1.0
-        a(j)=a(j)+delta
-        chisq3=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
-        if(chisq3.lt.chisq2) then
-           chisq1=chisq2
-           chisq2=chisq3
-           go to 20
-        endif
-
-! Find minimum of parabola defined by last three points
-        delta=delta*(1./(1.+(chisq1-chisq2)/(chisq3-chisq2))+0.5)
-        a(j)=a(j)-delta
-        deltaa(j)=deltaa(j)*fn/3.
-     enddo
-     chisqr=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
-     if(chisqr/chisqr0.gt.0.9999) go to 30
-     chisqr0=chisqr
-  enddo
-
-30 ccfbest=ccfmax * (1378.125/fsample)**2
-  dtbest=dtmax
-
-  return
-end subroutine afc65b
+subroutine afc65b(cx,npts,fsample,nflip,a,ccfbest,dtbest)
+
+! Find delta f, f1, f2 ==&gt; a(1:3)
+
+  complex cx(npts)
+  real a(5),deltaa(5)
+
+  a(1)=0.
+  a(2)=0.
+  a(3)=0.
+  a(4)=0.
+  deltaa(1)=2.0
+  deltaa(2)=2.0
+  deltaa(3)=2.0
+  deltaa(4)=0.05
+  nterms=3                                  !Maybe 2 is enough?
+
+!  Start the iteration
+  chisqr=0.
+  chisqr0=1.e6
+  do iter=1,3                               !One iteration is enough?
+     do j=1,nterms
+        chisq1=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
+        fn=0.
+        delta=deltaa(j)
+10      a(j)=a(j)+delta
+        chisq2=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
+        if(chisq2.eq.chisq1) go to 10
+        if(chisq2.gt.chisq1) then
+           delta=-delta                      !Reverse direction
+           a(j)=a(j)+delta
+           tmp=chisq1
+           chisq1=chisq2
+           chisq2=tmp
+        endif
+20      fn=fn+1.0
+        a(j)=a(j)+delta
+        chisq3=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
+        if(chisq3.lt.chisq2) then
+           chisq1=chisq2
+           chisq2=chisq3
+           go to 20
+        endif
+
+! Find minimum of parabola defined by last three points
+        delta=delta*(1./(1.+(chisq1-chisq2)/(chisq3-chisq2))+0.5)
+        a(j)=a(j)-delta
+        deltaa(j)=deltaa(j)*fn/3.
+     enddo
+     chisqr=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
+     if(chisqr/chisqr0.gt.0.9999) go to 30
+     chisqr0=chisqr
+  enddo
+
+30 ccfbest=ccfmax * (1378.125/fsample)**2
+  dtbest=dtmax
+
+  return
+end subroutine afc65b

Modified: branches/wsjtx/lib/afc9.f90
===================================================================
--- branches/wsjtx/lib/afc9.f90	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/lib/afc9.f90	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,58 +1,58 @@
-subroutine afc9(c3,npts,fsample,a,syncpk)
-
-  complex c3(0:npts-1)
-  real a(3),deltaa(3)
-
-  a(1)=0.                                   !f0
-  a(2)=0.                                   !f1
-  a(3)=0.                                   !f2
-  deltaa(1)=0.2
-  deltaa(2)=0.01
-  deltaa(3)=0.01
-  nterms=3
-
-! Start the iteration
-  chisqr=0.
-  chisqr0=1.e6
-  do iter=1,4                               !One iteration is enough?
-     do j=1,nterms
-        chisq1=fchisq(c3,npts,fsample,a)
-        fn=0.
-        delta=deltaa(j)
-10      a(j)=a(j)+delta
-        chisq2=fchisq(c3,npts,fsample,a)
-        if(chisq2.eq.chisq1) go to 10
-        if(chisq2.gt.chisq1) then
-           delta=-delta                      !Reverse direction
-           a(j)=a(j)+delta
-           tmp=chisq1
-           chisq1=chisq2
-           chisq2=tmp
-        endif
-20      fn=fn+1.0
-        a(j)=a(j)+delta
-        chisq3=fchisq(c3,npts,fsample,a)
-        if(chisq3.lt.chisq2) then
-           chisq1=chisq2
-           chisq2=chisq3
-           go to 20
-        endif
-
-! Find minimum of parabola defined by last three points
-        delta=delta*(1./(1.+(chisq1-chisq2)/(chisq3-chisq2))+0.5)
-        a(j)=a(j)-delta
-        deltaa(j)=deltaa(j)*fn/3.
-!        write(*,4000) iter,j,a,deltaa,-chisq2
-!4000    format(i1,i2,6f10.4,f9.3)
-     enddo
-     chisqr=fchisq(c3,npts,fsample,a)
-     if(chisqr/chisqr0.gt.0.9999) exit
-     chisqr0=chisqr
-  enddo
-
-  syncpk=-chisqr
-!  write(*,4001) a,deltaa,-chisq2
-!4001 format(3x,6f10.4,f9.3)
-
-  return
-end subroutine afc9
+subroutine afc9(c3,npts,fsample,a,syncpk)
+
+  complex c3(0:npts-1)
+  real a(3),deltaa(3)
+
+  a(1)=0.                                   !f0
+  a(2)=0.                                   !f1
+  a(3)=0.                                   !f2
+  deltaa(1)=0.2
+  deltaa(2)=0.01
+  deltaa(3)=0.01
+  nterms=3
+
+! Start the iteration
+  chisqr=0.
+  chisqr0=1.e6
+  do iter=1,4                               !One iteration is enough?
+     do j=1,nterms
+        chisq1=fchisq(c3,npts,fsample,a)
+        fn=0.
+        delta=deltaa(j)
+10      a(j)=a(j)+delta
+        chisq2=fchisq(c3,npts,fsample,a)
+        if(chisq2.eq.chisq1) go to 10
+        if(chisq2.gt.chisq1) then
+           delta=-delta                      !Reverse direction
+           a(j)=a(j)+delta
+           tmp=chisq1
+           chisq1=chisq2
+           chisq2=tmp
+        endif
+20      fn=fn+1.0
+        a(j)=a(j)+delta
+        chisq3=fchisq(c3,npts,fsample,a)
+        if(chisq3.lt.chisq2) then
+           chisq1=chisq2
+           chisq2=chisq3
+           go to 20
+        endif
+
+! Find minimum of parabola defined by last three points
+        delta=delta*(1./(1.+(chisq1-chisq2)/(chisq3-chisq2))+0.5)
+        a(j)=a(j)-delta
+        deltaa(j)=deltaa(j)*fn/3.
+!        write(*,4000) iter,j,a,deltaa,-chisq2
+!4000    format(i1,i2,6f10.4,f9.3)
+     enddo
+     chisqr=fchisq(c3,npts,fsample,a)
+     if(chisqr/chisqr0.gt.0.9999) exit
+     chisqr0=chisqr
+  enddo
+
+  syncpk=-chisqr
+!  write(*,4001) a,deltaa,-chisq2
+!4001 format(3x,6f10.4,f9.3)
+
+  return
+end subroutine afc9

Modified: branches/wsjtx/lib/gran.c
===================================================================
--- branches/wsjtx/lib/gran.c	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/lib/gran.c	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,28 +1,28 @@
-#include &lt;stdlib.h&gt;
-#include &lt;math.h&gt;
-
-/* Generate gaussian random float with mean=0 and std_dev=1 */
-float gran_()
-{
-  float fac,rsq,v1,v2;
-  static float gset;
-  static int iset;
-
-  if(iset){
-    /* Already got one */
-    iset = 0;
-    return gset;
-  }
-  /* Generate two evenly distributed numbers between -1 and +1
-   * that are inside the unit circle
-   */
-  do {
-    v1 = 2.0 * (float)rand() / RAND_MAX - 1;
-    v2 = 2.0 * (float)rand() / RAND_MAX - 1;
-    rsq = v1*v1 + v2*v2;
-  } while(rsq &gt;= 1.0 || rsq == 0.0);
-  fac = sqrt(-2.0*log(rsq)/rsq);
-  gset = v1*fac;
-  iset++;
-  return v2*fac;
-}
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+/* Generate gaussian random float with mean=0 and std_dev=1 */
+float gran_()
+{
+  float fac,rsq,v1,v2;
+  static float gset;
+  static int iset;
+
+  if(iset){
+    /* Already got one */
+    iset = 0;
+    return gset;
+  }
+  /* Generate two evenly distributed numbers between -1 and +1
+   * that are inside the unit circle
+   */
+  do {
+    v1 = 2.0 * (float)rand() / RAND_MAX - 1;
+    v2 = 2.0 * (float)rand() / RAND_MAX - 1;
+    rsq = v1*v1 + v2*v2;
+  } while(rsq &gt;= 1.0 || rsq == 0.0);
+  fac = sqrt(-2.0*log(rsq)/rsq);
+  gset = v1*fac;
+  iset++;
+  return v2*fac;
+}

Modified: branches/wsjtx/lib/usleep.c
===================================================================
--- branches/wsjtx/lib/usleep.c	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/lib/usleep.c	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,5 +1,5 @@
-/* usleep(3) */
-void usleep_(unsigned long *microsec)
-{
-  usleep(*microsec);
-}
+/* usleep(3) */
+void usleep_(unsigned long *microsec)
+{
+  usleep(*microsec);
+}

Modified: branches/wsjtx/lib/wrapkarn.c
===================================================================
--- branches/wsjtx/lib/wrapkarn.c	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/lib/wrapkarn.c	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,70 +1,70 @@
-#include &lt;math.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;float.h&gt;
-#include &lt;limits.h&gt;
-#include &lt;stdlib.h&gt;
-#include &quot;rs.h&quot;
-
-static void *rs;
-static int first=1;
-
-void rs_encode_(int *dgen, int *sent)
-// Encode JT65 data dgen[12], producing sent[63].
-{
-  int dat1[12];
-  int b[51];
-  int i;
-
-  if(first) {
-    // Initialize the JT65 codec
-    rs=init_rs_int(6,0x43,3,1,51,0);
-    first=0;
-  }
-
-  // Reverse data order for the Karn codec.
-  for(i=0; i&lt;12; i++) {
-    dat1[i]=dgen[11-i];
-  }
-  // Compute the parity symbols
-  encode_rs_int(rs,dat1,b);
-
-  // Move parity symbols and data into sent[] array, in reverse order.
-  for (i = 0; i &lt; 51; i++) sent[50-i] = b[i];
-  for (i = 0; i &lt; 12; i++) sent[i+51] = dat1[11-i];
-}
-
-void rs_decode_(int *recd0, int *era0, int *numera0, int *decoded, int *nerr)
-// Decode JT65 received data recd0[63], producing decoded[12].
-// Erasures are indicated in era0[numera].  The number of corrected
-// errors is *nerr.  If the data are uncorrectable, *nerr=-1 is returned.
-{
-  int numera;
-  int i;
-  int era_pos[50];
-  int recd[63];
-
-  if(first) {
-    rs=init_rs_int(6,0x43,3,1,51,0);
-    first=0;
-  }
-
-  numera=*numera0;
-  for(i=0; i&lt;12; i++) recd[i]=recd0[62-i];
-  for(i=0; i&lt;51; i++) recd[12+i]=recd0[50-i];
-  if(numera) 
-    for(i=0; i&lt;numera; i++) era_pos[i]=era0[i];
-  *nerr=decode_rs_int(rs,recd,era_pos,numera);
-  for(i=0; i&lt;12; i++) decoded[i]=recd[11-i];
-}
-
-
-void rs_encode__(int *dgen, int *sent)
-{
-  rs_encode_(dgen, sent);
-}
-
-void rs_decode__(int *recd0, int *era0, int *numera0, int *decoded, int *nerr)
-{
-  rs_decode_(recd0, era0, numera0, decoded, nerr);
-}
-
+#include &lt;math.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;float.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;rs.h&quot;
+
+static void *rs;
+static int first=1;
+
+void rs_encode_(int *dgen, int *sent)
+// Encode JT65 data dgen[12], producing sent[63].
+{
+  int dat1[12];
+  int b[51];
+  int i;
+
+  if(first) {
+    // Initialize the JT65 codec
+    rs=init_rs_int(6,0x43,3,1,51,0);
+    first=0;
+  }
+
+  // Reverse data order for the Karn codec.
+  for(i=0; i&lt;12; i++) {
+    dat1[i]=dgen[11-i];
+  }
+  // Compute the parity symbols
+  encode_rs_int(rs,dat1,b);
+
+  // Move parity symbols and data into sent[] array, in reverse order.
+  for (i = 0; i &lt; 51; i++) sent[50-i] = b[i];
+  for (i = 0; i &lt; 12; i++) sent[i+51] = dat1[11-i];
+}
+
+void rs_decode_(int *recd0, int *era0, int *numera0, int *decoded, int *nerr)
+// Decode JT65 received data recd0[63], producing decoded[12].
+// Erasures are indicated in era0[numera].  The number of corrected
+// errors is *nerr.  If the data are uncorrectable, *nerr=-1 is returned.
+{
+  int numera;
+  int i;
+  int era_pos[50];
+  int recd[63];
+
+  if(first) {
+    rs=init_rs_int(6,0x43,3,1,51,0);
+    first=0;
+  }
+
+  numera=*numera0;
+  for(i=0; i&lt;12; i++) recd[i]=recd0[62-i];
+  for(i=0; i&lt;51; i++) recd[12+i]=recd0[50-i];
+  if(numera) 
+    for(i=0; i&lt;numera; i++) era_pos[i]=era0[i];
+  *nerr=decode_rs_int(rs,recd,era_pos,numera);
+  for(i=0; i&lt;12; i++) decoded[i]=recd[11-i];
+}
+
+
+void rs_encode__(int *dgen, int *sent)
+{
+  rs_encode_(dgen, sent);
+}
+
+void rs_decode__(int *recd0, int *era0, int *numera0, int *decoded, int *nerr)
+{
+  rs_decode_(recd0, era0, numera0, decoded, nerr);
+}
+

Modified: branches/wsjtx/logqso.cpp
===================================================================
--- branches/wsjtx/logqso.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/logqso.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,174 +1,197 @@
-#include &quot;logqso.h&quot;
-#include &quot;ui_logqso.h&quot;
-#include &lt;QString&gt;
-#include &lt;QDebug&gt;
-
-
-LogQSO::LogQSO(QWidget *parent) :
-  QDialog(parent),
-  ui(new Ui::LogQSO)
-{
-  ui-&gt;setupUi(this);
-}
-
-LogQSO::~LogQSO()
-{
-  delete ui;
-}
-
-void LogQSO::initLogQSO(QString hisCall, QString hisGrid, QString mode,
-                        QString rptSent, QString rptRcvd, QDateTime dateTime,
-                        double dialFreq, QString myCall, QString myGrid,
-                        bool noSuffix, bool toRTTY, bool dBtoComments)
-{
-  ui-&gt;call-&gt;setText(hisCall);
-  ui-&gt;grid-&gt;setText(hisGrid);
-  ui-&gt;txPower-&gt;setText(&quot;&quot;);
-  ui-&gt;comments-&gt;setText(&quot;&quot;);
-  if(m_saveTxPower) ui-&gt;txPower-&gt;setText(m_txPower);
-  if(m_saveComments) ui-&gt;comments-&gt;setText(m_comments);
-  if(dBtoComments) {
-    QString t=mode;
-    if(rptSent!=&quot;&quot;) t+=&quot;  Sent: &quot; + rptSent;
-    if(rptRcvd!=&quot;&quot;) t+=&quot;  Rcvd: &quot; + rptRcvd;
-    ui-&gt;comments-&gt;setText(t);
-  }
-  if(noSuffix and mode.mid(0,3)==&quot;JT9&quot;) mode=&quot;JT9&quot;;
-  if(toRTTY and mode.mid(0,3)==&quot;JT9&quot;) mode=&quot;RTTY&quot;;
-  ui-&gt;mode-&gt;setText(mode);
-  ui-&gt;sent-&gt;setText(rptSent);
-  ui-&gt;rcvd-&gt;setText(rptRcvd);
-  m_dateTime=dateTime;
-  QString date=dateTime.toString(&quot;yyyy-MM-dd&quot;);
-  ui-&gt;date-&gt;setText(date);
-  QString time=dateTime.toString(&quot;hhmm&quot;);
-  ui-&gt;time-&gt;setText(time);
-  m_dialFreq=dialFreq;
-  m_myCall=myCall;
-  m_myGrid=myGrid;
-  QString band=&quot;&quot;;
-  if(dialFreq&gt;0.135 and dialFreq&lt;0.139) band=&quot;2200m&quot;;
-  if(dialFreq&gt;0.45 and dialFreq&lt;0.55) band=&quot;630m&quot;;
-  if(dialFreq&gt;1.8 and dialFreq&lt;2.0) band=&quot;160m&quot;;
-  if(dialFreq&gt;3.5 and dialFreq&lt;4.0) band=&quot;80m&quot;;
-  if(dialFreq&gt;5.1 and dialFreq&lt;5.45) band=&quot;60m&quot;;
-  if(dialFreq&gt;7.0 and dialFreq&lt;7.3) band=&quot;40m&quot;;
-  if(dialFreq&gt;10.0 and dialFreq&lt;10.15) band=&quot;30m&quot;;
-  if(dialFreq&gt;14.0 and dialFreq&lt;14.35) band=&quot;20m&quot;;
-  if(dialFreq&gt;18.068 and dialFreq&lt;18.168) band=&quot;17m&quot;;
-  if(dialFreq&gt;21.0 and dialFreq&lt;21.45) band=&quot;15m&quot;;
-  if(dialFreq&gt;24.890 and dialFreq&lt;24.990) band=&quot;12m&quot;;
-  if(dialFreq&gt;28.0 and dialFreq&lt;29.7) band=&quot;10m&quot;;
-  if(dialFreq&gt;50.0 and dialFreq&lt;54.0) band=&quot;6m&quot;;
-  if(dialFreq&gt;70.0 and dialFreq&lt;71.0) band=&quot;4m&quot;;
-  if(dialFreq&gt;144.0 and dialFreq&lt;148.0) band=&quot;2m&quot;;
-  if(dialFreq&gt;222.0 and dialFreq&lt;225.0) band=&quot;1.25m&quot;;
-  if(dialFreq&gt;420.0 and dialFreq&lt;450.0) band=&quot;70cm&quot;;
-  if(dialFreq&gt;902.0 and dialFreq&lt;928.0) band=&quot;33cm&quot;;
-  if(dialFreq&gt;1240.0 and dialFreq&lt;1300.0) band=&quot;23cm&quot;;
-  if(dialFreq&gt;2300.0 and dialFreq&lt;2450.0) band=&quot;13cm&quot;;
-  if(dialFreq&gt;3300.0 and dialFreq&lt;3500.0) band=&quot;9cm&quot;;
-  if(dialFreq&gt;5650.0 and dialFreq&lt;5925.0) band=&quot;6cm&quot;;
-  if(dialFreq&gt;10000.0 and dialFreq&lt;10500.0) band=&quot;3cm&quot;;
-  if(dialFreq&gt;24000.0 and dialFreq&lt;24250.0) band=&quot;1.25cm&quot;;
-  if(dialFreq&gt;47000.0 and dialFreq&lt;47200.0) band=&quot;6mm&quot;;
-  if(dialFreq&gt;75500.0 and dialFreq&lt;81000.0) band=&quot;4mm&quot;;
-  ui-&gt;band-&gt;setText(band);
-  ui-&gt;cbTxPower-&gt;setChecked(m_saveTxPower);
-  ui-&gt;cbComments-&gt;setChecked(m_saveComments);
-}
-
-void LogQSO::accept()
-{
-  QString hisCall,hisGrid,mode,rptSent,rptRcvd,date,time,band;
-  QString comments,name;
-
-  hisCall=ui-&gt;call-&gt;text();
-  hisGrid=ui-&gt;grid-&gt;text();
-  mode=ui-&gt;mode-&gt;text();
-  rptSent=ui-&gt;sent-&gt;text();
-  rptRcvd=ui-&gt;rcvd-&gt;text();
-  date=ui-&gt;date-&gt;text();
-  date=date.mid(0,4) + date.mid(5,2) + date.mid(8,2);
-  time=ui-&gt;time-&gt;text();
-  band=ui-&gt;band-&gt;text();
-  name=ui-&gt;name-&gt;text();
-  m_txPower=ui-&gt;txPower-&gt;text();
-  comments=ui-&gt;comments-&gt;text();
-  m_comments=comments;
-  QString strDialFreq(QString::number(m_dialFreq,'f',6));
-
-//Log this QSO to file &quot;wsjtx_log.adi&quot;
-  QFile f2(&quot;wsjtx_log.adi&quot;);
-  if(!f2.open(QIODevice::Text | QIODevice::Append)) {
-    QMessageBox m;
-    m.setText(&quot;Cannot open file \&quot;wsjtx_log.adi\&quot;.&quot;);
-    m.exec();
-  } else {
-    QTextStream out(&amp;f2);
-    if(f2.size()==0) out &lt;&lt; &quot;WSJT-X ADIF Export&lt;eoh&gt;&quot; &lt;&lt; endl;
-
-    QString t;
-    t=&quot;&lt;call:&quot; + QString::number(hisCall.length()) + &quot;&gt;&quot; + hisCall;
-    t+=&quot; &lt;gridsquare:&quot; + QString::number(hisGrid.length()) + &quot;&gt;&quot; + hisGrid;
-    t+=&quot; &lt;mode:&quot; + QString::number(mode.length()) + &quot;&gt;&quot; + mode;
-    t+=&quot; &lt;rst_sent:&quot; + QString::number(rptSent.length()) + &quot;&gt;&quot; + rptSent;
-    t+=&quot; &lt;rst_rcvd:&quot; + QString::number(rptRcvd.length()) + &quot;&gt;&quot; + rptRcvd;
-    t+=&quot; &lt;qso_date:8&gt;&quot; + date;
-    t+=&quot; &lt;time_on:4&gt;&quot; + time;
-    t+=&quot; &lt;band:&quot; + QString::number(band.length()) + &quot;&gt;&quot; + band;
-    t+=&quot; &lt;freq:&quot; + QString::number(strDialFreq.length()) + &quot;&gt;&quot; + strDialFreq;
-    t+=&quot; &lt;station_callsign:&quot; + QString::number(m_myCall.length()) + &quot;&gt;&quot; +
-        m_myCall;
-    t+=&quot; &lt;my_gridsquare:&quot; + QString::number(m_myGrid.length()) + &quot;&gt;&quot; +
-        m_myGrid;
-    if(m_txPower!=&quot;&quot;) t+= &quot; &lt;tx_pwr:&quot; + QString::number(m_txPower.length()) +
-        &quot;&gt;&quot; + m_txPower;
-    if(comments!=&quot;&quot;) t+=&quot; &lt;comment:&quot; + QString::number(comments.length()) +
-        &quot;&gt;&quot; + comments;
-    if(name!=&quot;&quot;) t+=&quot; &lt;name:&quot; + QString::number(name.length()) +
-        &quot;&gt;&quot; + name;
-    t+=&quot; &lt;eor&gt;&quot;;
-    out &lt;&lt; t &lt;&lt; endl;
-    f2.close();
-  }
-
-//Log this QSO to file &quot;wsjtx.log&quot;
-  QFile f(&quot;wsjtx.log&quot;);
-  if(!f.open(QIODevice::Text | QIODevice::Append)) {
-    QMessageBox m;
-    m.setText(&quot;Cannot open file \&quot;wsjtx.log\&quot;.&quot;);
-    m.exec();
-  } else {
-    QString logEntry=m_dateTime.date().toString(&quot;yyyy-MMM-dd,&quot;) +
-           m_dateTime.time().toString(&quot;hh:mm,&quot;) + hisCall + &quot;,&quot; +
-           hisGrid + &quot;,&quot; + strDialFreq + &quot;,&quot; + mode +
-               &quot;,&quot; + rptSent + &quot;,&quot; + rptRcvd;
-       if(m_txPower!=&quot;&quot;) logEntry += &quot;,&quot; + m_txPower;
-       if(comments!=&quot;&quot;) logEntry += &quot;,&quot; + comments;
-       if(name!=&quot;&quot;) logEntry += &quot;,&quot; + name;
-    QTextStream out(&amp;f);
-    out &lt;&lt; logEntry &lt;&lt; endl;
-    f.close();
-  }
-
-//Clean up and finish logging
-  emit(acceptQSO(true));
-  QDialog::accept();
-}
-
-void LogQSO::reject()
-{
-  emit(acceptQSO(false));
-  QDialog::reject();
-}
-
-void LogQSO::on_cbTxPower_toggled(bool checked)
-{
-  m_saveTxPower=checked;
-}
-
-void LogQSO::on_cbComments_toggled(bool checked)
-{
-  m_saveComments=checked;
-}
+#include &quot;logqso.h&quot;
+#include &quot;ui_logqso.h&quot;
+#include &lt;QString&gt;
+#include &lt;QDebug&gt;
+
+
+LogQSO::LogQSO(QSettings * settings, QWidget *parent) :
+  QDialog(parent),
+  ui(new Ui::LogQSO),
+  m_settings (settings)
+{
+  ui-&gt;setupUi(this);
+
+  loadSettings ();
+}
+
+LogQSO::~LogQSO ()
+{
+}
+
+void LogQSO::loadSettings ()
+{
+  m_settings-&gt;beginGroup (&quot;LogQSO&quot;);
+  restoreGeometry (m_settings-&gt;value (&quot;geometry&quot;, saveGeometry ()).toByteArray ());
+  ui-&gt;cbTxPower-&gt;setChecked (m_settings-&gt;value (&quot;SaveTxPower&quot;, false).toBool ());
+  ui-&gt;cbComments-&gt;setChecked (m_settings-&gt;value (&quot;SaveComments&quot;, false).toBool ());
+  m_txPower = m_settings-&gt;value (&quot;TxPower&quot;, &quot;&quot;).toString ();
+  m_comments = m_settings-&gt;value (&quot;LogComments&quot;, &quot;&quot;).toString();
+  m_settings-&gt;endGroup ();
+}
+
+void LogQSO::storeSettings () const
+{
+  m_settings-&gt;beginGroup (&quot;LogQSO&quot;);
+  m_settings-&gt;setValue (&quot;geometry&quot;, saveGeometry ());
+  m_settings-&gt;setValue (&quot;SaveTxPower&quot;, ui-&gt;cbTxPower-&gt;isChecked ());
+  m_settings-&gt;setValue (&quot;SaveComments&quot;, ui-&gt;cbComments-&gt;isChecked ());
+  m_settings-&gt;setValue (&quot;TxPower&quot;, m_txPower);
+  m_settings-&gt;setValue (&quot;LogComments&quot;, m_comments);
+  m_settings-&gt;endGroup ();
+}
+
+void LogQSO::initLogQSO(QString hisCall, QString hisGrid, QString mode,
+                        QString rptSent, QString rptRcvd, QDateTime dateTime,
+                        double dialFreq, QString myCall, QString myGrid,
+                        bool noSuffix, bool toRTTY, bool dBtoComments)
+{
+  ui-&gt;call-&gt;setText(hisCall);
+  ui-&gt;grid-&gt;setText(hisGrid);
+  ui-&gt;txPower-&gt;setText(&quot;&quot;);
+  ui-&gt;comments-&gt;setText(&quot;&quot;);
+  if (ui-&gt;cbTxPower-&gt;isChecked ()) ui-&gt;txPower-&gt;setText(m_txPower);
+  if (ui-&gt;cbComments-&gt;isChecked ()) ui-&gt;comments-&gt;setText(m_comments);
+  if(dBtoComments) {
+    QString t=mode;
+    if(rptSent!=&quot;&quot;) t+=&quot;  Sent: &quot; + rptSent;
+    if(rptRcvd!=&quot;&quot;) t+=&quot;  Rcvd: &quot; + rptRcvd;
+    ui-&gt;comments-&gt;setText(t);
+  }
+  if(noSuffix and mode.mid(0,3)==&quot;JT9&quot;) mode=&quot;JT9&quot;;
+  if(toRTTY and mode.mid(0,3)==&quot;JT9&quot;) mode=&quot;RTTY&quot;;
+  ui-&gt;mode-&gt;setText(mode);
+  ui-&gt;sent-&gt;setText(rptSent);
+  ui-&gt;rcvd-&gt;setText(rptRcvd);
+  m_dateTime=dateTime;
+  QString date=dateTime.toString(&quot;yyyy-MM-dd&quot;);
+  ui-&gt;date-&gt;setText(date);
+  QString time=dateTime.toString(&quot;hhmm&quot;);
+  ui-&gt;time-&gt;setText(time);
+  m_dialFreq=dialFreq;
+  m_myCall=myCall;
+  m_myGrid=myGrid;
+  QString band=&quot;&quot;;
+  if(dialFreq&gt;0.135 and dialFreq&lt;0.139) band=&quot;2200m&quot;;
+  if(dialFreq&gt;0.45 and dialFreq&lt;0.55) band=&quot;630m&quot;;
+  if(dialFreq&gt;1.8 and dialFreq&lt;2.0) band=&quot;160m&quot;;
+  if(dialFreq&gt;3.5 and dialFreq&lt;4.0) band=&quot;80m&quot;;
+  if(dialFreq&gt;5.1 and dialFreq&lt;5.45) band=&quot;60m&quot;;
+  if(dialFreq&gt;7.0 and dialFreq&lt;7.3) band=&quot;40m&quot;;
+  if(dialFreq&gt;10.0 and dialFreq&lt;10.15) band=&quot;30m&quot;;
+  if(dialFreq&gt;14.0 and dialFreq&lt;14.35) band=&quot;20m&quot;;
+  if(dialFreq&gt;18.068 and dialFreq&lt;18.168) band=&quot;17m&quot;;
+  if(dialFreq&gt;21.0 and dialFreq&lt;21.45) band=&quot;15m&quot;;
+  if(dialFreq&gt;24.890 and dialFreq&lt;24.990) band=&quot;12m&quot;;
+  if(dialFreq&gt;28.0 and dialFreq&lt;29.7) band=&quot;10m&quot;;
+  if(dialFreq&gt;50.0 and dialFreq&lt;54.0) band=&quot;6m&quot;;
+  if(dialFreq&gt;70.0 and dialFreq&lt;71.0) band=&quot;4m&quot;;
+  if(dialFreq&gt;144.0 and dialFreq&lt;148.0) band=&quot;2m&quot;;
+  if(dialFreq&gt;222.0 and dialFreq&lt;225.0) band=&quot;1.25m&quot;;
+  if(dialFreq&gt;420.0 and dialFreq&lt;450.0) band=&quot;70cm&quot;;
+  if(dialFreq&gt;902.0 and dialFreq&lt;928.0) band=&quot;33cm&quot;;
+  if(dialFreq&gt;1240.0 and dialFreq&lt;1300.0) band=&quot;23cm&quot;;
+  if(dialFreq&gt;2300.0 and dialFreq&lt;2450.0) band=&quot;13cm&quot;;
+  if(dialFreq&gt;3300.0 and dialFreq&lt;3500.0) band=&quot;9cm&quot;;
+  if(dialFreq&gt;5650.0 and dialFreq&lt;5925.0) band=&quot;6cm&quot;;
+  if(dialFreq&gt;10000.0 and dialFreq&lt;10500.0) band=&quot;3cm&quot;;
+  if(dialFreq&gt;24000.0 and dialFreq&lt;24250.0) band=&quot;1.25cm&quot;;
+  if(dialFreq&gt;47000.0 and dialFreq&lt;47200.0) band=&quot;6mm&quot;;
+  if(dialFreq&gt;75500.0 and dialFreq&lt;81000.0) band=&quot;4mm&quot;;
+  ui-&gt;band-&gt;setText(band);
+
+  show ();
+}
+
+void LogQSO::accept()
+{
+  QString hisCall,hisGrid,mode,rptSent,rptRcvd,date,time,band;
+  QString comments,name;
+
+  hisCall=ui-&gt;call-&gt;text();
+  hisGrid=ui-&gt;grid-&gt;text();
+  mode=ui-&gt;mode-&gt;text();
+  rptSent=ui-&gt;sent-&gt;text();
+  rptRcvd=ui-&gt;rcvd-&gt;text();
+  date=ui-&gt;date-&gt;text();
+  date=date.mid(0,4) + date.mid(5,2) + date.mid(8,2);
+  time=ui-&gt;time-&gt;text();
+  band=ui-&gt;band-&gt;text();
+  name=ui-&gt;name-&gt;text();
+  m_txPower=ui-&gt;txPower-&gt;text();
+  comments=ui-&gt;comments-&gt;text();
+  m_comments=comments;
+  QString strDialFreq(QString::number(m_dialFreq,'f',6));
+
+//Log this QSO to file &quot;wsjtx_log.adi&quot;
+  QFile f2(&quot;wsjtx_log.adi&quot;);
+  if(!f2.open(QIODevice::Text | QIODevice::Append)) {
+    QMessageBox m;
+    m.setText(&quot;Cannot open file \&quot;wsjtx_log.adi\&quot;.&quot;);
+    m.exec();
+  } else {
+    QTextStream out(&amp;f2);
+    if(f2.size()==0) out &lt;&lt; &quot;WSJT-X ADIF Export&lt;eoh&gt;&quot; &lt;&lt; endl;
+
+    QString t;
+    t=&quot;&lt;call:&quot; + QString::number(hisCall.length()) + &quot;&gt;&quot; + hisCall;
+    t+=&quot; &lt;gridsquare:&quot; + QString::number(hisGrid.length()) + &quot;&gt;&quot; + hisGrid;
+    t+=&quot; &lt;mode:&quot; + QString::number(mode.length()) + &quot;&gt;&quot; + mode;
+    t+=&quot; &lt;rst_sent:&quot; + QString::number(rptSent.length()) + &quot;&gt;&quot; + rptSent;
+    t+=&quot; &lt;rst_rcvd:&quot; + QString::number(rptRcvd.length()) + &quot;&gt;&quot; + rptRcvd;
+    t+=&quot; &lt;qso_date:8&gt;&quot; + date;
+    t+=&quot; &lt;time_on:4&gt;&quot; + time;
+    t+=&quot; &lt;band:&quot; + QString::number(band.length()) + &quot;&gt;&quot; + band;
+    t+=&quot; &lt;freq:&quot; + QString::number(strDialFreq.length()) + &quot;&gt;&quot; + strDialFreq;
+    t+=&quot; &lt;station_callsign:&quot; + QString::number(m_myCall.length()) + &quot;&gt;&quot; +
+        m_myCall;
+    t+=&quot; &lt;my_gridsquare:&quot; + QString::number(m_myGrid.length()) + &quot;&gt;&quot; +
+        m_myGrid;
+    if(m_txPower!=&quot;&quot;) t+= &quot; &lt;tx_pwr:&quot; + QString::number(m_txPower.length()) +
+        &quot;&gt;&quot; + m_txPower;
+    if(comments!=&quot;&quot;) t+=&quot; &lt;comment:&quot; + QString::number(comments.length()) +
+        &quot;&gt;&quot; + comments;
+    if(name!=&quot;&quot;) t+=&quot; &lt;name:&quot; + QString::number(name.length()) +
+        &quot;&gt;&quot; + name;
+    t+=&quot; &lt;eor&gt;&quot;;
+    out &lt;&lt; t &lt;&lt; endl;
+    f2.close();
+  }
+
+//Log this QSO to file &quot;wsjtx.log&quot;
+  QFile f(&quot;wsjtx.log&quot;);
+  if(!f.open(QIODevice::Text | QIODevice::Append)) {
+    QMessageBox m;
+    m.setText(&quot;Cannot open file \&quot;wsjtx.log\&quot;.&quot;);
+    m.exec();
+  } else {
+    QString logEntry=m_dateTime.date().toString(&quot;yyyy-MMM-dd,&quot;) +
+           m_dateTime.time().toString(&quot;hh:mm,&quot;) + hisCall + &quot;,&quot; +
+           hisGrid + &quot;,&quot; + strDialFreq + &quot;,&quot; + mode +
+               &quot;,&quot; + rptSent + &quot;,&quot; + rptRcvd;
+       if(m_txPower!=&quot;&quot;) logEntry += &quot;,&quot; + m_txPower;
+       if(comments!=&quot;&quot;) logEntry += &quot;,&quot; + comments;
+       if(name!=&quot;&quot;) logEntry += &quot;,&quot; + name;
+    QTextStream out(&amp;f);
+    out &lt;&lt; logEntry &lt;&lt; endl;
+    f.close();
+  }
+
+//Clean up and finish logging
+  emit(acceptQSO(true));
+  QDialog::accept();
+}
+
+void LogQSO::reject()
+{
+  emit(acceptQSO(false));
+  QDialog::reject();
+}
+
+// closeEvent is only called from the system menu close widget for a
+// modeless dialog so we use the hideEvent override to store the
+// window settings
+void LogQSO::hideEvent (QHideEvent * e)
+{
+  storeSettings ();
+  QDialog::hideEvent (e);
+}

Modified: branches/wsjtx/logqso.h
===================================================================
--- branches/wsjtx/logqso.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/logqso.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,53 +1,54 @@
-#ifndef LogQSO_H
-#define LogQSO_H
-
-#ifdef QT5
-#include &lt;QtWidgets&gt;
-#else
-#include &lt;QtGui&gt;
-#endif
-
-namespace Ui {
-class LogQSO;
-}
-
-class LogQSO : public QDialog
-{
-  Q_OBJECT
-
-public:
-  explicit LogQSO(QWidget *parent = 0);
-  ~LogQSO();
-  void initLogQSO(QString hisCall, QString hisGrid, QString mode,
-                  QString rptSent, QString rptRcvd, QDateTime dateTime,
-                  double dialFreq, QString myCall, QString myGrid,
-                  bool noSuffix, bool toRTTY, bool dBtoComments);
-
-  double m_dialFreq;
-
-  bool m_saveTxPower;
-  bool m_saveComments;
-
-  QString m_myCall;
-  QString m_myGrid;
-  QString m_txPower;
-  QString m_comments;
-
-  QDateTime m_dateTime;
-
-public slots:
-  void accept();
-  void reject();
-
-signals:
-  void acceptQSO(bool accepted);
-
-private slots:
-  void on_cbTxPower_toggled(bool checked);
-  void on_cbComments_toggled(bool checked);
-
-private:
-  Ui::LogQSO *ui;
-};
-
-#endif // LogQSO_H
+#ifndef LogQSO_H
+#define LogQSO_H
+
+#ifdef QT5
+#include &lt;QtWidgets&gt;
+#else
+#include &lt;QtGui&gt;
+#endif
+
+#include &lt;QScopedPointer&gt;
+
+namespace Ui {
+  class LogQSO;
+}
+
+class QSettings;
+
+class LogQSO : public QDialog
+{
+  Q_OBJECT
+
+public:
+  explicit LogQSO(QSettings *, QWidget *parent = 0);
+  ~LogQSO();
+  void initLogQSO(QString hisCall, QString hisGrid, QString mode,
+                  QString rptSent, QString rptRcvd, QDateTime dateTime,
+                  double dialFreq, QString myCall, QString myGrid,
+                  bool noSuffix, bool toRTTY, bool dBtoComments);
+
+public slots:
+  void accept();
+  void reject();
+
+signals:
+  void acceptQSO(bool accepted);
+
+protected:
+  void hideEvent (QHideEvent *);
+
+private:
+  void loadSettings ();
+  void storeSettings () const;
+
+  QScopedPointer&lt;Ui::LogQSO&gt; ui;
+  QSettings * m_settings;
+  QString m_txPower;
+  QString m_comments;
+  double m_dialFreq;
+  QString m_myCall;
+  QString m_myGrid;
+  QDateTime m_dateTime;
+};
+
+#endif // LogQSO_H

Modified: branches/wsjtx/main.cpp
===================================================================
--- branches/wsjtx/main.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/main.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -5,6 +5,7 @@
 #endif
 #include &lt;QApplication&gt;
 #include &lt;QObject&gt;
+#include &lt;QSettings&gt;
 
 #include &quot;mainwindow.h&quot;
 
@@ -18,6 +19,10 @@
 {
   QApplication a(argc, argv);
 
+  qRegisterMetaType&lt;AudioDevice::Channel&gt; (&quot;AudioDevice::Channel&quot;);
+
+  QSettings settings(a.applicationDirPath() + &quot;/wsjtx.ini&quot;, QSettings::IniFormat);
+
   QFile f(&quot;fonts.txt&quot;);
   qint32 fontSize,fontWeight,fontSize2,fontWeight2;   // Defaults 8 50 10 50
   fontSize2=10;
@@ -51,7 +56,7 @@
   memset(to,0,size);         //Zero all decoding params in shared memory
 
 // Multiple instances:  Call MainWindow() with the UUID key
-  MainWindow w(&amp;mem_jt9, &amp;my_key, fontSize2, fontWeight2);
+  MainWindow w(&amp;settings, &amp;mem_jt9, &amp;my_key, fontSize2, fontWeight2);
   w.show();
 
   QObject::connect (&amp;a, SIGNAL (lastWindowClosed()), &amp;a, SLOT (quit()));

Modified: branches/wsjtx/mainwindow.cpp
===================================================================
--- branches/wsjtx/mainwindow.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/mainwindow.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -15,7 +15,6 @@
 #include &quot;logqso.h&quot;
 
 #ifdef QT5
-#include &lt;QtConcurrent/QtConcurrentMap&gt;
 #include &lt;QtConcurrent/QtConcurrentRun&gt;
 #endif
 
@@ -30,8 +29,6 @@
 wchar_t buffer[256];
 
 
-WideGraph* g_pWideGraph = NULL;
-LogQSO* logDlg = NULL;
 Rig* rig = NULL;
 QTextEdit* pShortcuts;
 QTcpSocket* commanderSocket = new QTcpSocket(0);
@@ -42,49 +39,73 @@
 
 //-------------------------------------------------- MainWindow constructor
 // Multiple instances: new arg *thekey
-MainWindow::MainWindow(QSharedMemory *shdmem, QString *thekey, \
-                       qint32 fontSize2, qint32 fontWeight2, \
+MainWindow::MainWindow(QSettings * settings, QSharedMemory *shdmem, QString *thekey,
+                       qint32 fontSize2, qint32 fontWeight2,
                        QWidget *parent) :
   QMainWindow(parent),
+  m_settings (settings),
   ui(new Ui::MainWindow),
-  m_detector (RX_SAMPLE_RATE, NTMAX / 2, 6912 / 2 * sizeof (jt9com_.d2[0]), this),
+  m_wideGraph (new WideGraph (settings)),
+  m_logDlg (new LogQSO (settings, this)),
+  m_detector (RX_SAMPLE_RATE, NTMAX / 2, 6912 / 2, this),
   m_audioInputDevice (QAudioDeviceInfo::defaultInputDevice ()), // start with default
   m_modulator (TX_SAMPLE_RATE, NTMAX / 2),
   m_audioOutputDevice (QAudioDeviceInfo::defaultOutputDevice ()), // start with default
   m_soundOutput (&amp;m_modulator)
 {
   ui-&gt;setupUi(this);
-  m_detector.open ();
-  m_modulator.open ();
 
   connect (this, &amp;MainWindow::finished, this, &amp;MainWindow::close);
 
   // start sound out thread and hook up slots &amp; signals for shutdown management
+
+  // these two objects need to be in the other thread so that invoking
+  // their slots is done in a thread safe way
   m_soundOutput.moveToThread (&amp;m_soundOutputThread);
+  m_modulator.moveToThread (&amp;m_soundOutputThread);
+
   connect (this, &amp;MainWindow::finished, &amp;m_soundOutputThread, &amp;QThread::quit); // quit thread event loop
   connect (&amp;m_soundOutputThread, &amp;QThread::finished, &amp;m_soundOutputThread, &amp;QThread::deleteLater); // disposal
 
   // hook up sound output stream slots &amp; signals
-  connect (this, &amp;MainWindow::startAudioOutputStream, &amp;m_soundOutput, &amp;SoundOutput::startStream);
-  connect (this, &amp;MainWindow::stopAudioOutputStream, &amp;m_soundOutput, &amp;SoundOutput::stopStream);
+  connect (this, SIGNAL (startAudioOutputStream (QAudioDeviceInfo const&amp;, unsigned)), &amp;m_soundOutput, SLOT (startStream (QAudioDeviceInfo const&amp;, unsigned)));
+  connect (this, SIGNAL (stopAudioOutputStream ()), &amp;m_soundOutput, SLOT (stopStream ()));
   connect (&amp;m_soundOutput, &amp;SoundOutput::error, this, &amp;MainWindow::showSoundOutError);
   // connect (&amp;m_soundOutput, &amp;SoundOutput::status, this, &amp;MainWindow::showStatusMessage);
+  connect (this, SIGNAL (outAttenuationChanged (qreal)), &amp;m_soundOutput, SLOT (setAttenuation (qreal)));
 
   // hook up Modulator slots
-  connect (this, &amp;MainWindow::muteAudioOutput, &amp;m_modulator, &amp;Modulator::mute);
-  connect (this, &amp;MainWindow::transmitFrequency, &amp;m_modulator, &amp;Modulator::setFrequency);
-  connect (this, &amp;MainWindow::endTransmitMessage, &amp;m_modulator, &amp;Modulator::stop);
-  connect (this, &amp;MainWindow::tune, &amp;m_modulator, &amp;Modulator::tune);
+  connect (this, SIGNAL (muteAudioOutput (bool)), &amp;m_modulator, SLOT (mute (bool)));
+  connect (this, SIGNAL(transmitFrequency (unsigned)), &amp;m_modulator, SLOT (setFrequency (unsigned)));
+  connect (this, SIGNAL (endTransmitMessage ()), &amp;m_modulator, SLOT (close ()));
+  connect (this, SIGNAL (tune (bool)), &amp;m_modulator, SLOT (tune (bool)));
   connect (
 	   this
-	   , SIGNAL (sendMessage (unsigned, double, unsigned, bool, double))
+	   , SIGNAL (sendMessage (unsigned, double, unsigned, AudioDevice::Channel, bool, double))
 	   , &amp;m_modulator
-	   , SLOT (send (unsigned, double, unsigned, bool, double))
+	   , SLOT (open (unsigned, double, unsigned, AudioDevice::Channel, bool, double))
 	   );
 
   // start the sound output thread
   m_soundOutputThread.start (QThread::HighPriority);
 
+
+  // setup the waterfall
+  connect(m_wideGraph.data (), SIGNAL(freezeDecode2(int)),this,
+	  SLOT(freezeDecode(int)));
+  connect(m_wideGraph.data (), SIGNAL(f11f12(int)),this,
+	  SLOT(bumpFqso(int)));
+  connect(m_wideGraph.data (), SIGNAL(setXIT2(int)),this,
+	  SLOT(setXIT(int)));
+  //    connect(m_wideGraph.data (), SIGNAL(dialFreqChanged(double)),this,
+  //            SLOT(dialFreqChanged2(double)));
+  connect (this, &amp;MainWindow::finished, m_wideGraph.data (), &amp;WideGraph::close);
+
+
+  // setup the log QSO dialog
+  connect (m_logDlg.data (), SIGNAL (acceptQSO (bool)), this, SLOT (acceptQSO2 (bool)));
+
+
   on_EraseButton_clicked();
 
   QActionGroup* modeGroup = new QActionGroup(this);
@@ -117,7 +138,7 @@
           SLOT(doubleClickOnCall2(bool,bool)));
 
   setWindowTitle(Program_Title_Version);
-  connect(&amp;m_detector, &amp;Detector::bytesWritten, this, &amp;MainWindow::dataSink);
+  connect(&amp;m_detector, &amp;Detector::framesWritten, this, &amp;MainWindow::dataSink);
   connect(&amp;m_soundInput, SIGNAL(error(QString)), this,
           SLOT(showSoundInError(QString)));
   // connect(&amp;m_soundInput, SIGNAL(status(QString)), this,
@@ -165,6 +186,7 @@
 
   ptt0Timer = new QTimer(this);
   ptt0Timer-&gt;setSingleShot(true);
+  connect (ptt0Timer, SIGNAL (timeout ()), &amp;m_modulator, SLOT (close ()));
   connect(ptt0Timer, SIGNAL(timeout()), this, SLOT(stopTx2()));
   ptt1Timer = new QTimer(this);
   ptt1Timer-&gt;setSingleShot(true);
@@ -176,6 +198,7 @@
 
   tuneButtonTimer= new QTimer(this);
   tuneButtonTimer-&gt;setSingleShot(true);
+  connect (tuneButtonTimer, SIGNAL (timeout ()), &amp;m_modulator, SLOT (close ()));
   connect(tuneButtonTimer, SIGNAL(timeout()), this,
           SLOT(on_stopTxButton_clicked()));
 
@@ -318,15 +341,14 @@
   ui-&gt;txrb6-&gt;setChecked(true);
   if(m_mode!=&quot;JT9&quot; and m_mode!=&quot;JT65&quot; and m_mode!=&quot;JT9+JT65&quot;) m_mode=&quot;JT9&quot;;
   on_actionWide_Waterfall_triggered();                   //###
-  g_pWideGraph-&gt;setRxFreq(m_rxFreq);
-  g_pWideGraph-&gt;setTxFreq(m_txFreq);
-  g_pWideGraph-&gt;setLockTxFreq(m_lockTxFreq);
-  g_pWideGraph-&gt;setFmin(m_fMin);
-  g_pWideGraph-&gt;setModeTx(m_mode);
-  g_pWideGraph-&gt;setModeTx(m_modeTx);
+  m_wideGraph-&gt;setRxFreq(m_rxFreq);
+  m_wideGraph-&gt;setTxFreq(m_txFreq);
+  m_wideGraph-&gt;setLockTxFreq(m_lockTxFreq);
+  m_wideGraph-&gt;setModeTx(m_mode);
+  m_wideGraph-&gt;setModeTx(m_modeTx);
   dialFreqChanged2(m_dialFreq);
 
-  connect(g_pWideGraph, SIGNAL(setFreq3(int,int)),this,
+  connect(m_wideGraph.data (), SIGNAL(setFreq3(int,int)),this,
           SLOT(setFreq4(int,int)));
 
   if(m_mode==&quot;JT9&quot;) on_actionJT9_1_triggered();
@@ -341,7 +363,9 @@
   watcher2 = new QFutureWatcher&lt;void&gt;;
   connect(watcher2, SIGNAL(finished()),this,SLOT(diskWriteFinished()));
 
-  m_soundInput.start(m_audioInputDevice, RX_SAMPLE_RATE / 10, &amp;m_detector);
+  m_detector.open (m_audioInputChannel);
+  m_soundInput.start(m_audioInputDevice, AudioDevice::Mono == m_audioInputChannel ? 1 : 2, RX_SAMPLE_RATE / 10, &amp;m_detector);
+
   Q_EMIT transmitFrequency (m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0));
   Q_EMIT muteAudioOutput (false);
   m_monitoring=!m_monitorStartOFF;           // Start with Monitoring ON/OFF
@@ -400,125 +424,113 @@
 //-------------------------------------------------------- writeSettings()
 void MainWindow::writeSettings()
 {
-  QString inifile = m_appDir + &quot;/wsjtx.ini&quot;;
-  QSettings settings(inifile, QSettings::IniFormat);
+  m_settings-&gt;beginGroup(&quot;MainWindow&quot;);
+  m_settings-&gt;setValue (&quot;geometry&quot;, saveGeometry ());
+  m_settings-&gt;setValue (&quot;state&quot;, saveState ());
+  m_settings-&gt;setValue(&quot;MRUdir&quot;, m_path);
+  m_settings-&gt;setValue(&quot;TxFirst&quot;,m_txFirst);
+  m_settings-&gt;setValue(&quot;DXcall&quot;,ui-&gt;dxCallEntry-&gt;text());
+  m_settings-&gt;setValue(&quot;DXgrid&quot;,ui-&gt;dxGridEntry-&gt;text());
+  m_settings-&gt;endGroup();
 
-  settings.beginGroup(&quot;MainWindow&quot;);
-  settings.setValue(&quot;geometry&quot;, saveGeometry());
-  settings.setValue(&quot;MRUdir&quot;, m_path);
-  settings.setValue(&quot;TxFirst&quot;,m_txFirst);
-  settings.setValue(&quot;DXcall&quot;,ui-&gt;dxCallEntry-&gt;text());
-  settings.setValue(&quot;DXgrid&quot;,ui-&gt;dxGridEntry-&gt;text());
-  if(g_pWideGraph-&gt;isVisible()) {
-    m_wideGraphGeom = g_pWideGraph-&gt;geometry();
-    settings.setValue(&quot;WideGraphGeom&quot;,m_wideGraphGeom);
-    m_fMin=g_pWideGraph-&gt;getFmin();
-  }
-  settings.endGroup();
+  m_settings-&gt;beginGroup(&quot;Common&quot;);
+  m_settings-&gt;setValue(&quot;MyCall&quot;,m_myCall);
+  m_settings-&gt;setValue(&quot;MyGrid&quot;,m_myGrid);
+  m_settings-&gt;setValue(&quot;IDint&quot;,m_idInt);
+  m_settings-&gt;setValue(&quot;PTTmethod&quot;,m_pttMethodIndex);
+  m_settings-&gt;setValue(&quot;PTTport&quot;,m_pttPort);
+  m_settings-&gt;setValue(&quot;SaveDir&quot;,m_saveDir);
+  m_settings-&gt;setValue(&quot;SoundInName&quot;, m_audioInputDevice.deviceName ());
+  m_settings-&gt;setValue(&quot;SoundOutName&quot;, m_audioOutputDevice.deviceName ());
 
-  settings.beginGroup(&quot;Common&quot;);
-  settings.setValue(&quot;MyCall&quot;,m_myCall);
-  settings.setValue(&quot;MyGrid&quot;,m_myGrid);
-  settings.setValue(&quot;IDint&quot;,m_idInt);
-  settings.setValue(&quot;PTTmethod&quot;,m_pttMethodIndex);
-  settings.setValue(&quot;PTTport&quot;,m_pttPort);
-  settings.setValue(&quot;SaveDir&quot;,m_saveDir);
-  settings.setValue(&quot;SoundInName&quot;, m_audioInputDevice.deviceName ());
-  settings.setValue(&quot;SoundOutName&quot;, m_audioOutputDevice.deviceName ());
-  settings.setValue(&quot;Mode&quot;,m_mode);
-  settings.setValue(&quot;ModeTx&quot;,m_modeTx);
-  settings.setValue(&quot;SaveNone&quot;,ui-&gt;actionNone-&gt;isChecked());
-  settings.setValue(&quot;SaveDecoded&quot;,ui-&gt;actionSave_decoded-&gt;isChecked());
-  settings.setValue(&quot;SaveAll&quot;,ui-&gt;actionSave_all-&gt;isChecked());
-  settings.setValue(&quot;NDepth&quot;,m_ndepth);
-  settings.setValue(&quot;MonitorOFF&quot;,m_monitorStartOFF);
-  settings.setValue(&quot;DialFreq&quot;,m_dialFreq);
-  settings.setValue(&quot;RxFreq&quot;,m_rxFreq);
-  settings.setValue(&quot;TxFreq&quot;,m_txFreq);
-  settings.setValue(&quot;InGain&quot;,m_inGain);
-  settings.setValue(&quot;PSKReporter&quot;,m_pskReporter);
-  settings.setValue(&quot;After73&quot;,m_After73);
-  settings.setValue(&quot;Macros&quot;,m_macro);
+  m_settings-&gt;setValue (&quot;AudioInputChannel&quot;, AudioDevice::toString (m_audioInputChannel));
+  m_settings-&gt;setValue (&quot;AudioOutputChannel&quot;, AudioDevice::toString (m_audioOutputChannel));
+  m_settings-&gt;setValue(&quot;Mode&quot;,m_mode);
+  m_settings-&gt;setValue(&quot;ModeTx&quot;,m_modeTx);
+  m_settings-&gt;setValue(&quot;SaveNone&quot;,ui-&gt;actionNone-&gt;isChecked());
+  m_settings-&gt;setValue(&quot;SaveDecoded&quot;,ui-&gt;actionSave_decoded-&gt;isChecked());
+  m_settings-&gt;setValue(&quot;SaveAll&quot;,ui-&gt;actionSave_all-&gt;isChecked());
+  m_settings-&gt;setValue(&quot;NDepth&quot;,m_ndepth);
+  m_settings-&gt;setValue(&quot;MonitorOFF&quot;,m_monitorStartOFF);
+  m_settings-&gt;setValue(&quot;DialFreq&quot;,m_dialFreq);
+  m_settings-&gt;setValue(&quot;RxFreq&quot;,m_rxFreq);
+  m_settings-&gt;setValue(&quot;TxFreq&quot;,m_txFreq);
+  m_settings-&gt;setValue(&quot;InGain&quot;,m_inGain);
+  m_settings-&gt;setValue(&quot;OutAttenuation&quot;, ui-&gt;outAttenuation-&gt;value ());
+  m_settings-&gt;setValue(&quot;PSKReporter&quot;,m_pskReporter);
+  m_settings-&gt;setValue(&quot;After73&quot;,m_After73);
+  m_settings-&gt;setValue(&quot;Macros&quot;,m_macro);
   //Band Settings
-  settings.setValue(&quot;BandFrequencies&quot;,m_dFreq);
-  settings.setValue(&quot;BandDescriptions&quot;,m_bandDescription);
-  settings.setValue(&quot;AntennaDescriptions&quot;,m_antDescription);
-  settings.setValue(&quot;toRTTY&quot;,m_toRTTY);
-  settings.setValue(&quot;NoSuffix&quot;,m_noSuffix);
-  settings.setValue(&quot;dBtoComments&quot;,m_dBtoComments);
-  settings.setValue(&quot;catEnabled&quot;,m_catEnabled);
-  settings.setValue(&quot;Rig&quot;,m_rig);
-  settings.setValue(&quot;RigIndex&quot;,m_rigIndex);
-  settings.setValue(&quot;CATport&quot;,m_catPort);
-  settings.setValue(&quot;CATportIndex&quot;,m_catPortIndex);
-  settings.setValue(&quot;SerialRate&quot;,m_serialRate);
-  settings.setValue(&quot;SerialRateIndex&quot;,m_serialRateIndex);
-  settings.setValue(&quot;DataBits&quot;,m_dataBits);
-  settings.setValue(&quot;DataBitsIndex&quot;,m_dataBitsIndex);
-  settings.setValue(&quot;StopBits&quot;,m_stopBits);
-  settings.setValue(&quot;StopBitsIndex&quot;,m_stopBitsIndex);
-  settings.setValue(&quot;Handshake&quot;,m_handshake);
-  settings.setValue(&quot;HandshakeIndex&quot;,m_handshakeIndex);
-  settings.setValue(&quot;BandIndex&quot;,m_band);
-  settings.setValue(&quot;PromptToLog&quot;,m_promptToLog);
-  settings.setValue(&quot;InsertBlank&quot;,m_insertBlank);
-  settings.setValue(&quot;DXCCEntity&quot;,m_displayDXCCEntity);
-  settings.setValue(&quot;ClearCallGrid&quot;,m_clearCallGrid);
-  settings.setValue(&quot;Miles&quot;,m_bMiles);
-  settings.setValue(&quot;GUItab&quot;,ui-&gt;tabWidget-&gt;currentIndex());
-  settings.setValue(&quot;QuickCall&quot;,m_quickCall);
-  settings.setValue(&quot;73TxDisable&quot;,m_73TxDisable);
-  settings.setValue(&quot;Runaway&quot;,m_runaway);
-  settings.setValue(&quot;Tx2QSO&quot;,m_tx2QSO);
-  settings.setValue(&quot;MultipleOK&quot;,m_bMultipleOK);
-  settings.setValue(&quot;DTR&quot;,m_bDTR);
-  settings.setValue(&quot;RTS&quot;,m_bRTS);  settings.setValue(&quot;pttData&quot;,m_pttData);
-  settings.setValue(&quot;LogQSOgeom&quot;,m_logQSOgeom);
-  settings.setValue(&quot;Polling&quot;,m_poll);
-  settings.setValue(&quot;OutBufSize&quot;,outBufSize);
-  settings.setValue(&quot;LockTxFreq&quot;,m_lockTxFreq);
-  settings.setValue(&quot;SaveTxPower&quot;,m_saveTxPower);
-  settings.setValue(&quot;SaveComments&quot;,m_saveComments);
-  settings.setValue(&quot;TxPower&quot;,m_txPower);
-  settings.setValue(&quot;LogComments&quot;,m_logComments);
-  settings.setValue(&quot;Fmin&quot;,m_fMin);
-  settings.setValue(&quot;TxSplit&quot;,m_bSplit);
-  settings.setValue(&quot;UseXIT&quot;,m_bXIT);
-  settings.setValue(&quot;XIT&quot;,m_XIT);
-  settings.setValue(&quot;Plus2kHz&quot;,m_plus2kHz);
-  settings.endGroup();
+  m_settings-&gt;setValue(&quot;BandFrequencies&quot;,m_dFreq);
+  m_settings-&gt;setValue(&quot;BandDescriptions&quot;,m_bandDescription);
+  m_settings-&gt;setValue(&quot;AntennaDescriptions&quot;,m_antDescription);
+  m_settings-&gt;setValue(&quot;toRTTY&quot;,m_toRTTY);
+  m_settings-&gt;setValue(&quot;NoSuffix&quot;,m_noSuffix);
+  m_settings-&gt;setValue(&quot;dBtoComments&quot;,m_dBtoComments);
+  m_settings-&gt;setValue(&quot;catEnabled&quot;,m_catEnabled);
+  m_settings-&gt;setValue(&quot;Rig&quot;,m_rig);
+  m_settings-&gt;setValue(&quot;RigIndex&quot;,m_rigIndex);
+  m_settings-&gt;setValue(&quot;CATport&quot;,m_catPort);
+  m_settings-&gt;setValue(&quot;CATportIndex&quot;,m_catPortIndex);
+  m_settings-&gt;setValue(&quot;SerialRate&quot;,m_serialRate);
+  m_settings-&gt;setValue(&quot;SerialRateIndex&quot;,m_serialRateIndex);
+  m_settings-&gt;setValue(&quot;DataBits&quot;,m_dataBits);
+  m_settings-&gt;setValue(&quot;DataBitsIndex&quot;,m_dataBitsIndex);
+  m_settings-&gt;setValue(&quot;StopBits&quot;,m_stopBits);
+  m_settings-&gt;setValue(&quot;StopBitsIndex&quot;,m_stopBitsIndex);
+  m_settings-&gt;setValue(&quot;Handshake&quot;,m_handshake);
+  m_settings-&gt;setValue(&quot;HandshakeIndex&quot;,m_handshakeIndex);
+  m_settings-&gt;setValue(&quot;BandIndex&quot;,m_band);
+  m_settings-&gt;setValue(&quot;PromptToLog&quot;,m_promptToLog);
+  m_settings-&gt;setValue(&quot;InsertBlank&quot;,m_insertBlank);
+  m_settings-&gt;setValue(&quot;DXCCEntity&quot;,m_displayDXCCEntity);
+  m_settings-&gt;setValue(&quot;ClearCallGrid&quot;,m_clearCallGrid);
+  m_settings-&gt;setValue(&quot;Miles&quot;,m_bMiles);
+  m_settings-&gt;setValue(&quot;GUItab&quot;,ui-&gt;tabWidget-&gt;currentIndex());
+  m_settings-&gt;setValue(&quot;QuickCall&quot;,m_quickCall);
+  m_settings-&gt;setValue(&quot;73TxDisable&quot;,m_73TxDisable);
+  m_settings-&gt;setValue(&quot;Runaway&quot;,m_runaway);
+  m_settings-&gt;setValue(&quot;Tx2QSO&quot;,m_tx2QSO);
+  m_settings-&gt;setValue(&quot;MultipleOK&quot;,m_bMultipleOK);
+  m_settings-&gt;setValue(&quot;DTR&quot;,m_bDTR);
+  m_settings-&gt;setValue(&quot;RTS&quot;,m_bRTS);  m_settings-&gt;setValue(&quot;pttData&quot;,m_pttData);
+  m_settings-&gt;setValue(&quot;Polling&quot;,m_poll);
+  m_settings-&gt;setValue(&quot;OutBufSize&quot;,outBufSize);
+  m_settings-&gt;setValue(&quot;LockTxFreq&quot;,m_lockTxFreq);
+  m_settings-&gt;setValue(&quot;TxSplit&quot;,m_bSplit);
+  m_settings-&gt;setValue(&quot;UseXIT&quot;,m_bXIT);
+  m_settings-&gt;setValue(&quot;XIT&quot;,m_XIT);
+  m_settings-&gt;setValue(&quot;Plus2kHz&quot;,m_plus2kHz);
+  m_settings-&gt;endGroup();
 }
 
 //---------------------------------------------------------- readSettings()
 void MainWindow::readSettings()
 {
-  QString inifile = m_appDir + &quot;/wsjtx.ini&quot;;
-  QSettings settings(inifile, QSettings::IniFormat);
-  settings.beginGroup(&quot;MainWindow&quot;);
-  restoreGeometry(settings.value(&quot;geometry&quot;).toByteArray());
-  ui-&gt;dxCallEntry-&gt;setText(settings.value(&quot;DXcall&quot;,&quot;&quot;).toString());
-  ui-&gt;dxGridEntry-&gt;setText(settings.value(&quot;DXgrid&quot;,&quot;&quot;).toString());
-  m_wideGraphGeom = settings.value(&quot;WideGraphGeom&quot;, \
-                                   QRect(45,30,726,301)).toRect();
-  m_path = settings.value(&quot;MRUdir&quot;, m_appDir + &quot;/save&quot;).toString();
-  m_txFirst = settings.value(&quot;TxFirst&quot;,false).toBool();
+  m_settings-&gt;beginGroup(&quot;MainWindow&quot;);
+  restoreGeometry (m_settings-&gt;value (&quot;geometry&quot;, saveGeometry ()).toByteArray ());
+  restoreState (m_settings-&gt;value (&quot;state&quot;, saveState ()).toByteArray ());
+  ui-&gt;dxCallEntry-&gt;setText(m_settings-&gt;value(&quot;DXcall&quot;,&quot;&quot;).toString());
+  ui-&gt;dxGridEntry-&gt;setText(m_settings-&gt;value(&quot;DXgrid&quot;,&quot;&quot;).toString());
+  m_path = m_settings-&gt;value(&quot;MRUdir&quot;, m_appDir + &quot;/save&quot;).toString();
+  m_txFirst = m_settings-&gt;value(&quot;TxFirst&quot;,false).toBool();
   ui-&gt;txFirstCheckBox-&gt;setChecked(m_txFirst);
-  settings.endGroup();
+  m_settings-&gt;endGroup();
 
-  settings.beginGroup(&quot;Common&quot;);
-  m_myCall=settings.value(&quot;MyCall&quot;,&quot;&quot;).toString();
+  m_settings-&gt;beginGroup(&quot;Common&quot;);
+  m_myCall=m_settings-&gt;value(&quot;MyCall&quot;,&quot;&quot;).toString();
   morse_(m_myCall.toLatin1().data(),icw,&amp;m_ncw,m_myCall.length());
-  m_myGrid=settings.value(&quot;MyGrid&quot;,&quot;&quot;).toString();
-  m_idInt=settings.value(&quot;IDint&quot;,0).toInt();
-  m_pttMethodIndex=settings.value(&quot;PTTmethod&quot;,1).toInt();
-  m_pttPort=settings.value(&quot;PTTport&quot;,0).toInt();
-  m_saveDir=settings.value(&quot;SaveDir&quot;,m_appDir + &quot;/save&quot;).toString();
+  m_myGrid=m_settings-&gt;value(&quot;MyGrid&quot;,&quot;&quot;).toString();
+  m_idInt=m_settings-&gt;value(&quot;IDint&quot;,0).toInt();
+  m_pttMethodIndex=m_settings-&gt;value(&quot;PTTmethod&quot;,1).toInt();
+  m_pttPort=m_settings-&gt;value(&quot;PTTport&quot;,0).toInt();
+  m_saveDir=m_settings-&gt;value(&quot;SaveDir&quot;,m_appDir + &quot;/save&quot;).toString();
 
   {
     //
     // retrieve audio input device
     //
-    QString savedName = settings.value( &quot;SoundInName&quot;).toString();
+    QString savedName = m_settings-&gt;value( &quot;SoundInName&quot;).toString();
     QList&lt;QAudioDeviceInfo&gt; audioInputDevices (QAudioDeviceInfo::availableDevices (QAudio::AudioInput)); // available audio input devices
     for (QList&lt;QAudioDeviceInfo&gt;::const_iterator p = audioInputDevices.begin (); p != audioInputDevices.end (); ++p)
       {
@@ -533,7 +545,7 @@
     //
     // retrieve audio output device
     //
-    QString savedName = settings.value(&quot;SoundOutName&quot;).toString();
+    QString savedName = m_settings-&gt;value(&quot;SoundOutName&quot;).toString();
     QList&lt;QAudioDeviceInfo&gt; audioOutputDevices (QAudioDeviceInfo::availableDevices (QAudio::AudioOutput)); // available audio output devices
     for (QList&lt;QAudioDeviceInfo&gt;::const_iterator p = audioOutputDevices.begin (); p != audioOutputDevices.end (); ++p)
     {
@@ -543,95 +555,98 @@
     }
   }
 
-  m_mode=settings.value(&quot;Mode&quot;,&quot;JT9&quot;).toString();
-  m_modeTx=settings.value(&quot;ModeTx&quot;,&quot;JT9&quot;).toString();
+  // retrieve audio channel info
+  m_audioInputChannel = AudioDevice::fromString (m_settings-&gt;value (&quot;AudioInputChannel&quot;, &quot;Mono&quot;).toString ());
+  m_audioOutputChannel = AudioDevice::fromString (m_settings-&gt;value (&quot;AudioOutputChannel&quot;, &quot;Mono&quot;).toString ());
+
+  m_mode=m_settings-&gt;value(&quot;Mode&quot;,&quot;JT9&quot;).toString();
+  m_modeTx=m_settings-&gt;value(&quot;ModeTx&quot;,&quot;JT9&quot;).toString();
   if(m_modeTx==&quot;JT9&quot;) ui-&gt;pbTxMode-&gt;setText(&quot;Tx JT9  @&quot;);
   if(m_modeTx==&quot;JT65&quot;) ui-&gt;pbTxMode-&gt;setText(&quot;Tx JT65  #&quot;);
-  ui-&gt;actionNone-&gt;setChecked(settings.value(&quot;SaveNone&quot;,true).toBool());
-  ui-&gt;actionSave_decoded-&gt;setChecked(settings.value(
+  ui-&gt;actionNone-&gt;setChecked(m_settings-&gt;value(&quot;SaveNone&quot;,true).toBool());
+  ui-&gt;actionSave_decoded-&gt;setChecked(m_settings-&gt;value(
                                          &quot;SaveDecoded&quot;,false).toBool());
-  ui-&gt;actionSave_all-&gt;setChecked(settings.value(&quot;SaveAll&quot;,false).toBool());
-  m_dialFreq=settings.value(&quot;DialFreq&quot;,14.078).toDouble();
-  m_rxFreq=settings.value(&quot;RxFreq&quot;,1500).toInt();
+  ui-&gt;actionSave_all-&gt;setChecked(m_settings-&gt;value(&quot;SaveAll&quot;,false).toBool());
+  m_dialFreq=m_settings-&gt;value(&quot;DialFreq&quot;,14.078).toDouble();
+  m_rxFreq=m_settings-&gt;value(&quot;RxFreq&quot;,1500).toInt();
   ui-&gt;RxFreqSpinBox-&gt;setValue(m_rxFreq);
-  m_txFreq=settings.value(&quot;TxFreq&quot;,1500).toInt();
+  m_txFreq=m_settings-&gt;value(&quot;TxFreq&quot;,1500).toInt();
   ui-&gt;TxFreqSpinBox-&gt;setValue(m_txFreq);
   Q_EMIT transmitFrequency (m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0));
   m_saveDecoded=ui-&gt;actionSave_decoded-&gt;isChecked();
   m_saveAll=ui-&gt;actionSave_all-&gt;isChecked();
-  m_ndepth=settings.value(&quot;NDepth&quot;,3).toInt();
-  m_inGain=settings.value(&quot;InGain&quot;,0).toInt();
+  m_ndepth=m_settings-&gt;value(&quot;NDepth&quot;,3).toInt();
+  m_inGain=m_settings-&gt;value(&quot;InGain&quot;,0).toInt();
   ui-&gt;inGain-&gt;setValue(m_inGain);
-  m_monitorStartOFF=settings.value(&quot;MonitorOFF&quot;,false).toBool();
+
+  // setup initial value of tx attenuator
+  ui-&gt;outAttenuation-&gt;setValue (m_settings-&gt;value (&quot;OutAttenuation&quot;, 0).toInt ());
+  on_outAttenuation_valueChanged (ui-&gt;outAttenuation-&gt;value ());
+
+  m_monitorStartOFF=m_settings-&gt;value(&quot;MonitorOFF&quot;,false).toBool();
   ui-&gt;actionMonitor_OFF_at_startup-&gt;setChecked(m_monitorStartOFF);
-  m_pskReporter=settings.value(&quot;PSKReporter&quot;,false).toBool();
-  m_After73=settings.value(&quot;After73&quot;,false).toBool();
-  m_macro=settings.value(&quot;Macros&quot;,&quot;TNX 73 GL&quot;).toStringList();
+  m_pskReporter=m_settings-&gt;value(&quot;PSKReporter&quot;,false).toBool();
+  m_After73=m_settings-&gt;value(&quot;After73&quot;,false).toBool();
+  m_macro=m_settings-&gt;value(&quot;Macros&quot;,&quot;TNX 73 GL&quot;).toStringList();
   //Band Settings
-  m_dFreq=settings.value(&quot;BandFrequencies&quot;,&quot;&quot;).toStringList();
-  m_bandDescription=settings.value(&quot;BandDescriptions&quot;,&quot;&quot;).toStringList();
-  m_antDescription=settings.value(&quot;AntennaDescriptions&quot;,&quot;&quot;).toStringList();
-  m_toRTTY=settings.value(&quot;toRTTY&quot;,false).toBool();
+  m_dFreq=m_settings-&gt;value(&quot;BandFrequencies&quot;,&quot;&quot;).toStringList();
+  m_bandDescription=m_settings-&gt;value(&quot;BandDescriptions&quot;,&quot;&quot;).toStringList();
+  m_antDescription=m_settings-&gt;value(&quot;AntennaDescriptions&quot;,&quot;&quot;).toStringList();
+  m_toRTTY=m_settings-&gt;value(&quot;toRTTY&quot;,false).toBool();
   ui-&gt;actionConvert_JT9_x_to_RTTY-&gt;setChecked(m_toRTTY);
-  m_noSuffix=settings.value(&quot;NoSuffix&quot;,false).toBool();
-  m_dBtoComments=settings.value(&quot;dBtoComments&quot;,false).toBool();
+  m_noSuffix=m_settings-&gt;value(&quot;NoSuffix&quot;,false).toBool();
+  m_dBtoComments=m_settings-&gt;value(&quot;dBtoComments&quot;,false).toBool();
   ui-&gt;actionLog_dB_reports_to_Comments-&gt;setChecked(m_dBtoComments);
-  m_rig=settings.value(&quot;Rig&quot;,214).toInt();
-  m_rigIndex=settings.value(&quot;RigIndex&quot;,100).toInt();
-  m_catPort=settings.value(&quot;CATport&quot;,&quot;None&quot;).toString();
-  m_catPortIndex=settings.value(&quot;CATportIndex&quot;,0).toInt();
-  m_serialRate=settings.value(&quot;SerialRate&quot;,4800).toInt();
-  m_serialRateIndex=settings.value(&quot;SerialRateIndex&quot;,1).toInt();
-  m_dataBits=settings.value(&quot;DataBits&quot;,8).toInt();
-  m_dataBitsIndex=settings.value(&quot;DataBitsIndex&quot;,1).toInt();
-  m_stopBits=settings.value(&quot;StopBits&quot;,2).toInt();
-  m_stopBitsIndex=settings.value(&quot;StopBitsIndex&quot;,1).toInt();
-  m_handshake=settings.value(&quot;Handshake&quot;,&quot;None&quot;).toString();
-  m_handshakeIndex=settings.value(&quot;HandshakeIndex&quot;,0).toInt();
-  m_band=settings.value(&quot;BandIndex&quot;,7).toInt();
+  m_rig=m_settings-&gt;value(&quot;Rig&quot;,214).toInt();
+  m_rigIndex=m_settings-&gt;value(&quot;RigIndex&quot;,100).toInt();
+  m_catPort=m_settings-&gt;value(&quot;CATport&quot;,&quot;None&quot;).toString();
+  m_catPortIndex=m_settings-&gt;value(&quot;CATportIndex&quot;,0).toInt();
+  m_serialRate=m_settings-&gt;value(&quot;SerialRate&quot;,4800).toInt();
+  m_serialRateIndex=m_settings-&gt;value(&quot;SerialRateIndex&quot;,1).toInt();
+  m_dataBits=m_settings-&gt;value(&quot;DataBits&quot;,8).toInt();
+  m_dataBitsIndex=m_settings-&gt;value(&quot;DataBitsIndex&quot;,1).toInt();
+  m_stopBits=m_settings-&gt;value(&quot;StopBits&quot;,2).toInt();
+  m_stopBitsIndex=m_settings-&gt;value(&quot;StopBitsIndex&quot;,1).toInt();
+  m_handshake=m_settings-&gt;value(&quot;Handshake&quot;,&quot;None&quot;).toString();
+  m_handshakeIndex=m_settings-&gt;value(&quot;HandshakeIndex&quot;,0).toInt();
+  m_band=m_settings-&gt;value(&quot;BandIndex&quot;,7).toInt();
   ui-&gt;bandComboBox-&gt;setCurrentIndex(m_band);
   dialFreqChanged2(m_dialFreq);
-  m_catEnabled=settings.value(&quot;catEnabled&quot;,false).toBool();
-  m_promptToLog=settings.value(&quot;PromptToLog&quot;,false).toBool();
+  m_catEnabled=m_settings-&gt;value(&quot;catEnabled&quot;,false).toBool();
+  m_promptToLog=m_settings-&gt;value(&quot;PromptToLog&quot;,false).toBool();
   ui-&gt;actionPrompt_to_log_QSO-&gt;setChecked(m_promptToLog);
-  m_insertBlank=settings.value(&quot;InsertBlank&quot;,false).toBool();
+  m_insertBlank=m_settings-&gt;value(&quot;InsertBlank&quot;,false).toBool();
   ui-&gt;actionBlank_line_between_decoding_periods-&gt;setChecked(m_insertBlank);
-  m_displayDXCCEntity=settings.value(&quot;DXCCEntity&quot;,false).toBool();
+  m_displayDXCCEntity=m_settings-&gt;value(&quot;DXCCEntity&quot;,false).toBool();
   ui-&gt;actionEnable_DXCC_entity-&gt;setChecked(m_displayDXCCEntity);
-  m_clearCallGrid=settings.value(&quot;ClearCallGrid&quot;,false).toBool();
+  m_clearCallGrid=m_settings-&gt;value(&quot;ClearCallGrid&quot;,false).toBool();
   ui-&gt;actionClear_DX_Call_and_Grid_after_logging-&gt;setChecked(m_clearCallGrid);
-  m_bMiles=settings.value(&quot;Miles&quot;,false).toBool();
+  m_bMiles=m_settings-&gt;value(&quot;Miles&quot;,false).toBool();
   ui-&gt;actionDisplay_distance_in_miles-&gt;setChecked(m_bMiles);
-  int n=settings.value(&quot;GUItab&quot;,0).toInt();
+  int n=m_settings-&gt;value(&quot;GUItab&quot;,0).toInt();
   ui-&gt;tabWidget-&gt;setCurrentIndex(n);
-  m_quickCall=settings.value(&quot;QuickCall&quot;,false).toBool();
+  m_quickCall=m_settings-&gt;value(&quot;QuickCall&quot;,false).toBool();
   ui-&gt;actionDouble_click_on_call_sets_Tx_Enable-&gt;setChecked(m_quickCall);
-  m_73TxDisable=settings.value(&quot;73TxDisable&quot;,false).toBool();
+  m_73TxDisable=m_settings-&gt;value(&quot;73TxDisable&quot;,false).toBool();
   ui-&gt;action_73TxDisable-&gt;setChecked(m_73TxDisable);
-  m_runaway=settings.value(&quot;Runaway&quot;,false).toBool();
+  m_runaway=m_settings-&gt;value(&quot;Runaway&quot;,false).toBool();
   ui-&gt;actionRunaway_Tx_watchdog-&gt;setChecked(m_runaway);
-  m_tx2QSO=settings.value(&quot;Tx2QSO&quot;,false).toBool();
+  m_tx2QSO=m_settings-&gt;value(&quot;Tx2QSO&quot;,false).toBool();
   ui-&gt;actionTx2QSO-&gt;setChecked(m_tx2QSO);
-  m_bMultipleOK=settings.value(&quot;MultipleOK&quot;,false).toBool();
+  m_bMultipleOK=m_settings-&gt;value(&quot;MultipleOK&quot;,false).toBool();
   ui-&gt;actionAllow_multiple_instances-&gt;setChecked(m_bMultipleOK);
-  m_bDTR=settings.value(&quot;DTR&quot;,false).toBool();
-  m_bRTS=settings.value(&quot;RTS&quot;,false).toBool();  m_pttData=settings.value(&quot;pttData&quot;,false).toBool();
-  m_poll=settings.value(&quot;Polling&quot;,0).toInt();
-  m_logQSOgeom=settings.value(&quot;LogQSOgeom&quot;,QRect(500,400,424,283)).toRect();
-  outBufSize=settings.value(&quot;OutBufSize&quot;,4096).toInt();
-  m_lockTxFreq=settings.value(&quot;LockTxFreq&quot;,false).toBool();
+  m_bDTR=m_settings-&gt;value(&quot;DTR&quot;,false).toBool();
+  m_bRTS=m_settings-&gt;value(&quot;RTS&quot;,false).toBool();  m_pttData=m_settings-&gt;value(&quot;pttData&quot;,false).toBool();
+  m_poll=m_settings-&gt;value(&quot;Polling&quot;,0).toInt();
+  outBufSize=m_settings-&gt;value(&quot;OutBufSize&quot;,4096).toInt();
+  m_lockTxFreq=m_settings-&gt;value(&quot;LockTxFreq&quot;,false).toBool();
   ui-&gt;cbTxLock-&gt;setChecked(m_lockTxFreq);
-  m_saveTxPower=settings.value(&quot;SaveTxPower&quot;,false).toBool();
-  m_saveComments=settings.value(&quot;SaveComments&quot;,false).toBool();
-  m_txPower=settings.value(&quot;TxPower&quot;,&quot;&quot;).toString();
-  m_logComments=settings.value(&quot;LogComments&quot;,&quot;&quot;).toString();
-  m_fMin=settings.value(&quot;fMin&quot;,2500).toInt();
-  m_bSplit=settings.value(&quot;TxSplit&quot;,false).toBool();
-  m_bXIT=settings.value(&quot;UseXIT&quot;,false).toBool();
-  m_XIT=settings.value(&quot;XIT&quot;,0).toInt();
-	m_plus2kHz=settings.value(&quot;Plus2kHz&quot;,false).toBool();
+  m_bSplit=m_settings-&gt;value(&quot;TxSplit&quot;,false).toBool();
+  m_bXIT=m_settings-&gt;value(&quot;UseXIT&quot;,false).toBool();
+  m_XIT=m_settings-&gt;value(&quot;XIT&quot;,0).toInt();
+	m_plus2kHz=m_settings-&gt;value(&quot;Plus2kHz&quot;,false).toBool();
 	ui-&gt;cbPlus2kHz-&gt;setChecked(m_plus2kHz);
-  settings.endGroup();
+  m_settings-&gt;endGroup();
 
   if(m_ndepth==1) ui-&gt;actionQuickDecode-&gt;setChecked(true);
   if(m_ndepth==2) ui-&gt;actionMediumDecode-&gt;setChecked(true);
@@ -641,7 +656,7 @@
 }
 
 //-------------------------------------------------------------- dataSink()
-void MainWindow::dataSink(qint64 bytes)
+void MainWindow::dataSink(qint64 frames)
 {
   static float s[NSMAX];
   static int ihsym=0;
@@ -661,8 +676,8 @@
 // Get power, spectrum, and ihsym
   trmin=m_TRperiod/60;
   slope=0.0;
-  if(g_pWideGraph!=NULL) slope=(float)g_pWideGraph-&gt;getSlope();
-  int k (bytes / sizeof (jt9com_.d2[0]) - 1);
+  slope=(float)m_wideGraph-&gt;getSlope();
+  int k (frames - 1);
   symspec_(&amp;k,&amp;trmin,&amp;m_nsps,&amp;m_inGain,&amp;slope,&amp;px,s,&amp;df3,&amp;ihsym,&amp;npts8);
   if(ihsym &lt;=0) return;
   QString t;
@@ -670,7 +685,7 @@
   t.sprintf(&quot; Rx noise: %5.1f &quot;,px);
   signalMeter-&gt;setValue(px);                            // Update thermometer
   if(m_monitoring || m_diskData) {
-    g_pWideGraph-&gt;dataSink2(s,df3,ihsym,m_diskData);
+    m_wideGraph-&gt;dataSink2(s,df3,ihsym,m_diskData);
   }
 
   if(ihsym == m_hsymStop) {
@@ -716,6 +731,8 @@
   dlg.m_saveDir=m_saveDir;
   dlg.m_audioInputDevice = m_audioInputDevice;
   dlg.m_audioOutputDevice = m_audioOutputDevice;
+  dlg.m_audioInputChannel = m_audioInputChannel;
+  dlg.m_audioOutputChannel = m_audioOutputChannel;
   dlg.m_pskReporter=m_pskReporter;
   dlg.m_After73=m_After73;
   dlg.m_macro=m_macro;
@@ -761,6 +778,8 @@
     m_saveDir=dlg.m_saveDir;
     m_audioInputDevice = dlg.m_audioInputDevice;
     m_audioOutputDevice = dlg.m_audioOutputDevice;
+    m_audioInputChannel = dlg.m_audioInputChannel;
+    m_audioOutputChannel = dlg.m_audioOutputChannel;
     m_macro=dlg.m_macro;
     m_dFreq=dlg.m_dFreq;
     m_antDescription=dlg.m_antDescription;
@@ -796,7 +815,10 @@
     m_After73=dlg.m_After73;
 
     if(dlg.m_restartSoundIn) {
-      m_soundInput.start(m_audioInputDevice, RX_SAMPLE_RATE / 10, &amp;m_detector);
+      m_soundInput.stop ();
+      m_detector.close ();
+      m_detector.open (m_audioInputChannel);
+      m_soundInput.start(m_audioInputDevice, AudioDevice::Mono == m_audioInputChannel ? 1 : 2, RX_SAMPLE_RATE / 10, &amp;m_detector);
     }
 
     if(dlg.m_restartSoundOut) {
@@ -832,7 +854,7 @@
 {
   m_monitoring=true;
   m_detector.setMonitoring(true);
-  m_soundInput.start(m_audioInputDevice, RX_SAMPLE_RATE / 10, &amp;m_detector);
+  //  m_soundInput.start(m_audioInputDevice, AudioDevice::Mono == m_audioInputChannel ? 1 : 2, RX_SAMPLE_RATE / 10, &amp;m_detector);
   m_diskData=false;
 }
 
@@ -963,13 +985,13 @@
   int i;
   bool ctrl = (n&gt;=100);
   n=n%100;
-  i=g_pWideGraph-&gt;rxFreq();
+  i=m_wideGraph-&gt;rxFreq();
   if(n==11) i--;
   if(n==12) i++;
-  g_pWideGraph-&gt;setRxFreq(i);
+  m_wideGraph-&gt;setRxFreq(i);
   if(ctrl) {
     ui-&gt;TxFreqSpinBox-&gt;setValue(i);
-    g_pWideGraph-&gt;setTxFreq(i);
+    m_wideGraph-&gt;setTxFreq(i);
   }
 }
 
@@ -992,7 +1014,7 @@
   }
   ui-&gt;labDialFreq-&gt;setText(t);
   statusChanged();
-  if(g_pWideGraph!=NULL) g_pWideGraph-&gt;setDialFreq(m_dialFreq);
+  m_wideGraph-&gt;setDialFreq(m_dialFreq);
 }
 
 void MainWindow::statusChanged()
@@ -1047,16 +1069,16 @@
   OnExit();
 }
 
-void MainWindow::closeEvent(QCloseEvent*)
+void MainWindow::closeEvent(QCloseEvent * e)
 {
+  writeSettings ();
   OnExit();
+  QMainWindow::closeEvent (e);
 }
 
 void MainWindow::OnExit()
 {
   m_guiTimer.stop ();
-  g_pWideGraph-&gt;saveSettings();
-  writeSettings();
   if(m_fname != &quot;&quot;) killFile();
   m_killAll=true;
   mem_jt9-&gt;detach();
@@ -1076,7 +1098,6 @@
 {
   m_monitoring=false;
   m_detector.setMonitoring(m_monitoring);
-  m_soundInput.stop ();
   m_loopall=false;  
 }
 
@@ -1095,24 +1116,7 @@
 
 void MainWindow::on_actionWide_Waterfall_triggered()      //Display Waterfalls
 {
-  if(g_pWideGraph==NULL) {
-    g_pWideGraph = new WideGraph(0);
-    g_pWideGraph-&gt;setWindowTitle(&quot;Wide Graph&quot;);
-    g_pWideGraph-&gt;setGeometry(m_wideGraphGeom);
-    Qt::WindowFlags flags = Qt::WindowCloseButtonHint |
-        Qt::WindowMinimizeButtonHint;
-    g_pWideGraph-&gt;setWindowFlags(flags);
-    connect(g_pWideGraph, SIGNAL(freezeDecode2(int)),this,
-            SLOT(freezeDecode(int)));
-    connect(g_pWideGraph, SIGNAL(f11f12(int)),this,
-            SLOT(bumpFqso(int)));
-    connect(g_pWideGraph, SIGNAL(setXIT2(int)),this,
-            SLOT(setXIT(int)));
-//    connect(g_pWideGraph, SIGNAL(dialFreqChanged(double)),this,
-//            SLOT(dialFreqChanged2(double)));
-    connect (this, &amp;MainWindow::finished, g_pWideGraph, &amp;WideGraph::close);
-  }
-  g_pWideGraph-&gt;show();
+  m_wideGraph-&gt;show();
 }
 
 void MainWindow::on_actionOpen_triggered()                     //Open File
@@ -1295,10 +1299,10 @@
 void MainWindow::freezeDecode(int n)                          //freezeDecode()
 {
   bool ctrl = (n&gt;=100);
-  int i=g_pWideGraph-&gt;rxFreq();
+  int i=m_wideGraph-&gt;rxFreq();
   if(ctrl) {
     ui-&gt;TxFreqSpinBox-&gt;setValue(i);
-    g_pWideGraph-&gt;setTxFreq(i);
+    m_wideGraph-&gt;setTxFreq(i);
   }
   if((n%100)==2) on_DecodeButton_clicked();
 }
@@ -1316,13 +1320,13 @@
     jt9com_.nutc=100*ihr + imin;
   }
 
-  jt9com_.nfqso=g_pWideGraph-&gt;rxFreq();
+  jt9com_.nfqso=m_wideGraph-&gt;rxFreq();
   jt9com_.ndepth=m_ndepth;
   jt9com_.ndiskdat=0;
   if(m_diskData) jt9com_.ndiskdat=1;
-  jt9com_.nfa=g_pWideGraph-&gt;nStartFreq();
-  jt9com_.nfSplit=g_pWideGraph-&gt;getFmin();
-  jt9com_.nfb=g_pWideGraph-&gt;getFmax();
+  jt9com_.nfa=m_wideGraph-&gt;nStartFreq();
+  jt9com_.nfSplit=m_wideGraph-&gt;getFmin();
+  jt9com_.nfb=m_wideGraph-&gt;getFmax();
   jt9com_.ntol=20;
   if(jt9com_.nutc &lt; m_nutc0) m_RxLog |= 1;       //Date and Time to all.txt
   m_nutc0=jt9com_.nutc;
@@ -1420,7 +1424,7 @@
       QString bg=&quot;white&quot;;
       if(t.indexOf(&quot; CQ &quot;)&gt;0) bg=&quot;#66ff66&quot;;                          //green
       if(m_myCall!=&quot;&quot; and t.indexOf(&quot; &quot;+m_myCall+&quot; &quot;)&gt;0) bg=&quot;#ff6666&quot;; //red
-      bool bQSO=abs(t.mid(14,4).toInt() - g_pWideGraph-&gt;rxFreq()) &lt;= 10;
+      bool bQSO=abs(t.mid(14,4).toInt() - m_wideGraph-&gt;rxFreq()) &lt;= 10;
       QString t1=t.replace(&quot;\n&quot;,&quot;&quot;).mid(0,t.length()-4);
 
       // if enabled add the DXCC entity and B4 status to the end of the preformated text line t1
@@ -1752,7 +1756,6 @@
     signalMeter-&gt;setValue(0);
     m_monitoring=false;
     m_detector.setMonitoring(false);
-    m_soundInput.stop ();
     m_btxok=true;
     Q_EMIT muteAudioOutput (false);
     m_transmitting=true;
@@ -1881,7 +1884,6 @@
     signalMeter-&gt;setValue(0);
     m_monitoring=false;
     m_detector.setMonitoring(false);
-    m_soundInput.stop ();
     m_btxok=true;
     Q_EMIT muteAudioOutput (false);
     m_transmitting=true;
@@ -1900,7 +1902,6 @@
   lab1-&gt;setText(&quot;&quot;);
   ptt0Timer-&gt;start(200);                       //Sequencer delay
   m_monitoring=true;
-  m_soundInput.start(m_audioInputDevice, RX_SAMPLE_RATE / 10, &amp;m_detector);
   m_detector.setMonitoring(true);
 }
 
@@ -2046,7 +2047,7 @@
 
   int nfreq=t4.at(3).toInt();
   if(t4.at(1)==&quot;Tx&quot;) nfreq=t4.at(2).toInt();
-  g_pWideGraph-&gt;setRxFreq(nfreq);                      //Set Rx freq
+  m_wideGraph-&gt;setRxFreq(nfreq);                      //Set Rx freq
   if(t4.at(1)==&quot;Tx&quot;) {
     if(ctrl) ui-&gt;TxFreqSpinBox-&gt;setValue(nfreq);       //Set Tx freq
     return;
@@ -2054,12 +2055,12 @@
   if(t4.at(4)==&quot;@&quot;) {
     m_modeTx=&quot;JT9&quot;;
     ui-&gt;pbTxMode-&gt;setText(&quot;Tx JT9  @&quot;);
-    g_pWideGraph-&gt;setModeTx(m_modeTx);
+    m_wideGraph-&gt;setModeTx(m_modeTx);
   }
   if(t4.at(4)==&quot;#&quot;) {
     m_modeTx=&quot;JT65&quot;;
     ui-&gt;pbTxMode-&gt;setText(&quot;Tx JT65  #&quot;);
-    g_pWideGraph-&gt;setModeTx(m_modeTx);
+    m_wideGraph-&gt;setModeTx(m_modeTx);
   }
   QString firstcall=t4.at(5);
   // Don't change Tx freq if a station is calling me, unless m_lockTxFreq
@@ -2470,27 +2471,14 @@
   if(m_hisCall==&quot;&quot;) return;
   m_dateTimeQSO=QDateTime::currentDateTimeUtc();
 
-  logDlg = new LogQSO(0);
-  logDlg-&gt;m_saveTxPower=m_saveTxPower;
-  logDlg-&gt;m_saveComments=m_saveComments;
-  logDlg-&gt;m_txPower=m_txPower;
-  logDlg-&gt;m_comments=m_logComments;
-  logDlg-&gt;initLogQSO(m_hisCall,m_hisGrid,m_modeTx,m_rptSent,m_rptRcvd,
+  m_logDlg-&gt;initLogQSO(m_hisCall,m_hisGrid,m_modeTx,m_rptSent,m_rptRcvd,
                      m_dateTimeQSO,m_dialFreq+m_txFreq/1.0e6,
                      m_myCall,m_myGrid,m_noSuffix,m_toRTTY,m_dBtoComments);
-  connect(logDlg, SIGNAL(acceptQSO(bool)),this,SLOT(acceptQSO2(bool)));
-  if(m_logQSOgeom != QRect(500,400,424,283)) logDlg-&gt;setGeometry(m_logQSOgeom);
-  logDlg-&gt;show();
 }
 
 void MainWindow::acceptQSO2(bool accepted)
 {
   if(accepted) {
-    m_logQSOgeom=logDlg-&gt;geometry();
-    m_saveTxPower=logDlg-&gt;m_saveTxPower;
-    m_saveComments=logDlg-&gt;m_saveComments;
-    m_txPower=logDlg-&gt;m_txPower;
-    m_logComments=logDlg-&gt;m_comments;
     m_logBook.addAsWorked(m_hisCall);
     if(m_clearCallGrid) {
       m_hisCall=&quot;&quot;;
@@ -2516,9 +2504,9 @@
   lab2-&gt;setStyleSheet(&quot;QLabel{background-color: #ff6ec7}&quot;);
   lab2-&gt;setText(m_mode);
   ui-&gt;actionJT9_1-&gt;setChecked(true);
-  g_pWideGraph-&gt;setPeriod(m_TRperiod,m_nsps);
-  g_pWideGraph-&gt;setMode(m_mode);
-  g_pWideGraph-&gt;setModeTx(m_modeTx);
+  m_wideGraph-&gt;setPeriod(m_TRperiod,m_nsps);
+  m_wideGraph-&gt;setMode(m_mode);
+  m_wideGraph-&gt;setModeTx(m_modeTx);
   ui-&gt;pbTxMode-&gt;setEnabled(false);
 }
 
@@ -2533,9 +2521,9 @@
   lab2-&gt;setStyleSheet(&quot;QLabel{background-color: #ffff00}&quot;);
   lab2-&gt;setText(m_mode);
   ui-&gt;actionJT65-&gt;setChecked(true);
-  g_pWideGraph-&gt;setPeriod(m_TRperiod,m_nsps);
-  g_pWideGraph-&gt;setMode(m_mode);
-  g_pWideGraph-&gt;setModeTx(m_modeTx);
+  m_wideGraph-&gt;setPeriod(m_TRperiod,m_nsps);
+  m_wideGraph-&gt;setMode(m_mode);
+  m_wideGraph-&gt;setModeTx(m_modeTx);
   ui-&gt;pbTxMode-&gt;setEnabled(false);
 }
 
@@ -2550,16 +2538,16 @@
   lab2-&gt;setStyleSheet(&quot;QLabel{background-color: #ffa500}&quot;);
   lab2-&gt;setText(m_mode);
   ui-&gt;actionJT9_JT65-&gt;setChecked(true);
-  g_pWideGraph-&gt;setPeriod(m_TRperiod,m_nsps);
-  g_pWideGraph-&gt;setMode(m_mode);
-  g_pWideGraph-&gt;setModeTx(m_modeTx);
+  m_wideGraph-&gt;setPeriod(m_TRperiod,m_nsps);
+  m_wideGraph-&gt;setMode(m_mode);
+  m_wideGraph-&gt;setModeTx(m_modeTx);
   ui-&gt;pbTxMode-&gt;setEnabled(true);
 }
 
 void MainWindow::on_TxFreqSpinBox_valueChanged(int n)
 {
   m_txFreq=n;
-  if(g_pWideGraph!=NULL) g_pWideGraph-&gt;setTxFreq(n);
+  m_wideGraph-&gt;setTxFreq(n);
   if(m_lockTxFreq) ui-&gt;RxFreqSpinBox-&gt;setValue(n);
   Q_EMIT transmitFrequency (m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0));
 }
@@ -2567,7 +2555,7 @@
 void MainWindow::on_RxFreqSpinBox_valueChanged(int n)
 {
   m_rxFreq=n;
-  if(g_pWideGraph!=NULL) g_pWideGraph-&gt;setRxFreq(n);
+  m_wideGraph-&gt;setRxFreq(n);
   if(m_lockTxFreq) ui-&gt;TxFreqSpinBox-&gt;setValue(n);
 }
 
@@ -2719,10 +2707,9 @@
       ret=rig-&gt;setFreq(MHz(m_dialFreq));
       if(m_bSplit or m_bXIT) setXIT(m_txFreq);
 
-      if(g_pWideGraph!=NULL) {
-        bumpFqso(11);
-        bumpFqso(12);
-      }
+      bumpFqso(11);
+      bumpFqso(12);
+
       if(ret!=RIG_OK) {
         rt.sprintf(&quot;Set rig frequency failed:  %d&quot;,ret);
         msgBox(rt);
@@ -2973,13 +2960,13 @@
 
 void MainWindow::on_pbR2T_clicked()
 {
-  int n=g_pWideGraph-&gt;rxFreq();
+  int n=m_wideGraph-&gt;rxFreq();
   ui-&gt;TxFreqSpinBox-&gt;setValue(n);
 }
 
 void MainWindow::on_pbT2R_clicked()
 {
-  g_pWideGraph-&gt;setRxFreq(m_txFreq);
+  m_wideGraph-&gt;setRxFreq(m_txFreq);
 }
 
 
@@ -3009,7 +2996,7 @@
     m_modeTx=&quot;JT9&quot;;
     ui-&gt;pbTxMode-&gt;setText(&quot;Tx JT9  @&quot;);
   }
-  g_pWideGraph-&gt;setModeTx(m_modeTx);
+  m_wideGraph-&gt;setModeTx(m_modeTx);
   statusChanged();
 }
 
@@ -3045,7 +3032,7 @@
 void MainWindow::on_cbTxLock_clicked(bool checked)
 {
   m_lockTxFreq=checked;
-  g_pWideGraph-&gt;setLockTxFreq(m_lockTxFreq);
+  m_wideGraph-&gt;setLockTxFreq(m_lockTxFreq);
   if(m_lockTxFreq) on_pbR2T_clicked();
 }
 
@@ -3089,11 +3076,18 @@
 {
   if (m_modeTx == &quot;JT65&quot;)
     {
-      Q_EMIT sendMessage (NUM_JT65_SYMBOLS, 4096.0 * 12000.0 / 11025.0, m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0), true, snr);
+      Q_EMIT sendMessage (NUM_JT65_SYMBOLS, 4096.0 * 12000.0 / 11025.0, m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0), m_audioOutputChannel, true, snr);
     }
   else
     {
-      Q_EMIT sendMessage (NUM_JT9_SYMBOLS, m_nsps, m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0), true, snr);
+      Q_EMIT sendMessage (NUM_JT9_SYMBOLS, m_nsps, m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0), m_audioOutputChannel, true, snr);
     }
-  Q_EMIT startAudioOutputStream (m_audioOutputDevice);
+  Q_EMIT startAudioOutputStream (m_audioOutputDevice, AudioDevice::Mono == m_audioOutputChannel ? 1 : 2);
 }
+
+void MainWindow::on_outAttenuation_valueChanged (int a)
+{
+  qreal dBAttn (a / 10.);      // slider interpreted as hundredths of a dB
+  ui-&gt;outAttenuation-&gt;setToolTip (tr (&quot;Transmit digital gain &quot;) + (a ? QString::number (-dBAttn, 'f', 1) : &quot;0&quot;) + &quot;dB&quot;);
+  Q_EMIT outAttenuationChanged (dBAttn);
+}

Modified: branches/wsjtx/mainwindow.h
===================================================================
--- branches/wsjtx/mainwindow.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/mainwindow.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -10,6 +10,7 @@
 #include &lt;QDateTime&gt;
 #include &lt;QList&gt;
 #include &lt;QAudioDeviceInfo&gt;
+#include &lt;QScopedPointer&gt;
 
 #include &quot;soundin.h&quot;
 #include &quot;soundout.h&quot;
@@ -39,13 +40,17 @@
     class MainWindow;
 }
 
+class QSettings;
+class WideGraph;
+class LogQSO;
+
 class MainWindow : public QMainWindow
 {
   Q_OBJECT
 
 // Multiple instances: call MainWindow() with *thekey
 public:
-  explicit MainWindow(QSharedMemory *shdmem, QString *thekey, \
+  explicit MainWindow(QSettings *, QSharedMemory *shdmem, QString *thekey, \
                       qint32 fontSize2, qint32 fontWeight2, \
                       QWidget *parent = 0);
   ~MainWindow();
@@ -54,7 +59,7 @@
   void showSoundInError(const QString&amp; errorMsg);
   void showSoundOutError(const QString&amp; errorMsg);
   void showStatusMessage(const QString&amp; statusMsg);
-  void dataSink(qint64 bytes);
+  void dataSink(qint64 frames);
   void diskDat();
   void diskWriteFinished();
   void freezeDecode(int n);
@@ -175,20 +180,27 @@
   void on_cbTxLock_clicked(bool checked);
   void on_actionTx2QSO_triggered(bool checked);  
   void on_cbPlus2kHz_toggled(bool checked);
+  void on_outAttenuation_valueChanged (int);
 
  private:
-  Q_SIGNAL void startAudioOutputStream (QAudioDeviceInfo);
+  Q_SIGNAL void startAudioOutputStream (QAudioDeviceInfo, unsigned channels);
   Q_SIGNAL void stopAudioOutputStream ();
   Q_SIGNAL void finished ();
   Q_SIGNAL void muteAudioOutput (bool = true);
   Q_SIGNAL void transmitFrequency (unsigned);
   Q_SIGNAL void endTransmitMessage ();
   Q_SIGNAL void tune (bool = true);
-  Q_SIGNAL void sendMessage (unsigned symbolsLength, double framesPerSymbol, unsigned frequency, bool synchronize = true, double dBSNR = 99.);
+  Q_SIGNAL void sendMessage (unsigned symbolsLength, double framesPerSymbol, unsigned frequency, AudioDevice::Channel, bool synchronize = true, double dBSNR = 99.);
+  Q_SIGNAL void outAttenuationChanged (qreal);
 
 private:
+  QSettings * m_settings;
     Ui::MainWindow *ui;
 
+    // other windows
+    QScopedPointer&lt;WideGraph&gt; m_wideGraph;
+    QScopedPointer&lt;LogQSO&gt; m_logDlg;
+
     double  m_dialFreq;
 
     qint64  m_msErase;
@@ -213,10 +225,12 @@
 
     Detector m_detector;
     QAudioDeviceInfo m_audioInputDevice;
+    AudioDevice::Channel m_audioInputChannel;
     SoundInput m_soundInput;
 
     Modulator m_modulator;
     QAudioDeviceInfo m_audioOutputDevice;
+    AudioDevice::Channel m_audioOutputChannel;
     SoundOutput m_soundOutput;
     QThread m_soundOutputThread;
 
@@ -242,7 +256,6 @@
     qint32  m_repeatMsg;
     qint32  m_watchdogLimit;
     qint32  m_poll;
-    qint32  m_fMin;
     qint32  m_fMax;
     qint32  m_bad;
 
@@ -292,8 +305,6 @@
     bool    m_pttData;
     bool    m_dontReadFreq;
     bool    m_lockTxFreq;
-    bool    m_saveTxPower;
-    bool    m_saveComments;
     bool    m_tx2QSO;
     bool    m_CATerror;
     bool    m_bSplit;
@@ -304,9 +315,6 @@
 
     float   m_pctZap;
 
-    QRect   m_wideGraphGeom;
-    QRect   m_logQSOgeom;
-
     QLabel* lab1;                            // labels in status bar
     QLabel* lab2;
     QLabel* lab3;
@@ -361,8 +369,6 @@
     QString m_msgSent0;
     QString m_fileToSave;
     QString m_QSOmsg;
-    QString m_txPower;
-    QString m_logComments;
 
     QStringList m_macro;
     QStringList m_dFreq;           // per band frequency in MHz as a string

Modified: branches/wsjtx/mainwindow.ui
===================================================================
--- branches/wsjtx/mainwindow.ui	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/mainwindow.ui	2013-08-10 15:29:55 UTC (rev 3542)
@@ -7,7 +7,7 @@
     &lt;x&gt;0&lt;/x&gt;
     &lt;y&gt;0&lt;/y&gt;
     &lt;width&gt;760&lt;/width&gt;
-    &lt;height&gt;552&lt;/height&gt;
+    &lt;height&gt;523&lt;/height&gt;
    &lt;/rect&gt;
   &lt;/property&gt;
   &lt;property name=&quot;sizePolicy&quot;&gt;
@@ -1148,6 +1148,19 @@
         &lt;/item&gt;
        &lt;/layout&gt;
       &lt;/item&gt;
+      &lt;item row=&quot;1&quot; column=&quot;6&quot;&gt;
+       &lt;widget class=&quot;QPushButton&quot; name=&quot;pbTxMode&quot;&gt;
+        &lt;property name=&quot;enabled&quot;&gt;
+         &lt;bool&gt;false&lt;/bool&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;toolTip&quot;&gt;
+         &lt;string&gt;Toggle Tx mode&lt;/string&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;text&quot;&gt;
+         &lt;string&gt;Tx JT9&lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/widget&gt;
+      &lt;/item&gt;
       &lt;item row=&quot;5&quot; column=&quot;3&quot; rowspan=&quot;2&quot; colspan=&quot;2&quot;&gt;
        &lt;widget class=&quot;QLabel&quot; name=&quot;labUTC&quot;&gt;
         &lt;property name=&quot;sizePolicy&quot;&gt;
@@ -1193,6 +1206,16 @@
         &lt;/property&gt;
        &lt;/widget&gt;
       &lt;/item&gt;
+      &lt;item row=&quot;1&quot; column=&quot;0&quot; colspan=&quot;2&quot;&gt;
+       &lt;widget class=&quot;QCheckBox&quot; name=&quot;cbPlus2kHz&quot;&gt;
+        &lt;property name=&quot;toolTip&quot;&gt;
+         &lt;string&gt;Add 2 kHz to requested dial frequency&lt;/string&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;text&quot;&gt;
+         &lt;string&gt;+2 kHz&lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/widget&gt;
+      &lt;/item&gt;
       &lt;item row=&quot;0&quot; column=&quot;8&quot; rowspan=&quot;7&quot;&gt;
        &lt;widget class=&quot;QFrame&quot; name=&quot;frame_2&quot;&gt;
         &lt;property name=&quot;sizePolicy&quot;&gt;
@@ -2062,16 +2085,19 @@
         &lt;/item&gt;
        &lt;/layout&gt;
       &lt;/item&gt;
-      &lt;item row=&quot;1&quot; column=&quot;6&quot;&gt;
-       &lt;widget class=&quot;QPushButton&quot; name=&quot;pbTxMode&quot;&gt;
-        &lt;property name=&quot;enabled&quot;&gt;
-         &lt;bool&gt;false&lt;/bool&gt;
+      &lt;item row=&quot;1&quot; column=&quot;2&quot;&gt;
+       &lt;widget class=&quot;QPushButton&quot; name=&quot;readFreq&quot;&gt;
+        &lt;property name=&quot;maximumSize&quot;&gt;
+         &lt;size&gt;
+          &lt;width&gt;15&lt;/width&gt;
+          &lt;height&gt;15&lt;/height&gt;
+         &lt;/size&gt;
         &lt;/property&gt;
         &lt;property name=&quot;toolTip&quot;&gt;
-         &lt;string&gt;Toggle Tx mode&lt;/string&gt;
+         &lt;string&gt;&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;If orange, click to read dial frequency&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
         &lt;/property&gt;
         &lt;property name=&quot;text&quot;&gt;
-         &lt;string&gt;Tx JT9&lt;/string&gt;
+         &lt;string/&gt;
         &lt;/property&gt;
        &lt;/widget&gt;
       &lt;/item&gt;
@@ -2091,32 +2117,6 @@
         &lt;/property&gt;
        &lt;/spacer&gt;
       &lt;/item&gt;
-      &lt;item row=&quot;1&quot; column=&quot;0&quot; colspan=&quot;2&quot;&gt;
-       &lt;widget class=&quot;QCheckBox&quot; name=&quot;cbPlus2kHz&quot;&gt;
-        &lt;property name=&quot;toolTip&quot;&gt;
-         &lt;string&gt;Add 2 kHz to requested dial frequency&lt;/string&gt;
-        &lt;/property&gt;
-        &lt;property name=&quot;text&quot;&gt;
-         &lt;string&gt;+2 kHz&lt;/string&gt;
-        &lt;/property&gt;
-       &lt;/widget&gt;
-      &lt;/item&gt;
-      &lt;item row=&quot;1&quot; column=&quot;2&quot;&gt;
-       &lt;widget class=&quot;QPushButton&quot; name=&quot;readFreq&quot;&gt;
-        &lt;property name=&quot;maximumSize&quot;&gt;
-         &lt;size&gt;
-          &lt;width&gt;15&lt;/width&gt;
-          &lt;height&gt;15&lt;/height&gt;
-         &lt;/size&gt;
-        &lt;/property&gt;
-        &lt;property name=&quot;toolTip&quot;&gt;
-         &lt;string&gt;&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;If orange, click to read dial frequency&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
-        &lt;/property&gt;
-        &lt;property name=&quot;text&quot;&gt;
-         &lt;string/&gt;
-        &lt;/property&gt;
-       &lt;/widget&gt;
-      &lt;/item&gt;
       &lt;item row=&quot;0&quot; column=&quot;0&quot; colspan=&quot;3&quot;&gt;
        &lt;widget class=&quot;QComboBox&quot; name=&quot;bandComboBox&quot;&gt;
         &lt;property name=&quot;sizePolicy&quot;&gt;
@@ -2225,6 +2225,35 @@
         &lt;/item&gt;
        &lt;/widget&gt;
       &lt;/item&gt;
+      &lt;item row=&quot;0&quot; column=&quot;9&quot;&gt;
+       &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot;&gt;
+        &lt;property name=&quot;text&quot;&gt;
+         &lt;string&gt;Pwr&lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/widget&gt;
+      &lt;/item&gt;
+      &lt;item row=&quot;1&quot; column=&quot;9&quot; rowspan=&quot;6&quot;&gt;
+       &lt;widget class=&quot;QSlider&quot; name=&quot;outAttenuation&quot;&gt;
+        &lt;property name=&quot;value&quot;&gt;
+         &lt;number&gt;0&lt;/number&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;orientation&quot;&gt;
+         &lt;enum&gt;Qt::Vertical&lt;/enum&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;invertedAppearance&quot;&gt;
+         &lt;bool&gt;true&lt;/bool&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;invertedControls&quot;&gt;
+         &lt;bool&gt;true&lt;/bool&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;tickPosition&quot;&gt;
+         &lt;enum&gt;QSlider::TicksBelow&lt;/enum&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;tickInterval&quot;&gt;
+         &lt;number&gt;0&lt;/number&gt;
+        &lt;/property&gt;
+       &lt;/widget&gt;
+      &lt;/item&gt;
      &lt;/layout&gt;
     &lt;/item&gt;
    &lt;/layout&gt;
@@ -2235,7 +2264,7 @@
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;width&gt;760&lt;/width&gt;
-     &lt;height&gt;20&lt;/height&gt;
+     &lt;height&gt;25&lt;/height&gt;
     &lt;/rect&gt;
    &lt;/property&gt;
    &lt;widget class=&quot;QMenu&quot; name=&quot;menuFile&quot;&gt;

Modified: branches/wsjtx/meterwidget.cpp
===================================================================
--- branches/wsjtx/meterwidget.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/meterwidget.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,51 +1,51 @@
-// Simple bargraph meter
-// Implemented by Edson Pereira PY2SDR
-
-#include &quot;meterwidget.h&quot;
-
-MeterWidget::MeterWidget(QWidget *parent) :
-    QWidget(parent),
-    m_signal(0)
-{
-    for ( int i = 0; i &lt; 10; i++ ) {
-        signalQueue.enqueue(0);
-    }
-}
-
-void MeterWidget::setValue(int value)
-{
-    m_signal = value;
-    signalQueue.enqueue(value);
-    signalQueue.dequeue();
-
-    // Get signal peak
-    int tmp = 0;
-    for (int i = 0; i &lt; signalQueue.size(); ++i) {
-        if (signalQueue.at(i) &gt; tmp)
-            tmp = signalQueue.at(i);
-    }
-    m_sigPeak = tmp;
-
-    update();
-}
-
-void MeterWidget::paintEvent( QPaintEvent * )
-{
-    int pos;
-    QPainter p;
-
-    p.begin(this);
-
-    // Sanitize
-    m_signal = m_signal &lt; 0 ? 0 : m_signal;
-    m_signal = m_signal &gt; 60 ? 60 : m_signal;
-
-    pos = m_signal * 2;
-    QRect r(0, height() - pos, width(), pos );
-    p.fillRect(r, QColor( 255, 150, 0 ));
-
-    // Draw peak hold indicator
-    p.setPen(Qt::black);
-    pos = m_sigPeak * 2;
-    p.drawLine(0, height() - pos, 10, height() - pos);
-}
+// Simple bargraph meter
+// Implemented by Edson Pereira PY2SDR
+
+#include &quot;meterwidget.h&quot;
+
+MeterWidget::MeterWidget(QWidget *parent) :
+    QWidget(parent),
+    m_signal(0)
+{
+    for ( int i = 0; i &lt; 10; i++ ) {
+        signalQueue.enqueue(0);
+    }
+}
+
+void MeterWidget::setValue(int value)
+{
+    m_signal = value;
+    signalQueue.enqueue(value);
+    signalQueue.dequeue();
+
+    // Get signal peak
+    int tmp = 0;
+    for (int i = 0; i &lt; signalQueue.size(); ++i) {
+        if (signalQueue.at(i) &gt; tmp)
+            tmp = signalQueue.at(i);
+    }
+    m_sigPeak = tmp;
+
+    update();
+}
+
+void MeterWidget::paintEvent( QPaintEvent * )
+{
+    int pos;
+    QPainter p;
+
+    p.begin(this);
+
+    // Sanitize
+    m_signal = m_signal &lt; 0 ? 0 : m_signal;
+    m_signal = m_signal &gt; 60 ? 60 : m_signal;
+
+    pos = m_signal * 2;
+    QRect r(0, height() - pos, width(), pos );
+    p.fillRect(r, QColor( 255, 150, 0 ));
+
+    // Draw peak hold indicator
+    p.setPen(Qt::black);
+    pos = m_sigPeak * 2;
+    p.drawLine(0, height() - pos, 10, height() - pos);
+}

Modified: branches/wsjtx/meterwidget.h
===================================================================
--- branches/wsjtx/meterwidget.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/meterwidget.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,30 +1,30 @@
-#ifndef METERWIDGET_H
-#define METERWIDGET_H
-
-#include &lt;QWidget&gt;
-#include &lt;QtGui&gt;
-#include &lt;QQueue&gt;
-
-class MeterWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    explicit MeterWidget(QWidget *parent = 0);
-    
-signals:
-    
-public slots:
-    void setValue(int value);
-
-private:
-    QQueue&lt;int&gt; signalQueue;
-
-    int m_signal;
-    int m_sigPeak;
-
-protected:
-    void paintEvent( QPaintEvent * );
-    
-};
-
-#endif // METERWIDGET_H
+#ifndef METERWIDGET_H
+#define METERWIDGET_H
+
+#include &lt;QWidget&gt;
+#include &lt;QtGui&gt;
+#include &lt;QQueue&gt;
+
+class MeterWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    explicit MeterWidget(QWidget *parent = 0);
+    
+signals:
+    
+public slots:
+    void setValue(int value);
+
+private:
+    QQueue&lt;int&gt; signalQueue;
+
+    int m_signal;
+    int m_sigPeak;
+
+protected:
+    void paintEvent( QPaintEvent * );
+    
+};
+
+#endif // METERWIDGET_H

Modified: branches/wsjtx/psk_reporter.cpp
===================================================================
--- branches/wsjtx/psk_reporter.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/psk_reporter.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,112 +1,112 @@
-// KISS Interface for posting spots to PSK Reporter web site
-// Implemented by Edson Pereira PY2SDR
-//
-// Reports will be sent in batch mode every 5 minutes.
-
-#include &quot;psk_reporter.h&quot;
-
-PSK_Reporter::PSK_Reporter(QObject *parent) :
-    QObject(parent),
-    m_sequenceNumber(0)
-{
-    m_header_h = &quot;000Allllttttttttssssssssiiiiiiii&quot;;
-
-    // We use 50E2 and 50E3 for link Id
-    m_rxInfoDescriptor_h = &quot;0003002C50E200040000&quot;
-                           &quot;8002FFFF0000768F&quot;     // 2. Rx Call
-                           &quot;8004FFFF0000768F&quot;     // 4. Rx Grid
-                           &quot;8008FFFF0000768F&quot;     // 8. Rx Soft
-                           &quot;8009FFFF0000768F&quot;     // 9. Rx Antenna
-                           &quot;0000&quot;;
-
-    m_txInfoDescriptor_h = &quot;0002003C50E30007&quot;
-                           &quot;8001FFFF0000768F&quot; // 1. Tx Call
-                           &quot;800500040000768F&quot; // 5. Tx Freq
-                           &quot;800600010000768F&quot; // 6. Tx snr
-                           &quot;800AFFFF0000768F&quot; // 10. Tx Mode
-                           &quot;8003FFFF0000768F&quot; // 3. Tx Grid
-                           &quot;800B00010000768F&quot; // 11. Tx info src
-                           &quot;00960004&quot;;        // Report time
-
-
-    qsrand(QDateTime::currentDateTime().toTime_t());
-    m_randomId_h = QString(&quot;%1&quot;).arg(qrand(),8,16,QChar('0'));
-
-    m_udpSocket = new QUdpSocket(this);
-
-    reportTimer = new QTimer(this);
-    connect(reportTimer, SIGNAL(timeout()), this, SLOT(sendReport()));
-    reportTimer-&gt;start(5*60*1000); // 5 minutes;
-}
-
-void PSK_Reporter::setLocalStation(QString call, QString gridSquare, QString antenna, QString programInfo)
-{
-  m_rxCall = call;
-  m_rxGrid = gridSquare;
-  m_rxAnt = antenna;
-  m_progId = programInfo;
-  //qDebug() &lt;&lt; &quot;PSK_Reporter::setLocalStation. Antenna:&quot; &lt;&lt; antenna;
-}
-
-void PSK_Reporter::addRemoteStation(QString call, QString grid, QString freq, QString mode, QString snr, QString time )
-{
-    QHash&lt;QString,QString&gt; spot;
-    spot[&quot;call&quot;] = call;
-    spot[&quot;grid&quot;] = grid;
-    spot[&quot;snr&quot;] = snr;
-    spot[&quot;freq&quot;] = freq;
-    spot[&quot;mode&quot;] = mode;
-    spot[&quot;time&quot;] = time;
-    m_spotQueue.enqueue(spot);
-}
-
-void PSK_Reporter::sendReport()
-{
-    QString report_h;
-
-    // Header
-    QString header_h = m_header_h;
-    header_h.replace(&quot;tttttttt&quot;, QString(&quot;%1&quot;).arg(QDateTime::currentDateTime().toTime_t(),8,16,QChar('0')));
-    header_h.replace(&quot;ssssssss&quot;, QString(&quot;%1&quot;).arg(++m_sequenceNumber,8,16,QChar('0')));
-    header_h.replace(&quot;iiiiiiii&quot;, m_randomId_h);
-
-    // Receiver information
-    QString rxInfoData_h = &quot;50E2llll&quot;;
-    rxInfoData_h += QString(&quot;%1&quot;).arg(m_rxCall.length(),2,16,QChar('0')) + m_rxCall.toUtf8().toHex();
-    rxInfoData_h += QString(&quot;%1&quot;).arg(m_rxGrid.length(),2,16,QChar('0')) + m_rxGrid.toUtf8().toHex();
-    rxInfoData_h += QString(&quot;%1&quot;).arg(m_progId.length(),2,16,QChar('0')) + m_progId.toUtf8().toHex();
-    rxInfoData_h += QString(&quot;%1&quot;).arg(m_rxAnt.length(),2,16,QChar('0')) + m_rxAnt.toUtf8().toHex();
-    rxInfoData_h += &quot;0000&quot;;
-    rxInfoData_h.replace(&quot;50E2llll&quot;, &quot;50E2&quot; + QString(&quot;%1&quot;).arg(rxInfoData_h.length()/2,4,16,QChar('0')));
-
-    // Sender information
-    if (! m_spotQueue.isEmpty()) {
-        QString txInfoData_h = &quot;50E3llll&quot;;
-        while (!m_spotQueue.isEmpty()) {
-            QHash&lt;QString,QString&gt; spot = m_spotQueue.dequeue();
-            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;call&quot;].length(),2,16,QChar('0')) + spot[&quot;call&quot;].toUtf8().toHex();
-            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;freq&quot;].toLongLong(),8,16,QChar('0'));
-            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;snr&quot;].toInt(),8,16,QChar('0')).right(2);
-            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;mode&quot;].length(),2,16,QChar('0')) + spot[&quot;mode&quot;].toUtf8().toHex();
-            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;grid&quot;].length(),2,16,QChar('0')) + spot[&quot;grid&quot;].toUtf8().toHex();
-            txInfoData_h += QString(&quot;%1&quot;).arg(1,2,16,QChar('0')); // REPORTER_SOURCE_AUTOMATIC
-            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;time&quot;].toInt(),8,16,QChar('0'));
-        }
-        txInfoData_h += &quot;0000&quot;;
-        txInfoData_h.replace(&quot;50E3llll&quot;, &quot;50E3&quot; + QString(&quot;%1&quot;).arg(txInfoData_h.length()/2,4,16,QChar('0')));
-        report_h = header_h + m_rxInfoDescriptor_h + m_txInfoDescriptor_h + rxInfoData_h + txInfoData_h;
-        //qDebug() &lt;&lt; &quot;Sending Report TX: &quot;;
-    } else {
-        report_h = header_h + m_rxInfoDescriptor_h + rxInfoData_h;
-        //qDebug() &lt;&lt; &quot;Sending Report RX: &quot;;
-    }
-
-    report_h.replace(&quot;000Allll&quot;, &quot;000A&quot; + QString(&quot;%1&quot;).arg(report_h.length()/2,4,16,QChar('0')));
-    QByteArray report = QByteArray::fromHex(report_h.toUtf8());
-
-    // Get IP address for pskreporter.info and send report via UDP
-    QHostInfo info = QHostInfo::fromName(&quot;report.pskreporter.info&quot;);
-    m_udpSocket-&gt;writeDatagram(report,info.addresses().at(0),4739);
-}
-
-
+// KISS Interface for posting spots to PSK Reporter web site
+// Implemented by Edson Pereira PY2SDR
+//
+// Reports will be sent in batch mode every 5 minutes.
+
+#include &quot;psk_reporter.h&quot;
+
+PSK_Reporter::PSK_Reporter(QObject *parent) :
+    QObject(parent),
+    m_sequenceNumber(0)
+{
+    m_header_h = &quot;000Allllttttttttssssssssiiiiiiii&quot;;
+
+    // We use 50E2 and 50E3 for link Id
+    m_rxInfoDescriptor_h = &quot;0003002C50E200040000&quot;
+                           &quot;8002FFFF0000768F&quot;     // 2. Rx Call
+                           &quot;8004FFFF0000768F&quot;     // 4. Rx Grid
+                           &quot;8008FFFF0000768F&quot;     // 8. Rx Soft
+                           &quot;8009FFFF0000768F&quot;     // 9. Rx Antenna
+                           &quot;0000&quot;;
+
+    m_txInfoDescriptor_h = &quot;0002003C50E30007&quot;
+                           &quot;8001FFFF0000768F&quot; // 1. Tx Call
+                           &quot;800500040000768F&quot; // 5. Tx Freq
+                           &quot;800600010000768F&quot; // 6. Tx snr
+                           &quot;800AFFFF0000768F&quot; // 10. Tx Mode
+                           &quot;8003FFFF0000768F&quot; // 3. Tx Grid
+                           &quot;800B00010000768F&quot; // 11. Tx info src
+                           &quot;00960004&quot;;        // Report time
+
+
+    qsrand(QDateTime::currentDateTime().toTime_t());
+    m_randomId_h = QString(&quot;%1&quot;).arg(qrand(),8,16,QChar('0'));
+
+    m_udpSocket = new QUdpSocket(this);
+
+    reportTimer = new QTimer(this);
+    connect(reportTimer, SIGNAL(timeout()), this, SLOT(sendReport()));
+    reportTimer-&gt;start(5*60*1000); // 5 minutes;
+}
+
+void PSK_Reporter::setLocalStation(QString call, QString gridSquare, QString antenna, QString programInfo)
+{
+  m_rxCall = call;
+  m_rxGrid = gridSquare;
+  m_rxAnt = antenna;
+  m_progId = programInfo;
+  //qDebug() &lt;&lt; &quot;PSK_Reporter::setLocalStation. Antenna:&quot; &lt;&lt; antenna;
+}
+
+void PSK_Reporter::addRemoteStation(QString call, QString grid, QString freq, QString mode, QString snr, QString time )
+{
+    QHash&lt;QString,QString&gt; spot;
+    spot[&quot;call&quot;] = call;
+    spot[&quot;grid&quot;] = grid;
+    spot[&quot;snr&quot;] = snr;
+    spot[&quot;freq&quot;] = freq;
+    spot[&quot;mode&quot;] = mode;
+    spot[&quot;time&quot;] = time;
+    m_spotQueue.enqueue(spot);
+}
+
+void PSK_Reporter::sendReport()
+{
+    QString report_h;
+
+    // Header
+    QString header_h = m_header_h;
+    header_h.replace(&quot;tttttttt&quot;, QString(&quot;%1&quot;).arg(QDateTime::currentDateTime().toTime_t(),8,16,QChar('0')));
+    header_h.replace(&quot;ssssssss&quot;, QString(&quot;%1&quot;).arg(++m_sequenceNumber,8,16,QChar('0')));
+    header_h.replace(&quot;iiiiiiii&quot;, m_randomId_h);
+
+    // Receiver information
+    QString rxInfoData_h = &quot;50E2llll&quot;;
+    rxInfoData_h += QString(&quot;%1&quot;).arg(m_rxCall.length(),2,16,QChar('0')) + m_rxCall.toUtf8().toHex();
+    rxInfoData_h += QString(&quot;%1&quot;).arg(m_rxGrid.length(),2,16,QChar('0')) + m_rxGrid.toUtf8().toHex();
+    rxInfoData_h += QString(&quot;%1&quot;).arg(m_progId.length(),2,16,QChar('0')) + m_progId.toUtf8().toHex();
+    rxInfoData_h += QString(&quot;%1&quot;).arg(m_rxAnt.length(),2,16,QChar('0')) + m_rxAnt.toUtf8().toHex();
+    rxInfoData_h += &quot;0000&quot;;
+    rxInfoData_h.replace(&quot;50E2llll&quot;, &quot;50E2&quot; + QString(&quot;%1&quot;).arg(rxInfoData_h.length()/2,4,16,QChar('0')));
+
+    // Sender information
+    if (! m_spotQueue.isEmpty()) {
+        QString txInfoData_h = &quot;50E3llll&quot;;
+        while (!m_spotQueue.isEmpty()) {
+            QHash&lt;QString,QString&gt; spot = m_spotQueue.dequeue();
+            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;call&quot;].length(),2,16,QChar('0')) + spot[&quot;call&quot;].toUtf8().toHex();
+            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;freq&quot;].toLongLong(),8,16,QChar('0'));
+            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;snr&quot;].toInt(),8,16,QChar('0')).right(2);
+            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;mode&quot;].length(),2,16,QChar('0')) + spot[&quot;mode&quot;].toUtf8().toHex();
+            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;grid&quot;].length(),2,16,QChar('0')) + spot[&quot;grid&quot;].toUtf8().toHex();
+            txInfoData_h += QString(&quot;%1&quot;).arg(1,2,16,QChar('0')); // REPORTER_SOURCE_AUTOMATIC
+            txInfoData_h += QString(&quot;%1&quot;).arg(spot[&quot;time&quot;].toInt(),8,16,QChar('0'));
+        }
+        txInfoData_h += &quot;0000&quot;;
+        txInfoData_h.replace(&quot;50E3llll&quot;, &quot;50E3&quot; + QString(&quot;%1&quot;).arg(txInfoData_h.length()/2,4,16,QChar('0')));
+        report_h = header_h + m_rxInfoDescriptor_h + m_txInfoDescriptor_h + rxInfoData_h + txInfoData_h;
+        //qDebug() &lt;&lt; &quot;Sending Report TX: &quot;;
+    } else {
+        report_h = header_h + m_rxInfoDescriptor_h + rxInfoData_h;
+        //qDebug() &lt;&lt; &quot;Sending Report RX: &quot;;
+    }
+
+    report_h.replace(&quot;000Allll&quot;, &quot;000A&quot; + QString(&quot;%1&quot;).arg(report_h.length()/2,4,16,QChar('0')));
+    QByteArray report = QByteArray::fromHex(report_h.toUtf8());
+
+    // Get IP address for pskreporter.info and send report via UDP
+    QHostInfo info = QHostInfo::fromName(&quot;report.pskreporter.info&quot;);
+    m_udpSocket-&gt;writeDatagram(report,info.addresses().at(0),4739);
+}
+
+

Modified: branches/wsjtx/psk_reporter.h
===================================================================
--- branches/wsjtx/psk_reporter.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/psk_reporter.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,42 +1,42 @@
-#ifndef PSK_REPORTER_H
-#define PSK_REPORTER_H
-
-#include &lt;QtCore&gt;
-#include &lt;QUdpSocket&gt;
-#include &lt;QHostInfo&gt;
-
-class PSK_Reporter : public QObject
-{
-    Q_OBJECT
-public:
-    explicit PSK_Reporter(QObject *parent = 0);
-    void setLocalStation(QString call, QString grid, QString antenna, QString programInfo);
-    void addRemoteStation(QString call, QString grid, QString freq, QString mode, QString snr, QString time);
-    
-signals:
-    
-public slots:
-    void sendReport();
-
-private:
-    QString m_header_h;
-    QString m_rxInfoDescriptor_h;
-    QString m_txInfoDescriptor_h;
-    QString m_randomId_h;
-    QString m_linkId_h;
-
-    QString m_rxCall;
-    QString m_rxGrid;
-    QString m_rxAnt;
-    QString m_progId;
-
-    QQueue&lt; QHash&lt;QString,QString&gt; &gt; m_spotQueue;
-
-    QUdpSocket *m_udpSocket;
-
-    QTimer *reportTimer;
-
-    int m_sequenceNumber;
-};
-
-#endif // PSK_REPORTER_H
+#ifndef PSK_REPORTER_H
+#define PSK_REPORTER_H
+
+#include &lt;QtCore&gt;
+#include &lt;QUdpSocket&gt;
+#include &lt;QHostInfo&gt;
+
+class PSK_Reporter : public QObject
+{
+    Q_OBJECT
+public:
+    explicit PSK_Reporter(QObject *parent = 0);
+    void setLocalStation(QString call, QString grid, QString antenna, QString programInfo);
+    void addRemoteStation(QString call, QString grid, QString freq, QString mode, QString snr, QString time);
+    
+signals:
+    
+public slots:
+    void sendReport();
+
+private:
+    QString m_header_h;
+    QString m_rxInfoDescriptor_h;
+    QString m_txInfoDescriptor_h;
+    QString m_randomId_h;
+    QString m_linkId_h;
+
+    QString m_rxCall;
+    QString m_rxGrid;
+    QString m_rxAnt;
+    QString m_progId;
+
+    QQueue&lt; QHash&lt;QString,QString&gt; &gt; m_spotQueue;
+
+    QUdpSocket *m_udpSocket;
+
+    QTimer *reportTimer;
+
+    int m_sequenceNumber;
+};
+
+#endif // PSK_REPORTER_H

Modified: branches/wsjtx/rigclass.cpp
===================================================================
--- branches/wsjtx/rigclass.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/rigclass.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,332 +1,332 @@
-/**
- * \file src/rigclass.cc
- * \brief Ham Radio Control Libraries C++ interface
- * \author Stephane Fillod
- * \date 2001-2003
- *
- * Hamlib C++ interface is a frontend implementing wrapper functions.
- */
-
-/**
- *
- *  Hamlib C++ bindings - main file
- *  Copyright (c) 2001-2003 by Stephane Fillod
- *
- *
- *   This library is free software; you can redistribute it and/or
- *   modify it under the terms of the GNU Lesser General Public
- *   License as published by the Free Software Foundation; either
- *   version 2.1 of the License, or (at your option) any later version.
- *
- *   This library is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *   Lesser General Public License for more details.
- *
- *   You should have received a copy of the GNU Lesser General Public
- *   License along with this library; if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &lt;hamlib/rig.h&gt;
-#include &quot;rigclass.h&quot;
-#include &lt;QDebug&gt;
-#include &lt;QHostAddress&gt;
-
-#define NUMTRIES 5
-
-static int hamlibpp_freq_event(RIG *rig, vfo_t vfo, freq_t freq, rig_ptr_t arg);
-
-static int hamlibpp_freq_event(RIG *rig, vfo_t vfo, freq_t freq, rig_ptr_t arg)
-{
-  if (!rig || !rig-&gt;state.obj)
-    return -RIG_EINVAL;
-
-/* assert rig == ((Rig*)rig-&gt;state.obj).theRig */
-  return ((Rig*)rig-&gt;state.obj)-&gt;FreqEvent(vfo, freq, arg);
-}
-
-Rig::Rig()
-{
-  rig_set_debug_level( RIG_DEBUG_WARN);
-}
-
-Rig::~Rig() {
-  theRig-&gt;state.obj = NULL;
-  rig_cleanup(theRig);
-  caps = NULL;
-}
-
-int Rig::init(rig_model_t rig_model)
-{
-    int initOk;
-
-    theRig = rig_init(rig_model);
-    if (!theRig)
-        initOk = false;
-    else
-        initOk = true;
-
-    caps = theRig-&gt;caps;
-    theRig-&gt;callbacks.freq_event = &amp;hamlibpp_freq_event;
-    theRig-&gt;state.obj = (rig_ptr_t)this;
-
-    return initOk;
-}
-
-int Rig::open(int n) {
-  m_hrd=false;
-  m_cmndr=false;
-  if(n&lt;9900) {
-    if(n==-99999) return -1;                      //Silence compiler warning
-    return rig_open(theRig);
-  }
-
-#ifdef WIN32	              // Ham radio Deluxe or Commander (Windows only)
-  if(n==9999) {
-    m_hrd=true;
-    bool bConnect=false;
-    bConnect = HRDInterfaceConnect(L&quot;localhost&quot;,7809);
-    if(bConnect) {
-      const wchar_t* context=HRDInterfaceSendMessage(L&quot;Get Context&quot;);
-      m_context=&quot;[&quot; + QString::fromWCharArray (context,-1) + &quot;] &quot;;
-      HRDInterfaceFreeString(context);
-      return 0;
-    } else {
-      m_hrd=false;
-      return -1;
-    }
-  }
-  if(n==9998) {
-    if(commanderSocket-&gt;state()==QAbstractSocket::ConnectedState) {
-      commanderSocket-&gt;abort();
-    }
-
-    if(commanderSocket-&gt;state()==QAbstractSocket::UnconnectedState) {
-      commanderSocket-&gt;connectToHost(QHostAddress::LocalHost, 52002);
-      if(!commanderSocket-&gt;waitForConnected(1000)) {
-        return -1;
-      }
-    }
-    QString t;
-    t=&quot;&lt;command:10&gt;CmdGetFreq&lt;parameters:0&gt;&quot;;
-    QByteArray ba = t.toLocal8Bit();
-    const char* buf=ba.data();
-    commanderSocket-&gt;write(buf);
-    commanderSocket-&gt;waitForReadyRead(1000);
-    QByteArray reply=commanderSocket-&gt;read(128);
-    if(reply.indexOf(&quot;&lt;CmdFreq:&quot;)==0) {
-      m_cmndr=true;
-      return 0;
-    }
-  }
-#endif
-  return -1;
-}
-
-int Rig::close(void) {
-#ifdef WIN32	// Ham Radio Deluxe only on Windows
-  if(m_hrd) {
-    HRDInterfaceDisconnect();
-    return 0;
-  } else if(m_cmndr) {
-    commanderSocket-&gt;close();
-    return 0;
-  } else
-#endif
-    {
-    return rig_close(theRig);
-  }
-}
-
-int Rig::setConf(const char *name, const char *val)
-{
-  return rig_set_conf(theRig, tokenLookup(name), val);
-}
-
-int Rig::setFreq(freq_t freq, vfo_t vfo) {
-#ifdef WIN32	// Ham Radio Deluxe (only on Windows)
-  if(m_hrd) {
-    QString t;
-    int nhz=(int)freq;
-    t=m_context + &quot;Set Frequency-Hz &quot; + QString::number(nhz);
-    const wchar_t* cmnd = (const wchar_t*) t.utf16();
-    const wchar_t* result=HRDInterfaceSendMessage(cmnd);
-    QString t2=QString::fromWCharArray (result,-1);
-    HRDInterfaceFreeString(result);
-    if(t2==&quot;OK&quot;) {
-      return 0;
-    } else {
-      return -1;
-    }
-  } else if(m_cmndr) {
-    QString t;
-    double f=0.001*freq;
-    t.sprintf(&quot;&lt;command:10&gt;CmdSetFreq&lt;parameters:23&gt;&lt;xcvrfreq:10&gt;%10.3f&quot;,f);
-    QLocale locale;
-    t.replace(&quot;.&quot;,locale.decimalPoint());
-    QByteArray ba = t.toLocal8Bit();
-    const char* buf=ba.data();
-    commanderSocket-&gt;write(buf);
-    commanderSocket-&gt;waitForBytesWritten(1000);
-    return 0;
-  } else
-#endif
-  {
-    return rig_set_freq(theRig, vfo, freq);
-  }
-}
-
-int Rig::setXit(shortfreq_t xit, vfo_t vfo)
-{
-  return rig_set_xit(theRig, vfo, xit);
-}
-
-int Rig::setVFO(vfo_t vfo)
-{
-  return rig_set_vfo(theRig, vfo);
-}
-
-vfo_t Rig::getVFO()
-{
-  vfo_t vfo;
-  rig_get_vfo(theRig, &amp;vfo);
-  return vfo;
-}
-
-int Rig::setSplitFreq(freq_t tx_freq, vfo_t vfo) {
-#ifdef WIN32	// Ham Radio Deluxe only on Windows
-  if(m_hrd) {
-    QString t;
-    int nhz=(int)tx_freq;
-    t=m_context + &quot;Set Frequency-Hz &quot; + QString::number(nhz);
-    const wchar_t* cmnd = (const wchar_t*) t.utf16();
-    const wchar_t* result=HRDInterfaceSendMessage(cmnd);
-    QString t2=QString::fromWCharArray (result,-1);
-    HRDInterfaceFreeString(result);
-    if(t2==&quot;OK&quot;) {
-      return 0;
-    } else {
-      return -1;
-    }
-  } else if(m_cmndr) {
-    QString t;
-    double f=0.001*tx_freq;
-    t.sprintf(&quot;&lt;command:12&gt;CmdSetTxFreq&lt;parameters:23&gt;&lt;xcvrfreq:10&gt;%10.3f&quot;,f);
-    QLocale locale;
-    t.replace(&quot;.&quot;,locale.decimalPoint());
-    QByteArray ba = t.toLocal8Bit();
-    const char* buf=ba.data();
-    commanderSocket-&gt;write(buf);
-    commanderSocket-&gt;waitForBytesWritten(1000);
-    return 0;
-  } else
-#endif
-  {
-    return rig_set_split_freq(theRig, vfo, tx_freq);
-  }
-}
-
-freq_t Rig::getFreq(vfo_t vfo)
-{
-  freq_t freq;
-#ifdef WIN32	// Ham Radio Deluxe (only on Windows)
-  if(m_hrd) {
-    const wchar_t* cmnd = (const wchar_t*) (m_context+&quot;Get Frequency&quot;).utf16();
-    const wchar_t* freqString=HRDInterfaceSendMessage(cmnd);
-    QString t2=QString::fromWCharArray (freqString,-1);
-    HRDInterfaceFreeString(freqString);
-    freq=t2.toDouble();
-    return freq;
-  } else if(m_cmndr) {
-    QString t;
-    t=&quot;&lt;command:10&gt;CmdGetFreq&lt;parameters:0&gt;&quot;;
-    QByteArray ba = t.toLocal8Bit();
-    const char* buf=ba.data();
-    commanderSocket-&gt;write(buf);
-    commanderSocket-&gt;waitForReadyRead(1000);
-    QByteArray reply=commanderSocket-&gt;read(128);
-    QString t2(reply);
-    if(t2.indexOf(&quot;&lt;CmdFreq:&quot;)==0) {
-      int i1=t2.indexOf(&quot;&gt;&quot;);
-      t2=t2.mid(i1+1).replace(&quot;,&quot;,&quot;&quot;);
-      freq=1000.0*t2.toDouble();
-      return freq;
-    } else {
-      return -1.0;
-    }
-  } else
-#endif
-  {
-    freq=-1.0;
-    for(int i=0; i&lt;NUMTRIES; i++) {
-      int iret=rig_get_freq(theRig, vfo, &amp;freq);
-      if(iret==RIG_OK) break;
-    }
-    return freq;
-  }
-}
-
-int Rig::setMode(rmode_t mode, pbwidth_t width, vfo_t vfo) {
-  return rig_set_mode(theRig, vfo, mode, width);
-}
-
-rmode_t Rig::getMode(pbwidth_t&amp; width, vfo_t vfo) {
-  rmode_t mode;
-  rig_get_mode(theRig, vfo, &amp;mode, &amp;width);
-  return mode;
-}
-
-int Rig::setPTT(ptt_t ptt, vfo_t vfo)
-{
-#ifdef WIN32	// Ham Radio Deluxe only on Windows
-  if(m_hrd) {
-    wchar_t* cmnd;
-
-    if(ptt==0) {
-      cmnd = (wchar_t*) (m_context +
-                             &quot;Set Button-Select TX 0&quot;).utf16();
-    } else {
-      cmnd = (wchar_t*) (m_context +
-                             &quot;Set Button-Select TX 1&quot;).utf16();
-    }
-    const wchar_t* result=HRDInterfaceSendMessage(cmnd);
-    QString t2=QString::fromWCharArray (result,-1);
-    HRDInterfaceFreeString(result);
-    if(t2==&quot;OK&quot;) {
-      return 0;
-    } else {
-      return -1;
-    }
-  } else if(m_cmndr) {
-    QString t;
-    if(ptt==0) t=&quot;&lt;command:5&gt;CmdRX&lt;parameters:0&gt;&quot;;
-    if(ptt&gt;0) t=&quot;&lt;command:5&gt;CmdTX&lt;parameters:0&gt;&quot;;
-    QByteArray ba = t.toLocal8Bit();
-    const char* buf=ba.data();
-    commanderSocket-&gt;write(buf);
-    commanderSocket-&gt;waitForBytesWritten(1000);
-    return 0;
-  } else
-#endif
-    {
-    return rig_set_ptt(theRig, vfo, ptt);
-  }
-}
-
-ptt_t Rig::getPTT(vfo_t vfo)
-{
-  ptt_t ptt;
-  rig_get_ptt(theRig, vfo, &amp;ptt);
-  return ptt;
-}
-
-token_t Rig::tokenLookup(const char *name)
-{
-  return rig_token_lookup(theRig, name);
-}
+/**
+ * \file src/rigclass.cc
+ * \brief Ham Radio Control Libraries C++ interface
+ * \author Stephane Fillod
+ * \date 2001-2003
+ *
+ * Hamlib C++ interface is a frontend implementing wrapper functions.
+ */
+
+/**
+ *
+ *  Hamlib C++ bindings - main file
+ *  Copyright (c) 2001-2003 by Stephane Fillod
+ *
+ *
+ *   This library is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU Lesser General Public
+ *   License as published by the Free Software Foundation; either
+ *   version 2.1 of the License, or (at your option) any later version.
+ *
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   Lesser General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Lesser General Public
+ *   License along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &lt;hamlib/rig.h&gt;
+#include &quot;rigclass.h&quot;
+#include &lt;QDebug&gt;
+#include &lt;QHostAddress&gt;
+
+#define NUMTRIES 5
+
+static int hamlibpp_freq_event(RIG *rig, vfo_t vfo, freq_t freq, rig_ptr_t arg);
+
+static int hamlibpp_freq_event(RIG *rig, vfo_t vfo, freq_t freq, rig_ptr_t arg)
+{
+  if (!rig || !rig-&gt;state.obj)
+    return -RIG_EINVAL;
+
+/* assert rig == ((Rig*)rig-&gt;state.obj).theRig */
+  return ((Rig*)rig-&gt;state.obj)-&gt;FreqEvent(vfo, freq, arg);
+}
+
+Rig::Rig()
+{
+  rig_set_debug_level( RIG_DEBUG_WARN);
+}
+
+Rig::~Rig() {
+  theRig-&gt;state.obj = NULL;
+  rig_cleanup(theRig);
+  caps = NULL;
+}
+
+int Rig::init(rig_model_t rig_model)
+{
+    int initOk;
+
+    theRig = rig_init(rig_model);
+    if (!theRig)
+        initOk = false;
+    else
+        initOk = true;
+
+    caps = theRig-&gt;caps;
+    theRig-&gt;callbacks.freq_event = &amp;hamlibpp_freq_event;
+    theRig-&gt;state.obj = (rig_ptr_t)this;
+
+    return initOk;
+}
+
+int Rig::open(int n) {
+  m_hrd=false;
+  m_cmndr=false;
+  if(n&lt;9900) {
+    if(n==-99999) return -1;                      //Silence compiler warning
+    return rig_open(theRig);
+  }
+
+#ifdef WIN32	              // Ham radio Deluxe or Commander (Windows only)
+  if(n==9999) {
+    m_hrd=true;
+    bool bConnect=false;
+    bConnect = HRDInterfaceConnect(L&quot;localhost&quot;,7809);
+    if(bConnect) {
+      const wchar_t* context=HRDInterfaceSendMessage(L&quot;Get Context&quot;);
+      m_context=&quot;[&quot; + QString::fromWCharArray (context,-1) + &quot;] &quot;;
+      HRDInterfaceFreeString(context);
+      return 0;
+    } else {
+      m_hrd=false;
+      return -1;
+    }
+  }
+  if(n==9998) {
+    if(commanderSocket-&gt;state()==QAbstractSocket::ConnectedState) {
+      commanderSocket-&gt;abort();
+    }
+
+    if(commanderSocket-&gt;state()==QAbstractSocket::UnconnectedState) {
+      commanderSocket-&gt;connectToHost(QHostAddress::LocalHost, 52002);
+      if(!commanderSocket-&gt;waitForConnected(1000)) {
+        return -1;
+      }
+    }
+    QString t;
+    t=&quot;&lt;command:10&gt;CmdGetFreq&lt;parameters:0&gt;&quot;;
+    QByteArray ba = t.toLocal8Bit();
+    const char* buf=ba.data();
+    commanderSocket-&gt;write(buf);
+    commanderSocket-&gt;waitForReadyRead(1000);
+    QByteArray reply=commanderSocket-&gt;read(128);
+    if(reply.indexOf(&quot;&lt;CmdFreq:&quot;)==0) {
+      m_cmndr=true;
+      return 0;
+    }
+  }
+#endif
+  return -1;
+}
+
+int Rig::close(void) {
+#ifdef WIN32	// Ham Radio Deluxe only on Windows
+  if(m_hrd) {
+    HRDInterfaceDisconnect();
+    return 0;
+  } else if(m_cmndr) {
+    commanderSocket-&gt;close();
+    return 0;
+  } else
+#endif
+    {
+    return rig_close(theRig);
+  }
+}
+
+int Rig::setConf(const char *name, const char *val)
+{
+  return rig_set_conf(theRig, tokenLookup(name), val);
+}
+
+int Rig::setFreq(freq_t freq, vfo_t vfo) {
+#ifdef WIN32	// Ham Radio Deluxe (only on Windows)
+  if(m_hrd) {
+    QString t;
+    int nhz=(int)freq;
+    t=m_context + &quot;Set Frequency-Hz &quot; + QString::number(nhz);
+    const wchar_t* cmnd = (const wchar_t*) t.utf16();
+    const wchar_t* result=HRDInterfaceSendMessage(cmnd);
+    QString t2=QString::fromWCharArray (result,-1);
+    HRDInterfaceFreeString(result);
+    if(t2==&quot;OK&quot;) {
+      return 0;
+    } else {
+      return -1;
+    }
+  } else if(m_cmndr) {
+    QString t;
+    double f=0.001*freq;
+    t.sprintf(&quot;&lt;command:10&gt;CmdSetFreq&lt;parameters:23&gt;&lt;xcvrfreq:10&gt;%10.3f&quot;,f);
+    QLocale locale;
+    t.replace(&quot;.&quot;,locale.decimalPoint());
+    QByteArray ba = t.toLocal8Bit();
+    const char* buf=ba.data();
+    commanderSocket-&gt;write(buf);
+    commanderSocket-&gt;waitForBytesWritten(1000);
+    return 0;
+  } else
+#endif
+  {
+    return rig_set_freq(theRig, vfo, freq);
+  }
+}
+
+int Rig::setXit(shortfreq_t xit, vfo_t vfo)
+{
+  return rig_set_xit(theRig, vfo, xit);
+}
+
+int Rig::setVFO(vfo_t vfo)
+{
+  return rig_set_vfo(theRig, vfo);
+}
+
+vfo_t Rig::getVFO()
+{
+  vfo_t vfo;
+  rig_get_vfo(theRig, &amp;vfo);
+  return vfo;
+}
+
+int Rig::setSplitFreq(freq_t tx_freq, vfo_t vfo) {
+#ifdef WIN32	// Ham Radio Deluxe only on Windows
+  if(m_hrd) {
+    QString t;
+    int nhz=(int)tx_freq;
+    t=m_context + &quot;Set Frequency-Hz &quot; + QString::number(nhz);
+    const wchar_t* cmnd = (const wchar_t*) t.utf16();
+    const wchar_t* result=HRDInterfaceSendMessage(cmnd);
+    QString t2=QString::fromWCharArray (result,-1);
+    HRDInterfaceFreeString(result);
+    if(t2==&quot;OK&quot;) {
+      return 0;
+    } else {
+      return -1;
+    }
+  } else if(m_cmndr) {
+    QString t;
+    double f=0.001*tx_freq;
+    t.sprintf(&quot;&lt;command:12&gt;CmdSetTxFreq&lt;parameters:23&gt;&lt;xcvrfreq:10&gt;%10.3f&quot;,f);
+    QLocale locale;
+    t.replace(&quot;.&quot;,locale.decimalPoint());
+    QByteArray ba = t.toLocal8Bit();
+    const char* buf=ba.data();
+    commanderSocket-&gt;write(buf);
+    commanderSocket-&gt;waitForBytesWritten(1000);
+    return 0;
+  } else
+#endif
+  {
+    return rig_set_split_freq(theRig, vfo, tx_freq);
+  }
+}
+
+freq_t Rig::getFreq(vfo_t vfo)
+{
+  freq_t freq;
+#ifdef WIN32	// Ham Radio Deluxe (only on Windows)
+  if(m_hrd) {
+    const wchar_t* cmnd = (const wchar_t*) (m_context+&quot;Get Frequency&quot;).utf16();
+    const wchar_t* freqString=HRDInterfaceSendMessage(cmnd);
+    QString t2=QString::fromWCharArray (freqString,-1);
+    HRDInterfaceFreeString(freqString);
+    freq=t2.toDouble();
+    return freq;
+  } else if(m_cmndr) {
+    QString t;
+    t=&quot;&lt;command:10&gt;CmdGetFreq&lt;parameters:0&gt;&quot;;
+    QByteArray ba = t.toLocal8Bit();
+    const char* buf=ba.data();
+    commanderSocket-&gt;write(buf);
+    commanderSocket-&gt;waitForReadyRead(1000);
+    QByteArray reply=commanderSocket-&gt;read(128);
+    QString t2(reply);
+    if(t2.indexOf(&quot;&lt;CmdFreq:&quot;)==0) {
+      int i1=t2.indexOf(&quot;&gt;&quot;);
+      t2=t2.mid(i1+1).replace(&quot;,&quot;,&quot;&quot;);
+      freq=1000.0*t2.toDouble();
+      return freq;
+    } else {
+      return -1.0;
+    }
+  } else
+#endif
+  {
+    freq=-1.0;
+    for(int i=0; i&lt;NUMTRIES; i++) {
+      int iret=rig_get_freq(theRig, vfo, &amp;freq);
+      if(iret==RIG_OK) break;
+    }
+    return freq;
+  }
+}
+
+int Rig::setMode(rmode_t mode, pbwidth_t width, vfo_t vfo) {
+  return rig_set_mode(theRig, vfo, mode, width);
+}
+
+rmode_t Rig::getMode(pbwidth_t&amp; width, vfo_t vfo) {
+  rmode_t mode;
+  rig_get_mode(theRig, vfo, &amp;mode, &amp;width);
+  return mode;
+}
+
+int Rig::setPTT(ptt_t ptt, vfo_t vfo)
+{
+#ifdef WIN32	// Ham Radio Deluxe only on Windows
+  if(m_hrd) {
+    wchar_t* cmnd;
+
+    if(ptt==0) {
+      cmnd = (wchar_t*) (m_context +
+                             &quot;Set Button-Select TX 0&quot;).utf16();
+    } else {
+      cmnd = (wchar_t*) (m_context +
+                             &quot;Set Button-Select TX 1&quot;).utf16();
+    }
+    const wchar_t* result=HRDInterfaceSendMessage(cmnd);
+    QString t2=QString::fromWCharArray (result,-1);
+    HRDInterfaceFreeString(result);
+    if(t2==&quot;OK&quot;) {
+      return 0;
+    } else {
+      return -1;
+    }
+  } else if(m_cmndr) {
+    QString t;
+    if(ptt==0) t=&quot;&lt;command:5&gt;CmdRX&lt;parameters:0&gt;&quot;;
+    if(ptt&gt;0) t=&quot;&lt;command:5&gt;CmdTX&lt;parameters:0&gt;&quot;;
+    QByteArray ba = t.toLocal8Bit();
+    const char* buf=ba.data();
+    commanderSocket-&gt;write(buf);
+    commanderSocket-&gt;waitForBytesWritten(1000);
+    return 0;
+  } else
+#endif
+    {
+    return rig_set_ptt(theRig, vfo, ptt);
+  }
+}
+
+ptt_t Rig::getPTT(vfo_t vfo)
+{
+  ptt_t ptt;
+  rig_get_ptt(theRig, vfo, &amp;ptt);
+  return ptt;
+}
+
+token_t Rig::tokenLookup(const char *name)
+{
+  return rig_token_lookup(theRig, name);
+}

Modified: branches/wsjtx/rigclass.h
===================================================================
--- branches/wsjtx/rigclass.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/rigclass.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,98 +1,98 @@
-/*
- *  Hamlib C++ bindings - API header
- *  Copyright (c) 2001-2002 by Stephane Fillod
- *
- *
- *   This library is free software; you can redistribute it and/or
- *   modify it under the terms of the GNU Lesser General Public
- *   License as published by the Free Software Foundation; either
- *   version 2.1 of the License, or (at your option) any later version.
- *
- *   This library is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *   Lesser General Public License for more details.
- *
- *   You should have received a copy of the GNU Lesser General Public
- *   License along with this library; if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifndef _RIGCLASS_H
-#define _RIGCLASS_H 1
-
-#include &lt;hamlib/rig.h&gt;
-#include &lt;iostream&gt;
-#include &lt;QString&gt;
-#include &lt;QTcpSocket&gt;
-
-extern QTcpSocket* commanderSocket;
-
-class BACKEND_IMPEXP Rig {
-private:
-  RIG* theRig;  // Global ref. to the rig
-  bool m_hrd;
-  bool m_cmndr;
-  QString m_context;
-
-
-protected:
-public:
-  Rig();
-  virtual ~Rig();
-
-  const struct rig_caps *caps;
-
-  // Initialize rig
-  int init(rig_model_t rig_model);
-
-  // This method open the communication port to the rig
-  int open(int n);
-
-  // This method close the communication port to the rig
-  int close(void);
-
-  int setConf(const char *name, const char *val);
-  token_t tokenLookup(const char *name);
-
-  int setFreq(freq_t freq, vfo_t vfo = RIG_VFO_CURR);
-  freq_t getFreq(vfo_t vfo = RIG_VFO_CURR);
-  int setMode(rmode_t, pbwidth_t width = RIG_PASSBAND_NORMAL, vfo_t vfo = RIG_VFO_CURR);
-  rmode_t getMode(pbwidth_t&amp;, vfo_t vfo = RIG_VFO_CURR);
-  int setVFO(vfo_t);
-  vfo_t getVFO();
-  int setXit(shortfreq_t xit, vfo_t vfo);
-  int setSplitFreq(freq_t tx_freq, vfo_t vfo = RIG_VFO_CURR);
-  int setPTT (ptt_t ptt, vfo_t vfo = RIG_VFO_CURR);
-  ptt_t getPTT (vfo_t vfo = RIG_VFO_CURR);
-
-  // callbacks available in your derived object
-  virtual int FreqEvent(vfo_t, freq_t, rig_ptr_t) const {
-		  return RIG_OK;
-  }
-  virtual int ModeEvent(vfo_t, rmode_t, pbwidth_t, rig_ptr_t) const {
-		  return RIG_OK;
-  }
-  virtual int VFOEvent(vfo_t, rig_ptr_t) const {
-		  return RIG_OK;
-  }
-  virtual int PTTEvent(vfo_t, ptt_t, rig_ptr_t) const {
-		  return RIG_OK;
-  }
-  virtual int DCDEvent(vfo_t, dcd_t, rig_ptr_t) const {
-		  return RIG_OK;
-  }
-};
-
-#ifdef WIN32
-extern &quot;C&quot; {
-  bool HRDInterfaceConnect(const wchar_t *host, const ushort);
-  void HRDInterfaceDisconnect();
-  bool HRDInterfaceIsConnected();
-  wchar_t* HRDInterfaceSendMessage(const wchar_t *msg);
-  void HRDInterfaceFreeString(const wchar_t *lstring);
-}
-#endif
-
-#endif	// _RIGCLASS_H
+/*
+ *  Hamlib C++ bindings - API header
+ *  Copyright (c) 2001-2002 by Stephane Fillod
+ *
+ *
+ *   This library is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU Lesser General Public
+ *   License as published by the Free Software Foundation; either
+ *   version 2.1 of the License, or (at your option) any later version.
+ *
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   Lesser General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Lesser General Public
+ *   License along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _RIGCLASS_H
+#define _RIGCLASS_H 1
+
+#include &lt;hamlib/rig.h&gt;
+#include &lt;iostream&gt;
+#include &lt;QString&gt;
+#include &lt;QTcpSocket&gt;
+
+extern QTcpSocket* commanderSocket;
+
+class BACKEND_IMPEXP Rig {
+private:
+  RIG* theRig;  // Global ref. to the rig
+  bool m_hrd;
+  bool m_cmndr;
+  QString m_context;
+
+
+protected:
+public:
+  Rig();
+  virtual ~Rig();
+
+  const struct rig_caps *caps;
+
+  // Initialize rig
+  int init(rig_model_t rig_model);
+
+  // This method open the communication port to the rig
+  int open(int n);
+
+  // This method close the communication port to the rig
+  int close(void);
+
+  int setConf(const char *name, const char *val);
+  token_t tokenLookup(const char *name);
+
+  int setFreq(freq_t freq, vfo_t vfo = RIG_VFO_CURR);
+  freq_t getFreq(vfo_t vfo = RIG_VFO_CURR);
+  int setMode(rmode_t, pbwidth_t width = RIG_PASSBAND_NORMAL, vfo_t vfo = RIG_VFO_CURR);
+  rmode_t getMode(pbwidth_t&amp;, vfo_t vfo = RIG_VFO_CURR);
+  int setVFO(vfo_t);
+  vfo_t getVFO();
+  int setXit(shortfreq_t xit, vfo_t vfo);
+  int setSplitFreq(freq_t tx_freq, vfo_t vfo = RIG_VFO_CURR);
+  int setPTT (ptt_t ptt, vfo_t vfo = RIG_VFO_CURR);
+  ptt_t getPTT (vfo_t vfo = RIG_VFO_CURR);
+
+  // callbacks available in your derived object
+  virtual int FreqEvent(vfo_t, freq_t, rig_ptr_t) const {
+		  return RIG_OK;
+  }
+  virtual int ModeEvent(vfo_t, rmode_t, pbwidth_t, rig_ptr_t) const {
+		  return RIG_OK;
+  }
+  virtual int VFOEvent(vfo_t, rig_ptr_t) const {
+		  return RIG_OK;
+  }
+  virtual int PTTEvent(vfo_t, ptt_t, rig_ptr_t) const {
+		  return RIG_OK;
+  }
+  virtual int DCDEvent(vfo_t, dcd_t, rig_ptr_t) const {
+		  return RIG_OK;
+  }
+};
+
+#ifdef WIN32
+extern &quot;C&quot; {
+  bool HRDInterfaceConnect(const wchar_t *host, const ushort);
+  void HRDInterfaceDisconnect();
+  bool HRDInterfaceIsConnected();
+  wchar_t* HRDInterfaceSendMessage(const wchar_t *msg);
+  void HRDInterfaceFreeString(const wchar_t *lstring);
+}
+#endif
+
+#endif	// _RIGCLASS_H

Modified: branches/wsjtx/signalmeter.cpp
===================================================================
--- branches/wsjtx/signalmeter.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/signalmeter.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,53 +1,53 @@
-// Simple bargraph dB meter
-// Implemented by Edson Pereira PY2SDR
-//
-// Limits and geometry are hardcded for now.
-
-#include &quot;signalmeter.h&quot;
-
-SignalMeter::SignalMeter(QWidget *parent) :
-    QWidget(parent)
-{
-    resize(parent-&gt;size());
-
-    m_meter = new MeterWidget(this);
-    m_meter-&gt;setGeometry(10, 10, 10, 120);
-
-    m_label = new QLabel(this);
-    m_label-&gt;setGeometry(10, 135, 20, 20);
-
-    QLabel *dbLabel = new QLabel(this);
-    dbLabel-&gt;setText(&quot;dB&quot;);
-    dbLabel-&gt;setGeometry(30, 135, 20, 20);
-}
-
-SignalMeter::~SignalMeter()
-{
-
-}
-
-void SignalMeter::paintEvent( QPaintEvent * )
-{
-    QPainter p;
-    p.begin(this);
-    p.drawLine(22, 10, 22, 130);
-
-    for ( int i = 0; i &lt;= 60; i += 10 ) {
-        p.drawLine(22, i*2 + 10, 25, i*2 + 10);
-    }
-
-    for ( int i = 10; i &lt; 60; i += 10 ) {
-        p.drawText(30, i*2 + 15, QString::number(60 - i));
-    }
-}
-
-void SignalMeter::setValue(int value)
-{
-    m_meter-&gt;setValue(value);
-    m_label-&gt;setText(QString::number(value));
-}
-
-void SignalMeter::resizeEvent(QResizeEvent *s)
-{
-    resize(s-&gt;size());
-}
+// Simple bargraph dB meter
+// Implemented by Edson Pereira PY2SDR
+//
+// Limits and geometry are hardcded for now.
+
+#include &quot;signalmeter.h&quot;
+
+SignalMeter::SignalMeter(QWidget *parent) :
+    QWidget(parent)
+{
+    resize(parent-&gt;size());
+
+    m_meter = new MeterWidget(this);
+    m_meter-&gt;setGeometry(10, 10, 10, 120);
+
+    m_label = new QLabel(this);
+    m_label-&gt;setGeometry(10, 135, 20, 20);
+
+    QLabel *dbLabel = new QLabel(this);
+    dbLabel-&gt;setText(&quot;dB&quot;);
+    dbLabel-&gt;setGeometry(30, 135, 20, 20);
+}
+
+SignalMeter::~SignalMeter()
+{
+
+}
+
+void SignalMeter::paintEvent( QPaintEvent * )
+{
+    QPainter p;
+    p.begin(this);
+    p.drawLine(22, 10, 22, 130);
+
+    for ( int i = 0; i &lt;= 60; i += 10 ) {
+        p.drawLine(22, i*2 + 10, 25, i*2 + 10);
+    }
+
+    for ( int i = 10; i &lt; 60; i += 10 ) {
+        p.drawText(30, i*2 + 15, QString::number(60 - i));
+    }
+}
+
+void SignalMeter::setValue(int value)
+{
+    m_meter-&gt;setValue(value);
+    m_label-&gt;setText(QString::number(value));
+}
+
+void SignalMeter::resizeEvent(QResizeEvent *s)
+{
+    resize(s-&gt;size());
+}

Modified: branches/wsjtx/signalmeter.h
===================================================================
--- branches/wsjtx/signalmeter.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/signalmeter.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,32 +1,32 @@
-#ifndef SIGNALMETER_H
-#define SIGNALMETER_H
-
-#include &lt;QtGui&gt;
-#include &lt;QLabel&gt;
-#include &lt;meterwidget.h&gt;
-
-class SignalMeter : public QWidget
-{
-    Q_OBJECT
-    
-public:
-    explicit SignalMeter(QWidget *parent = 0);
-    ~SignalMeter();
-
-public slots:
-    void setValue(int value);
-
-private:
-    MeterWidget *m_meter;
-
-    QLabel *m_label;
-
-    int m_signal;
-    int m_sigPeak;
-
-protected:
-    void paintEvent( QPaintEvent * );
-    void resizeEvent(QResizeEvent *s);
-};
-
-#endif // SIGNALMETER_H
+#ifndef SIGNALMETER_H
+#define SIGNALMETER_H
+
+#include &lt;QtGui&gt;
+#include &lt;QLabel&gt;
+#include &lt;meterwidget.h&gt;
+
+class SignalMeter : public QWidget
+{
+    Q_OBJECT
+    
+public:
+    explicit SignalMeter(QWidget *parent = 0);
+    ~SignalMeter();
+
+public slots:
+    void setValue(int value);
+
+private:
+    MeterWidget *m_meter;
+
+    QLabel *m_label;
+
+    int m_signal;
+    int m_sigPeak;
+
+protected:
+    void paintEvent( QPaintEvent * );
+    void resizeEvent(QResizeEvent *s);
+};
+
+#endif // SIGNALMETER_H

Modified: branches/wsjtx/soundin.cpp
===================================================================
--- branches/wsjtx/soundin.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/soundin.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -38,12 +38,15 @@
   return result;
 }
 
-bool SoundInput::start(QAudioDeviceInfo const&amp; device, int framesPerBuffer, QIODevice * sink)
+bool SoundInput::start(QAudioDeviceInfo const&amp; device, unsigned channels, int framesPerBuffer, QIODevice * sink)
 {
+  Q_ASSERT (0 &lt; channels &amp;&amp; channels &lt; 3);
+  Q_ASSERT (sink);
+
   stop();
 
   QAudioFormat format (device.preferredFormat());
-  format.setChannelCount (1);
+  format.setChannelCount (channels);
   format.setCodec (&quot;audio/pcm&quot;);
   format.setSampleRate (12000);
   format.setSampleType (QAudioFormat::SignedInt);

Modified: branches/wsjtx/soundin.h
===================================================================
--- branches/wsjtx/soundin.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/soundin.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -32,7 +32,7 @@
 
 public Q_SLOTS:
   // sink must exist from the start call to any following stop () call
-  bool start(QAudioDeviceInfo const&amp;, int framesPerBuffer, QIODevice * sink);
+  bool start(QAudioDeviceInfo const&amp;, unsigned channels, int framesPerBuffer, QIODevice * sink);
   void stop();
 
 private:

Modified: branches/wsjtx/soundout.cpp
===================================================================
--- branches/wsjtx/soundout.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/soundout.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -3,6 +3,7 @@
 #include &lt;QDateTime&gt;
 #include &lt;QAudioDeviceInfo&gt;
 #include &lt;QAudioOutput&gt;
+#include &lt;qmath.h&gt;
 #include &lt;QDebug&gt;
 
 #if defined (WIN32)
@@ -52,18 +53,15 @@
   Q_ASSERT (source);
 }
 
-void SoundOutput::startStream (QAudioDeviceInfo const&amp; device)
+void SoundOutput::startStream (QAudioDeviceInfo const&amp; device, unsigned channels)
 {
-  if (!m_stream || device != m_currentDevice)
+  Q_ASSERT (0 &lt; channels &amp;&amp; channels &lt; 3);
+
+  if (!m_stream || device != m_currentDevice || channels != static_cast&lt;unsigned&gt; (m_stream-&gt;format ().channelCount ()))
     {
       QAudioFormat format (device.preferredFormat ());
 
-#ifdef UNIX
-      format.setChannelCount (2);
-#else
-      format.setChannelCount (1);
-#endif
-
+      format.setChannelCount (channels);
       format.setCodec (&quot;audio/pcm&quot;);
       format.setSampleRate (48000);
       format.setSampleType (QAudioFormat::SignedInt);
@@ -79,6 +77,7 @@
 
       m_stream.reset (new QAudioOutput (device, format, this));
       audioError ();
+      m_stream-&gt;setVolume (m_volume);
 
       connect (m_stream.data(), &amp;QAudioOutput::stateChanged, this, &amp;SoundOutput::handleStateChanged);
 
@@ -86,13 +85,13 @@
     }
 
   //
-  // This buffer size is critical since we are running in the GUI
-  // thread. If it is too short; high activity levels on the GUI can
-  // starve the audio buffer. On the other hand the Windows
-  // implementation seems to take the length of the buffer in time to
-  // stop the audio stream even if reset() is used.
+  // This buffer size is critical since for proper sound streaming. If
+  // it is too short; high activity levels on the machine can starve
+  // the audio buffer. On the other hand the Windows implementation
+  // seems to take the length of the buffer in time to stop the audio
+  // stream even if reset() is used.
   //
-  // 1 seconds seems a reasonable compromise except for Windows
+  // 2 seconds seems a reasonable compromise except for Windows
   // where things are probably broken.
   //
   // we have to set this before every start on the stream because the
@@ -121,6 +120,31 @@
     }
 }
 
+qreal SoundOutput::attenuation () const
+{
+  return -(10. * qLn (m_volume) / qLn (10.));
+}
+
+void SoundOutput::setAttenuation (qreal a)
+{
+  Q_ASSERT (0. &lt;= a &amp;&amp; a &lt;= 99.);
+  m_volume = qPow (10., -a / 10.);
+  qDebug () &lt;&lt; &quot;SoundOut: attn = &quot; &lt;&lt; a &lt;&lt; &quot;, vol = &quot; &lt;&lt; m_volume;
+  if (m_stream)
+    {
+      m_stream-&gt;setVolume (m_volume);
+    }
+}
+
+void SoundOutput::resetAttenuation ()
+{
+  m_volume = 1.;
+  if (m_stream)
+    {
+      m_stream-&gt;setVolume (m_volume);
+    }
+}
+
 void SoundOutput::stopStream ()
 {
   if (m_stream)

Modified: branches/wsjtx/soundout.h
===================================================================
--- branches/wsjtx/soundout.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/soundout.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -17,6 +17,7 @@
   Q_OBJECT;
 
   Q_PROPERTY(bool running READ isRunning);
+  Q_PROPERTY(unsigned attenuation READ attenuation WRITE setAttenuation RESET resetAttenuation);
 
  private:
   Q_DISABLE_COPY (SoundOutput);
@@ -26,12 +27,18 @@
   ~SoundOutput ();
 
   bool isRunning() const {return m_active;}
+  qreal attenuation () const;
 
- public Q_SLOTS:
-  void startStream (QAudioDeviceInfo const&amp; device);
+ private Q_SLOTS:
+  /* private because we expect to run in a thread and don't want direct
+     C++ calls made, instead they must be invoked via the Qt
+     signal/slot mechanism which is thread safe */
+  void startStream (QAudioDeviceInfo const&amp; device, unsigned channels);
   void suspend ();
   void resume ();
   void stopStream ();
+  void setAttenuation (qreal);	/* unsigned */
+  void resetAttenuation ();	/* to zero */
 
  Q_SIGNALS:
   void error (QString message) const;
@@ -49,6 +56,7 @@
   QIODevice * m_source;
   bool volatile m_active;
   QAudioDeviceInfo m_currentDevice;
+  qreal m_volume;
 };
 
 #endif

Modified: branches/wsjtx/widegraph.cpp
===================================================================
--- branches/wsjtx/widegraph.cpp	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/widegraph.cpp	2013-08-10 15:29:55 UTC (rev 3542)
@@ -4,16 +4,20 @@
 
 #define MAX_SCREENSIZE 2048
 
-WideGraph::WideGraph(QWidget *parent) :
+WideGraph::WideGraph(QSettings * settings, QWidget *parent) :
   QDialog(parent),
-  ui(new Ui::WideGraph)
+  ui(new Ui::WideGraph),
+  m_settings (settings)
 {
+  installEventFilter (parent);
+
+  setWindowTitle (&quot;Wide Graph&quot;);
+  setWindowFlags (Qt::WindowCloseButtonHint | Qt::WindowMinimizeButtonHint);
+  setMaximumWidth (MAX_SCREENSIZE);
+  setMaximumHeight (880);
+
   ui-&gt;setupUi(this);
-  this-&gt;setWindowFlags(Qt::Dialog);
-  this-&gt;installEventFilter(parent); //Installing the filter
   ui-&gt;widePlot-&gt;setCursor(Qt::CrossCursor);
-	this-&gt;setMaximumWidth(MAX_SCREENSIZE);
-  this-&gt;setMaximumHeight(880);
   ui-&gt;widePlot-&gt;setMaximumHeight(800);
   ui-&gt;widePlot-&gt;m_bCurrent=false;
 
@@ -23,38 +27,35 @@
   connect(ui-&gt;widePlot, SIGNAL(setFreq1(int,int)),this,
           SLOT(setFreq2(int,int)));
 
-  m_fMin=3000;
-  ui-&gt;fMinSpinBox-&gt;setValue(m_fMin);
-
   //Restore user's settings
-  QString inifile(QApplication::applicationDirPath());
-  inifile += &quot;/wsjtx.ini&quot;;
-  QSettings settings(inifile, QSettings::IniFormat);
-
-  settings.beginGroup(&quot;WideGraph&quot;);
-  ui-&gt;widePlot-&gt;setPlotZero(settings.value(&quot;PlotZero&quot;, 0).toInt());
-  ui-&gt;widePlot-&gt;setPlotGain(settings.value(&quot;PlotGain&quot;, 0).toInt());
+  m_settings-&gt;beginGroup(&quot;WideGraph&quot;);
+  restoreGeometry (m_settings-&gt;value (&quot;geometry&quot;, saveGeometry ()).toByteArray ());
+  ui-&gt;widePlot-&gt;setPlotZero(m_settings-&gt;value(&quot;PlotZero&quot;, 0).toInt());
+  ui-&gt;widePlot-&gt;setPlotGain(m_settings-&gt;value(&quot;PlotGain&quot;, 0).toInt());
   ui-&gt;zeroSpinBox-&gt;setValue(ui-&gt;widePlot-&gt;getPlotZero());
   ui-&gt;gainSpinBox-&gt;setValue(ui-&gt;widePlot-&gt;getPlotGain());
-  int n = settings.value(&quot;FreqSpan&quot;,2).toInt();
-  int w = settings.value(&quot;PlotWidth&quot;,1000).toInt();
+  int n = m_settings-&gt;value(&quot;FreqSpan&quot;,2).toInt();
+  int w = m_settings-&gt;value(&quot;PlotWidth&quot;,1000).toInt();
   ui-&gt;widePlot-&gt;m_w=w;
   ui-&gt;freqSpanSpinBox-&gt;setValue(n);
   ui-&gt;widePlot-&gt;setNSpan(n);
-  m_waterfallAvg = settings.value(&quot;WaterfallAvg&quot;,5).toInt();
+  m_waterfallAvg = m_settings-&gt;value(&quot;WaterfallAvg&quot;,5).toInt();
   ui-&gt;waterfallAvgSpinBox-&gt;setValue(m_waterfallAvg);
-  ui-&gt;widePlot-&gt;m_bCurrent=settings.value(&quot;Current&quot;,false).toBool();
-  ui-&gt;widePlot-&gt;m_bCumulative=settings.value(&quot;Cumulative&quot;,true).toBool();
+  ui-&gt;widePlot-&gt;m_bCurrent=m_settings-&gt;value(&quot;Current&quot;,false).toBool();
+  ui-&gt;widePlot-&gt;m_bCumulative=m_settings-&gt;value(&quot;Cumulative&quot;,true).toBool();
   if(ui-&gt;widePlot-&gt;m_bCurrent) ui-&gt;spec2dComboBox-&gt;setCurrentIndex(0);
   if(ui-&gt;widePlot-&gt;m_bCumulative) ui-&gt;spec2dComboBox-&gt;setCurrentIndex(1);
-  int nbpp=settings.value(&quot;BinsPerPixel&quot;,2).toInt();
+  int nbpp=m_settings-&gt;value(&quot;BinsPerPixel&quot;,2).toInt();
   ui-&gt;widePlot-&gt;setBinsPerPixel(nbpp);
-  m_slope=settings.value(&quot;Slope&quot;,0.0).toDouble();
+  m_slope=m_settings-&gt;value(&quot;Slope&quot;,0.0).toDouble();
   ui-&gt;slopeSpinBox-&gt;setValue(m_slope);
-  ui-&gt;widePlot-&gt;setStartFreq(settings.value(&quot;StartFreq&quot;,0).toInt());
+  ui-&gt;widePlot-&gt;setStartFreq(m_settings-&gt;value(&quot;StartFreq&quot;,0).toInt());
   ui-&gt;fStartSpinBox-&gt;setValue(ui-&gt;widePlot-&gt;startFreq());
-  m_waterfallPalette=settings.value(&quot;WaterfallPalette&quot;,&quot;Default&quot;).toString();
-  settings.endGroup();
+  m_waterfallPalette=m_settings-&gt;value(&quot;WaterfallPalette&quot;,&quot;Default&quot;).toString();
+  int m_fMin = m_settings-&gt;value (&quot;fMin&quot;, 2500).toInt ();
+  ui-&gt;fMinSpinBox-&gt;setValue (m_fMin);
+  setRxRange (m_fMin);
+  m_settings-&gt;endGroup();
 
   QDir recoredDir(&quot;Palettes&quot;);
   QStringList allFiles = recoredDir.entryList(QDir::NoDotAndDotDot |
@@ -73,32 +74,33 @@
   readPalette(&quot;Palettes/&quot; + m_waterfallPalette + &quot;.pal&quot;);
 }
 
-WideGraph::~WideGraph()
+WideGraph::~WideGraph ()
 {
-  saveSettings();
-  delete ui;
 }
 
-void WideGraph::saveSettings()
+void WideGraph::closeEvent (QCloseEvent * e)
 {
-  //Save user's settings
-  QString inifile(QApplication::applicationDirPath());
-  inifile += &quot;/wsjtx.ini&quot;;
-  QSettings settings(inifile, QSettings::IniFormat);
+  saveSettings ();
+  QDialog::closeEvent (e);
+}
 
-  settings.beginGroup(&quot;WideGraph&quot;);
-  settings.setValue(&quot;PlotZero&quot;,ui-&gt;widePlot-&gt;m_plotZero);
-  settings.setValue(&quot;PlotGain&quot;,ui-&gt;widePlot-&gt;m_plotGain);
-  settings.setValue(&quot;PlotWidth&quot;,ui-&gt;widePlot-&gt;plotWidth());
-  settings.setValue(&quot;FreqSpan&quot;,ui-&gt;freqSpanSpinBox-&gt;value());
-  settings.setValue(&quot;WaterfallAvg&quot;,ui-&gt;waterfallAvgSpinBox-&gt;value());
-  settings.setValue(&quot;Current&quot;,ui-&gt;widePlot-&gt;m_bCurrent);
-  settings.setValue(&quot;Cumulative&quot;,ui-&gt;widePlot-&gt;m_bCumulative);
-  settings.setValue(&quot;BinsPerPixel&quot;,ui-&gt;widePlot-&gt;binsPerPixel());
-  settings.setValue(&quot;Slope&quot;,m_slope);
-  settings.setValue(&quot;StartFreq&quot;,ui-&gt;widePlot-&gt;startFreq());
-  settings.setValue(&quot;WaterfallPalette&quot;,m_waterfallPalette);
-  settings.endGroup();
+void WideGraph::saveSettings()
+{
+  m_settings-&gt;beginGroup (&quot;WideGraph&quot;);
+  m_settings-&gt;setValue (&quot;geometry&quot;, saveGeometry ());
+  m_settings-&gt;setValue (&quot;PlotZero&quot;, ui-&gt;widePlot-&gt;m_plotZero);
+  m_settings-&gt;setValue (&quot;PlotGain&quot;, ui-&gt;widePlot-&gt;m_plotGain);
+  m_settings-&gt;setValue (&quot;PlotWidth&quot;, ui-&gt;widePlot-&gt;plotWidth ());
+  m_settings-&gt;setValue (&quot;FreqSpan&quot;, ui-&gt;freqSpanSpinBox-&gt;value ());
+  m_settings-&gt;setValue (&quot;WaterfallAvg&quot;, ui-&gt;waterfallAvgSpinBox-&gt;value ());
+  m_settings-&gt;setValue (&quot;Current&quot;, ui-&gt;widePlot-&gt;m_bCurrent);
+  m_settings-&gt;setValue (&quot;Cumulative&quot;, ui-&gt;widePlot-&gt;m_bCumulative);
+  m_settings-&gt;setValue (&quot;BinsPerPixel&quot;, ui-&gt;widePlot-&gt;binsPerPixel ());
+  m_settings-&gt;setValue (&quot;Slope&quot;, m_slope);
+  m_settings-&gt;setValue (&quot;StartFreq&quot;, ui-&gt;widePlot-&gt;startFreq ());
+  m_settings-&gt;setValue (&quot;WaterfallPalette&quot;, m_waterfallPalette);
+  m_settings-&gt;setValue (&quot;Fmin&quot;, m_fMin);
+  m_settings-&gt;endGroup ();
 }
 
 void WideGraph::dataSink2(float s[], float df3, int ihsym,
@@ -238,13 +240,6 @@
   return n;
 }
 
-void WideGraph::setFmin(int n)
-{
-  m_fMin = n;
-  ui-&gt;fMinSpinBox-&gt;setValue(n);
-  setRxRange(m_fMin);
-}
-
 double WideGraph::fGreen()
 {
   return ui-&gt;widePlot-&gt;fGreen();

Modified: branches/wsjtx/widegraph.h
===================================================================
--- branches/wsjtx/widegraph.h	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/widegraph.h	2013-08-10 15:29:55 UTC (rev 3542)
@@ -1,88 +1,93 @@
-#ifndef WIDEGRAPH_H
-#define WIDEGRAPH_H
-#include &lt;QDialog&gt;
-
-namespace Ui {
-  class WideGraph;
-}
-
-class WideGraph : public QDialog
-{
-  Q_OBJECT
-
-public:
-  explicit WideGraph(QWidget *parent = 0);
-  ~WideGraph();
-
-  void   dataSink2(float s[], float df3, int ihsym, int ndiskdata);
-  void   setRxFreq(int n);
-  int    rxFreq();
-  int    nSpan();
-  int    nStartFreq();
-  int    getFmin();
-  int    getFmax();
-  float  fSpan();
-  void   saveSettings();
-  void   setRxRange(int fMin);
-  void   setFmin(int n);
-  void   setFsample(int n);
-  void   setPeriod(int ntrperiod, int nsps);
-  void   setTxFreq(int n);
-  void   setMode(QString mode);
-  void   setModeTx(QString modeTx);
-  void   setSlope(double d);
-  void   setLockTxFreq(bool b);
-  double getSlope();
-  double fGreen();
-  void   readPalette(QString fileName);
-
-  qint32 m_rxFreq;
-  qint32 m_txFreq;
-
-signals:
-  void freezeDecode2(int n);
-  void f11f12(int n);
-  void setXIT2(int n);
-  void setFreq3(int rxFreq, int txFreq);
-
-public slots:
-  void wideFreezeDecode(int n);
-  void setFreq2(int rxFreq, int txFreq);
-  void setDialFreq(double d);
-
-protected:
-  virtual void keyPressEvent( QKeyEvent *e );
-
-private slots:
-  void on_waterfallAvgSpinBox_valueChanged(int arg1);
-  void on_freqSpanSpinBox_valueChanged(int arg1);
-  void on_zeroSpinBox_valueChanged(int arg1);
-  void on_gainSpinBox_valueChanged(int arg1);
-  void on_spec2dComboBox_currentIndexChanged(const QString &amp;arg1);
-  void on_fMinSpinBox_valueChanged(int n);
-  void on_slopeSpinBox_valueChanged(double d);
-  void on_fStartSpinBox_valueChanged(int n);
-  void on_paletteComboBox_activated(const QString &amp;palette);
-
-private:
-  double m_slope;
-  double m_dialFreq;
-
-  qint32 m_waterfallAvg;
-  qint32 m_fSample;
-  qint32 m_TRperiod;
-  qint32 m_nsps;
-  qint32 m_ntr0;
-  qint32 m_fMin;
-  qint32 m_fMax;
-
-  bool   m_lockTxFreq;
-
-  QString m_mode;
-  QString m_modeTx;
-  QString m_waterfallPalette;
-
-  Ui::WideGraph *ui;
-};
-
-#endif // WIDEGRAPH_H
+#ifndef WIDEGRAPH_H
+#define WIDEGRAPH_H
+
+#include &lt;QDialog&gt;
+#include &lt;QScopedPointer&gt;
+
+namespace Ui {
+  class WideGraph;
+}
+
+class QSettings;
+
+class WideGraph : public QDialog
+{
+  Q_OBJECT
+
+public:
+  explicit WideGraph(QSettings *, QWidget *parent = 0);
+  ~WideGraph ();
+
+  void   dataSink2(float s[], float df3, int ihsym, int ndiskdata);
+  void   setRxFreq(int n);
+  int    rxFreq();
+  int    nSpan();
+  int    nStartFreq();
+  int    getFmin();
+  int    getFmax();
+  float  fSpan();
+  void   saveSettings();
+  void   setRxRange(int fMin);
+  void   setFsample(int n);
+  void   setPeriod(int ntrperiod, int nsps);
+  void   setTxFreq(int n);
+  void   setMode(QString mode);
+  void   setModeTx(QString modeTx);
+  void   setSlope(double d);
+  void   setLockTxFreq(bool b);
+  double getSlope();
+  double fGreen();
+  void   readPalette(QString fileName);
+
+signals:
+  void freezeDecode2(int n);
+  void f11f12(int n);
+  void setXIT2(int n);
+  void setFreq3(int rxFreq, int txFreq);
+
+public slots:
+  void wideFreezeDecode(int n);
+  void setFreq2(int rxFreq, int txFreq);
+  void setDialFreq(double d);
+
+protected:
+  virtual void keyPressEvent( QKeyEvent *e );
+  void closeEvent (QCloseEvent *);
+
+private slots:
+  void on_waterfallAvgSpinBox_valueChanged(int arg1);
+  void on_freqSpanSpinBox_valueChanged(int arg1);
+  void on_zeroSpinBox_valueChanged(int arg1);
+  void on_gainSpinBox_valueChanged(int arg1);
+  void on_spec2dComboBox_currentIndexChanged(const QString &amp;arg1);
+  void on_fMinSpinBox_valueChanged(int n);
+  void on_slopeSpinBox_valueChanged(double d);
+  void on_fStartSpinBox_valueChanged(int n);
+  void on_paletteComboBox_activated(const QString &amp;palette);
+
+private:
+  QScopedPointer&lt;Ui::WideGraph&gt; ui;
+  QSettings * m_settings;
+
+  qint32 m_rxFreq;
+  qint32 m_txFreq;
+
+  double m_slope;
+  double m_dialFreq;
+
+  qint32 m_waterfallAvg;
+  qint32 m_fSample;
+  qint32 m_TRperiod;
+  qint32 m_nsps;
+  qint32 m_ntr0;
+  qint32 m_fMin;
+  qint32 m_fMax;
+
+  bool   m_lockTxFreq;
+
+  QString m_mode;
+  QString m_modeTx;
+  QString m_waterfallPalette;
+};
+
+#endif // WIDEGRAPH_H

Modified: branches/wsjtx/wsjtx.pro
===================================================================
--- branches/wsjtx/wsjtx.pro	2013-08-09 23:11:05 UTC (rev 3541)
+++ branches/wsjtx/wsjtx.pro	2013-08-10 15:29:55 UTC (rev 3542)
@@ -67,7 +67,7 @@
 HEADERS  += mainwindow.h plotter.h soundin.h soundout.h \
             about.h devsetup.h widegraph.h getfile.h \
             commons.h sleep.h displaytext.h logqso.h \
-            Detector.hpp Modulator.hpp psk_reporter.h rigclass.h \
+            AudioDevice.hpp Detector.hpp Modulator.hpp psk_reporter.h rigclass.h \
     signalmeter.h \
     meterwidget.h \
     logbook/logbook.h \

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003233.html">[WSJT-SVN] r3541 - in branches/wsjtx: . lib
</A></li>
	<LI>Next message: <A HREF="003235.html">[WSJT-SVN] r3543 - branches/wsjtx
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3234">[ date ]</a>
              <a href="thread.html#3234">[ thread ]</a>
              <a href="subject.html#3234">[ subject ]</a>
              <a href="author.html#3234">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
