<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2996 - in trunk: . jt4
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2013-February/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2996%20-%20in%20trunk%3A%20.%20jt4&In-Reply-To=%3C20130205161632.CA7E055B0C%40scm.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="002689.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2996 - in trunk: . jt4</H1>
    <B>k1jt at scm.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2996%20-%20in%20trunk%3A%20.%20jt4&In-Reply-To=%3C20130205161632.CA7E055B0C%40scm.berlios.de%3E"
       TITLE="[WSJT-SVN] r2996 - in trunk: . jt4">k1jt at scm.berlios.de
       </A><BR>
    <I>Tue Feb  5 17:16:32 CET 2013</I>
    <P><UL>
        
        <LI>Next message: <A HREF="002689.html">[WSJT-SVN] r2997 - trunk/jt4
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2688">[ date ]</a>
              <a href="thread.html#2688">[ thread ]</a>
              <a href="subject.html#2688">[ subject ]</a>
              <a href="author.html#2688">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2013-02-05 17:16:31 +0100 (Tue, 05 Feb 2013)
New Revision: 2996

Added:
   trunk/gran.c
   trunk/jt4/
   trunk/jt4/Makefile
   trunk/jt4/acfs.f90
   trunk/jt4/chkmsg.f
   trunk/jt4/conv232.f90
   trunk/jt4/deg2grid.f
   trunk/jt4/encode232.f90
   trunk/jt4/encode4.f90
   trunk/jt4/entail.f
   trunk/jt4/fano232.f90
   trunk/jt4/getmet4.f90
   trunk/jt4/getpfx1.f
   trunk/jt4/getpfx2.f
   trunk/jt4/gran.c
   trunk/jt4/grid2deg.f
   trunk/jt4/grid2k.f
   trunk/jt4/interleave4.f90
   trunk/jt4/jt4code.f90
   trunk/jt4/jt4metrics.f90
   trunk/jt4/k2grid.f
   trunk/jt4/nchar.f
   trunk/jt4/packcall.f
   trunk/jt4/packgrid.f
   trunk/jt4/packmsg.f
   trunk/jt4/packtext.f
   trunk/jt4/pfx.f
   trunk/jt4/simjt4.f90
   trunk/jt4/simsync.f90
   trunk/jt4/unpackcall.f
   trunk/jt4/unpackgrid.f
   trunk/jt4/unpackmsg.f
   trunk/jt4/unpacktext.f
Removed:
   trunk/encode232.f
   trunk/gran.f90
Modified:
   trunk/Makefile.MinGW
   trunk/packmsg.f
Log:
Added a &quot;jt4&quot; subdirectory for tests of the JT4 decoding procedures.


Modified: trunk/Makefile.MinGW
===================================================================
--- trunk/Makefile.MinGW	2013-01-31 14:13:31 UTC (rev 2995)
+++ trunk/Makefile.MinGW	2013-02-05 16:16:31 UTC (rev 2996)
@@ -34,7 +34,7 @@
 	$(FC) $(FFLAGS) -o JT65code.exe $(OBJS1)
 
 OBJS2C   = init_rs.o encode_rs.o decode_rs.o jtaudio.o fano.o \
-	tab.o nhash.o
+	tab.o nhash.o 
 
 OBJS4	= t72.o abc441.o gen441.o coh441.o dfdphi.o tweak1.o
 t72.exe:$(OBJS4)
@@ -56,20 +56,21 @@
 	ftn_quit.f90 get_fname.f90 getfile.F90 horizspec.f90 hscroll.f90 \
 	pix2d.f90 pix2d65.f90 rfile.f90 savedata.f90 spec.f90 match.f90 \
 	wsjtgen.f90 fivehz.f90 chkt0.f90 deep65.f90 makepings.f90 \
-	packpfx.f90 unpackpfx.f90 genms.f90 decodems.f90 setupms.f90 gran.f90 \
+	packpfx.f90 unpackpfx.f90 genms.f90 decodems.f90 setupms.f90 \
 	thnix.f90 tweak1.f90 smo.f90 analytic.f90 geniscat.f90 synciscat.f90 \
 	iscat.f90 four2a.f90 hipass.f90 msdf.f90 syncms.f90 lenms.f90 \
 	jtms.f90 foldms.f90 avecho.f90 echogen.f90 alignmsg.f90 \
 	chk441.f90 gen441.f90 tm2.f90 gendiana.f90 diana.f90 ana932.f90 \
 	specdiana.f90 syncdiana.f90 decdiana.f90 tweak2.f90 dtrim.f90 \
-	wsjt24.f90 decode24.f90 encode4.f90 getmet24.f90 extract4.f90 \
-	deep24.f90 avemsg4.f90 encode232.f90 fano232.f90 sync24.f90 \
-	snr4.f90 xcor24.f90
+	wsjt4.f90 decode4.f90 encode4.f90 getmet4.f90 extract4.f90 \
+	deep4.f90 avemsg4.f90 encode232.f90 fano232.f90 sync4.f90 \
+	snr4.f90 xcor4.f90 gen4.f90 ps4.f90 interleave4.f90 rfile2.f90
 
 
+
 SRCS2F77 = avesp2.f bzap.f spec441.f spec2d.f mtdecode.f stdecode.f \
-	indexx.f s2shape.f flat2.f gen65.f gen24.f entail.f \
-	genmet.f ps24.f chkmsg.f interleave24.f astro.f extract.f \
+	indexx.f s2shape.f flat2.f gen65.f entail.f \
+	genmet.f chkmsg.f astro.f extract.f \
 	gentone.f syncf0.f syncf1.f synct.f avemsg6m.f \
 	set.f flatten.f db.f pctile.f sort.f ssort.f ps.f smooth.f ping.f \
 	longx.f peakup.f sync.f detect.f avemsg65.f decode65.f demod64a.f \
@@ -82,11 +83,10 @@
 	xcor.f xfft.f xfft2.f wsjt65.f azdist.f coord.f dcoord.f \
 	deg2grid.f dot.f ftsky.f geocentric.f GeoDist.f grid2deg.f \
 	moon2.f MoonDop.f sun.f toxyz.f pfxdump.f \
-	ftpeak65.f fil651.f fil652.f fil653.f symsync65.f \
-	rfile2.f
+	ftpeak65.f fil651.f fil652.f fil653.f symsync65.f 
 
 SRCS2C   = resample.c ptt.c igray.c wrapkarn.c start_threads.c \
-	cutil.c fthread.c tmoonsub.c
+	cutil.c fthread.c tmoonsub.c gran.c
 
 WSJT9.EXE: WsjtMod/Audio.pyd wsjt.spec
 	c:/python27/python c:/python27/pyinstaller-1.5.1/Build.py wsjt.spec

Deleted: trunk/encode232.f
===================================================================
--- trunk/encode232.f	2013-01-31 14:13:31 UTC (rev 2995)
+++ trunk/encode232.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -1,30 +0,0 @@
-      subroutine encode232(dat,nbytes,symbol,maxsym)
-
-C  Convolutional encoder for a K=32, r=1/2 code.
-
-      integer*1 dat(nbytes)             !User data, packed 8 bits per byte
-      integer*1 symbol(maxsym)          !Channel symbols, one bit per byte
-      integer*1 i1
-      include 'conv232.f'
-
-      nstate=0
-      k=0
-      do j=1,nbytes
-         do i=7,0,-1
-            i1=dat(j)
-            i4=i1
-            if (i4.lt.0) i4=i4+256
-            nstate=ior(ishft(nstate,1),iand(ishft(i4,-i),1))
-            n=iand(nstate,npoly1)
-            n=ieor(n,ishft(n,-16))
-            k=k+1
-            symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
-            n=iand(nstate,npoly2)
-            n=ieor(n,ishft(n,-16))
-            k=k+1
-            symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
-         enddo
-      enddo
-
-      return
-      end

Added: trunk/gran.c
===================================================================
--- trunk/gran.c	                        (rev 0)
+++ trunk/gran.c	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,28 @@
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+/* Generate gaussian random float with mean=0 and std_dev=1 */
+float gran_()
+{
+  float fac,rsq,v1,v2;
+  static float gset;
+  static int iset;
+
+  if(iset){
+    /* Already got one */
+    iset = 0;
+    return gset;
+  }
+  /* Generate two evenly distributed numbers between -1 and +1
+   * that are inside the unit circle
+   */
+  do {
+    v1 = 2.0 * (float)rand() / RAND_MAX - 1;
+    v2 = 2.0 * (float)rand() / RAND_MAX - 1;
+    rsq = v1*v1 + v2*v2;
+  } while(rsq &gt;= 1.0 || rsq == 0.0);
+  fac = sqrt(-2.0*log(rsq)/rsq);
+  gset = v1*fac;
+  iset++;
+  return v2*fac;
+}

Deleted: trunk/gran.f90
===================================================================
--- trunk/gran.f90	2013-01-31 14:13:31 UTC (rev 2995)
+++ trunk/gran.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -1,9 +0,0 @@
-real function gran(idum)
-  real r(12)
-  if(idum.lt.0) then
-     call random_seed
-     idum=0
-  endif
-  call random_number(r)
-  gran=sum(r)-6.0
-end function gran

Added: trunk/jt4/Makefile
===================================================================
--- trunk/jt4/Makefile	                        (rev 0)
+++ trunk/jt4/Makefile	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,53 @@
+# Makefile for Windows
+# For re-direct:
+#   C&gt; make &gt; junk 2&gt;&amp;1
+
+CC = /mingw/bin/gcc
+FC = /mingw/bin/g95
+
+FFLAGS = -O2 -fbounds-check -Wall -Wno-precision-loss
+CFLAGS = -I. -fbounds-check
+
+# Default rules
+%.o: %.c
+	${CC} ${CFLAGS} -c $&lt;
+%.o: %.f
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.f90
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F90
+	${FC} ${FFLAGS} -c $&lt;
+
+all:    libjt.a jt4metrics.exe simsync.exe jt4code.exe simjt4.exe
+
+OBJS1 = chkmsg.o deg2grid.o encode232.o encode4.o entail.o fano232.o \
+	getmet4.o getpfx1.o getpfx2.o gran.o grid2deg.o grid2k.o \
+	interleave4.o k2grid.o nchar.o packcall.o packgrid.o packmsg.o \
+	packtext.o unpackcall.o unpackgrid.o unpackmsg.o unpacktext.o
+
+libjt.a: $(OBJS1)
+	ar cr libjt.a $(OBJS1) 
+	ranlib libjt.a
+
+OBJS2 = jt4metrics.o libjt.a 
+jt4metrics.exe: $(OBJS2)
+	$(FC) -o jt4metrics.exe $(FFLAGS) $(OBJS2)  libjt.a 
+
+OBJS3 = simsync.o  libjt.a 
+simsync.exe: $(OBJS3)
+	$(FC) -o simsync.exe $(FFLAGS) $(OBJS3) libjt.a 
+
+OBJS4 = jt4code.o libjt.a 
+jt4code.exe: $(OBJS4)
+	$(FC) -o jt4code.exe $(FFLAGS) $(OBJS4) libjt.a 
+
+OBJS5 = simjt4.o libjt.a 
+simjt4.exe: $(OBJS5)
+	$(FC) -o simjt4.exe $(FFLAGS) $(OBJS5) libjt.a 
+
+.PHONY : clean
+
+clean:
+	rm -f *.o jt4metrics.exe simsync.exe jt4code.exe simjt4.exe

Added: trunk/jt4/acfs.f90
===================================================================
--- trunk/jt4/acfs.f90	                        (rev 0)
+++ trunk/jt4/acfs.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,55 @@
+program acfs
+
+  character*63 ctmp
+  real acf1(0:50)
+  real acf2(0:50)
+  integer is1(207)
+  integer is2(207)
+  data is1/                                                       &amp;
+       0,0,0,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,1,1,0,0, &amp;
+       0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0, &amp;
+       1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,0,0,1, &amp;
+       0,0,0,1,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1, &amp;
+       0,1,1,1,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,0,1,1,0,0,0,1,1,1, &amp;
+       0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,1,1, &amp;
+       1,0,0,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1/
+  data m1/z'4314f472'/,m2/z'5bb357e0'/
+
+  write(ctmp,1000) m1,m2
+1000 format(b31.31,b32.32)
+  read(ctmp,1002) is2(1:63)
+1002 format(63b1)
+
+  j=0
+  do i=64,207
+     j=j+1
+     if(j.gt.63) j=j-63
+     is2(i)=is2(j)
+  enddo
+
+  sq1=0.
+  sq2=0.
+  do lag=0,50
+     n1=0
+     n2=0
+     do i=1,207-lag
+        j=i+lag
+        if(is1(i).eq.is1(j)) n1=n1+1
+        if(is2(i).eq.is2(j)) n2=n2+1
+        if(is1(i).ne.is1(j)) n1=n1-1
+        if(is2(i).ne.is2(j)) n2=n2-1
+     enddo
+     acf1(lag)=float(n1)/(207.0-lag)
+     acf2(lag)=float(n2)/(207.0-lag)
+     sq1=sq1 + acf1(lag)**2
+     sq2=sq2 + acf2(lag)**2
+     write(13,1010) lag,acf1(lag),acf2(lag)
+1010 format(i2,2f10.4)
+  enddo
+
+  rms1=sqrt((sq1-1.0)/50.0)
+  rms2=sqrt((sq2-1.0)/50.0)
+  print*,sum(is1),rms1,maxval(acf1(2:))
+  print*,sum(is2),rms2,maxval(acf2(2:))
+
+end program acfs

Added: trunk/jt4/chkmsg.f
===================================================================
--- trunk/jt4/chkmsg.f	                        (rev 0)
+++ trunk/jt4/chkmsg.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,33 @@
+      subroutine chkmsg(message,cok,nspecial,flip)
+
+      character message*22,cok*3
+
+      nspecial=0
+      flip=1.0
+      cok=&quot;   &quot;
+
+      do i=22,1,-1
+         if(message(i:i).ne.' ') go to 10
+      enddo
+      i=22
+
+ 10   if(i.ge.11) then
+         if((message(i-3:i).eq.' OOO') .or. 
+     +                 (message(20:22).eq.' OO')) then
+            cok='OOO'
+            flip=-1.0
+            if(message(20:22).eq.' OO') then
+               message=message(1:19)
+            else
+               message=message(1:i-4)
+            endif
+         endif
+      endif
+
+!      if(message(1:3).eq.'ATT') nspecial=1
+      if(message(1:2).eq.'RO')  nspecial=2
+      if(message(1:3).eq.'RRR') nspecial=3
+      if(message(1:2).eq.'73')  nspecial=4
+
+      return
+      end

Added: trunk/jt4/conv232.f90
===================================================================
--- trunk/jt4/conv232.f90	                        (rev 0)
+++ trunk/jt4/conv232.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,38 @@
+! Layland-Lushbaugh polynomials for a K=32, r=1/2 convolutional code,
+! and 8-bit parity lookup table.
+
+      data npoly1/-221228207/,npoly2/-463389625/
+      integer*1 partab(0:255)
+      data partab/                &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
+         1, 0, 0, 1, 0, 1, 1, 0/

Added: trunk/jt4/deg2grid.f
===================================================================
--- trunk/jt4/deg2grid.f	                        (rev 0)
+++ trunk/jt4/deg2grid.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,30 @@
+      subroutine deg2grid(dlong0,dlat,grid)
+
+      real dlong                        !West longitude (deg)
+      real dlat                         !Latitude (deg)
+      character grid*6
+
+      dlong=dlong0
+      if(dlong.lt.-180.0) dlong=dlong+360.0
+      if(dlong.gt.180.0) dlong=dlong-360.0
+
+C  Convert to units of 5 min of longitude, working east from 180 deg.
+      nlong=60.0*(180.0-dlong)/5.0
+      n1=nlong/240                      !20-degree field
+      n2=(nlong-240*n1)/24              !2 degree square
+      n3=nlong-240*n1-24*n2             !5 minute subsquare
+      grid(1:1)=char(ichar('A')+n1)
+      grid(3:3)=char(ichar('0')+n2)
+      grid(5:5)=char(ichar('a')+n3)
+
+C  Convert to units of 2.5 min of latitude, working north from -90 deg.
+      nlat=60.0*(dlat+90)/2.5
+      n1=nlat/240                       !10-degree field
+      n2=(nlat-240*n1)/24               !1 degree square
+      n3=nlat-240*n1-24*n2              !2.5 minuts subsquare
+      grid(2:2)=char(ichar('A')+n1)
+      grid(4:4)=char(ichar('0')+n2)
+      grid(6:6)=char(ichar('a')+n3)
+
+      return
+      end

Added: trunk/jt4/encode232.f90
===================================================================
--- trunk/jt4/encode232.f90	                        (rev 0)
+++ trunk/jt4/encode232.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,33 @@
+subroutine encode232(dat,nsym,symbol)
+
+! Convolutional encoder for a K=32, r=1/2 code.
+
+  integer*1 dat(13)                 !User data, packed 8 bits per byte
+  integer*1 symbol(500)             !Channel symbols, one bit per byte
+  integer*1 i1
+  include 'conv232.f90'
+
+  nstate=0
+  k=0
+  do j=1,nsym
+     do i=7,0,-1
+        i1=dat(j)
+        i4=i1
+        if (i4.lt.0) i4=i4+256
+        nstate=ior(ishft(nstate,1),iand(ishft(i4,-i),1))
+        n=iand(nstate,npoly1)
+        n=ieor(n,ishft(n,-16))
+        k=k+1
+        symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
+        n=iand(nstate,npoly2)
+        n=ieor(n,ishft(n,-16))
+        k=k+1
+        symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
+        if(k.ge.nsym) go to 100
+     enddo
+  enddo
+
+100 continue
+
+  return
+end subroutine encode232

Added: trunk/jt4/encode4.f90
===================================================================
--- trunk/jt4/encode4.f90	                        (rev 0)
+++ trunk/jt4/encode4.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,20 @@
+subroutine encode4(message,ncode)
+
+  parameter (MAXCALLS=7000,MAXRPT=63)
+  integer ncode(206)
+  character*22 message          !Message to be generated
+  character*3 cok               !'   ' or 'OOO'
+  integer dgen(13)
+  integer*1 data0(13),symbol(216)
+  logical text
+
+  call chkmsg(message,cok,nspecial,flip)
+  call packmsg(message,dgen,text)  !Pack 72-bit message into 12 six-bit symbols
+  call entail(dgen,data0)
+  call encode232(data0,206,symbol)       !Convolutional encoding
+  call interleave4(symbol,1)             !Apply JT4 interleaving
+  do i=1,206
+     ncode(i)=symbol(i)
+  enddo
+
+end subroutine encode4

Added: trunk/jt4/entail.f
===================================================================
--- trunk/jt4/entail.f	                        (rev 0)
+++ trunk/jt4/entail.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,30 @@
+      subroutine entail(dgen,data0)
+
+C  Move 72-bit packed data from 6-bit to 8-bit symbols and add a zero tail.
+      integer dgen(13)
+      integer*1 data0(13)
+
+      i4=0
+      k=0
+      m=0
+      do i=1,12
+         n=dgen(i)
+         do j=1,6
+            k=k+1
+            i4=i4+i4+iand(1,ishft(n,j-6))
+            i4=iand(i4,255)
+            if(k.eq.8) then
+               m=m+1
+               if(i4.gt.127) i4=i4-256
+               data0(m)=i4
+               k=0
+            endif
+         enddo
+      enddo
+      do m=10,13
+         data0(m)=0
+      enddo
+
+      return
+      end
+

Added: trunk/jt4/fano232.f90
===================================================================
--- trunk/jt4/fano232.f90	                        (rev 0)
+++ trunk/jt4/fano232.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,140 @@
+subroutine fano232(symbol,nbits,mettab,ndelta,maxcycles,dat,     &amp;
+     ncycles,metric,ierr)
+
+! Sequential decoder for K=32, r=1/2 convolutional code using 
+! the Fano algorithm.  Translated from C routine for same purpose
+! written by Phil Karn, KA9Q.
+
+  parameter (MAXBITS=103)
+  parameter (MAXBYTES=(MAXBITS+7)/8)
+  integer*1 symbol(0:2*MAXBITS-1)  !Soft symbols (as unsigned i*1)
+  integer*1 dat(MAXBYTES)          !Decoded user data, 8 bits per byte
+  integer mettab(0:255,0:1)        !Metric table
+
+! These were the &quot;node&quot; structure in Karn's C code:
+  integer nstate(0:MAXBITS-1)      !Encoder state of next node
+  integer gamma(0:MAXBITS-1)       !Cumulative metric to this node
+  integer metrics(0:3,0:MAXBITS-1) !Metrics indexed by all possible Tx syms
+  integer tm(0:1,0:MAXBITS-1)      !Sorted metrics for current hypotheses
+  integer ii(0:MAXBITS-1)          !Current branch being tested
+
+  logical noback
+  include 'conv232.f90'            !Polynomials defined here
+
+  ntail=nbits-31
+
+! Compute all possible branch metrics for each symbol pair.
+! This is the only place we actually look at the raw input symbols
+  i4a=0
+  i4b=0
+  do np=0,nbits-1
+     j=2*np
+     i4a=symbol(j)
+     i4b=symbol(j+1)
+     if (i4a.lt.0) i4a=i4a+256
+     if (i4b.lt.0) i4b=i4b+256
+     metrics(0,np) = mettab(i4a,0) + mettab(i4b,0)
+     metrics(1,np) = mettab(i4a,0) + mettab(i4b,1)
+     metrics(2,np) = mettab(i4a,1) + mettab(i4b,0)
+     metrics(3,np) = mettab(i4a,1) + mettab(i4b,1)
+  enddo
+
+  np=0
+  nstate(np)=0
+
+  n=iand(nstate(np),npoly1)                  !Compute and sort branch metrics 
+  n=ieor(n,ishft(n,-16))                     !from the root node
+  lsym=partab(iand(ieor(n,ishft(n,-8)),255))
+  n=iand(nstate(np),npoly2)
+  n=ieor(n,ishft(n,-16))
+  lsym=lsym+lsym+partab(iand(ieor(n,ishft(n,-8)),255))
+  m0=metrics(lsym,np)
+  m1=metrics(ieor(3,lsym),np)
+  if(m0.gt.m1) then
+     tm(0,np)=m0                             !0-branch has better metric
+     tm(1,np)=m1
+  else
+     tm(0,np)=m1                             !1-branch is better
+     tm(1,np)=m0
+     nstate(np)=nstate(np) + 1               !Set low bit
+  endif
+
+  ii(np)=0                                   !Start with best branch
+  gamma(np)=0
+  nt=0
+
+  do i=1,nbits*maxcycles                     !Start the Fano decoder
+     ngamma=gamma(np) + tm(ii(np),np)        !Look forward
+     if(ngamma.ge.nt) then
+! Node is acceptable.  If first time visiting this node, tighten threshold:
+        if(gamma(np).lt.(nt+ndelta)) nt=nt + ndelta * ((ngamma-nt)/ndelta)
+        gamma(np+1)=ngamma                   !Move forward
+        nstate(np+1)=ishft(nstate(np),1)
+        np=np+1
+        if(np.eq.nbits-1) go to 100          !We're done!
+
+        n=iand(nstate(np),npoly1)
+        n=ieor(n,ishft(n,-16))
+        lsym=partab(iand(ieor(n,ishft(n,-8)),255))
+        n=iand(nstate(np),npoly2)
+        n=ieor(n,ishft(n,-16))
+        lsym=lsym+lsym+partab(iand(ieor(n,ishft(n,-8)),255))
+            
+        if(np.ge.ntail) then
+           tm(0,np)=metrics(lsym,np)      !We're in the tail, now all zeros
+        else
+           m0=metrics(lsym,np)
+           m1=metrics(ieor(3,lsym),np)
+           if(m0.gt.m1) then
+              tm(0,np)=m0                 !0-branch has better metric
+              tm(1,np)=m1
+           else
+              tm(0,np)=m1                 !1-branch is better
+              tm(1,np)=m0
+              nstate(np)=nstate(np) + 1   !Set low bit
+           endif
+        endif
+        ii(np)=0                          !Start with best branch
+     else
+        do while(.true.)
+           noback=.false.                 !Threshold violated, can't go forward
+           if(np.eq.0) noback=.true.
+           if(np.gt.0) then
+              if(gamma(np-1).lt.nt) noback=.true.
+           endif
+
+           if(noback) then               !Can't back up, either
+              nt=nt-ndelta               !Relax threshold and look forward again
+              if(ii(np).ne.0) then
+                 ii(np)=0
+                 nstate(np)=ieor(nstate(np),1)
+              endif
+              exit
+           endif
+
+           np=np-1                       !Back up
+           if(np.lt.ntail .and. ii(np).ne.1) then
+              ii(np)=ii(np)+1            !Search the next best branch
+              nstate(np)=ieor(nstate(np),1)
+              exit
+           endif
+        enddo
+     endif
+  enddo
+  i=nbits*maxcycles
+  
+100 metric=gamma(np)                       !Final path metric
+  nbytes=(nbits+7)/8                       !Copy decoded data to user's buffer
+  np=7
+  do j=1,nbytes-1
+     i4a=nstate(np)
+     dat(j)=i4a
+     np=np+8
+  enddo
+  dat(nbytes)=0
+  ncycles=i+1
+  ierr=0
+  if(i.ge.maxcycles*nbits) ierr=-1
+
+  return
+end subroutine fano232

Added: trunk/jt4/getmet4.f90
===================================================================
--- trunk/jt4/getmet4.f90	                        (rev 0)
+++ trunk/jt4/getmet4.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,52 @@
+subroutine getmet4(mode,mettab)
+
+! Return appropriate metric table for soft-decision convolutional decoder.
+
+! Metric table (RxSymbol,TxSymbol)
+  integer mettab(0:255,0:1)
+  real*4 xx0(0:255)
+  data xx0/                                                      &amp;
+        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
+        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
+        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
+        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
+        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
+        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
+        0.988, 1.000, 0.991, 0.993, 1.000, 0.995, 1.000, 0.991,  &amp;
+        1.000, 0.991, 0.992, 0.991, 0.990, 0.990, 0.992, 0.996,  &amp;
+        0.990, 0.994, 0.993, 0.991, 0.992, 0.989, 0.991, 0.987,  &amp;
+        0.985, 0.989, 0.984, 0.983, 0.979, 0.977, 0.971, 0.975,  &amp;
+        0.974, 0.970, 0.970, 0.970, 0.967, 0.962, 0.960, 0.957,  &amp;
+        0.956, 0.953, 0.942, 0.946, 0.937, 0.933, 0.929, 0.920,  &amp;
+        0.917, 0.911, 0.903, 0.895, 0.884, 0.877, 0.869, 0.858,  &amp;
+        0.846, 0.834, 0.821, 0.806, 0.790, 0.775, 0.755, 0.737,  &amp;
+        0.713, 0.691, 0.667, 0.640, 0.612, 0.581, 0.548, 0.510,  &amp;
+        0.472, 0.425, 0.378, 0.328, 0.274, 0.212, 0.146, 0.075,  &amp;
+        0.000,-0.079,-0.163,-0.249,-0.338,-0.425,-0.514,-0.606,  &amp;
+       -0.706,-0.796,-0.895,-0.987,-1.084,-1.181,-1.280,-1.376,  &amp;
+       -1.473,-1.587,-1.678,-1.790,-1.882,-1.992,-2.096,-2.201,  &amp;
+       -2.301,-2.411,-2.531,-2.608,-2.690,-2.829,-2.939,-3.058,  &amp;
+       -3.164,-3.212,-3.377,-3.463,-3.550,-3.768,-3.677,-3.975,  &amp;
+       -4.062,-4.098,-4.186,-4.261,-4.472,-4.621,-4.623,-4.608,  &amp;
+       -4.822,-4.870,-4.652,-4.954,-5.108,-5.377,-5.544,-5.995,  &amp;
+       -5.632,-5.826,-6.304,-6.002,-6.559,-6.369,-6.658,-7.016,  &amp;
+       -6.184,-7.332,-6.534,-6.152,-6.113,-6.288,-6.426,-6.313,  &amp;
+       -9.966,-6.371,-9.966,-7.055,-9.966,-6.629,-6.313,-9.966,  &amp;
+       -5.858,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
+       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
+       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
+       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
+       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
+       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966/
+  save
+
+  bias=0.5
+  scale=10.0
+  do i=0,255
+     mettab(i,0)=nint(scale*(xx0(i)-bias))
+     if(i.ge.1) mettab(256-i,1)=mettab(i,0)
+  enddo
+
+  return
+end subroutine getmet4
+

Added: trunk/jt4/getpfx1.f
===================================================================
--- trunk/jt4/getpfx1.f	                        (rev 0)
+++ trunk/jt4/getpfx1.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,96 @@
+      subroutine getpfx1(callsign,k,nv2)
+
+      character*12 callsign0,callsign,lof,rof
+      character*8 c
+      character addpfx*8,tpfx*4,tsfx*3
+      logical ispfx,issfx,invalid
+      common/pfxcom/addpfx
+      include 'pfx.f'
+
+      callsign0=callsign
+      nv2=0
+      iz=index(callsign,' ') - 1
+      if(iz.lt.0) iz=12
+      islash=index(callsign(1:iz),'/')
+      k=0
+      c='   '
+      if(islash.gt.0 .and. islash.le.(iz-4)) then
+!  Add-on prefix
+         c=callsign(1:islash-1)
+         callsign=callsign(islash+1:iz)
+         do i=1,NZ
+            if(pfx(i)(1:4).eq.c) then
+               k=i
+               go to 10
+            endif
+         enddo
+         if(addpfx.eq.c) then
+            k=449
+            go to 10
+         endif
+
+      else if(islash.eq.(iz-1)) then
+!  Add-on suffix
+         c=callsign(islash+1:iz)
+         callsign=callsign(1:islash-1)
+         do i=1,NZ2
+            if(sfx(i).eq.c(1:1)) then
+               k=400+i
+               go to 10
+            endif
+         enddo
+      endif
+
+ 10   if(islash.ne.0 .and.k.eq.0) then
+!  Original JT65 would force this compound callsign to be treated as
+!  plain text.  In JT65v2, we will encode the prefix or suffix into nc1.
+!  The task here is to compute the proper value of k.
+         lof=callsign0(:islash-1)
+         rof=callsign0(islash+1:)
+         llof=len_trim(lof)
+         lrof=len_trim(rof)
+         ispfx=(llof.gt.0 .and. llof.le.4)
+         issfx=(lrof.gt.0 .and. lrof.le.3)
+         invalid=.not.(ispfx.or.issfx)
+         if(ispfx.and.issfx) then
+            if(llof.lt.3) issfx=.false.
+            if(lrof.lt.3) ispfx=.false.
+            if(ispfx.and.issfx) then
+               i=ichar(callsign0(islash-1:islash-1))
+               if(i.ge.ichar('0') .and. i.le.ichar('9')) then
+                  issfx=.false.
+               else
+                  ispfx=.false.
+               endif
+            endif
+         endif
+
+         if(invalid) then
+            k=-1
+         else
+            if(ispfx) then
+               tpfx=lof
+               k=nchar(tpfx(1:1))
+               k=37*k + nchar(tpfx(2:2))
+               k=37*k + nchar(tpfx(3:3))
+               k=37*k + nchar(tpfx(4:4))
+               nv2=1
+               i=index(callsign0,'/')
+               callsign=callsign0(:i-1)
+               callsign=callsign0(i+1:)
+            endif
+            if(issfx) then
+               tsfx=rof
+               k=nchar(tsfx(1:1))
+               k=37*k + nchar(tsfx(2:2))
+               k=37*k + nchar(tsfx(3:3))
+               nv2=2
+               i=index(callsign0,'/')
+               callsign=callsign0(:i-1)
+            endif
+         endif
+      endif
+
+      return
+      end
+

Added: trunk/jt4/getpfx2.f
===================================================================
--- trunk/jt4/getpfx2.f	                        (rev 0)
+++ trunk/jt4/getpfx2.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,24 @@
+      subroutine getpfx2(k0,callsign)
+
+      character callsign*12
+      include 'pfx.f'
+      character addpfx*8
+      common/gcom4/addpfx
+
+      k=k0
+      if(k.gt.450) k=k-450
+      if(k.ge.1 .and. k.le.NZ) then
+         iz=index(pfx(k),' ') - 1
+         callsign=pfx(k)(1:iz)//'/'//callsign
+      else if(k.ge.401 .and. k.le.400+NZ2) then
+         iz=index(callsign,' ') - 1
+         callsign=callsign(1:iz)//'/'//sfx(k-400)
+      else if(k.eq.449) then
+         iz=index(addpfx,' ') - 1
+         if(iz.lt.1) iz=8
+         callsign=addpfx(1:iz)//'/'//callsign
+      endif
+
+      return
+      end
+

Added: trunk/jt4/gran.c
===================================================================
--- trunk/jt4/gran.c	                        (rev 0)
+++ trunk/jt4/gran.c	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,28 @@
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+/* Generate gaussian random float with mean=0 and std_dev=1 */
+float gran_()
+{
+  float fac,rsq,v1,v2;
+  static float gset;
+  static int iset;
+
+  if(iset){
+    /* Already got one */
+    iset = 0;
+    return gset;
+  }
+  /* Generate two evenly distributed numbers between -1 and +1
+   * that are inside the unit circle
+   */
+  do {
+    v1 = 2.0 * (float)rand() / RAND_MAX - 1;
+    v2 = 2.0 * (float)rand() / RAND_MAX - 1;
+    rsq = v1*v1 + v2*v2;
+  } while(rsq &gt;= 1.0 || rsq == 0.0);
+  fac = sqrt(-2.0*log(rsq)/rsq);
+  gset = v1*fac;
+  iset++;
+  return v2*fac;
+}

Added: trunk/jt4/grid2deg.f
===================================================================
--- trunk/jt4/grid2deg.f	                        (rev 0)
+++ trunk/jt4/grid2deg.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,40 @@
+      subroutine grid2deg(grid0,dlong,dlat)
+
+C  Converts Maidenhead grid locator to degrees of West longitude
+C  and North latitude.
+
+      character*6 grid0,grid
+      character*1 g1,g2,g3,g4,g5,g6
+
+      grid=grid0
+      i=ichar(grid(5:5))
+      if(grid(5:5).eq.' ' .or. i.le.64 .or. i.ge.128) grid(5:6)='mm'
+
+      if(grid(1:1).ge.'a' .and. grid(1:1).le.'z') grid(1:1)= 
+     +   char(ichar(grid(1:1))+ichar('A')-ichar('a'))
+      if(grid(2:2).ge.'a' .and. grid(2:2).le.'z') grid(2:2)=
+     +   char(ichar(grid(2:2))+ichar('A')-ichar('a'))
+      if(grid(5:5).ge.'A' .and. grid(5:5).le.'Z') grid(5:5)=
+     +   char(ichar(grid(5:5))-ichar('A')+ichar('a'))
+      if(grid(6:6).ge.'A' .and. grid(6:6).le.'Z') grid(6:6)=
+     +   char(ichar(grid(6:6))-ichar('A')+ichar('a'))
+
+      g1=grid(1:1)
+      g2=grid(2:2)
+      g3=grid(3:3)
+      g4=grid(4:4)
+      g5=grid(5:5)
+      g6=grid(6:6)
+
+      nlong = 180 - 20*(ichar(g1)-ichar('A'))
+      n20d = 2*(ichar(g3)-ichar('0'))
+      xminlong = 5*(ichar(g5)-ichar('a')+0.5)
+      dlong = nlong - n20d - xminlong/60.0
+c      print*,nlong,n20d,xminlong,dlong
+      nlat = -90+10*(ichar(g2)-ichar('A')) + ichar(g4)-ichar('0')
+      xminlat = 2.5*(ichar(g6)-ichar('a')+0.5)
+      dlat = nlat + xminlat/60.0
+c      print*,nlat,xminlat,dlat
+
+      return
+      end

Added: trunk/jt4/grid2k.f
===================================================================
--- trunk/jt4/grid2k.f	                        (rev 0)
+++ trunk/jt4/grid2k.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,12 @@
+      subroutine grid2k(grid,k)
+
+      character*6 grid
+
+      call grid2deg(grid,xlong,xlat)
+      nlong=nint(xlong)
+      nlat=nint(xlat)
+      k=0
+      if(nlat.ge.85) k=5*(nlong+179)/2 + nlat-84
+
+      return
+      end

Added: trunk/jt4/interleave4.f90
===================================================================
--- trunk/jt4/interleave4.f90	                        (rev 0)
+++ trunk/jt4/interleave4.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,43 @@
+subroutine interleave4(id,ndir)
+  integer*1 id(0:205),itmp(0:205)
+  integer j0(0:205)
+  logical first
+  data first/.true./
+  save first,j0
+
+  if(first) then
+     k=-1
+     do i=0,255
+        m=i
+        n=iand(m,1)
+        n=2*n + iand(m/2,1)
+        n=2*n + iand(m/4,1)
+        n=2*n + iand(m/8,1)
+        n=2*n + iand(m/16,1)
+        n=2*n + iand(m/32,1)
+        n=2*n + iand(m/64,1)
+        n=2*n + iand(m/128,1)
+        if(n.le.205) then
+           k=k+1
+           j0(k)=n
+        endif
+     enddo
+     first=.false.
+  endif
+
+  if(ndir.eq.1) then
+     do i=0,205
+        itmp(j0(i))=id(i)
+     enddo
+  else
+     do i=0,205
+        itmp(i)=id(j0(i))
+     enddo
+  endif
+
+  do i=0,205
+     id(i)=itmp(i)
+  enddo
+
+  return
+end subroutine interleave4

Added: trunk/jt4/jt4code.f90
===================================================================
--- trunk/jt4/jt4code.f90	                        (rev 0)
+++ trunk/jt4/jt4code.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,72 @@
+program jt4code
+
+! Provides examples of message packing, bit and symbol ordering,
+! convolutional encoding, and other necessary details of the JT4
+! protocol.
+
+  character*22 msg0,msg,decoded
+  character*72 c72
+  integer   dgen(12)
+  integer*1 data0(13),symbol(216)
+  integer*1 data1(13)                   !Decoded data (8-bit bytes)
+  integer   data4a(9)                   !Decoded data (8-bit bytes)
+  integer   data4(12)                   !Decoded data (6-bit bytes)
+  integer mettab(0:255,0:1)             !Metric table
+  integer ncode(206)
+
+  nargs=iargc()
+  if(nargs.ne.1) then
+     print*,'Usage: JT65code &quot;message&quot;'
+     go to 999
+  endif
+  call getmet4(7,mettab)
+  call getarg(1,msg0)                     !Get message from command line
+  msg=msg0
+
+  call packmsg(msg,dgen)         !Pack 72-bit message into 12 six-bit symbols
+  write(*,1020) msg0
+1020 format('Message:   ',a22)            !Echo input message
+  if(iand(dgen(10),8).ne.0) write(*,1030) !Is the plain text bit set?
+1030 format('Plain text.')         
+  write(*,1040) dgen
+1040 format('Packed message, 6-bit symbols: ',12i3) !Display packed symbols
+
+  call encode4(msg,ncode)
+  symbol(1:206)=ncode
+
+  write(*,1050) symbol(1:206)
+1050 format('Channel symbols:',50i1/                              &amp;
+            ('                ',50i1))
+
+  call interleave4(symbol,-1)         !Remove interleaving
+
+  do i=1,206
+     if(symbol(i).eq.1) then
+        symbol(i)=-118
+     else
+        symbol(i)=118
+     endif
+  enddo
+
+  nbits=72+31
+  ndelta=50
+  limit=100
+  call fano232(symbol,nbits,mettab,ndelta,limit,data1,ncycles,metric,ncount)
+  nlim=ncycles/nbits
+
+  if(ncount.ge.0) then
+     do i=1,9
+        i4=data1(i)
+        if(i4.lt.0) i4=i4+256
+        data4a(i)=i4
+     enddo
+     write(c72,1100) (data4a(i),i=1,9)
+1100 format(9b8.8)
+     read(c72,1102) data4
+1102 format(12b6)
+     call unpackmsg(data4,decoded)
+     write(*,1060) decoded
+1060 format('Decoded message: ',a22)
+  endif
+
+999 end program jt4code

Added: trunk/jt4/jt4metrics.f90
===================================================================
--- trunk/jt4/jt4metrics.f90	                        (rev 0)
+++ trunk/jt4/jt4metrics.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,71 @@
+program jt4metrics
+
+  implicit real*8 (a-h,o-z)
+  parameter (NMAX=100)
+  character*12 arg
+  integer hn(0:NMAX)                      !Noise histogram
+  integer hs(0:NMAX)                      !(Noise + Signal) histogram
+  real pn(0:NMAX)
+  real ps(0:NMAX)
+
+  nargs=iargc()
+  if(nargs.ne.3) then
+     print*,'Usage: jt4metrics nadd snr mult'
+     go to 999
+  endif
+
+  call getarg(1,arg)
+  read(arg,*) nadd
+  call getarg(2,arg)
+  read(arg,*) snrdb
+  sig=10.0**(0.05*snrdb) * (1.0/nadd)**0.25
+  call getarg(3,arg)
+  read(arg,*) mult
+
+  hn=0
+  hs=0
+  sq0=0.
+  sq00=0.
+  mult0=100000
+  nerr=0
+
+  do iter1=1,mult
+     do iter2=1,mult0
+        s0=0.
+        s1=0.
+        do n=1,nadd
+           x=0.707107*gran()
+           y=0.707107*gran()
+           s0=s0 + x**2 + y**2
+           x=0.707107*gran()
+           y=0.707107*gran()
+           s1=s1 + (x+sig)**2 + y**2
+        enddo
+        s0=s0/nadd
+        s1=s1/nadd
+        sq0=sq0 + s0
+        sq00=sq00 + min(s0,s1)
+        i0=(NMAX/10)*s0
+        if(i0.gt.NMAX) i0=NMAX
+        i1=(NMAX/10)*s1
+        if(i1.gt.NMAX) i1=NMAX
+        hn(i0)=hn(i0)+1
+        hs(i1)=hs(i1)+1
+        if(s1.lt.s0) nerr=nerr+1
+     enddo
+  enddo
+  xiters=float(mult)*mult0
+  avg0=sq0/xiters
+  avg00=sq00/xiters
+  ber=nerr/xiters
+  write(*,1000) avg0,avg00,ber
+1000 format('Avg noise:',f8.3,'   Est noise:',f8.3,'   BER:',f8.3)
+
+  do i=0,NMAX
+     pn(i)=hn(i)/xiters
+     ps(i)=hs(i)/xiters
+     write(13,1010) 0.01*i,pn(i),ps(i)
+1010 format(f8.2,2f15.12)
+  enddo
+
+999 end program jt4metrics

Added: trunk/jt4/k2grid.f
===================================================================
--- trunk/jt4/k2grid.f	                        (rev 0)
+++ trunk/jt4/k2grid.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,12 @@
+      subroutine k2grid(k,grid)
+      character grid*6
+
+      nlong=2*mod((k-1)/5,90)-179
+      if(k.gt.450) nlong=nlong+180
+      nlat=mod(k-1,5)+ 85
+      dlat=nlat
+      dlong=nlong
+      call deg2grid(dlong,dlat,grid)
+
+      return
+      end

Added: trunk/jt4/nchar.f
===================================================================
--- trunk/jt4/nchar.f	                        (rev 0)
+++ trunk/jt4/nchar.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,22 @@
+      function nchar(c)
+
+C  Convert ascii number, letter, or space to 0-36 for callsign packing.
+
+      character c*1
+
+      if(c.ge.'0' .and. c.le.'9') then
+         n=ichar(c)-ichar('0')
+      else if(c.ge.'A' .and. c.le.'Z') then
+         n=ichar(c)-ichar('A') + 10
+      else if(c.ge.'a' .and. c.le.'z') then
+         n=ichar(c)-ichar('a') + 10
+      else if(c.ge.' ') then
+         n=36
+      else
+         Print*,'Invalid character in callsign ',c,' ',ichar(c)
+         stop
+      endif
+      nchar=n
+
+      return
+      end

Added: trunk/jt4/packcall.f
===================================================================
--- trunk/jt4/packcall.f	                        (rev 0)
+++ trunk/jt4/packcall.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,79 @@
+      subroutine packcall(callsign,ncall,text)
+
+C  Pack a valid callsign into a 28-bit integer.
+
+      parameter (NBASE=37*36*10*27*27*27)
+      character callsign*6,c*1,tmp*6
+      logical text
+
+      text=.false.
+
+C  Work-around for Swaziland prefix:
+      if(callsign(1:4).eq.'3DA0') callsign='3D0'//callsign(5:6)
+
+      if(callsign(1:3).eq.'CQ ') then
+         ncall=NBASE + 1
+         if(callsign(4:4).ge.'0' .and. callsign(4:4).le.'9' .and. 
+     +      callsign(5:5).ge.'0' .and. callsign(5:5).le.'9' .and. 
+     +      callsign(6:6).ge.'0' .and. callsign(6:6).le.'9') then
+            read(callsign(4:6),*) nfreq
+            ncall=NBASE + 3 + nfreq
+         endif
+         return
+      else if(callsign(1:4).eq.'QRZ ') then
+         ncall=NBASE + 2
+         return
+      else if(callsign(1:3).eq.'DE ') then
+         ncall=267796945
+         return
+      endif
+
+      tmp='      '
+      if(callsign(3:3).ge.'0' .and. callsign(3:3).le.'9') then
+         tmp=callsign
+      else if(callsign(2:2).ge.'0' .and. callsign(2:2).le.'9') then
+         if(callsign(6:6).ne.' ') then
+            text=.true.
+            return
+         endif
+         tmp=' '//callsign(:5)
+      else
+         text=.true.
+         return
+      endif
+
+      do i=1,6
+         c=tmp(i:i)
+         if(c.ge.'a' .and. c.le.'z') 
+     +     tmp(i:i)=char(ichar(c)-ichar('a')+ichar('A'))
+      enddo
+
+      n1=0
+      if((tmp(1:1).ge.'A'.and.tmp(1:1).le.'Z').or.tmp(1:1).eq.' ') n1=1
+      if(tmp(1:1).ge.'0' .and. tmp(1:1).le.'9') n1=1
+      n2=0
+      if(tmp(2:2).ge.'A' .and. tmp(2:2).le.'Z') n2=1
+      if(tmp(2:2).ge.'0' .and. tmp(2:2).le.'9') n2=1
+      n3=0
+      if(tmp(3:3).ge.'0' .and. tmp(3:3).le.'9') n3=1
+      n4=0
+      if((tmp(4:4).ge.'A'.and.tmp(4:4).le.'Z').or.tmp(4:4).eq.' ') n4=1
+      n5=0
+      if((tmp(5:5).ge.'A'.and.tmp(5:5).le.'Z').or.tmp(5:5).eq.' ') n5=1
+      n6=0
+      if((tmp(6:6).ge.'A'.and.tmp(6:6).le.'Z').or.tmp(6:6).eq.' ') n6=1
+
+      if(n1+n2+n3+n4+n5+n6 .ne. 6) then
+         text=.true.
+         return 
+      endif
+
+      ncall=nchar(tmp(1:1))
+      ncall=36*ncall+nchar(tmp(2:2))
+      ncall=10*ncall+nchar(tmp(3:3))
+      ncall=27*ncall+nchar(tmp(4:4))-10
+      ncall=27*ncall+nchar(tmp(5:5))-10
+      ncall=27*ncall+nchar(tmp(6:6))-10
+
+      return
+      end

Added: trunk/jt4/packgrid.f
===================================================================
--- trunk/jt4/packgrid.f	                        (rev 0)
+++ trunk/jt4/packgrid.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,57 @@
+      subroutine packgrid(grid,ng,text)
+
+      parameter (NGBASE=180*180)
+      character*4 grid
+      logical text
+
+      text=.false.
+      if(grid.eq.'    ') go to 90                 !Blank grid is OK
+
+C  Test for numerical signal report, etc.
+      if(grid(1:1).eq.'-') then
+         if(grid(3:3).ne.' ') then
+            n=10*(ichar(grid(2:2))-48) + ichar(grid(3:3)) - 48
+         else
+            n=ichar(grid(2:2))-48
+         endif
+         if(n.gt.30) n=30
+         ng=NGBASE+1+n
+         go to 100
+      else if(grid(1:2).eq.'R-') then
+         if(grid(4:4).ne.' ') then
+            n=10*(ichar(grid(3:3))-48) + ichar(grid(4:4)) - 48
+         else
+            n=ichar(grid(3:3))-48
+         endif
+         if(n.gt.30) n=30
+         if(n.eq.0) go to 90
+         ng=NGBASE+31+n
+         go to 100
+      else if(grid(1:2).eq.'RO') then
+         ng=NGBASE+62
+         go to 100
+      else if(grid(1:3).eq.'RRR') then
+         ng=NGBASE+63
+         go to 100
+      else if(grid(1:2).eq.'73') then
+         ng=NGBASE+64
+         go to 100
+      endif
+
+      if(grid(1:1).lt.'A' .or. grid(1:1).gt.'R') text=.true.
+      if(grid(2:2).lt.'A' .or. grid(2:2).gt.'R') text=.true.
+      if(grid(3:3).lt.'0' .or. grid(3:3).gt.'9') text=.true.
+      if(grid(4:4).lt.'0' .or. grid(4:4).gt.'9') text=.true.
+      if(text) go to 100
+
+      call grid2deg(grid//'mm',dlong,dlat)
+      long=dlong
+      lat=dlat+ 90.0
+      ng=((long+180)/2)*180 + lat
+      go to 100
+
+ 90   ng=NGBASE + 1
+
+ 100  return
+      end
+

Added: trunk/jt4/packmsg.f
===================================================================
--- trunk/jt4/packmsg.f	                        (rev 0)
+++ trunk/jt4/packmsg.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,103 @@
+      subroutine packmsg(msg,dat)
+
+      parameter (NBASE=37*36*10*27*27*27)
+      parameter (NBASE2=262178562)
+      character*22 msg
+      integer dat(12)
+      character*12 c1,c2,c2z
+      character*4 c3
+      character*6 grid6
+c      character*3 dxcc                  !Where is DXCC implemented?
+      logical text1,text2,text3
+
+C  Convert all letters to upper case
+      do i=1,22
+         if(msg(i:i).ge.'a' .and. msg(i:i).le.'z') 
+     +     msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
+      enddo
+
+C  See if it's a CQ message
+      if(msg(1:3).eq.'CQ ') then
+         i=3
+C  ... and if so, does it have a reply frequency?
+         if(msg(4:4).ge.'0' .and. msg(4:4).le.'9' .and. 
+     +      msg(5:5).ge.'0' .and. msg(5:5).le.'9' .and. 
+     +      msg(6:6).ge.'0' .and. msg(6:6).le.'9') i=7
+         go to 1
+      endif
+
+      do i=1,22
+         if(msg(i:i).eq.' ') go to 1       !Get 1st blank
+      enddo 
+      go to 10                             !Consider msg as plain text
+      
+ 1    ia=i
+      c1=msg(1:ia-1)
+      do i=ia+1,22
+         if(msg(i:i).eq.' ') go to 2       !Get 2nd blank
+      enddo
+      go to 10                             !Consider msg as plain text
+
+ 2    ib=i
+      c2=msg(ia+1:ib-1)
+
+      do i=ib+1,22
+         if(msg(i:i).eq.' ') go to 3       !Get 3rd blank
+      enddo
+      go to 10                             !Consider msg as plain text
+
+ 3    ic=i
+      c3='    '
+      if(ic.ge.ib+1) c3=msg(ib+1:ic)
+      if(c3.eq.'OOO ') c3='    '           !Strip out the OOO flag
+      call getpfx1(c1,k1,junk)
+      call packcall(c1,nc1,text1)
+      c2z=c2
+      call getpfx1(c2,k2,nv2)
+      call packcall(c2,nc2,text2)
+      if(nv2.eq.0) then
+         if(k1.lt.0 .or. k2.lt.0 .or. k1*k2.ne.0) go to 10
+         if(k2.gt.0) k2=k2+450
+         k=max(k1,k2)
+         if(k.gt.0) then
+            call k2grid(k,grid6)
+            c3=grid6(:4)
+         endif
+      endif
+      call packgrid(c3,ng,text3)
+      if(nv2.eq.0 .and. (.not.text1) .and. (.not.text2) .and. 
+     +        (.not.text3)) go to 20
+      if(nv2.gt.0) then
+         if(nv2.eq.1) then
+            if(c1(1:3).eq.'CQ ')  nc1=262178563 + k2
+            if(c1(1:4).eq.'QRZ ') nc1=264002072 + k2 
+            if(c1(1:3).eq.'DE ')  nc1=265825581 + k2
+         endif
+         if(nv2.eq.2) then
+            if(c1(1:3).eq.'CQ ')  nc1=267649090 + k2
+            if(c1(1:4).eq.'QRZ ') nc1=267698375 + k2
+            if(c1(1:3).eq.'DE ')  nc1=267747660 + k2
+         endif
+         go to 20
+      endif
+
+C  The message will be treated as plain text.
+ 10   call packtext(msg,nc1,nc2,ng)
+      ng=ng+32768
+
+C  Encode data into 6-bit words
+ 20   dat(1)=iand(ishft(nc1,-22),63)                !6 bits
+      dat(2)=iand(ishft(nc1,-16),63)                !6 bits
+      dat(3)=iand(ishft(nc1,-10),63)                !6 bits
+      dat(4)=iand(ishft(nc1, -4),63)                !6 bits
+      dat(5)=4*iand(nc1,15)+iand(ishft(nc2,-26),3)  !4+2 bits
+      dat(6)=iand(ishft(nc2,-20),63)                !6 bits
+      dat(7)=iand(ishft(nc2,-14),63)                !6 bits
+      dat(8)=iand(ishft(nc2, -8),63)                !6 bits
+      dat(9)=iand(ishft(nc2, -2),63)                !6 bits
+      dat(10)=16*iand(nc2,3)+iand(ishft(ng,-12),15) !2+4 bits
+      dat(11)=iand(ishft(ng,-6),63)                 !6 bits
+      dat(12)=iand(ng,63)                           !6 bits
+
+      return
+      end

Added: trunk/jt4/packtext.f
===================================================================
--- trunk/jt4/packtext.f	                        (rev 0)
+++ trunk/jt4/packtext.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,47 @@
+      subroutine packtext(msg,nc1,nc2,nc3)
+
+      parameter (MASK28=2**28 - 1)
+      character*13 msg
+      character*44 c
+      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?'/
+
+      nc1=0
+      nc2=0
+      nc3=0
+
+      do i=1,5                                !First 5 characters in nc1
+         do j=1,44                            !Get character code
+            if(msg(i:i).eq.c(j:j)) go to 10
+         enddo
+         j=37
+ 10      j=j-1                                !Codes should start at zero
+         nc1=42*nc1 + j
+      enddo
+
+      do i=6,10                               !Characters 6-10 in nc2
+         do j=1,44                            !Get character code
+            if(msg(i:i).eq.c(j:j)) go to 20
+         enddo
+         j=37
+ 20      j=j-1                                !Codes should start at zero
+         nc2=42*nc2 + j
+      enddo
+
+      do i=11,13                              !Characters 11-13 in nc3
+         do j=1,44                            !Get character code
+            if(msg(i:i).eq.c(j:j)) go to 30
+         enddo
+         j=37
+ 30      j=j-1                                !Codes should start at zero
+         nc3=42*nc3 + j
+      enddo
+
+C  We now have used 17 bits in nc3.  Must move one each to nc1 and nc2.
+      nc1=nc1+nc1
+      if(iand(nc3,32768).ne.0) nc1=nc1+1
+      nc2=nc2+nc2
+      if(iand(nc3,65536).ne.0) nc2=nc2+1
+      nc3=iand(nc3,32767)
+
+      return
+      end

Added: trunk/jt4/pfx.f
===================================================================
--- trunk/jt4/pfx.f	                        (rev 0)
+++ trunk/jt4/pfx.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,50 @@
+      parameter (NZ=339)                     !Total number of prefixes
+      parameter (NZ2=12)                     !Total number of suffixes
+      character*1 sfx(NZ2)
+      character*5 pfx(NZ)
+
+      data sfx/'P','0','1','2','3','4','5','6','7','8','9','A'/
+      data pfx/
+     +  '1A   ','1S   ','3A   ','3B6  ','3B8  ','3B9  ','3C   ','3C0  ',
+     +  '3D2  ','3D2C ','3D2R ','3DA  ','3V   ','3W   ','3X   ','3Y   ',
+     +  '3YB  ','3YP  ','4J   ','4L   ','4S   ','4U1I ','4U1U ','4W   ',
+     +  '4X   ','5A   ','5B   ','5H   ','5N   ','5R   ','5T   ','5U   ',
+     +  '5V   ','5W   ','5X   ','5Z   ','6W   ','6Y   ','7O   ','7P   ',
+     +  '7Q   ','7X   ','8P   ','8Q   ','8R   ','9A   ','9G   ','9H   ',
+     +  '9J   ','9K   ','9L   ','9M2  ','9M6  ','9N   ','9Q   ','9U   ',
+     +  '9V   ','9X   ','9Y   ','A2   ','A3   ','A4   ','A5   ','A6   ',
+     +  'A7   ','A9   ','AP   ','BS7  ','BV   ','BV9  ','BY   ','C2   ',
+     +  'C3   ','C5   ','C6   ','C9   ','CE   ','CE0X ','CE0Y ','CE0Z ',
+     +  'CE9  ','CM   ','CN   ','CP   ','CT   ','CT3  ','CU   ','CX   ',
+     +  'CY0  ','CY9  ','D2   ','D4   ','D6   ','DL   ','DU   ','E3   ',
+     +  'E4   ','EA   ','EA6  ','EA8  ','EA9  ','EI   ','EK   ','EL   ',
+     +  'EP   ','ER   ','ES   ','ET   ','EU   ','EX   ','EY   ','EZ   ',
+     +  'F    ','FG   ','FH   ','FJ   ','FK   ','FKC  ','FM   ','FO   ',
+     +  'FOA  ','FOC  ','FOM  ','FP   ','FR   ','FRG  ','FRJ  ','FRT  ',
+     +  'FT5W ','FT5X ','FT5Z ','FW   ','FY   ','M    ','MD   ','MI   ',
+     +  'MJ   ','MM   ',        'MU   ','MW   ','H4   ','H40  ','HA   ',
+     +  'HB   ','HB0  ','HC   ','HC8  ','HH   ','HI   ','HK   ','HK0A ',
+     +  'HK0M ','HL   ','HM   ','HP   ','HR   ','HS   ','HV   ','HZ   ',
+     +  'I    ','IS   ','IS0  ',        'J2   ','J3   ','J5   ','J6   ',
+     +  'J7   ','J8   ','JA   ','JDM  ','JDO  ','JT   ','JW   ',        
+     +  'JX   ','JY   ','K    ','KG4  ','KH0  ','KH1  ','KH2  ','KH3  ',
+     +  'KH4  ','KH5  ','KH5K ','KH6  ','KH7  ','KH8  ','KH9  ','KL   ',
+     +  'KP1  ','KP2  ','KP4  ','KP5  ','LA   ','LU   ','LX   ','LY   ',
+     +  'LZ   ','OA   ','OD   ','OE   ','OH   ','OH0  ','OJ0  ','OK   ',
+     +  'OM   ','ON   ','OX   ','OY   ','OZ   ','P2   ','P4   ','PA   ',
+     +  'PJ2  ','PJ7  ','PY   ','PY0F ','PT0S ','PY0T ','PZ   ','R1F  ',
+     +  'R1M  ','S0   ','S2   ','S5   ','S7   ','S9   ','SM   ','SP   ',
+     +  'ST   ','SU   ','SV   ','SVA  ','SV5  ','SV9  ','T2   ','T30  ',
+     +  'T31  ','T32  ','T33  ','T5   ','T7   ','T8   ','T9   ','TA   ',
+     +          'TF   ','TG   ','TI   ','TI9  ','TJ   ','TK   ','TL   ',
+     +  'TN   ','TR   ','TT   ','TU   ','TY   ','TZ   ','UA   ','UA2  ',
+     +  'UA9  ','UK   ','UN   ','UR   ','V2   ','V3   ','V4   ','V5   ',
+     +  'V6   ','V7   ','V8   ','VE   ','VK   ','VK0H ','VK0M ','VK9C ',
+     +  'VK9L ','VK9M ','VK9N ','VK9W ','VK9X ','VP2E ','VP2M ','VP2V ',
+     +  'VP5  ','VP6  ','VP6D ','VP8  ','VP8G ','VP8H ','VP8O ','VP8S ',
+     +  'VP9  ','VQ9  ','VR   ','VU   ','VU4  ','VU7  ','XE   ','XF4  ',
+     +  'XT   ','XU   ','XW   ','XX9  ','XZ   ','YA   ','YB   ','YI   ',
+     +  'YJ   ','YK   ','YL   ','YN   ','YO   ','YS   ','YU   ','YV   ',
+     +  'YV0  ','Z2   ','Z3   ','ZA   ','ZB   ','ZC4  ','ZD7  ','ZD8  ',
+     +  'ZD9  ','ZF   ','ZK1N ','ZK1S ','ZK2  ','ZK3  ','ZL   ','ZL7  ',
+     +  'ZL8  ','ZL9  ','ZP   ','ZS   ','ZS8  ','KC4  ','E5   '/

Added: trunk/jt4/simjt4.f90
===================================================================
--- trunk/jt4/simjt4.f90	                        (rev 0)
+++ trunk/jt4/simjt4.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,167 @@
+program simjt4
+
+  parameter (NMAX=100)
+  real*4 ps(0:NMAX)
+  real*4 pn(0:NMAX)
+  real*4 sym(0:1,207)
+  real*8 sum0,sum1,sumcycles
+  character arg*12,c72*72
+  character*22 msg,decoded
+  integer icode(206)
+  integer*1 icode1(206),i10,i11
+  integer mettab(0:255,0:1)             !Metric table
+  integer*1 symbol(206)
+  integer*1 data1(13)                   !Decoded data (8-bit bytes)
+  integer   data4a(9)                   !Decoded data (8-bit bytes)
+  integer   data4(12)                   !Decoded data (6-bit bytes)
+  real log2
+  log2(x)=log(x)/log(2.0)
+
+  nargs=iargc()
+  if(nargs.ne.7) then
+     print*,'Usage: simjt4 nadd scale ndelta limit known snr iters'
+     go to 999
+  endif
+
+  call getarg(1,arg)
+  read(arg,*) nadd
+  call getarg(2,arg)
+  read(arg,*) scale
+  call getarg(3,arg)
+  read(arg,*) ndelta
+  call getarg(4,arg)
+  read(arg,*) limit
+  call getarg(5,arg)
+  read(arg,*) known
+  call getarg(6,arg)
+  read(arg,*) snrdb
+  call getarg(7,arg)
+  read(arg,*) iters
+
+  do i=0,NMAX
+     read(13,*) x,pn(i),ps(i)
+  enddo
+  call getmet4(7,mettab)
+
+  write(*,1010) 
+1010 format(/                                                              &amp;
+  '  EsNo  EbNo  db65    false    fcopy  cycles    ber    ave0    ave1'/  &amp;
+  '--------------------------------------------------------------------')
+
+  msg='CQ K1JT FN20'
+  call encode4(msg,icode)
+  icode1=icode
+  call interleave4(icode1,-1)
+
+  rate=0.350
+  baud=nadd*11025.0/2520.0
+  nbits=72+31
+  maxlim=0
+
+  idb1=10
+  idb2=-20
+  if(snrdb.ne.0.0) idb2=idb1
+  do idb=idb1,idb2,-1
+     EsNo=idb
+     if(snrdb.ne.0.0) EsNo=snrdb
+     EbNo=EsNo - 10.0*log10(rate)
+     db65=EsNo - 10.0*log10(2500.0/baud)
+     sig=sqrt(10.0**(0.1*EsNo))                !Signal level
+
+     ngood=0
+     nfalse=0
+     nbadbit=0
+     sumcycles=0.d0
+     sum0=0.d0
+     sum1=0.d0
+     do iter=1,iters
+        do j=1,206                            !Simulate received 2-FSK symbols
+           s0=0.
+           s1=0.
+           do n=1,nadd
+              x=0.707107*gran()
+              y=0.707107*gran()
+              s0=s0 + x**2 + y**2
+              x=0.707107*gran()
+              y=0.707107*gran()
+              s1=s1 + (x+sig)**2 + y**2
+           enddo
+           s0=s0/nadd
+           s1=s1/nadd
+           sum0=sum0 + min(s0,s1)
+           sum1=sum1 + max(s0,s1)
+           if(icode(j).eq.1) then
+              sym(0,j)=s0
+              sym(1,j)=s1
+           else
+              sym(0,j)=s1
+              sym(1,j)=s0
+           endif
+        enddo
+
+        nb=0
+        do j=1,206
+           i4=nint(scale*(sym(1,j)-sym(0,j))) 
+           if(i4.gt.127) i4=127
+           if(i4.lt.-127) i4=-127
+           i4=i4+128
+           if(i4.ge.128) i4=i4-256
+           symbol(j)=i4
+           if(icode(j).eq.1 .and. sym(1,j).lt.sym(0,j)) nb=nb+1
+           if(icode(j).eq.0 .and. sym(1,j).ge.sym(0,j)) nb=nb+1
+        enddo
+        call interleave4(symbol,-1)         !Remove interleaving
+
+        if(known.gt.0) then
+           i10=64
+           i11=-64
+!           do j=1,2*known
+           kused=0
+           nalt=103/known
+           do j=1,206,2*nalt
+              if(icode1(j).eq.0) symbol(j)=i10
+              if(icode1(j).eq.1) symbol(j)=i11
+              if(icode1(j+1).eq.0) symbol(j+1)=i10
+              if(icode1(j+1).eq.1) symbol(j+1)=i11
+              kused=kused+1
+              if(kused.ge.known) exit
+           enddo
+        endif
+        call fano232(symbol,nbits,mettab,ndelta,limit,data1,ncycles,   &amp;
+             metric,ncount)
+        nlim=ncycles/nbits
+        maxlim=max(maxlim,nlim)
+        sumcycles=sumcycles+nlim
+        if(ncount.eq.0) then
+           do i=1,9
+              i4=data1(i)
+              if(i4.lt.0) i4=i4+256
+              data4a(i)=i4
+           enddo
+           write(c72,1100) (data4a(i),i=1,9)
+1100       format(9b8.8)
+           read(c72,1102) data4
+1102       format(12b6)
+           call unpackmsg(data4,decoded)
+           if(decoded.ne.msg) then
+              nfalse=nfalse+1
+           else
+              ngood=ngood+1
+              nbadbit=nbadbit+nb
+           endif
+        endif
+     enddo
+
+     fgood=float(ngood)/iters
+     ffalse=float(nfalse)/iters
+     avecycles=sumcycles/iters
+     ber=nbadbit/((ngood+1)*206.0)
+     ave0=sum0/(iters*206.d0)
+     ave1=sum1/(iters*206.d0)
+     write(*,1020)  EsNo,EbNo,db65,ffalse,fgood,nint(avecycles),  &amp;
+          ber,ave0,ave1
+1020 format(3f6.1,2f9.4,i7,3f8.3)
+     if(fgood.eq.0) exit
+  enddo
+
+999 end program simjt4

Added: trunk/jt4/simsync.f90
===================================================================
--- trunk/jt4/simsync.f90	                        (rev 0)
+++ trunk/jt4/simsync.f90	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,109 @@
+program simsync
+
+  parameter (NMAX=1000)
+  real sym(0:1,240)
+  real ccf(-10:20)
+  character*12 arg
+  integer isync(207)
+  data isync/                                                       &amp;
+       0,0,0,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,1,1,0,0, &amp;
+       0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0, &amp;
+       1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,0,0,1, &amp;
+       0,0,0,1,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1, &amp;
+       0,1,1,1,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,0,1,1,0,0,0,1,1,1, &amp;
+       0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,1,1, &amp;
+       1,0,0,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1/
+
+  nargs=iargc()
+  if(nargs.ne.3) then
+     print*,'Usage: simsync nadd snr iters'
+     go to 999
+  endif
+
+  call getarg(1,arg)
+  read(arg,*) nadd
+  call getarg(2,arg)
+  read(arg,*) snrdb
+  sig0=10.0**(0.05*snrdb) * (1.0/nadd)**0.25
+  call getarg(3,arg)
+  read(arg,*) iters
+
+  write(*,1010) 
+1010 format(/'  EsNo  EbNo  db65    sync'/  &amp;
+             '---------------------------')
+
+  rate=0.350
+  baud=nadd*11025.0/2520.0
+  idb1=0
+  idb2=-20
+  if(snrdb.ne.0.0) idb2=idb1
+  do idb=idb1,idb2,-1
+     EsNo=idb
+     if(snrdb.ne.0.0) EsNo=snrdb
+     EbNo=EsNo - 10.0*log10(rate)
+     db65=EsNo - 10.0*log10(2500.0/baud)
+     sig0=sqrt(10.0**(0.1*EsNo))                !Signal level
+
+     ngood=0
+     do iter=1,iters
+        do j=1,240
+           sig=0.
+           s0=0.
+           s1=0.
+           if(j.ge.11 .and. j.le.217) sig=sig0
+           do n=1,nadd
+              x=0.707107*gran()
+              y=0.707107*gran()
+              s0=s0 + x**2 + y**2
+              x=0.707107*gran()
+              y=0.707107*gran()
+              s1=s1 + (x+sig)**2 + y**2
+           enddo
+           s0=s0/nadd
+           s1=s1/nadd
+           if(j.ge.11 .and. j.le.217) then
+              if(isync(j-10).eq.1) then
+                 sym(0,j)=s0
+                 sym(1,j)=s1
+              else
+                 sym(0,j)=s1
+                 sym(1,j)=s0
+              endif
+           else
+              sym(0,j)=s0
+              sym(1,j)=s1
+           endif
+        enddo
+
+        sq=0.
+        ccfmax=0.
+        ccf=0.
+        lagpk=-99
+        do lag=-10,20
+           ccf(lag)=0.
+           do i=1,207
+              k=isync(i)
+              j=i+10+lag
+              ccf(lag)=ccf(lag) + sym(k,j) - sym(1-k,j)
+           enddo
+           if(ccf(lag).gt.ccfmax) then
+              ccfmax=ccf(lag)
+              lagpk=lag
+           else
+              sq=sq + ccf(lag)**2
+           endif
+!        write(15,3001) lag,ccf(lag)
+!3001    format(i3,f12.3)
+        enddo
+        if(lagpk.eq.0) ngood=ngood+1
+        rms=sqrt(sq/30.0)
+        snr=ccfmax/rms
+!     write(*,1010) iter,lagpk,snr
+!1010 format(i10,i4,f6.2)
+     enddo
+     fsync=float(ngood)/iters
+     write(*,1020)  EsNo,EbNo,db65,fsync
+1020 format(3f6.1,f9.4)
+  enddo
+
+999 end program simsync

Added: trunk/jt4/unpackcall.f
===================================================================
--- trunk/jt4/unpackcall.f	                        (rev 0)
+++ trunk/jt4/unpackcall.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,142 @@
+      subroutine unpackcall(ncall,word,iv2,psfx)
+
+      parameter (NBASE=37*36*10*27*27*27)
+      character word*12,c*37,psfx*4
+
+      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ '/
+
+      n=ncall
+      iv2=0
+      if(n.ge.262177560) go to 20
+      word='......'
+      if(n.ge.262177560) go to 999            !Plain text message ...
+      i=mod(n,27)+11
+      word(6:6)=c(i:i)
+      n=n/27
+      i=mod(n,27)+11
+      word(5:5)=c(i:i)
+      n=n/27
+      i=mod(n,27)+11
+      word(4:4)=c(i:i)
+      n=n/27
+      i=mod(n,10)+1
+      word(3:3)=c(i:i)
+      n=n/10
+      i=mod(n,36)+1
+      word(2:2)=c(i:i)
+      n=n/36
+      i=n+1
+      word(1:1)=c(i:i)
+      do i=1,4
+         if(word(i:i).ne.' ') go to 10
+      enddo
+      go to 999
+ 10   word=word(i:)
+      go to 999
+
+ 20   if(n.ge.267796946) go to 999
+
+! We have a JT65v2 message
+      if((n.ge.262178563) .and. (n.le.264002071)) Then
+! CQ with prefix
+         iv2=1
+         n=n-262178563
+         i=mod(n,37)+1
+         psfx(4:4)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.264002072) .and. (n.le.265825580)) Then
+! QRZ with prefix
+         iv2=2
+         n=n-264002072
+         i=mod(n,37)+1
+         psfx(4:4)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.265825581) .and. (n.le.267649089)) Then
+! DE with prefix
+         iv2=3
+         n=n-265825581
+         i=mod(n,37)+1
+         psfx(4:4)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.267649090) .and. (n.le.267698374)) Then
+! CQ with suffix
+         iv2=4
+         n=n-267649090
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.267698375) .and. (n.le.267747659)) Then
+! QRZ with suffix
+         iv2=5
+         n=n-267698375
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.267747660) .and. (n.le.267796944)) Then
+! DE with suffix
+         iv2=6
+         n=n-267747660
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if(n.eq.267796945) Then
+! DE with no prefix or suffix
+         iv2=7
+         psfx = '    '
+      endif
+
+ 999  if(word(1:3).eq.'3D0') word='3DA0'//word(4:)
+
+      return
+      end

Added: trunk/jt4/unpackgrid.f
===================================================================
--- trunk/jt4/unpackgrid.f	                        (rev 0)
+++ trunk/jt4/unpackgrid.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,35 @@
+      subroutine unpackgrid(ng,grid)
+
+      parameter (NGBASE=180*180)
+      character grid*4,grid6*6,digit*10
+      data digit/'0123456789'/
+
+      grid='    '
+      if(ng.ge.32400) go to 10
+      dlat=mod(ng,180)-90
+      dlong=(ng/180)*2 - 180 + 2
+      call deg2grid(dlong,dlat,grid6)
+      grid=grid6(1:4) !XXX explicitly truncate this -db
+      go to 100
+
+ 10   n=ng-NGBASE-1
+      if(n.ge.1 .and.n.le.30) then
+         grid(1:1)='-'
+         grid(2:2)=char(48+n/10)
+         grid(3:3)=char(48+mod(n,10))
+      else if(n.ge.31 .and.n.le.60) then
+         n=n-30
+         grid(1:2)='R-'
+         grid(3:3)=char(48+n/10)
+         grid(4:4)=char(48+mod(n,10))
+      else if(n.eq.61) then
+         grid='RO'
+      else if(n.eq.62) then
+         grid='RRR'
+      else if(n.eq.63) then
+         grid='73'
+      endif
+
+ 100  return
+      end
+

Added: trunk/jt4/unpackmsg.f
===================================================================
--- trunk/jt4/unpackmsg.f	                        (rev 0)
+++ trunk/jt4/unpackmsg.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,100 @@
+      subroutine unpackmsg(dat,msg)
+
+      parameter (NBASE=37*36*10*27*27*27)
+      parameter (NGBASE=180*180)
+      integer dat(12)
+      character c1*12,c2*12,grid*4,msg*22,grid6*6,psfx*4,junk2*4
+      logical cqnnn
+
+      cqnnn=.false.
+      nc1=ishft(dat(1),22) + ishft(dat(2),16) + ishft(dat(3),10)+
+     +  ishft(dat(4),4) + iand(ishft(dat(5),-2),15)
+
+      nc2=ishft(iand(dat(5),3),26) + ishft(dat(6),20) + 
+     +  ishft(dat(7),14) + ishft(dat(8),8) + ishft(dat(9),2) + 
+     +  iand(ishft(dat(10),-4),3)
+
+      ng=ishft(iand(dat(10),15),12) + ishft(dat(11),6) + dat(12)
+
+      if(ng.gt.32768) then
+         call unpacktext(nc1,nc2,ng,msg)
+         go to 100
+      endif
+
+      call unpackcall(nc1,c1,iv2,psfx)
+      if(iv2.eq.0) then
+! This is an &quot;original JT65&quot; message
+         if(nc1.eq.NBASE+1) c1='CQ    '
+         if(nc1.eq.NBASE+2) c1='QRZ   '
+         nfreq=nc1-NBASE-3
+         if(nfreq.ge.0 .and. nfreq.le.999) then
+            write(c1,1002) nfreq
+ 1002       format('CQ ',i3.3)
+            cqnnn=.true.
+         endif
+      endif
+
+      call unpackcall(nc2,c2,junk1,junk2)
+      call unpackgrid(ng,grid)
+
+      if(iv2.gt.0) then
+! This is a JT65v2 message
+         n1=len_trim(psfx)
+         n2=len_trim(c2)
+         if(iv2.eq.1) msg='CQ '//psfx(:n1)//'/'//c2(:n2)//' '//grid
+         if(iv2.eq.2) msg='QRZ '//psfx(:n1)//'/'//c2(:n2)//' '//grid
+         if(iv2.eq.3) msg='DE '//psfx(:n1)//'/'//c2(:n2)//' '//grid
+         if(iv2.eq.4) msg='CQ '//c2(:n2)//'/'//psfx(:n1)//' '//grid
+         if(iv2.eq.5) msg='QRZ '//c2(:n2)//'/'//psfx(:n1)//' '//grid
+         if(iv2.eq.6) msg='DE '//c2(:n2)//'/'//psfx(:n1)//' '//grid
+         if(iv2.eq.7) msg='DE '//c2(:n2)//' '//grid
+         go to 100
+      else
+         
+      endif
+
+      grid6=grid//'ma'
+      call grid2k(grid6,k)
+      if(k.ge.1 .and. k.le.450)   call getpfx2(k,c1)
+      if(k.ge.451 .and. k.le.900) call getpfx2(k,c2)
+
+      i=index(c1,char(0))
+      if(i.ge.3) c1=c1(1:i-1)//'            '
+      i=index(c2,char(0))
+      if(i.ge.3) c2=c2(1:i-1)//'            '
+
+      msg='                      '
+      j=0
+      if(cqnnn) then
+         msg=c1//'          '
+         j=7                                  !### ??? ###
+         go to 10
+      endif
+
+      do i=1,12
+         j=j+1
+         msg(j:j)=c1(i:i)
+         if(c1(i:i).eq.' ') go to 10
+      enddo
+      j=j+1
+      msg(j:j)=' '
+
+ 10   do i=1,12
+         if(j.le.21) j=j+1
+         msg(j:j)=c2(i:i)
+         if(c2(i:i).eq.' ') go to 20
+      enddo
+      if(j.le.21) j=j+1
+      msg(j:j)=' '
+
+ 20   if(k.eq.0) then
+         do i=1,4
+            if(j.le.21) j=j+1
+            msg(j:j)=grid(i:i)
+         enddo
+         if(j.le.21) j=j+1
+         msg(j:j)=' '
+      endif
+
+ 100  return
+      end

Added: trunk/jt4/unpacktext.f
===================================================================
--- trunk/jt4/unpacktext.f	                        (rev 0)
+++ trunk/jt4/unpacktext.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -0,0 +1,35 @@
+      subroutine unpacktext(nc1,nc2,nc3,msg)
+
+      character*22 msg
+      character*44 c
+      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?'/
+
+      nc3=iand(nc3,32767)                      !Remove the &quot;plain text&quot; bit
+      if(iand(nc1,1).ne.0) nc3=nc3+32768
+      nc1=nc1/2
+      if(iand(nc2,1).ne.0) nc3=nc3+65536
+      nc2=nc2/2
+
+      do i=5,1,-1
+         j=mod(nc1,42)+1
+         msg(i:i)=c(j:j)
+         nc1=nc1/42
+      enddo
+
+      do i=10,6,-1
+         j=mod(nc2,42)+1
+         msg(i:i)=c(j:j)
+         nc2=nc2/42
+      enddo
+
+      do i=13,11,-1
+         j=mod(nc3,42)+1
+         msg(i:i)=c(j:j)
+         nc3=nc3/42
+      enddo
+      msg(14:22) = '         '
+
+      return
+      end
+
+

Modified: trunk/packmsg.f
===================================================================
--- trunk/packmsg.f	2013-01-31 14:13:31 UTC (rev 2995)
+++ trunk/packmsg.f	2013-02-05 16:16:31 UTC (rev 2996)
@@ -96,8 +96,8 @@
       dat(8)=iand(ishft(nc2, -8),63)                !6 bits
       dat(9)=iand(ishft(nc2, -2),63)                !6 bits
       dat(10)=16*iand(nc2,3)+iand(ishft(ng,-12),15) !2+4 bits
-      dat(11)=iand(ishft(ng,-6),63)
-      dat(12)=iand(ng,63)
+      dat(11)=iand(ishft(ng,-6),63)                 !6 bits
+      dat(12)=iand(ng,63)                           !6 bits
 
       return
       end

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="002689.html">[WSJT-SVN] r2997 - trunk/jt4
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2688">[ date ]</a>
              <a href="thread.html#2688">[ thread ]</a>
              <a href="subject.html#2688">[ subject ]</a>
              <a href="author.html#2688">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
