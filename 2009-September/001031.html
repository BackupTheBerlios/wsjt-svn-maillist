<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r1339 - branches/wsjt8a
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1339%20-%20branches/wsjt8a&In-Reply-To=%3C200909120134.n8C1YdIF021907%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001030.html">
   <LINK REL="Next"  HREF="001032.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r1339 - branches/wsjt8a</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1339%20-%20branches/wsjt8a&In-Reply-To=%3C200909120134.n8C1YdIF021907%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r1339 - branches/wsjt8a">k1jt at mail.berlios.de
       </A><BR>
    <I>Sat Sep 12 03:34:39 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001030.html">[WSJT-SVN] r1338 - branches/wsjt8a
</A></li>
        <LI>Next message: <A HREF="001032.html">[WSJT-SVN] r1340 - branches/wsjt8a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1031">[ date ]</a>
              <a href="thread.html#1031">[ thread ]</a>
              <a href="subject.html#1031">[ subject ]</a>
              <a href="author.html#1031">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2009-09-12 03:34:30 +0200 (Sat, 12 Sep 2009)
New Revision: 1339

Removed:
   branches/wsjt8a/chkt0.f90
   branches/wsjt8a/detect.f
   branches/wsjt8a/gencw.f
   branches/wsjt8a/genmet.f
   branches/wsjt8a/longx.f
   branches/wsjt8a/mtdecode.f
   branches/wsjt8a/packmsg.f
   branches/wsjt8a/packtext2.f90
   branches/wsjt8a/peakup.f
   branches/wsjt8a/stdecode.f
   branches/wsjt8a/unpackmsg.f
   branches/wsjt8a/unpacktext2.f90
Modified:
   branches/wsjt8a/Makefile.in
   branches/wsjt8a/wsjt.py
   branches/wsjt8a/wsjt1.F
Log:
Still removing routines not used in any WSJT8 modes.


Modified: branches/wsjt8a/Makefile.in
===================================================================
--- branches/wsjt8a/Makefile.in	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/Makefile.in	2009-09-12 01:34:30 UTC (rev 1339)
@@ -50,15 +50,14 @@
 	hash.o nhash.o chenc.o chdec.o packbits.o unpackbits.o \
 	wrapkarn.o init_rs_int.o encode_rs_int.o decode_rs_int.o 
 
-F2PYONLY = ftn_init ftn_quit audio_init spec getfile azdist0 astro0 chkt0
+F2PYONLY = ftn_init ftn_quit audio_init spec getfile azdist0 astro0
 
 SRCS2F90 = astro0.F90 audio_init.F90 azdist0.f90 \
 	blanker.f90 decode1.F90 decode2.f90 decode3.F90 ftn_init.F90 \
 	ftn_quit.f90 get_fname.F90 getfile.F90 horizspec.f90 hscroll.f90 \
 	pix2d.f90 pix2d65.f90 rfile.f90 savedata.F90 spec.f90 \
-	wsjtgen.F90 runqqq.F90 fivehz.F90 chkt0.f90 \
-	packpfx.f90 unpackpfx.f90 \
-	packname.f90 unpackname.f90 packtext2.f90 unpacktext2.f90 \
+	wsjtgen.F90 runqqq.F90 fivehz.F90 \
+	packpfx.f90 unpackpfx.f90 packname.f90 unpackname.f90 \
 	hash.f90 gen64.f90 thnix.f90
 
 OBJS2F90 = ${SRCS2F90:.f90=.o}
@@ -66,18 +65,15 @@
 SRCS2F77 = wsjt1.f astro.f azdist.f coord.f dcoord.f deg2grid.f \
 	dot.f ftsky.f geocentric.f GeoDist.f grid2deg.f moon2.f \
 	MoonDop.f sun.f toxyz.f pfxdump.f \
-        avesp2.f bzap.f spec441.f spec2d.f mtdecode.f stdecode.f \
-        indexx.f s2shape.f flat2.f genmet.f \
-	fourt.f chkmsg.f gentone.f \
+        bzap.f spec441.f spec2d.f avesp2.f \
+        indexx.f s2shape.f flat2.f fourt.f chkmsg.f gentone.f \
         set.f flatten.f db.f pctile.f sort.f ssort.f ps.f smooth.f \
-        ping.f longx.f peakup.f sync.f detect.f \
-        demod64a.f chkhist.f flat1.f four2.f \
-        gencw.f gencwid.f msgtype.f \
-	getpfx1.f getpfx2.f getsnr.f graycode.f grid2k.f \
+        sync.f demod64a.f chkhist.f flat1.f four2.f \
+        gencwid.f msgtype.f getsnr.f graycode.f grid2k.f \
         k2grid.f limit.f lpf1.f morse.f \
-        nchar.f packcall.f packgrid.f packmsg.f packtext.f \
+        nchar.f packcall.f packgrid.f packtext.f \
         slope.f spec2d65.f unpackcall.f \
-        unpackgrid.f unpackmsg.f unpacktext.f xcor.f xfft.f xfft2.f \
+        unpackgrid.f unpacktext.f xcor.f xfft.f xfft2.f \
 	ftpeak65.f fil651.f fil652.f fil653.f symsync65.f \
 	rfile2.f filbig2.F twkfreq.f fchisq.f ccf2.f wsjt64.f sync64.f 
 

Deleted: branches/wsjt8a/chkt0.f90
===================================================================
--- branches/wsjt8a/chkt0.f90	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/chkt0.f90	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,31 +0,0 @@
-subroutine chkt0(nplain,naddon,ndiff)
-
-!f2py threadsafe
-!f2py intent(out) nplain,naddon,ndiff
-  integer dgen(12)
-  character*22 t0msg2
-  include 'gcom2.f90'
-
-  call cs_lock('chkt0')
-  call packmsg(t0msg,dgen)
-  call unpackmsg(dgen,t0msg2)
-  if(index(t0msg,'/').gt.0) then
-     naddon=1
-  else
-     naddon=0
-  endif
-  if(iand(dgen(10),8).ne.0) then
-     nplain=1
-     naddon=0
-  else
-     nplain=0
-  endif
-  if(t0msg2.ne.t0msg) then
-     ndiff=1
-  else
-     ndiff=0
-  endif
-  call cs_unlock
-
-  return
-end subroutine chkt0

Deleted: branches/wsjt8a/detect.f
===================================================================
--- branches/wsjt8a/detect.f	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/detect.f	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,29 +0,0 @@
-      subroutine detect(data,npts,f,y)
-
-C  Compute powers at the tone frequencies using 1-sample steps.
-
-      parameter (NZ=11025,NSPD=25)
-      real data(npts)
-      real y(npts)
-      complex c(NZ)
-      complex csum
-      data twopi/6.283185307/
-
-      dpha=twopi*f/11025.0
-      do i=1,npts
-         c(i)=data(i)*cmplx(cos(dpha*i),-sin(dpha*i))
-      enddo
-
-      csum=0.
-      do i=1,NSPD
-         csum=csum+c(i)
-      enddo
-         
-      y(1)=real(csum)**2 + aimag(csum)**2
-      do i=2,npts-(NSPD-1)
-         csum=csum-c(i-1)+c(i+NSPD-1)
-         y(i)=real(csum)**2 + aimag(csum)**2
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/gencw.f
===================================================================
--- branches/wsjt8a/gencw.f	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/gencw.f	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,90 +0,0 @@
-      subroutine gencw(msg,wpm0,freqcw,samfac,iwave,nwave)
-
-C  Generates array iwave() containing an audio signal corresponding
-C  to an EME CW message.
-
-      parameter (NMAX=150*11025)
-      character*22 msg,s1,s2,s3
-      integer*2 iwave(NMAX)
-      integer*1 idat(5000),idat1(460),idat2(200),idat3(200)
-      real*8 dt,t,twopi,pha,dpha,tdit,samfac
-      data twopi/6.283185307d0/
-
-      call msgtype(msg,ntype,nrpt1,nrpt2,s1,s2)
-      call morse(s1,idat1,nz1)         !Encode string 1
-      nz2=0
-      if(ntype.ge.2) call morse(s2,idat2,nz2)   !Encode string 2
-      s3='KK'
-      call morse(s3,idat3,nz3)         !Encode 'KK'
-
-      b4=58.0*wpm0/1.2
-      b3=0.75*b4
-!      b1=0.25*b4
-
-      nr1=1
-      nr2=0
-      if(nrpt1.eq.100) then
-         nr1=nint((b4-nz3)/nz1)
-      else if(nrpt1.eq.1) then
-         nr2=nint((b4-nz1-nz3)/nz2)
-      else if(nrpt1.eq.75) then
-         nr1=nint(b3/nz1)
-         nr2=nint((b4-nr1*nz1-nz3)/nz2)
-      endif
-      nbits=nr1*nz1 + nr2*nz2 + nz3
-      
-      j=0
-      do n=1,nr1
-         do i=1,nz1
-            j=j+1
-            idat(j)=idat1(i)
-         enddo
-      enddo
-      if(nr2.gt.0) then
-         do n=1,nr2
-            do i=1,nz2
-               j=j+1
-               idat(j)=idat2(i)
-            enddo
-         enddo
-      endif
-
-      do i=1,nz3
-         j=j+1
-         idat(j)=idat3(i)
-      enddo
-      jz=j
-      do i=jz+1,5000
-         idat(j)=0
-      enddo
-
-      wpm=wpm0 * nbits/b4
-      tdit=1.2d0/wpm                   !Key-down dit time, seconds
-      dt=1.d0/(11025.d0*samfac)
-!      write(*,3001) msg,ntype,nr1,nz1,nr2,nz2,nz3,nbits,wpm,b4,1.d6*dt
-! 3001 format(a22,i3,6i5,f7.2,f8.2,f9.3)
-      nwave=jz*tdit/dt
-      pha=0.
-      dpha=twopi*freqcw*dt
-      t=0.
-      s=0.
-      u=wpm/(11025*0.03)
-      j0=1
-      nsign=1
-      do i=1,nwave
-         t=t+dt
-         pha=pha+dpha
-         j=nint(t/tdit) + 1
-         s=s + u*(idat(j)-s)
-         if(idat(j0).eq.0 .and. idat(j).ne.0) nsign=-nsign
-         iwave(i)=nsign*nint(s*32767.d0*sin(pha))
-         j0=j
-      enddo
-      do i=nwave+1,NMAX
-         iwave(i)=0
-      enddo
-      nwave=nwave+11025
-
-      return
-      end
-

Deleted: branches/wsjt8a/genmet.f
===================================================================
--- branches/wsjt8a/genmet.f	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/genmet.f	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,32 +0,0 @@
-      subroutine genmet(mode,mettab)
-
-C  Return appropriate metric table for soft-decision convolutional decoder.
-
-      real bias                         !bias for integer table
-      integer scale                     !scale factor for integer table
-C Metric table (RxSymbol,TxSymbol)
-      integer mettab(0:255,0:1)
-
-      call cs_lock('genmet')
-      bias=0.5
-      scale=10
-      if(mode.eq.6) then       !JT2, DBPSK
-         open(19,file='dmet_20_-2_2.dat',status='old')
-         scale=20
-      else if(mode.eq.7) then  !Non-coherent 2FSK
-         open(19,file='dmet_10_-1_3.dat',status='old')
-      else
-         print*,'Unsupported mode:',mode,' in genmet.'
-         stop 'genmet'
-      endif
-      call cs_unlock
-
-      do i=0,255
-         read(19,*) junk,d0,d1
-         mettab(i,0)=nint(scale*(d0-bias))
-         mettab(i,1)=nint(scale*(d1-bias))
-      enddo
-
-      return
-      end
-

Deleted: branches/wsjt8a/longx.f
===================================================================
--- branches/wsjt8a/longx.f	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/longx.f	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,132 +0,0 @@
-      subroutine longx(dat,npts0,ps,DFTolerance,noffset,
-     +    msg,msglen,bauderr)
-
-C  Look for 441-baud modulation, synchronize to it, and decode message.
-C  Longest allowed data analysis is 1 second.
-
-      parameter (NMAX=11025)
-      parameter (NDMAX=NMAX/25)
-      real dat(npts0)
-      real ps(128),psmo(20)
-      integer DFTolerance
-      real y1(NMAX)
-      real y2(NMAX)
-      real y3(NMAX)
-      real y4(NMAX)
-      real wgt(-2:2)
-      integer dit(NDMAX)
-      integer n4(0:2)
-      character msg*40
-      character c*48
-      common/acom/a1,a2,a3,a4
-      data c/' 123456789.,?/# $ABCD FGHIJKLMNOPQRSTUVWXY 0EZ  '/
-      data wgt/1.0,4.0,6.0,4.0,1.0/
-
-      kpk=0 !shut up compiler warnings -db
-      do i=1,NDMAX
-        dit(i)=0
-      enddo
-      NSPD=25                                !Change if FSK110 is implemented
-      LTone=2
-      NBaud=11025/NSPD
-      npts=min(NMAX,npts0)
-      df=11025.0/256.0
-      smax=0.
-
-C  Find the frequency offset of this ping.
-C  NB: this might be improved by including a bandpass correction to ps.
-
-      ia=nint((LTone*NBaud-DFTolerance)/df)
-      ib=nint((LTone*NBaud+DFTolerance)/df)
-
-      do i=ia,ib                            !Search for correct DF
-         sum=0.
-         do j=1,4                           !Sum over the 4 tones
-            m=nint((i*df+(j-1)*NBaud)/df)
-            do k=-2,2                       !Weighted averages over 5 bins
-               sum=sum+wgt(k)*ps(m+k)
-            enddo
-         enddo
-         k=i-ia+1
-         psmo(k)=sum
-
-         if(sum.gt.smax) then
-            smax=sum
-            noffset=nint(i*df-LTone*NBaud)
-            kpk=k
-         endif
-      enddo
-
-
-      if(kpk.gt.1 .and. kpk.lt.20) then
-         call peakup(psmo(kpk-1),psmo(kpk),psmo(kpk+1),dx)
-         noffset=nint(noffset+dx*df)
-      endif
-
-C  Do square-law detection in each of four filters.
-      f1=LTone*NBaud+noffset
-      f2=(LTone+1)*NBaud+noffset
-      f3=(LTone+2)*NBaud+noffset
-      f4=(LTone+3)*NBaud+noffset
-      call detect(dat,npts,f1,y1)
-      call detect(dat,npts,f2,y2)
-      call detect(dat,npts,f3,y3)
-      call detect(dat,npts,f4,y4)
-
-C  Bandpass correction:
-      npts=npts-(NSPD-1)
-      do i=1,npts
-         y1(i)=y1(i)*a1
-         y2(i)=y2(i)*a2
-         y3(i)=y3(i)*a3
-         y4(i)=y4(i)*a4
-      enddo
-
-      call sync(y1,y2,y3,y4,npts,jpk,baud,bauderr)
-
-C  Decimate y arrays by NSPD
-      ndits=npts/NSPD - 1
-      do i=1,ndits
-         y1(i)=y1(jpk+(i-1)*NSPD)
-         y2(i)=y2(jpk+(i-1)*NSPD)
-         y3(i)=y3(jpk+(i-1)*NSPD)
-         y4(i)=y4(jpk+(i-1)*NSPD)
-      enddo
-
-C  Now find the mod3 phase that has no tone 3's
-      n4(0)=0
-      n4(1)=0
-      n4(2)=0
-      do i=1,ndits
-         ymax=max(y1(i),y2(i),y3(i),y4(i))
-         if(y1(i).eq.ymax) dit(i)=0
-         if(y2(i).eq.ymax) dit(i)=1
-         if(y3(i).eq.ymax) dit(i)=2
-         if(y4(i).eq.ymax) then
-            dit(i)=3
-            k=mod(i,3)
-            n4(k)=n4(k)+1
-         endif
-      enddo
-
-      n4min=min(n4(0),n4(1),n4(2))
-      if(n4min.eq.n4(0)) jsync=3
-      if(n4min.eq.n4(1)) jsync=1
-      if(n4min.eq.n4(2)) jsync=2
-C  Might want to notify if n4min&gt;0 or if one of the others is equal
-C  to n4min.  In both cases, could then decode 2 or 3 times, using
-C  other starting phases.
-
-C  Finally, decode the message.
-      msg='                                        '
-      msglen=ndits/3
-      msglen=min(msglen,40)
-      do i=1,msglen
-         j=(i-1)*3+jsync
-         nc=16*dit(j) + 4*dit(j+1) +dit(j+2)
-         msg(i:i)=' '
-         if(nc.le.47 .and. nc.ge.0) msg(i:i)=c(nc+1:nc+1)
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/mtdecode.f
===================================================================
--- branches/wsjt8a/mtdecode.f	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/mtdecode.f	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,147 +0,0 @@
-      subroutine mtdecode(dat,jz,nz,MinSigdB,MinWidth,
-     +    NQRN,DFTolerance,istart,pick,cfile6,ps0)
-
-C  Decode Multi-Tone FSK441 mesages.
-
-      real dat(jz)                !Raw audio data
-      integer NQRN
-      integer DFTolerance
-      logical pick
-      character*6 cfile6,cf*1
-
-      real sigdb(3100)             !Detected signal in dB, sampled at 20 ms
-      real work(3100)
-      integer indx(3100)
-      real pingdat(3,100)
-      real ps(128)
-      real ps0(128)
-      character msg*40,msg3*3
-      character*90 line
-      common/ccom/nline,tping(100),line(100)
-
-      slim=MinSigdB
-      wmin=0.001*MinWidth * (19.95/20.0)
-      nf1=-DFTolerance
-      nf2=DFTolerance
-      msg3='   '
-      dt=1.0/11025.0
-
-C  Find signal power at suitable intervals to search for pings.
-      istep=221
-      dtbuf=istep/11025.
-      do n=1,nz
-         s=0.
-         ib=n*istep
-         ia=ib-istep+1
-         do i=ia,ib
-            s=s+dat(i)**2
-         enddo
-         sigdb(n)=s/istep
-      enddo
-
-!#####################################################################
-      if(.not.pick) then
-! Remove initial transient from sigdb
-         call indexx(nz,sigdb,indx)
-         imax=0
-         do i=1,50
-            if(indx(i).gt.50) go to 10
-            imax=max(imax,indx(i))
-         enddo
- 10      do i=1,50
-            if(indx(nz+1-i).gt.50) go to 20
-            imax=max(imax,indx(nz+1-i))
-         enddo
- 20      imax=imax+6            !Safety margin
-         base1=sigdb(indx(nz/2))
-         do i=1,imax
-            sigdb(i)=base1
-         enddo
-      endif
-!##################################################################
-
-      call smooth(sigdb,nz)
-
-C  Remove baseline and one dB for good measure.
-      call pctile (sigdb,work,nz,50,base1)
-      do i=1,nz
-         sigdb(i)=dB(sigdb(i)/base1) - 1.0
-      enddo
-
-      call ping(sigdb,nz,dtbuf,slim,wmin,pingdat,nping)
-
-C  If this is a &quot;mouse pick&quot; and no ping was found, force a pseudo-ping 
-C  at center of data.
-        if(pick.and.nping.eq.0) then
-           if(nping.le.99) nping=nping+1
-           pingdat(1,nping)=0.5*jz*dt
-           pingdat(2,nping)=0.16
-           pingdat(3,nping)=1.0
-        endif
-
-      bigpeak=0.
-      do iping=1,nping
-C  Find starting place and length of data to be analyzed:
-         tstart=pingdat(1,iping)
-         width=pingdat(2,iping)
-         peak=pingdat(3,iping)
-         mswidth=10*nint(100.0*width)
-         jj=(tstart-0.02)/dt
-         if(jj.lt.1) jj=1
-         jjz=nint((width+0.02)/dt)+1
-         jjz=min(jjz,jz+1-jj)
-
-C  Compute average spectrum of this ping.
-         call spec441(dat(jj),jjz,ps,f0)
-
-C  Decode the message.
-         msg=' '
-         call longx(dat(jj),jjz,ps,DFTolerance,noffset,msg,
-     +     msglen,bauderr)
-         qrnlimit=4.4*1.5**(5.0-NQRN)
-         if(NQRN.eq.0) qrnlimit=99.
-         if(msglen.eq.0) go to 100
-
-C  Assemble a signal report:
-         nwidth=0
-         if(width.ge.0.04) nwidth=1     !These might depend on NSPD
-         if(width.ge.0.12) nwidth=2
-         if(width.gt.1.00) nwidth=3
-         nstrength=6
-         if(peak.ge.11.0) nstrength=7
-         if(peak.ge.17.0) nstrength=8
-         if(peak.ge.23.0) nstrength=9
-
-!         if(peak.gt.5.0 .and.mswidth.ge.100) then
-!            call specsq(dat(jj),jjz,DFTolerance,0,noffset2)
-!            noffset=noffset2
-!         endif
-
-C  Discard this ping if DF outside tolerance limits or bauderr too big.
-C  (However, if the ping was mouse-picked, proceed anyway.)
-
-         if(.not.pick .and. ((noffset.lt.nf1 .or. noffset.gt.nf2) .or.
-     +      (abs(bauderr).gt.qrnlimit))) goto 100
-
-C  If it's the best ping yet, save the spectrum:
-         if(peak.gt.bigpeak) then
-            bigpeak=peak
-            do i=1,128
-               ps0(i)=ps(i)
-            enddo
-         endif
-   
-         tstart=tstart + dt*(istart-1)
-         cf=' '
-         if(nline.le.99) nline=nline+1
-         tping(nline)=tstart
-         call cs_lock('mtdecode')
-         write(line(nline),1050) cfile6,tstart,mswidth,int(peak),
-     +        nwidth,nstrength,noffset,msg3,msg,cf
- 1050    format(a6,f5.1,i5,i3,1x,2i1,i5,1x,a3,1x,a40,1x,a1)
-         call cs_unlock
- 100  continue
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/packmsg.f
===================================================================
--- branches/wsjt8a/packmsg.f	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/packmsg.f	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,85 +0,0 @@
-      subroutine packmsg(msg,dat)
-
-      parameter (NBASE=37*36*10*27*27*27)
-      character*22 msg
-      integer dat(12)
-      character*12 c1,c2
-      character*4 c3
-      character*6 grid6
-c      character*3 dxcc                  !Where is DXCC implemented?
-      logical text1,text2,text3
-
-C  Convert all letters to upper case
-      do i=1,22
-         if(msg(i:i).ge.'a' .and. msg(i:i).le.'z') 
-     +     msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
-      enddo
-
-C  See if it's a CQ message
-      if(msg(1:3).eq.'CQ ') then
-         i=3
-C  ... and if so, does it have a reply frequency?
-         if(msg(4:4).ge.'0' .and. msg(4:4).le.'9' .and. 
-     +      msg(5:5).ge.'0' .and. msg(5:5).le.'9' .and. 
-     +      msg(6:6).ge.'0' .and. msg(6:6).le.'9') i=7
-         go to 1
-      endif
-
-      do i=1,22
-         if(msg(i:i).eq.' ') go to 1       !Get 1st blank
-      enddo 
-      go to 10                             !Consider msg as plain text
-      
- 1    ia=i
-      c1=msg(1:ia-1)
-      do i=ia+1,22
-         if(msg(i:i).eq.' ') go to 2       !Get 2nd blank
-      enddo
-      go to 10                             !Consider msg as plain text
-
- 2    ib=i
-      c2=msg(ia+1:ib-1)
-
-      do i=ib+1,22
-         if(msg(i:i).eq.' ') go to 3       !Get 3rd blank
-      enddo
-      go to 10                             !Consider msg as plain text
-
- 3    ic=i
-      c3='    '
-      if(ic.ge.ib+1) c3=msg(ib+1:ic)
-      if(c3.eq.'OOO ') c3='    '           !Strip out the OOO flag
-      call getpfx1(c1,k1)
-      call packcall(c1,nc1,text1)
-      call getpfx1(c2,k2)
-      call packcall(c2,nc2,text2)
-      if(k1.lt.0 .or. k2.lt.0 .or. k1*k2.ne.0) go to 10
-      if(k2.gt.0) k2=k2+450
-      k=max(k1,k2)
-      if(k.gt.0) then
-         call k2grid(k,grid6)
-         c3=grid6(1:4) !XXX explicitly truncate this -db
-      endif
-      call packgrid(c3,ng,text3)
-      if((.not.text1) .and. (.not.text2) .and. (.not.text3)) go to 20
-
-C  The message will be treated as plain text.
- 10   call packtext(msg,nc1,nc2,ng)
-      ng=ng+32768
-
-C  Encode data into 6-bit words
- 20   dat(1)=iand(ishft(nc1,-22),63)                !6 bits
-      dat(2)=iand(ishft(nc1,-16),63)                !6 bits
-      dat(3)=iand(ishft(nc1,-10),63)                !6 bits
-      dat(4)=iand(ishft(nc1, -4),63)                !6 bits
-      dat(5)=4*iand(nc1,15)+iand(ishft(nc2,-26),3)  !4+2 bits
-      dat(6)=iand(ishft(nc2,-20),63)                !6 bits
-      dat(7)=iand(ishft(nc2,-14),63)                !6 bits
-      dat(8)=iand(ishft(nc2, -8),63)                !6 bits
-      dat(9)=iand(ishft(nc2, -2),63)                !6 bits
-      dat(10)=16*iand(nc2,3)+iand(ishft(ng,-12),15) !2+4 bits
-      dat(11)=iand(ishft(ng,-6),63)
-      dat(12)=iand(ng,63)
-
-      return
-      end

Deleted: branches/wsjt8a/packtext2.f90
===================================================================
--- branches/wsjt8a/packtext2.f90	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/packtext2.f90	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,22 +0,0 @@
-subroutine packtext2(msg,n1,ng)
-
-  character*8 msg
-  real*8 dn
-  character*41 c
-  data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +./?'/
-
-  dn=0.
-  do i=1,8
-     do j=1,41
-        if(msg(i:i).eq.c(j:j)) go to 10
-     enddo
-     j=37
-10   j=j-1                                !Codes should start at zero
-     dn=41.d0*dn + j
-  enddo
-
-  ng=mod(dn,32768.d0)
-  n1=(dn-ng)/32768.d0
-
-  return
-end subroutine packtext2

Deleted: branches/wsjt8a/peakup.f
===================================================================
--- branches/wsjt8a/peakup.f	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/peakup.f	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,8 +0,0 @@
-      subroutine peakup(ym,y0,yp,dx)
-
-      b=(yp-ym)/2.0
-      c=(yp+ym-2.0*y0)/2.0
-      dx=-b/(2.0*c)
-
-      return
-      end

Deleted: branches/wsjt8a/stdecode.f
===================================================================
--- branches/wsjt8a/stdecode.f	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/stdecode.f	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,110 +0,0 @@
-      subroutine stdecode(s2,nchan,nz,sigma,dtbuf,df,stlim0,
-     +    DFTolerance,cfile6,pick,istart)
-
-C  Search for and decode single-tone messages.
-
-      real s2(nchan,nz)
-      integer DFTolerance
-      logical pick
-      character cfile6*6,msg3*3
-      character*90 line
-      common/ccom/nline,tping(100),line(100)
-
-      NSPD=25                                !Change if FSK110 is implemented
-      LTone=2
-      NBaud=11025/NSPD
-
-      stlim=stlim0
-      if(pick) stlim=stlim0-1.0
-      iwidth=1
-      ts0=-1.0
-      dt=1.0/11025.0
-
-C  In each time slice, find largest peak between LTone*NBaud-DFTolerance and
-C  (LTone+3)*NBaud+DFTolerance.
-
-      ia=(LTone*NBaud-DFTolerance)/df - 5.0
-      ib=((LTone+3)*NBaud+DFTolerance)/df - 4.0
-      ipk=0 !Shut up compiler warnings. -db
-      do j=1,nz
-         smax=0.
-         do i=ia,ib                      !Get the spectral peak
-            if(s2(i,j).gt.smax) then
-               smax=s2(i,j)
-               ipk=i
-            endif
-         enddo
-         peak=dB(smax/sigma) - 14.0  !Empirical
-C  constant should be dB(43/2500) = -17.6 dB?
-
-         if(peak.gt.stlim) then
-C  To minimize false ST decodings from QRN and MT pings, find the
-C  second best peak (excluding points around the first peak).
-            smax2=0.
-            do i=ia,ib
-               if((abs(i-ipk).gt.iwidth) .and. s2(i,j).gt.smax2) then
-                  smax2=s2(i,j)
-               endif
-            enddo
-
-C  Larger values of ratlim make it more likely to report ST decodings.
-            ratlim=0.18
-            if(stlim.lt.-2.5) ratlim=0.20
-            if(stlim.lt.-3.5) ratlim=0.22
-            if(stlim.lt.-4.5) ratlim=0.24
-            if(pick) ratlim=0.27                !Fine tuning here...
-            if(smax2/smax.gt.ratlim) goto 20
-
-            call peakup(s2(ipk-1,j),s2(ipk,j),s2(ipk+1,j),dx)
-            freq=(ipk+5+dx)*df
-            tstart=j*dtbuf + dt*(istart-1)
-            mswidth=20
-            nwidth=0
-            nstrength=0
-            n=nint(freq/NBaud)
-            noffset=freq-n*NBaud
-            if((noffset.lt.-DFTolerance) .or.
-     +        (noffset.gt.DFTolerance)) goto 20
-
-C  The numbers 2 and 5 depend on Ltone:
-            if(n.lt.2 .or. n.gt.5) goto 20
-
-C  OK, this detection has survived all tests.  Save it for output
-C  (uness perhaps it is redundant).
-
-            if(n.eq.LTone)   msg3='R26'
-            if(n.eq.LTone+1) msg3='R27'
-            if(n.eq.LTone+2) msg3='RRR'
-            if(n.eq.LTone+3) msg3='73'
-
-C  Now check for redundant detections.  (Not sure, now, why I chose
-C  the time span 0.11 s.)
-            peak0=0.0 !Shut up compiler warnings. -db
-            if(tstart-ts0.gt.0.11) then
-               peak0=0.                 !If time diff&gt;0.11s, start fresh
-            else
-               if(peak.le.peak0) goto 20
-               nline=nline-1            !Delete previous, this one's better
-               peak0=peak               !Save best peak
-            endif
-
-C  OK, we want to output this one.  Save the information.
-            if(nline.le.99) nline=nline+1
-            ts0=tstart
-            tping(nline)=tstart
-            nst=(int(smax/smax2)-4)/2 + 1
-            if(nst.lt.1) nst=1
-            if(nst.gt.3) nst=3
-
-            call cs_lock('stdecode')
-            write(line(nline),1050) cfile6,tstart,mswidth,int(peak),
-     +           nwidth,nstrength,noffset,msg3,nst
- 1050       format(a6,f5.1,i5,i3,1x,2i1,i5,1x,a3,40x,i3)
-            call cs_unlock
-         endif
-
- 20      continue
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/unpackmsg.f
===================================================================
--- branches/wsjt8a/unpackmsg.f	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/unpackmsg.f	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,91 +0,0 @@
-      subroutine unpackmsg(dat,msg)
-
-      parameter (NBASE=37*36*10*27*27*27)
-      parameter (NGBASE=180*180)
-      integer dat(12)
-      character c1*12,c2*12,grid*4,msg*22,grid6*6
-      logical cqnnn
-
-      cqnnn=.false.
-      nc1=ishft(dat(1),22) + ishft(dat(2),16) + ishft(dat(3),10)+
-     +  ishft(dat(4),4) + iand(ishft(dat(5),-2),15)
-
-      nc2=ishft(iand(dat(5),3),26) + ishft(dat(6),20) + 
-     +  ishft(dat(7),14) + ishft(dat(8),8) + ishft(dat(9),2) + 
-     +  iand(ishft(dat(10),-4),3)
-
-      ng=ishft(iand(dat(10),15),12) + ishft(dat(11),6) + dat(12)
-
-      if(ng.gt.32768) then
-         call unpacktext(nc1,nc2,ng,msg)
-         go to 100
-      endif
-
-      if(nc1.lt.NBASE) then
-         call unpackcall(nc1,c1)
-      else
-         c1='......'
-         if(nc1.eq.NBASE+1) c1='CQ    '
-         if(nc1.eq.NBASE+2) c1='QRZ   '
-         nfreq=nc1-NBASE-3
-         if(nfreq.ge.0 .and. nfreq.le.999) then
-            c1(1:3)='CQ '
-            c1(4:4)=char(48+nfreq/100)
-            c1(5:5)=char(48+mod(nfreq/10,10))
-            c1(6:6)=char(48+mod(nfreq,10))
-            cqnnn=.true.           
-         endif         
-      endif
-
-      if(nc2.lt.NBASE) then
-         call unpackcall(nc2,c2)
-      else
-         c2='......'
-      endif
-
-      call unpackgrid(ng,grid)
-      grid6=grid//'ma'
-      call grid2k(grid6,k)
-      if(k.ge.1 .and. k.le.450)   call getpfx2(k,c1)
-      if(k.ge.451 .and. k.le.900) call getpfx2(k,c2)
-
-      i=index(c1,char(0))
-      if(i.ge.3) c1=c1(1:i-1)//'            '
-      i=index(c2,char(0))
-      if(i.ge.3) c2=c2(1:i-1)//'            '
-
-      msg='                      '
-      j=0
-      if(cqnnn) then
-         msg=c1//'                '
-         j=7                                  !### ??? ###
-         go to 10
-      endif
-
-      do i=1,12
-         j=j+1
-         msg(j:j)=c1(i:i)
-         if(c1(i:i).eq.' ') go to 10
-      enddo
-      j=j+1
-      msg(j:j)=' '
-
- 10   do i=1,12
-         if(j.le.21) j=j+1
-         msg(j:j)=c2(i:i)
-         if(c2(i:i).eq.' ') go to 20
-      enddo
-      j=j+1
-      msg(j:j)=' '
-
- 20   if(k.eq.0) then
-         do i=1,4
-            if(j.le.21) j=j+1
-            msg(j:j)=grid(i:i)
-         enddo
-         j=j+1
-         msg(j:j)=' '
-      endif
-
- 100  return
-      end

Deleted: branches/wsjt8a/unpacktext2.f90
===================================================================
--- branches/wsjt8a/unpacktext2.f90	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/unpacktext2.f90	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1,17 +0,0 @@
-subroutine unpacktext2(n1,ng,msg)
-
-  character*22 msg
-  real*8 dn
-  character*41 c
-  data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +./?'/
-
-  msg='                      '
-  dn=32768.d0*n1 + ng
-  do i=8,1,-1
-     j=mod(dn,41.d0)
-     msg(i:i)=c(j+1:j+1)
-     dn=dn/41.d0
-  enddo
-
-  return
-end subroutine unpacktext2

Modified: branches/wsjt8a/wsjt.py
===================================================================
--- branches/wsjt8a/wsjt.py	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/wsjt.py	2009-09-12 01:34:30 UTC (rev 1339)
@@ -1218,21 +1218,21 @@
             ToRadio0=ToRadio.get()
             t0=(&quot;SM5BSZ &quot;+options.MyCall.get()).upper()
             Audio.gcom2.t0msg=(t0+' '*22)[:22]
-            nplain,naddon,ndiff=Audio.chkt0()
-            if nplain==1:
-                MsgBox(&quot;Bad 'MyCall' or bad prefix/suffix?\nPlease check on Setup | Options screen.&quot;)
-                options1()
-            t0=(&quot;SM5BSZ &quot;+ToRadio0).upper()
-            Audio.gcom2.t0msg=(t0+' '*22)[:22]
-            nplain,naddon,ndiff=Audio.chkt0()
-            if nplain==1:
-                MsgBox(&quot;Bad callsign in 'To Radio'?\nPlease check.&quot;)
+#            nplain,naddon,ndiff=Audio.chkt0()
+#            if nplain==1:
+#                MsgBox(&quot;Bad 'MyCall' or bad prefix/suffix?\nPlease check on Setup | Options screen.&quot;)
+#                options1()
+#            t0=(&quot;SM5BSZ &quot;+ToRadio0).upper()
+#            Audio.gcom2.t0msg=(t0+' '*22)[:22]
+#            nplain,naddon,ndiff=Audio.chkt0()
+#            if nplain==1:
+#                MsgBox(&quot;Bad callsign in 'To Radio'?\nPlease check.&quot;)
             
-        t0=(ToRadio.get() + &quot; &quot;+options.MyCall.get()).upper()
-        Audio.gcom2.t0msg=(t0+' '*22)[:22]
-        nplain,naddon,ndiff=Audio.chkt0()
-        if nplain==0 and naddon==0 and ndiff==0:
-            t0=t0 + &quot; &quot;+options.MyGrid.get()[:4]
+#        t0=(ToRadio.get() + &quot; &quot;+options.MyCall.get()).upper()
+#        Audio.gcom2.t0msg=(t0+' '*22)[:22]
+#        nplain,naddon,ndiff=Audio.chkt0()
+#        if nplain==0 and naddon==0 and ndiff==0:
+#            t0=t0 + &quot; &quot;+options.MyGrid.get()[:4]
         tx1.insert(0,t0.upper())
         tx2.insert(0,tx1.get()+&quot; OOO&quot;)
         tx3.insert(0,&quot;RO&quot;)
@@ -1240,10 +1240,10 @@
         tx5.insert(0,&quot;73&quot;)
 
         t0=&quot;CQ &quot; + options.MyCall.get().upper()
-        Audio.gcom2.t0msg=(t0+' '*22)[:22]
-        nplain,naddon,ndiff=Audio.chkt0()
-        if nplain==0 and naddon==0 and ndiff==0:
-            t0=t0 + &quot; &quot;+options.MyGrid.get()[:4]
+#        Audio.gcom2.t0msg=(t0+' '*22)[:22]
+#        nplain,naddon,ndiff=Audio.chkt0()
+#        if nplain==0 and naddon==0 and ndiff==0:
+#            t0=t0 + &quot; &quot;+options.MyGrid.get()[:4]
         tx6.insert(0,t0.upper())
         altmsg=0
     elif mode.get()[:4]=='JT64':
@@ -1253,19 +1253,19 @@
             addpfx0=options.addpfx.get()
             ToRadio0=ToRadio.get()
             t0=(&quot;SM5BSZ &quot;+options.MyCall.get()).upper()
-            Audio.gcom2.t0msg=(t0+' '*22)[:22]
-            nplain,naddon,ndiff=Audio.chkt0()
-            if nplain==1:
-                MsgBox(&quot;Bad 'MyCall' or bad prefix/suffix?\nPlease check on Setup | Options screen.&quot;)
-                options1()
-            t0=(&quot;SM5BSZ &quot;+ToRadio0).upper()
-            Audio.gcom2.t0msg=(t0+' '*22)[:22]
-            nplain,naddon,ndiff=Audio.chkt0()
-            if nplain==1:
-                MsgBox(&quot;Bad callsign in 'To Radio'?\nPlease check.&quot;)
+#            Audio.gcom2.t0msg=(t0+' '*22)[:22]
+#            nplain,naddon,ndiff=Audio.chkt0()
+#            if nplain==1:
+#                MsgBox(&quot;Bad 'MyCall' or bad prefix/suffix?\nPlease check on Setup | Options screen.&quot;)
+#                options1()
+#            t0=(&quot;SM5BSZ &quot;+ToRadio0).upper()
+#            Audio.gcom2.t0msg=(t0+' '*22)[:22]
+#            nplain,naddon,ndiff=Audio.chkt0()
+#            if nplain==1:
+#                MsgBox(&quot;Bad callsign in 'To Radio'?\nPlease check.&quot;)
             
-        t0=(&quot;&lt;&quot; + ToRadio.get() + &quot;&gt; &quot;+options.MyCall.get()).upper()
-        Audio.gcom2.t0msg=(t0+' '*22)[:22]
+#        t0=(&quot;&lt;&quot; + ToRadio.get() + &quot;&gt; &quot;+options.MyCall.get()).upper()
+#        Audio.gcom2.t0msg=(t0+' '*22)[:22]
 ##        nplain,naddon,ndiff=Audio.chkt0()
 ##        if nplain==0 and naddon==0 and ndiff==0:
 ##            t0=t0 + &quot; &quot;+options.MyGrid.get()[:4]
@@ -1281,11 +1281,11 @@
         t5=(&quot;73 DE &quot;+options.MyCall.get()+ &quot; &quot;+options.MyGrid.get()[:4]).upper()
         tx5.insert(0,t5)
 
-        t0=&quot;CQ &quot; + options.MyCall.get().upper()
-        Audio.gcom2.t0msg=(t0+' '*22)[:22]
-        nplain,naddon,ndiff=Audio.chkt0()
-        if nplain==0 and naddon==0 and ndiff==0:
-            t0=t0 + &quot; &quot;+options.MyGrid.get()[:4]
+#        t0=&quot;CQ &quot; + options.MyCall.get().upper()
+#        Audio.gcom2.t0msg=(t0+' '*22)[:22]
+#        nplain,naddon,ndiff=Audio.chkt0()
+#        if nplain==0 and naddon==0 and ndiff==0:
+#            t0=t0 + &quot; &quot;+options.MyGrid.get()[:4]
         tx6.insert(0,t0.upper())
         altmsg=0
     

Modified: branches/wsjt8a/wsjt1.F
===================================================================
--- branches/wsjt8a/wsjt1.F	2009-09-11 20:44:43 UTC (rev 1338)
+++ branches/wsjt8a/wsjt1.F	2009-09-12 01:34:30 UTC (rev 1339)
@@ -224,52 +224,7 @@
         if(sigma.lt.0.0) basevb=-99.0
         if(sigma.lt.0.0) go to 900
         nline0=nline
-        STfound=.false.
-        npkept=0
 
-C  Look for single-tone messages
-        if((.not.pick) .or. MouseButton.eq.1) then
-           call stdecode(s2,nchan,nz,sigma,dtbuf,df,stlim,
-     +       DFTolerance,cfile6,pick,istart)
-        endif
-        if(nline.gt.nline0) STfound=.true.  !ST message(s) found
-
-C  Now the multi-tone decoding
-        call mtdecode(dat,jz,nz,MinSigdB,MinWidth,
-     +    NQRN,DFTolerance,istart,pick,cfile6,ps0)
-
-        npkept=nline             !Number of pings that were kept
-        smax=0.
-        stbest=.false.
-        if(npkept.gt.0) then
-           call indexx(npkept,tping,indx) !Merge the ST and MT decodes
-           do i=1,npkept
-              j=indx(i)
-              if(pick .and. STFound .and.
-     +          line(j)(29:31).eq.'   ') goto 10
-              call cs_lock('wsjt1')
-              write(lumsg,1050) line(j) !Write to decoded.txt
- 1050         format(a79)
-              if(lcum) write(21,1050) line(j) !Write to ALL.TXT
-              read(line(j),1060) sig,msg3
- 1060         format(16x,f3.0,9x,a3)
-              call cs_unlock
-              if(sig.gt.smax) then
-                 smax=sig
-                 tbest=tping(j)
-                 stbest = (msg3.ne.'   ')
-              endif
- 10        continue
-           enddo
-        endif
-
-        dt=1.0/11025.0                !Compute spectrum for pink curve
-        if(stbest) then
-           jj=nint(tbest/dt)
-           call spec441(dat(jj),1102,ps0,f0)
-        endif
-
- 800    continue
         call s2shape(s2,nchan,nz,tbest)
 
  900    LDecoded = ((NSyncOK.gt.0) .or. npkept.gt.0)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001030.html">[WSJT-SVN] r1338 - branches/wsjt8a
</A></li>
	<LI>Next message: <A HREF="001032.html">[WSJT-SVN] r1340 - branches/wsjt8a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1031">[ date ]</a>
              <a href="thread.html#1031">[ thread ]</a>
              <a href="subject.html#1031">[ subject ]</a>
              <a href="author.html#1031">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
