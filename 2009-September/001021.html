<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r1327 - branches/wsjt8a
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1327%20-%20branches/wsjt8a&In-Reply-To=%3C200909101908.n8AJ85mh004484%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001020.html">
   <LINK REL="Next"  HREF="001022.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r1327 - branches/wsjt8a</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1327%20-%20branches/wsjt8a&In-Reply-To=%3C200909101908.n8AJ85mh004484%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r1327 - branches/wsjt8a">k1jt at mail.berlios.de
       </A><BR>
    <I>Thu Sep 10 21:08:05 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001020.html">[WSJT-SVN] r1326 - branches/wsjt8a
</A></li>
        <LI>Next message: <A HREF="001022.html">[WSJT-SVN] r1328 - branches/wsjt8a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1021">[ date ]</a>
              <a href="thread.html#1021">[ thread ]</a>
              <a href="subject.html#1021">[ subject ]</a>
              <a href="author.html#1021">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2009-09-10 21:07:57 +0200 (Thu, 10 Sep 2009)
New Revision: 1327

Removed:
   branches/wsjt8a/JT65code.f
   branches/wsjt8a/JT65code_all.f
   branches/wsjt8a/avemsg65.f
   branches/wsjt8a/avemsg6m.f
   branches/wsjt8a/decode24.f
   branches/wsjt8a/decode65.f
   branches/wsjt8a/decode6m.f
   branches/wsjt8a/deep65.F
   branches/wsjt8a/encode65.f
   branches/wsjt8a/gen24.f
   branches/wsjt8a/gen65.f
   branches/wsjt8a/gen6m.f
   branches/wsjt8a/interleave24.f
   branches/wsjt8a/ps24.f
   branches/wsjt8a/setup65.f
   branches/wsjt8a/short65.f
   branches/wsjt8a/sync24.f
   branches/wsjt8a/sync65.f
   branches/wsjt8a/wsjt24.f
   branches/wsjt8a/wsjt65.f
   branches/wsjt8a/xcor24.f
Modified:
   branches/wsjt8a/wsjt1.F
   branches/wsjt8a/wsjtgen.F90
Log:
Removed many routines not presently used.


Deleted: branches/wsjt8a/JT65code.f
===================================================================
--- branches/wsjt8a/JT65code.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/JT65code.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,46 +0,0 @@
-      program JT65code
-
-C  Provides examples of message packing, bit and symbol ordering,
-C  Reed Solomon encoding, and other necessary details of the JT65
-C  protocol.
-
-      character*22 msg0,msg,decoded,cok*3
-      integer dgen(12),sent(63),recd(12),era(51)
-
-      nargs=iargc()
-      if(nargs.ne.1) then
-         print*,'Usage: JT65code &quot;message&quot;'
-         go to 999
-      endif
-
-      call getarg(1,msg0)                     !Get message from command line
-      msg=msg0
-
-      call chkmsg(msg,cok,nspecial,flip)      !See if it includes &quot;OOO&quot; report
-      if(nspecial.gt.0) then                  !or is a shorthand message
-         write(*,1010) 
- 1010    format('Shorthand message.')
-         go to 999
-      endif
-
-      call packmsg(msg,dgen)                  !Pack message into 72 bits
-      write(*,1020) msg0
- 1020 format('Message:   ',a22)               !Echo input message
-      if(iand(dgen(10),8).ne.0) write(*,1030)  !Is the plain text bit set?
- 1030 format('Plain text.')         
-      write(*,1040) dgen
- 1040 format('Packed message, 6-bit symbols: ',12i3) !Display packed symbols
-
-      call rs_encode(dgen,sent)               !RS encode
-      call interleave63(sent,1)               !Interleave channel symbols
-      call graycode(sent,63,1)                !Apply Gray code
-      write(*,1050) sent
- 1050 format('Channel symbols, including FEC:'/(i5,20i3))
-
-      call graycode(sent,63,-1)
-      call interleave63(sent,-1)
-      call rs_decode(sent,era,0,recd,nerr)
-      call unpackmsg(recd,decoded)            !Unpack the user message
-      write(*,1060) decoded,cok
- 1060 format('Decoded message: ',a22,2x,a3)
- 999  end

Deleted: branches/wsjt8a/JT65code_all.f
===================================================================
--- branches/wsjt8a/JT65code_all.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/JT65code_all.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,20 +0,0 @@
-	include 'JT65code.f'
-	include 'nchar.f'
-	include 'grid2deg.f'
-	include 'packmsg.f'
-	include 'packtext.f'
-	include 'packcall.f'
-	include 'packgrid.f'
-	include 'unpackmsg.f'
-	include 'unpacktext.f'
-	include 'unpackcall.f'
-	include 'unpackgrid.f'
-	include 'deg2grid.f'
-	include 'chkmsg.f'
-	include 'getpfx1.f'
-	include 'getpfx2.f'
-	include 'k2grid.f'
-	include 'grid2k.f'
-	include 'interleave63.f'
-	include 'graycode.f'
-	include 'set.f'

Deleted: branches/wsjt8a/avemsg65.f
===================================================================
--- branches/wsjt8a/avemsg65.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/avemsg65.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,63 +0,0 @@
-      subroutine avemsg65(mseg,mode65,ndepth,nchallenge,decoded,nused,
-     +  nq1,nq2,neme,mycall,hiscall,hisgrid,qual,
-     +  ns,ncount)
-
-C  Decodes averaged JT65 data for the specified segment (mseg=1 or 2).
-
-      parameter (MAXAVE=120)                    !Max avg count is 120
-      character decoded*22,deepmsg*22
-      character mycall*12,hiscall*12,hisgrid*6
-      real s3(64,63)
-      common/ave/ppsave(64,63,MAXAVE),nflag(MAXAVE),nsave,iseg(MAXAVE)
-
-C  Count the available spectra for this Monitor segment (mseg=1 or 2),
-C  and the number of spectra flagged as good.
-
-      nused=0
-      ns=0
-      nqual=0
-      deepmsg='                      '
-      do i=1,nsave
-         if(iseg(i).eq.mseg) then
-            ns=ns+1
-            if(nflag(i).eq.1) nused=nused+1
-         endif
-      enddo
-      if(nused.lt.1) go to 100
-
-C  Compute the average of all flagged spectra for this segment.
-      do j=1,63
-         call zero(s3(1,j),64)
-         do n=1,nsave
-            if(nflag(n).eq.1 .and. iseg(n).eq.mseg) then
-               call add(s3(1,j),ppsave(1,j,n),s3(1,j),64)
-            endif
-         enddo
-      enddo
-
-      nadd=nused*mode65
-      call extract(s3,nadd,ncount,decoded)     !Extract the message
-      if(ncount.lt.0) decoded='                      '
-
-      nqual=0
-C  Possibly should pass nadd=nused, also:
-      if(ndepth.ge.3) then
-         flipx=1.0                     !Normal flip not relevant for ave msg
-         call deep65(s3,mode65,neme,nchallenge,flipx, 
-     +   mycall,hiscall,hisgrid,deepmsg,qual)
-         nqual=qual
-         if(nqual.lt.nq1) deepmsg='                      '
-         if(nqual.ge.nq1 .and. nqual.lt.nq2) deepmsg(19:19)='?'
-      else
-         deepmsg='                      '
-         qual=0.
-      endif
-      if(ncount.lt.0) decoded=deepmsg
-
-C  Suppress &quot;birdie messages&quot;:
-      if(decoded(1:7).eq.'000AAA ') decoded='                      '
-      if(decoded(1:7).eq.'0L6MWK ') decoded='                      '
-
- 100  if(nused.lt.1) decoded='                      '
-      return
-      end

Deleted: branches/wsjt8a/avemsg6m.f
===================================================================
--- branches/wsjt8a/avemsg6m.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/avemsg6m.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,115 +0,0 @@
-      subroutine avemsg6m(s2db,nz,nslim,NFixLen,cfile6,lcum,
-     +  f0,lumsg,npkept)
-
-C  Attempts to find message length and then decodes an average message.
-
-      real s2db(0:43,nz)
-      real s2dc(0:43,22)
-      real wgt(22)
-      real acf(0:430)
-      logical lcum
-      character*43 pua
-      character*6 cfile6
-      character*22 avemsg,blanks
-      data pua/'0123456789., /#?$ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
-      data blanks/'                      '/
-      data twopi/6.283185307/
-      data offset/20.6/
-
-C  Adjustable sig limit, depending on length of data to average.
-      nslim2=nslim - 9 + 4.0*log10(624.0/nz)       !### +10 was here
-
-      k=0
-      sum=0.
-      nsum=0
-      do j=1,nz
-         if(mod(j,3).eq.1) then
-            sum=sum+s2db(0,j)        !Measure avg sig strength for sync tone
-            nsum=nsum+1
-         else
-            k=k+1
-            call move(s2db(0,j),s2db(0,k),44)  !Save data spectra
-         endif
-      enddo
-      sig=sum/nsum                                 !Signal strength estimate
-      nsig=nint(db(sig)-offset)
-
-C  Most of the time in this routine is in this loop.
-      kz=k
-      do lag=0,kz-1
-         sum=0.
-         do j=1,kz-lag
-            do i=0,43
-               sum=sum+s2db(i,j)*s2db(i,j+lag)
-            enddo
-         enddo
-         acf(lag)=sum
-      enddo
-      acf0=acf(0)
-      do lag=0,kz-1
-         acf(lag)=acf(lag)/acf0
-      enddo
-
-      lmsg1=NFixLen/256
-      lmsg2=NFixLen-256*lmsg1
-      if(mod(lmsg1,2).eq.1) lmsg1=lmsg1+1
-      if(mod(lmsg2,2).eq.1) lmsg2=lmsg2+1
-      smax=-1.e9
-      do ip=4,22,2               !Compute periodogram for allowed msg periods
-         if(NFixLen.ne.0 .and. ip.ne.4 .and. ip.ne.lmsg1 
-     +     .and. ip.ne.lmsg2) go to 5
-         f=1.0/ip
-         s=0.
-         do lag=0,kz-1
-            s=s+acf(lag)*cos(twopi*f*lag)
-         enddo
-         if(s.gt.smax) then
-            smax=s
-            msglen=ip                            !Save best message length
-         endif
- 5    continue
-      enddo
-
-
-C  Average the symbols from s2db into s2dc.
-
-      call zero(s2dc,44*22)
-      call zero(wgt,22)
-      do j=1,kz
-         k=mod(j-1,msglen)+1
-         call add(s2db(0,j),s2dc(0,k),s2dc(0,k),44)
-         wgt(k)=wgt(k)+1.0
-      enddo
-
-      ipk=0 !Shut up compiler warnings. -db
-      do j=1,msglen                            !Hard-decode the avg msg,
-         smax=-1.e9                            !picking max bin for each char
-         do i=1,43
-            s2dc(i,j)=s2dc(i,j)/wgt(j)
-            if(s2dc(i,j).gt.smax) then
-               smax=s2dc(i,j)
-               ipk=i
-            endif
-         enddo
-         k=mod(ipk,3)
-         i=ipk
-         avemsg(j:j)=pua(i:i)
-      enddo
-      ndf0=nint(f0-1076.66)
-      do i=1,msglen
-         if(avemsg(i:i).eq.' ') goto 10
-      enddo
-      go to 20
- 10   avemsg=avemsg(i+1:msglen)//avemsg(1:i)
- 20   if(nsig.gt.nslim2) then
-         npkept=npkept+1
-         avemsg=avemsg(1:msglen)//blanks
-         call cs_lock('avemsg6m')
-         write(lumsg,1020) cfile6,nsig,ndf0,avemsg,msglen
-         if(lcum) write(21,1020) cfile6,nsig,ndf0,avemsg,msglen
- 1020    format(a6,8x,i6,i5,7x,a22,19x,'*',i4)
-         call cs_unlock
-      endif
-
-      return
-      end

Deleted: branches/wsjt8a/decode24.f
===================================================================
--- branches/wsjt8a/decode24.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/decode24.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,236 +0,0 @@
-      subroutine decode24(dat,npts,dtx,dfx,flip,mode,mode4,
-     +  decoded,ncount,deepmsg,qual)
-
-C  Decodes JT65 data, assuming that DT and DF have already been determined.
-
-      real dat(npts)                        !Raw data
-      character decoded*22,deepmsg*22
-      character*72 c72
-      real*8 dt,df,phi,f0,dphi,twopi,phi1,dphi1
-      complex*16 cz,cz1,c0,c1
-      integer*1 symbol(207)
-      integer*1 data1(13)                   !Decoded data (8-bit bytes)
-      integer   data4a(9)                   !Decoded data (8-bit bytes)
-      integer   data4(12)                   !Decoded data (6-bit bytes)
-      integer amp,delta
-      integer mettab(0:255,0:1)             !Metric table
-      integer fano
-      integer nch(7)
-      integer npr2(207)
-      include 'avecom.h'
-      data mode0/-999/
-      data npr2/
-     +  0,0,0,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,1,1,0,0,
-     +  0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,
-     +  1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,0,0,1,
-     +  0,0,0,1,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,
-     +  0,1,1,1,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,0,1,1,0,0,0,1,1,1,
-     +  0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,1,1,
-     +  1,0,0,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1/
-      data nch/1,2,4,9,18,36,72/
-      save mettab,mode0
-
-      if(mode.ne.mode0) call genmet(mode,mettab)
-      mode0=mode
-      twopi=8*atan(1.d0)
-      dt=2.d0/11025             !Sample interval (2x downsampled data)
-      df=11025.d0/2520.d0
-      nsym=206
-      amp=15
-      istart=nint(dtx/dt)              !Start index for synced FFTs
-      if(istart.lt.0) istart=0
-      idfbest = 0
-      nchips = 0
-      ich = 0
-
-C  Should amp be adjusted according to signal strength?
-
-C  Compute soft symbols using differential BPSK demodulation
-      c0=0.                                !### C0=amp ???
-      k=istart
-      fac=1.e-4
-      phi=0.d0
-      phi1=0.d0
-      ang0=0.
-
-      if(mode.eq.6) then                   !JT2
-         nhmax=0
-         do idf=-20,20,2
-            c0=amp
-            k=istart
-            phi=0.d0
-            nh=0
-            do j=1,nsym+1
-               if(flip.gt.0.0) then
-                  f0=1270.46 + dfx + npr2(j)*df
-               else
-                  f0=1270.46 + dfx + (1-npr2(j))*df
-               endif
-               f0=f0 + 0.1*idf
-               dphi=twopi*dt*f0
-               c1=0.
-               do i=1,1260
-                  k=k+1
-                  phi=phi+dphi
-                  cz=dcmplx(cos(phi),-sin(phi))
-                  if(k.le.npts) c1=c1 + dat(k)*cz
-               enddo
-               rsym=amp*(real(c1)*real(c0) + aimag(c1)*aimag(c0))
-               ang=atan2(aimag(c1),real(c1))
-               ndang=nint(57.1957795131d0*(ang-ang0))
-               ang0=ang
-               if(ndang.le.-180) ndang=ndang+360
-               if(ndang.gt.180) ndang=ndang-360
-               if(ndang.lt.-90) ndang=ndang+180
-               if(ndang.gt. 90) ndang=ndang-180
-               if(rsym.ge.0.05 .and. abs(ndang).lt.20)nh=nh+1
-            enddo
-            if(nh.gt.nhmax) then
-               nhmax=nh
-               idfbest=idf
-            endif
-         enddo
-
-         c0=0
-         k=istart
-         phi=0.d0
-         do j=1,nsym+1
-            if(flip.gt.0.0) then
-               f0=1270.46 + dfx + npr2(j)*df
-            else
-               f0=1270.46 + dfx + (1-npr2(j))*df
-            endif
-            f0=f0 + 0.1*idfbest
-            dphi=twopi*dt*f0
-            c1=0.
-            do i=1,1260
-               k=k+1
-               phi=phi+dphi
-               cz=dcmplx(cos(phi),-sin(phi))
-               if(k.le.npts) c1=c1 + dat(k)*cz
-            enddo
-            c1=fac*c1
-            rsym=amp*(real(c1)*real(c0) + aimag(c1)*aimag(c0))
-
-C  NB: It may be possible to track phase.  In that case, remove the 
-C  average phase and then use:
-!            rsym=amp*real(c1)*real(c0)
-
-            ang=atan2(aimag(c1),real(c1))
-            ndang=nint(57.1957795131d0*(ang-ang0))
-            if(ndang.le.-180) ndang=ndang+360
-            if(ndang.gt.180) ndang=ndang-360
-            c0=c1
-            r=rsym+128.
-            if(r.gt.255.0) r=255.0
-            if(r.lt.0.0) r=0.0
-            i4=nint(r)
-            if(i4.gt.127) i4=i4-256
-            if(j.ge.1) symbol(j)=i4
-            ang0=ang
-         enddo
-         go to 50
-      endif
-
-! JT4 mode
-      ich=0
- 40   ich=ich+1
-      nchips=nch(ich)
-      nspchip=1260/nchips
-      k=istart
-      phi=0.d0
-      phi1=0.d0
-      fac2=1.e-8 * sqrt(float(mode4))
-      do j=1,nsym+1
-         if(flip.gt.0.0) then
-            f0=1270.46 + dfx + (npr2(j)-1.5)*mode4*df
-            f1=1270.46 + dfx + (2+npr2(j)-1.5)*mode4*df
-         else
-            f0=1270.46 + dfx + (1-npr2(j)-1.5)*mode4*df
-            f1=1270.46 + dfx + (3-npr2(j)-1.5)*mode4*df
-         endif
-         dphi=twopi*dt*f0
-         dphi1=twopi*dt*f1
-         sq0=0.
-         sq1=0.
-         do nc=1,nchips
-            phi=0.d0
-            phi1=0.d0
-            c0=0.
-            c1=0.
-            do i=1,nspchip
-               k=k+1
-               phi=phi+dphi
-               phi1=phi1+dphi1
-               cz=dcmplx(cos(phi),-sin(phi))
-               cz1=dcmplx(cos(phi1),-sin(phi1))
-               if(k.le.npts) then
-                  c0=c0 + dat(k)*cz
-                  c1=c1 + dat(k)*cz1
-               endif
-            enddo
-            sq0=sq0 + real(c0)**2 + aimag(c0)**2
-            sq1=sq1 + real(c1)**2 + aimag(c1)**2
-         enddo
-         sq0=fac2*sq0
-         sq1=fac2*sq1
-         rsym=amp*(sq1-sq0)
-         r=rsym+128.
-         if(r.gt.255.0) r=255.0
-         if(r.lt.0.0) r=0.0
-         i4=nint(r)
-         if(i4.gt.127) i4=i4-256
-         if(j.ge.1) symbol(j)=i4
-      enddo
-
- 50   nbits=72+31
-      delta=100
-      limit=100000
-      ncycles=0
-      call interleave24(symbol(2),-1)         !Remove the interleaving
-
-C  This is a kludge:
-      iters=1
-      if(mode.eq.6) iters=2
-      do iter=1,iters
-         if(iter.eq.2) then
-            do i=2,207
-               i4=symbol(i)
-               if(i4.lt.0) i4=i4+256
-               i4=255-i4
-               if(i4.gt.127) i4=i4-256
-               symbol(i)=i4
-            enddo
-         endif
-         ncount=fano(metric,ncycles,data1,symbol(2),nbits,mettab,
-     +        delta,limit)
-         if(ncount.ge.0) go to 100
-      enddo
-      if(mode.eq.7 .and. nchips.lt.mode4) go to 40
-
- 100  do i=1,9
-         i4=data1(i)
-         if(i4.lt.0) i4=i4+256
-         data4a(i)=i4
-      enddo
-      call cs_lock('decode24')
-      write(c72,1100) (data4a(i),i=1,9)
- 1100 format(9b8.8)
-      read(c72,1102) data4
- 1102 format(12b6)
-      call cs_unlock
-
-      decoded='                      '
-      if(ncount.ge.0) call unpackmsg(data4,decoded)
-      if(decoded(1:6).eq.'000AAA') then
-         decoded='***WRONG MODE?***'
-         ncount=-1
-      endif
-
-      qual=0.
-      deepmsg='                      '
-
-C  Save symbol spectra for possible decoding of average.
-
-      return
-      end

Deleted: branches/wsjt8a/decode65.f
===================================================================
--- branches/wsjt8a/decode65.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/decode65.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,52 +0,0 @@
-      subroutine decode65(dat,npts,dtx,dfx,flip,ndepth,neme,
-     +  mycall,hiscall,hisgrid,mode65,nafc,decoded,ncount,
-     +  deepmsg,qual)
-
-C  Decodes JT65 data, assuming that DT and DF have already been determined.
-
-      real dat(npts)                        !Raw data
-      real s2(77,126)
-      real s3(64,63)
-      real ftrack(126)
-      character decoded*22,deepmsg*22
-      character mycall*12,hiscall*12,hisgrid*6
-      include 'avecom.h'
-      include 'prcom.h'
-
-      dt=2.0/11025.0                   !Sample interval (2x downsampled data)
-      istart=nint(dtx/dt)              !Start index for synced FFTs
-      nsym=126
-
-C  Compute spectra of the channel symbols
-      f0=1270.46 + dfx
-      call spec2d65(dat,npts,nsym,flip,istart,f0,ftrack,nafc,mode65,s2)
-
-      do j=1,63
-         k=mdat(j)                       !Points to data symbol
-         if(flip.lt.0.0) k=mdat2(j)
-         do i=1,64
-            s3(i,j)=s2(i+7,k)
-         enddo
-      enddo
-      nadd=mode65
-
-      call extract(s3,nadd,ncount,decoded)     !Extract the message
-      qual=0.
-      if(ndepth.ge.1) call deep65(s3,mode65,neme,
-     +    flip,mycall,hiscall,hisgrid,deepmsg,qual)
-
-      if(ncount.lt.0) decoded='                      '
-
-C  Suppress &quot;birdie messages&quot;:
-      if(decoded(1:7).eq.'000AAA ') decoded='                      '
-      if(decoded(1:7).eq.'0L6MWK ') decoded='                      '
-
-C  Save symbol spectra for possible decoding of average.
-      do j=1,63
-         k=mdat(j)
-         if(flip.lt.0.0) k=mdat2(j)
-         call move(s2(8,k),ppsave(1,j,nsave),64)
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/decode6m.f
===================================================================
--- branches/wsjt8a/decode6m.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/decode6m.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,166 +0,0 @@
-      subroutine decode6m(data,jz,cfile6,MinSigdB,istart,
-     +  NFixLen,lcum,f0,lumsg,npkept,yellow)
-
-C  Decode a JT6M message.  Data must start at the beginning of a 
-C  sync symbol; sync frequency is assumed to be f0.
-
-C      parameter (NMAX=30*11025)
-C There must be a better way of doing this 
-C NMAX is overruled in lfp1 to be 1024*1024 which is called from here -db
-C
-      parameter (NMAX=1024*1024)
-      real data(jz)              !Raw data
-      real s2db(0:43,646)        !Spectra of symbols
-c      real s2(128,646)
-      real syncsig(646)
-      real yellow(216)
-      real ref(0:43)
-      logical lcum
-      character*43 pua
-      character*48 msg
-      character*6 cfile6
-      real*8 dpha,twopi
-      complex*16 z,dz
-      complex zz
-      complex ct(0:511)
-      complex c
-      common/hcom/c(NMAX)
-      data pua/'0123456789., /#?$ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
-      data offset/20.6/
-
-      ps(zz)=real(zz)**2 + aimag(zz)**2          !Power spectrum function
-
-C  Convert data to baseband (complex result) using quadrature LO.
-      twopi=8*atan(1.d0)
-      dpha=twopi*f0/11025.d0
-      dz=cmplx(cos(dpha),-sin(dpha))
-      z=1.d0/dz
-      do i=1,jz
-         z=z*dz
-         c(i)=data(i)*z
-      enddo
-
-C  Get spectrum for each symbol.
-C  NB: for decoding pings, could do FFTs first for sync intervals only, 
-C  and then for data symbols only where the sync amplitude is above 
-C  threshold.  However, for the average message we want all FFTs computed.
-
-      call zero(ref,44)
-
-      nz=jz/512 - 1
-      fac=1.0/512.0
-      do j=1,nz        
-         i0=512*(j-1) + 1
-          do i=0,511
-            ct(i)=fac*c(i0+i)
-         enddo
-         call four2a(ct,512,1,-1,1)
-
-C  Save PS for each symbol
-         do i=0,127
-            xps=ps(ct(i))
-            if(i.le.43) s2db(i,j)=xps
-c            s2(i+1,j)=xps
-         enddo
-         if(mod(j,3).eq.1) call add(ref,s2db(0,j),ref,44) !Accumulate ref spec
-      enddo
-
-C  Return sync-tone amplitudes for plotting.
-      iz=nz/3 -1
-      do i=1,iz
-         j=3*i-2
-         yellow(i)=s2db(0,j)-0.5*(s2db(0,j+1)+s2db(0,j+2))
-      enddo
-      yellow(216)=iz
-
-      fac=3.0/nz
-      do i=0,43                               !Normalize the ref spectrum
-         ref(i)=fac*ref(i)
-      enddo
-      ref(0)=ref(2)                           !Sync bin uses bin 2 as ref
-
-      do j=1,nz                               !Compute strength of sync
-         m=mod(j-1,3)                         !signal at each j.
-         ja=j-m-3
-         jb=ja+3
-         if(ja.lt.1) ja=ja+3
-         if(jb.gt.nz) jb=jb-3
-         syncsig(j)=0.5*(s2db(0,ja)+s2db(0,jb))/ref(0)
-         syncsig(j)=db(syncsig(j)) - offset
-         do i=0,43                            !Normalize s2db
-            s2db(i,j)=s2db(i,j)/ref(i)
-         enddo
-      enddo
-
-C  Decode any message of 2 or more consecutive characters bracketed by
-C  sync-tones above a threshold.
-C  Use hard-decoding (i.e., pick max bin).
-
-      nslim=MinSigdB                       !Signal limit for decoding
-      ndf0=nint(f0-1076.77)                !Freq offset DF, in Hz
-      n=0                                  !Number of decoded characters
-      j0=0
-      sbest=-1.e9
-      do j=2,nz-1,3
-         if(syncsig(j).ge.float(nslim)) then
-
-C  Is it time to write out the results?
-            if((n.eq.48) .or. (j.ne.j0+3 .and. j0.ne.0)) then
-               nsig=nint(sbest)
-               width=(512./11025.)*(1.5*n+1.0)
-               if(nsig.ge.nslim) then
-                  npkept=npkept+1
-                  call cs_lock('decode6m')
-                  write(lumsg,1010) cfile6,tping,width,
-     +            nsig,ndf0,(msg(k:k),k=1,n)
-                  if(lcum) write(21,1010) cfile6,tping,width,
-     +              nsig,ndf0,(msg(k:k),k=1,n)
- 1010             format(a6,2f5.1,i4,i5,6x,48a1)       !### 6x was 7x ###
-                  call cs_unlock
-               endif
-               n=0
-               sbest=-1.e9
-            endif
-            j0=j
-            smax1=-1.e9
-            ipk=0 !Shut up compiler warning. -db
-            do i=1,43                         !Pick max bin for 1st char
-               if(s2db(i,j).gt.smax1) then
-                  smax1=s2db(i,j)
-                  ipk=i
-               endif
-            enddo
-            n=n+1
-            if(n.eq.1) tping=j*512./11025. + (istart-1)/11025.0 !Start of ping
-            msg(n:n)=pua(ipk:ipk)                        !Decoded character
-
-            smax2=-1.e9
-            do i=1,43
-               if(s2db(i,j+1).gt.smax2) then
-                  smax2=s2db(i,j+1)
-                  ipk=i
-               endif
-            enddo
-            n=n+1
-            msg(n:n)=pua(ipk:ipk)
-            sig0=10.0**(0.1*(syncsig(j)+offset))
-            sig=db(0.5*sig0 + 0.25*(smax1+smax2))-offset
-            sbest=max(sbest,sig)
-         endif
-      enddo
-
-      nsig=nint(sbest)
-      width=(512./11025.)*(1.5*n+1.0)
-      if(n.ne.0 .and. nsig.ge.nslim) then
-         npkept=npkept+1
-         write(lumsg,1010) cfile6,tping,
-     +     width,nsig,ndf0,(msg(k:k),k=1,n)
-         if(lcum) write(21,1010) cfile6,tping,
-     +     width,nsig,ndf0,(msg(k:k),k=1,n)
-      endif
-
-C  Decode average message for the whole record.
-      call avemsg6m(s2db,nz,nslim,NFixLen,cfile6,lcum,f0,lumsg,npkept)
-
-      return
-      end

Deleted: branches/wsjt8a/deep65.F
===================================================================
--- branches/wsjt8a/deep65.F	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/deep65.F	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,171 +0,0 @@
-      subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,
-     +  hisgrid,decoded,qual)
-
-      parameter (MAXCALLS=7000,MAXRPT=63)
-      real s3(64,63)
-      character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
-      character*12 mycall,hiscall
-      character*22 decoded
-      character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
-      character*15 callgrid(MAXCALLS)
-      character*180 line
-      character*4 rpt(MAXRPT)
-      integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
-!      character*1 cflag
-      character*36 cc
-      integer dgen(12)
-      common/tmp9/ mrs(63),mrs2(63)
-      data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
-#ifdef CVF
-C  This prevents some optimizations that break this subroutine.
-      volatile p1,p2,bias
-#endif
-
-      data neme0/-99/
-      data rpt/'-01','-02','-03','-04','-05',
-     +         '-06','-07','-08','-09','-10',
-     +         '-11','-12','-13','-14','-15',
-     +         '-16','-17','-18','-19','-20',
-     +         '-21','-22','-23','-24','-25',
-     +         '-26','-27','-28','-29','-30',
-     +         'R-01','R-02','R-03','R-04','R-05',
-     +         'R-06','R-07','R-08','R-09','R-10',
-     +         'R-11','R-12','R-13','R-14','R-15',
-     +         'R-16','R-17','R-18','R-19','R-20',
-     +         'R-21','R-22','R-23','R-24','R-25',
-     +         'R-26','R-27','R-28','R-29','R-30',
-     +         'RO','RRR','73'/
-      data iseed/1000000001/,dgen(1)/999/
-      save
-
-      call cs_lock('deep65')
-      rewind 23
-      k=0
-      icall=0
-      do n=1,MAXCALLS
-         if(n.eq.1) then
-            callsign=hiscall
-            do i=4,12
-               if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
-            enddo
-            grid=hisgrid(1:4)
-            if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
-            if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
-         else
-            read(23,1002,end=20) line
- 1002       format (A80)
-            if(line(1:4).eq.'ZZZZ') go to 20
-            if(line(1:2).eq.'//') go to 10
-            i1=index(line,',')
-            if(i1.lt.4) go to 10
-            i2=index(line(i1+1:),',')
-            if(i2.lt.5) go to 10
-            i2=i2+i1
-            i3=index(line(i2+1:),',')
-            if(i3.lt.1) i3=index(line(i2+1:),' ')
-            i3=i2+i3
-            callsign=line(1:i1-1)
-            grid=line(i1+1:i2-1)
-            ceme=line(i2+1:i3-1)
-            if(callsign.eq.hiscall .and. grid.eq.hisgrid(1:4)) go to 10
-            if(neme.eq.1 .and. ceme.ne.'EME') go to 10
-         endif
-
-         icall=icall+1
-         j1=index(mycall,' ') - 1
-         if(j1.le.-1) j1=12
-         if(j1.lt.3) j1=6
-         j2=index(callsign,' ') - 1
-         if(j2.le.-1) j2=12
-         if(j2.lt.3) j2=6
-         j3=index(mycall,'/')
-         j4=index(callsign,'/')
-         callgrid(icall)=callsign(1:j2)
-
-         mz=1
-         if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.
-     +      flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
-C  Test for messages with MyCall + HisCall + report
-         do m=1,mz
-            if(m.gt.1) grid=rpt(m-1)
-            if(j3.lt.1 .and.j4.lt.1) 
-     +         callgrid(icall)=callsign(1:j2)//' '//grid
-            message=mycall(1:j1)//' '//callgrid(icall)
-            k=k+1
-            testmsg(k)=message
-            call encode65(message,ncode(1,k))
-C  Insert CQ message unless sync=OOO (flip=-1).
-            if(m.eq.1 .and. flip.gt.0.0) then
-               message='CQ '//callgrid(icall)
-               k=k+1
-               testmsg(k)=message
-               call encode65(message,ncode(1,k))
-            endif
-         enddo
- 10      continue
-      enddo
- 20   ntot=k
-      call cs_unlock
-      neme0=neme
-
-      ref0=0.
-      do j=1,63
-         ref0=ref0 + s3(mrs(j),j)
-      enddo
-
-      p1=0.
-      p2=0.
-      do k=1,ntot
-         sum=0.
-         ref=ref0
-         do j=1,63
-            i=ncode(j,k)+1
-            sum=sum + s3(i,j)
-            if(i.eq.mrs(j)) then
-               ref=ref - s3(i,j) + s3(mrs2(j),j)
-            endif
-         enddo
-         p=sum/ref
-         if(p.gt.p2) then
-            if(p.gt.p1) then
-               p2=p1
-!               ip2=ip1
-               p1=p
-               ip1=k
-            else
-               p2=p
-!               ip2=k
-            endif
-         endif
-      enddo
-
-      if(mode65.eq.1) bias=max(1.12*p2,0.335)
-      if(mode65.eq.2) bias=max(1.08*p2,0.405)
-      if(mode65.ge.4) bias=max(1.04*p2,0.505)
-      qual=100.0*(p1-bias)
-      if(qual.lt.0.0) qual=0.0
-      decoded='                      '
-      c=' '
-
-      if(qual.gt.1.0) then
-         if(ip1.le.ntot) then
-            if(qual.lt.6.0) c='?'
-            decoded=testmsg(ip1)
-         else
-            i=ip1-ntot-1
-            i1=i/(36**3)
-            i2=(i - i1*36**3)/(36**2)
-            i3=(i - i1*36**3 - i2*36**2)/36
-            i4=mod(i,36)
-            decoded=cc(i1+1:i1+1)//cc(i2+1:i2+1)//cc(i3+1:i3+1)//
-     +           cc(i4+1:i4+1)//'                  '
-         endif
-      endif
-      decoded(22:22)=c
-
-C  Neutralize the SM2CEW foolishness
-      call packmsg(decoded,dgen)
-      call unpackmsg(dgen,decoded)
-
-      return
-      end

Deleted: branches/wsjt8a/encode65.f
===================================================================
--- branches/wsjt8a/encode65.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/encode65.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,13 +0,0 @@
-      subroutine encode65(message,sent)
-
-      character message*22
-      integer dgen(12)
-      integer sent(63)
-
-      call packmsg(message,dgen)
-      call rs_encode(dgen,sent)
-      call interleave63(sent,1)
-      call graycode(sent,63,1)
-
-      return
-      end

Deleted: branches/wsjt8a/gen24.f
===================================================================
--- branches/wsjt8a/gen24.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/gen24.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,117 +0,0 @@
-      subroutine gen24(message,mode,mode4,samfac,ntxdf,ndebug,
-     +    iwave,nwave,sendingsh,msgsent,nmsg)
-
-C  Encodes a JT2 or JT4 message into a wavefile.
-
-      parameter (NMAX=60*11025)     !Max length of wave file
-      character*22 message          !Message to be generated
-      character*22 msgsent          !Message as it will be received
-      character*3 cok               !'   ' or 'OOO'
-      character*6 mode
-      real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,samfac,tsymbol
-      integer*2 iwave(NMAX)         !Generated wave file
-      integer sendingsh
-      integer dgen(13)
-      integer*1 data0(13),symbol(216)
-      logical first
-      include 'prcom2.f'
-      data first/.true./
-      save
-
-      nsym=207                               !Symbols per transmission
-      if(first) then
-         do i=1,nsym
-            pr2(i)=2*npr2(i)-1
-         enddo
-         pi=4.d0*atan(1.d0)
-         twopi=2.d0*pi
-         first=.false.
-      endif
-
-      call chkmsg(message,cok,nspecial,flip)
-      call packmsg(message,dgen)  !Pack 72-bit message into 12 six-bit symbols
-      call entail(dgen,data0)
-      call unpackmsg(dgen,msgsent)
-
-      nbytes=(72+31+7)/8
-      call encode(data0,nbytes,symbol(2))    !Convolutional encoding
-      symbol(1)=0                            !Reference phase
-      sendingsh=0
-      if(iand(dgen(10),8).ne.0) sendingsh=-1 !Plain text flag
-      call interleave24(symbol(2),1)         !Apply JT2/JT4 interleaving
-
-      if(ndebug.ne.0) then
-         rewind 51
-         do i=1,nsym
-            write(51,3001) i,symbol(i),npr2(i),npr2(i)+2*symbol(i)
- 3001       format(4i5)
-         enddo
-      endif
-
-C  Set up necessary constants
-      tsymbol=2520.d0/11025.d0
-      dt=1.d0/(samfac*11025.d0)
-      f0=118*11025.d0/1024 + ntxdf
-      dfgen=11025.d0/2520                     !4.375 Hz
-      t=0.d0
-      phi=0.d0
-      j0=0
-      ndata=(nsym*11025.d0*samfac*tsymbol)/2
-      ndata=2*ndata
-      if(mode(1:3).eq.'JT2') then                 !JT2 mode
-         ss=1.0
-         s=0.0
-         u=0.04
-         do i=1,ndata
-            t=t+dt
-            j=int(t/tsymbol) + 1                  !Symbol number, 1-207
-            if(j.ne.j0) then
-               f=f0 + npr2(j)*dfgen
-               if(flip.lt.0.0) f=f0 + (1-npr2(j))*dfgen
-               dphi=twopi*dt*f
-               if(symbol(j).gt.0) ss=-ss
-               j0=j
-            endif
-            phi=phi+dphi
-            s=s + u*(ss-s)
-            iwave(i)=32767.0 * s * sin(phi)
-         enddo
-      else                                        !JT4x mode
-         do i=1,ndata
-            t=t+dt
-            j=int(t/tsymbol) + 1                  !Symbol number, 1-207
-            if(j.ne.j0) then
-               f=f0 + (npr2(j)+2*symbol(j)-1.5) * dfgen * mode4
-               if(flip.lt.0.0) 
-     +              f=f0+((1-npr2(j))+2*symbol(j)-1.5)*dfgen*mode4
-               dphi=twopi*dt*f
-               j0=j
-            endif
-            phi=phi+dphi
-            iwave(i)=32767.0*sin(phi)
-         enddo
-      endif
-
-      do j=1,5512                !Put another 0.5 sec of silence at end
-         i=i+1
-         iwave(i)=0
-      enddo
-      nwave=i
-
-      if(flip.lt.0.0) then
-         do i=22,1,-1
-            if(msgsent(i:i).ne.' ') goto 10
-         enddo
- 10      msgsent=msgsent(1:i)//' OOO'
-      endif
-      do i=22,1,-1
-         if(msgsent(i:i).ne.' ') goto 20
-      enddo
- 20   nmsg=i
-
-!      write(*,3002) (symbol(i),i=1,207)
-! 3002 format(70i1)
-
-      return
-      end
-

Deleted: branches/wsjt8a/gen65.f
===================================================================
--- branches/wsjt8a/gen65.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/gen65.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,91 +0,0 @@
-      subroutine gen65(message,mode65,samfac,ntxdf,ndebug,iwave,nwave,
-     +  sendingsh,msgsent,nmsg)
-
-C  Encodes a JT65 message into a wavefile.
-
-      parameter (NMAX=60*11025)     !Max length of wave file
-      character*22 message          !Message to be generated
-      character*22 msgsent          !Message as it will be received
-      character*3 cok               !'   ' or 'OOO'
-      character*6 c1,c2
-      real*8 t,dt,phi,f,f0,dfgen,dphi,twopi,samfac,tsymbol
-
-      integer*2 iwave(NMAX)  !Generated wave file
-      integer dgen(12)
-      integer sent(63)
-      integer sendingsh
-      common/c1c2/c1,c2
-      include 'prcom.h'
-      data twopi/6.283185307d0/
-      save
-
-      if(abs(pr(1)).ne.1.0) call setup65
-
-      call chkmsg(message,cok,nspecial,flip)
-      if(nspecial.eq.0) then
-         call packmsg(message,dgen)          !Pack message into 72 bits
-         sendingsh=0
-         if(iand(dgen(10),8).ne.0) sendingsh=-1    !Plain text flag
-         call rs_encode(dgen,sent)
-         call interleave63(sent,1)           !Apply interleaving
-         call graycode(sent,63,1)            !Apply Gray code
-         if(ndebug.ne.0) then
-            rewind 51
-            write(51,1050) sent
- 1050       format('Channel symbols, including FEC:'/(i5,20i3))
-         endif
-         tsymbol=4096.d0/11025.d0
-         nsym=126                            !Symbols per transmission
-      else
-         tsymbol=16384.d0/11025.d0
-         nsym=32
-         sendingsh=1                         !Flag for shorthand message
-      endif
-
-C  Set up necessary constants
-      dt=1.0/(samfac*11025.0)
-      f0=118*11025.d0/1024 + ntxdf
-      dfgen=mode65*11025.0/4096.0
-      t=0.d0
-      phi=0.d0
-      k=0
-      j0=0
-      ndata=(nsym*11025.d0*samfac*tsymbol)/2
-      ndata=2*ndata
-      do i=1,ndata
-         t=t+dt
-         j=int(t/tsymbol) + 1                    !Symbol number, 1-126
-         if(j.ne.j0) then
-            f=f0
-            if(nspecial.ne.0 .and. mod(j,2).eq.0) f=f0+10*nspecial*dfgen
-            if(nspecial.eq.0 .and. flip*pr(j).lt.0.0) then
-               k=k+1
-               f=f0+(sent(k)+2)*dfgen
-            endif
-            dphi=twopi*dt*f
-            j0=j
-         endif
-         phi=phi+dphi
-         iwave(i)=32767.0*sin(phi)
-      enddo
-
-      do j=1,5512                !Put another 0.5 sec of silence at end
-         i=i+1
-         iwave(i)=0
-      enddo
-      nwave=i
-      call unpackmsg(dgen,msgsent)
-      if(flip.lt.0.0) then
-         do i=22,1,-1
-            if(msgsent(i:i).ne.' ') goto 10
-         enddo
- 10      msgsent=msgsent(1:i)//' OOO'
-      endif
-      do i=22,1,-1
-         if(msgsent(i:i).ne.' ') goto 20
-      enddo
- 20   nmsg=i
-
-      return
-      end
-

Deleted: branches/wsjt8a/gen6m.f
===================================================================
--- branches/wsjt8a/gen6m.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/gen6m.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,49 +0,0 @@
-      subroutine gen6m(msg,samfac,iwave,nwave)
-
-C  Encodes a message into a wavefile for transmitting JT6M signals.
-
-      parameter (NMAX=21504)     !NMAX=28*512*3/2: number of waveform samples
-      character*28 msg           !Message to be generated
-      real*8 samfac
-      real*4 x(NMAX)             !Data for wavefile
-      integer*2 iwave(NMAX)      !Generated wave file
-      integer*4 imsg(28)
-
-      do i=27,1,-1                           !Get message length
-         if(msg(i:i).ne.' ') go to 10
-      enddo
-      i=1
- 10   nmsg=i+1
-      if(mod(nmsg,2).eq.1) nmsg=nmsg+1       !Make it even
-
-      nwave=nmsg*512*3/2
-      do m=1,nmsg                            !Get character code numbers
-         ic=m
-         n=ichar(msg(ic:ic))
-C  Calculate i in range 0-42:
-         if(n.ge.ichar('0') .and. n.le.ichar('9')) i=n-ichar('0')
-         if(msg(ic:ic).eq.'.') i=10
-         if(msg(ic:ic).eq.',') i=11
-         if(msg(ic:ic).eq.' ') i=12
-         if(msg(ic:ic).eq.'/') i=13
-         if(msg(ic:ic).eq.'#') i=14
-         if(msg(ic:ic).eq.'?') i=15
-         if(msg(ic:ic).eq.'$') i=16
-         if(n.ge.ichar('a') .and. n.le.ichar('z')) i=n-ichar('a')+17
-         if(n.ge.ichar('A') .and. n.le.ichar('Z')) i=n-ichar('A')+17
-         imsg(m)=i
-      enddo
-
-      k=1
-      do i=1,nmsg,2
-         call gentone(x(k),-1,k,samfac)               !Generate a sync tone
-         call gentone(x(k),imsg(i),k,samfac)          !First character
-         call gentone(x(k),imsg(i+1),k,samfac)        !Second character
-      enddo
-
-      do i=1,nwave
-         iwave(i)=nint(32767.0*x(i))
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/interleave24.f
===================================================================
--- branches/wsjt8a/interleave24.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/interleave24.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,44 +0,0 @@
-      subroutine interleave24(id,ndir)
-      integer*1 id(0:205),itmp(0:205)
-      integer j0(0:205)
-      character*8 c0,c1
-      logical first
-      data first/.true./
-      save first
-
-      if(first) then
-         k=-1
-         do i=0,255
-            m=i
-            n=iand(m,1)
-            n=2*n + iand(m/2,1)
-            n=2*n + iand(m/4,1)
-            n=2*n + iand(m/8,1)
-            n=2*n + iand(m/16,1)
-            n=2*n + iand(m/32,1)
-            n=2*n + iand(m/64,1)
-            n=2*n + iand(m/128,1)
-            if(n.le.205) then
-               k=k+1
-               j0(k)=n
-            endif
-         enddo
-         first=.false.
-      endif
-
-      if(ndir.eq.1) then
-         do i=0,205
-            itmp(j0(i))=id(i)
-         enddo
-      else
-         do i=0,205
-            itmp(i)=id(j0(i))
-         enddo
-      endif
-
-      do i=0,205
-         id(i)=itmp(i)
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/ps24.f
===================================================================
--- branches/wsjt8a/ps24.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/ps24.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,26 +0,0 @@
-      subroutine ps24(dat,nfft,s)
-
-      parameter (NMAX=2520+2)
-      parameter (NHMAX=NMAX/2-1)
-      real dat(nfft)
-      real s(NHMAX)
-      real work(2*NMAX)
-      complex c(0:NMAX)
-
-      nh=nfft/2
-      do i=1,nh
-         c(i-1)=dat(i)/128.0       !### Why 128 ??
-      enddo
-      do i=nh+1,nfft
-         c(i-1)=0.
-      enddo
-
-      call fourt(c,nfft,1,-1,0,work)
-
-      fac=1.0/nfft
-      do i=1,nh
-         s(i)=fac*(real(c(i))**2 + aimag(c(i))**2)
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/setup65.f
===================================================================
--- branches/wsjt8a/setup65.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/setup65.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,108 +0,0 @@
-      subroutine setup65
-
-C  Defines arrays related to the pseudo-random synchronizing pattern.
-C  Executed at program start.
-
-      integer npra(135),nprc(126)
-      include 'prcom.h'
-
-C  JT44
-      data npra/
-     +    1,1,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,0,
-     +    1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,1,
-     +    1,0,0,1,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,0,
-     +    0,0,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,0,1,0,
-     +    1,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,
-     +    1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,0,
-     +    1,1,1,0,1,1,0,1,1,0,1,0,1,1,0/
-
-C  JT65
-      data nprc/
-     + 1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,
-     + 0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,
-     + 0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,
-     + 0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,
-     + 1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,
-     + 0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,
-     + 1,1,1,1,1,1/
-      data mr2/0/                !Silence g77 warning
-
-C  Put the appropriate pseudo-random sequence into pr
-      nsym=126
-      do i=1,nsym
-         pr(i)=2*nprc(i)-1
-      enddo
-
-C  Determine locations of data and reference symbols
-      k=0
-      mr1=0
-      do i=1,nsym
-         if(pr(i).lt.0.0) then
-            k=k+1
-            mdat(k)=i
-         else
-            mr2=i
-            if(mr1.eq.0) mr1=i
-         endif
-      enddo
-      nsig=k
-
-C  Determine the reference symbols for each data symbol.
-      do k=1,nsig
-         m=mdat(k)
-         mref(k,1)=mr1
-         do n=1,10                     !Get ref symbol before data
-            if((m-n).gt.0) then
-               if (pr(m-n).gt.0.0) go to 10
-            endif
-         enddo
-         go to 12
- 10      mref(k,1)=m-n
- 12      mref(k,2)=mr2
-         do n=1,10                     !Get ref symbol after data
-            if((m+n).le.nsym) then
-               if (pr(m+n).gt.0.0) go to 20
-            endif
-         enddo
-         go to 22
- 20      mref(k,2)=m+n
- 22   continue
-      enddo
-
-C  Now do it all again, using opposite logic on pr(i)
-      k=0
-      mr1=0
-      do i=1,nsym
-         if(pr(i).gt.0.0) then
-            k=k+1
-            mdat2(k)=i
-         else
-            mr2=i
-            if(mr1.eq.0) mr1=i
-         endif
-      enddo
-      nsig=k
-
-      do k=1,nsig
-         m=mdat2(k)
-         mref2(k,1)=mr1
-         do n=1,10
-            if((m-n).gt.0) then
-               if (pr(m-n).lt.0.0) go to 110
-            endif
-         enddo
-         go to 112
- 110      mref2(k,1)=m-n
- 112      mref2(k,2)=mr2
-         do n=1,10
-            if((m+n).le.nsym) then
-               if (pr(m+n).lt.0.0) go to 120
-            endif
-         enddo
-         go to 122
- 120     mref2(k,2)=m+n
- 122  continue
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/short65.f
===================================================================
--- branches/wsjt8a/short65.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/short65.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,191 +0,0 @@
-      subroutine short65(data,jz,NFreeze,MouseDF,DFTolerance,
-     +  mode65,nspecialbest,nstest,dfsh,iderrbest,idriftbest,
-     +  snrdb,ss1a,ss2a,nwsh,idfsh)
-
-C  Checks to see if this might be a shorthand message.
-C  This is done before zapping, downsampling, or normal decoding.
-
-      parameter (NP2=60*11025)               !Size of data array
-      parameter (NFFT=16384)                 !FFT length
-      parameter (NH=NFFT/2)                  !Step size
-      parameter (MAXSTEPS=60*11025/NH)       !Max # of steps
-
-      real data(jz)
-      integer DFTolerance
-      real s2(NH,MAXSTEPS)                   !2d spectrum
-      real ss(NH,4)                          !Save spectra in four phase bins
-      real psavg(NH)
-      real sigmax(4)                         !Peak of spectrum at each phase
-      real ss1a(-224:224)                    !Lower magenta curve
-      real ss2a(-224:224)                    !Upper magenta curve
-      real ss1(-473:1784)                    !Lower magenta curve (temp)
-      real ss2(-473:1784)                    !Upper magenta curve (temp)
-      real ssavg(-11:11)
-      integer ipk(4)                         !Peak bin at each phase
-      save
-
-      nspecialbest=0                         !Default return value
-      nstest=0
-      df=11025.0/NFFT
-
-C  Do 16 k FFTs, stepped by 8k.  (*** Maybe should step by 4k? ***)
-      call zero(psavg,NH)
-      nsteps=(jz-NH)/(4*NH)
-      nsteps=4*nsteps                        !Number of steps
-      do j=1,nsteps
-         k=(j-1)*NH + 1
-         call ps(data(k),NFFT,s2(1,j))       !Get power spectra
-         if(mode65.eq.4) then
-            call smooth(s2(1,j),NH)
-            call smooth(s2(1,j),NH)
-         endif
-         call add(psavg,s2(1,j),psavg,NH)
-      enddo
-
-      call flat1(psavg,s2,NH,nsteps,NH,MAXSTEPS)
-
-      nfac=40*mode65
-      dtstep=0.5/df
-      fac=dtstep/(60.0*df)
-
-C  Define range of frequencies to be searched
-      fa=max(200.0,1270.46+MouseDF-600.0)
-      fb=min(4800.0,1270.46+MouseDF+600.0)
-      ia=fa/df
-      ib=fb/df + 4.1*nfac  !Upper tone is above sync tone by 4*nfac*df Hz
-      if(NFreeze.eq.1) then
-         fa=max(200.0,1270.46+MouseDF-DFTolerance)
-         fb=min(4800.0,1270.46+MouseDF+DFTolerance)
-      endif
-      ia2=fa/df
-      ib2=fb/df + 4.1*nfac  !Upper tone is above sync tone by 4*nfac*df Hz
-      if(ib2.gt.NH) ib2=NH
-
-C  Find strongest line in each of the 4 phases, repeating for each drift rate.
-      sbest=0.
-      snrbest=0.
-      idz=6.0/df                !Is this the right drift range?
-      do idrift=-idz,idz
-         drift=idrift*df*60.0/49.04
-         call zero(ss,4*NH)     !Clear the accumulating array
-         do j=1,nsteps
-            n=mod(j-1,4)+1
-            k=nint((j-nsteps/2)*drift*fac) + ia
-            call add(ss(ia,n),s2(k,j),ss(ia,n),ib-ia+1)
-         enddo
-
-         do n=1,4
-            sigmax(n)=0.
-            do i=ia2,ib2
-               sig=ss(i,n)
-               if(sig.ge.sigmax(n)) then
-                  ipk(n)=i
-                  sigmax(n)=sig
-                  if(sig.ge.sbest) then
-                     sbest=sig
-                     nbest=n
-                  endif
-               endif
-            enddo
-         enddo
-         n2best=nbest+2
-         if(n2best.gt.4) n2best=nbest-2
-         xdf=min(ipk(nbest),ipk(n2best))*df - 1270.46
-         if(NFreeze.eq.1 .and. abs(xdf-mousedf).gt.DFTolerance) goto 10
-
-         idiff=abs(ipk(nbest)-ipk(n2best))
-         xk=float(idiff)/nfac
-         k=nint(xk)
-         iderr=nint((xk-k)*nfac)
-         nspecial=0
-         maxerr=nint(0.008*abs(idiff) + 0.51)
-         if(abs(iderr).le.maxerr .and. k.ge.2 .and. k.le.4) nspecial=k
-         if(nspecial.gt.0) then
-            call getsnr(ss(ia2,nbest),ib2-ia2+1,snr1)
-            call getsnr(ss(ia2,n2best),ib2-ia2+1,snr2)
-            snr=0.5*(snr1+snr2)
-            if(snr.gt.snrbest) then
-               snrbest=snr
-               nspecialbest=nspecial
-               nstest=snr/2.0 - 2.0             !Threshold set here
-               if(nstest.lt.0) nstest=0
-               if(nstest.gt.10) nstest=10
-               dfsh=nint(xdf)
-               iderrbest=iderr
-               idriftbest=idrift
-               snrdb=db(snr) - db(2500.0/df) - db(sqrt(nsteps/4.0))+1.8
-               n1=nbest
-               n2=n2best
-               ipk1=ipk(n1)
-               ipk2=ipk(n2)
-            endif
-         endif
-         if(nstest.eq.0) nspecial=0
- 10   continue
-      enddo
-
-
-      if(nstest.eq.0) nspecialbest=0
-      df4=4.0*df
-      if(nstest.gt.0) then
-
-         if(ipk1.gt.ipk2) then
-            ntmp=n1
-            n1=n2
-            n2=ntmp
-            ntmp=ipk1
-            ipk1=ipk2
-            ipk2=ntmp
-         endif
-
-         call zero(ss1,2258)
-         call zero(ss2,2258)
-         do i=ia2,ib2,4
-            f=df*i
-            k=nint((f-1270.46)/df4)
-            ss1(k)=0.3 * (ss(i-2,n1) + ss(i-1,n1) + ss(i,n1) + 
-     +        ss(i+1,n1) + ss(i+2,n1))
-            ss2(k)=0.3 * (ss(i-2,n2) + ss(i-1,n2) + ss(i,n2) +
-     +        ss(i+1,n2) + ss(i+2,n2))
-         enddo
-
-         kpk1=nint(0.25*ipk1-472.0)
-         kpk2=kpk1 + nspecial*mode65*10
-         ssmax=0.
-         do i=-10,10
-            ssavg(i)=ss1(kpk1+i) + ss2(kpk2+i)
-            if(ssavg(i).gt.ssmax) then
-               ssmax=ssavg(i)
-               itop=i
-            endif
-         enddo
-         base=0.25*(ssavg(-10)+ssavg(-9)+ssavg(9)+ssavg(10))
-         shalf=0.5*(ssmax+base)
-         do k=1,8
-            if(ssavg(itop-k).lt.shalf) go to 110
-         enddo
-         k=8
- 110     x=(ssavg(itop-(k-1))-shalf)/(ssavg(itop-(k-1))-ssavg(itop-k))
-         do k=1,8
-            if(ssavg(itop+k).lt.shalf) go to 120
-         enddo
-         k=8
- 120     x=x+(ssavg(itop+(k-1))-shalf)/(ssavg(itop+(k-1))-ssavg(itop+k))
-         nwsh=nint(x*df4)
-      endif
-
-C  See if orange/magenta curves need to be shifted:
-      idfsh=0
-      if(mousedf.lt.-600) idfsh=-670
-      if(mousedf.gt.600) idfsh=1000
-      if(mousedf.gt.1600) idfsh=2000
-      if(mousedf.gt.2600) idfsh=3000
-      i0=nint(idfsh/df4)
-
-      do i=-224,224
-         ss1a(i)=ss1(i+i0)
-         ss2a(i)=ss2(i+i0)
-      enddo
-
-      return
-      end

Deleted: branches/wsjt8a/sync24.f
===================================================================
--- branches/wsjt8a/sync24.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/sync24.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,194 +0,0 @@
-      subroutine sync24(dat,jz,DFTolerance,NFreeze,MouseDF,
-     +  mode,mode4,dtx,dfx,snrx,snrsync,ccfblue,ccfred1,flip,width)
-
-C  Synchronizes JT2 and JT4 data, finding the best-fit DT and DF.  
-
-      parameter (NFFTMAX=2520)         !Max length of FFTs
-      parameter (NHMAX=NFFTMAX/2)      !Max length of power spectra
-      parameter (NSMAX=525)            !Max number of half-symbol steps
-      integer DFTolerance              !Range of DF search
-      real dat(jz)
-      real psavg(NHMAX)                !Average spectrum of whole record
-      real s2(NHMAX,NSMAX)             !2d spectrum, stepped by half-symbols
-      real ccfblue(-5:540)             !CCF with pseudorandom sequence
-      real ccfred(-450:450)            !Peak of ccfblue, as function of freq
-      real ccfred1(-224:224)           !Peak of ccfblue, as function of freq
-      real tmp(550)
-      save
-
-C  Do FFTs of twice symbol length, stepped by half symbols.  Note that 
-C  we have already downsampled the data by factor of 2.
-
-      nsym=207
-      nfft=2520
-      nh=nfft/2
-      nq=nfft/4
-      nsteps=jz/nq - 1
-      df=0.5*11025.0/nfft
-      call zero(psavg,nh)
-
-C  Compute power spectrum for each step and get average
-      do j=1,nsteps
-         k=(j-1)*nq + 1
-!         call limit(dat(k),nfft)
-         call ps24(dat(k),nfft,s2(1,j))
-!         if(mode65.eq.4) call smooth(s2(1,j),nh)
-         call add(psavg,s2(1,j),psavg,nh)
-      enddo
-
-      call flat1(psavg,s2,nh,nsteps,NHMAX,NSMAX)        !Flatten the spectra
-
-C  Find the best frequency channel for CCF
-!      famin= 670.46
-!      fbmax=1870.46
-      famin=200.
-      fbmax=2700.
-
-      fa=famin
-      fb=fbmax
-      if(NFreeze.eq.1) then
-         fa=max(famin,1270.46+MouseDF-DFTolerance)
-         fb=min(fbmax,1270.46+MouseDF+DFTolerance)
-      else
-         fa=max(famin,1270.46+MouseDF-600)
-         fb=min(fbmax,1270.46+MouseDF+600)
-      endif
-      ia=fa/df
-      ib=fb/df
-      if(mode.eq.7) then
-         ia=ia - 3*mode4
-         ib=ib - 3*mode4
-      endif
-      i0=nint(1270.46/df)
-      lag1=-5
-      lag2=59
-      syncbest=-1.e30
-      syncbest2=-1.e30
-
-      call zero(ccfred,901)
-      do i=ia,ib
-         call xcor24(s2,i,nsteps,nsym,lag1,lag2,mode,mode4,
-     +        ccfblue,ccf0,lagpk0,flip)
-         j=i-i0
-         if(mode.eq.7) j=j + 3*mode4
-         if(j.ge.-372 .and. j.le.372) ccfred(j)=ccf0
-
-C  Find rms of the CCF, without the main peak
-         call slope(ccfblue(lag1),lag2-lag1+1,lagpk0-lag1+1.0)
-         sync=abs(ccfblue(lagpk0))
-         ppmax=psavg(i)-1.0
-
-C  Find the best sync value
-         if(sync.gt.syncbest2) then
-            ipk2=i
-            lagpk2=lagpk0
-            syncbest2=sync
-         endif
-
-C  We are most interested if snrx will be more than -30 dB.
-         if(ppmax.gt.0.2938) then            !Corresponds to snrx.gt.-30.0
-            if(sync.gt.syncbest) then
-               ipk=i
-               lagpk=lagpk0
-               syncbest=sync
-            endif
-         endif
-      enddo
-
-C  If we found nothing with snrx &gt; -30 dB, take the best sync that *was* found.
-      if(syncbest.lt.-10.) then
-         ipk=ipk2
-         lagpk=lagpk2
-         syncbest=syncbest2
-      endif
-
-C  Peak up in frequency to fraction of channel
-!      call peakup(psavg(ipk-1),psavg(ipk),psavg(ipk+1),dx)
-!      if(dx.lt.-1.0) dx=-1.0
-!      if(dx.gt.1.0) dx=1.0
-      dx=0.
-      dfx=(ipk+dx-i0)*df
-      if(mode.eq.7) dfx=dfx + 3*mode4*df
-
-C  Peak up in time, at best whole-channel frequency
-      call xcor24(s2,ipk,nsteps,nsym,lag1,lag2,mode,mode4,
-     +  ccfblue,ccfmax,lagpk,flip)
-      xlag=lagpk
-      if(lagpk.gt.lag1 .and. lagpk.lt.lag2) then
-         call peakup(ccfblue(lagpk-1),ccfmax,ccfblue(lagpk+1),dx2)
-         xlag=lagpk+dx2
-      endif
-
-C  Find rms of the CCF, without the main peak
-      call slope(ccfblue(lag1),lag2-lag1+1,xlag-lag1+1.0)
-      sq=0.
-      nsq=0
-      do lag=lag1,lag2
-         if(abs(lag-xlag).gt.2.0) then
-            sq=sq+ccfblue(lag)**2
-            nsq=nsq+1
-         endif
-      enddo
-      rms=sqrt(sq/nsq)
-      snrsync=abs(ccfblue(lagpk))/rms - 1.1    !Empirical
-
-      dt=2.0/11025.0
-      istart=xlag*nq
-      dtx=istart*dt
-      snrx=-99.0
-      ppmax=psavg(ipk)-1.0
-
-      if(ppmax.gt.0.0001) then
-         snrx=db(ppmax*df/2500.0) + 7.5        !Empirical
-         if(mode.eq.7) snrx=snrx + 3.0         !Empirical
-      endif
-      if(snrx.lt.-33.0) snrx=-33.0
-
-C  Compute width of sync tone to outermost -3 dB points
-!      call pctile(ccfred(ia-i0),tmp,ib-ia+1,45,base)
-!      i1=max(-224,ia-i0)
-!      i2=min(224,ib-i0)
-      i1=max(-450,ia-i0)
-      i2=min(450,ib-i0)
-      call pctile(ccfred(i1),tmp,i2-i1+1,45,base)
-
-      jpk=ipk-i0
-      if(abs(jpk).gt.450) then
-         print*,'sync24 a:',jpk,ipk,i0
-         snrsync=0.
-         go to 999
-      else
-         stest=base + 0.5*(ccfred(jpk)-base) ! -3 dB
-      endif
-      do i=-10,0
-         if(jpk+i.ge.-371) then 
-            if(ccfred(jpk+i).gt.stest) go to 30
-         endif
-      enddo
-      i=0
- 30   continue
-      if(abs(jpk+i-1).gt.450 .or. abs(jpk+i).gt.450) then
-         print*,'sync24 b:',jpk,i
-      else
-         x1=i-1+(stest-ccfred(jpk+i-1))/(ccfred(jpk+i)-ccfred(jpk+i-1))
-      endif
-
-      do i=10,0,-1
-         if(jpk+i.le.371) then
-            if(ccfred(jpk+i).gt.stest) go to 32
-         endif
-      enddo
-      i=0
- 32   x2=i+1-(stest-ccfred(jpk+i+1))/(ccfred(jpk+i)-ccfred(jpk+i+1))
-      width=x2-x1
-      if(width.gt.1.2) width=sqrt(width**2 - 1.44)
-      width=df*width
-      width=max(0.0,min(99.0,width))
-
-      do i=-224,224
-         ccfred1(i)=ccfred(i)
-      enddo
-
- 999  return
-      end
-

Deleted: branches/wsjt8a/sync65.f
===================================================================
--- branches/wsjt8a/sync65.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/sync65.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,175 +0,0 @@
-      subroutine sync65(dat,jz,DFTolerance,NFreeze,MouseDF,
-     +  mode65,dtx,dfx,snrx,snrsync,ccfblue,ccfred1,flip,width)
-
-C  Synchronizes JT65 data, finding the best-fit DT and DF.  
-C  NB: at this stage, submodes ABC are processed in the same way.
-
-      parameter (NP2=60*11025)         !Size of data array
-      parameter (NFFTMAX=2048)         !Max length of FFTs
-      parameter (NHMAX=NFFTMAX/2)      !Max length of power spectra
-      parameter (NSMAX=320)            !Max number of half-symbol steps
-      integer DFTolerance              !Range of DF search
-      real dat(jz)
-      real psavg(NHMAX)                !Average spectrum of whole record
-      real s2(NHMAX,NSMAX)             !2d spectrum, stepped by half-symbols
-      real ccfblue(-5:540)             !CCF with pseudorandom sequence
-
-C  The value 450 is empirical:
-      real ccfred(-450:450)            !Peak of ccfblue, as function of freq
-      real ccfred1(-224:224)           !Peak of ccfblue, as function of freq
-      real tmp(450)
-      save
-
-C  Do FFTs of symbol length, stepped by half symbols.  Note that we have
-C  already downsampled the data by factor of 2.
-      nsym=126
-      nfft=2048
-      nsteps=2*jz/nfft - 1
-      nh=nfft/2
-
-      df=0.5*11025.0/nfft
-C  Compute power spectrum for each step and get average
-      call zero(psavg,nh)
-      do j=1,nsteps
-         k=(j-1)*nh + 1
-         call limit(dat(k),nfft)
-         call ps(dat(k),nfft,s2(1,j))
-         if(mode65.eq.4) call smooth(s2(1,j),nh)
-         call add(psavg,s2(1,j),psavg,nh)
-      enddo
-
-      call flat1(psavg,s2,nh,nsteps,NHMAX,NSMAX)        !Flatten the spectra
-
-C  Find the best frequency channel for CCF
-!      famin= 670.46
-!      fbmax=1870.46
-      famin=3.
-      fbmax=2700.
-
-      fa=famin
-      fb=fbmax
-      if(NFreeze.eq.1) then
-         fa=max(famin,1270.46+MouseDF-DFTolerance)
-         fb=min(fbmax,1270.46+MouseDF+DFTolerance)
-      else
-         fa=max(famin,1270.46+MouseDF-600)
-         fb=min(fbmax,1270.46+MouseDF+600)
-      endif
-      ia=fa/df
-      ib=fb/df
-      i0=nint(1270.46/df)
-      lag1=-5
-      lag2=59
-      syncbest=-1.e30
-      syncbest2=-1.e30
-
-      call zero(ccfred,745)
-      do i=ia,ib
-         call xcor(s2,i,nsteps,nsym,lag1,lag2,
-     +        ccfblue,ccf0,lagpk0,flip,0.0)
-         j=i-i0
-         if(j.ge.-372 .and. j.le.372) ccfred(j)=ccf0
-
-C  Find rms of the CCF, without the main peak
-         call slope(ccfblue(lag1),lag2-lag1+1,lagpk0-lag1+1.0)
-         sync=abs(ccfblue(lagpk0))
-         ppmax=psavg(i)-1.0
-
-C  Find the best sync value
-         if(sync.gt.syncbest2) then
-            ipk2=i
-            lagpk2=lagpk0
-            syncbest2=sync
-         endif
-
-C  We are most interested if snrx will be more than -30 dB.
-         if(ppmax.gt.0.2938) then            !Corresponds to snrx.gt.-30.0
-            if(sync.gt.syncbest) then
-               ipk=i
-               lagpk=lagpk0
-               syncbest=sync
-            endif
-         endif
-      enddo
-
-C  If we found nothing with snrx &gt; -30 dB, take the best sync that *was* found.
-      if(syncbest.lt.-10.) then
-         ipk=ipk2
-         lagpk=lagpk2
-         syncbest=syncbest2
-      endif
-
-C  Peak up in frequency to fraction of channel
-      base=0.25*(psavg(ipk-3)+psavg(ipk-2)+psavg(ipk+2)+psavg(ipk+3))
-!      call peakup(psavg(ipk-1),psavg(ipk),psavg(ipk+1),dx)
-!      if(dx.lt.-1.0) dx=-1.0
-!      if(dx.gt.1.0) dx=1.0
-      dx=0.
-      dfx=(ipk+dx-i0)*df
-
-C  Peak up in time, at best whole-channel frequency
-      call xcor(s2,ipk,nsteps,nsym,lag1,lag2,
-     +  ccfblue,ccfmax,lagpk,flip,0.0)
-      xlag=lagpk
-      if(lagpk.gt.lag1 .and. lagpk.lt.lag2) then
-         call peakup(ccfblue(lagpk-1),ccfmax,ccfblue(lagpk+1),dx2)
-         xlag=lagpk+dx2
-      endif
-
-C  Find rms of the CCF, without the main peak
-      call slope(ccfblue(lag1),lag2-lag1+1,xlag-lag1+1.0)
-      sq=0.
-      nsq=0
-      do lag=lag1,lag2
-         if(abs(lag-xlag).gt.2.0) then
-            sq=sq+ccfblue(lag)**2
-            nsq=nsq+1
-         endif
-      enddo
-      rms=sqrt(sq/nsq)
-      snrsync=abs(ccfblue(lagpk))/rms - 1.1    !Empirical
-
-      dt=2.0/11025.0
-      istart=xlag*nh
-      dtx=istart*dt
-      snrx=-99.0
-!      ppmax=psavg(ipk)/base-1.0
-      ppmax=psavg(ipk)-1.0
-C  Plus 3 dB because sync tone is on half the time.  (Don't understand 
-C  why an additional +2 dB is needed ...)
-      if(ppmax.gt.0.0001) snrx=db(ppmax*df/2500.0) + 5.0    !###
-      if(mode65.eq.4) snrx=snrx + 2.0
-      if(snrx.lt.-33.0) snrx=-33.0
-
-C  Compute width of sync tone to outermost -3 dB points
-      call pctile(ccfred(ia-i0),tmp,ib-ia+1,45,base)
-
-      jpk=ipk-i0
-      stest=base + 0.5*(ccfred(jpk)-base)                ! -3 dB
-      do i=-10,0
-         if(jpk+i.ge.-371) then 
-            if(ccfred(jpk+i).gt.stest) go to 30
-         endif
-      enddo
-      i=0
- 30   x1=i-1+(stest-ccfred(jpk+i-1))/(ccfred(jpk+i)-ccfred(jpk+i-1))
-
-      do i=10,0,-1
-         if(jpk+i.le.371) then
-            if(ccfred(jpk+i).gt.stest) go to 32
-         endif
-      enddo
-      i=0
- 32   x2=i+1-(stest-ccfred(jpk+i+1))/(ccfred(jpk+i)-ccfred(jpk+i+1))
-      width=x2-x1
-      if(width.gt.1.2) width=sqrt(width**2 - 1.44)
-      width=df*width
-      width=max(0.0,min(99.0,width))
-
-      do i=-224,224
-         ccfred1(i)=ccfred(i)
-      enddo
-
-      return
-      end
-

Modified: branches/wsjt8a/wsjt1.F
===================================================================
--- branches/wsjt8a/wsjt1.F	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/wsjt1.F	2009-09-10 19:07:57 UTC (rev 1327)
@@ -166,155 +166,26 @@
         tbest=0.
         NsyncOK=0
 
-!  If we're in JT65 mode, call the decode65 routines.
-        if(mode.eq.2) then
-!          if(rmspower.gt.34000.0) go to 900     !Reject very noisy data
-!  Check for a JT65 shorthand message
-           nstest=0
-           if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
-     +        DFTolerance,mode65,nspecial,nstest,dfsh,iderrsh,
-     +        idriftsh,snrsh,ss1,ss2,nwsh,idfsh)
-!  Lowpass filter and decimate by 2
-           call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
-           idf=mousedf-mousedf2
-           jz=jz2
-           nadd=1
-           fzap(1)=0.
-           if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
-     +       DFTolerance,fzap)
-       if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
 
-           i=index(MyCall,char(0))
-           if(i.le.0) i=index(MyCall,' ')
-           mycall=MyCall(1:i-1)//'            '
-           i=index(HisCall,char(0))
-           if(i.le.0) i=index(HisCall,' ')
-           hiscall=HisCall(1:i-1)//'            '
-
-!  Offset data by about 1 s.
-!           jztest=126*2048
-           jztest=11025*ntdecode/2 - 2755
-           if(jz.ge.jztest) call wsjt65(dat(4097),jz-4096,cfile6,
-     +        NClearAve,MinSigdB,DFTolerance,NFreeze,NAFC,mode65,Nseg,
-     +        MouseDF2,NAgain,ndepth,neme,idf,idfsh,
-     +        mycall,hiscall,hisgrid,lumsg,lcum,nspecial,ndf,
-     +        nstest,dfsh,snrsh,
-     +        NSyncOK,ccf,psavg,ndiag,nwsh)
-           goto 900
-        endif
-
-! If we're in JT6M mode, call the 6M decoding routines.
+! Iscat mode:
         if(mode.eq.4) then
-           do i=1,jz                    !### Why is it level-sensitive?
-              dat(i)=dat(i)/25.0
-           enddo
 ! For waterfall plot
            call spec2d(dat,jz,nstep,s2,nchan,nz,psavg,sigma)
-           if(sigma.lt.0.0) basevb=-99.0
-           if(jz/11025.0.lt.3.9 .or. sigma.lt.0.0) go to 900
-
-           f0=1076.66
-           if(NFreeze.eq.1) f0=1076.66 + MouseDF
-           f00=f0
-           call syncf0(dat,jz,NFreeze,DFTolerance,jstart,f0,smax)
-           call synct(dat,jz,jstart,f0,smax)
-           call syncf1(dat,jz,jstart,f0,NFreeze,DFTolerance,smax,red)
-
-           do i=1,512
-              ccf(i-6)=dB(red(i))
-           enddo
-           df=11025./256.
-           do i=1,64
-              sum=0.
-              do k=8*i-7,8*i
-                 sum=sum+red(k)
-              enddo
-              psavg(i)=5.0*sum
-              fac=1.0
-              freq=i*df
-              if(freq.gt.2500.0) fac=((freq-2500.)/20.0)**(-1.0)
-              psavg(i)=fac*psavg(i)
-              psavg(i+64)=0.001
-           enddo
-
-           jz=jz-jstart+1
-           nslim=MinSigdB
-           NFixLen=0
-
-C  Call the decoder if DF is in range or Freeze is off.
-           if(NFreeze.eq.0 .or. 
-     +         abs(f0-f00).lt.float(DFTolerance)) then
-              call decode6m(dat(jstart),jz,cfile6,nslim,istart,
-     +            NFixLen,lcum,f0,lumsg,npkept,yellow)
-           endif
-
-           if(pick) then
-              do i=1,216
-                 ps0(i)=yellow0(i)
-              enddo
-           else
-              ps0(216)=yellow(216)
-              yellow0(216)=yellow(216)
-              do i=1,215
-                 ps0(i)=2*yellow(i)
-                 yellow0(i)=ps0(i)
-              enddo
-           endif
-           goto 800
         endif
 
-        if(mode.eq.5) then
-!  We're in CW mode.
-!          call decodecw(dat,jz,cfile6,DFTolerance,NFreeze,
-!     +        MouseDF2,mycall,hiscall,hisgrid)
-           go to 900
-        endif
-
-!  If we're in JT2 or JT4 mode, call the decode24 routines.
+! JT8 mode:
         if(mode.eq.6 .or. mode.eq.7) then
-!  Lowpass filter and decimate by 2
-           call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
-           idf=mousedf-mousedf2
-           jz=jz2
-           nadd=1
-           fzap(1)=0.
-           if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
-     +       DFTolerance,fzap)
-      if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
-
-           i=index(MyCall,char(0))
-           if(i.le.0) i=index(MyCall,' ')
-           mycall=MyCall(1:i-1)//'            '
-           i=index(HisCall,char(0))
-           if(i.le.0) i=index(HisCall,' ')
-           hiscall=HisCall(1:i-1)//'            '
-
-!  Offset data by about 1 s.
-           jztest=165000
-           if(jz.ge.jztest) call wsjt24(dat(4097),jz-4096,cfile6,
-     +        NClearAve,MinSigdB,DFTolerance,NFreeze,mode,mode4,
-     +        Nseg,MouseDF2,NAgain,idf,lumsg,lcum,nspecial,ndf,
-     +        NSyncOK,ccf,psavg,ndiag)
            goto 900
         endif
 
-!  If we're in WSPR mode, call the wspr routines.
-        if(mode.eq.8) then
-           i=index(MyCall,char(0))
-           if(i.le.0) i=index(MyCall,' ')
-           mycall=MyCall(1:i-1)//'            '
-           call wsjtwspr(dat,jz,cfile6,ndiag,ccf,psavg)
-           ccf(-5)=-9999.0
-           goto 900
-        endif
-
 !  JT64 mode:
         if(mode.eq.9) then
            mode64=1
            nstest=0
-           if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
-     +        DFTolerance,mode64,nspecial,nstest,dfsh,iderrsh,
-     +        idriftsh,snrsh,ss1,ss2,nwsh,idfsh)
+!           if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
+!     +        DFTolerance,mode64,nspecial,nstest,dfsh,iderrsh,
+!     +        idriftsh,snrsh,ss1,ss2,nwsh,idfsh)
+
 !  Lowpass filter and decimate by 2
            call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
            idf=mousedf-mousedf2
@@ -323,7 +194,7 @@
            fzap(1)=0.
            if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
      +       DFTolerance,fzap)
-      if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
+          if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
 
            i=index(MyCall,char(0))
            if(i.le.0) i=index(MyCall,' ')
@@ -345,7 +216,7 @@
 
         endif
 
-!  We're in FSK441 mode. Compute the 2D spectrum.
+!  We're in JTMS mode. Compute the 2D spectrum.
         df=11025.0/256.0            !FFT resolution ~43 Hz
         dtbuf=nstep/11025.0
         stlim=nslim2                !Single-tone threshold

Deleted: branches/wsjt8a/wsjt24.f
===================================================================
--- branches/wsjt8a/wsjt24.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/wsjt24.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,178 +0,0 @@
-      subroutine wsjt24(dat,npts,cfile6,NClearAve,MinSigdB,
-     +  DFTolerance,NFreeze,mode,mode4,Nseg,MouseDF,NAgain,
-     +  idf,lumsg,lcum,nspecial,ndf,NSyncOK,ccfblue,ccfred,ndiag)
-
-C  Orchestrates the process of decoding JT2 and JT4 messages, using 
-C  data that have been 2x downsampled.  
-
-      real dat(npts)                        !Raw data
-      integer DFTolerance
-      logical first
-      logical lcum
-      character decoded*22,cfile6*6,special*5,cooo*3
-      character*22 avemsg1,avemsg2,deepmsg
-      character*67 line,ave1,ave2
-      character*1 csync,c1
-      character*12 mycall
-      character*12 hiscall
-      character*6 hisgrid
-      real ccfblue(-5:540),ccfred(-224:224)
-      include 'avecom.h'
-      data first/.true./,ns10/0/,ns20/0/
-      save
-
-      mode65=2
-      if(first) then
-         nsave=0
-         first=.false.
-         ave1=' '
-         ave2=' '
-         if(nspecial.eq.999) go to 900        !Silence compiler warning
-      endif
-
-      naggressive=0
-      if(ndepth.ge.2) naggressive=1
-      nq1=3
-      nq2=6
-      if(naggressive.eq.1) nq1=1
-
-      if(NClearAve.ne.0) then
-         nsave=0                        !Clear the averaging accumulators
-         ns10=0
-         ns20=0
-         ave1=' '
-         ave2=' '
-      endif
-      if(MinSigdB.eq.99 .or. MinSigdB.eq.-99) then
-         ns10=0                         !For Include/Exclude ?
-         ns20=0
-      endif
-
-C  Attempt to synchronize: look for sync tone, get DF and DT.
-      call sync24(dat,npts,DFTolerance,NFreeze,MouseDF,mode,
-     +    mode4,dtx,dfx,snrx,snrsync,ccfblue,ccfred,flip,width)
-
-      csync=' '
-      decoded='                      '
-      deepmsg='                      '
-      special='     '
-      cooo='   '
-      ncount=-1             !Flag for RS decode of current record
-      ncount1=-1            !Flag for RS Decode of ave1
-      ncount2=-1            !Flag for RS Decode of ave2
-      NSyncOK=0
-      nqual1=0
-      nqual2=0
-
-      if(nsave.lt.MAXAVE .and. (NAgain.eq.0 .or. NClearAve.eq.1)) 
-     +  nsave=nsave+1
-      if(nsave.le.0) go to 900          !Prevent bounds error
-
-      nflag(nsave)=0                    !Clear the &quot;good sync&quot; flag
-      iseg(nsave)=Nseg                  !Set the RX segment to 1 or 2
-      nsync=nint(snrsync-3.0)
-      nsnr=nint(snrx)
-      if(nsnr.lt.-30 .or. nsync.lt.0) nsync=0
-      nsnrlim=-32
-      if(nsync.lt.MinSigdB .or. nsnr.lt.nsnrlim) go to 200
-
-C  If we get here, we have achieved sync!
-      NSyncOK=1
-      nflag(nsave)=1            !Mark this RX file as good
-      csync='*'
-      if(flip.lt.0.0) then
-         csync='#'
-         cooo='O ?'
-      endif
-
-      call decode24(dat,npts,dtx,dfx,flip,mode,mode4,decoded,
-     +   ncount,deepmsg,qual)
- 200  kvqual=0
-      if(ncount.ge.0) kvqual=1
-      nqual=qual
-      if(ndiag.eq.0 .and. nqual.gt.10) nqual=10
-      if(nqual.ge.nq1 .and.kvqual.eq.0) decoded=deepmsg
-
-      ndf=nint(dfx)
-      if(flip.lt.0.0 .and. (kvqual.eq.1 .or. nqual.ge.nq2)) cooo='OOO'
-      if(kvqual.eq.0.and.nqual.ge.nq1.and.nqual.lt.nq2) cooo(2:3)=' ?'
-      if(decoded.eq.'                      ') cooo='   '
-      do i=1,22
-         c1=decoded(i:i)
-         if(c1.ge.'a' .and. c1.le.'z') decoded(i:i)=char(ichar(c1)-32)
-      enddo
-      jdf=ndf+idf
-
-      call cs_lock('wsjt24')
-      write(line,1010) cfile6,nsync,nsnr,dtx-1.0,jdf,
-     +    nint(width),csync,special,decoded(1:19),cooo,kvqual,nqual
- 1010 format(a6,i3,i5,f5.1,i5,i3,1x,a1,1x,a5,a19,1x,a3,i4,i4)
-
-C  Blank all end-of-line stuff if no decode
-      if(line(31:40).eq.'          ') line=line(:30)
-
-      if(lcum) write(21,1011) line
- 1011 format(a67)
-
-C  Write decoded msg unless this is an &quot;Exclude&quot; request:
-      if(MinSigdB.lt.99) write(lumsg,1011) line
-
-      if(nsave.ge.1) call avemsg65(1,mode65,ndepth,nchallenge,
-     +   avemsg1,nused1,nq1,nq2,neme,mycall,hiscall,hisgrid,qual1,
-     +   ns1,ncount1)
-      if(nsave.ge.1) call avemsg65(2,mode65,ndepth,nchallenge,
-     +   avemsg2,nused2,nq1,nq2,neme,mycall,hiscall,hisgrid,qual2,
-     +   ns2,ncount2)
-      nqual1=qual1
-      nqual2=qual2
-      if(ndiag.eq.0 .and. nqual1.gt.10) nqual1=10
-      if(ndiag.eq.0 .and. nqual2.gt.10) nqual2=10
-      nc1=0
-      nc2=0
-      if(ncount1.ge.0) nc1=1
-      if(ncount2.ge.0) nc2=1
-
-C  Write the average line
-!      if(ns1.ge.1 .and. ns1.ne.ns10) then
-      if(ns1.ge.1) then
-         if(ns1.lt.10) write(ave1,1021) cfile6,1,nused1,ns1,avemsg1,
-     +      nc1,nqual1
- 1021    format(a6,i3,i4,'/',i1,20x,a19,i8,i4)
-         if(ns1.ge.10 .and. nsave.le.99) write(ave1,1022) cfile6,
-     +     1,nused1,ns1,avemsg1,nc1,nqual1
- 1022    format(a6,i3,i4,'/',i2,19x,a19,i8,i4)
-         if(ns1.ge.100) write(ave1,1023) cfile6,1,nused1,ns1,
-     +     avemsg1,nc1,nqual1
- 1023    format(a6,i3,i4,'/',i3,18x,a19,i8,i4)
-         if(lcum .and. (avemsg1.ne.'                  ')) 
-     +      write(21,1011) ave1
-         ns10=ns1
-      endif
-
-C  If Monitor segment #2 is available, write that line also
-!      if(ns2.ge.1 .and. ns2.ne.ns20) then     !***Why the 2nd part?? ***
-      if(ns2.ge.1) then
-         if(ns2.lt.10) write(ave2,1021) cfile6,2,nused2,ns2,avemsg2,
-     +      nc2,nqual2
-         if(ns2.ge.10 .and. nsave.le.99) write(ave2,1022) cfile6,
-     +     2,nused2,ns2,avemsg2,nc2,nqual2
-         if(ns2.ge.100) write(ave2,1023) cfile6,2,nused2,ns2,avemsg2,
-     +     nc2,nqual2
-         if(lcum .and. (avemsg2.ne.'                  ')) 
-     +      write(21,1011) ave2
-         ns20=ns2
-      endif
-
-      if(ave1(31:40).eq.'          ') ave1=ave1(:30)
-      if(ave2(31:40).eq.'          ') ave2=ave2(:30)
-      write(12,1011) ave1
-      write(12,1011) ave2
-      call flushqqq(12)
- 
-      if(lumsg.ne.6) end file 11
-      call cs_unlock
-
- 900  continue
-
-      return
-      end

Deleted: branches/wsjt8a/wsjt65.f
===================================================================
--- branches/wsjt8a/wsjt65.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/wsjt65.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,216 +0,0 @@
-      subroutine wsjt65(dat,npts,cfile6,NClearAve,MinSigdB,
-     +  DFTolerance,NFreeze,NAFC,mode65,Nseg,MouseDF,NAgain,
-     +  ndepth,neme,idf,idfsh,mycall,hiscall,hisgrid,
-     +  lumsg,lcum,nspecial,ndf,nstest,dfsh,
-     +  snrsh,NSyncOK,ccfblue,ccfred,ndiag,nwsh)
-
-C  Orchestrates the process of decoding JT65 messages, using data that
-C  have been 2x downsampled.  The search for shorthand messages has
-C  already been done.
-
-      real dat(npts)                        !Raw data
-      integer DFTolerance
-      logical first
-      logical lcum
-      character decoded*22,cfile6*6,special*5,cooo*3
-      character*22 avemsg1,avemsg2,deepmsg
-      character*67 line,ave1,ave2
-      character*1 csync,c1
-      character*12 mycall
-      character*12 hiscall
-      character*6 hisgrid
-      real ccfblue(-5:540),ccfred(-224:224)
-      integer itf(2,9)
-      include 'avecom.h'
-      data first/.true./,ns10/0/,ns20/0/
-      data itf/0,0, 1,0, -1,0, 0,-1, 0,1, 1,-1, 1,1, -1,-1, -1,1/
-      save
-
-      if(first) then
-         call setup65                   !Initialize pseudo-random arrays
-         nsave=0
-         first=.false.
-         ave1=' '
-         ave2=' '
-      endif
-
-      naggressive=0
-      if(ndepth.ge.2) naggressive=1
-      nq1=3
-      nq2=6
-      if(naggressive.eq.1) nq1=1
-
-      if(NClearAve.ne.0) then
-         nsave=0                        !Clear the averaging accumulators
-         ns10=0
-         ns20=0
-         ave1=' '
-         ave2=' '
-      endif
-      if(MinSigdB.eq.99 .or. MinSigdB.eq.-99) then
-         ns10=0                         !For Include/Exclude ?
-         ns20=0
-      endif
-
-C  Attempt to synchronize: look for sync tone, get DF and DT.
-      call sync65(dat,npts,DFTolerance,NFreeze,MouseDF,
-     +    mode65,dtx,dfx,snrx,snrsync,ccfblue,ccfred,flip,width)
-      csync=' '
-      decoded='                      '
-      deepmsg='                      '
-      special='     '
-      cooo='   '
-      ncount=-1             !Flag for RS decode of current record
-      ncount1=-1            !Flag for RS Decode of ave1
-      ncount2=-1            !Flag for RS Decode of ave2
-      NSyncOK=0
-      nqual1=0
-      nqual2=0
-
-      if(nsave.lt.MAXAVE .and. (NAgain.eq.0 .or. NClearAve.eq.1)) 
-     +  nsave=nsave+1
-      if(nsave.le.0) go to 900          !Prevent bounds error
-
-      nflag(nsave)=0                    !Clear the &quot;good sync&quot; flag
-      iseg(nsave)=Nseg                  !Set the RX segment to 1 or 2
-      nsync=nint(snrsync-3.0)
-      nsnr=nint(snrx)
-      if(nsnr.lt.-30 .or. nsync.lt.0) nsync=0
-      nsnrlim=-32
-
-C  Good Sync takes precedence over a shorthand message:
-      if(nsync.ge.MinSigdB .and. nsnr.ge.nsnrlim .and.
-     +   nsync.ge.nstest) nstest=0
-
-      if(nstest.gt.0) then
-         dfx=dfsh
-         nsync=nstest
-         nsnr=snrsh
-         dtx=1.
-         ccfblue(-5)=-999.0
-         if(nspecial.eq.1) special='ATT  '
-         if(nspecial.eq.2) special='RO   '
-         if(nspecial.eq.3) special='RRR  '
-         if(nspecial.eq.4) special='73   '
-         NSyncOK=1              !Mark this RX file as good (for &quot;Save Decoded&quot;)
-         if(NFreeze.eq.0 .or. DFTolerance.ge.200) special(5:5)='?'
-         width=nwsh
-         idf=idfsh
-         go to 200
-      endif
-
-      if(nsync.lt.MinSigdB .or. nsnr.lt.nsnrlim) go to 200
-
-C  If we get here, we have achieved sync!
-      NSyncOK=1
-      nflag(nsave)=1            !Mark this RX file as good
-      csync='*'
-      if(flip.lt.0.0) then
-         csync='#'
-         cooo='O ?'
-      endif
-
-      call decode65(dat,npts,dtx,dfx,flip,ndepth,neme,
-     +   mycall,hiscall,hisgrid,mode65,nafc,decoded,
-     +   ncount,deepmsg,qual)
-      if(ncount.eq.-999) qual=0                 !Bad data
- 200  kvqual=0
-      if(ncount.ge.0) kvqual=1
-      nqual=qual
-      if(ndiag.eq.0 .and. nqual.gt.10) nqual=10
-      if(nqual.ge.nq1 .and.kvqual.eq.0) decoded=deepmsg
-
-      ndf=nint(dfx)
-      if(flip.lt.0.0 .and. (kvqual.eq.1 .or. nqual.ge.nq2)) cooo='OOO'
-      if(kvqual.eq.0.and.nqual.ge.nq1.and.nqual.lt.nq2) cooo(2:3)=' ?'
-      if(decoded.eq.'                      ') cooo='   '
-      do i=1,22
-         c1=decoded(i:i)
-         if(c1.ge.'a' .and. c1.le.'z') decoded(i:i)=char(ichar(c1)-32)
-      enddo
-      jdf=ndf+idf
-      if(nstest.gt.0) jdf=ndf
-
-      call cs_lock('wsjt65')
-      write(line,1010) cfile6,nsync,nsnr,dtx-1.0,jdf,
-     +    nint(width),csync,special,decoded(1:19),cooo,kvqual,nqual
- 1010 format(a6,i3,i5,f5.1,i5,i3,1x,a1,1x,a5,a19,1x,a3,i4,i4)
-
-C  Blank all end-of-line stuff if no decode
-      if(line(31:40).eq.'          ') line=line(:30)
-
-C  Blank DT if shorthand message  (### wrong logic? ###)
-      if(special.ne.'     ') then
-         line(15:19)='     '
-         line=line(:35)
-          ccfblue(-5)=-9999.0
-      else
-         nspecial=0
-      endif
-
-      if(lcum) write(21,1011) line
- 1011 format(a67)
-C  Write decoded msg unless this is an &quot;Exclude&quot; request:
-      if(MinSigdB.lt.99) write(lumsg,1011) line
-      call cs_unlock
-
-      if(nsave.ge.1) call avemsg65(1,mode65,ndepth,nchallenge,
-     +   avemsg1,nused1,nq1,nq2,neme,mycall,hiscall,hisgrid,qual1,
-     +   ns1,ncount1)
-      if(nsave.ge.1) call avemsg65(2,mode65,ndepth,nchallenge,
-     +   avemsg2,nused2,nq1,nq2,neme,mycall,hiscall,hisgrid,qual2,
-     +   ns2,ncount2)
-      nqual1=qual1
-      nqual2=qual2
-      if(ndiag.eq.0 .and. nqual1.gt.10) nqual1=10
-      if(ndiag.eq.0 .and. nqual2.gt.10) nqual2=10
-      nc1=0
-      nc2=0
-      if(ncount1.ge.0) nc1=1
-      if(ncount2.ge.0) nc2=1
-
-C  Write the average line
-!      if(ns1.ge.1 .and. ns1.ne.ns10) then
-      if(ns1.ge.1) then
-         call cs_lock('wsjt65')
-         if(ns1.lt.10) write(ave1,1021) cfile6,1,nused1,ns1,avemsg1,
-     +      nc1,nqual1
- 1021    format(a6,i3,i4,'/',i1,20x,a19,i8,i4)
-         if(ns1.ge.10 .and. nsave.le.99) write(ave1,1022) cfile6,
-     +     1,nused1,ns1,avemsg1,nc1,nqual1
- 1022    format(a6,i3,i4,'/',i2,19x,a19,i8,i4)
-         if(ns1.ge.100) write(ave1,1023) cfile6,1,nused1,ns1,
-     +     avemsg1,nc1,nqual1
- 1023    format(a6,i3,i4,'/',i3,18x,a19,i8,i4)
-         if(lcum .and. (avemsg1.ne.'                  ')) 
-     +      write(21,1011) ave1
-         ns10=ns1
-         call cs_unlock
-      endif
-
-C  If Monitor segment #2 is available, write that line also
-!      if(ns2.ge.1 .and. ns2.ne.ns20) then     !***Why the 2nd part?? ***
-      if(ns2.ge.1) then
-         if(ns2.lt.10) write(ave2,1021) cfile6,2,nused2,ns2,avemsg2,
-     +      nc2,nqual2
-         if(ns2.ge.10 .and. nsave.le.99) write(ave2,1022) cfile6,
-     +     2,nused2,ns2,avemsg2,nc2,nqual2
-         if(ns2.ge.100) write(ave2,1023) cfile6,2,nused2,ns2,avemsg2,
-     +     nc2,nqual2
-         if(lcum .and. (avemsg2.ne.'                  ')) 
-     +      write(21,1011) ave2
-         ns20=ns2
-      endif
-
-      if(ave1(31:40).eq.'          ') ave1=ave1(:30)
-      if(ave2(31:40).eq.'          ') ave2=ave2(:30)
-      write(12,1011) ave1
-      write(12,1011) ave2
-      call flushqqq(12)
- 
-      if(lumsg.ne.6) end file 11
-
- 900  continue
-
-      return
-      end

Modified: branches/wsjt8a/wsjtgen.F90
===================================================================
--- branches/wsjt8a/wsjtgen.F90	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/wsjtgen.F90	2009-09-10 19:07:57 UTC (rev 1327)
@@ -118,51 +118,35 @@
   dt=1.d0/fsample_out
   LTone=2
 
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or.                  &amp;
-       mode(1:3).eq.'JT4' .or. mode(1:4).eq.'WSPR' .or.                &amp;
-       mode(1:4).eq.'JT64') then
+  if(mode(1:4).eq.'JT64') then
+     mode64=1
+     call gen64(msg,mode64,samfacout,ntxdf,iwave,nwave,sendingsh,   &amp;
+          msgsent,nmsg0)
+  else
+     print*,'Unknown Tx mode requested.'
+!     stop 'Unknown Tx mode requested.'
+  endif
 
-     if(mode(1:4).eq.'JT65') then
-!  We're in JT65 mode.
-        if(mode(5:5).eq.'A') mode65=1
-        if(mode(5:5).eq.'B') mode65=2
-        if(mode(5:5).eq.'C') mode65=4
-        call gen65(msg,mode65,samfacout,ntxdf,ndebug,iwave,nwave,sendingsh,   &amp;
-             msgsent,nmsg0)
-     else if(mode(1:4).eq.'WSPR') then
-        call genwspr(msg,samfacout,ntxdf,iwave,nwave,sendingsh,msgsent)
-     else if(mode(1:3).eq.'JT2' .or. mode(1:3).eq.'JT4' ) then
-        call gen24(msg,mode,mode4,samfacout,ntxdf,ndebug,iwave,nwave,      &amp;
-             sendingsh,msgsent,nmsg0)
-     else if(mode(1:4).eq.'JT64') then
-        mode64=1
-        call gen64(msg,mode64,samfacout,ntxdf,iwave,nwave,sendingsh,   &amp;
-             msgsent,nmsg0)
-     else
-        stop 'Unknown Tx mode requested.'
-     endif
-
-     if(lcwid) then
+  if(lcwid) then
 !  Generate and insert the CW ID.
-        wpm=25.
-        freqcw=800.
-        idmsg=MyCall//'          '
-        call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
-        k=nwave
-        do i=1,ncwid
-           k=k+1
-           iwave(k)=icwid(i)
-        enddo
-        do i=1,2205                   !Add 0.2 s of silence
-           k=k+1
-           iwave(k)=0
-        enddo
-        nwave=k
-     endif
-
-     goto 900
+     wpm=25.
+     freqcw=800.
+     idmsg=MyCall//'          '
+     call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
+     k=nwave
+     do i=1,ncwid
+        k=k+1
+        iwave(k)=icwid(i)
+     enddo
+     do i=1,2205                   !Add 0.2 s of silence
+        k=k+1
+        iwave(k)=0
+     enddo
+     nwave=k
   endif
 
+  goto 900
+
   if(mode(1:4).eq.'Echo') then
 !  We're in Echo mode.
 !     dither=AmpA
@@ -170,65 +154,6 @@
 !     AmpB=f1
      goto 900
   endif
-
-  if(mode(1:4).eq.'JT6M') then
-!  We're in JT6M mode.
-     call gen6m(msg,samfacout,iwave,nwave)
-     goto 900
-  endif
-
-  if(mode(1:2).eq.'CW') then
-!  We're in CW mode
-!     wpm=15.
-     wpm=17.
-     freqcw=800.
-     call gencw(msg,wpm,freqcw,samfacout,iwave,nwave)
-     goto 900
-  endif
-
-!  We're in FSK441 mode.
-  if(nmsg.lt.28) nmsg=nmsg+1          !Add trailing blank if nmsg &lt; 28
-
-!  Check for shorthand messages
-  sendingsh = 0
-  if(shok.eq.1 .and. nmsg.le.4) then
-     if (msg(1:3).eq.'R26') then
-        msg='++'
-        nmsg=2
-        sendingsh = 1
-     else if (msg(1:3).eq.'R27') then
-        msg='**'
-        nmsg=2
-        sendingsh = 1
-     else if (msg(1:3).eq.'RRR') then
-        msg='%%'
-        nmsg=2
-        sendingsh = 1
-     else if (msg(1:2).eq.'73') then
-        msg='@@'
-        nmsg=2
-        sendingsh = 1
-     endif
-  endif
-
-!  Encode the message
-  call abc441(msg,nmsg,itone,ndits)
-  ndata=ndits*nspd
-
-! Generate iwave
-  k=0
-  df=11025.0/NSPD
-  pha=0.
-  do m=1,ndits
-     freq=(LTone-1+itone(m))*df
-     dpha=twopi*freq*dt
-     do i=1,NSPD
-        k=k+1
-        pha=pha+dpha
-        iwave(k)=nint(32767.0*sin(pha))
-     enddo
-  enddo
-  nwave=k
   
 900 sending=txmsg
   if((mode(1:4).eq.'JT65' .or. mode(1:4).eq.'JT64' .or. &amp;

Deleted: branches/wsjt8a/xcor24.f
===================================================================
--- branches/wsjt8a/xcor24.f	2009-09-10 18:36:50 UTC (rev 1326)
+++ branches/wsjt8a/xcor24.f	2009-09-10 19:07:57 UTC (rev 1327)
@@ -1,101 +0,0 @@
-      subroutine xcor24(s2,ipk,nsteps,nsym,lag1,lag2,mode,mode4,
-     +  ccf,ccf0,lagpk,flip)
-
-C  Computes ccf of a row of s2 and the pseudo-random array pr2.  Returns
-C  peak of the CCF and the lag at which peak occurs.  For JT65, the 
-C  CCF peak may be either positive or negative, with negative implying
-C  the &quot;OOO&quot; message.
-
-      parameter (NHMAX=1260)           !Max length of power spectra
-      parameter (NSMAX=525)            !Max number of half-symbol steps
-      real s2(NHMAX,NSMAX)             !2d spectrum, stepped by half-symbols
-      real a(NSMAX)
-      real ccf(-5:540)
-      integer npr2(207)
-      real pr2(207)
-      logical first
-      common/clipcom/ nclip
-      data lagmin/0/                    !Silence g77 warning
-      data first/.true./
-      data npr2/
-     +  0,0,0,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,1,1,0,0,
-     +  0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,
-     +  1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,0,0,1,
-     +  0,0,0,1,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,
-     +  0,1,1,1,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,0,1,1,0,0,0,1,1,1,
-     +  0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,1,1,
-     +  1,0,0,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1/
-      save
-
-      if(first) then
-         do i=1,207
-            pr2(i)=2*npr2(i)-1
-         enddo
-         first=.false.
-      endif
-
-      do j=1,nsteps
-         if(mode.eq.6) then
-            a(j)=s2(ipk+2,j) - s2(ipk,j)             !JT2
-         else                                        !JT4
-            n=2*mode4
-            if(mode4.eq.1) then
-               a(j)=max(s2(ipk+n,j),s2(ipk+3*n,j)) - 
-     +              max(s2(ipk  ,j),s2(ipk+2*n,j))
-            else
-               kz=mode4/2
-               ss0=0.
-               ss1=0.
-               ss2=0.
-               ss3=0.
-               wsum=0.
-               do k=-kz+1,kz-1
-                  w=float(kz-iabs(k))/mode4
-                  wsum=wsum+w
-                  if(ipk+k.lt.1 .or. ipk+3*n+k.gt.1260) then
-                     print*,'xcor24:',ipk,n,k
-                  else
-                     ss0=ss0 + w*s2(ipk    +k,j)
-                     ss1=ss1 + w*s2(ipk+  n+k,j)
-                     ss2=ss2 + w*s2(ipk+2*n+k,j)
-                     ss3=ss3 + w*s2(ipk+3*n+k,j)
-                  endif
-               enddo
-               a(j)=(max(ss1,ss3) - max(ss0,ss2))/sqrt(wsum)
-            endif
-         endif
-      enddo
-
-      ccfmax=0.
-      ccfmin=0.
-      do lag=lag1,lag2
-         x=0.
-         do i=1,nsym
-            j=2*i-1+lag
-            if(j.ge.1 .and. j.le.nsteps) x=x+a(j)*pr2(i)
-         enddo
-         ccf(lag)=2*x                        !The 2 is for plotting scale
-         if(ccf(lag).gt.ccfmax) then
-            ccfmax=ccf(lag)
-            lagpk=lag
-         endif
-
-         if(ccf(lag).lt.ccfmin) then
-            ccfmin=ccf(lag)
-            lagmin=lag
-         endif
-      enddo
-
-      ccf0=ccfmax
-      flip=1.0
-      if(-ccfmin.gt.ccfmax) then
-         do lag=lag1,lag2
-            ccf(lag)=-ccf(lag)
-         enddo
-         lagpk=lagmin
-         ccf0=-ccfmin
-         flip=-1.0
-      endif
-
-      return
-      end


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001020.html">[WSJT-SVN] r1326 - branches/wsjt8a
</A></li>
	<LI>Next message: <A HREF="001022.html">[WSJT-SVN] r1328 - branches/wsjt8a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1021">[ date ]</a>
              <a href="thread.html#1021">[ thread ]</a>
              <a href="subject.html#1021">[ subject ]</a>
              <a href="author.html#1021">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
