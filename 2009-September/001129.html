<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r1438 - branches/wsjt8a
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1438%20-%20branches/wsjt8a&In-Reply-To=%3C200909281430.n8SEUUmu019866%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001128.html">
   <LINK REL="Next"  HREF="001130.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r1438 - branches/wsjt8a</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1438%20-%20branches/wsjt8a&In-Reply-To=%3C200909281430.n8SEUUmu019866%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r1438 - branches/wsjt8a">k1jt at mail.berlios.de
       </A><BR>
    <I>Mon Sep 28 16:30:30 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001128.html">[WSJT-SVN] r1437 - branches/wsjt8a
</A></li>
        <LI>Next message: <A HREF="001130.html">[WSJT-SVN] r1439 - branches/wsjt8a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1129">[ date ]</a>
              <a href="thread.html#1129">[ thread ]</a>
              <a href="subject.html#1129">[ subject ]</a>
              <a href="author.html#1129">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2009-09-28 16:30:25 +0200 (Mon, 28 Sep 2009)
New Revision: 1438

Added:
   branches/wsjt8a/four2a.f
   branches/wsjt8a/sec_midn.F90
Removed:
   branches/wsjt8a/four2.f
   branches/wsjt8a/fourt.f
   branches/wsjt8a/ps64.f
Modified:
   branches/wsjt8a/Makefile.CVF
   branches/wsjt8a/Makefile.in
   branches/wsjt8a/int.h
   branches/wsjt8a/sync64.f
Log:
Corrected int.h
All FFTs now done with FFTW.


Modified: branches/wsjt8a/Makefile.CVF
===================================================================
--- branches/wsjt8a/Makefile.CVF	2009-09-27 19:25:26 UTC (rev 1437)
+++ branches/wsjt8a/Makefile.CVF	2009-09-28 14:30:25 UTC (rev 1438)
@@ -26,13 +26,12 @@
 	pk30.f90 pk48.f90 pk78.f90 pkcall.f90 unpkcall.f90 \
 	pkgrid.f90 unpkgrid.f90 pkpfx.f90 unpkpfx.f90 \
 	pktext.f90 unpktext.f90 msgtrim.f90 genms.f90 geniscat.f90 \
-	genjt8.f90
+	genjt8.f90 sec_midn.F90
 
 SRCS2F77 = wsjt1.f avesp2.f bzap.f spec441.f spec2d.f \
 	indexx.f s2shape.f flat2.f packbits.f unpackbits.f \
-	set.f flatten.f db.f pctile.f sort.f ssort.f ps.f ps64.f \
-	smooth.f sync.f demod64a.f \
-	four2.f fourt.f gencwid.f msgtype.f \
+	set.f flatten.f db.f pctile.f sort.f ssort.f ps.f \
+	smooth.f sync.f demod64a.f four2a.f gencwid.f msgtype.f \
 	limit.f lpf1.f morse.f nchar.f packcall.f packgrid.f \
 	packtext.f spec2d65.f ftpeak65.f \
 	fil651.f fil652.f fil653.f symsync65.f \

Modified: branches/wsjt8a/Makefile.in
===================================================================
--- branches/wsjt8a/Makefile.in	2009-09-27 19:25:26 UTC (rev 1437)
+++ branches/wsjt8a/Makefile.in	2009-09-28 14:30:25 UTC (rev 1438)
@@ -63,7 +63,7 @@
 	unpkcall.f90 unpkgrid.f90 unpktext.f90 \
 	pk30.f90 pk48.f90 pk78.f90 pkpfx.f90 unpkpfx.f90 \
 	hash.f90 chenc.f90 chdec.f90 genms.f90 geniscat.f90 \
-	genjt8.f90
+	genjt8.f90 sec_midn.F90
 
 OBJS2F90 = ${SRCS2F90:.f90=.o}
 
@@ -71,8 +71,8 @@
 	dot.f ftsky.f geocentric.f GeoDist.f grid2deg.f moon2.f \
 	MoonDop.f sun.f toxyz.f bzap.f spec441.f spec2d.f avesp2.f \
         indexx.f s2shape.f gentone.f packbits.f unpackbits.f \
-        set.f flatten.f db.f pctile.f sort.f ssort.f ps.f ps64.f \
-	smooth.f sync.f demod64a.f flat2.f four2.f fourt.f \
+        set.f flatten.f db.f pctile.f sort.f ssort.f ps.f \
+	smooth.f sync.f demod64a.f flat2.f four2a.f \
         gencwid.f msgtype.f limit.f lpf1.f morse.f \
         nchar.f packcall.f packgrid.f packtext.f spec2d65.f unpackcall.f \
         unpackgrid.f unpacktext.f xfft.f xfft2.f \

Deleted: branches/wsjt8a/four2.f
===================================================================
--- branches/wsjt8a/four2.f	2009-09-27 19:25:26 UTC (rev 1437)
+++ branches/wsjt8a/four2.f	2009-09-28 14:30:25 UTC (rev 1438)
@@ -1,354 +0,0 @@
-      SUBROUTINE FOUR2a (DATA,N,NDIM,ISIGN,IFORM)
-
-C     Cooley-Tukey fast Fourier transform in USASI basic Fortran.
-C     multi-dimensional transform, each dimension a power of two,
-C     complex or real data.
-
-C     TRANSFORM(K1,K2,...) = SUM(DATA(J1,J2,...)*EXP(ISIGN*2*PI*SQRT(-1)
-C     *((J1-1)*(K1-1)/N(1)+(J2-1)*(K2-1)/N(2)+...))), summed for all
-C     J1 and K1 from 1 to N(1), J2 and K2 from 1 TO N(2),
-C     etc, for all NDIM subscripts.  NDIM must be positive and
-C     each N(IDIM) must be a power of two.  ISIGN is +1 or -1.
-C     Let NTOT = N(1)*N(2)*...*N(NDIM).  Then a -1 transform
-C     followed by a +1 one (or vice versa) returns NTOT
-C     times the original data.  
-
-C     IFORM = 1, 0 or -1, as data is
-C     complex, real, or the first half of a complex array.  Transform
-C     values are returned in array DATA.  They are complex, real, or
-C     the first half of a complex array, as IFORM = 1, -1 or 0.
-
-C     The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
-C     by ... will be returned in the same array, now considered to
-C     be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
-C     IFORM = 0 or -1, N(1) must be even, and enough room must be
-C     reserved.  The missing values may be obtained by complex conjuga-
-C     tion.  
-
-C     The reverse transformation of a half complex array dimensioned
-C     N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
-C     to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
-C     The transform will be real and returned to the input array.
-
-C     Running time is proportional to NTOT*LOG2(NTOT), rather than
-C     the naive NTOT**2.  Furthermore, less error is built up.
-
-C     Written by Norman Brenner of MIT Lincoln Laboratory, January 1969.
-C     See IEEE Audio Transactions (June 1967), Special issue on FFT.
-
-      parameter(NMAX=2048*1024)
-      DIMENSION DATA(NMAX), N(1)
-      NTOT=1
-      DO 10 IDIM=1,NDIM
- 10   NTOT=NTOT*N(IDIM)
-      IF (IFORM) 70,20,20
- 20   NREM=NTOT
-      DO 60 IDIM=1,NDIM
-      NREM=NREM/N(IDIM)
-      NPREV=NTOT/(N(IDIM)*NREM)
-      NCURR=N(IDIM)
-      IF (IDIM-1+IFORM) 30,30,40
- 30   NCURR=NCURR/2
- 40   CALL BITRV (DATA,NPREV,NCURR,NREM)
-      CALL COOL2 (DATA,NPREV,NCURR,NREM,ISIGN)
-      IF (IDIM-1+IFORM) 50,50,60
- 50   CALL FIXRL (DATA,N(1),NREM,ISIGN,IFORM)
-      NTOT=(NTOT/N(1))*(N(1)/2+1)
- 60   CONTINUE
-      RETURN
- 70   NTOT=(NTOT/N(1))*(N(1)/2+1)
-      NREM=1
-      DO 100 JDIM=1,NDIM
-      IDIM=NDIM+1-JDIM
-      NCURR=N(IDIM)
-      IF (IDIM-1) 80,80,90
- 80   NCURR=NCURR/2
-      CALL FIXRL (DATA,N(1),NREM,ISIGN,IFORM)
-      NTOT=NTOT/(N(1)/2+1)*N(1)
- 90   NPREV=NTOT/(N(IDIM)*NREM)
-      CALL BITRV (DATA,NPREV,NCURR,NREM)
-      CALL COOL2 (DATA,NPREV,NCURR,NREM,ISIGN)
- 100  NREM=NREM*N(IDIM)
-      RETURN
-      END
-      SUBROUTINE BITRV (DATA,NPREV,N,NREM)
-C     SHUFFLE THE DATA BY BIT REVERSAL.
-C     DIMENSION DATA(NPREV,N,NREM)
-C     COMPLEX DATA
-C     EXCHANGE DATA(J1,J4REV,J5) WITH DATA(J1,J4,J5) FOR ALL J1 FROM 1
-C     TO NPREV, ALL J4 FROM 1 TO N (WHICH MUST BE A POWER OF TWO), AND
-C     ALL J5 FROM 1 TO NREM.  J4REV-1 IS THE BIT REVERSAL OF J4-1.  E.G.
-C     SUPPOSE N = 32.  THEN FOR J4-1 = 10011, J4REV-1 = 11001, ETC.
-      parameter(NMAX=2048*1024)
-      DIMENSION DATA(NMAX)
-      IP0=2
-      IP1=IP0*NPREV
-      IP4=IP1*N
-      IP5=IP4*NREM
-      I4REV=1
-C     I4REV = 1+(J4REV-1)*IP1
-      DO 60 I4=1,IP4,IP1
-C     I4 = 1+(J4-1)*IP1
-      IF (I4-I4REV) 10,30,30
- 10   I1MAX=I4+IP1-IP0
-      DO 20 I1=I4,I1MAX,IP0
-C     I1 = 1+(J1-1)*IP0+(J4-1)*IP1
-      DO 20 I5=I1,IP5,IP4
-C     I5 = 1+(J1-1)*IP0+(J4-1)*IP1+(J5-1)*IP4
-      I5REV=I4REV+I5-I4
-C     I5REV = 1+(J1-1)*IP0+(J4REV-1)*IP1+(J5-1)*IP4
-      TEMPR=DATA(I5)
-      TEMPI=DATA(I5+1)
-      DATA(I5)=DATA(I5REV)
-      DATA(I5+1)=DATA(I5REV+1)
-      DATA(I5REV)=TEMPR
- 20   DATA(I5REV+1)=TEMPI
-C     ADD ONE WITH DOWNWARD CARRY TO THE HIGH ORDER BIT OF J4REV-1.
- 30   IP2=IP4/2
- 40   IF (I4REV-IP2) 60,60,50
- 50   I4REV=I4REV-IP2
-      IP2=IP2/2
-      IF (IP2-IP1) 60,40,40
- 60   I4REV=I4REV+IP2
-      RETURN
-      END
-      SUBROUTINE COOL2 (DATA,NPREV,N,NREM,ISIGN)
-C     DISCRETE FOURIER TRANSFORM OF LENGTH N.  IN-PLACE COOLEY-TUKEY
-C     ALGORITHM, BIT-REVERSED TO NORMAL ORDER, SANDE-TUKEY PHASE SHIFTS.
-C     DIMENSION DATA(NPREV,N,NREM)
-C     COMPLEX DATA
-C     DATA(J1,K4,J5) = SUM(DATA(J1,J4,J5)*EXP(ISIGN*2*PI*I*(J4-1)*
-C     (K4-1)/N)), SUMMED OVER J4 = 1 TO N FOR ALL J1 FROM 1 TO NPREV,
-C     K4 FROM 1 TO N AND J5 FROM 1 TO NREM.  N MUST BE A POWER OF TWO.
-C     METHOD--LET IPREV TAKE THE VALUES 1, 2 OR 4, 4 OR 8, ..., N/16,
-C     N/4, N.  THE CHOICE BETWEEN 2 OR 4, ETC., DEPENDS ON WHETHER N IS
-C     A POWER OF FOUR.  DEFINE IFACT = 2 OR 4, THE NEXT FACTOR THAT
-C     IPREV MUST TAKE, AND IREM = N/(IFACT*IPREV).  THEN--
-C     DIMENSION DATA(NPREV,IPREV,IFACT,IREM,NREM)
-C     COMPLEX DATA
-C     DATA(J1,J2,K3,J4,J5) = SUM(DATA(J1,J2,J3,J4,J5)*EXP(ISIGN*2*PI*I*
-C     (K3-1)*((J3-1)/IFACT+(J2-1)/(IFACT*IPREV)))), SUMMED OVER J3 = 1
-C     TO IFACT FOR ALL J1 FROM 1 TO NPREV, J2 FROM 1 TO IPREV, K3 FROM
-C     1 TO IFACT, J4 FROM 1 TO IREM AND J5 FROM 1 TO NREM.  THIS IS
-C     A PHASE-SHIFTED DISCRETE FOURIER TRANSFORM OF LENGTH IFACT.
-C     FACTORING N BY FOURS SAVES ABOUT TWENTY FIVE PERCENT OVER FACTOR-
-C     ING BY TWOS.  DATA MUST BE BIT-REVERSED INITIALLY.
-C     IT IS NOT NECESSARY TO REWRITE THIS SUBROUTINE INTO COMPLEX
-C     NOTATION SO LONG AS THE FORTRAN COMPILER USED STORES REAL AND
-C     IMAGINARY PARTS IN ADJACENT STORAGE LOCATIONS.  IT MUST ALSO
-C     STORE ARRAYS WITH THE FIRST SUBSCRIPT INCREASING FASTEST.
-      parameter(NMAX=2048*1024)
-      DIMENSION DATA(NMAX)
-
-      real*8 twopi,wstpr,wstpi,wr,wi,w2r,w2i,w3r,w3i,wtempr
-
-      w3i=0.
-      w2r=0.
-      w2i=0.
-      w3r=0.
-      TWOPI=6.2831853072*FLOAT(ISIGN)
-      IP0=2
-      IP1=IP0*NPREV
-      IP4=IP1*N
-      IP5=IP4*NREM
-      IP2=IP1
-C     IP2=IP1*IPROD
-      NPART=N
- 10   IF (NPART-2) 60,30,20
- 20   NPART=NPART/4
-      GO TO 10
-C     DO A FOURIER TRANSFORM OF LENGTH TWO
- 30   IF (IP2-IP4) 40,160,160
- 40   IP3=IP2*2
-C     IP3=IP2*IFACT
-      DO 50 I1=1,IP1,IP0
-C     I1 = 1+(J1-1)*IP0
-      DO 50 I5=I1,IP5,IP3
-C     I5 = 1+(J1-1)*IP0+(J4-1)*IP3+(J5-1)*IP4
-      I3A=I5
-      I3B=I3A+IP2
-C     I3 = 1+(J1-1)*IP0+(J2-1)*IP1+(J3-1)*IP2+(J4-1)*IP3+(J5-1)*IP4
-      TEMPR=DATA(I3B)
-      TEMPI=DATA(I3B+1)
-      DATA(I3B)=DATA(I3A)-TEMPR
-      DATA(I3B+1)=DATA(I3A+1)-TEMPI
-      DATA(I3A)=DATA(I3A)+TEMPR
- 50   DATA(I3A+1)=DATA(I3A+1)+TEMPI
-      IP2=IP3
-C     DO A FOURIER TRANSFORM OF LENGTH FOUR (FROM BIT REVERSED ORDER)
- 60   IF (IP2-IP4) 70,160,160
- 70   IP3=IP2*4
-C     IP3=IP2*IFACT
-C     COMPUTE TWOPI THRU WR AND WI IN DOUBLE PRECISION, IF AVAILABLE.
-      THETA=TWOPI/FLOAT(IP3/IP1)
-      SINTH=SIN(THETA/2)
-      WSTPR=-2*SINTH*SINTH
-      WSTPI=SIN(THETA)
-      WR=1.
-      WI=0.
-      DO 150 I2=1,IP2,IP1
-C     I2 = 1+(J2-1)*IP1
-      IF (I2-1) 90,90,80
- 80   W2R=WR*WR-WI*WI
-      W2I=2*WR*WI
-      W3R=W2R*WR-W2I*WI
-      W3I=W2R*WI+W2I*WR
- 90   I1MAX=I2+IP1-IP0
-      DO 140 I1=I2,I1MAX,IP0
-C     I1 = 1+(J1-1)*IP0+(J2-1)*IP1
-      DO 140 I5=I1,IP5,IP3
-C     I5 = 1+(J1-1)*IP0+(J2-1)*IP1+(J4-1)*IP3+(J5-1)*IP4
-      I3A=I5
-      I3B=I3A+IP2
-      I3C=I3B+IP2
-      I3D=I3C+IP2
-C     I3 = 1+(J1-1)*IP0+(J2-1)*IP1+(J3-1)*IP2+(J4-1)*IP3+(J5-1)*IP4
-      IF (I2-1) 110,110,100
-C     APPLY THE PHASE SHIFT FACTORS
- 100  TEMPR=DATA(I3B)
-      DATA(I3B)=W2R*DATA(I3B)-W2I*DATA(I3B+1)
-      DATA(I3B+1)=W2R*DATA(I3B+1)+W2I*TEMPR
-      TEMPR=DATA(I3C)
-      DATA(I3C)=WR*DATA(I3C)-WI*DATA(I3C+1)
-      DATA(I3C+1)=WR*DATA(I3C+1)+WI*TEMPR
-      TEMPR=DATA(I3D)
-      DATA(I3D)=W3R*DATA(I3D)-W3I*DATA(I3D+1)
-      DATA(I3D+1)=W3R*DATA(I3D+1)+W3I*TEMPR
- 110  T0R=DATA(I3A)+DATA(I3B)
-      T0I=DATA(I3A+1)+DATA(I3B+1)
-      T1R=DATA(I3A)-DATA(I3B)
-      T1I=DATA(I3A+1)-DATA(I3B+1)
-      T2R=DATA(I3C)+DATA(I3D)
-      T2I=DATA(I3C+1)+DATA(I3D+1)
-      T3R=DATA(I3C)-DATA(I3D)
-      T3I=DATA(I3C+1)-DATA(I3D+1)
-      DATA(I3A)=T0R+T2R
-      DATA(I3A+1)=T0I+T2I
-      DATA(I3C)=T0R-T2R
-      DATA(I3C+1)=T0I-T2I
-      IF (ISIGN) 120,120,130
- 120  T3R=-T3R
-      T3I=-T3I
- 130  DATA(I3B)=T1R-T3I
-      DATA(I3B+1)=T1I+T3R
-      DATA(I3D)=T1R+T3I
- 140  DATA(I3D+1)=T1I-T3R
-      WTEMPR=WR
-      WR=WSTPR*WTEMPR-WSTPI*WI+WTEMPR
- 150  WI=WSTPR*WI+WSTPI*WTEMPR+WI
-      IP2=IP3
-      GO TO 60
- 160  RETURN
-      END
-      SUBROUTINE FIXRL (DATA,N,NREM,ISIGN,IFORM)
-C     FOR IFORM = 0, CONVERT THE TRANSFORM OF A DOUBLED-UP REAL ARRAY,
-C     CONSIDERED COMPLEX, INTO ITS TRUE TRANSFORM.  SUPPLY ONLY THE
-C     FIRST HALF OF THE COMPLEX TRANSFORM, AS THE SECOND HALF HAS
-C     CONJUGATE SYMMETRY.  FOR IFORM = -1, CONVERT THE FIRST HALF
-C     OF THE TRUE TRANSFORM INTO THE TRANSFORM OF A DOUBLED-UP REAL
-C     ARRAY.  N MUST BE EVEN.
-C     USING COMPLEX NOTATION AND SUBSCRIPTS STARTING AT ZERO, THE
-C     TRANSFORMATION IS--
-C     DIMENSION DATA(N,NREM)
-C     ZSTP = EXP(ISIGN*2*PI*I/N)
-C     DO 10 I2=0,NREM-1
-C     DATA(0,I2) = CONJ(DATA(0,I2))*(1+I)
-C     DO 10 I1=1,N/4
-C     Z = (1+(2*IFORM+1)*I*ZSTP**I1)/2
-C     I1CNJ = N/2-I1
-C     DIF = DATA(I1,I2)-CONJ(DATA(I1CNJ,I2))
-C     TEMP = Z*DIF
-C     DATA(I1,I2) = (DATA(I1,I2)-TEMP)*(1-IFORM)
-C 10  DATA(I1CNJ,I2) = (DATA(I1CNJ,I2)+CONJ(TEMP))*(1-IFORM)
-C     IF I1=I1CNJ, THE CALCULATION FOR THAT VALUE COLLAPSES INTO
-C     A SIMPLE CONJUGATION OF DATA(I1,I2).
-      parameter(NMAX=2048*1024)
-      DIMENSION DATA(NMAX)
-      TWOPI=6.283185307*FLOAT(ISIGN)
-      IP0=2
-      IP1=IP0*(N/2)
-      IP2=IP1*NREM
-      IF (IFORM) 10,70,70
-C     PACK THE REAL INPUT VALUES (TWO PER COLUMN)
- 10   J1=IP1+1
-      DATA(2)=DATA(J1)
-      IF (NREM-1) 70,70,20
- 20   J1=J1+IP0
-      I2MIN=IP1+1
-      DO 60 I2=I2MIN,IP2,IP1
-      DATA(I2)=DATA(J1)
-      J1=J1+IP0
-      IF (N-2) 50,50,30
- 30   I1MIN=I2+IP0
-      I1MAX=I2+IP1-IP0
-      DO 40 I1=I1MIN,I1MAX,IP0
-      DATA(I1)=DATA(J1)
-      DATA(I1+1)=DATA(J1+1)
- 40   J1=J1+IP0
- 50   DATA(I2+1)=DATA(J1)
- 60   J1=J1+IP0
- 70   DO 80 I2=1,IP2,IP1
-      TEMPR=DATA(I2)
-      DATA(I2)=DATA(I2)+DATA(I2+1)
- 80   DATA(I2+1)=TEMPR-DATA(I2+1)
-      IF (N-2) 200,200,90
- 90   THETA=TWOPI/FLOAT(N)
-      SINTH=SIN(THETA/2.)
-      ZSTPR=-2.*SINTH*SINTH
-      ZSTPI=SIN(THETA)
-      ZR=(1.-ZSTPI)/2.
-      ZI=(1.+ZSTPR)/2.
-      IF (IFORM) 100,110,110
- 100  ZR=1.-ZR
-      ZI=-ZI
- 110  I1MIN=IP0+1
-      I1MAX=IP0*(N/4)+1
-      DO 190 I1=I1MIN,I1MAX,IP0
-      DO 180 I2=I1,IP2,IP1
-      I2CNJ=IP0*(N/2+1)-2*I1+I2
-      IF (I2-I2CNJ) 150,120,120
- 120  IF (ISIGN*(2*IFORM+1)) 130,140,140
- 130  DATA(I2+1)=-DATA(I2+1)
- 140  IF (IFORM) 170,180,180
- 150  DIFR=DATA(I2)-DATA(I2CNJ)
-      DIFI=DATA(I2+1)+DATA(I2CNJ+1)
-      TEMPR=DIFR*ZR-DIFI*ZI
-      TEMPI=DIFR*ZI+DIFI*ZR
-      DATA(I2)=DATA(I2)-TEMPR
-      DATA(I2+1)=DATA(I2+1)-TEMPI
-      DATA(I2CNJ)=DATA(I2CNJ)+TEMPR
-      DATA(I2CNJ+1)=DATA(I2CNJ+1)-TEMPI
-      IF (IFORM) 160,180,180
- 160  DATA(I2CNJ)=DATA(I2CNJ)+DATA(I2CNJ)
-      DATA(I2CNJ+1)=DATA(I2CNJ+1)+DATA(I2CNJ+1)
- 170  DATA(I2)=DATA(I2)+DATA(I2)
-      DATA(I2+1)=DATA(I2+1)+DATA(I2+1)
- 180  CONTINUE
-      TEMPR=ZR-.5
-      ZR=ZSTPR*TEMPR-ZSTPI*ZI+ZR
- 190  ZI=ZSTPR*ZI+ZSTPI*TEMPR+ZI
-C     RECURSION SAVES TIME, AT A SLIGHT LOSS IN ACCURACY.  IF AVAILABLE,
-C     USE DOUBLE PRECISION TO COMPUTE ZR AND ZI.
- 200  IF (IFORM) 270,210,210
-C     UNPACK THE REAL TRANSFORM VALUES (TWO PER COLUMN)
- 210  I2=IP2+1
-      I1=I2
-      J1=IP0*(N/2+1)*NREM+1
-      GO TO 250
- 220  DATA(J1)=DATA(I1)
-      DATA(J1+1)=DATA(I1+1)
-      I1=I1-IP0
-      J1=J1-IP0
- 230  IF (I2-I1) 220,240,240
- 240  DATA(J1)=DATA(I1)
-      DATA(J1+1)=0.
- 250  I2=I2-IP1
-      J1=J1-IP0
-      DATA(J1)=DATA(I2+1)
-      DATA(J1+1)=0.
-      I1=I1-IP0
-      J1=J1-IP0
-      IF (I2-1) 260,260,230
- 260  DATA(2)=0.
- 270  RETURN
-      END

Added: branches/wsjt8a/four2a.f
===================================================================
--- branches/wsjt8a/four2a.f	2009-09-27 19:25:26 UTC (rev 1437)
+++ branches/wsjt8a/four2a.f	2009-09-28 14:30:25 UTC (rev 1438)
@@ -0,0 +1,85 @@
+      SUBROUTINE FOUR2a (a,nfft,NDIM,ISIGN,IFORM)
+
+C     IFORM = 1, 0 or -1, as data is
+C     complex, real, or the first half of a complex array.  Transform
+C     values are returned in array DATA.  They are complex, real, or
+C     the first half of a complex array, as IFORM = 1, -1 or 0.
+
+C     The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
+C     by ... will be returned in the same array, now considered to
+C     be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
+C     IFORM = 0 or -1, N(1) must be even, and enough room must be
+C     reserved.  The missing values may be obtained by complex conjuga-
+C     tion.  
+
+C     The reverse transformation of a half complex array dimensioned
+C     N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
+C     to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
+C     The transform will be real and returned to the input array.
+
+      parameter (NPMAX=100)
+      complex a(nfft)
+      complex aa(32768)
+      integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
+      real*8 plan(NPMAX)                   !Should be i*8
+      data nplan/0/
+      include 'fftw3.f'
+      save
+
+      if(nfft.lt.0) go to 999
+
+      nloc=loc(a)
+      do i=1,nplan
+         if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.
+     +      iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
+      enddo
+      if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
+      nplan=nplan+1
+      i=nplan
+      nn(i)=nfft
+      ns(i)=isign
+      nf(i)=iform
+      nl(i)=nloc
+
+C  Planning: FFTW_ESTIMATE, FFTW_MEASURE, FFTW_PATIENT, FFTW_EXHAUSTIVE
+      nspeed=FFTW_ESTIMATE
+      if(nfft.le.16384) nspeed=FFTW_MEASURE
+      nspeed=FFTW_MEASURE
+      if(nfft.le.32768) then
+         do j=1,nfft
+            aa(j)=a(j)
+         enddo
+      endif
+      call sleep_msec(0)
+      if(isign.eq.-1 .and. iform.eq.1) then
+         call sfftw_plan_dft_1d_(plan(i),nfft,a,a,
+     +        FFTW_FORWARD,nspeed)
+      else if(isign.eq.1 .and. iform.eq.1) then
+         call sfftw_plan_dft_1d_(plan(i),nfft,a,a,
+     +        FFTW_BACKWARD,nspeed)
+      else if(isign.eq.-1 .and. iform.eq.0) then
+         call sfftw_plan_dft_r2c_1d_(plan(i),nfft,a,a,nspeed)
+      else if(isign.eq.1 .and. iform.eq.-1) then
+         call sfftw_plan_dft_c2r_1d_(plan(i),nfft,a,a,nspeed)
+      else
+         stop 'Unsupported request in four2a'
+      endif
+      call sleep_msec(0)
+      i=nplan
+      if(nfft.le.32768) then
+         do j=1,nfft
+            a(j)=aa(j)
+         enddo
+      endif
+
+ 10   call sleep_msec(0)
+      call sfftw_execute_(plan(i))
+      call sleep_msec(0)
+      return
+
+ 999  do i=1,nplan
+         call sfftw_destroy_plan_(plan(i))
+      enddo
+
+      return
+      end

Deleted: branches/wsjt8a/fourt.f
===================================================================
--- branches/wsjt8a/fourt.f	2009-09-27 19:25:26 UTC (rev 1437)
+++ branches/wsjt8a/fourt.f	2009-09-28 14:30:25 UTC (rev 1438)
@@ -1,640 +0,0 @@
-      SUBROUTINE FOURT(DATA,NN,NDIM,ISIGN,IFORM,WORK)
-c
-c     The Cooley-Tukey FFT in USASI basic fortran
-c
-c     transform(j1,j2,,,,) = sum(data(i1,i2,,,,)*w1**((i2-1)*(j2-1))
-c                                 *w2**((i2-1)*(j2-1))*,,,),
-c     where i1 and j1 run from 1 to nn(1) and w1=exp(isign*2*pi=
-c     sqrt(-1)/nn(1)), etc.  There is no limit on the dimensionality
-c     (number of subscripts) of the data array.  If an inverse
-c     transform (isign=+1) is performed upon an array of transformed
-c     (isign=-1) data, the original data will reappear,
-c     multiplied by nn(1)*nn(2)*...  The array of input data must be
-c     in complex format.  However, if all imaginary parts are zero (i.e.
-c     the data are disguised real) running time is cut up to forty per-
-c     cent.  (For fastest transform of real data, nn(1) should be even.)
-c     The transform values are always complex and are returned in the
-c     original array of data, replacing the input data.  The length
-c     of each dimension of the data array may be any integer.  The
-c     program runs faster on composite integers than on primes, and is
-c     particularly fast on numbers rich in factors of two.
-c
-c     Timing is in fact given by the following formula.  Let ntot be the
-c     total number of points (real or complex) in the data array, that
-c     is, ntot=nn(1)*nn(2)*...  Decompose ntot into its prime factors,
-c     such as 2**k2 * 3**k3 * 5**k5 * ...  Let sum2 be the sum of all
-c     the factors of two in ntot, that is, sum2 = 2*k2.  Let sumf be
-c     the sum of all other factors of ntot, that is, sumf = 3*k3*5*k5*...
-c     The time taken by a multidimensional transform on these ntot data
-c     is t = t0 + ntot*(t1+t2*sum2+t3*sumf).  On the cdc 3300 (floating
-c     point add time = six microseconds), t = 3000 + ntot*(600+40*sum2+
-c     175*sumf) microseconds on complex data.
-c
-c     Implementation of the definition by summation will run in a time
-c     proportional to ntot*(nn(1)+nn(2)+...).  For highly composite ntot
-c     the savings offered by this program can be dramatic.  A one-dimen-
-c     sional array 4000 in length will be transformed in 4000*(600+
-c     40*(2+2+2+2+2)+175*(5+5+5)) = 14.5 seconds versus about 4000*
-c     4000*175 = 2800 seconds for the straightforward technique.
-c
-c     The fast fourier transform places three restrictions upon the
-c     data.
-c     1.  The number of input data and the number of transform values
-c     must be the same.
-c     2.  Both the input data and the transform values must represent
-c     equispaced points in their respective domains of time and
-c     frequency.  Calling these spacings deltat and deltaf, it must be
-c     true that deltaf=2*pi/(nn(i)*deltat).  Of course, deltat need not
-c     be the same for every dimension.
-c     3.  Conceptually at least, the input data and the transform output
-c     represent single cycles of periodic functions.
-c
-c     The calling sequence is:
-c     call fourt(data,nn,ndim,isign,iform,work)
-c
-c     Data is the array used to hold the real and imaginary parts
-c     of the data on input and the transform values on output.  It
-c     is a multidimensional floating point array, with the real and
-c     imaginary parts of a datum stored immediately adjacent in storage
-c     (such as fortran iv places them).  Normal fortran ordering is
-c     expected, the first subscript changing fastest.  The dimensions
-c     are given in the integer array nn, of length ndim.  isign is -1
-c     to indicate a forward transform (exponential sign is -) and +1
-c     for an inverse transform (sign is +).  iform is +1 if the data are
-c     complex, 0 if the data are real.  If it is 0, the imaginary
-c     parts of the data must be set to zero.  As explained above, the
-c     transform values are always complex and are stored in array data.
-c     work is an array used for working storage.  It is floating point
-c     real, one dimensional of length equal to twice the largest array
-c     dimension nn(i) that is not a power of two.  If all nn(i) are
-c     powers of two, it is not needed and may be replaced by zero in the
-c     calling sequence.  Thus, for a one-dimensional array, nn(1) odd,
-c     work occupies as many storage locations as data.  If supplied,
-c     work must not be the same array as data.  All subscripts of all
-c     arrays begin at one.
-c
-c     Example 1:  Three-dimensional forward fourier transform of a
-c     complex array dimensioned 32 by 25 by 13 in fortran IV.
-c     dimension data(32,25,13),work(50),nn(3)
-c     complex data
-c     data nn/32,25,13/
-c     do 1 i=1,32
-c     do 1 j=1,25
-c     do 1 k=1,13
-c  1  data(i,j,k)=complex value
-c     call fourt(data,nn,3,-1,1,work)
-c
-c     Example 2:  One-dimensional forward transform of a real array of
-c     length 64 in fortran II.
-c     dimension data(2,64)
-c     do 2 i=1,64
-c     data(1,i)=real part
-c  2  data(2,i)=0.
-c     call fourt(data,64,1,-1,0,0)
-c
-c     There are no error messages or error halts in this program.  The
-c     program returns immediately if ndim or any nn(i) is less than one.
-c
-c     Program by Norman Brenner from the basic program by Charles
-c     Rader, June 1967.  The idea for the digit reversal was
-c     suggested by Ralph Alter.
-c
-c     This is the fastest and most versatile version of the FFT known
-c     to the author.  A program called four2 is available that also
-c     performs the fast fourier transform and is written in USASI basic
-c     fortran.  It is about one third as long and restricts the
-c     dimensions of the input array (which must be complex) to be powers
-c     of two.  Another program, called four1, is one tenth as long and
-c     runs two thirds as fast on a one-dimensional complex array whose
-c     length is a power of two.
-c
-c     Reference:
-c     IEEE Audio Transactions (June 1967), special issue on the FFT.
-c
-C     .. Scalar Arguments ..
-      INTEGER IFORM,ISIGN,NDIM
-C     ..
-C     .. Array Arguments ..
-      REAL DATA(*),WORK(*)
-      INTEGER NN(*)
-C     ..
-C     .. Local Scalars ..
-      REAL DIFI,DIFR,OLDSI,OLDSR,RTHLF,SUMI,SUMR,T2I,T2R,T3I,T3R,T4I,
-     +     T4R,TEMPI,TEMPR,THETA,TWOPI,TWOWR,U1I,U1R,U2I,U2R,U3I,U3R,
-     +     U4I,U4R,W2I,W2R,W3I,W3R,WI,WR,WSTPI,WSTPR
-      INTEGER I,I1,I1MAX,I1RNG,I2,I2MAX,I3,ICASE,ICONJ,IDIM,IDIV,IF,
-     +        IFMIN,IFP1,IFP2,IMAX,IMIN,INON2,IPAR,IQUOT,IREM,J,J1,
-     +        J1MAX,J1MIN,J2,J2MAX,J2MIN,J2RNG,J3,J3MAX,JMAX,JMIN,K1,K2,
-     +        K3,K4,KDIF,KMIN,KSTEP,L,LMAX,M,MMAX,N,NHALF,NP0,NP1,NP1HF,
-     +        NP1TW,NP2,NP2HF,NPREV,NTOT,NTWO,NWORK
-C     ..
-C     .. Local Arrays ..
-      INTEGER IFACT(32)
-C     ..
-C     .. Intrinsic Functions ..
-      INTRINSIC COS,MAX0,REAL,SIN
-C     ..
-C     .. Data statements ..
-      DATA NP0/0/,NPREV/0/,TWOWR/0.0/
-      DATA TWOPI/6.2831853071796/,RTHLF/0.70710678118655/
-C     ..
-      WI = 0.0
-      W2I = 0.0
-      W3I = 0.0
-      WR = 0.0
-      W2R = 0.0
-      W3R = 0.0
-      IF (NDIM-1) 232,101,101
-  101 NTOT = 2
-      DO 103 IDIM = 1,NDIM
-          IF (NN(IDIM)) 232,232,102
-  102     NTOT = NTOT*NN(IDIM)
-  103 CONTINUE
-c
-c     main loop for each dimension
-c
-      NP1 = 2
-      DO 231 IDIM = 1,NDIM
-          N = NN(IDIM)
-          NP2 = NP1*N
-          IF (N-1) 232,230,104
-c
-c     is n a power of two and if not, what are its factors
-c
-  104     M = N
-          NTWO = NP1
-          IF = 1
-          IDIV = 2
-  105     IQUOT = M/IDIV
-          IREM = M - IDIV*IQUOT
-          IF (IQUOT-IDIV) 113,106,106
-  106     IF (IREM) 108,107,108
-  107     NTWO = NTWO + NTWO
-          IFACT(IF) = IDIV
-          IF = IF + 1
-          M = IQUOT
-          GO TO 105
-
-  108     IDIV = 3
-          INON2 = IF
-  109     IQUOT = M/IDIV
-          IREM = M - IDIV*IQUOT
-          IF (IQUOT-IDIV) 115,110,110
-  110     IF (IREM) 112,111,112
-  111     IFACT(IF) = IDIV
-          IF = IF + 1
-          M = IQUOT
-          GO TO 109
-
-  112     IDIV = IDIV + 2
-          GO TO 109
-
-  113     INON2 = IF
-          IF (IREM) 115,114,115
-  114     NTWO = NTWO + NTWO
-          GO TO 116
-
-  115     IFACT(IF) = M
-c
-c     separate four cases--
-c        1. complex transform or real transform for the 4th, 9th,etc.
-c           dimensions.
-c        2. real transform for the 2nd or 3rd dimension.  method--
-c           transform half the data, supplying the other half by con-
-c           jugate symmetry.
-c        3. real transform for the 1st dimension, n odd.  method--
-c           set the imaginary parts to zero.
-c        4. real transform for the 1st dimension, n even.  method--
-c           transform a complex array of length n/2 whose real parts
-c           are the even numbered real values and whose imaginary parts
-c           are the odd numbered real values.  separate and supply
-c           the second half by conjugate symmetry.
-c
-  116     ICASE = 1
-          IFMIN = 1
-          I1RNG = NP1
-          IF (IDIM-4) 117,122,122
-  117     IF (IFORM) 118,118,122
-  118     ICASE = 2
-          I1RNG = NP0* (1+NPREV/2)
-          IF (IDIM-1) 119,119,122
-  119     ICASE = 3
-          I1RNG = NP1
-          IF (NTWO-NP1) 122,122,120
-  120     ICASE = 4
-          IFMIN = 2
-          NTWO = NTWO/2
-          N = N/2
-          NP2 = NP2/2
-          NTOT = NTOT/2
-          I = 1
-          DO 121 J = 1,NTOT
-              DATA(J) = DATA(I)
-              I = I + 2
-  121     CONTINUE
-c
-c     shuffle data by bit reversal, since n=2**k.  as the shuffling
-c     can be done by simple interchange, no working array is needed
-c
-  122     IF (NTWO-NP2) 132,123,123
-  123     NP2HF = NP2/2
-          J = 1
-          DO 131 I2 = 1,NP2,NP1
-              IF (J-I2) 124,127,127
-  124         I1MAX = I2 + NP1 - 2
-              DO 126 I1 = I2,I1MAX,2
-                  DO 125 I3 = I1,NTOT,NP2
-                      J3 = J + I3 - I2
-                      TEMPR = DATA(I3)
-                      TEMPI = DATA(I3+1)
-                      DATA(I3) = DATA(J3)
-                      DATA(I3+1) = DATA(J3+1)
-                      DATA(J3) = TEMPR
-                      DATA(J3+1) = TEMPI
-  125             CONTINUE
-  126         CONTINUE
-  127         M = NP2HF
-  128         IF (J-M) 130,130,129
-  129         J = J - M
-              M = M/2
-              IF (M-NP1) 130,128,128
-  130         J = J + M
-  131     CONTINUE
-          GO TO 142
-c
-c     shuffle data by digit reversal for general n
-c
-  132     NWORK = 2*N
-          DO 141 I1 = 1,NP1,2
-              DO 140 I3 = I1,NTOT,NP2
-                  J = I3
-                  DO 138 I = 1,NWORK,2
-                      IF (ICASE-3) 133,134,133
-  133                 WORK(I) = DATA(J)
-                      WORK(I+1) = DATA(J+1)
-                      GO TO 135
-
-  134                 WORK(I) = DATA(J)
-                      WORK(I+1) = 0.
-  135                 IFP2 = NP2
-                      IF = IFMIN
-  136                 IFP1 = IFP2/IFACT(IF)
-                      J = J + IFP1
-                      IF (J-I3-IFP2) 138,137,137
-  137                 J = J - IFP2
-                      IFP2 = IFP1
-                      IF = IF + 1
-                      IF (IFP2-NP1) 138,138,136
-  138             CONTINUE
-                  I2MAX = I3 + NP2 - NP1
-                  I = 1
-                  DO 139 I2 = I3,I2MAX,NP1
-                      DATA(I2) = WORK(I)
-                      DATA(I2+1) = WORK(I+1)
-                      I = I + 2
-  139             CONTINUE
-  140         CONTINUE
-  141     CONTINUE
-c
-c     main loop for factors of two.  perform fourier transforms of
-c     length four, with one of length two if needed.  the twiddle factor
-c     w=exp(isign*2*pi*sqrt(-1)*m/(4*mmax)).  check for w=isign*sqrt(-1)
-c     and repeat for w=w*(1+isign*sqrt(-1))/sqrt(2).
-c
-  142     IF (NTWO-NP1) 174,174,143
-  143     NP1TW = NP1 + NP1
-          IPAR = NTWO/NP1
-  144     IF (IPAR-2) 149,146,145
-  145     IPAR = IPAR/4
-          GO TO 144
-
-  146     DO 148 I1 = 1,I1RNG,2
-              DO 147 K1 = I1,NTOT,NP1TW
-                  K2 = K1 + NP1
-                  TEMPR = DATA(K2)
-                  TEMPI = DATA(K2+1)
-                  DATA(K2) = DATA(K1) - TEMPR
-                  DATA(K2+1) = DATA(K1+1) - TEMPI
-                  DATA(K1) = DATA(K1) + TEMPR
-                  DATA(K1+1) = DATA(K1+1) + TEMPI
-  147         CONTINUE
-  148     CONTINUE
-  149     MMAX = NP1
-  150     IF (MMAX-NTWO/2) 151,174,174
-  151     LMAX = MAX0(NP1TW,MMAX/2)
-          DO 173 L = NP1,LMAX,NP1TW
-              M = L
-              IF (MMAX-NP1) 156,156,152
-  152         THETA = -TWOPI*REAL(L)/REAL(4*MMAX)
-              IF (ISIGN) 154,153,153
-  153         THETA = -THETA
-  154         WR = COS(THETA)
-              WI = SIN(THETA)
-  155         W2R = WR*WR - WI*WI
-              W2I = 2.*WR*WI
-              W3R = W2R*WR - W2I*WI
-              W3I = W2R*WI + W2I*WR
-  156         DO 169 I1 = 1,I1RNG,2
-                  KMIN = I1 + IPAR*M
-                  IF (MMAX-NP1) 157,157,158
-  157             KMIN = I1
-  158             KDIF = IPAR*MMAX
-  159             KSTEP = 4*KDIF
-                  IF (KSTEP-NTWO) 160,160,169
-  160             DO 168 K1 = KMIN,NTOT,KSTEP
-                      K2 = K1 + KDIF
-                      K3 = K2 + KDIF
-                      K4 = K3 + KDIF
-                      IF (MMAX-NP1) 161,161,164
-  161                 U1R = DATA(K1) + DATA(K2)
-                      U1I = DATA(K1+1) + DATA(K2+1)
-                      U2R = DATA(K3) + DATA(K4)
-                      U2I = DATA(K3+1) + DATA(K4+1)
-                      U3R = DATA(K1) - DATA(K2)
-                      U3I = DATA(K1+1) - DATA(K2+1)
-                      IF (ISIGN) 162,163,163
-  162                 U4R = DATA(K3+1) - DATA(K4+1)
-                      U4I = DATA(K4) - DATA(K3)
-                      GO TO 167
-
-  163                 U4R = DATA(K4+1) - DATA(K3+1)
-                      U4I = DATA(K3) - DATA(K4)
-                      GO TO 167
-
-  164                 T2R = W2R*DATA(K2) - W2I*DATA(K2+1)
-                      T2I = W2R*DATA(K2+1) + W2I*DATA(K2)
-                      T3R = WR*DATA(K3) - WI*DATA(K3+1)
-                      T3I = WR*DATA(K3+1) + WI*DATA(K3)
-                      T4R = W3R*DATA(K4) - W3I*DATA(K4+1)
-                      T4I = W3R*DATA(K4+1) + W3I*DATA(K4)
-                      U1R = DATA(K1) + T2R
-                      U1I = DATA(K1+1) + T2I
-                      U2R = T3R + T4R
-                      U2I = T3I + T4I
-                      U3R = DATA(K1) - T2R
-                      U3I = DATA(K1+1) - T2I
-                      IF (ISIGN) 165,166,166
-  165                 U4R = T3I - T4I
-                      U4I = T4R - T3R
-                      GO TO 167
-
-  166                 U4R = T4I - T3I
-                      U4I = T3R - T4R
-  167                 DATA(K1) = U1R + U2R
-                      DATA(K1+1) = U1I + U2I
-                      DATA(K2) = U3R + U4R
-                      DATA(K2+1) = U3I + U4I
-                      DATA(K3) = U1R - U2R
-                      DATA(K3+1) = U1I - U2I
-                      DATA(K4) = U3R - U4R
-                      DATA(K4+1) = U3I - U4I
-  168             CONTINUE
-                  KDIF = KSTEP
-                  KMIN = 4* (KMIN-I1) + I1
-                  GO TO 159
-
-  169         CONTINUE
-              M = M + LMAX
-              IF (M-MMAX) 170,170,173
-  170         IF (ISIGN) 171,172,172
-  171         TEMPR = WR
-              WR = (WR+WI)*RTHLF
-              WI = (WI-TEMPR)*RTHLF
-              GO TO 155
-
-  172         TEMPR = WR
-              WR = (WR-WI)*RTHLF
-              WI = (TEMPR+WI)*RTHLF
-              GO TO 155
-
-  173     CONTINUE
-          IPAR = 3 - IPAR
-          MMAX = MMAX + MMAX
-          GO TO 150
-c
-c     main loop for factors not equal to two.  apply the twiddle factor
-c     w=exp(isign*2*pi*sqrt(-1)*(j1-1)*(j2-j1)/(ifp1+ifp2)), then
-c     perform a fourier transform of length ifact(if), making use of
-c     conjugate symmetries.
-c
-  174     IF (NTWO-NP2) 175,201,201
-  175     IFP1 = NTWO
-          IF = INON2
-          NP1HF = NP1/2
-  176     IFP2 = IFACT(IF)*IFP1
-          J1MIN = NP1 + 1
-          IF (J1MIN-IFP1) 177,177,184
-  177     DO 183 J1 = J1MIN,IFP1,NP1
-              THETA = -TWOPI*REAL(J1-1)/REAL(IFP2)
-              IF (ISIGN) 179,178,178
-  178         THETA = -THETA
-  179         WSTPR = COS(THETA)
-              WSTPI = SIN(THETA)
-              WR = WSTPR
-              WI = WSTPI
-              J2MIN = J1 + IFP1
-              J2MAX = J1 + IFP2 - IFP1
-              DO 182 J2 = J2MIN,J2MAX,IFP1
-                  I1MAX = J2 + I1RNG - 2
-                  DO 181 I1 = J2,I1MAX,2
-                      DO 180 J3 = I1,NTOT,IFP2
-                          TEMPR = DATA(J3)
-                          DATA(J3) = DATA(J3)*WR - DATA(J3+1)*WI
-                          DATA(J3+1) = TEMPR*WI + DATA(J3+1)*WR
-  180                 CONTINUE
-  181             CONTINUE
-                  TEMPR = WR
-                  WR = WR*WSTPR - WI*WSTPI
-                  WI = TEMPR*WSTPI + WI*WSTPR
-  182         CONTINUE
-  183     CONTINUE
-  184     THETA = -TWOPI/REAL(IFACT(IF))
-          IF (ISIGN) 186,185,185
-  185     THETA = -THETA
-  186     WSTPR = COS(THETA)
-          WSTPI = SIN(THETA)
-          J2RNG = IFP1* (1+IFACT(IF)/2)
-          DO 200 I1 = 1,I1RNG,2
-              DO 199 I3 = I1,NTOT,NP2
-                  J2MAX = I3 + J2RNG - IFP1
-                  DO 197 J2 = I3,J2MAX,IFP1
-                      J1MAX = J2 + IFP1 - NP1
-                      DO 193 J1 = J2,J1MAX,NP1
-                          J3MAX = J1 + NP2 - IFP2
-                          DO 192 J3 = J1,J3MAX,IFP2
-                              JMIN = J3 - J2 + I3
-                              JMAX = JMIN + IFP2 - IFP1
-                              I = 1 + (J3-I3)/NP1HF
-                              IF (J2-I3) 187,187,189
-  187                         SUMR = 0.
-                              SUMI = 0.
-                              DO 188 J = JMIN,JMAX,IFP1
-                                  SUMR = SUMR + DATA(J)
-                                  SUMI = SUMI + DATA(J+1)
-  188                         CONTINUE
-                              WORK(I) = SUMR
-                              WORK(I+1) = SUMI
-                              GO TO 192
-
-  189                         ICONJ = 1 + (IFP2-2*J2+I3+J3)/NP1HF
-                              J = JMAX
-                              SUMR = DATA(J)
-                              SUMI = DATA(J+1)
-                              OLDSR = 0.
-                              OLDSI = 0.
-                              J = J - IFP1
-  190                         TEMPR = SUMR
-                              TEMPI = SUMI
-                              SUMR = TWOWR*SUMR - OLDSR + DATA(J)
-                              SUMI = TWOWR*SUMI - OLDSI + DATA(J+1)
-                              OLDSR = TEMPR
-                              OLDSI = TEMPI
-                              J = J - IFP1
-                              IF (J-JMIN) 191,191,190
-  191                         TEMPR = WR*SUMR - OLDSR + DATA(J)
-                              TEMPI = WI*SUMI
-                              WORK(I) = TEMPR - TEMPI
-                              WORK(ICONJ) = TEMPR + TEMPI
-                              TEMPR = WR*SUMI - OLDSI + DATA(J+1)
-                              TEMPI = WI*SUMR
-                              WORK(I+1) = TEMPR + TEMPI
-                              WORK(ICONJ+1) = TEMPR - TEMPI
-  192                     CONTINUE
-  193                 CONTINUE
-                      IF (J2-I3) 194,194,195
-  194                 WR = WSTPR
-                      WI = WSTPI
-                      GO TO 196
-
-  195                 TEMPR = WR
-                      WR = WR*WSTPR - WI*WSTPI
-                      WI = TEMPR*WSTPI + WI*WSTPR
-  196                 TWOWR = WR + WR
-  197             CONTINUE
-                  I = 1
-                  I2MAX = I3 + NP2 - NP1
-                  DO 198 I2 = I3,I2MAX,NP1
-                      DATA(I2) = WORK(I)
-                      DATA(I2+1) = WORK(I+1)
-                      I = I + 2
-  198             CONTINUE
-  199         CONTINUE
-  200     CONTINUE
-          IF = IF + 1
-          IFP1 = IFP2
-          IF (IFP1-NP2) 176,201,201
-c
-c     complete a real transform in the 1st dimension, n even, by con-
-c     jugate symmetries.
-c
-  201     GO TO (230,220,230,202) ICASE
-
-  202     NHALF = N
-          N = N + N
-          THETA = -TWOPI/REAL(N)
-          IF (ISIGN) 204,203,203
-  203     THETA = -THETA
-  204     WSTPR = COS(THETA)
-          WSTPI = SIN(THETA)
-          WR = WSTPR
-          WI = WSTPI
-          IMIN = 3
-          JMIN = 2*NHALF - 1
-          GO TO 207
-
-  205     J = JMIN
-          DO 206 I = IMIN,NTOT,NP2
-              SUMR = (DATA(I)+DATA(J))/2.
-              SUMI = (DATA(I+1)+DATA(J+1))/2.
-              DIFR = (DATA(I)-DATA(J))/2.
-              DIFI = (DATA(I+1)-DATA(J+1))/2.
-              TEMPR = WR*SUMI + WI*DIFR
-              TEMPI = WI*SUMI - WR*DIFR
-              DATA(I) = SUMR + TEMPR
-              DATA(I+1) = DIFI + TEMPI
-              DATA(J) = SUMR - TEMPR
-              DATA(J+1) = -DIFI + TEMPI
-              J = J + NP2
-  206     CONTINUE
-          IMIN = IMIN + 2
-          JMIN = JMIN - 2
-          TEMPR = WR
-          WR = WR*WSTPR - WI*WSTPI
-          WI = TEMPR*WSTPI + WI*WSTPR
-  207     IF (IMIN-JMIN) 205,208,211
-  208     IF (ISIGN) 209,211,211
-  209     DO 210 I = IMIN,NTOT,NP2
-              DATA(I+1) = -DATA(I+1)
-  210     CONTINUE
-  211     NP2 = NP2 + NP2
-          NTOT = NTOT + NTOT
-          J = NTOT + 1
-          IMAX = NTOT/2 + 1
-  212     IMIN = IMAX - 2*NHALF
-          I = IMIN
-          GO TO 214
-
-  213     DATA(J) = DATA(I)
-          DATA(J+1) = -DATA(I+1)
-  214     I = I + 2
-          J = J - 2
-          IF (I-IMAX) 213,215,215
-  215     DATA(J) = DATA(IMIN) - DATA(IMIN+1)
-          DATA(J+1) = 0.
-          IF (I-J) 217,219,219
-  216     DATA(J) = DATA(I)
-          DATA(J+1) = DATA(I+1)
-  217     I = I - 2
-          J = J - 2
-          IF (I-IMIN) 218,218,216
-  218     DATA(J) = DATA(IMIN) + DATA(IMIN+1)
-          DATA(J+1) = 0.
-          IMAX = IMIN
-          GO TO 212
-
-  219     DATA(1) = DATA(1) + DATA(2)
-          DATA(2) = 0.
-          GO TO 230
-c
-c     complete a real transform for the 2nd or 3rd dimension by
-c     conjugate symmetries.
-c
-  220     IF (I1RNG-NP1) 221,230,230
-  221     DO 229 I3 = 1,NTOT,NP2
-              I2MAX = I3 + NP2 - NP1
-              DO 228 I2 = I3,I2MAX,NP1
-                  IMIN = I2 + I1RNG
-                  IMAX = I2 + NP1 - 2
-                  JMAX = 2*I3 + NP1 - IMIN
-                  IF (I2-I3) 223,223,222
-  222             JMAX = JMAX + NP2
-  223             IF (IDIM-2) 226,226,224
-  224             J = JMAX + NP0
-                  DO 225 I = IMIN,IMAX,2
-                      DATA(I) = DATA(J)
-                      DATA(I+1) = -DATA(J+1)
-                      J = J - 2
-  225             CONTINUE
-  226             J = JMAX
-                  DO 227 I = IMIN,IMAX,NP0
-                      DATA(I) = DATA(J)
-                      DATA(I+1) = -DATA(J+1)
-                      J = J - NP0
-  227             CONTINUE
-  228         CONTINUE
-  229     CONTINUE
-c
-c     end of loop on each dimension
-c
-  230     NP0 = NP1
-          NP1 = NP2
-          NPREV = N
-  231 CONTINUE
-  232 RETURN
-c
-c revision history---
-c
-c january 1978     deleted references to the  *cosy  cards and
-c                  added revision history
-c-----------------------------------------------------------------------
-      END

Modified: branches/wsjt8a/int.h
===================================================================
--- branches/wsjt8a/int.h	2009-09-27 19:25:26 UTC (rev 1437)
+++ branches/wsjt8a/int.h	2009-09-28 14:30:25 UTC (rev 1438)
@@ -19,7 +19,7 @@
   int pad;        /* Padding bytes in shortened block */
 };
 
-static inline int modnn(struct rs *rs,int x){
+static int modnn(struct rs *rs,int x){
   while (x &gt;= rs-&gt;nn) {
     x -= rs-&gt;nn;
     x = (x &gt;&gt; rs-&gt;mm) + (x &amp; rs-&gt;nn);
@@ -33,7 +33,8 @@
 #define ALPHA_TO (rs-&gt;alpha_to) 
 #define INDEX_OF (rs-&gt;index_of)
 #define GENPOLY (rs-&gt;genpoly)
-#define NROOTS (rs-&gt;nroots)
+//#define NROOTS (rs-&gt;nroots)
+#define NROOTS (51)
 #define FCR (rs-&gt;fcr)
 #define PRIM (rs-&gt;prim)
 #define IPRIM (rs-&gt;iprim)

Deleted: branches/wsjt8a/ps64.f
===================================================================
--- branches/wsjt8a/ps64.f	2009-09-27 19:25:26 UTC (rev 1437)
+++ branches/wsjt8a/ps64.f	2009-09-28 14:30:25 UTC (rev 1438)
@@ -1,26 +0,0 @@
-      subroutine ps64(dat,nfft,s)
-
-      parameter (NMAX=6480+2)
-      parameter (NHMAX=NMAX/2-1)
-      real dat(nfft)
-      real s(NHMAX)
-      real work(2*NMAX)
-      complex c(0:NMAX)
-
-      nh=nfft/2
-      do i=1,nh
-         c(i-1)=dat(i)/128.0       !### Why 128 ??
-      enddo
-      do i=nh+1,nfft
-         c(i-1)=0.
-      enddo
-
-      call fourt(c,nfft,1,-1,0,work)
-
-      fac=1.0/nfft
-      do i=1,nh
-         s(i)=fac*(real(c(i))**2 + aimag(c(i))**2)
-      enddo
-
-      return
-      end

Added: branches/wsjt8a/sec_midn.F90
===================================================================
--- branches/wsjt8a/sec_midn.F90	2009-09-27 19:25:26 UTC (rev 1437)
+++ branches/wsjt8a/sec_midn.F90	2009-09-28 14:30:25 UTC (rev 1438)
@@ -0,0 +1,19 @@
+real function sec_midn()
+  sec_midn=secnds(0.0)
+  return
+end function sec_midn
+
+subroutine sleep_msec(n)
+
+#ifdef CVF
+  use dflib
+#endif
+
+#ifdef CVF
+  call sleepqq(n)
+#else
+  call usleep(1000*n)
+#endif
+
+  return
+end subroutine sleep_msec

Modified: branches/wsjt8a/sync64.f
===================================================================
--- branches/wsjt8a/sync64.f	2009-09-27 19:25:26 UTC (rev 1437)
+++ branches/wsjt8a/sync64.f	2009-09-28 14:30:25 UTC (rev 1438)
@@ -55,7 +55,7 @@
             x(i)=dat(k+i-1)
             x(i+nh)=0.
          enddo
-         call ps64(x,nfft,s2(1,j))
+         call ps(x,nfft,s2(1,j))
       enddo
 
 C  Determine the search range in frequency


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001128.html">[WSJT-SVN] r1437 - branches/wsjt8a
</A></li>
	<LI>Next message: <A HREF="001130.html">[WSJT-SVN] r1439 - branches/wsjt8a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1129">[ date ]</a>
              <a href="thread.html#1129">[ thread ]</a>
              <a href="subject.html#1129">[ subject ]</a>
              <a href="author.html#1129">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
