<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r862 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r862%20-%20trunk&In-Reply-To=%3C200806072345.m57Njah9024104%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000546.html">
   <LINK REL="Next"  HREF="000547.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r862 - trunk</H1>
    <B>va3db at BerliOS</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r862%20-%20trunk&In-Reply-To=%3C200806072345.m57Njah9024104%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r862 - trunk">va3db at mail.berlios.de
       </A><BR>
    <I>Sun Jun  8 01:45:36 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000546.html">[WSJT-SVN] r861 - trunk
</A></li>
        <LI>Next message: <A HREF="000547.html">[WSJT-SVN] r863 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#552">[ date ]</a>
              <a href="thread.html#552">[ thread ]</a>
              <a href="subject.html#552">[ subject ]</a>
              <a href="author.html#552">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: va3db
Date: 2008-06-08 01:45:35 +0200 (Sun, 08 Jun 2008)
New Revision: 862

Modified:
   trunk/GeoDist.f
   trunk/astro.F
   trunk/coord.f
   trunk/db.f
   trunk/dcoord.f
   trunk/mtdecode.f
   trunk/pctile.f
   trunk/ping.f
   trunk/spec2d.f
   trunk/spec441.f
   trunk/wsjt1.F
   trunk/wsjtgen.F90
Log:
- I have removed tabs from these files, this will make it easier to
  spot cleanups to do. The &quot;non conforming tabs&quot; has been hiding
  a lot of faults. I also had to shorten a few lines in wsjt1.F to get
  it to compile without an error on g95. 



Modified: trunk/GeoDist.f
===================================================================
--- trunk/GeoDist.f	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/GeoDist.f	2008-06-07 23:45:35 UTC (rev 862)
@@ -1,38 +1,38 @@
-	subroutine geodist(Eplat, Eplon, Stlat, Stlon,
-     +	  Az, Baz, Dist)
-	implicit none
-	real eplat, eplon, stlat, stlon, az, baz, dist
+        subroutine geodist(Eplat, Eplon, Stlat, Stlon,
+     +    Az, Baz, Dist)
+        implicit none
+        real eplat, eplon, stlat, stlon, az, baz, dist
 
 C JHT: In actual fact, I use the first two arguments for &quot;My Location&quot;,
 C      the second two for &quot;His location&quot;; West longitude is positive.
 
 c
 c
-c	Taken directly from:
-c	Thomas, P.D., 1970, Spheroidal geodesics, reference systems,
-c	&amp; local geometry, U.S. Naval Oceanographic Office SP-138,
-c	165 pp.
+c       Taken directly from:
+c       Thomas, P.D., 1970, Spheroidal geodesics, reference systems,
+c       &amp; local geometry, U.S. Naval Oceanographic Office SP-138,
+c       165 pp.
 c
-c	assumes North Latitude and East Longitude are positive
+c       assumes North Latitude and East Longitude are positive
 c
-c	EpLat, EpLon = End point Lat/Long
-c	Stlat, Stlon = Start point lat/long
-c	Az, BAz = direct &amp; reverse azimuith
-c	Dist = Dist (km); Deg = central angle, discarded
+c       EpLat, EpLon = End point Lat/Long
+c       Stlat, Stlon = Start point lat/long
+c       Az, BAz = direct &amp; reverse azimuith
+c       Dist = Dist (km); Deg = central angle, discarded
 c
 
-	real BOA, F, P1R, P2R, L1R, L2R, DLR, T1R, T2R, TM,
+        real BOA, F, P1R, P2R, L1R, L2R, DLR, T1R, T2R, TM,
      +    DTM, STM, CTM, SDTM,CDTM, KL, KK, SDLMR, L,
      +    CD, DL, SD, T, U, V, D, X, E, Y, A, FF64, TDLPM,
      +    HAPBR, HAMBR, A1M2, A2M1
 
-	real AL,BL,D2R,Pi2
+        real AL,BL,D2R,Pi2
 
-	data AL/6378206.4/		! Clarke 1866 ellipsoid
-	data BL/6356583.8/
-c	real pi /3.14159265359/
-	data D2R/0.01745329251994/	! degrees to radians conversion factor
-	data Pi2/6.28318530718/
+        data AL/6378206.4/              ! Clarke 1866 ellipsoid
+        data BL/6356583.8/
+c       real pi /3.14159265359/
+        data D2R/0.01745329251994/      ! degrees to radians conversion factor
+        data Pi2/6.28318530718/
 
         BOA = BL/AL
         F = 1.0 - BOA
@@ -41,7 +41,7 @@
         P2R = Stlat * D2R
         L1R = Eplon * D2R
         L2R = StLon * D2R
-        DLR = L2R - L1R			! DLR = Delta Long in Rads
+        DLR = L2R - L1R                 ! DLR = Delta Long in Rads
         T1R = ATan(BOA * Tan(P1R))
         T2R = ATan(BOA * Tan(P2R))
         TM = (T1R + T2R) / 2.0
@@ -75,28 +75,28 @@
         A1M2 = Pi2 + HAMBR - HAPBR
         A2M1 = Pi2 - HAMBR - HAPBR
 
-1	If ((A1M2 .ge. 0.0) .AND. (A1M2 .lt. Pi2)) GOTO 5
- 	If (A1M2 .lt. Pi2) GOTO 4
- 	A1M2 = A1M2 - Pi2
+1       If ((A1M2 .ge. 0.0) .AND. (A1M2 .lt. Pi2)) GOTO 5
+        If (A1M2 .lt. Pi2) GOTO 4
+        A1M2 = A1M2 - Pi2
         GOTO 1
-4	A1M2 = A1M2 + Pi2
+4       A1M2 = A1M2 + Pi2
         GOTO 1
 c
 c all of this gens the proper az, baz (forward and back azimuth)
 c
 
-5	If ((A2M1 .ge. 0.0) .AND. (A2M1 .lt. Pi2)) GOTO 9
- 	If (A2M1 .lt. Pi2) GOTO 8
-	A2M1 = A2M1 - Pi2
+5       If ((A2M1 .ge. 0.0) .AND. (A2M1 .lt. Pi2)) GOTO 9
+        If (A2M1 .lt. Pi2) GOTO 8
+        A2M1 = A2M1 - Pi2
         GOTO 5
-8	A2M1 = A2M1 + Pi2
+8       A2M1 = A2M1 + Pi2
         GOTO 5
 
-9	Az = A1M2 / D2R
-	BAZ = A2M1 / D2R
+9       Az = A1M2 / D2R
+        BAZ = A2M1 / D2R
 c
 c Fix the mirrored coords here.
 c
-	az = 360.0 - az
-	baz = 360.0 - baz
-	end
+        az = 360.0 - az
+        baz = 360.0 - baz
+        end

Modified: trunk/astro.F
===================================================================
--- trunk/astro.F	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/astro.F	2008-06-07 23:45:35 UTC (rev 862)
@@ -22,13 +22,13 @@
       save first
 
       if(first) then
-	do i=80,1,-1
-	   if(ichar(AppDir(i:i)).ne.0 .and. 
+        do i=80,1,-1
+           if(ichar(AppDir(i:i)).ne.0 .and. 
      +            ichar(AppDir(i:i)).ne.32) goto 1
-	enddo
- 1	lenappdir=i
+        enddo
+ 1      lenappdir=i
         call zero(nsky,180*180)
-	fname=Appdir(1:lenappdir)//'/TSKY.DAT'
+        fname=Appdir(1:lenappdir)//'/TSKY.DAT'
 #ifdef CVF
         open(13,file=fname,status='old',form='binary',err=10)
         read(13) nsky

Modified: trunk/coord.f
===================================================================
--- trunk/coord.f	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/coord.f	2008-06-07 23:45:35 UTC (rev 862)
@@ -1,18 +1,18 @@
-	SUBROUTINE COORD(A0,B0,AP,BP,A1,B1,A2,B2)
+        SUBROUTINE COORD(A0,B0,AP,BP,A1,B1,A2,B2)
 
 C  Examples:
 C  1. From ha,dec to az,el:
-C	call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
+C       call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
 C  2. From az,el to ha,dec:
-C	call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
+C       call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
 C  3. From ra,dec to l,b
-C	call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
-C	  ra,dec,l,b)
+C       call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
+C         ra,dec,l,b)
 C  4. From l,b to ra,dec
-C	call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
+C       call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
 C         0.478220215d0,l,b,ra,dec)
 C  5. From ecliptic latitude (eb) and longitude (el) to ra, dec:
-C	call coord(0.e0,0.e0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
+C       call coord(0.e0,0.e0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
 
       SB0=sin(B0)
       CB0=cos(B0)

Modified: trunk/db.f
===================================================================
--- trunk/db.f	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/db.f	2008-06-07 23:45:35 UTC (rev 862)
@@ -1,5 +1,5 @@
-	real function db(x)
-	db=-99.0
-	if(x.gt.1.259e-10) db=10.0*log10(x)
-	return
-	end
+        real function db(x)
+        db=-99.0
+        if(x.gt.1.259e-10) db=10.0*log10(x)
+        return
+        end

Modified: trunk/dcoord.f
===================================================================
--- trunk/dcoord.f	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/dcoord.f	2008-06-07 23:45:35 UTC (rev 862)
@@ -1,19 +1,19 @@
-	SUBROUTINE DCOORD(A0,B0,AP,BP,A1,B1,A2,B2)
+        SUBROUTINE DCOORD(A0,B0,AP,BP,A1,B1,A2,B2)
 
-	implicit real*8 (a-h,o-z)
+        implicit real*8 (a-h,o-z)
 C  Examples:
 C  1. From ha,dec to az,el:
-C	call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
+C       call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
 C  2. From az,el to ha,dec:
-C	call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
+C       call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
 C  3. From ra,dec to l,b
-C	call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
-C	  ra,dec,l,b)
+C       call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
+C         ra,dec,l,b)
 C  4. From l,b to ra,dec
-C	call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
+C       call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
 C         0.478220215d0,l,b,ra,dec)
 C  5. From ecliptic latitude (eb) and longitude (el) to ra, dec:
-C	call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
+C       call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
 
       SB0=sin(B0)
       CB0=cos(B0)

Modified: trunk/mtdecode.f
===================================================================
--- trunk/mtdecode.f	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/mtdecode.f	2008-06-07 23:45:35 UTC (rev 862)
@@ -72,12 +72,12 @@
 
 C  If this is a &quot;mouse pick&quot; and no ping was found, force a pseudo-ping 
 C  at center of data.
-	if(pick.and.nping.eq.0) then
+        if(pick.and.nping.eq.0) then
            if(nping.le.99) nping=nping+1
-	   pingdat(1,nping)=0.5*jz*dt
-	   pingdat(2,nping)=0.16
-	   pingdat(3,nping)=1.0
-	endif
+           pingdat(1,nping)=0.5*jz*dt
+           pingdat(2,nping)=0.16
+           pingdat(3,nping)=1.0
+        endif
 
       bigpeak=0.
       do iping=1,nping

Modified: trunk/pctile.f
===================================================================
--- trunk/pctile.f	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/pctile.f	2008-06-07 23:45:35 UTC (rev 862)
@@ -1,13 +1,13 @@
-	subroutine pctile(x,tmp,nmax,npct,xpct)
-	real x(nmax),tmp(nmax)
+        subroutine pctile(x,tmp,nmax,npct,xpct)
+        real x(nmax),tmp(nmax)
 
-	do i=1,nmax
-	  tmp(i)=x(i)
-	enddo
-	call sort(nmax,tmp)
-	j=nint(nmax*0.01*npct)
-	if(j.lt.1) j=1
-	xpct=tmp(j)
+        do i=1,nmax
+          tmp(i)=x(i)
+        enddo
+        call sort(nmax,tmp)
+        j=nint(nmax*0.01*npct)
+        if(j.lt.1) j=1
+        xpct=tmp(j)
 
-	return
-	end
+        return
+        end

Modified: trunk/ping.f
===================================================================
--- trunk/ping.f	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/ping.f	2008-06-07 23:45:35 UTC (rev 862)
@@ -1,41 +1,41 @@
-	subroutine ping(s,nz,dtbuf,slim,wmin,pingdat,nping)
+        subroutine ping(s,nz,dtbuf,slim,wmin,pingdat,nping)
 
 C  Detect pings and make note of their start time, duration, and peak strength.
 
-	real*4 s(nz)
-	real*4 pingdat(3,100)
-	logical inside
+        real*4 s(nz)
+        real*4 pingdat(3,100)
+        logical inside
 
-	nping=0
-	peak=0.
-	inside=.false.
-c###	sdown=slim-1.0
-	snrlim=10.0**(0.1*slim) - 1.0
-	sdown=10.0*log10(0.25*snrlim+1.0)
+        nping=0
+        peak=0.
+        inside=.false.
+c###    sdown=slim-1.0
+        snrlim=10.0**(0.1*slim) - 1.0
+        sdown=10.0*log10(0.25*snrlim+1.0)
 
-	do i=2,nz
-	   if(s(i).ge.slim .and. .not.inside) then
-	      i0=i
-	      tstart=i0*dtbuf
-	      inside=.true.
-	      peak=0.
-	   endif
-	   if(inside .and. s(i).gt.peak) then
-	      peak=s(i)
-	   endif
-	   if(inside .and. (s(i).lt.sdown .or. i.eq.nz)) then
-	      if(i.gt.i0) then
-		 if(dtbuf*(i-i0).ge.wmin) then
-		    if(nping.le.99) nping=nping+1
-		    pingdat(1,nping)=tstart
-		    pingdat(2,nping)=dtbuf*(i-i0)
-		    pingdat(3,nping)=peak
-		 endif
-	        inside=.false.
-	        peak=0.
-	     endif
-	   endif
-	enddo
+        do i=2,nz
+           if(s(i).ge.slim .and. .not.inside) then
+              i0=i
+              tstart=i0*dtbuf
+              inside=.true.
+              peak=0.
+           endif
+           if(inside .and. s(i).gt.peak) then
+              peak=s(i)
+           endif
+           if(inside .and. (s(i).lt.sdown .or. i.eq.nz)) then
+              if(i.gt.i0) then
+                 if(dtbuf*(i-i0).ge.wmin) then
+                    if(nping.le.99) nping=nping+1
+                    pingdat(1,nping)=tstart
+                    pingdat(2,nping)=dtbuf*(i-i0)
+                    pingdat(3,nping)=peak
+                 endif
+                inside=.false.
+                peak=0.
+             endif
+           endif
+        enddo
 
- 	return
-	end
+        return
+        end

Modified: trunk/spec2d.f
===================================================================
--- trunk/spec2d.f	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/spec2d.f	2008-06-07 23:45:35 UTC (rev 862)
@@ -1,128 +1,128 @@
-	subroutine spec2d(data,jz,nstep,s2,nchan,nz,psavg0,sigma)
+        subroutine spec2d(data,jz,nstep,s2,nchan,nz,psavg0,sigma)
 
 C  Computes 2d spectrogram for FSK441 single-tone search and waterfall
 C  display.
 
-	parameter (NFFT=256)
-	parameter (NR=NFFT+2)
-	parameter (NH=NFFT/2)
-	parameter (NQ=NFFT/4)
+        parameter (NFFT=256)
+        parameter (NR=NFFT+2)
+        parameter (NH=NFFT/2)
+        parameter (NQ=NFFT/4)
 
-	real data(jz)
-	real s2(nchan,nz)
-	real x(NR)
-	real w1(7),w2(7)
-	real psavg(128)
-	real psavg0(128)
-	real ps2(128)
-	complex c(0:NH)
-	common/acom/a1,a2,a3,a4
-	common/fcom/s(3100),indx(3100)
-	equivalence (x,c)
-	save
+        real data(jz)
+        real s2(nchan,nz)
+        real x(NR)
+        real w1(7),w2(7)
+        real psavg(128)
+        real psavg0(128)
+        real ps2(128)
+        complex c(0:NH)
+        common/acom/a1,a2,a3,a4
+        common/fcom/s(3100),indx(3100)
+        equivalence (x,c)
+        save
 
-	df=11025.0/NFFT
+        df=11025.0/NFFT
 
 C  Compute the 2d spectrogram s2(nchan,nz).  Note that in s2 the frequency
 C  bins are shifted down 5 bins from their natural positions.
 
-	call set(0.0,psavg,NH)
-	do n=1,nz
-	   j=1 + (n-1)*nstep
-	   call move(data(j),x,NFFT)
-	   call xfft(x,NFFT)
+        call set(0.0,psavg,NH)
+        do n=1,nz
+           j=1 + (n-1)*nstep
+           call move(data(j),x,NFFT)
+           call xfft(x,NFFT)
 
-	   sum=0.
-	   do i=1,NQ
-	      s2(i,n)=real(c(5+i))**2 + aimag(c(5+i))**2
-	      sum=sum+s2(i,n)
-	   enddo
-	   s(n)=sum/NQ
+           sum=0.
+           do i=1,NQ
+              s2(i,n)=real(c(5+i))**2 + aimag(c(5+i))**2
+              sum=sum+s2(i,n)
+           enddo
+           s(n)=sum/NQ
 
 C  Accumulate average spectrum for the whole file.
-	   do i=1,nh
-	      psavg0(i) = psavg0(i)+ real(c(i))**2 + aimag(c(i))**2
-	   enddo
-	enddo
+           do i=1,nh
+              psavg0(i) = psavg0(i)+ real(c(i))**2 + aimag(c(i))**2
+           enddo
+        enddo
 
 C  Normalize and save a copy of psavg0 for plotting.  Roll off the
 C  spectrum at 300 and 3000 Hz.
-	do i=1,nh
-	   psavg0(i)=3.e-5*psavg0(i)/nz
-	   f=df*i
-	   fac=1.0
-	   if(f.lt.300.0) fac=f/300.0
-	   if(f.gt.3000.0) fac=max(0.00333,(3300.0-f)/300.0)
-	   psavg0(i)=(fac**2)*psavg0(i)
-	enddo
+        do i=1,nh
+           psavg0(i)=3.e-5*psavg0(i)/nz
+           f=df*i
+           fac=1.0
+           if(f.lt.300.0) fac=f/300.0
+           if(f.gt.3000.0) fac=max(0.00333,(3300.0-f)/300.0)
+           psavg0(i)=(fac**2)*psavg0(i)
+        enddo
 
 C  Compute an average spectrum from the weakest 25% of time slices.
-	call indexx(nz,s,indx)
-	call zero(ps2,NQ)
-	do j=1,nz/4
-	   k=indx(j)
-	   do i=1,NQ
-	      ps2(i+5)=ps2(i+5)+s2(i,k)
-	   enddo
-	enddo
-	ps2(1)=ps2(5)
-	ps2(2)=ps2(5)
-	ps2(3)=ps2(5)
-	ps2(4)=ps2(5)
-	sum=0.
-	do i=6,59
-	   sum=sum+ps2(i)
-	enddo
-	if(sum.eq.0.0) then
-	   sigma=-999.
-	   go to 999
-	endif
+        call indexx(nz,s,indx)
+        call zero(ps2,NQ)
+        do j=1,nz/4
+           k=indx(j)
+           do i=1,NQ
+              ps2(i+5)=ps2(i+5)+s2(i,k)
+           enddo
+        enddo
+        ps2(1)=ps2(5)
+        ps2(2)=ps2(5)
+        ps2(3)=ps2(5)
+        ps2(4)=ps2(5)
+        sum=0.
+        do i=6,59
+           sum=sum+ps2(i)
+        enddo
+        if(sum.eq.0.0) then
+           sigma=-999.
+           go to 999
+        endif
 
 C  Compute a smoothed spectrum without local peaks, and find its max.
-	smaxx=0.
-	do i=4,NQ
-	   sum=0.
-	   do k=1,7
-	      w1(k)=ps2(i+k-4)
-	      sum=sum+w1(k)
-	   enddo
-	   ave=sum/7.0
-	   if(i.ge.14 .and. i.le.58) then
-	      call pctile(w1,w2,7,50,base)
-	      ave=0.25*(w2(1)+w2(2)+w2(3)+w2(4))
-	   endif
-	   psavg(i)=ave
-	   smaxx=max(psavg(i),smaxx)
-	enddo
+        smaxx=0.
+        do i=4,NQ
+           sum=0.
+           do k=1,7
+              w1(k)=ps2(i+k-4)
+              sum=sum+w1(k)
+           enddo
+           ave=sum/7.0
+           if(i.ge.14 .and. i.le.58) then
+              call pctile(w1,w2,7,50,base)
+              ave=0.25*(w2(1)+w2(2)+w2(3)+w2(4))
+           endif
+           psavg(i)=ave
+           smaxx=max(psavg(i),smaxx)
+        enddo
 
 C  Save scale factors for flattening spectra of pings.
-	a1=1.0
-	a2=psavg(nint(2*441/df))/psavg(nint(3*441/df))
-	a3=psavg(nint(2*441/df))/psavg(nint(4*441/df))
-	a4=psavg(nint(2*441/df))/psavg(nint(5*441/df))
-	afac=4.0/(a1+a2+a3+a4)
-	a1=afac*a1
-	a2=afac*a2
-	a3=afac*a3
-	a4=afac*a4
+        a1=1.0
+        a2=psavg(nint(2*441/df))/psavg(nint(3*441/df))
+        a3=psavg(nint(2*441/df))/psavg(nint(4*441/df))
+        a4=psavg(nint(2*441/df))/psavg(nint(5*441/df))
+        afac=4.0/(a1+a2+a3+a4)
+        a1=afac*a1
+        a2=afac*a2
+        a3=afac*a3
+        a4=afac*a4
 
 C  Normalize 2D spectrum by the average based on weakest 25% of time
 C  slices, smoothed, and with local peaks removed.
 
-	do i=1,NQ
-	   do j=1,nz
-	      s2(i,j)=s2(i,j)/max(psavg(i+5),0.01*smaxx)
-	   enddo
-	enddo
+        do i=1,NQ
+           do j=1,nz
+              s2(i,j)=s2(i,j)/max(psavg(i+5),0.01*smaxx)
+           enddo
+        enddo
 
 C  Find average of active spectral region, over the whole file.
-	sum=0.
-	do i=9,52
-	   do j=1,nz
-	      sum=sum+s2(i,j)
-	   enddo
-	enddo
-	sigma=sum/(44*nz)
+        sum=0.
+        do i=9,52
+           do j=1,nz
+              sum=sum+s2(i,j)
+           enddo
+        enddo
+        sigma=sum/(44*nz)
 
- 999	return
-	end
+ 999    return
+        end

Modified: trunk/spec441.f
===================================================================
--- trunk/spec441.f	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/spec441.f	2008-06-07 23:45:35 UTC (rev 862)
@@ -1,37 +1,37 @@
-	subroutine spec441(dat,jz,s,f0)
+        subroutine spec441(dat,jz,s,f0)
 
 C  Computes average spectrum over a range of dat, e.g. for a ping.
 C  Returns spectral array and frequency of peak value.
 
-	parameter (NFFT=256)
-	parameter (NR=NFFT+2)
-	parameter (NH=NFFT/2)
-	real*4 dat(jz)
-	real*4 x(NR),s(NH)
-	complex c(0:NH)
-	equivalence (x,c)
+        parameter (NFFT=256)
+        parameter (NR=NFFT+2)
+        parameter (NH=NFFT/2)
+        real*4 dat(jz)
+        real*4 x(NR),s(NH)
+        complex c(0:NH)
+        equivalence (x,c)
 
-	call zero(s,NH)
-	nz=jz/NFFT
-	do n=1,nz
-	   j=1 + (n-1)*NFFT
-	   call move(dat(j),x,NFFT)
-	   call xfft(x,NFFT)
-	   do i=1,NH
-	      s(i)=s(i)+real(c(i))**2 + aimag(c(i))**2
-	   enddo
-	enddo
+        call zero(s,NH)
+        nz=jz/NFFT
+        do n=1,nz
+           j=1 + (n-1)*NFFT
+           call move(dat(j),x,NFFT)
+           call xfft(x,NFFT)
+           do i=1,NH
+              s(i)=s(i)+real(c(i))**2 + aimag(c(i))**2
+           enddo
+        enddo
 
-	smax=0.
-	df=11025.0/NFFT
-	fac=1.0/(100.0*nfft*nz)
-	do i=1,nh
-	   s(i)=fac*s(i)
-	   if(s(i).gt.smax) then
-	      smax=s(i)
-	      f0=i*df
-	   endif
-	enddo
+        smax=0.
+        df=11025.0/NFFT
+        fac=1.0/(100.0*nfft*nz)
+        do i=1,nh
+           s(i)=fac*s(i)
+           if(s(i).gt.smax) then
+              smax=s(i)
+              f0=i*df
+           endif
+        enddo
 
- 	return
-	end
+        return
+        end

Modified: trunk/wsjt1.F
===================================================================
--- trunk/wsjt1.F	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/wsjt1.F	2008-06-07 23:45:35 UTC (rev 862)
@@ -1,405 +1,405 @@
-	subroutine wsjt1(d,jz0,istart,samfacin,FileID,ndepth,nchallenge,
+        subroutine wsjt1(d,jz0,istart,samfacin,FileID,ndepth,nchallenge,
      +    MinSigdB,NQRN,DFTolerance,MouseButton,NClearAve,nforce,
      +    Mode,NFreeze,NAFC,NZap,mode65,mode4,idf,ntdecode0,
      +    MyCall,HisCall,HisGrid,neme,ntx2,s2,
      +    ps0,npkept,lumsg,basevb,rmspower,nslim2,psavg,ccf,Nseg,
      +    MouseDF,NAgain,LDecoded,nspecial,ndf,ss1,ss2)
 
-!	parameter (NP2=1024*1024)
-	parameter (NP2=120*12000)
+!       lparameter (NP2=1024*1024)
+        parameter (NP2=120*12000)
 
-	integer*2 d(jz0)        !Buffer for raw one-byte data
-	integer istart          !Starting location in original d() array
-	character FileID*40     !Name of file being processed
-	integer MinSigdB        !Minimum ping strength, dB
-	integer NQRN            !QRN rejection parameter
-	integer DFTolerance     !Defines DF search range
-	integer NSyncOK         !Set to 1 if JT65 file synchronized OK
-	character*12 mycall
-	character*12 hiscall
-	character*6 hisgrid
-	real ps0(431)           !Spectrum of best ping
-	integer npkept          !Number of pings kept and decoded
-	integer lumsg           !Logical unit for decoded.txt
-	real basevb             !Baseline signal level, dB
-	integer nslim2          !Minimum strength for single-tone pings, dB
-	real psavg(450)         !Average spectrum of the whole file
-	integer Nseg            !First or second Tx sequence?
-	integer MouseDF         !Freeze position for DF
-	logical pick            !True if this is a mouse-picked ping
-	logical stbest          !True if the best decode was Single-Tone
-	logical STfound         !True if at least one ST decode
-	logical LDecoded        !True if anything was decoded
-	real s2(64,3100)        !2D spectral array
-	real ccf(-5:540)        !X-cor function in JT65 mode (blue line)
-	real red(512)
-	real ss1(-224:224)	!Magenta curve (for JT65 shorthands)
-	real ss2(-224:224)	!Orange curve (for JT65 shorthands)
-	real yellow(216)
-	real yellow0(216)
-	real fzap(200)
-	integer resample
-	real*8 samfacin,samratio
-	real dat2(NP2)
-	character msg3*3
-	character cfile6*6
-	logical lcum
-	integer indx(100)
-	character*90 line
-	common/avecom/dat(NP2),labdat,jza,modea
-	common/ccom/nline,tping(100),line(100)
-	common/limcom/ nslim2a
-	common/extcom/ntdecode
-	common/clipcom/ nclip
-	save
+        integer*2 d(jz0)        !Buffer for raw one-byte data
+        integer istart          !Starting location in original d() array
+        character FileID*40     !Name of file being processed
+        integer MinSigdB        !Minimum ping strength, dB
+        integer NQRN            !QRN rejection parameter
+        integer DFTolerance     !Defines DF search range
+        integer NSyncOK         !Set to 1 if JT65 file synchronized OK
+        character*12 mycall
+        character*12 hiscall
+        character*6 hisgrid
+        real ps0(431)           !Spectrum of best ping
+        integer npkept          !Number of pings kept and decoded
+        integer lumsg           !Logical unit for decoded.txt
+        real basevb             !Baseline signal level, dB
+        integer nslim2          !Minimum strength for single-tone pings, dB
+        real psavg(450)         !Average spectrum of the whole file
+        integer Nseg            !First or second Tx sequence?
+        integer MouseDF         !Freeze position for DF
+        logical pick            !True if this is a mouse-picked ping
+        logical stbest          !True if the best decode was Single-Tone
+        logical STfound         !True if at least one ST decode
+        logical LDecoded        !True if anything was decoded
+        real s2(64,3100)        !2D spectral array
+        real ccf(-5:540)        !X-cor function in JT65 mode (blue line)
+        real red(512)
+        real ss1(-224:224)      !Magenta curve (for JT65 shorthands)
+        real ss2(-224:224)      !Orange curve (for JT65 shorthands)
+        real yellow(216)
+        real yellow0(216)
+        real fzap(200)
+        integer resample
+        real*8 samfacin,samratio
+        real dat2(NP2)
+        character msg3*3
+        character cfile6*6
+        logical lcum
+        integer indx(100)
+        character*90 line
+        common/avecom/dat(NP2),labdat,jza,modea
+        common/ccom/nline,tping(100),line(100)
+        common/limcom/ nslim2a
+        common/extcom/ntdecode
+        common/clipcom/ nclip
+        save
 
-	lcum=.true.
-	jz=jz0
-	ntdecode=ntdecode0
-	modea=Mode
-	nclip=NQRN-5
-	nslim2a=nclip
-	MinWidth=40                            !Minimum width of pings, ms
-	call zero(psavg,450)
-	rewind 11
-	rewind 12
+        lcum=.true.
+        jz=jz0
+        ntdecode=ntdecode0
+        modea=Mode
+        nclip=NQRN-5
+        nslim2a=nclip
+        MinWidth=40                            !Minimum width of pings, ms
+        call zero(psavg,450)
+        rewind 11
+        rewind 12
 
- 	do i=1,40
-	   if(FileID(i:i).eq.'.') go to 3
-	enddo
-	i=4
- 3	ia=max(1,i-6)
+        do i=1,40
+           if(FileID(i:i).eq.'.') go to 3
+        enddo
+        i=4
+ 3      ia=max(1,i-6)
         cfile6=FileID(ia:i-1)
 
-	nline=0
-	ndiag=0
+        nline=0
+        ndiag=0
 ! If file &quot;/wsjt.reg&quot; exists, set ndiag=1
-	open(16,file='/wsjt.reg',status='old',err=4)
-	ndiag=1
-	close(16)
+        open(16,file='/wsjt.reg',status='old',err=4)
+        ndiag=1
+        close(16)
 
- 4	if(mode.lt.8 .and. jz.gt.655360) jz=655360
-	if(mode.eq.4 .and. jz.gt.330750) jz=330750	!### Fix this!
- 	if(mode.eq.8 .and. jz.gt.1323000) jz=1323000
+ 4      if(mode.lt.8 .and. jz.gt.655360) jz=655360
+        if(mode.eq.4 .and. jz.gt.330750) jz=330750      !### Fix this!
+        if(mode.eq.8 .and. jz.gt.1323000) jz=1323000
 
-	sum=0.
-	do j=1,jz            !Convert raw data from i*2 to real, remove DC
+        sum=0.
+        do j=1,jz            !Convert raw data from i*2 to real, remove DC
            dat(j)=0.1*d(j)
-	   sum=sum + dat(j)
-	enddo
-	ave=sum/jz
-	samratio=1.d0/samfacin
-	if(samratio.eq.1.d0) then
-	   do j=1,jz
-	      dat(j)=dat(j)-ave
-	   enddo
-	else
-	   do j=1,jz
-	      dat2(j)=dat(j)-ave
-	   enddo
-	   ierr=resample(dat2,dat,samratio,jz)
-	   if(ierr.ne.0) print*,'Resample error.',samratio
-	endif
+           sum=sum + dat(j)
+        enddo
+        ave=sum/jz
+        samratio=1.d0/samfacin
+        if(samratio.eq.1.d0) then
+           do j=1,jz
+              dat(j)=dat(j)-ave
+           enddo
+        else
+           do j=1,jz
+              dat2(j)=dat(j)-ave
+           enddo
+           ierr=resample(dat2,dat,samratio,jz)
+           if(ierr.ne.0) print*,'Resample error.',samratio
+        endif
 
-	if(ndiag.ne.0 .and. nclip.lt.0) then
+        if(ndiag.ne.0 .and. nclip.lt.0) then
 C  Intentionally degrade SNR by -nclip dB.
-	   sq=0.
-	   do i=1,jz
-	      sq=sq + dat(i)**2
-	   enddo
-	   p0=sq/jz
-	   p1=p0*10.0**(-0.1*nclip)
-	   dnoise=sqrt(4*(p1-p0))
-	   idum=-1
-	   do i=1,jz
-	      dat(i)=dat(i) + dnoise*gran(idum)
-	   enddo
-	endif
+           sq=0.
+           do i=1,jz
+              sq=sq + dat(i)**2
+           enddo
+           p0=sq/jz
+           p1=p0*10.0**(-0.1*nclip)
+           dnoise=sqrt(4*(p1-p0))
+           idum=-1
+           do i=1,jz
+              dat(i)=dat(i) + dnoise*gran(idum)
+           enddo
+        endif
 
-	if(mode.ne.2 .and. nzap.ne.0) then
-	   nfrz=NFreeze
-	   if(mode.eq.1) nfrz=0
-	   if(jz.gt.100000) call avesp2(dat,jz,2,mode,nfrz,MouseDF,
+        if(mode.ne.2 .and. nzap.ne.0) then
+           nfrz=NFreeze
+           if(mode.eq.1) nfrz=0
+           if(jz.gt.100000) call avesp2(dat,jz,2,mode,nfrz,MouseDF,
      +         DFTolerance,fzap)
-	   nadd=1
- 	   call bzap(dat,jz,nadd,mode,fzap)
-	endif
+           nadd=1
+           call bzap(dat,jz,nadd,mode,fzap)
+        endif
 
-	sq=0.
-	do j=1,jz                  !Compute power level for whole array
-	   sq=sq + dat(j)**2
-	enddo
-	avesq=sq/jz
-	basevb=dB(avesq) - 44    !Base power level to send back to GUI
-	if(avesq.eq.0) go to 900
+        sq=0.
+        do j=1,jz                  !Compute power level for whole array
+           sq=sq + dat(j)**2
+        enddo
+        avesq=sq/jz
+        basevb=dB(avesq) - 44    !Base power level to send back to GUI
+        if(avesq.eq.0) go to 900
 
-	nz=600
-	nstep=jz/nz
-	sq=0.
-	k=0
-	do j=1,nz
-	   sum=0.
-	   do n=1,nstep
-	      k=k+1
-	      sum=sum+dat(k)**2
-	   enddo
-	   sum=sum/nstep
-	   sq=sq + (sum-avesq)**2
-	enddo
-	rmspower=sqrt(sq/nz)
+        nz=600
+        nstep=jz/nz
+        sq=0.
+        k=0
+        do j=1,nz
+           sum=0.
+           do n=1,nstep
+              k=k+1
+              sum=sum+dat(k)**2
+           enddo
+           sum=sum/nstep
+           sq=sq + (sum-avesq)**2
+        enddo
+        rmspower=sqrt(sq/nz)
 
-	pick=.false.
-	if(istart.gt.1) pick=.true. !This is a mouse-picked decoding
-   	if(.not.pick .and. nforce.eq.0 .and. 
+        pick=.false.
+        if(istart.gt.1) pick=.true. !This is a mouse-picked decoding
+        if(.not.pick .and. nforce.eq.0 .and. 
      +     (basevb.lt.-15.0 .or. basevb.gt.20.0)) goto 900
-	nchan=64                   !Save 64 spectral channels
-	nstep=221                  !Set step size to ~20 ms
-	nz=jz/nstep - 1            !# of spectra to compute
-	if(.not.pick) then
-	   MouseButton=0
-	   jza=jz
-	   labdat=labdat+1
-	endif
-	tbest=0.
+        nchan=64                   !Save 64 spectral channels
+        nstep=221                  !Set step size to ~20 ms
+        nz=jz/nstep - 1            !# of spectra to compute
+        if(.not.pick) then
+           MouseButton=0
+           jza=jz
+           labdat=labdat+1
+        endif
+        tbest=0.
         NsyncOK=0
 
 !  If we're in JT65 mode, call the decode65 routines.
-  	if(mode.eq.2) then
-! 	   if(rmspower.gt.34000.0) go to 900     !Reject very noisy data
+        if(mode.eq.2) then
+!          if(rmspower.gt.34000.0) go to 900     !Reject very noisy data
 !  Check for a JT65 shorthand message
- 	   nstest=0
- 	   if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
+           nstest=0
+           if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
      +        DFTolerance,mode65,nspecial,nstest,dfsh,iderrsh,
      +        idriftsh,snrsh,ss1,ss2,nwsh,idfsh)
 !  Lowpass filter and decimate by 2
- 	   call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
-	   idf=mousedf-mousedf2
- 	   jz=jz2
- 	   nadd=1
- 	   fzap(1)=0.
- 	   if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
+           call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
+           idf=mousedf-mousedf2
+           jz=jz2
+           nadd=1
+           fzap(1)=0.
+           if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
      +       DFTolerance,fzap)
-    	   if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
+       if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
 
- 	   i=index(MyCall,char(0))
-	   if(i.le.0) i=index(MyCall,' ')
- 	   mycall=MyCall(1:i-1)//'            '
- 	   i=index(HisCall,char(0))
-	   if(i.le.0) i=index(HisCall,' ')
- 	   hiscall=HisCall(1:i-1)//'            '
+           i=index(MyCall,char(0))
+           if(i.le.0) i=index(MyCall,' ')
+           mycall=MyCall(1:i-1)//'            '
+           i=index(HisCall,char(0))
+           if(i.le.0) i=index(HisCall,' ')
+           hiscall=HisCall(1:i-1)//'            '
 
 !  Offset data by about 1 s.
-! 	    jztest=126*2048
-	   jztest=11025*ntdecode/2 - 2755
- 	   if(jz.ge.jztest) call wsjt65(dat(4097),jz-4096,cfile6,
+!           jztest=126*2048
+           jztest=11025*ntdecode/2 - 2755
+           if(jz.ge.jztest) call wsjt65(dat(4097),jz-4096,cfile6,
      +        NClearAve,MinSigdB,DFTolerance,NFreeze,NAFC,mode65,Nseg,
      +        MouseDF2,NAgain,ndepth,nchallenge,neme,idf,idfsh,
      +        mycall,hiscall,hisgrid,lumsg,lcum,nspecial,ndf,
      +        nstest,dfsh,snrsh,
      +        NSyncOK,ccf,psavg,ndiag,nwsh)
- 	   goto 900
- 	endif
+           goto 900
+        endif
 
 ! If we're in JT6M mode, call the 6M decoding routines.
-	if(mode.eq.4) then
-	   do i=1,jz                    !### Why is it level-sensitive?
-	      dat(i)=dat(i)/25.0
-	   enddo
+        if(mode.eq.4) then
+           do i=1,jz                    !### Why is it level-sensitive?
+              dat(i)=dat(i)/25.0
+           enddo
 ! For waterfall plot
-	   call spec2d(dat,jz,nstep,s2,nchan,nz,psavg,sigma)
-	   if(sigma.lt.0.0) basevb=-99.0
-	   if(jz/11025.0.lt.3.9 .or. sigma.lt.0.0) go to 900
+           call spec2d(dat,jz,nstep,s2,nchan,nz,psavg,sigma)
+           if(sigma.lt.0.0) basevb=-99.0
+           if(jz/11025.0.lt.3.9 .or. sigma.lt.0.0) go to 900
 
-	   f0=1076.66
-	   if(NFreeze.eq.1) f0=1076.66 + MouseDF
-	   f00=f0
-	   call syncf0(dat,jz,NFreeze,DFTolerance,jstart,f0,smax)
-	   call synct(dat,jz,jstart,f0,smax)
-	   call syncf1(dat,jz,jstart,f0,NFreeze,DFTolerance,smax,red)
+           f0=1076.66
+           if(NFreeze.eq.1) f0=1076.66 + MouseDF
+           f00=f0
+           call syncf0(dat,jz,NFreeze,DFTolerance,jstart,f0,smax)
+           call synct(dat,jz,jstart,f0,smax)
+           call syncf1(dat,jz,jstart,f0,NFreeze,DFTolerance,smax,red)
 
-	   do i=1,512
-	      ccf(i-6)=dB(red(i))
-	   enddo
-	   df=11025./256.
-	   do i=1,64
-	      sum=0.
-	      do k=8*i-7,8*i
-		 sum=sum+red(k)
-	      enddo
-	      psavg(i)=5.0*sum
-	      fac=1.0
-	      freq=i*df
-	      if(freq.gt.2500.0) fac=((freq-2500.)/20.0)**(-1.0)
-	      psavg(i)=fac*psavg(i)
-	      psavg(i+64)=0.001
-	   enddo
+           do i=1,512
+              ccf(i-6)=dB(red(i))
+           enddo
+           df=11025./256.
+           do i=1,64
+              sum=0.
+              do k=8*i-7,8*i
+                 sum=sum+red(k)
+              enddo
+              psavg(i)=5.0*sum
+              fac=1.0
+              freq=i*df
+              if(freq.gt.2500.0) fac=((freq-2500.)/20.0)**(-1.0)
+              psavg(i)=fac*psavg(i)
+              psavg(i+64)=0.001
+           enddo
 
-	   jz=jz-jstart+1
-	   nslim=MinSigdB
-	   NFixLen=0
+           jz=jz-jstart+1
+           nslim=MinSigdB
+           NFixLen=0
 
 C  Call the decoder if DF is in range or Freeze is off.
- 	   if(NFreeze.eq.0 .or. 
+           if(NFreeze.eq.0 .or. 
      +         abs(f0-f00).lt.float(DFTolerance)) then
-	      call decode6m(dat(jstart),jz,cfile6,nslim,istart,
+              call decode6m(dat(jstart),jz,cfile6,nslim,istart,
      +            NFixLen,lcum,f0,lumsg,npkept,yellow)
-	   endif
+           endif
 
-	   if(pick) then
-	      do i=1,216
-		 ps0(i)=yellow0(i)
-	      enddo
-	   else
-	      ps0(216)=yellow(216)
-	      yellow0(216)=yellow(216)
-	      do i=1,215
-		 ps0(i)=2*yellow(i)
-		 yellow0(i)=ps0(i)
-	      enddo
-	   endif
-	   goto 800
-	endif
+           if(pick) then
+              do i=1,216
+                 ps0(i)=yellow0(i)
+              enddo
+           else
+              ps0(216)=yellow(216)
+              yellow0(216)=yellow(216)
+              do i=1,215
+                 ps0(i)=2*yellow(i)
+                 yellow0(i)=ps0(i)
+              enddo
+           endif
+           goto 800
+        endif
 
-	if(mode.eq.5) then
+        if(mode.eq.5) then
 !  We're in CW mode.
-! 	   call decodecw(dat,jz,cfile6,DFTolerance,NFreeze,
+!          call decodecw(dat,jz,cfile6,DFTolerance,NFreeze,
 !     +        MouseDF2,mycall,hiscall,hisgrid)
-	   go to 900
-	endif
+           go to 900
+        endif
 
 !  If we're in JT2 or JT4 mode, call the decode24 routines.
-  	if(mode.eq.6 .or. mode.eq.7) then
+        if(mode.eq.6 .or. mode.eq.7) then
 !  Lowpass filter and decimate by 2
- 	   call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
-	   idf=mousedf-mousedf2
- 	   jz=jz2
- 	   nadd=1
- 	   fzap(1)=0.
- 	   if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
+           call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
+           idf=mousedf-mousedf2
+           jz=jz2
+           nadd=1
+           fzap(1)=0.
+           if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
      +       DFTolerance,fzap)
-    	   if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
+      if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
 
- 	   i=index(MyCall,char(0))
-	   if(i.le.0) i=index(MyCall,' ')
- 	   mycall=MyCall(1:i-1)//'            '
- 	   i=index(HisCall,char(0))
-	   if(i.le.0) i=index(HisCall,' ')
- 	   hiscall=HisCall(1:i-1)//'            '
+           i=index(MyCall,char(0))
+           if(i.le.0) i=index(MyCall,' ')
+           mycall=MyCall(1:i-1)//'            '
+           i=index(HisCall,char(0))
+           if(i.le.0) i=index(HisCall,' ')
+           hiscall=HisCall(1:i-1)//'            '
 
 !  Offset data by about 1 s.
-	   jztest=165000
- 	   if(jz.ge.jztest) call wsjt24(dat(4097),jz-4096,cfile6,
+           jztest=165000
+           if(jz.ge.jztest) call wsjt24(dat(4097),jz-4096,cfile6,
      +        NClearAve,MinSigdB,DFTolerance,NFreeze,NAFC,mode,mode4,
      +        Nseg,MouseDF2,NAgain,ndepth,neme,idf,mycall,hiscall,
      +        hisgrid,lumsg,lcum,nspecial,ndf,NSyncOK,ccf,psavg,ndiag)
- 	   goto 900
-	endif
+           goto 900
+        endif
 
 !  If we're in WSPR mode, call the wspr routines.
-  	if(mode.eq.8) then
- 	   i=index(MyCall,char(0))
-	   if(i.le.0) i=index(MyCall,' ')
- 	   mycall=MyCall(1:i-1)//'            '
-	   call wsjtwspr(dat,jz,cfile6,ndiag)
- 	   goto 900
- 	endif
+        if(mode.eq.8) then
+           i=index(MyCall,char(0))
+           if(i.le.0) i=index(MyCall,' ')
+           mycall=MyCall(1:i-1)//'            '
+           call wsjtwspr(dat,jz,cfile6,ndiag)
+           goto 900
+        endif
 
 !  JT64 mode:
-  	if(mode.eq.9) then
-	   mode64=1
- 	   nstest=0
- 	   if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
+        if(mode.eq.9) then
+           mode64=1
+           nstest=0
+           if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
      +        DFTolerance,mode64,nspecial,nstest,dfsh,iderrsh,
      +        idriftsh,snrsh,ss1,ss2,nwsh,idfsh)
 !  Lowpass filter and decimate by 2
- 	   call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
-	   idf=mousedf-mousedf2
- 	   jz=jz2
- 	   nadd=1
- 	   fzap(1)=0.
- 	   if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
+           call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
+           idf=mousedf-mousedf2
+           jz=jz2
+           nadd=1
+           fzap(1)=0.
+           if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
      +       DFTolerance,fzap)
-    	   if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
+      if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
 
- 	   i=index(MyCall,char(0))
-	   if(i.le.0) i=index(MyCall,' ')
- 	   mycall=MyCall(1:i-1)//'            '
- 	   i=index(HisCall,char(0))
-	   if(i.le.0) i=index(HisCall,' ')
- 	   hiscall=HisCall(1:i-1)//'            '
+           i=index(MyCall,char(0))
+           if(i.le.0) i=index(MyCall,' ')
+           mycall=MyCall(1:i-1)//'            '
+           i=index(HisCall,char(0))
+           if(i.le.0) i=index(HisCall,' ')
+           hiscall=HisCall(1:i-1)//'            '
 
 !  Offset data by about 1 s.
-! 	    jztest=126*2048
-	   jztest=11025*ntdecode/2 - 2755
- 	   if(jz.ge.jztest) call wsjt64(dat(4097),jz-4096,cfile6,
+!           jztest=126*2048
+           jztest=11025*ntdecode/2 - 2755
+           if(jz.ge.jztest) call wsjt64(dat(4097),jz-4096,cfile6,
      +        NClearAve,MinSigdB,DFTolerance,NFreeze,NAFC,mode64,Nseg,
      +        MouseDF2,NAgain,ndepth,nchallenge,neme,idf,idfsh,
      +        mycall,hiscall,hisgrid,lumsg,lcum,nspecial,ndf,
      +        nstest,dfsh,snrsh,
      +        NSyncOK,ccf,psavg,ndiag,nwsh)
- 	   goto 900
+           goto 900
 
- 	endif
+        endif
 
 !  We're in FSK441 mode. Compute the 2D spectrum.
-	df=11025.0/256.0            !FFT resolution ~43 Hz
-	dtbuf=nstep/11025.0
-	stlim=nslim2                !Single-tone threshold
-	call spec2d(dat,jz,nstep,s2,nchan,nz,psavg,sigma)
-	if(sigma.lt.0.0) basevb=-99.0
-	if(sigma.lt.0.0) go to 900
-	nline0=nline
-	STfound=.false.
-	npkept=0
+        df=11025.0/256.0            !FFT resolution ~43 Hz
+        dtbuf=nstep/11025.0
+        stlim=nslim2                !Single-tone threshold
+        call spec2d(dat,jz,nstep,s2,nchan,nz,psavg,sigma)
+        if(sigma.lt.0.0) basevb=-99.0
+        if(sigma.lt.0.0) go to 900
+        nline0=nline
+        STfound=.false.
+        npkept=0
 
 C  Look for single-tone messages
-	if((.not.pick) .or. MouseButton.eq.1) then
-	   call stdecode(s2,nchan,nz,sigma,dtbuf,df,stlim,
+        if((.not.pick) .or. MouseButton.eq.1) then
+           call stdecode(s2,nchan,nz,sigma,dtbuf,df,stlim,
      +       DFTolerance,cfile6,pick,istart)
-	endif
-	if(nline.gt.nline0) STfound=.true.  !ST message(s) found
+        endif
+        if(nline.gt.nline0) STfound=.true.  !ST message(s) found
 
 C  Now the multi-tone decoding
-	call mtdecode(dat,jz,nz,MinSigdB,MinWidth,
+        call mtdecode(dat,jz,nz,MinSigdB,MinWidth,
      +    NQRN,DFTolerance,istart,pick,cfile6,ps0)
 
-	npkept=nline             !Number of pings that were kept
-	smax=0.
-	stbest=.false.
-	if(npkept.gt.0) then
-	   call indexx(npkept,tping,indx) !Merge the ST and MT decodes
-	   do i=1,npkept
-	      j=indx(i)
-	      if(pick .and. STFound .and.
+        npkept=nline             !Number of pings that were kept
+        smax=0.
+        stbest=.false.
+        if(npkept.gt.0) then
+           call indexx(npkept,tping,indx) !Merge the ST and MT decodes
+           do i=1,npkept
+              j=indx(i)
+              if(pick .and. STFound .and.
      +          line(j)(29:31).eq.'   ') goto 10
-	      write(lumsg,1050) line(j)	!Write to decoded.txt
- 1050	      format(a79)
-	      if(lcum) write(21,1050) line(j) !Write to ALL.TXT
-	      read(line(j),1060) sig,msg3
- 1060	      format(16x,f3.0,9x,a3)
-	      if(sig.gt.smax) then
-		 smax=sig
-		 tbest=tping(j)
-		 stbest = (msg3.ne.'   ')
-	      endif
- 10	   enddo
-	endif
+              write(lumsg,1050) line(j) !Write to decoded.txt
+ 1050         format(a79)
+              if(lcum) write(21,1050) line(j) !Write to ALL.TXT
+              read(line(j),1060) sig,msg3
+ 1060         format(16x,f3.0,9x,a3)
+              if(sig.gt.smax) then
+                 smax=sig
+                 tbest=tping(j)
+                 stbest = (msg3.ne.'   ')
+              endif
+ 10        enddo
+        endif
 
-	dt=1.0/11025.0                !Compute spectrum for pink curve
-	if(stbest) then
-	   jj=nint(tbest/dt)
-	   call spec441(dat(jj),1102,ps0,f0)
-	endif
+        dt=1.0/11025.0                !Compute spectrum for pink curve
+        if(stbest) then
+           jj=nint(tbest/dt)
+           call spec441(dat(jj),1102,ps0,f0)
+        endif
 
- 800	continue
+ 800    continue
         call s2shape(s2,nchan,nz,tbest)
 
- 900	LDecoded = ((NSyncOK.gt.0) .or. npkept.gt.0)
-	end file 11
-	call flushqqq(11)
-	call flushqqq(12)
-	call flushqqq(21)
+ 900    LDecoded = ((NSyncOK.gt.0) .or. npkept.gt.0)
+        end file 11
+        call flushqqq(11)
+        call flushqqq(12)
+        call flushqqq(21)
 
- 	return
- 	end
+        return
+        end
 

Modified: trunk/wsjtgen.F90
===================================================================
--- trunk/wsjtgen.F90	2008-06-07 22:29:31 UTC (rev 861)
+++ trunk/wsjtgen.F90	2008-06-07 23:45:35 UTC (rev 862)
@@ -75,21 +75,21 @@
 
 #else
         tfile2=testfile
-	call rfile2(tfile2,hdr,44+2*120*12000,nr)
-	if(nr.le.0) then
+        call rfile2(tfile2,hdr,44+2*120*12000,nr)
+        if(nr.le.0) then
            print*,'Error reading ',testfile
-	   stop
+           stop
         endif
-	do i=1,ndata/2
-	   iwave(i)=jwave(i)
+        do i=1,ndata/2
+           iwave(i)=jwave(i)
         enddo
 #endif
         nwave=ndata/2
         do i=nwave,NTXMAX
            iwave(i)=0
         enddo
-	sending=txmsg
-	sendingsh=2
+        sending=txmsg
+        sendingsh=2
         go to 999
      endif
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000546.html">[WSJT-SVN] r861 - trunk
</A></li>
	<LI>Next message: <A HREF="000547.html">[WSJT-SVN] r863 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#552">[ date ]</a>
              <a href="thread.html#552">[ thread ]</a>
              <a href="subject.html#552">[ subject ]</a>
              <a href="author.html#552">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
