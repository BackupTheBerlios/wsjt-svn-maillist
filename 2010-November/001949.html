<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2257 - branches/map65iq
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2010-November/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2257%20-%20branches/map65iq&In-Reply-To=%3C20101119181956.7E78D48032B%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001948.html">
   <LINK REL="Next"  HREF="001950.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2257 - branches/map65iq</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2257%20-%20branches/map65iq&In-Reply-To=%3C20101119181956.7E78D48032B%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r2257 - branches/map65iq">k1jt at mail.berlios.de
       </A><BR>
    <I>Fri Nov 19 19:19:56 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001948.html">[WSJT-SVN] r2256 - branches/map65iq
</A></li>
        <LI>Next message: <A HREF="001950.html">[WSJT-SVN] r2258 - branches/map65iq
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1949">[ date ]</a>
              <a href="thread.html#1949">[ thread ]</a>
              <a href="subject.html#1949">[ subject ]</a>
              <a href="author.html#1949">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2010-11-19 19:19:55 +0100 (Fri, 19 Nov 2010)
New Revision: 2257

Added:
   branches/map65iq/astro.f
   branches/map65iq/astro0.f90
   branches/map65iq/decode1.f90
   branches/map65iq/deep65.f
   branches/map65iq/display.f90
   branches/map65iq/fivehz.f90
   branches/map65iq/flushqqq.f90
   branches/map65iq/fthread.c
   branches/map65iq/ftn_init.f90
   branches/map65iq/getfile.f90
   branches/map65iq/getfile2.f90
   branches/map65iq/map65a.f90
   branches/map65iq/plrr.f90
   branches/map65iq/plrs.f90
   branches/map65iq/recvpkt.f90
   branches/map65iq/rfile3a.f90
   branches/map65iq/runqqq.f90
   branches/map65iq/savetf2.f90
   branches/map65iq/sec_midn.f90
   branches/map65iq/thnix.f90
   branches/map65iq/wsjtgen.f90
Removed:
   branches/map65iq/astro.F
   branches/map65iq/astro0.F90
   branches/map65iq/audio_init.F90
   branches/map65iq/decode1.F90
   branches/map65iq/deep65.F
   branches/map65iq/display.F90
   branches/map65iq/fivehz.F90
   branches/map65iq/flushqqq.F90
   branches/map65iq/fstatqqq.f90
   branches/map65iq/ftn_init.F90
   branches/map65iq/getfile.F90
   branches/map65iq/getfile2.F90
   branches/map65iq/map65a.F90
   branches/map65iq/plrr.F90
   branches/map65iq/plrs.F90
   branches/map65iq/recvpkt.F90
   branches/map65iq/rfile3a.F90
   branches/map65iq/runqqq.F90
   branches/map65iq/savetf2.F90
   branches/map65iq/sec_midn.F90
   branches/map65iq/wsjtgen.F90
Modified:
   branches/map65iq/Makefile.in
   branches/map65iq/a2d.f90
   branches/map65iq/extract.f
   branches/map65iq/map65.py
   branches/map65iq/plrs_subs.c
   branches/map65iq/rfile.f90
   branches/map65iq/specjt.py
   branches/map65iq/start_portaudio.c
   branches/map65iq/symspec.f90
   branches/map65iq/sysqqq.f90
Log:
Eliminate all &quot;CVF&quot; stuff.
Add cs_lock/cs_unlock calls.
Other code cleanup.


Modified: branches/map65iq/Makefile.in
===================================================================
--- branches/map65iq/Makefile.in	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/Makefile.in	2010-11-19 18:19:55 UTC (rev 2257)
@@ -10,13 +10,6 @@
 CFLAGS += ${DEFS}
 CPPFLAGS += ${DEFS} -I.
 
-# WSJT specific Fortran flags
-#FFLAGS += -Wall -fbounds-check -fno-second-underscore -fPIC
-#FFLAGS += -Wall -Wno-precision-loss -fbounds-check -fno-second-underscore -fPIC
-#FFLAGS += -Wall -fbounds-check -fno-second-underscore -ffixed-line-length-none -fPIC
-#FFLAGS += -Wall -fbounds-check -fno-second-underscore -fPIC
-#FFLAGS += -cpp -fno-second-underscore
-
 all:    Audio.so plrs plrr
 
 # The default rules
@@ -41,16 +34,16 @@
 
 ###
 
-OBJS2C   = init_rs.o encode_rs.o decode_rs.o plrr_subs.o loc.o deep65.o
+OBJS2C   = init_rs.o encode_rs.o decode_rs.o plrr_subs.o loc.o \
+	deep65.o fthread.o
 
 F2PYONLY = ftn_init ftn_quit audio_init getfile azdist0 astro0 spec
 
-SRCS2F90 = astro0.F90 audio_init.F90 azdist0.f90 \
-	decode1.F90 ftn_init.F90 ftn_quit.f90 wsjtgen.F90 \
-	runqqq.F90 fivehz.F90 flushqqq.F90 \
-	rfile.f90 rfile3a.F90 spec.f90 map65a.F90 display.F90 \
-	getfile.F90 getfile2.F90 recvpkt.F90 savetf2.F90 \
-	symspec.f90 sec_midn.F90
+SRCS2F90 = astro0.f90 audio_init.f90 azdist0.f90 decode1.f90 \
+	ftn_init.f90 ftn_quit.f90 wsjtgen.f90 runqqq.f90 fivehz.f90 \
+	rfile.f90 rfile3a.f90 spec.f90 map65a.f90 display.f90 \
+	getfile.f90 getfile2.f90 recvpkt.f90 savetf2.f90 \
+	symspec.f90 sec_midn.f90 thnix.f90
 
 SRCS2F77 = indexx.f gen65.f chkmsg.f \
 	gentone.f gencwid.f set.f db.f pctile.f sort.f ssort.f \
@@ -65,30 +58,15 @@
 	filbig.f fil6521.f twkfreq.f decode65b.f \
 	afc65b.f fchisq.f ccf2.f rfile2.f
 
-SRCS2C   = ptt.c igray.c wrapkarn.c rfile3.c wfile3.c
-
 OBJS2F77 = ${SRCS2F77:.f=.o}
 
 SRCS3C = ptt_unix.c igray.c wrapkarn.c cutil.c
 OBJS3C = ${SRCS3C:.c=.o}
 AUDIOSRCS = a2d.f90 jtaudio.c start_portaudio.c
 
-#Audio.so: $(OBJS2C) $(SRCS2F90) $(SRCS2F77) $(SRCS2C)
-#	python f2py.py -c \
-#	--quiet --&quot;fcompiler=compaqv&quot; \
-#	--opt=&quot;/nologo /traceback /warn:errors /fast /fpp /define:Win32 \
-#	      /define:USE_PORTAUDIO&quot; \
-#	$(OBJS2C) \
-#	-lwinmm -lpa -lfftw3single -llibsamplerate \
-#	-m Audio \
-#	only: $(F2PYONLY) : \
-#	$(SRCS2F90) $(SRCS2F77) $(SRCS2C)
+deep65.o: deep65.f
+	$(FC) -c -O0 -fno-second-underscore -Wall -fPIC deep65.f
 
-###
-
-deep65.o: deep65.F
-	$(FC) -c -O0 -Wall -fPIC deep65.F
-
 Audio.so: $(OBJS2C) $(OBJS3C) $(OBJS2F77) $(SRCS2F90) $(AUDIOSRCS)
 	 ${F2PY} -c --quiet --opt=&quot;-O ${CFLAGS} \
 	-fno-second-underscore&quot;	$(OBJS2C) $(OBJS2F77) -m Audio \
@@ -105,17 +83,17 @@
 decode_rs_int.o: decode_rs.c
 	$(CC) $(CFLAGS) -c -DBIGSYM=1 -o decode_rs_int.o decode_rs.c
 
-plrr:   plrr.F90 sec_midn.F90 plrr_subs.c cutil.c
+plrr:   plrr.f90 sec_midn.f90 plrr_subs.c cutil.c
 	$(CC) -c plrs_subs.c cutil.c
-	$(FC) -o plrr -fno-second-underscore plrr.F90 sec_midn.F90 plrr_subs.o cutil.o
+	$(FC) -o plrr -fno-second-underscore plrr.f90 sec_midn.f90 plrr_subs.o cutil.o
 
-plrs:   plrs.F90 sec_midn.F90 plrs_subs.c cutil.c
+plrs:   plrs.f90 sec_midn.f90 plrs_subs.c cutil.c
 	$(CC) -c plrs_subs.c cutil.c
-	$(FC) -o plrs -fno-second-underscore plrs.F90 sec_midn.F90 plrs_subs.o cutil.o
+	$(FC) -o plrs -fno-second-underscore plrs.f90 sec_midn.f90 plrs_subs.o cutil.o
 
 .PHONY : clean
 clean:
-	${RM} -f *.o *.pyc *.so *~ map65 map65.spec
+	${RM} -f *.o *.pyc *.so *~ map65 map65.spec plrs plrr
 
 distclean: clean
 	${RM} -f config.log config.status Makefile

Modified: branches/map65iq/a2d.f90
===================================================================
--- branches/map65iq/a2d.f90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/a2d.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,4 +1,3 @@
-!---------------------------------------------------- a2d
 subroutine a2d(iarg)
 
 ! Start the PortAudio streams for audio input and output.
@@ -9,26 +8,32 @@
 ! This call does not normally return, as the background portion of
 ! JTaudio goes into a test-and-sleep loop.
 
+  call cs_lock('a2d')
   write(*,1000)
 1000 format('Using Linrad for input, PortAudio for output.')
   idevout=ndevout
   call padevsub(numdevs,ndefin,ndefout,nchin,nchout)
-  
-  write(*,1002) ndefout
+    write(*,1002) ndefout
 1002 format(/'Default Output:',i3)
   write(*,1004) idevout
 1004 format('Requested Output:',i3)
+  call cs_unlock
+
   if(idevout.lt.0 .or. idevout.ge.numdevs) idevout=ndefout
   if(idevout.eq.0) idevout=ndefout
   idevin=0
   ierr=jtaudio(idevin,idevout,y1,y2,NMAX,iwrite,iwave,nwave,    &amp;
        11025,NSPB,TRPeriod,TxOK,ndebug,Transmitting,            &amp;
        Tsec,ngo,nmode,tbuf,ibuf,ndsec)
+
+  call cs_lock('a2d')
   if(ierr.ne.0) then
      print*,'Error ',ierr,' in JTaudio, cannot continue.'
   else
      write(*,1006) 
 1006 format('Audio output stream terminated normally.')
   endif
+  call cs_unlock
+
   return
 end subroutine a2d

Deleted: branches/map65iq/astro.F
===================================================================
--- branches/map65iq/astro.F	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/astro.F	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,112 +0,0 @@
-      subroutine astro(AppDir,nyear,month,nday,uth,nfreq,Mygrid,
-     +     NStation,mode,MoonDX,AzSun,ElSun,AzMoon,ElMoon0,
-     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
-     +     poloffset,xnr,auxra,auxdec,azaux,elaux)
-
-C  Computes astronomical quantities for display in JT65, CW, and EME Echo mode.
-C  NB: may want to smooth the Tsky map to 10 degrees or so.
-
-      character*80 AppDir,fname
-      character*6 MyGrid,HisGrid
-      logical first,ltsky
-      real LST
-      real lat,lon
-      real ldeg
-      integer*1 n1sky(129600)
-      integer*2 nsky
-      common/sky/ nsky(360,180)
-      common/echo/xdop(2),techo,ElMoon,mjd
-      equivalence (n1sky,nsky)
-      data first/.true./
-      data rad/57.2957795/
-      save
-
-      if(first) then
-	do i=80,1,-1
-	   if(ichar(AppDir(i:i)).ne.0 .and. 
-     +            ichar(AppDir(i:i)).ne.32) goto 1
-	enddo
- 1	lenappdir=i
-        call zero(nsky,180*180)
-	fname=Appdir(1:lenappdir)//'/TSKY.DAT'
-#ifdef CVF
-        open(13,file=fname,status='old',form='binary',err=10)
-        read(13) nsky
-        close(13)
-#else
-        open(13,file=fname,status='old',access='stream',err=10)
-        read(13) nsky
-        close(13)
-#endif
-        ltsky=.true.
-        first=.false.
-      endif
-      go to 20
- 10   ltsky=.false.
-
- 20   call grid2deg(MyGrid,elon,lat)
-      lon=-elon
-      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
-     +    AzSun,ElSun,mjd)
-
-      freq=nfreq*1.e6
-
-      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
-     +  LST,HA,AzMoon,ElMoon,ldeg,bdeg,vr,dist)
-
-C  Compute spatial polarization offset
-      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
-     +     cos(AzMoon/rad)*sin(ElMoon/rad)
-      yy=cos(lat/rad)*sin(AzMoon/rad)
-      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
-      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
-
-      techo=2.0 * dist/2.99792458e5                 !Echo delay time
-      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
-      t408=ftsky(ldeg,bdeg)                         !Read sky map
-      tsky=t408*(408.0/nfreq)**2.6                  !Tsky for obs freq
-      if(ltsky.and.(tsky.lt.3.0)) tsky=3.0          !Minimum = 3 Kelvin
-
-      xdop(NStation)=doppler
-      if(NStation.eq.2) then
-         HisGrid=MyGrid
-         go to 900
-      endif
-
-      doppler00=2.0*xdop(1)
-      if(mode.eq.2 .or. mode.eq.5) doppler=xdop(1)+xdop(2)
-      if(mode.eq.3) doppler=2.0*xdop(1)
-      dBMoon=-40.0*log10(dist/356903.)
-      sd=16.23*370152.0/dist
-
-!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
-!     +    (mode.eq.2 .or. mode.eq.5)) then
-      if(NStation.eq.1 .and. MoonDX.ne.0) then
-         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
-         if(poloffset.gt.90.0) poloffset=poloffset-180.0
-         x1=abs(cos(2*poloffset/rad))
-         if(x1.lt.0.056234) x1=0.056234
-         xnr=-20.0*log10(x1)
-         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'Z') xnr=0
-      endif
-
-      tr=80.0                              !Good preamp
-      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
-      tsysmin=tskymin+tr
-      tsys=tsky+tr
-      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
-
- 900  ElMoon0=Elmoon
-      ntsky=nint(tsky)
-
-      auxHA = 15.0*(LST-auxra)                       !HA in degrees
-      pi=3.14159265
-      pio2=0.5*pi
-      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
-     +  auxdec/rad,azaux,elaux)
-      AzAux=azaux*rad
-      ElAux=ElAux*rad
-
-      return
-
-      end

Added: branches/map65iq/astro.f
===================================================================
--- branches/map65iq/astro.f	                        (rev 0)
+++ branches/map65iq/astro.f	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,108 @@
+      subroutine astro(AppDir,nyear,month,nday,uth,nfreq,Mygrid,
+     +     NStation,mode,MoonDX,AzSun,ElSun,AzMoon,ElMoon0,
+     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
+     +     poloffset,xnr,auxra,auxdec,azaux,elaux)
+
+C  Computes astronomical quantities for display in JT65, CW, and EME Echo mode.
+C  NB: may want to smooth the Tsky map to 10 degrees or so.
+
+      character*80 AppDir,fname
+      character*6 MyGrid,HisGrid
+      logical first,ltsky
+      real LST
+      real lat,lon
+      real ldeg
+      integer*1 n1sky(129600)
+      integer*2 nsky
+      common/sky/ nsky(360,180)
+      common/echo/xdop(2),techo,ElMoon,mjd
+      equivalence (n1sky,nsky)
+      data first/.true./
+      data rad/57.2957795/
+      save
+
+      if(first) then
+	do i=80,1,-1
+	   if(ichar(AppDir(i:i)).ne.0 .and. 
+     +            ichar(AppDir(i:i)).ne.32) goto 1
+	enddo
+ 1	lenappdir=i
+        call zero(nsky,180*180)
+	fname=Appdir(1:lenappdir)//'/TSKY.DAT'
+        call cs_lock('astro')
+        open(13,file=fname,status='old',access='stream',err=10)
+        read(13) nsky
+        close(13)
+        call cs_unlock
+        ltsky=.true.
+        first=.false.
+      endif
+      go to 20
+ 10   ltsky=.false.
+
+ 20   call grid2deg(MyGrid,elon,lat)
+      lon=-elon
+      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
+     +    AzSun,ElSun,mjd)
+
+      freq=nfreq*1.e6
+
+      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
+     +  LST,HA,AzMoon,ElMoon,ldeg,bdeg,vr,dist)
+
+C  Compute spatial polarization offset
+      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
+     +     cos(AzMoon/rad)*sin(ElMoon/rad)
+      yy=cos(lat/rad)*sin(AzMoon/rad)
+      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
+      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
+
+      techo=2.0 * dist/2.99792458e5                 !Echo delay time
+      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
+      t408=ftsky(ldeg,bdeg)                         !Read sky map
+      tsky=t408*(408.0/nfreq)**2.6                  !Tsky for obs freq
+      if(ltsky.and.(tsky.lt.3.0)) tsky=3.0          !Minimum = 3 Kelvin
+
+      xdop(NStation)=doppler
+      if(NStation.eq.2) then
+         HisGrid=MyGrid
+         go to 900
+      endif
+
+      doppler00=2.0*xdop(1)
+      if(mode.eq.2 .or. mode.eq.5) doppler=xdop(1)+xdop(2)
+      if(mode.eq.3) doppler=2.0*xdop(1)
+      dBMoon=-40.0*log10(dist/356903.)
+      sd=16.23*370152.0/dist
+
+!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
+!     +    (mode.eq.2 .or. mode.eq.5)) then
+      if(NStation.eq.1 .and. MoonDX.ne.0) then
+         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
+         if(poloffset.gt.90.0) poloffset=poloffset-180.0
+         x1=abs(cos(2*poloffset/rad))
+         if(x1.lt.0.056234) x1=0.056234
+         xnr=-20.0*log10(x1)
+         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'Z') xnr=0
+      endif
+
+      tr=80.0                              !Good preamp
+      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
+      tsysmin=tskymin+tr
+      tsys=tsky+tr
+      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
+
+ 900  ElMoon0=Elmoon
+      ntsky=nint(tsky)
+
+      auxHA = 15.0*(LST-auxra)                       !HA in degrees
+      pi=3.14159265
+      pio2=0.5*pi
+      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
+     +  auxdec/rad,azaux,elaux)
+      AzAux=azaux*rad
+      ElAux=ElAux*rad
+
+      return
+
+      end

Deleted: branches/map65iq/astro0.F90
===================================================================
--- branches/map65iq/astro0.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/astro0.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,119 +0,0 @@
-!--------------------------------------------------- astro0
-subroutine astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
-     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
-     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
-     RaAux8,DecAux8,AzAux8,ElAux8)
-
-!f2py intent(in) nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec
-!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8
-
-  character grid*6
-  character*9 cauxra,cauxdec
-  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,AzAux8,ElAux8
-  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0
-  real*8 sd8,poloffset8
-  include 'gcom2.f90'
-  data uth8z/0.d0/,imin0/-99/
-  save
-
-  auxra=0.
-  i=index(cauxra,':')
-  if(i.eq.0) then
-     read(cauxra,*,err=1,end=1) auxra
-  else
-     read(cauxra(1:i-1),*,err=1,end=1) ih
-     read(cauxra(i+1:i+2),*,err=1,end=1) im
-     read(cauxra(i+4:i+5),*,err=1,end=1) is
-     auxra=ih + im/60.0 + is/3600.0
-  endif
-1 auxdec=0.
-  i=index(cauxdec,':')
-  if(i.eq.0) then
-     read(cauxdec,*,err=2,end=2) auxdec
-  else
-     read(cauxdec(1:i-1),*,err=2,end=2) id
-     read(cauxdec(i+1:i+2),*,err=2,end=2) im
-     read(cauxdec(i+4:i+5),*,err=2,end=2) is
-     auxdec=id + im/60.0 + is/3600.0
-  endif
-
-2 nmode=1
-  if(mode(1:4).eq.'JT65') then
-     nmode=2
-     if(mode(5:5).eq.'A') mode65=1
-     if(mode(5:5).eq.'B') mode65=2
-     if(mode(5:5).eq.'C') mode65=4
-  endif
-  if(mode.eq.'Echo') nmode=3
-  if(mode.eq.'JT6M') nmode=4
-  uth=uth8
-
-  call astro(AppDir,nyear,month,nday,uth,nfreq,hisgrid,2,nmode,1,    &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
-  AzMoonB8=AzMoon
-  ElMoonB8=ElMoon
-  call astro(AppDir,nyear,month,nday,uth,nfreq,grid,1,nmode,1,       &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
-
-  RaAux8=auxra
-  DecAux8=auxdec
-  AzSun8=AzSun
-  ElSun8=ElSun
-  AzMoon8=AzMoon
-  ElMoon8=ElMoon
-  dbMoon8=dbMoon
-  RAMoon8=RAMoon/15.0
-  DecMoon8=DecMoon
-  HA8=HA
-  Dgrd8=Dgrd
-  sd8=sd
-  poloffset8=poloffset
-  xnr8=xnr
-  AzAux8=AzAux
-  ElAux8=ElAux
-  ndop=nint(doppler)
-  ndop00=nint(doppler00)
-
-  if(uth8z.eq.0.d0) then
-     uth8z=uth8-1.d0/3600.d0
-     dopplerz=doppler
-     doppler00z=doppler00
-  endif
-     
-  dt=60.0*(uth8-uth8z)
-  if(dt.le.0) dt=1.d0/60.d0
-  dfdt=(doppler-dopplerz)/dt
-  dfdt0=(doppler00-doppler00z)/dt
-  uth8z=uth8
-  dopplerz=doppler
-  doppler00z=doppler00
-
-  imin=60*uth8
-  isec=3600*uth8
-
-  if(isec.ne.isec0 .and. ndecoding.eq.0) then
-     ih=uth8
-     im=mod(imin,60)
-     is=mod(isec,60)
-     rewind 14
-     write(14,1010) ih,im,is,AzMoon,ElMoon,                          &amp;
-        ih,im,is,AzSun,ElSun,                                        &amp;
-        ih,im,is,AzAux,ElAux,                                        &amp;
-        nfreq,doppler,dfdt,doppler00,dfdt0,                          &amp;
-        mousefqso,nsetftx
-1010 format(i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Moon'/        &amp;
-            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Sun'/         &amp;
-            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Source'/      &amp;
-            i4,',',f8.1,',',f8.2,',',f8.1,',',f8.2,',Doppler'/       &amp;
-            i4,',',i1,',fQSO')
-     call flushqqq(14)
-     nsetftx=0
-     isec0=isec
-  endif
-
-  return
-end subroutine astro0

Added: branches/map65iq/astro0.f90
===================================================================
--- branches/map65iq/astro0.f90	                        (rev 0)
+++ branches/map65iq/astro0.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,120 @@
+subroutine astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
+     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
+     RaAux8,DecAux8,AzAux8,ElAux8)
+
+!f2py intent(in) nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec
+!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8
+
+  character grid*6
+  character*9 cauxra,cauxdec
+  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,AzAux8,ElAux8
+  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0
+  real*8 sd8,poloffset8
+  include 'gcom2.f90'
+  data uth8z/0.d0/,imin0/-99/
+  save
+
+  auxra=0.
+  i=index(cauxra,':')
+  if(i.eq.0) then
+     read(cauxra,*,err=1,end=1) auxra
+  else
+     read(cauxra(1:i-1),*,err=1,end=1) ih
+     read(cauxra(i+1:i+2),*,err=1,end=1) im
+     read(cauxra(i+4:i+5),*,err=1,end=1) is
+     auxra=ih + im/60.0 + is/3600.0
+  endif
+1 auxdec=0.
+  i=index(cauxdec,':')
+  if(i.eq.0) then
+     read(cauxdec,*,err=2,end=2) auxdec
+  else
+     read(cauxdec(1:i-1),*,err=2,end=2) id
+     read(cauxdec(i+1:i+2),*,err=2,end=2) im
+     read(cauxdec(i+4:i+5),*,err=2,end=2) is
+     auxdec=id + im/60.0 + is/3600.0
+  endif
+
+2 nmode=1
+  if(mode(1:4).eq.'JT65') then
+     nmode=2
+     if(mode(5:5).eq.'A') mode65=1
+     if(mode(5:5).eq.'B') mode65=2
+     if(mode(5:5).eq.'C') mode65=4
+  endif
+  if(mode.eq.'Echo') nmode=3
+  if(mode.eq.'JT6M') nmode=4
+  uth=uth8
+
+  call astro(AppDir,nyear,month,nday,uth,nfreq,hisgrid,2,nmode,1,    &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
+       AzAux,ElAux)
+  AzMoonB8=AzMoon
+  ElMoonB8=ElMoon
+  call astro(AppDir,nyear,month,nday,uth,nfreq,grid,1,nmode,1,       &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
+       AzAux,ElAux)
+
+  RaAux8=auxra
+  DecAux8=auxdec
+  AzSun8=AzSun
+  ElSun8=ElSun
+  AzMoon8=AzMoon
+  ElMoon8=ElMoon
+  dbMoon8=dbMoon
+  RAMoon8=RAMoon/15.0
+  DecMoon8=DecMoon
+  HA8=HA
+  Dgrd8=Dgrd
+  sd8=sd
+  poloffset8=poloffset
+  xnr8=xnr
+  AzAux8=AzAux
+  ElAux8=ElAux
+  ndop=nint(doppler)
+  ndop00=nint(doppler00)
+
+  if(uth8z.eq.0.d0) then
+     uth8z=uth8-1.d0/3600.d0
+     dopplerz=doppler
+     doppler00z=doppler00
+  endif
+     
+  dt=60.0*(uth8-uth8z)
+  if(dt.le.0) dt=1.d0/60.d0
+  dfdt=(doppler-dopplerz)/dt
+  dfdt0=(doppler00-doppler00z)/dt
+  uth8z=uth8
+  dopplerz=doppler
+  doppler00z=doppler00
+
+  imin=60*uth8
+  isec=3600*uth8
+
+  if(isec.ne.isec0 .and. ndecoding.eq.0) then
+     ih=uth8
+     im=mod(imin,60)
+     is=mod(isec,60)
+     call cs_lock('astro0')
+     rewind 14
+     write(14,1010) ih,im,is,AzMoon,ElMoon,                          &amp;
+        ih,im,is,AzSun,ElSun,                                        &amp;
+        ih,im,is,AzAux,ElAux,                                        &amp;
+        nfreq,doppler,dfdt,doppler00,dfdt0,                          &amp;
+        mousefqso,nsetftx
+1010 format(i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Moon'/        &amp;
+            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Sun'/         &amp;
+            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Source'/      &amp;
+            i4,',',f8.1,',',f8.2,',',f8.1,',',f8.2,',Doppler'/       &amp;
+            i4,',',i1,',fQSO')
+     call flush(14)
+     call cs_unlock
+     nsetftx=0
+     isec0=isec
+  endif
+
+  return
+end subroutine astro0


Property changes on: branches/map65iq/astro0.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/audio_init.F90
===================================================================
--- branches/map65iq/audio_init.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/audio_init.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,74 +0,0 @@
-!------------------------------------------------ audio_init
-subroutine audio_init(ndin,ndout)
-
-#ifdef CVF
-  use dfmt
-  integer Thread1,Thread2,Thread3
-  external a2d,decode1,recvpkt
-#endif
-
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  nmode=2
-  if(mode(5:5).eq.'A') mode65=1
-  if(mode(5:5).eq.'B') mode65=2
-  if(mode(5:5).eq.'C') mode65=4
-  ndevout=ndout
-  TxOK=0
-  Transmitting=0
-  nfsample=11025
-  nspb=1024
-  nbufs=2048
-  nmax=nbufs*nspb
-  nwave=60*nfsample
-  ngo=1
-  f0=800.0
-  do i=1,nwave
-     iwave(i)=nint(32767.0*sin(6.283185307*i*f0/nfsample))
-  enddo
-
-#ifdef CVF
-!  Priority classes (for processes):
-!     IDLE_PRIORITY_CLASS               64
-!     NORMAL_PRIORITY_CLASS             32
-!     HIGH_PRIORITY_CLASS              128
-
-!  Priority definitions (for threads):
-!     THREAD_PRIORITY_IDLE             -15
-!     THREAD_PRIORITY_LOWEST            -2
-!     THREAD_PRIORITY_BELOW_NORMAL      -1
-!     THREAD_PRIORITY_NORMAL             0
-!     THREAD_PRIORITY_ABOVE_NORMAL       1
-!     THREAD_PRIORITY_HIGHEST            2
-!     THREAD_PRIORITY_TIME_CRITICAL     15
-    
-  m0=SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS)
-!  m0=SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS)
-
-! Start a thread for doing A/D and D/A with sound card.
-!  (actually, only D/A is used in MAP65)
-  Thread1=CreateThread(0,0,a2d,0,CREATE_SUSPENDED,id1)
-  m1=SetThreadPriority(Thread1,THREAD_PRIORITY_ABOVE_NORMAL)
-  m2=ResumeThread(Thread1)
-
-! Start a thread for background decoding.
-  Thread2=CreateThread(0,0,decode1,0,CREATE_SUSPENDED,id2)
-  m3=SetThreadPriority(Thread2,THREAD_PRIORITY_BELOW_NORMAL)
-  m4=ResumeThread(Thread2)
-
-! Start a thread to receive packets from Linrad
-  Thread3=CreateThread(0,0,recvpkt,0,CREATE_SUSPENDED,id3)
-  m5=SetThreadPriority(Thread3,THREAD_PRIORITY_ABOVE_NORMAL)
-  m6=ResumeThread(Thread3)
-
-#else
-!  print*,'Audio INIT called.'
-  ierr=start_threads(ndevin,ndevout,y1,y2,nmax,iwrite,iwave,nwave,    &amp;
-       11025,NSPB,TRPeriod,TxOK,ndebug,Transmitting,            &amp;
-       Tsec,ngo,nmode,tbuf,ibuf,ndsec,PttPort,devin_name,devout_name)
-
-#endif
-
-  return
-end subroutine audio_init

Deleted: branches/map65iq/decode1.F90
===================================================================
--- branches/map65iq/decode1.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/decode1.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,81 +0,0 @@
-subroutine decode1(iarg)
-
-! Get data and parameters from gcom, then call the decoders when needed.
-! This routine runs in a background thread and will never return.
-
-#ifdef CVF
-  use dflib
-#endif
-
-  character sending0*28,mode0*6,cshort*11
-  integer sendingsh0
-
-  include 'datcom.f90'
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  include 'gcom4.f90'
-  data kbuf0/0/,ns00/-999/
-  data sending0/'                      '/
-  save
-
-  kkdone=-99
-  ns0=999999
-
-10 continue
-  if(newdat2.gt.0) then
-     call getfile2(fname80,nlen)
-     newdat2=0
-     kbuf=1
-     kk=NSMAX
-     kkdone=0
-     newdat=1
-  endif
-
-  if(kbuf.ne.kbuf0) kkdone=0
-  kbuf0=kbuf
-  kkk=kk
-  if(kbuf.eq.2) kkk=kk-5760000
-  n=Tsec
-
-  if((ndiskdat.eq.1 .or. ndecoding.eq.0) .and. ((kkk-kkdone).gt.32768)) then
-     call symspec(id,kbuf,kk,kkdone,nutc,newdat)
-     call sleep_msec(10)
-  endif
-
-  if(ndecoding.gt.0 .and. mode(1:4).eq.'JT65') then
-     ndecdone=0
-     call map65a(newdat)
-     if(mousebutton.eq.0) ndecoding0=ndecoding
-     ndecoding=0
-  endif
-
-  if(ns0.lt.0) then
-     rewind 21
-     ns0=999999
-  endif
-  if(n.lt.ns0 .and. utcdate(1:1).eq.'2') then
-     write(21,1001) utcdate(:11)
-1001 format(/'UTC Date: ',a11/'---------------------')
-     ns0=n
-  endif
-
-  if(transmitting.eq.1 .and. (sending.ne.sending0 .or.       &amp;
-       sendingsh.ne.sendingsh0 .or. mode.ne.mode0)) then
-     ih=n/3600
-     im=mod(n/60,60)
-     is=mod(n,60)
-     cshort='           '
-     if(sendingsh.eq.1) cshort='(Shorthand)'
-     write(21,1010) ih,im,is,mode,sending,cshort
-1010 format(3i2.2,'  Transmitting: ',a6,2x,a28,2x,a11)
-     call flushqqq(21)
-     sending0=sending
-     sendingsh0=sendingsh
-     mode0=mode
-  endif
-
-  call sleep_msec(100)                  !### was 100
-  go to 10
-
-end subroutine decode1

Added: branches/map65iq/decode1.f90
===================================================================
--- branches/map65iq/decode1.f90	                        (rev 0)
+++ branches/map65iq/decode1.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,86 @@
+subroutine decode1(iarg)
+
+! Get data and parameters from gcom, then call the decoders when needed.
+! This routine runs in a background thread and will never return.
+
+  character sending0*28,mode0*6,cshort*11
+  integer sendingsh0
+
+  include 'datcom.f90'
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  include 'gcom4.f90'
+  data kbuf0/0/,ns00/-999/
+  data sending0/'                      '/
+  save
+
+  kkdone=-99
+  ns0=999999
+
+10 continue
+  if(newdat2.gt.0) then
+     call getfile2(fname80,nlen)
+     newdat2=0
+     kbuf=1
+     kk=NSMAX
+     kkdone=0
+     newdat=1
+  endif
+
+  if(kbuf.ne.kbuf0) kkdone=0
+  kbuf0=kbuf
+  kkk=kk
+  if(kbuf.eq.2) kkk=kk-5760000
+  n=Tsec
+
+  if((ndiskdat.eq.1 .or. ndecoding.eq.0) .and. ((kkk-kkdone).gt.32768)) then
+     call symspec(id,kbuf,kk,kkdone,nutc,newdat)
+     call sleep_msec(10)
+  endif
+
+  if(ndecoding.gt.0 .and. mode(1:4).eq.'JT65') then
+     ndecdone=0
+     call map65a(newdat)
+     if(mousebutton.eq.0) ndecoding0=ndecoding
+     ndecoding=0
+  endif
+
+  if(ns0.lt.0) then
+     rewind 21
+     ns0=999999
+  endif
+  if(n.lt.ns0 .and. utcdate(1:1).eq.'2') then
+
+     call cs_lock('decode1a')
+     write(21,1001) utcdate(:11)
+1001 format(/'UTC Date: ',a11/'---------------------')
+     call flush(21)
+     call cs_unlock
+
+     ns0=n
+  endif
+
+  if(transmitting.eq.1 .and. (sending.ne.sending0 .or.       &amp;
+       sendingsh.ne.sendingsh0 .or. mode.ne.mode0)) then
+     ih=n/3600
+     im=mod(n/60,60)
+     is=mod(n,60)
+     cshort='           '
+     if(sendingsh.eq.1) cshort='(Shorthand)'
+
+     call cs_lock('decode1b')
+     write(21,1010) ih,im,is,mode,sending,cshort
+1010 format(3i2.2,'  Transmitting: ',a6,2x,a28,2x,a11)
+     call flush(21)
+     call cs_unlock
+
+     sending0=sending
+     sendingsh0=sendingsh
+     mode0=mode
+  endif
+
+  call sleep_msec(100)                  !### was 100
+  go to 10
+
+end subroutine decode1


Property changes on: branches/map65iq/decode1.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/deep65.F
===================================================================
--- branches/map65iq/deep65.F	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/deep65.F	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,176 +0,0 @@
-      subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,
-     +  hisgrid,decoded,qual)
-
-      parameter (MAXCALLS=7000,MAXRPT=63)
-      real s3(64,63)
-      character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
-      character*12 mycall,hiscall
-      character mycall0*12,hiscall0*12,hisgrid0*6
-      character*22 decoded
-      character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
-      character*15 callgrid(MAXCALLS)
-      character*180 line
-      character*4 rpt(MAXRPT)
-      integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
-      real pp(2*MAXCALLS + 2 + MAXRPT)
-      common/mrscom/ mrs(63),mrs2(63)
-
-      data neme0/-99/
-      data rpt/'-01','-02','-03','-04','-05',
-     +         '-06','-07','-08','-09','-10',
-     +         '-11','-12','-13','-14','-15',
-     +         '-16','-17','-18','-19','-20',
-     +         '-21','-22','-23','-24','-25',
-     +         '-26','-27','-28','-29','-30',
-     +         'R-01','R-02','R-03','R-04','R-05',
-     +         'R-06','R-07','R-08','R-09','R-10',
-     +         'R-11','R-12','R-13','R-14','R-15',
-     +         'R-16','R-17','R-18','R-19','R-20',
-     +         'R-21','R-22','R-23','R-24','R-25',
-     +         'R-26','R-27','R-28','R-29','R-30',
-     +         'RO','RRR','73'/
-      save
-
-      modified=0                              !@@@
-      if(mycall.eq.mycall0 .and. hiscall.eq.hiscall0 .and. 
-     +   hisgrid.eq.hisgrid0 .and. modified.eq.modified0) go to 30
-      rewind 23
-      k=0
-      icall=0
-      do n=1,MAXCALLS
-         if(n.eq.1) then
-            callsign=hiscall
-            do i=4,12
-               if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
-            enddo
-            grid=hisgrid(1:4)
-            if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
-            if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
-         else
-            read(23,1002,end=20) line
- 1002       format (A80)
-            if(line(1:4).eq.'ZZZZ') go to 20
-            if(line(1:2).eq.'//') go to 10
-            i1=index(line,',')
-            if(i1.lt.4) go to 10
-            i2=index(line(i1+1:),',')
-            if(i2.lt.5) go to 10
-            i2=i2+i1
-            i3=index(line(i2+1:),',')
-            if(i3.lt.1) i3=index(line(i2+1:),' ')
-            i3=i2+i3
-            callsign=line(1:i1-1)
-            grid=line(i1+1:i2-1)
-            ceme=line(i2+1:i3-1)
-            if(neme.eq.1 .and. ceme.ne.'EME') go to 10
-         endif
-
-         icall=icall+1
-         j1=index(mycall,' ') - 1
-         if(j1.le.-1) j1=12
-         if(j1.lt.3) j1=6
-         j2=index(callsign,' ') - 1
-         if(j2.le.-1) j2=12
-         if(j2.lt.3) j2=6
-         j3=index(mycall,'/')                 ! j3&gt;0 means compound mycall
-         j4=index(callsign,'/')               ! j4&gt;0 means compound hiscall
-         callgrid(icall)=callsign(1:j2)
-
-         mz=1
-! Allow MyCall + HisCall + rpt (?)
-         if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.
-     +     flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
-         do m=1,mz
-            if(m.gt.1) grid=rpt(m-1)
-            if(j3.lt.1 .and.j4.lt.1) 
-     +         callgrid(icall)=callsign(1:j2)//' '//grid
-            message=mycall(1:j1)//' '//callgrid(icall)
-            k=k+1
-            testmsg(k)=message
-            call encode65(message,ncode(1,k))
-
-            if(n.ge.2) then
-C  Insert CQ message
-               if(j4.lt.1) callgrid(icall)=callsign(1:j2)//' '//grid
-               message='CQ '//callgrid(icall)
-               k=k+1
-               testmsg(k)=message
-               call encode65(message,ncode(1,k))
-            endif
-         enddo
- 10      continue
-      enddo
- 20   ntot=k
-      neme0=neme
-
- 30   mycall0=mycall
-      hiscall0=hiscall
-      hisgrid0=hisgrid
-      modified0=modified
-      ref0=0.
-      do j=1,63
-         ref0=ref0 + s3(mrs(j),j)
-      enddo
-
-      p1=-1.e30
-      p2=-1.e30
-      do k=1,ntot
-         pp(k)=0.
-! Test all messages if flip=+1; skip the CQ messages if flip=-1.
-         if(flip.gt.0.0 .or. testmsg(k)(1:3).ne.'CQ ') then
-            sum=0.
-            ref=ref0
-            do j=1,63
-               i=ncode(j,k)+1
-               sum=sum + s3(i,j)
-               if(i.eq.mrs(j)) then
-                  ref=ref - s3(i,j) + s3(mrs2(j),j)
-               endif
-            enddo
-            p=sum/ref
-            pp(k)=p
-            if(p.gt.p1) then
-               p1=p
-               ip1=k
-            endif
-         endif
-      enddo
-
-      do i=1,ntot
-         if(pp(i).gt.p2 .and. pp(i).ne.p1) p2=pp(i)
-      enddo
-
-C  ### DO NOT REMOVE ### 
-      rewind 77
-      write(77,*) p1,p2
-C  ### Works OK without it (in both Windows and Linux) if compiled 
-C  ### without optimization.  However, in Windows this is a colossal 
-C  ### pain because of the way McMillan Installer wants to run the 
-C  ### compile step.
-
-      if(mode65.eq.1) bias=max(1.12*p2,0.335)
-      if(mode65.eq.2) bias=max(1.08*p2,0.405)
-      if(mode65.ge.4) bias=max(1.04*p2,0.505)
-
-      if(p2.eq.p1 .and. p1.ne.-1.e30) stop 'Error in deep65'
-      qual=100.0*(p1-bias)
-
-      decoded='                      '
-      c=' '
-
-      if(qual.gt.1.0) then
-         if(qual.lt.6.0) c='?'
-         decoded=testmsg(ip1)
-      else
-         qual=0.
-      endif
-      decoded(22:22)=c
-
-C  Make sure everything is upper case.
-      do i=1,22
-         if(decoded(i:i).ge.'a' .and. decoded(i:i).le.'z') 
-     +     decoded(i:i)=char(ichar(decoded(i:i))-32)
-      enddo
-
-      return
-      end

Added: branches/map65iq/deep65.f
===================================================================
--- branches/map65iq/deep65.f	                        (rev 0)
+++ branches/map65iq/deep65.f	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,183 @@
+      subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,
+     +  hisgrid,decoded,qual)
+
+      parameter (MAXCALLS=7000,MAXRPT=63)
+      real s3(64,63)
+      character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
+      character*12 mycall,hiscall
+      character mycall0*12,hiscall0*12,hisgrid0*6
+      character*22 decoded
+      character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
+      character*15 callgrid(MAXCALLS)
+      character*180 line
+      character*4 rpt(MAXRPT)
+      integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
+      real pp(2*MAXCALLS + 2 + MAXRPT)
+      common/mrscom/ mrs(63),mrs2(63)
+
+      data neme0/-99/
+      data rpt/'-01','-02','-03','-04','-05',
+     +         '-06','-07','-08','-09','-10',
+     +         '-11','-12','-13','-14','-15',
+     +         '-16','-17','-18','-19','-20',
+     +         '-21','-22','-23','-24','-25',
+     +         '-26','-27','-28','-29','-30',
+     +         'R-01','R-02','R-03','R-04','R-05',
+     +         'R-06','R-07','R-08','R-09','R-10',
+     +         'R-11','R-12','R-13','R-14','R-15',
+     +         'R-16','R-17','R-18','R-19','R-20',
+     +         'R-21','R-22','R-23','R-24','R-25',
+     +         'R-26','R-27','R-28','R-29','R-30',
+     +         'RO','RRR','73'/
+      save
+
+      modified=0                              !@@@
+      if(mycall.eq.mycall0 .and. hiscall.eq.hiscall0 .and. 
+     +   hisgrid.eq.hisgrid0 .and. modified.eq.modified0) go to 30
+
+      call cs_lock('deep65')
+      rewind 23
+      k=0
+      icall=0
+      do n=1,MAXCALLS
+         if(n.eq.1) then
+            callsign=hiscall
+            do i=4,12
+               if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
+            enddo
+            grid=hisgrid(1:4)
+            if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
+            if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
+         else
+            read(23,1002,end=20) line
+ 1002       format (A80)
+            if(line(1:4).eq.'ZZZZ') go to 20
+            if(line(1:2).eq.'//') go to 10
+            i1=index(line,',')
+            if(i1.lt.4) go to 10
+            i2=index(line(i1+1:),',')
+            if(i2.lt.5) go to 10
+            i2=i2+i1
+            i3=index(line(i2+1:),',')
+            if(i3.lt.1) i3=index(line(i2+1:),' ')
+            i3=i2+i3
+            callsign=line(1:i1-1)
+            grid=line(i1+1:i2-1)
+            ceme=line(i2+1:i3-1)
+            if(neme.eq.1 .and. ceme.ne.'EME') go to 10
+         endif
+
+         icall=icall+1
+         j1=index(mycall,' ') - 1
+         if(j1.le.-1) j1=12
+         if(j1.lt.3) j1=6
+         j2=index(callsign,' ') - 1
+         if(j2.le.-1) j2=12
+         if(j2.lt.3) j2=6
+         j3=index(mycall,'/')                 ! j3&gt;0 means compound mycall
+         j4=index(callsign,'/')               ! j4&gt;0 means compound hiscall
+         callgrid(icall)=callsign(1:j2)
+
+         mz=1
+! Allow MyCall + HisCall + rpt (?)
+         if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.
+     +     flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
+         do m=1,mz
+            if(m.gt.1) grid=rpt(m-1)
+            if(j3.lt.1 .and.j4.lt.1) 
+     +         callgrid(icall)=callsign(1:j2)//' '//grid
+            message=mycall(1:j1)//' '//callgrid(icall)
+            k=k+1
+            testmsg(k)=message
+            call encode65(message,ncode(1,k))
+
+            if(n.ge.2) then
+C  Insert CQ message
+               if(j4.lt.1) callgrid(icall)=callsign(1:j2)//' '//grid
+               message='CQ '//callgrid(icall)
+               k=k+1
+               testmsg(k)=message
+               call encode65(message,ncode(1,k))
+            endif
+         enddo
+ 10      continue
+      enddo
+ 20   continue
+      call cs_unlock
+      ntot=k
+      neme0=neme
+
+ 30   mycall0=mycall
+      hiscall0=hiscall
+      hisgrid0=hisgrid
+      modified0=modified
+      ref0=0.
+      do j=1,63
+         ref0=ref0 + s3(mrs(j),j)
+      enddo
+
+      p1=-1.e30
+      p2=-1.e30
+      do k=1,ntot
+         pp(k)=0.
+! Test all messages if flip=+1; skip the CQ messages if flip=-1.
+         if(flip.gt.0.0 .or. testmsg(k)(1:3).ne.'CQ ') then
+            sum=0.
+            ref=ref0
+            do j=1,63
+               i=ncode(j,k)+1
+               sum=sum + s3(i,j)
+               if(i.eq.mrs(j)) then
+                  ref=ref - s3(i,j) + s3(mrs2(j),j)
+               endif
+            enddo
+            p=sum/ref
+            pp(k)=p
+            if(p.gt.p1) then
+               p1=p
+               ip1=k
+            endif
+         endif
+      enddo
+
+      do i=1,ntot
+         if(pp(i).gt.p2 .and. pp(i).ne.p1) p2=pp(i)
+      enddo
+
+C  ### DO NOT REMOVE ### 
+      call cs_lock('deep65')
+      rewind 77
+      write(77,*) p1,p2
+      call cs_unlock
+
+C  ### Works OK without it (in both Windows and Linux) if compiled 
+C  ### without optimization.  However, in Windows this is a colossal 
+C  ### pain because of the way McMillan Installer wants to run the 
+C  ### compile step.
+
+      if(mode65.eq.1) bias=max(1.12*p2,0.335)
+      if(mode65.eq.2) bias=max(1.08*p2,0.405)
+      if(mode65.ge.4) bias=max(1.04*p2,0.505)
+
+      if(p2.eq.p1 .and. p1.ne.-1.e30) stop 'Error in deep65'
+      qual=100.0*(p1-bias)
+
+      decoded='                      '
+      c=' '
+
+      if(qual.gt.1.0) then
+         if(qual.lt.6.0) c='?'
+         decoded=testmsg(ip1)
+      else
+         qual=0.
+      endif
+      decoded(22:22)=c
+
+C  Make sure everything is upper case.
+      do i=1,22
+         if(decoded(i:i).ge.'a' .and. decoded(i:i).le.'z') 
+     +     decoded(i:i)=char(ichar(decoded(i:i))-32)
+      enddo
+
+      return
+      end

Deleted: branches/map65iq/display.F90
===================================================================
--- branches/map65iq/display.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/display.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,171 +0,0 @@
-subroutine display(nkeep,ncsmin,mhz)
-
-#ifdef CVF
-  use dfport
-#endif
-
-  parameter (MAXLINES=500,MX=500)
-  integer indx(MAXLINES),indx2(MX)
-  character*83 line(MAXLINES),line2(MX),line3(MAXLINES)
-  character out*50,cfreq0*3
-  character*6 callsign,callsign0
-  character*12 freqcall(100)
-  character*40 bm2
-  real freqkHz(MAXLINES)
-  integer utc(MAXLINES),utc2(MX),utcz
-  real*8 f0
-
-  ftol=0.02
-  rewind 26
-
-  do i=1,MAXLINES
-     read(26,1010,end=10) line(i)
-1010 format(a83)
-     read(line(i),1020) f0,ndf,nh,nm
-1020 format(f9.3,i5,26x,i3,i2)
-     utc(i)=60*nh + nm
-     freqkHz(i)=1000.d0*(f0-mhz) + 0.001d0*ndf
-  enddo
-
-10 nz=i-1
-  utcz=utc(nz)
-  nz=nz-1
-  if(nz.lt.1) go to 999
-  nquad=max(nkeep/4,3)
-  do i=1,nz
-     nage=utcz-utc(i)
-     if(nage.lt.0) nage=nage+1440
-     iage=(nage/nquad) + 1
-     if(nage.le.1) iage=0
-     write(line(i)(80:83),1021) iage
-1021 format(i4)
-  enddo
-
-  nage=utcz-utc(1)
-  if(nage.lt.0) nage=nage+1440
-  if(nage.gt.nkeep) then
-     do i=1,nz
-        nage=utcz-utc(i)
-        if(nage.lt.0) nage=nage+1440
-        if(nage.le.nkeep) go to 20
-     enddo
-20   i0=i
-     nz=nz-i0+1
-     rewind 26
-     if(nz.lt.1) go to 999
-     do i=1,nz
-        j=i+i0-1
-        line(i)=line(j)
-        utc(i)=utc(j)
-        freqkHz(i)=freqkHz(j)
-        write(26,1010) line(i)
-     enddo
-  endif
-
-  call flushqqq(26)
-  call indexx(nz,freqkHz,indx)
-
-  nstart=1
-  k3=0
-  k=1
-  m=indx(1)
-  if(m.lt.1 .or. m.gt.MAXLINES) then
-     print*,'Error in display.F90: ',nz,m
-     m=1
-  endif
-  line2(1)=line(m)
-  utc2(1)=utc(m)
-  do i=2,nz
-     j0=indx(i-1)
-     j=indx(i)
-     if(freqkHz(j)-freqkHz(j0).gt.ftol) then
-        if(nstart.eq.0) then
-           k=k+1
-           line2(k)=&quot;&quot;
-           utc2(k)=-1
-        endif
-        kz=k
-        if(nstart.eq.1) then
-           call indexx(kz,utc2,indx2)
-           k3=0
-           do k=1,kz
-              k3=k3+1
-              line3(k3)=line2(indx2(k))
-           enddo
-           nstart=0
-        else
-           call indexx(kz,utc2,indx2)
-           do k=1,kz
-              k3=k3+1
-              line3(k3)=line2(indx2(k))
-           enddo
-        endif
-        k=0
-     endif
-     if(i.eq.nz) then
-        k=k+1
-        line2(k)=&quot;&quot;
-        utc2(k)=-1
-     endif
-     k=k+1
-     line2(k)=line(j)
-     utc2(k)=utc(j)
-     j0=j
-  enddo
-  kz=k
-  call indexx(kz,utc2,indx2)
-  do k=1,kz
-     k3=k3+1
-     line3(k3)=line2(indx2(k))
-  enddo
-
-  rewind 19
-  rewind 20
-  cfreq0='   '
-  nc=0
-  callsign0='          '
-  do k=1,k3
-     out=line3(k)(7:14)//line3(k)(30:33)//line3(k)(41:45)//       &amp;
-          line3(k)(37:40)//line3(k)(46:69)//line3(k)(79:83)
-     if(out(1:3).ne.'   ') then
-        if(out(1:3).eq.cfreq0) then
-           out(1:3)='   '
-        else
-           cfreq0=out(1:3)
-        endif
-        write(19,1030) out
-1030    format(a50)
-        i1=index(out(24:),' ')
-        callsign=out(i1+24:)
-        i2=index(callsign,' ')
-        if(i2.gt.1) callsign(i2:)='      '
-        if(callsign.ne.'      ' .and. callsign.ne.callsign0) then
-           len=i2-1
-           if(len.lt.0) len=6
-           if(len.ge.ncsmin) then                       !Omit short &quot;callsigns&quot;
-              nc=nc+1
-              freqcall(nc)=cfreq0//' '//callsign//line3(k)(82:83)
-              callsign0=callsign
-           endif
-        endif
-        if(callsign.ne.'      ' .and. callsign.eq.callsign0) then
-           freqcall(nc)=cfreq0//' '//callsign//line3(k)(82:83)
-        endif
-     endif
-  enddo
-  call flushqqq(19)
-  nc=nc+1
-  freqcall(nc)='            '
-  nc=nc+1
-  freqcall(nc)='            '
-  freqcall(nc+1)='            '
-  freqcall(nc+2)='            '
-  iz=(nc+2)/3
-  do i=1,iz
-     bm2=freqcall(i)//'  '//freqcall(i+iz)//'  '//freqcall(i+2*iz)
-     write(20,1040) bm2
-1040 format(a40)
-  enddo
-  call flushqqq(20)
-999  return
-end subroutine display

Added: branches/map65iq/display.f90
===================================================================
--- branches/map65iq/display.f90	                        (rev 0)
+++ branches/map65iq/display.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,170 @@
+subroutine display(nkeep,ncsmin,mhz)
+
+  parameter (MAXLINES=500,MX=500)
+  integer indx(MAXLINES),indx2(MX)
+  character*83 line(MAXLINES),line2(MX),line3(MAXLINES)
+  character out*50,cfreq0*3
+  character*6 callsign,callsign0
+  character*12 freqcall(100)
+  character*40 bm2
+  real freqkHz(MAXLINES)
+  integer utc(MAXLINES),utc2(MX),utcz
+  real*8 f0
+
+  call cs_lock('display')
+  ftol=0.02
+  rewind 26
+  do i=1,MAXLINES
+     read(26,1010,end=10) line(i)
+1010 format(a83)
+     read(line(i),1020) f0,ndf,nh,nm
+1020 format(f9.3,i5,26x,i3,i2)
+     utc(i)=60*nh + nm
+     freqkHz(i)=1000.d0*(f0-mhz) + 0.001d0*ndf
+  enddo
+
+10 nz=i-1
+  utcz=utc(nz)
+  nz=nz-1
+  if(nz.lt.1) go to 999
+  nquad=max(nkeep/4,3)
+  do i=1,nz
+     nage=utcz-utc(i)
+     if(nage.lt.0) nage=nage+1440
+     iage=(nage/nquad) + 1
+     if(nage.le.1) iage=0
+     write(line(i)(80:83),1021) iage
+1021 format(i4)
+  enddo
+
+  nage=utcz-utc(1)
+  if(nage.lt.0) nage=nage+1440
+  if(nage.gt.nkeep) then
+     do i=1,nz
+        nage=utcz-utc(i)
+        if(nage.lt.0) nage=nage+1440
+        if(nage.le.nkeep) go to 20
+     enddo
+20   i0=i
+     nz=nz-i0+1
+     rewind 26
+     if(nz.lt.1) go to 999
+     do i=1,nz
+        j=i+i0-1
+        line(i)=line(j)
+        utc(i)=utc(j)
+        freqkHz(i)=freqkHz(j)
+        write(26,1010) line(i)
+     enddo
+  endif
+
+  call flush(26)
+  call indexx(nz,freqkHz,indx)
+
+  nstart=1
+  k3=0
+  k=1
+  m=indx(1)
+  if(m.lt.1 .or. m.gt.MAXLINES) then
+     print*,'Error in display.F90: ',nz,m
+     m=1
+  endif
+  line2(1)=line(m)
+  utc2(1)=utc(m)
+  do i=2,nz
+     j0=indx(i-1)
+     j=indx(i)
+     if(freqkHz(j)-freqkHz(j0).gt.ftol) then
+        if(nstart.eq.0) then
+           k=k+1
+           line2(k)=&quot;&quot;
+           utc2(k)=-1
+        endif
+        kz=k
+        if(nstart.eq.1) then
+           call indexx(kz,utc2,indx2)
+           k3=0
+           do k=1,kz
+              k3=k3+1
+              line3(k3)=line2(indx2(k))
+           enddo
+           nstart=0
+        else
+           call indexx(kz,utc2,indx2)
+           do k=1,kz
+              k3=k3+1
+              line3(k3)=line2(indx2(k))
+           enddo
+        endif
+        k=0
+     endif
+     if(i.eq.nz) then
+        k=k+1
+        line2(k)=&quot;&quot;
+        utc2(k)=-1
+     endif
+     k=k+1
+     line2(k)=line(j)
+     utc2(k)=utc(j)
+     j0=j
+  enddo
+  kz=k
+  call indexx(kz,utc2,indx2)
+  do k=1,kz
+     k3=k3+1
+     line3(k3)=line2(indx2(k))
+  enddo
+
+  rewind 19
+  rewind 20
+  cfreq0='   '
+  nc=0
+  callsign0='          '
+  do k=1,k3
+     out=line3(k)(7:14)//line3(k)(30:33)//line3(k)(41:45)//       &amp;
+          line3(k)(37:40)//line3(k)(46:69)//line3(k)(79:83)
+     if(out(1:3).ne.'   ') then
+        if(out(1:3).eq.cfreq0) then
+           out(1:3)='   '
+        else
+           cfreq0=out(1:3)
+        endif
+        write(19,1030) out
+1030    format(a50)
+        i1=index(out(24:),' ')
+        callsign=out(i1+24:)
+        i2=index(callsign,' ')
+        if(i2.gt.1) callsign(i2:)='      '
+        if(callsign.ne.'      ' .and. callsign.ne.callsign0) then
+           len=i2-1
+           if(len.lt.0) len=6
+           if(len.ge.ncsmin) then                       !Omit short &quot;callsigns&quot;
+              nc=nc+1
+              freqcall(nc)=cfreq0//' '//callsign//line3(k)(82:83)
+              callsign0=callsign
+           endif
+        endif
+        if(callsign.ne.'      ' .and. callsign.eq.callsign0) then
+           freqcall(nc)=cfreq0//' '//callsign//line3(k)(82:83)
+        endif
+     endif
+  enddo
+  call flush(19)
+  nc=nc+1
+  freqcall(nc)='            '
+  nc=nc+1
+  freqcall(nc)='            '
+  freqcall(nc+1)='            '
+  freqcall(nc+2)='            '
+  iz=(nc+2)/3
+  do i=1,iz
+     bm2=freqcall(i)//'  '//freqcall(i+iz)//'  '//freqcall(i+2*iz)
+     write(20,1040) bm2
+1040 format(a40)
+  enddo
+  call flush(20)
+999  continue
+  call cs_unlock
+
+  return
+end subroutine display


Property changes on: branches/map65iq/display.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65iq/extract.f
===================================================================
--- branches/map65iq/extract.f	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/extract.f	2010-11-19 18:19:55 UTC (rev 2257)
@@ -11,10 +11,14 @@
 
       nfail=0
  1    call demod64a(s3,nadd,mrsym,mrprob,mr2sym,mr2prob,ntest,nlow)
-      do j=1,63
-         write(52,5001) j,mrsym(j),mrprob(j),mr2sym(j),mr2prob(j)
- 5001    format(5i5)
-      enddo
+
+!      call cs_lock('extract')
+!      do j=1,63
+!         write(52,5001) j,mrsym(j),mrprob(j),mr2sym(j),mr2prob(j)
+! 5001    format(5i5)
+!      enddo
+!      call cs_unlock
+
       if(ntest.lt.50 .or. nlow.gt.20) then
          ncount=-999                         !Flag bad data
          go to 900
@@ -43,11 +47,14 @@
          call graycode(mr2sym,63,-1)
          call interleave63(mr2sym,-1)
          call interleave63(mr2prob,-1)
+         nsec1=nsec1+1
 
-         nsec1=nsec1+1
+         call cs_lock('extract')
          write(22,rec=1) nsec1,xlambda,maxe,200,
      +        mrsym,mrprob,mr2sym,mr2prob
-         call flushqqq(22)
+         call flush(22)
+         call cs_unlock
+
          call runqqq('kvasd.exe','-q',iret)
          if(iret.ne.0) then
             if(first) write(*,1000) iret
@@ -57,7 +64,11 @@
             first=.false.
             go to 20
          endif
+
+         call cs_lock('extract')
          read(22,rec=2) nsec2,ncount,dat4
+         call cs_unlock
+
          decoded='                      '
          ltext=.false.
          if(ncount.ge.0) then

Deleted: branches/map65iq/fivehz.F90
===================================================================
--- branches/map65iq/fivehz.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/fivehz.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,250 +0,0 @@
-subroutine fivehz
-
-!  Called at interrupt level from the PortAudio callback routine.
-!  For nspb=2048 the callback rate is nfsample/nspb = 5.38 Hz.
-!  Thus, we should be able to control the timing of T/R sequence events
-!  here to within about 0.2 s.
-
-!  Do not do anything very time consuming in this routine!!
-!  Disk I/O is a bad idea.  Writing to stdout (for diagnostic purposes)
-!  seems to be OK.
-
-#ifdef CVF
-  use dflib
-  use dfport
-#endif
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,txtime,filled
-  integer ptt
-  integer TxOKz
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  data first/.true./,nc0/1/,nc1/1/
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     rxdelay=0.2
-     txdelay=0.4
-     tlatency=1.0
-     first=.false.
-     iptt=0
-     ntr0=-99
-     rxdone=.false.
-     ibuf00=-99
-     ncall=-1
-     u=0.05d0
-     fsample=11025.d0
-     mfsample=110250
-     filled=.false.
-  endif
-
-  if(txdelay.lt.0.2d0) txdelay=0.2d0
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-!  if(ncall.ge.10 .and. mod(ncall,2).eq.1) then
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample=nint(10.d0*fsample)
-     endif
-  endif
-
-  if(trperiod.le.0) trperiod=30
-  tx1=0.0                              !Time to start a TX sequence
-  tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
-  if(mode(1:4).eq.'JT65') then
-     if(nwave.lt.126*4096) nwave=126*4096
-     tx2=txdelay + nwave/11025.0
-     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
-  endif
-
-  if(TxFirst.eq.0) then
-     tx1=tx1+trperiod
-     tx2=tx2+trperiod
-  endif
-
-  t=mod(Tsec,2.d0*trperiod)
-  txtime = t.ge.tx1 .and. t.lt.tx2
-
-! If we're transmitting, freeze the input buffer pointers where they were.
-  receiving=1
-  if(((txtime .and. (lauto.eq.1)) .or. TxOK.eq.1 .or. transmitting.eq.1) &amp; 
-       .and. (mute.eq.0)) then
-     receiving=0
-     ibuf=ibuf000
-     iwrite=iwrite000
-  endif
-  ibuf000=ibuf
-  iwrite000=iwrite
-  nsec=Tsec
-  ntr=mod(nsec/trperiod,2)             !ntr=0 in 1st sequence, 1 in 2nd
-
-  if(ntr.ne.ntr0) then
-     ibuf0=ibuf                        !Start of new sequence, save ibuf
-!     if(mode(1:4).ne.'JT65') then
-!        ibuf0=ibuf0+3                  !So we don't copy our own Tx
-!        if(ibuf0.gt.1024) ibuf0=ibuf0-1024
-!     endif
-     ntime=time()                      !Save start time
-     if(mantx.eq.1 .and. iptt.eq.1) then
-        mantx=0
-        TxOK=0
-     endif
-  endif
-
-! Switch PTT line and TxOK appropriately
-  if(lauto.eq.1) then
-     if(txtime .and. iptt.eq.0 .and.          &amp;
-          mute.eq.0) i1=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(.not.txtime .or. mute.eq.1) TxOK=0               !Lower TxOK
-  else
-     if(mantx.eq.1 .and. iptt.eq.0 .and.      &amp;
-          mute.eq.0) i2=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(mantx.eq.0 .or. mute.eq.1) TxOK=0                !Lower TxOK
-  endif
-
-! Calculate Tx waveform as needed
-  if((iptt.eq.1 .and. iptt0.eq.0) .or. nrestart.eq.1) then
-     call wsjtgen
-     nrestart=0
-  endif
-
-! If PTT was just raised, start a countdown for raising TxOK:
-  nc1a=txdelay/0.18576
-  if(nc1a.lt.2) nc1a=2
-  if(iptt.eq.1 .and. iptt0.eq.0) nc1=-nc1a-1
-  if(nc1.le.0) nc1=nc1+1
-  if(nc1.eq.0) TxOK=1                               ! We are transmitting
-
-! If TxOK was just lowered, start a countdown for lowering PTT:
-  nc0a=(tlatency+txdelay)/0.18576
-  if(nc0a.lt.5) nc0a=5
-  if(TxOK.eq.0 .and. TxOKz.eq.1 .and. iptt.eq.1) nc0=-nc0a-1
-  if(nc0.le.0) nc0=nc0+1
-  if(nc0.eq.0) i3=ptt(nport,pttport,0,iptt)
-
-  if(iptt.eq.0 .and.TxOK.eq.0) then
-     sending=&quot;                      &quot;
-     sendingsh=0
-  endif
-
-  nbufs=ibuf-ibuf0
-  if(nbufs.lt.0) nbufs=nbufs+1024
-  tdata=nbufs*2048.0/11025.0
-  if(mode(1:4).eq.'JT65' .and. monitoring.eq.1 .and. tdata.gt.53.0    &amp;
-       .and. ibuf0.ne.ibuf00) then
-     rxdone=.true.
-     ibuf00=ibuf0
-  endif
-  iptt0=iptt
-  TxOKz=TxOK
-  ntr0=ntr
-
-  return
-end subroutine fivehz
-
-subroutine fivehztx
-
-!  Called at interrupt level from the PortAudio output callback.
-
-#ifdef CVF
-  use dflib
-  use dfport
-#endif
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,filled
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  data first/.true./
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     first=.false.
-     ncall=-1
-     fsample=11025.d0
-     u=0.05d0
-     mfsample2=110250
-     filled=.false.
-  endif
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample2=nint(10.d0*fsample)
-     endif
-  endif
-
-  return
-end subroutine fivehztx
-
-subroutine addnoise(n)
-  integer*2 n
-  real*8 txsnrdb0
-  include 'gcom1.f90'
-  data idum/0/
-  save
-
-  if(txsnrdb.gt.40.0) return
-  if(txsnrdb.ne.txsnrdb0) then
-     snr=10.0**(0.05*(txsnrdb-1))
-     fac=3000.0
-     if(snr.gt.1.0) fac=3000.0/snr
-     txsnrdb0=txsnrdb
-  endif
-  i=fac*(gran(idum) + n*snr/32768.0)
-  if(i&gt;32767) i=32767;
-  if(i&lt;-32767) i=-32767;
-  n=i
-
-  return
-end subroutine addnoise
-
-real function gran(idum)
-  real r(12)
-  if(idum.lt.0) then
-     call random_seed
-     idum=0
-  endif
-  call random_number(r)
-  gran=sum(r)-6.0
-end function gran

Added: branches/map65iq/fivehz.f90
===================================================================
--- branches/map65iq/fivehz.f90	                        (rev 0)
+++ branches/map65iq/fivehz.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,240 @@
+subroutine fivehz
+
+!  Called at interrupt level from the PortAudio callback routine.
+!  For nspb=2048 the callback rate is nfsample/nspb = 5.38 Hz.
+!  Thus, we should be able to control the timing of T/R sequence events
+!  here to within about 0.2 s.
+
+!  Do not do anything very time consuming in this routine!!
+!  Disk I/O is a bad idea.  Writing to stdout (for diagnostic purposes)
+!  seems to be OK.
+
+  parameter (NTRING=64)
+  real*8 tt1(0:NTRING-1)
+  logical first,txtime,filled
+  integer ptt
+  integer TxOKz
+  real*8 fs,fsample,tt,u
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  data first/.true./,nc0/1/,nc1/1/
+  save
+
+  n1=time()
+  n2=mod(n1,86400)
+  tt=n1-n2+tsec-0.1d0*ndsec
+
+  if(first) then
+     rxdelay=0.2
+     txdelay=0.4
+     tlatency=1.0
+     first=.false.
+     iptt=0
+     ntr0=-99
+     rxdone=.false.
+     ibuf00=-99
+     ncall=-1
+     u=0.05d0
+     fsample=11025.d0
+     mfsample=110250
+     filled=.false.
+  endif
+
+  if(txdelay.lt.0.2d0) txdelay=0.2d0
+
+! Measure average sampling frequency over a recent interval
+  ncall=ncall+1
+  if(ncall.eq.9) then
+     ntt0=0
+     ntt1=0
+     tt1(ntt1)=tt
+  endif
+!  if(ncall.ge.10 .and. mod(ncall,2).eq.1) then
+  if(ncall.ge.10) then
+     ntt1=iand(ntt1+1,NTRING-1)
+     tt1(ntt1)=tt
+     if(ntt1.eq.NTRING-1) filled=.true.
+     if(filled) ntt0=iand(ntt1+1,NTRING-1)
+     if(mod(ncall,2).eq.1) then
+        nd=ntt1-ntt0
+        if(nd.lt.0) nd=nd+NTRING
+        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
+        fsample=u*fs + (1.d0-u)*fsample
+        mfsample=nint(10.d0*fsample)
+     endif
+  endif
+
+  if(trperiod.le.0) trperiod=30
+  tx1=0.0                              !Time to start a TX sequence
+  tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
+  if(mode(1:4).eq.'JT65') then
+     if(nwave.lt.126*4096) nwave=126*4096
+     tx2=txdelay + nwave/11025.0
+     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
+  endif
+
+  if(TxFirst.eq.0) then
+     tx1=tx1+trperiod
+     tx2=tx2+trperiod
+  endif
+
+  t=mod(Tsec,2.d0*trperiod)
+  txtime = t.ge.tx1 .and. t.lt.tx2
+
+! If we're transmitting, freeze the input buffer pointers where they were.
+  receiving=1
+  if(((txtime .and. (lauto.eq.1)) .or. TxOK.eq.1 .or. transmitting.eq.1) &amp; 
+       .and. (mute.eq.0)) then
+     receiving=0
+     ibuf=ibuf000
+     iwrite=iwrite000
+  endif
+  ibuf000=ibuf
+  iwrite000=iwrite
+  nsec=Tsec
+  ntr=mod(nsec/trperiod,2)             !ntr=0 in 1st sequence, 1 in 2nd
+
+  if(ntr.ne.ntr0) then
+     ibuf0=ibuf                        !Start of new sequence, save ibuf
+!     if(mode(1:4).ne.'JT65') then
+!        ibuf0=ibuf0+3                  !So we don't copy our own Tx
+!        if(ibuf0.gt.1024) ibuf0=ibuf0-1024
+!     endif
+     ntime=time()                      !Save start time
+     if(mantx.eq.1 .and. iptt.eq.1) then
+        mantx=0
+        TxOK=0
+     endif
+  endif
+
+! Switch PTT line and TxOK appropriately
+  if(lauto.eq.1) then
+     if(txtime .and. iptt.eq.0 .and.          &amp;
+          mute.eq.0) i1=ptt(nport,pttport,1,iptt)        !Raise PTT
+     if(.not.txtime .or. mute.eq.1) TxOK=0               !Lower TxOK
+  else
+     if(mantx.eq.1 .and. iptt.eq.0 .and.      &amp;
+          mute.eq.0) i2=ptt(nport,pttport,1,iptt)        !Raise PTT
+     if(mantx.eq.0 .or. mute.eq.1) TxOK=0                !Lower TxOK
+  endif
+
+! Calculate Tx waveform as needed
+  if((iptt.eq.1 .and. iptt0.eq.0) .or. nrestart.eq.1) then
+     call wsjtgen
+     nrestart=0
+  endif
+
+! If PTT was just raised, start a countdown for raising TxOK:
+  nc1a=txdelay/0.18576
+  if(nc1a.lt.2) nc1a=2
+  if(iptt.eq.1 .and. iptt0.eq.0) nc1=-nc1a-1
+  if(nc1.le.0) nc1=nc1+1
+  if(nc1.eq.0) TxOK=1                               ! We are transmitting
+
+! If TxOK was just lowered, start a countdown for lowering PTT:
+  nc0a=(tlatency+txdelay)/0.18576
+  if(nc0a.lt.5) nc0a=5
+  if(TxOK.eq.0 .and. TxOKz.eq.1 .and. iptt.eq.1) nc0=-nc0a-1
+  if(nc0.le.0) nc0=nc0+1
+  if(nc0.eq.0) i3=ptt(nport,pttport,0,iptt)
+
+  if(iptt.eq.0 .and.TxOK.eq.0) then
+     sending=&quot;                      &quot;
+     sendingsh=0
+  endif
+
+  nbufs=ibuf-ibuf0
+  if(nbufs.lt.0) nbufs=nbufs+1024
+  tdata=nbufs*2048.0/11025.0
+  if(mode(1:4).eq.'JT65' .and. monitoring.eq.1 .and. tdata.gt.53.0    &amp;
+       .and. ibuf0.ne.ibuf00) then
+     rxdone=.true.
+     ibuf00=ibuf0
+  endif
+  iptt0=iptt
+  TxOKz=TxOK
+  ntr0=ntr
+
+  return
+end subroutine fivehz
+
+subroutine fivehztx
+
+!  Called at interrupt level from the PortAudio output callback.
+
+  parameter (NTRING=64)
+  real*8 tt1(0:NTRING-1)
+  logical first,filled
+  real*8 fs,fsample,tt,u
+  include 'gcom1.f90'
+  data first/.true./
+  save
+
+  n1=time()
+  n2=mod(n1,86400)
+  tt=n1-n2+tsec-0.1d0*ndsec
+
+  if(first) then
+     first=.false.
+     ncall=-1
+     fsample=11025.d0
+     u=0.05d0
+     mfsample2=110250
+     filled=.false.
+  endif
+
+! Measure average sampling frequency over a recent interval
+  ncall=ncall+1
+  if(ncall.eq.9) then
+     ntt0=0
+     ntt1=0
+     tt1(ntt1)=tt
+  endif
+  if(ncall.ge.10) then
+     ntt1=iand(ntt1+1,NTRING-1)
+     tt1(ntt1)=tt
+     if(ntt1.eq.NTRING-1) filled=.true.
+     if(filled) ntt0=iand(ntt1+1,NTRING-1)
+     if(mod(ncall,2).eq.1) then
+        nd=ntt1-ntt0
+        if(nd.lt.0) nd=nd+NTRING
+        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
+        fsample=u*fs + (1.d0-u)*fsample
+        mfsample2=nint(10.d0*fsample)
+     endif
+  endif
+
+  return
+end subroutine fivehztx
+
+subroutine addnoise(n)
+  integer*2 n
+  real*8 txsnrdb0
+  include 'gcom1.f90'
+  data idum/0/
+  save
+
+  if(txsnrdb.gt.40.0) return
+  if(txsnrdb.ne.txsnrdb0) then
+     snr=10.0**(0.05*(txsnrdb-1))
+     fac=3000.0
+     if(snr.gt.1.0) fac=3000.0/snr
+     txsnrdb0=txsnrdb
+  endif
+  i=fac*(gran(idum) + n*snr/32768.0)
+  if(i&gt;32767) i=32767;
+  if(i&lt;-32767) i=-32767;
+  n=i
+
+  return
+end subroutine addnoise
+
+real function gran(idum)
+  real r(12)
+  if(idum.lt.0) then
+     call random_seed
+     idum=0
+  endif
+  call random_number(r)
+  gran=sum(r)-6.0
+end function gran


Property changes on: branches/map65iq/fivehz.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/flushqqq.F90
===================================================================
--- branches/map65iq/flushqqq.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/flushqqq.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,10 +0,0 @@
-subroutine flushqqq(lu)
-
-#ifdef CVF
-  use dfport
-#endif
-
-  call flush(lu)
-
-  return
-end subroutine flushqqq

Added: branches/map65iq/flushqqq.f90
===================================================================
--- branches/map65iq/flushqqq.f90	                        (rev 0)
+++ branches/map65iq/flushqqq.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,10 @@
+subroutine flushqqq(lu)
+
+#ifdef CVF
+  use dfport
+#endif
+
+  call flush(lu)
+
+  return
+end subroutine flushqqq


Property changes on: branches/map65iq/flushqqq.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/fstatqqq.f90
===================================================================
--- branches/map65iq/fstatqqq.f90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/fstatqqq.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,14 +0,0 @@
-subroutine fstatqqq(lu,istat,ierr)
-
-#ifdef CVF
-  use dfport
-#endif
-
-#ifdef CVF
-  ierr=fstat(lu,istat)
-#else
-  call fstat(lu,istat,ierr)
-#endif
-
-  return
-end subroutine fstatqqq

Added: branches/map65iq/fthread.c
===================================================================
--- branches/map65iq/fthread.c	                        (rev 0)
+++ branches/map65iq/fthread.c	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,75 @@
+/*
+* fthread.c
+*
+* pthread library interface to Fortran, for OSs supporting pthreads
+*
+* Adapted from code by V. Ganesh
+*/
+#include &lt;stdio.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;stdlib.h&gt;
+
+// Create a new fortran thread through a subroutine.
+void fthread_create_(void *(*thread_func)(void *), pthread_t *theThread) 
+{
+  pthread_create(theThread, NULL, thread_func, NULL);
+} 
+
+/*
+// Yield control to other threads
+void fthread_yield_() 
+{
+  pthread_yield();
+}
+*/
+
+// Return my own thread ID
+pthread_t fthread_self_() 
+{
+  return pthread_self();
+} 
+
+// Lock the execution of all threads until we have the mutex
+int fthread_mutex_lock_(pthread_mutex_t **theMutex) 
+{
+  return(pthread_mutex_lock(*theMutex));
+}
+
+int fthread_mutex_trylock_(pthread_mutex_t **theMutex) 
+{
+  return(pthread_mutex_trylock(*theMutex));
+}
+
+// Unlock the execution of all threads that were stopped by this mutex
+void fthread_mutex_unlock_(pthread_mutex_t **theMutex) 
+{
+  pthread_mutex_unlock(*theMutex);
+}
+
+// Get a new mutex object
+void fthread_mutex_init_(pthread_mutex_t **theMutex) 
+{
+  *theMutex = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
+  pthread_mutex_init(*theMutex, NULL);
+}
+
+// Release a mutex object
+void fthread_mutex_destroy_(pthread_mutex_t **theMutex) 
+{
+  pthread_mutex_destroy(*theMutex);
+  free(*theMutex);
+}
+
+// Waits for thread ID to join
+void fthread_join(pthread_t *theThread) 
+{
+  int value = 0;
+  pthread_join(*theThread, (void **)&amp;value);
+}
+
+// Exit from a thread
+void fthread_exit_(void *status) 
+{
+  pthread_exit(status);
+}
+


Property changes on: branches/map65iq/fthread.c
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/ftn_init.F90
===================================================================
--- branches/map65iq/ftn_init.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/ftn_init.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,165 +0,0 @@
-! Fortran logical units used in WSJT6
-!
-!   10  binary input data, *.tf2 files
-!   11  decoded.txt
-!   12  decoded.ave
-!   13  tsky.dat
-!   14  azel.dat
-!   15  
-!   16
-!   17  saved *.tf2 files
-!   18  test file to be transmitted (wsjtgen.f90)
-!   19  messages.txt
-!   20  bandmap.txt
-!   21  ALL65.TXT
-!   22  kvasd.dat
-!   23  CALL3.TXT
-!   24  meas24.dat
-!   25  meas25.dat
-!   26  tmp26.txt
-!   27  dphi.txt
-!   28  
-!   29  debug.txt
-!------------------------------------------------ ftn_init
-subroutine ftn_init
-
-  character*1 cjunk
-  integer ptt
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  include 'gcom4.f90'
-
-!  print*,'ftn_init.F90 nport=', nport, 'pttport=', pttport
-  i=ptt(nport,pttport,0,iptt)                       !Clear the PTT line
-  addpfx='    '
-  nrw26=0
-
-  do i=80,1,-1
-     if(AppDir(i:i).ne.' ') goto 1
-  enddo
-1 iz=i
-  lenappdir=iz
-  call pfxdump(appdir(:iz)//'/prefixes.txt')
-
-  do i=80,1,-1
-     if(AzElDir(i:i).ne.' ') goto 2
-  enddo
-2 iz2=i
-
-#ifdef CVF
-  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
-       share='denynone',err=910)
-#else
-  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
-       err=910)
-#endif
-  endfile 11
-
-#ifdef CVF
-  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
-       share='denynone',err=920)
-#else
-  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
-       err=920)
-#endif
-  endfile 12
-
-#ifdef CVF
-  open(14,file=azeldir(:iz2)//'/azel.dat',status='unknown',                  &amp;
-       share='denynone',err=930)
-#else
-  open(14,file=azeldir(:iz2)//'/azel.dat',status='unknown',                  &amp;
-       err=930)
-#endif
-
-#ifdef CVF
-  open(19,file=appdir(:iz)//'/messages.txt',status='unknown',               &amp;
-       share='denynone',err=911)
-#else
-  open(19,file=appdir(:iz)//'/messages.txt',status='unknown',               &amp;
-       err=911)
-#endif
-  endfile 19
-
-#ifdef CVF
-  open(20,file=appdir(:iz)//'/bandmap.txt',status='unknown',               &amp;
-       share='denynone',err=912)
-#else
-  open(20,file=appdir(:iz)//'/bandmap.txt',status='unknown',               &amp;
-       err=912)
-#endif
-  endfile 20
-
-#ifdef CVF
-  open(21,file=appdir(:iz)//'/ALL65.TXT',status='unknown',                   &amp;
-       access='append',share='denynone',err=950)
-#else
-  open(21,file=appdir(:iz)//'/ALL65.TXT',status='unknown',                   &amp;
-	access='append',err=950)
-  do i=1,9999999
-     read(21,*,end=10) cjunk
-  enddo
-10 continue
-#endif
-
-#ifdef CVF
-  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
-       status='unknown',share='denynone')
-#else
-  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
-       status='unknown')
-#endif
-
-#ifdef CVF
-  open(24,file=appdir(:iz)//'/meas24.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(24,file=appdir(:iz)//'/meas24.txt',status='unknown')
-#endif
-
-#ifdef CVF
-  open(25,file=appdir(:iz)//'/meas25.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(25,file=appdir(:iz)//'/meas25.txt',status='unknown')
-#endif
-
-#ifdef CVF
-  open(26,file=appdir(:iz)//'/tmp26.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(26,file=appdir(:iz)//'/tmp26.txt',status='unknown')
-#endif
-
-#ifdef CVF
-  open(27,file=appdir(:iz)//'/dphi.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(27,file=appdir(:iz)//'/dphi.txt',status='unknown')
-#endif
-
-#ifdef CVF
-  open(29,file=appdir(:iz)//'/debug.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(29,file=appdir(:iz)//'/debug.txt',status='unknown')
-#endif
-
-
-  return
-
-910 print*,'Error opening DECODED.TXT'
-  stop
-911 print*,'Error opening messages.txt'
-  stop
-912 print*,'Error opening bandmap.txt'
-  stop
-920 print*,'Error opening DECODED.AVE'
-  stop
-930 print*,'Error opening AZEL.DAT'
-  stop
-950 print*,'Error opening ALL65.TXT'
-  stop
-
-end subroutine ftn_init

Added: branches/map65iq/ftn_init.f90
===================================================================
--- branches/map65iq/ftn_init.f90	                        (rev 0)
+++ branches/map65iq/ftn_init.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,101 @@
+subroutine ftn_init
+
+! Fortran logical units used in WSJT6
+!
+!   10  binary input data, *.tf2 files
+!   11  decoded.txt
+!   12  decoded.ave
+!   13  tsky.dat
+!   14  azel.dat
+!   15  
+!   16
+!   17  saved *.tf2 files
+!   18  test file to be transmitted (wsjtgen.f90)
+!   19  messages.txt
+!   20  bandmap.txt
+!   21  ALL65.TXT
+!   22  kvasd.dat
+!   23  CALL3.TXT
+!   24  meas24.dat
+!   25  meas25.dat
+!   26  tmp26.txt
+!   27  dphi.txt
+!   28  
+!   29  debug.txt
+!------------------------------------------------ ftn_init
+
+  character*1 cjunk
+  integer ptt
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  include 'gcom4.f90'
+
+  i=ptt(nport,pttport,0,iptt)                       !Clear the PTT line
+  addpfx='    '
+  nrw26=0
+
+  do i=80,1,-1
+     if(AppDir(i:i).ne.' ') goto 1
+  enddo
+1 iz=i
+  lenappdir=iz
+  call pfxdump(appdir(:iz)//'/prefixes.txt')
+
+  do i=80,1,-1
+     if(AzElDir(i:i).ne.' ') goto 2
+  enddo
+2 iz2=i
+
+  call cs_init
+  call cs_lock('ftn_init')
+  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',err=910)
+  endfile 11
+
+  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',err=920)
+  endfile 12
+
+  open(14,file=azeldir(:iz2)//'/azel.dat',status='unknown',err=930)
+
+  open(19,file=appdir(:iz)//'/messages.txt',status='unknown',err=911)
+  endfile 19
+
+  open(20,file=appdir(:iz)//'/bandmap.txt',status='unknown',err=912)
+  endfile 20
+
+  open(21,file=appdir(:iz)//'/ALL65.TXT',status='unknown',access='append',err=950)
+  do i=1,9999999
+     read(21,*,end=10) cjunk
+  enddo
+10 continue
+
+  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
+       status='unknown')
+
+  open(24,file=appdir(:iz)//'/meas24.txt',status='unknown')
+ 
+  open(25,file=appdir(:iz)//'/meas25.txt',status='unknown')
+
+  open(26,file=appdir(:iz)//'/tmp26.txt',status='unknown')
+
+  open(27,file=appdir(:iz)//'/dphi.txt',status='unknown')
+
+  open(29,file=appdir(:iz)//'/debug.txt',status='unknown')
+  call cs_unlock
+  
+  return
+
+910 print*,'Error opening DECODED.TXT'
+  stop
+911 print*,'Error opening messages.txt'
+  stop
+912 print*,'Error opening bandmap.txt'
+  stop
+920 print*,'Error opening DECODED.AVE'
+  stop
+930 print*,'Error opening AZEL.DAT'
+  stop
+950 print*,'Error opening ALL65.TXT'
+  stop
+
+end subroutine ftn_init


Property changes on: branches/map65iq/ftn_init.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/getfile.F90
===================================================================
--- branches/map65iq/getfile.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/getfile.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,14 +0,0 @@
-!----------------------------------------------------- getfile
-subroutine getfile(fname,len)
-  character*(*) fname
-
-  include 'datcom.f90'
-  include 'gcom2.f90'
-
-  fname80=fname
-  nlen=len
-  newdat2=1
-  ierr=0
-
-  return
-end subroutine getfile

Added: branches/map65iq/getfile.f90
===================================================================
--- branches/map65iq/getfile.f90	                        (rev 0)
+++ branches/map65iq/getfile.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,14 @@
+!----------------------------------------------------- getfile
+subroutine getfile(fname,len)
+  character*(*) fname
+
+  include 'datcom.f90'
+  include 'gcom2.f90'
+
+  fname80=fname
+  nlen=len
+  newdat2=1
+  ierr=0
+
+  return
+end subroutine getfile


Property changes on: branches/map65iq/getfile.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/getfile2.F90
===================================================================
--- branches/map65iq/getfile2.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/getfile2.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,61 +0,0 @@
-subroutine getfile2(fname,len)
-
-#ifdef CVF
-  use dflib
-#endif
-
-  character*(*) fname
-  real*8 sq
-
-  include 'datcom.f90'
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom4.f90'
-
-1 if(ndecoding.eq.0) go to 2
-#ifdef CVF
-  call sleepqq(100)
-#else
-  call usleep(100*1000)
-#endif
-
-  go to 1
-
-2 do i=len,1,-1
-     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
-  enddo
-  i=0
-10 filename=fname(i+1:)
-  ierr=0
-
-  n=4*NSMAX
-  ndecoding=4
-  monitoring=0
-  kbuf=1
-
-  call rfile3a(fname,id,n,ierr)
-  if(ierr.ne.0) then
-     print*,'Error opening or reading file: ',fname,ierr
-     go to 999
-  endif
-
-  sq=0.
-  ka=0.1*NSMAX
-  kb=0.8*NSMAX
-  do k=ka,kb
-     sq=sq + float(int(id(1,k,1)))**2 + float(int(id(2,k,1)))**2
-  enddo
-  sqave=174*sq/(kb-ka+1)
-  rxnoise=10.0*log10(sqave) - 48.0
-  read(filename(8:11),*,err=20,end=20) nutc
-  go to 30
-20 nutc=0
-
-30 ndiskdat=1
-  mousebutton=0
-  fcenter=144.130
-  if(fcfile.gt.1.5 .and. fcfile.lt.11000.0) fcenter=fcfile
-  fcfile=0.d0
-
-999 return
-end subroutine getfile2

Added: branches/map65iq/getfile2.f90
===================================================================
--- branches/map65iq/getfile2.f90	                        (rev 0)
+++ branches/map65iq/getfile2.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,55 @@
+subroutine getfile2(fname,len)
+
+  character*(*) fname
+  real*8 sq
+
+  include 'datcom.f90'
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom4.f90'
+
+1 if(ndecoding.eq.0) go to 2
+  call usleep(100*1000)
+
+  go to 1
+
+2 do i=len,1,-1
+     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
+  enddo
+  i=0
+10 filename=fname(i+1:)
+  ierr=0
+
+  n=4*NSMAX
+  ndecoding=4
+  monitoring=0
+  kbuf=1
+
+  call rfile3a(fname,id,n,ierr)
+  if(ierr.ne.0) then
+     print*,'Error opening or reading file: ',fname,ierr
+     go to 999
+  endif
+
+  sq=0.
+  ka=0.1*NSMAX
+  kb=0.8*NSMAX
+  do k=ka,kb
+     sq=sq + float(int(id(1,k,1)))**2 + float(int(id(2,k,1)))**2
+  enddo
+  sqave=174*sq/(kb-ka+1)
+  rxnoise=10.0*log10(sqave) - 48.0
+  call cs_lock('getfile2')
+  read(filename(8:11),*,err=20,end=20) nutc
+  call cs_unlock
+  go to 30
+20 nutc=0
+
+30 ndiskdat=1
+  mousebutton=0
+  fcenter=144.130
+  if(fcfile.gt.1.5 .and. fcfile.lt.11000.0) fcenter=fcfile
+  fcfile=0.d0
+
+999 return
+end subroutine getfile2


Property changes on: branches/map65iq/getfile2.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65iq/map65.py
===================================================================
--- branches/map65iq/map65.py	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/map65.py	2010-11-19 18:19:55 UTC (rev 2257)
@@ -43,7 +43,6 @@
         pass
 root_geom=&quot;&quot;
 
-
 #------------------------------------------------------ Global variables
 appdir=os.getcwd()
 g.appdir=appdir
@@ -1864,6 +1863,7 @@
 f.truncate(0)
 f.close
 Audio.ftn_init()
+
 GenStdMsgs()
 Audio.gcom4.addpfx=(options.addpfx.get().lstrip()+'        ')[:8]
 Audio.gcom2.mousefqso=130

Deleted: branches/map65iq/map65a.F90
===================================================================
--- branches/map65iq/map65a.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/map65a.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,331 +0,0 @@
-subroutine map65a(newdat)
-
-!  Processes timf2 data from Linrad to find and decode JT65 signals.
-
-  parameter (MAXMSG=1000)            !Size of decoded message list
-  real tavg(-50:50)                  !Temp for finding local base level
-  real tmp (200)                     !Temp storage for pctile sorting
-  real sig(MAXMSG,30)                !Parameters of detected signals
-  real a(5)
-  character*22 msg(MAXMSG)
-  character*3 shmsg0(4)
-  integer indx(MAXMSG),nsiz(MAXMSG)
-  logical done(MAXMSG)
-  character decoded*22,blank*22
-  include 'spcom.f90'
-  real short(2,NFFT)                 !SNR, dt for potential shorthands
-  include 'gcom2.f90'
-  include 'datcom.f90'
-  data blank/'                      '/
-  data shmsg0/'   ','RO ','RRR','73 '/
-  data nfile/0/,nutc0/-999/,mousefqso0/-999/
-  save
-
-  if(mousefqso.ne.mousefqso0 .and. nagain.eq.1) newspec=2
-  mousefqso0=mousefqso
-
-  rewind 11
-  rewind 12
-  if(nrw26.ne.0) then
-     endfile (26)              !Compiler bug?  Don't write &quot;end file 26&quot; !!!
-     rewind 26
-     rewind 19
-     endfile (19)
-     rewind 19
-     nrw26=0
-  endif
-
-#ifdef CVF
-  open(23,file='CALL3.TXT',status='unknown',share='denynone')
-#else
-  open(23,file='CALL3.TXT',status='unknown')
-#endif
-
-  if(nutc.ne.nutc0) nfile=nfile+1
-  nutc0=nutc
-  fsample=66666667.0/700.0                !fsample=95238.1
-  df=fsample/NFFT                         !df = 2.906 Hz
-  ftol=0.020                              !Frequency tolerance (kHz)
-  foffset=0.001*(1270 + nfcal)            !Offset from sync tone plus cal
-  fqso=mousefqso-0.5*(nfa+nfb)+foffset    !fQSO at baseband (kHz)
-
-  do i=12,3,-1
-     if(hiscall(i:i).ne.' ') go to 1
-  enddo
-  i=0
-1 len_hiscall=i
-
-  do nqd=1,0,-1
-     if(nqd.eq.1) then                     !Quick decode, at fQSO
-        fa=1000.0*(fqso+0.001*mousedf) - dftolerance
-        fb=1000.0*(fqso+0.001*mousedf) + dftolerance + mode65*107.666016
-     else                                  !Wideband decode at all freqs
-        fa=-500*(nfb-nfa)
-        fb= 500*(nfb-nfa)
-     endif
-     ia=nint(fa/df) + 16385
-     ib=nint(fb/df) + 16385
-     ia=max(51,ia)
-     ib=min(32768-51,ib)
-
-     km=0
-     nkm=1
-     nz=n/8
-     freq0=-999.
-     sync10=-999.
-     fshort0=-999.
-     sync20=-999.
-     ntry=0
-     short=0.                              !Zero the whole short array
-
-     do i=ia,ib                            !Search over freq range
-        call sleep_msec(0)
-        freq=0.001*(i-16385)*df
-!  Find the local base level; update every 10 bins.
-        if(mod(i-ia,10).eq.0) then
-           do ii=-50,50
-              tavg(ii)=savg(i+ii)
-           enddo
-           call pctile(tavg,tmp,101,50,base)
-        endif
-
-!  Do not process extremely strong signals
-        if(nqd.eq.0 .and. base.gt.1000.0) go to 70
-        smax=savg(i)/base
-
-        if(smax.gt.1.1) then
-           ntry=ntry+1
-!  Look for JT65 sync patterns and shorthand square-wave patterns.
-           call ccf65(ss(1,i),nhsym,sync1,dt,flipk,mode65,            &amp;
-                sync2,snr2,dt2)
-
-! ########################### Search for Shorthand Messages #################
-!  Is there a shorthand tone above threshold?
-           thresh0=1.0
-!  Use lower thresh0 at fQSO
-           if(nqd.eq.1 .and. dftolerance.le.100) thresh0=0.
-
-           if(sync2.gt.thresh0) then
-! ### Do shorthand AFC here (or maybe after finding a pair?) ###
-              short(1,i)=sync2
-              short(2,i)=dt2
-
-!  Check to see if lower tone of shorthand pair was found.
-              do j=2,4
-                 i0=i-nint(j*mode65*10.0*(11025.0/4096.0)/df)
-!  Should this be i0 +/- 1, or just i0?
-!  Should we also insist that difference in DT be either 1.5 or -1.5 s?
-                 if(short(1,i0).gt.1.0) then
-                    fshort=0.001*(i0-16385)*df
-                    noffset=0
-                    if(nqd.eq.1) noffset=nint(1000.0*(freq-fqso)-mousedf)
-                    if(abs(noffset).le.dftolerance) then
-!  Keep only the best candidate within ftol.
-!### NB: sync2 was not defined here!
-                       if(fshort-fshort0.le.ftol .and. sync2.gt.sync20    &amp;
-                            .and. nkm.eq.2) km=km-1
-                       if(fshort-fshort0.gt.ftol .or. sync2.gt.sync20) then
-                          km=km+1
-                          sig(km,1)=nfile
-                          sig(km,2)=nutc
-                          sig(km,3)=fshort + 0.5*(nfa+nfb)
-                          sig(km,4)=sync2
-                          sig(km,5)=dt2
-                          sig(km,6)=0
-                          sig(km,7)=0
-                          sig(km,8)=snr2
-                          sig(km,9)=0
-                          sig(km,10)=0
-                          sig(km,12)=savg(i)
-                          sig(km,13)=0
-                          sig(km,14)=0
-                          sig(km,15)=0
-                          sig(km,16)=0
-                          sig(km,18)=0
-                          msg(km)=shmsg0(j)
-                          fshort0=fshort
-                          sync20=sync2
-                          nkm=2
-                       endif
-                    endif
-                 endif
-              enddo
-           endif
-
-! ########################### Search for Normal Messages ###########
-!  Is sync1 above threshold?
-           thresh1=1.0
-!  Use lower thresh1 at fQSO
-           if(nqd.eq.1 .and. dftolerance.le.100) thresh1=0.
-           noffset=0
-           if(nqd.eq.1) noffset=nint(1000.0*(freq-fqso)-mousedf)
-           if(sync1.gt.thresh1 .and. abs(noffset).le.dftolerance) then
-!  Keep only the best candidate within ftol.
-!  (Am I deleting any good decodes by doing this?)
-              if(freq-freq0.le.ftol .and. sync1.gt.sync10 .and.             &amp;
-                   nkm.eq.1) km=km-1
-              if(freq-freq0.gt.ftol .or. sync1.gt.sync10) then
-                 nflip=nint(flipk)
-                 f00=(i-1)*df        !Freq of detected sync tone (0-95238 Hz)
-                 call decode1a(id(1,1,kbuf),newdat,f00,nflip,mode65,        &amp;
-                      mycall,hiscall,hisgrid,neme,ndepth,nqd,dphi,ndphi,    &amp;
-                      sync2,a,dt,nkv,nhist,qual,decoded)
-                 km=min(1000,km+1)
-                 sig(km,1)=nfile
-                 sig(km,2)=nutc
-                 sig(km,3)=freq + 0.5*(nfa+nfb)
-                 sig(km,4)=sync1
-                 sig(km,5)=dt
-                 sig(km,6)=0.
-                 sig(km,7)=flipk
-                 sig(km,8)=sync2
-                 sig(km,9)=nkv
-                 sig(km,10)=qual
-                 sig(km,12)=savg(i)
-                 sig(km,13)=a(1)
-                 sig(km,14)=a(2)
-                 sig(km,15)=a(3)
-                 sig(km,16)=a(4)
-                 sig(km,18)=nhist
-                 msg(km)=decoded
-                 freq0=freq
-                 sync10=sync1
-                 nkm=1
-              endif
-           endif
-        endif
-70      continue
-     enddo
-
-     if(nqd.eq.1) then
-        nwrite=0
-        do k=1,km
-           decoded=msg(k)
-           if(decoded.ne.'                      ') then
-              nutc=sig(k,2)
-              freq=sig(k,3)
-              sync1=sig(k,4)
-              dt=sig(k,5)
-              npol=0
-              flip=sig(k,7)
-              sync2=sig(k,8)
-              nkv=sig(k,9)
-              nqual=sig(k,10)
-              if(flip.lt.0.0) then
-                 do i=22,1,-1
-                    if(decoded(i:i).ne.' ') go to 8
-                 enddo
-                 stop 'Error in message format'
-8                if(i.le.18) decoded(i+2:i+4)='OOO'
-              endif
-              nkHz=nint(freq-foffset)
-              mhz=fcenter+fadd
-              f0=mhz+0.001*nkHz
-              ndf=nint(1000.0*(freq-foffset-nkHz))
-              nsync1=sync1
-              nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
-              if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
-                 decoded(1:4).eq.'73  ') nsync2=nsync2-6
-              nwrite=nwrite+1
-              npol=0
-              write(11,1010) nkHz,ndf,npol,nutc,dt,nsync2,decoded,nkv,nqual
-1010          format(i3.3,i5,i4,i5.4,f5.1,i4,2x,a22,i5,i5)
-           endif
-        enddo
-        if(nwrite.eq.0) then
-           write(11,1012) mousefqso,nutc
-1012          format(i3.3,9x,i5.4)
-        endif
-   
-     endif
-     if(nqd.eq.1) then
-        write(11,*) '$EOF'
-        call flushqqq(11)
-        ndecdone=1
-     endif
-     if(nagain.eq.1) go to 999
-  enddo
-
-!  Trim the list and produce a sorted index and sizes of groups.
-!  (Should trimlist remove all but best SNR for given UTC and message content?)
-  call trimlist(sig,km,indx,nsiz,nz)
-
-  do i=1,km
-     done(i)=.false.
-  enddo
-  j=0
-  ilatest=-1
-  do n=1,nz
-     ifile0=0
-     do m=1,nsiz(n)
-        i=indx(j+m)
-        ifile=sig(i,1)
-        if(ifile.gt.ifile0 .and.msg(i).ne.blank) then
-           ilatest=i
-           ifile0=ifile
-        endif
-     enddo
-     i=ilatest
-
-     if(i.ge.1) then
-        if(.not.done(i)) then
-           done(i)=.true.
-           nutc=sig(i,2)
-           freq=sig(i,3)
-           sync1=sig(i,4)
-           dt=sig(i,5)
-           flip=sig(i,7)
-           sync2=sig(i,8)
-           nkv=sig(i,9)
-           nqual=min(sig(i,10),10.0)
-           do k=1,5
-              a(k)=sig(i,12+k)
-           enddo
-           nhist=sig(i,18)
-           decoded=msg(i)
-           
-           if(flip.lt.0.0) then
-              do i=22,1,-1
-                 if(decoded(i:i).ne.' ') go to 10
-              enddo
-              stop 'Error in message format'
-10            if(i.le.18) decoded(i+2:i+4)='OOO'
-           endif
-           mhz=fcenter+fadd
-           nkHz=nint(freq-foffset)
-           f0=mhz+0.001*nkHz
-           ndf=nint(1000.0*(freq-foffset-nkHz))
-           ndf0=nint(a(1))
-           ndf1=nint(a(2))
-           ndf2=nint(a(3))
-           nsync1=sync1
-           nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
-           if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
-                decoded(1:4).eq.'73  ') nsync2=nsync2-6
-           write(26,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
-                nsync2,nutc,decoded,nkv,nqual,nhist
-           write(21,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
-                nsync2,nutc,decoded,nkv,nqual,nhist
-1014       format(f9.3,i5,3i3,f5.1,i5,i3,i4,i5.4,2x,a22,3i3)
-
-        endif
-     endif
-     j=j+nsiz(n)
-  enddo
-  write(26,1015) nutc
-1015 format(41x,i4.4)
-  call flushqqq(26)
-  call display(nkeep,ncsmin,mhz)
-  ndecdone=2
-
-  if(nsave.gt.0 .and. ndiskdat.eq.0) call savetf2(id(1,1,kbuf),       &amp;
-       fnamedate,savedir,fcenter+fadd)
-
-999 close(23)
-  if(kbuf.eq.1) kkdone=60*96000
-  if(kbuf.eq.2 .or. ndiskdat.eq.1) kkdone=0
-  kk=kkdone
-  nagain=0
-
-  return
-end subroutine map65a

Added: branches/map65iq/map65a.f90
===================================================================
--- branches/map65iq/map65a.f90	                        (rev 0)
+++ branches/map65iq/map65a.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,340 @@
+subroutine map65a(newdat)
+
+!  Processes timf2 data from Linrad to find and decode JT65 signals.
+
+  parameter (MAXMSG=1000)            !Size of decoded message list
+  real tavg(-50:50)                  !Temp for finding local base level
+  real tmp (200)                     !Temp storage for pctile sorting
+  real sig(MAXMSG,30)                !Parameters of detected signals
+  real a(5)
+  character*22 msg(MAXMSG)
+  character*3 shmsg0(4)
+  integer indx(MAXMSG),nsiz(MAXMSG)
+  logical done(MAXMSG)
+  character decoded*22,blank*22
+  include 'spcom.f90'
+  real short(2,NFFT)                 !SNR, dt for potential shorthands
+  include 'gcom2.f90'
+  include 'datcom.f90'
+  data blank/'                      '/
+  data shmsg0/'   ','RO ','RRR','73 '/
+  data nfile/0/,nutc0/-999/,mousefqso0/-999/
+  save
+
+  if(mousefqso.ne.mousefqso0 .and. nagain.eq.1) newspec=2
+  mousefqso0=mousefqso
+
+  rewind 11
+  rewind 12
+  if(nrw26.ne.0) then
+     endfile (26)              !Compiler bug?  Don't write &quot;end file 26&quot; !!!
+     rewind 26
+     rewind 19
+     endfile (19)
+     rewind 19
+     nrw26=0
+  endif
+
+  open(23,file='CALL3.TXT',status='unknown')
+
+  if(nutc.ne.nutc0) nfile=nfile+1
+  nutc0=nutc
+  fsample=66666667.0/700.0                !fsample=95238.1
+  df=fsample/NFFT                         !df = 2.906 Hz
+  ftol=0.020                              !Frequency tolerance (kHz)
+  foffset=0.001*(1270 + nfcal)            !Offset from sync tone plus cal
+  fqso=mousefqso-0.5*(nfa+nfb)+foffset    !fQSO at baseband (kHz)
+
+  do i=12,3,-1
+     if(hiscall(i:i).ne.' ') go to 1
+  enddo
+  i=0
+1 len_hiscall=i
+
+  do nqd=1,0,-1
+     if(nqd.eq.1) then                     !Quick decode, at fQSO
+        fa=1000.0*(fqso+0.001*mousedf) - dftolerance
+        fb=1000.0*(fqso+0.001*mousedf) + dftolerance + mode65*107.666016
+     else                                  !Wideband decode at all freqs
+        fa=-500*(nfb-nfa)
+        fb= 500*(nfb-nfa)
+     endif
+     ia=nint(fa/df) + 16385
+     ib=nint(fb/df) + 16385
+     ia=max(51,ia)
+     ib=min(32768-51,ib)
+
+     km=0
+     nkm=1
+     nz=n/8
+     freq0=-999.
+     sync10=-999.
+     fshort0=-999.
+     sync20=-999.
+     ntry=0
+     short=0.                              !Zero the whole short array
+
+     do i=ia,ib                            !Search over freq range
+        call sleep_msec(0)
+        freq=0.001*(i-16385)*df
+!  Find the local base level; update every 10 bins.
+        if(mod(i-ia,10).eq.0) then
+           do ii=-50,50
+              tavg(ii)=savg(i+ii)
+           enddo
+           call pctile(tavg,tmp,101,50,base)
+        endif
+
+!  Do not process extremely strong signals
+        if(nqd.eq.0 .and. base.gt.1000.0) go to 70
+        smax=savg(i)/base
+
+        if(smax.gt.1.1) then
+           ntry=ntry+1
+!  Look for JT65 sync patterns and shorthand square-wave patterns.
+           call ccf65(ss(1,i),nhsym,sync1,dt,flipk,mode65,            &amp;
+                sync2,snr2,dt2)
+
+! ########################### Search for Shorthand Messages #################
+!  Is there a shorthand tone above threshold?
+           thresh0=1.0
+!  Use lower thresh0 at fQSO
+           if(nqd.eq.1 .and. dftolerance.le.100) thresh0=0.
+
+           if(sync2.gt.thresh0) then
+! ### Do shorthand AFC here (or maybe after finding a pair?) ###
+              short(1,i)=sync2
+              short(2,i)=dt2
+
+!  Check to see if lower tone of shorthand pair was found.
+              do j=2,4
+                 i0=i-nint(j*mode65*10.0*(11025.0/4096.0)/df)
+!  Should this be i0 +/- 1, or just i0?
+!  Should we also insist that difference in DT be either 1.5 or -1.5 s?
+                 if(short(1,i0).gt.1.0) then
+                    fshort=0.001*(i0-16385)*df
+                    noffset=0
+                    if(nqd.eq.1) noffset=nint(1000.0*(freq-fqso)-mousedf)
+                    if(abs(noffset).le.dftolerance) then
+!  Keep only the best candidate within ftol.
+!### NB: sync2 was not defined here!
+                       if(fshort-fshort0.le.ftol .and. sync2.gt.sync20    &amp;
+                            .and. nkm.eq.2) km=km-1
+                       if(fshort-fshort0.gt.ftol .or. sync2.gt.sync20) then
+                          km=km+1
+                          sig(km,1)=nfile
+                          sig(km,2)=nutc
+                          sig(km,3)=fshort + 0.5*(nfa+nfb)
+                          sig(km,4)=sync2
+                          sig(km,5)=dt2
+                          sig(km,6)=0
+                          sig(km,7)=0
+                          sig(km,8)=snr2
+                          sig(km,9)=0
+                          sig(km,10)=0
+                          sig(km,12)=savg(i)
+                          sig(km,13)=0
+                          sig(km,14)=0
+                          sig(km,15)=0
+                          sig(km,16)=0
+                          sig(km,18)=0
+                          msg(km)=shmsg0(j)
+                          fshort0=fshort
+                          sync20=sync2
+                          nkm=2
+                       endif
+                    endif
+                 endif
+              enddo
+           endif
+
+! ########################### Search for Normal Messages ###########
+!  Is sync1 above threshold?
+           thresh1=1.0
+!  Use lower thresh1 at fQSO
+           if(nqd.eq.1 .and. dftolerance.le.100) thresh1=0.
+           noffset=0
+           if(nqd.eq.1) noffset=nint(1000.0*(freq-fqso)-mousedf)
+           if(sync1.gt.thresh1 .and. abs(noffset).le.dftolerance) then
+!  Keep only the best candidate within ftol.
+!  (Am I deleting any good decodes by doing this?)
+              if(freq-freq0.le.ftol .and. sync1.gt.sync10 .and.             &amp;
+                   nkm.eq.1) km=km-1
+              if(freq-freq0.gt.ftol .or. sync1.gt.sync10) then
+                 nflip=nint(flipk)
+                 f00=(i-1)*df        !Freq of detected sync tone (0-95238 Hz)
+                 call decode1a(id(1,1,kbuf),newdat,f00,nflip,mode65,        &amp;
+                      mycall,hiscall,hisgrid,neme,ndepth,nqd,dphi,ndphi,    &amp;
+                      sync2,a,dt,nkv,nhist,qual,decoded)
+                 km=min(1000,km+1)
+                 sig(km,1)=nfile
+                 sig(km,2)=nutc
+                 sig(km,3)=freq + 0.5*(nfa+nfb)
+                 sig(km,4)=sync1
+                 sig(km,5)=dt
+                 sig(km,6)=0.
+                 sig(km,7)=flipk
+                 sig(km,8)=sync2
+                 sig(km,9)=nkv
+                 sig(km,10)=qual
+                 sig(km,12)=savg(i)
+                 sig(km,13)=a(1)
+                 sig(km,14)=a(2)
+                 sig(km,15)=a(3)
+                 sig(km,16)=a(4)
+                 sig(km,18)=nhist
+                 msg(km)=decoded
+                 freq0=freq
+                 sync10=sync1
+                 nkm=1
+              endif
+           endif
+        endif
+70      continue
+     enddo
+
+     if(nqd.eq.1) then
+        nwrite=0
+        do k=1,km
+           decoded=msg(k)
+           if(decoded.ne.'                      ') then
+              nutc=sig(k,2)
+              freq=sig(k,3)
+              sync1=sig(k,4)
+              dt=sig(k,5)
+              npol=0
+              flip=sig(k,7)
+              sync2=sig(k,8)
+              nkv=sig(k,9)
+              nqual=sig(k,10)
+              if(flip.lt.0.0) then
+                 do i=22,1,-1
+                    if(decoded(i:i).ne.' ') go to 8
+                 enddo
+                 stop 'Error in message format'
+8                if(i.le.18) decoded(i+2:i+4)='OOO'
+              endif
+              nkHz=nint(freq-foffset)
+              mhz=fcenter+fadd
+              f0=mhz+0.001*nkHz
+              ndf=nint(1000.0*(freq-foffset-nkHz))
+              nsync1=sync1
+              nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
+              if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
+                 decoded(1:4).eq.'73  ') nsync2=nsync2-6
+              nwrite=nwrite+1
+              npol=0
+
+              call cs_lock('map65a')
+              write(11,1010) nkHz,ndf,npol,nutc,dt,nsync2,decoded,nkv,nqual
+1010          format(i3.3,i5,i4,i5.4,f5.1,i4,2x,a22,i5,i5)
+              call cs_unlock
+
+           endif
+        enddo
+        if(nwrite.eq.0) then
+           call cs_lock('map65a')
+           write(11,1012) mousefqso,nutc
+1012       format(i3.3,9x,i5.4)
+           call cs_unlock
+        endif
+   
+     endif
+     if(nqd.eq.1) then
+        write(11,*) '$EOF'
+        call flush(11)
+        ndecdone=1
+     endif
+     if(nagain.eq.1) go to 999
+  enddo
+
+!  Trim the list and produce a sorted index and sizes of groups.
+!  (Should trimlist remove all but best SNR for given UTC and message content?)
+  call trimlist(sig,km,indx,nsiz,nz)
+
+  do i=1,km
+     done(i)=.false.
+  enddo
+  j=0
+  ilatest=-1
+  do n=1,nz
+     ifile0=0
+     do m=1,nsiz(n)
+        i=indx(j+m)
+        ifile=sig(i,1)
+        if(ifile.gt.ifile0 .and.msg(i).ne.blank) then
+           ilatest=i
+           ifile0=ifile
+        endif
+     enddo
+     i=ilatest
+
+     if(i.ge.1) then
+        if(.not.done(i)) then
+           done(i)=.true.
+           nutc=sig(i,2)
+           freq=sig(i,3)
+           sync1=sig(i,4)
+           dt=sig(i,5)
+           flip=sig(i,7)
+           sync2=sig(i,8)
+           nkv=sig(i,9)
+           nqual=min(sig(i,10),10.0)
+           do k=1,5
+              a(k)=sig(i,12+k)
+           enddo
+           nhist=sig(i,18)
+           decoded=msg(i)
+           
+           if(flip.lt.0.0) then
+              do i=22,1,-1
+                 if(decoded(i:i).ne.' ') go to 10
+              enddo
+              stop 'Error in message format'
+10            if(i.le.18) decoded(i+2:i+4)='OOO'
+           endif
+           mhz=fcenter+fadd
+           nkHz=nint(freq-foffset)
+           f0=mhz+0.001*nkHz
+           ndf=nint(1000.0*(freq-foffset-nkHz))
+           ndf0=nint(a(1))
+           ndf1=nint(a(2))
+           ndf2=nint(a(3))
+           nsync1=sync1
+           nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
+           if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
+                decoded(1:4).eq.'73  ') nsync2=nsync2-6
+
+           call cs_lock('map65a')
+           write(26,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
+                nsync2,nutc,decoded,nkv,nqual,nhist
+           write(21,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
+                nsync2,nutc,decoded,nkv,nqual,nhist
+1014       format(f9.3,i5,3i3,f5.1,i5,i3,i4,i5.4,2x,a22,3i3)
+           call cs_unlock
+
+        endif
+     endif
+     j=j+nsiz(n)
+  enddo
+
+  call cs_lock('map65a')
+  write(26,1015) nutc
+1015 format(41x,i4.4)
+  call flush(26)
+  call cs_unlock
+
+  call display(nkeep,ncsmin,mhz)
+  ndecdone=2
+
+  if(nsave.gt.0 .and. ndiskdat.eq.0) call savetf2(id(1,1,kbuf),       &amp;
+       fnamedate,savedir,fcenter+fadd)
+
+999 close(23)
+  if(kbuf.eq.1) kkdone=60*96000
+  if(kbuf.eq.2 .or. ndiskdat.eq.1) kkdone=0
+  kk=kkdone
+  nagain=0
+
+  return
+end subroutine map65a


Property changes on: branches/map65iq/map65a.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/plrr.F90
===================================================================
--- branches/map65iq/plrr.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/plrr.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,63 +0,0 @@
-program plrr
-
-!  Pseudo-Linrad &quot;Receive&quot; program
-
-  integer*1 userx_no,iusb
-  integer*2 nblock,nblock0
-  integer*2 id(2,348)
-  real*8 center_freq
-  logical first
-  common/plrscom/center_freq,msec,fselect,iptr,nblock,userx_no,iusb,buf4(348)
-  equivalence (id,buf4)
-  data first/.true./
-
-  call setup_rsocket(0)
-  ns0=-99
-  nlost=0
-  k=0
-
-10 call recv_pkt(center_freq)
-
-  lost=nblock-nblock0-1
-  if(lost.ne.0 .and. .not.first) then
-     nb=nblock
-     if(nb.lt.0) nb=nb+65536
-     nb0=nblock0
-     if(nb0.lt.0) nb0=nb0+65536
-     print*,'Lost packets:',nb,nb0,lost
-     first=.false.
-     nlost=nlost+lost
-  endif
-  nblock0=nblock
-  ns=mod(msec/1000,60)
-  if(ns.ne.ns0) then
-     sumi=0.
-     sumq=0.
-     sqi=0.
-     sqq=0.
-     do i=1,348
-        xi=id(1,i)
-        xq=id(2,i)
-        sumi=sumi + xi
-        sumq=sumq + xq
-        sqi=sqi + xi*xi
-        sqq=sqq + xq*xq
-        k=k+1
-        write(52,4001) k,id(1,i),id(2,i)
-4001    format(3i10)
-     enddo
-     avei=sumi/348.
-     aveq=sumq/348.
-     rmsi=sqrt(sqi/348.)
-     rmsq=sqrt(sqq/348.)
-     write(*,1010) ns,center_freq,0.001*msec,sec_midn(),nlost,  &amp;
-          avei,aveq,rmsi,rmsq
-1010 format(i3,f10.3,f10.3,f10.3,i5,4f8.1)
-     ns0=ns
-  endif
-
-  go to 10
-
-end program plrr
-
-! To compile: % gfortran -o plrr plrr.f90 sec_midn.F90 plrr_subs.c

Added: branches/map65iq/plrr.f90
===================================================================
--- branches/map65iq/plrr.f90	                        (rev 0)
+++ branches/map65iq/plrr.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,63 @@
+program plrr
+
+!  Pseudo-Linrad &quot;Receive&quot; program
+
+  integer*1 userx_no,iusb
+  integer*2 nblock,nblock0
+  integer*2 id(2,348)
+  real*8 center_freq
+  logical first
+  common/plrscom/center_freq,msec,fselect,iptr,nblock,userx_no,iusb,buf4(348)
+  equivalence (id,buf4)
+  data first/.true./
+
+  call setup_rsocket(0)
+  ns0=-99
+  nlost=0
+  k=0
+
+10 call recv_pkt(center_freq)
+
+  lost=nblock-nblock0-1
+  if(lost.ne.0 .and. .not.first) then
+     nb=nblock
+     if(nb.lt.0) nb=nb+65536
+     nb0=nblock0
+     if(nb0.lt.0) nb0=nb0+65536
+     print*,'Lost packets:',nb,nb0,lost
+     first=.false.
+     nlost=nlost+lost
+  endif
+  nblock0=nblock
+  ns=mod(msec/1000,60)
+  if(ns.ne.ns0) then
+     sumi=0.
+     sumq=0.
+     sqi=0.
+     sqq=0.
+     do i=1,348
+        xi=id(1,i)
+        xq=id(2,i)
+        sumi=sumi + xi
+        sumq=sumq + xq
+        sqi=sqi + xi*xi
+        sqq=sqq + xq*xq
+        k=k+1
+        write(52,4001) k,id(1,i),id(2,i)
+4001    format(3i10)
+     enddo
+     avei=sumi/348.
+     aveq=sumq/348.
+     rmsi=sqrt(sqi/348.)
+     rmsq=sqrt(sqq/348.)
+     write(*,1010) ns,center_freq,0.001*msec,sec_midn(),nlost,  &amp;
+          avei,aveq,rmsi,rmsq
+1010 format(i3,f10.3,f10.3,f10.3,i5,4f8.1)
+     ns0=ns
+  endif
+
+  go to 10
+
+end program plrr
+
+! To compile: % gfortran -o plrr plrr.f90 sec_midn.F90 plrr_subs.c


Property changes on: branches/map65iq/plrr.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/plrs.F90
===================================================================
--- branches/map65iq/plrs.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/plrs.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,123 +0,0 @@
-program plrs
-
-! Pseudo-Linrad &quot;Send&quot; program.  Reads recorded Linrad data from &quot;*.tf2&quot;
-! files, and multicasts it as Linrad would do for timf2 data.
-
-  integer RMODE
-  parameter(RMODE=0)
-  parameter (NBPP=1392)                  !Bytes of sampled data per packet
-!  parameter (NZ=60*96000)
-  parameter (NZ=6*952381)
-  parameter (NBYTES=4*NZ)
-  parameter (NPPR=NBYTES/NBPP)
-  integer*1 userx_no,iusb
-  integer*2 nblock
-  real*8 d(NZ),buf8
-  integer fd
-  integer open,read,close
-  integer nm(11)
-  character*8 fname,arg,cjunk*1
-  logical fast,pause
-  real*8 center_freq,dmsec,dtmspacket,tmsec
-  common/plrscom/center_freq,msec2,fsample,iptr,nblock,userx_no,iusb,buf8(174)
-  data nm/45,46,48,50,52,54,55,56,57,58,59/
-  data nblock/0/,fast/.false./,pause/.false./
-
-  nargs=iargc()
-  if(nargs.ne.4) then
-     print*,'Usage: plrs &lt;fast|pause|slow&gt; &lt;minutes&gt; &lt;iters&gt; &lt;iwait&gt;'
-     go to 999
-  endif
-
-  call getarg(1,arg)
-  if(arg(1:1).eq.'f' .or. arg(1:1).eq.'p') fast=.true.
-  if(arg(1:1).eq.'p') pause=.true.
-  call getarg(2,arg)
-  read(arg,*) nfiles
-  call getarg(3,arg)
-  read(arg,*) iters
-  call getarg(4,arg)
-  read(arg,*) iwait
-
-  if(iwait.ne.0) then
-1    if(mod(int(sec_midn()),60).eq.0) go to 2
-     call sleep_msec(100)
-     go to 1
-  endif
-
-2 fname=&quot;all.iq&quot;//char(0)
-  userx_no=0
-  iusb=1
-  center_freq=144.125d0
-!  dtmspacket=1000.d0*NBPP/(8.d0*96000.d0)
-  dtmspacket=1000.d0*NBPP/(4.d0*95238.1d0)
-  print*,nz,nbytes,nppr,dtmspacket
-
-!  fsample=96000.0
-  fsample=95238.1
-  npkt=0
-
-  call setup_ssocket                       !Open a socket for multicasting
-
-  do iter=1,iters
-#ifdef CVF
-     open(10,file=fname,form='binary',status='old')
-#else
-     open(10,file=fname,access='stream',status='old')
-!     fd=open(fname,RMODE)                  !Open file for reading
-#endif
-     dmsec=-dtmspacket
-     nsec0=sec_midn()
-
-     do ifile=1,nfiles
-        ns0=0
-        tmsec=1000*(3600*7 + 60*nm(ifile))-dtmspacket
-        k=0
-        do ipacket=1,NPPR
-           dmsec=dmsec+dtmspacket
-           tmsec=tmsec+dtmspacket
-           msec2=nint(tmsec)
-           msec=nint(dmsec)
-
-#ifdef CVF
-           read(10) buf8
-#else
-           read(10) buf8
-!           nr=read(fd,buf8,NBPP)
-!           if(nr.ne.NBPP) then
-!              print*,'Error reading file all.tf2'
-!              go to 999
-!           endif
-#endif
-           nblock=nblock+1
-           call send_pkt(center_freq)
-           npkt=npkt+1
-              
-           if(mod(npkt,100).eq.0) then
-              nsec=int(sec_midn())-nsec0
-              nwait=msec-1000*nsec
-!  Pace the data at close to its real-time rate
-              if(nwait.gt.0 .and. .not.fast) call sleep_msec(nwait)
-           endif
-           ns=mod(msec2/1000,60)
-           if(ns.ne.ns0) write(*,1010) ns,center_freq,0.001*msec2,sec_midn()
-1010       format('ns:',i3,'   f0:',f10.3,'   t1:',f10.3,'   t2:',f10.3)
-           ns0=ns
-        enddo
-        if(pause) then
-           print*,'Type anything to continue:'
-           read(*,*) cjunk,pause,fast
-        endif
-     enddo
-#ifdef CVF
-     close(10)
-#else
-     close(10)
-!     i=close(fd)
-#endif
-  enddo
-
-
-999 end program plrs
-
-! To compile: % gfortran -o plrs plrs.f90 plrs_subs.c cutil.c

Added: branches/map65iq/plrs.f90
===================================================================
--- branches/map65iq/plrs.f90	                        (rev 0)
+++ branches/map65iq/plrs.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,104 @@
+program plrs
+
+! Pseudo-Linrad &quot;Send&quot; program.  Reads recorded Linrad data from &quot;*.tf2&quot;
+! files, and multicasts it as Linrad would do for timf2 data.
+
+  integer RMODE
+  parameter(RMODE=0)
+  parameter (NBPP=1392)                  !Bytes of sampled data per packet
+!  parameter (NZ=60*96000)
+  parameter (NZ=6*952381)
+  parameter (NBYTES=4*NZ)
+  parameter (NPPR=NBYTES/NBPP)
+  integer*1 userx_no,iusb
+  integer*2 nblock
+  real*8 d(NZ),buf8
+  integer fd
+  integer open,read,close
+  integer nm(11)
+  character*8 fname,arg,cjunk*1
+  logical fast,pause
+  real*8 center_freq,dmsec,dtmspacket,tmsec
+  common/plrscom/center_freq,msec2,fsample,iptr,nblock,userx_no,iusb,buf8(174)
+  data nm/45,46,48,50,52,54,55,56,57,58,59/
+  data nblock/0/,fast/.false./,pause/.false./
+
+  nargs=iargc()
+  if(nargs.ne.4) then
+     print*,'Usage: plrs &lt;fast|pause|slow&gt; &lt;minutes&gt; &lt;iters&gt; &lt;iwait&gt;'
+     go to 999
+  endif
+
+  call getarg(1,arg)
+  if(arg(1:1).eq.'f' .or. arg(1:1).eq.'p') fast=.true.
+  if(arg(1:1).eq.'p') pause=.true.
+  call getarg(2,arg)
+  read(arg,*) nfiles
+  call getarg(3,arg)
+  read(arg,*) iters
+  call getarg(4,arg)
+  read(arg,*) iwait
+
+  if(iwait.ne.0) then
+1    if(mod(int(sec_midn()),60).eq.0) go to 2
+     call sleep_msec(100)
+     go to 1
+  endif
+
+2 fname=&quot;all.iq&quot;//char(0)
+  userx_no=0
+  iusb=1
+  center_freq=144.125d0
+!  dtmspacket=1000.d0*NBPP/(8.d0*96000.d0)
+  dtmspacket=1000.d0*NBPP/(4.d0*95238.1d0)
+  print*,nz,nbytes,nppr,dtmspacket
+
+!  fsample=96000.0
+  fsample=95238.1
+  npkt=0
+
+  call setup_ssocket                       !Open a socket for multicasting
+
+  do iter=1,iters
+     open(10,file=fname,access='stream',status='old')
+     dmsec=-dtmspacket
+     nsec0=sec_midn()
+
+     do ifile=1,nfiles
+        ns0=0
+        tmsec=1000*(3600*7 + 60*nm(ifile))-dtmspacket
+        k=0
+        do ipacket=1,NPPR
+           dmsec=dmsec+dtmspacket
+           tmsec=tmsec+dtmspacket
+           msec2=nint(tmsec)
+           msec=nint(dmsec)
+
+           read(10) buf8
+           nblock=nblock+1
+           call send_pkt(center_freq)
+           npkt=npkt+1
+              
+           if(mod(npkt,100).eq.0) then
+              nsec=int(sec_midn())-nsec0
+              nwait=msec-1000*nsec
+!  Pace the data at close to its real-time rate
+              if(nwait.gt.0 .and. .not.fast) call sleep_msec(nwait)
+           endif
+           ns=mod(msec2/1000,60)
+           if(ns.ne.ns0) write(*,1010) ns,center_freq,0.001*msec2,sec_midn()
+1010       format('ns:',i3,'   f0:',f10.3,'   t1:',f10.3,'   t2:',f10.3)
+           ns0=ns
+        enddo
+        if(pause) then
+           print*,'Type anything to continue:'
+           read(*,*) cjunk,pause,fast
+        endif
+     enddo
+     close(10)
+  enddo
+
+
+999 end program plrs
+
+! To compile: % gfortran -o plrs plrs.f90 plrs_subs.c cutil.c


Property changes on: branches/map65iq/plrs.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65iq/plrs_subs.c
===================================================================
--- branches/map65iq/plrs_subs.c	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/plrs_subs.c	2010-11-19 18:19:55 UTC (rev 2257)
@@ -8,8 +8,10 @@
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
 
-#define HELLO_PORT 50004
-#define HELLO_GROUP &quot;239.255.0.0&quot;
+// #define HELLO_PORT 50004
+// #define HELLO_GROUP &quot;239.255.0.0&quot;
+#define HELLO_PORT 50024
+#define HELLO_GROUP &quot;128.112.87.74&quot;
 
 struct sockaddr_in addr;
 int fd;

Deleted: branches/map65iq/recvpkt.F90
===================================================================
--- branches/map65iq/recvpkt.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/recvpkt.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,139 +0,0 @@
-subroutine recvpkt(iarg)
-
-! Receive timf2 packets from Linrad and stuff data into array id().
-! (This routine runs in a background thread and will never return.)
-
-  parameter (NSZ=2*60*96000)
-  real d4(NSZ)
-  integer*1 userx_no,iusb
-  integer*2 nblock,nblock0
-  logical synced
-  real*8 center_freq
-  common/plrscom/center_freq,msec,fqso,iptr,nblock,userx_no,iusb,buf4(348)
-  include 'datcom.f90'
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  equivalence (id,d4)
-  data nblock0/0/,kb/1/,ns00/99/
-  data sqave/0.0/,u/0.002/,rxnoise/0.0/,pctblank/0.0/,kbuf/1/,lost_tot/0/
-  data multicast0/-99/
-  save
-
-1 call setup_rsocket(multicast)     !Open socket for multicast/unicast data
-  k=0
-  kk=0
-  kxp=0
-  kb=1
-  nsec0=-999
-  fcenter=144.130d0                 !Default (startup) frequency)
-  multicast0=multicast
-  ntx=0
-  synced=.false.
-
-10 if(multicast.ne.multicast0) go to 1
-  call recv_pkt(center_freq)
-
-! Should receive a new packet every 348/95238.1 = 0.003654 s
-  nsec=mod(Tsec,86400.d0)           !Time according to MAP65
-  nseclr=msec/1000                  !Time according to Linrad
-  if(lauto+monitoring.ne.0) fcenter=center_freq
-
-! Reset buffer pointers at start of minute.
-  ns=mod(nsec,60)
-  
-!  if(ns.ne.ns00) print*,ns00,ns,kb,k,synced
-  if(ns.lt.ns00 .and. (lauto+monitoring.ne.0)) then
-     if(ntx.eq.0) kb=3-kb
-     k=(kb-1)*60*96000
-     kxp=k
-     ndone1=0
-     ndone2=0
-     lost_tot=0
-     synced=.true.
-     ntx=0
-     nblock0=nblock-1
-!     print*,'new minute:',ns00,ns,kb,k,synced
-  endif
-  ns00=ns
-
-  if(transmitting.eq.1) ntx=1
-
-! Test for buffer full
-  if((kb.eq.1 .and. (k+348).gt.NSMAX) .or.                          &amp;
-       (kb.eq.2 .and. (k+348).gt.2*NSMAX)) go to 20
-
-! Check for lost packets
-  lost=nblock-nblock0-1
-  if(lost.ne.0) then
-     nb=nblock
-     if(nb.lt.0) nb=nb+65536
-     nb0=nblock0
-     if(nb0.lt.0) nb0=nb0+65536
-     lost_tot=lost_tot + lost               ! Insert zeros for the lost data.
-     do i=1,348*lost
-        k=k+1
-        d4(k)=0.
-     enddo
-  endif
-  nblock0=nblock
-
-  tdiff=mod(0.001d0*msec,60.d0)-mod(Tsec,60.d0)
-  if(tdiff.lt.-30.) tdiff=tdiff+60.
-  if(tdiff.gt.30.) tdiff=tdiff-60.
-
-! Move data into Rx buffer and compute average signal level.
-! Each r*4 word of buf4 and d4 is one sample, I and Q
-  sq=0.
-  do i=1,348
-     k=k+1
-     d4(k)=buf4(i)
-     k2=k
-     n=1
-     if(k.gt.NSMAX) then
-        k2=k2-NSMAX
-        n=2
-     endif
-     x1=id(1,k2,n)
-     x2=id(2,k2,n)
-     sq=sq + x1*x1 + x2*x2
-  enddo
-  sq=sq/(2.0*348.0)
-  sqave=sqave + u*(sq-sqave)
-  rxnoise=10.0*log10(sqave) - 20.0           !Target rms=10, sqave=100
-  kxp=k
-
-20 if(nsec.ne.nsec0) then
-     nsec0=nsec
-     mutch=nseclr/3600
-     mutcm=mod(nseclr/60,60)
-     mutc=100*mutch + mutcm
-
-!### Temporary!
-!     write(*,4100) center_freq,fadd,nfcal,mutc
-!4100 format(2f12.6,2i10)
-!###
-
-! If we have not transmitted in this minute, see if it's time to start FFTs
-     if(ntx.eq.0 .and. lauto+monitoring.ne.0) then
-        if(ns.ge.nt1 .and. ndone1.eq.0 .and. synced) then
-           nutc=mutc
-           if(lauto+monitoring.ne.0) fcenter=center_freq
-           kbuf=kb
-           kk=k
-           ndiskdat=0
-           ndone1=1
-        endif
-
-! See if it's time to start the full decoding procedure.
-        nhsym=(k-(kbuf-1)*60*96000)/17691.3949
-        if(ndone1.eq.1 .and. nhsym.ge.279 .and.ndone2.eq.0) then
-           kk=k
-           nlost=lost_tot                         ! Save stats for printout
-           ndone2=1
-        endif
-     endif
-
-  endif
-  go to 10
-
-end subroutine recvpkt

Added: branches/map65iq/recvpkt.f90
===================================================================
--- branches/map65iq/recvpkt.f90	                        (rev 0)
+++ branches/map65iq/recvpkt.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,142 @@
+subroutine recvpkt(iarg)
+
+! Receive timf2 packets from Linrad and stuff data into array id().
+! (This routine runs in a background thread and will never return.)
+
+  parameter (NSZ=2*60*96000)
+  real d4(NSZ)
+  integer*1 userx_no,iusb
+  integer*2 nblock,nblock0
+  logical synced
+  real*8 center_freq
+  common/plrscom/center_freq,msec,fqso,iptr,nblock,userx_no,iusb,buf4(348)
+  include 'datcom.f90'
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  equivalence (id,d4)
+  data nblock0/0/,kb/1/,ns00/99/
+  data sqave/0.0/,u/0.002/,rxnoise/0.0/,pctblank/0.0/,kbuf/1/,lost_tot/0/
+  data multicast0/-99/
+  save
+
+1 continue
+  call cs_lock('recvpkt')
+  call setup_rsocket(multicast)     !Open socket for multicast/unicast data
+  call cs_unlock
+  k=0
+  kk=0
+  kxp=0
+  kb=1
+  nsec0=-999
+  fcenter=144.130d0                 !Default (startup) frequency)
+  multicast0=multicast
+  ntx=0
+  synced=.false.
+
+10 if(multicast.ne.multicast0) go to 1
+  call recv_pkt(center_freq)
+
+! Should receive a new packet every 348/95238.1 = 0.003654 s
+  nsec=mod(Tsec,86400.d0)           !Time according to MAP65
+  nseclr=msec/1000                  !Time according to Linrad
+  if(lauto+monitoring.ne.0) fcenter=center_freq
+
+! Reset buffer pointers at start of minute.
+  ns=mod(nsec,60)
+  
+!  if(ns.ne.ns00) print*,ns00,ns,kb,k,synced
+  if(ns.lt.ns00 .and. (lauto+monitoring.ne.0)) then
+     if(ntx.eq.0) kb=3-kb
+     k=(kb-1)*60*96000
+     kxp=k
+     ndone1=0
+     ndone2=0
+     lost_tot=0
+     synced=.true.
+     ntx=0
+     nblock0=nblock-1
+!     print*,'new minute:',ns00,ns,kb,k,synced
+  endif
+  ns00=ns
+
+  if(transmitting.eq.1) ntx=1
+
+! Test for buffer full
+  if((kb.eq.1 .and. (k+348).gt.NSMAX) .or.                          &amp;
+       (kb.eq.2 .and. (k+348).gt.2*NSMAX)) go to 20
+
+! Check for lost packets
+  lost=nblock-nblock0-1
+  if(lost.ne.0) then
+     nb=nblock
+     if(nb.lt.0) nb=nb+65536
+     nb0=nblock0
+     if(nb0.lt.0) nb0=nb0+65536
+     lost_tot=lost_tot + lost               ! Insert zeros for the lost data.
+     do i=1,348*lost
+        k=k+1
+        d4(k)=0.
+     enddo
+  endif
+  nblock0=nblock
+
+  tdiff=mod(0.001d0*msec,60.d0)-mod(Tsec,60.d0)
+  if(tdiff.lt.-30.) tdiff=tdiff+60.
+  if(tdiff.gt.30.) tdiff=tdiff-60.
+
+! Move data into Rx buffer and compute average signal level.
+! Each r*4 word of buf4 and d4 is one sample, I and Q
+  sq=0.
+  do i=1,348
+     k=k+1
+     d4(k)=buf4(i)
+     k2=k
+     n=1
+     if(k.gt.NSMAX) then
+        k2=k2-NSMAX
+        n=2
+     endif
+     x1=id(1,k2,n)
+     x2=id(2,k2,n)
+     sq=sq + x1*x1 + x2*x2
+  enddo
+  sq=sq/(2.0*348.0)
+  sqave=sqave + u*(sq-sqave)
+  rxnoise=10.0*log10(sqave) - 20.0           !Target rms=10, sqave=100
+  kxp=k
+
+20 if(nsec.ne.nsec0) then
+     nsec0=nsec
+     mutch=nseclr/3600
+     mutcm=mod(nseclr/60,60)
+     mutc=100*mutch + mutcm
+
+!### Temporary!
+!     write(*,4100) center_freq,fadd,nfcal,mutc
+!4100 format(2f12.6,2i10)
+!###
+
+! If we have not transmitted in this minute, see if it's time to start FFTs
+     if(ntx.eq.0 .and. lauto+monitoring.ne.0) then
+        if(ns.ge.nt1 .and. ndone1.eq.0 .and. synced) then
+           nutc=mutc
+           if(lauto+monitoring.ne.0) fcenter=center_freq
+           kbuf=kb
+           kk=k
+           ndiskdat=0
+           ndone1=1
+        endif
+
+! See if it's time to start the full decoding procedure.
+        nhsym=(k-(kbuf-1)*60*96000)/17691.3949
+        if(ndone1.eq.1 .and. nhsym.ge.279 .and.ndone2.eq.0) then
+           kk=k
+           nlost=lost_tot                         ! Save stats for printout
+           ndone2=1
+        endif
+     endif
+
+  endif
+  go to 10
+
+end subroutine recvpkt


Property changes on: branches/map65iq/recvpkt.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65iq/rfile.f90
===================================================================
--- branches/map65iq/rfile.f90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/rfile.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,12 +1,13 @@
-
-!----------------------------------------------------- rfile
 subroutine rfile(lu,ibuf,n,ierr)
 
   integer*1 ibuf(n)
 
+  call cs_lock('rfile')
   read(lu,end=998) ibuf
   ierr=0
   go to 999
 998 ierr=1002
-999  return
+999 continue
+  call cs_unlock
+  return
 end subroutine rfile

Deleted: branches/map65iq/rfile3a.F90
===================================================================
--- branches/map65iq/rfile3a.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/rfile3a.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,18 +0,0 @@
-!----------------------------------------------------- rfile3a
-subroutine rfile3a(infile,ibuf,n,ierr)
-
-  character*(*) infile
-  integer*1 ibuf(n)
-
-#ifdef CVF
-  open(10,file=infile,form='binary',status='old',err=998)
-#else
-  open(10,file=infile,access='stream',status='old',err=998)
-#endif
-  read(10,end=998) ibuf
-  ierr=0
-  go to 999
-998 ierr=1002
-999 close(10)
-  return
-end subroutine rfile3a

Added: branches/map65iq/rfile3a.f90
===================================================================
--- branches/map65iq/rfile3a.f90	                        (rev 0)
+++ branches/map65iq/rfile3a.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,14 @@
+!----------------------------------------------------- rfile3a
+subroutine rfile3a(infile,ibuf,n,ierr)
+
+  character*(*) infile
+  integer*1 ibuf(n)
+
+  open(10,file=infile,access='stream',status='old',err=998)
+  read(10,end=998) ibuf
+  ierr=0
+  go to 999
+998 ierr=1002
+999 close(10)
+  return
+end subroutine rfile3a


Property changes on: branches/map65iq/rfile3a.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/runqqq.F90
===================================================================
--- branches/map65iq/runqqq.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/runqqq.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,17 +0,0 @@
-subroutine runqqq(fname,cmnd,iret)
-
-#ifdef CVF
-  use dflib
-#endif
-  integer system
-
-  character*(*) fname,cmnd
-
-#ifdef CVF
-  iret=runqq(fname,cmnd)
-#else
-  iret=system('KVASD_g95 -q &gt; dev_null')
-#endif
-
-  return
-end subroutine runqqq

Added: branches/map65iq/runqqq.f90
===================================================================
--- branches/map65iq/runqqq.f90	                        (rev 0)
+++ branches/map65iq/runqqq.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,9 @@
+subroutine runqqq(fname,cmnd,iret)
+
+  integer system
+  character*(*) fname,cmnd
+
+  iret=system('KVASD_g95 -q &gt; dev_null')
+
+  return
+end subroutine runqqq


Property changes on: branches/map65iq/runqqq.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/savetf2.F90
===================================================================
--- branches/map65iq/savetf2.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/savetf2.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,49 +0,0 @@
-subroutine savetf2(id,fnamedate,savedir,fhdr)
-
-  parameter (NZ=60*96000)
-  parameter (NSPP=174)
-  parameter (NPKTS=NZ/NSPP)
-  integer*2 id(2,NZ)
-  real*8 fhdr
-  character*80 savedir,fname
-  character cdate*8,ctime2*10,czone*5,fnamedate*6
-  integer  itt(8)
-
-  call date_and_time(cdate,ctime2,czone,itt)
-  nh=itt(5)-itt(4)/60
-  nm=itt(6)
-  ns=itt(7)
-  if(ns.lt.50) nm=nm-1
-  if(nm.lt.0) then
-     nm=nm+60
-     nh=nh-1
-  endif
-  if(nh.lt.0) nh=nh+24
-  if(nh.ge.24) nh=nh-24
-  write(fname,1001) fnamedate,nh,nm
-1001 format('/',a6,'_',2i2.2,'.iq')
-  do i=80,1,-1
-     if(savedir(i:i).ne.' ') go to 1
-  enddo
-1 iz=i
-  fname=savedir(1:iz)//fname
-#ifdef CVF
-  open(17,file=fname,status='unknown',form='binary',err=998)
-#else
-  open(17,file=fname,status='unknown',access='stream',err=998)
-#endif
-
-  write(17,err=997) fhdr,id
-  close(17)
-  go to 999
-
-997 print*,'Error writing *.iq file'
-  print*,fname
-  go to 999
-
-998 print*,'Cannot open file:'
-  print*,fname
-
-999 return
-end subroutine savetf2
-

Added: branches/map65iq/savetf2.f90
===================================================================
--- branches/map65iq/savetf2.f90	                        (rev 0)
+++ branches/map65iq/savetf2.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,48 @@
+subroutine savetf2(id,fnamedate,savedir,fhdr)
+
+  parameter (NZ=60*96000)
+  parameter (NSPP=174)
+  parameter (NPKTS=NZ/NSPP)
+  integer*2 id(2,NZ)
+  real*8 fhdr
+  character*80 savedir,fname
+  character cdate*8,ctime2*10,czone*5,fnamedate*6
+  integer  itt(8)
+
+  call date_and_time(cdate,ctime2,czone,itt)
+  nh=itt(5)-itt(4)/60
+  nm=itt(6)
+  ns=itt(7)
+  if(ns.lt.50) nm=nm-1
+  if(nm.lt.0) then
+     nm=nm+60
+     nh=nh-1
+  endif
+  if(nh.lt.0) nh=nh+24
+  if(nh.ge.24) nh=nh-24
+
+  call cs_lock('savetf2')
+  write(fname,1001) fnamedate,nh,nm
+1001 format('/',a6,'_',2i2.2,'.iq')
+  do i=80,1,-1
+     if(savedir(i:i).ne.' ') go to 1
+  enddo
+1 iz=i
+  fname=savedir(1:iz)//fname
+  open(17,file=fname,status='unknown',access='stream',err=998)
+  write(17,err=997) fhdr,id
+  close(17)
+  go to 999
+
+997 print*,'Error writing *.iq file'
+  print*,fname
+  go to 999
+
+998 print*,'Cannot open file:'
+  print*,fname
+
+999 continue
+  call cs_unlock
+  return
+end subroutine savetf2
+


Property changes on: branches/map65iq/savetf2.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/sec_midn.F90
===================================================================
--- branches/map65iq/sec_midn.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/sec_midn.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,19 +0,0 @@
-real function sec_midn()
-  sec_midn=secnds(0.0)
-  return
-end function sec_midn
-
-subroutine sleep_msec(n)
-
-#ifdef CVF
-  use dflib
-#endif
-
-#ifdef CVF
-  call sleepqq(n)
-#else
-  call usleep(1000*n)
-#endif
-
-  return
-end subroutine sleep_msec

Added: branches/map65iq/sec_midn.f90
===================================================================
--- branches/map65iq/sec_midn.f90	                        (rev 0)
+++ branches/map65iq/sec_midn.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,11 @@
+real function sec_midn()
+  sec_midn=secnds(0.0)
+  return
+end function sec_midn
+
+subroutine sleep_msec(n)
+
+  call usleep(1000*n)
+
+  return
+end subroutine sleep_msec


Property changes on: branches/map65iq/sec_midn.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65iq/specjt.py
===================================================================
--- branches/map65iq/specjt.py	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/specjt.py	2010-11-19 18:19:55 UTC (rev 2257)
@@ -561,9 +561,7 @@
     ndevout=0
 Audio.gcom1.ndevout=ndevout
 						# Only valid for windows
-                                                # for now
 Audio.audio_init(ndevin,ndevout)                #Start the audio stream
-
 ltime.after(200,update)
 
 root.deiconify()

Modified: branches/map65iq/start_portaudio.c
===================================================================
--- branches/map65iq/start_portaudio.c	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/start_portaudio.c	2010-11-19 18:19:55 UTC (rev 2257)
@@ -20,11 +20,8 @@
   int iret1,iret2,iret3;
   int iarg1=1, iarg2=2, iarg3=3;
 
-  iret1 = pthread_create(&amp;thread1,NULL,
-			 (void *)a2d_,&amp;iarg1);
-  iret2 = pthread_create(&amp;thread2,NULL,
-			 (void *)decode1_,&amp;iarg2);
-  iret3 = pthread_create(&amp;thread3,NULL,
-			 (void *)recvpkt_,&amp;iarg3);
+  iret1 = pthread_create(&amp;thread1,NULL,(void *)a2d_,&amp;iarg1);
+  iret2 = pthread_create(&amp;thread2,NULL,(void *)decode1_,&amp;iarg2);
+  iret3 = pthread_create(&amp;thread3,NULL,(void *)recvpkt_,&amp;iarg3);
   return(iret1 | iret2 | iret3);
 }

Modified: branches/map65iq/symspec.f90
===================================================================
--- branches/map65iq/symspec.f90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/symspec.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -107,8 +107,12 @@
 !         if(n.eq.ntot) then
      if(n.ge.279) then
         call move(ssz5,ss5,322*NFFT)
+
+        call cs_lock('symspec')
         write(utcdata,1002) nutc
 1002    format(i4.4)
+        call cs_unlock
+
         utcdata=utcdata(1:2)//':'//utcdata(3:4)
         newspec=1
         call move(ssz,ss,322*NFFT)

Modified: branches/map65iq/sysqqq.f90
===================================================================
--- branches/map65iq/sysqqq.f90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/sysqqq.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,10 +1,6 @@
 subroutine sysqqq(cmnd,iret)
 
-#ifdef CVF
-  use dfport
-#else
   integer system
-#endif
   character*(*) cmnd
 
   iret=system(cmnd)

Added: branches/map65iq/thnix.f90
===================================================================
--- branches/map65iq/thnix.f90	                        (rev 0)
+++ branches/map65iq/thnix.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,58 @@
+subroutine cs_init
+  character*12 csub0
+  integer*8 mtx
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+  ltrace=0
+  mtxstate=0
+  csub0='**unlocked**'
+  call fthread_mutex_init(mtx)
+  return
+end subroutine cs_init
+
+subroutine cs_destroy
+  character*12 csub0
+  integer*8 mtx
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+  call fthread_mutex_destroy(mtx)
+  return
+end subroutine cs_destroy
+
+subroutine th_create(sub)
+  call fthread_create(sub,id)
+  return
+end subroutine th_create
+
+subroutine th_exit
+  call fthread_exit
+  return
+end subroutine th_exit
+
+subroutine cs_lock(csub)
+  character*(*) csub
+  character*12 csub0
+  integer fthread_mutex_lock,fthread_mutex_trylock
+  integer*8 mtx
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+  n=fthread_mutex_trylock(mtx)
+  if(n.ne.0) then
+! Another thread has already locked the mutex
+     n=fthread_mutex_lock(mtx)
+     iz=index(csub0,' ')
+     if(ltrace.ge.1) print*,'&quot;',csub,'&quot; requested mutex when &quot;',   &amp;
+          csub0(:iz-1),'&quot; owned it.'
+  endif
+  mtxstate=1
+  csub0=csub
+  if(ltrace.ge.3) print*,'Mutex locked by ',csub
+  return
+end subroutine cs_lock
+
+subroutine cs_unlock
+  character*12 csub0
+  integer*8 mtx
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+  if(ltrace.ge.3) print*,'Mutex unlocked,',ltrace,mtx,mtxstate,csub0
+  mtxstate=0
+  call fthread_mutex_unlock(mtx)
+  return
+end subroutine cs_unlock


Property changes on: branches/map65iq/thnix.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/map65iq/wsjtgen.F90
===================================================================
--- branches/map65iq/wsjtgen.F90	2010-11-19 14:35:04 UTC (rev 2256)
+++ branches/map65iq/wsjtgen.F90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -1,137 +0,0 @@
-subroutine wsjtgen
-
-! Compute the waveform to be transmitted.  
-
-! Input:    txmsg        message to be transmitted, up to 28 characters
-!           samfacout    fsample_out/11025.d0
-
-! Output:   iwave        waveform data, i*2 format
-!           nwave        number of samples
-!           sendingsh    0=normal; 1=shorthand (FSK441) or plain text (JT65)
-
-  parameter (NMSGMAX=28)             !Max characters per message
-  parameter (NSPD=25)                !Samples per dit
-  parameter (NDPC=3)                 !Dits per character
-  parameter (NWMAX=661500)           !Max length of waveform = 60*11025
-  parameter (NTONES=4)               !Number of FSK tones
-  character msg*28,msgsent*22,idmsg*22
-  real*8 freq,dpha,twopi
-  character testfile*27
-  logical lcwid
-  integer*2 icwid(110250),jwave(NWMAX)
-
-  integer*1 hdr(44)
-  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-  character*4 ariff,awave,afmt,adata
-  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
-     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,jwave
-  equivalence (ariff,hdr)
-
-  data twopi/6.28318530718d0/
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  fsample_out=11025.d0*samfacout
-  lcwid=.false.
-  if(idinterval.gt.0) then
-     n=(mod(int(tsec/60.d0),idinterval))
-     if(n.eq.(1-txfirst)) lcwid=.true.
-     if(idinterval.eq.1) lcwid=.true.
-  endif
-
-  msg=txmsg
-  ntxnow=ntxreq
-
-! Convert all letters to upper case
-  do i=1,28
-     if(msg(i:i).ge.'a' .and. msg(i:i).le.'z')                  &amp;
-          msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
-  enddo
-  txmsg=msg
-
-! Find message length
-  do i=NMSGMAX,1,-1
-     if(msg(i:i).ne.' ') go to 10
-  enddo
-  i=1
-10 nmsg=i
-  nmsg0=nmsg
-
-  if(msg(1:1).eq.'@') then
-     if(msg(2:2).eq.'/' .or. ichar(msg(2:2)).eq.92) then
-        txmsg=msg
-        testfile=msg(2:)
-#ifdef CVF
-        open(18,file=testfile,form='binary',status='old',err=12)
-#else
-        open(18,file=testfile,access='stream',status='old',err=12)
-#endif
-        go to 14
-12      print*,'Cannot open test file ',msg(2:)
-        go to 999
-14      read(18) hdr
-        if(ndata.gt.NTxMax) ndata=NTxMax
-        call rfile(18,iwave,ndata,ierr)
-        close(18)
-        if(ierr.ne.0) print*,'Error reading test file ',msg(2:)
-        nwave=ndata/2
-        do i=nwave,NTXMAX
-           iwave(i)=0
-        enddo
-	sending=txmsg
-	sendingsh=2
-        go to 999
-     endif
-
-! Transmit a fixed tone at specified frequency
-     freq=1000.0
-     if(msg(2:2).eq.'A' .or. msg(2:2).eq.'a') freq=882
-     if(msg(2:2).eq.'B' .or. msg(2:2).eq.'b') freq=1323
-     if(msg(2:2).eq.'C' .or. msg(2:2).eq.'c') freq=1764
-     if(msg(2:2).eq.'D' .or. msg(2:2).eq.'d') freq=2205
-     if(freq.eq.1000.0) then
-        read(msg(2:),*,err=1) freq
-        goto 2
-1       txmsg='@1000'
-        nmsg=5
-        nmsg0=5
-     endif
-2    nwave=60*fsample_out
-     dpha=twopi*freq/fsample_out
-     do i=1,nwave
-        iwave(i)=32767.0*sin(i*dpha)
-     enddo
-     goto 900
-  endif
-
-!  We're in JT65 mode.
-  if(mode(5:5).eq.'A') mode65=1
-  if(mode(5:5).eq.'B') mode65=2
-  if(mode(5:5).eq.'C') mode65=4
-  call gen65(msg,mode65,samfacout,iwave,nwave,sendingsh,msgsent)
-
-  if(lcwid) then
-!  Generate and insert the CW ID.
-     wpm=25.
-     freqcw=800.
-     idmsg=MyCall//'          '
-     call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
-     k=nwave
-     do i=1,ncwid
-        k=k+1
-        iwave(k)=icwid(i)
-     enddo
-     do i=1,2205                   !Add 0.2 s of silence
-        k=k+1
-        iwave(k)=0
-     enddo
-     nwave=k
-  endif
-
-900 sending=txmsg
-  if(sendingsh.ne.1) sending=msgsent
-  nmsg=nmsg0
-
-999  return
-end subroutine wsjtgen
-

Added: branches/map65iq/wsjtgen.f90
===================================================================
--- branches/map65iq/wsjtgen.f90	                        (rev 0)
+++ branches/map65iq/wsjtgen.f90	2010-11-19 18:19:55 UTC (rev 2257)
@@ -0,0 +1,142 @@
+subroutine wsjtgen
+
+! Compute the waveform to be transmitted.  
+
+! Input:    txmsg        message to be transmitted, up to 28 characters
+!           samfacout    fsample_out/11025.d0
+
+! Output:   iwave        waveform data, i*2 format
+!           nwave        number of samples
+!           sendingsh    0=normal; 1=shorthand (FSK441) or plain text (JT65)
+
+  parameter (NMSGMAX=28)             !Max characters per message
+  parameter (NSPD=25)                !Samples per dit
+  parameter (NDPC=3)                 !Dits per character
+  parameter (NWMAX=661500)           !Max length of waveform = 60*11025
+  parameter (NTONES=4)               !Number of FSK tones
+  character msg*28,msgsent*22,idmsg*22
+  real*8 freq,dpha,twopi
+  character testfile*27
+  logical lcwid
+  integer*2 icwid(110250),jwave(NWMAX)
+
+  integer*1 hdr(44)
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,jwave
+  equivalence (ariff,hdr)
+
+  data twopi/6.28318530718d0/
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+
+  fsample_out=11025.d0*samfacout
+  lcwid=.false.
+  if(idinterval.gt.0) then
+     n=(mod(int(tsec/60.d0),idinterval))
+     if(n.eq.(1-txfirst)) lcwid=.true.
+     if(idinterval.eq.1) lcwid=.true.
+  endif
+
+  msg=txmsg
+  ntxnow=ntxreq
+
+! Convert all letters to upper case
+  do i=1,28
+     if(msg(i:i).ge.'a' .and. msg(i:i).le.'z')                  &amp;
+          msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
+  enddo
+  txmsg=msg
+
+! Find message length
+  do i=NMSGMAX,1,-1
+     if(msg(i:i).ne.' ') go to 10
+  enddo
+  i=1
+10 nmsg=i
+  nmsg0=nmsg
+
+  if(msg(1:1).eq.'@') then
+     if(msg(2:2).eq.'/' .or. ichar(msg(2:2)).eq.92) then
+        txmsg=msg
+        testfile=msg(2:)
+        open(18,file=testfile,access='stream',status='old',err=12)
+        go to 14
+12      print*,'Cannot open test file ',msg(2:)
+        go to 999
+
+14      call cs_lock('wsjtgen')
+        read(18) hdr
+        if(ndata.gt.NTxMax) ndata=NTxMax
+        call rfile(18,iwave,ndata,ierr)
+        close(18)
+        call cs_unlock
+
+        if(ierr.ne.0) print*,'Error reading test file ',msg(2:)
+        nwave=ndata/2
+        do i=nwave,NTXMAX
+           iwave(i)=0
+        enddo
+	sending=txmsg
+	sendingsh=2
+        go to 999
+     endif
+
+! Transmit a fixed tone at specified frequency
+     freq=1000.0
+     if(msg(2:2).eq.'A' .or. msg(2:2).eq.'a') freq=882
+     if(msg(2:2).eq.'B' .or. msg(2:2).eq.'b') freq=1323
+     if(msg(2:2).eq.'C' .or. msg(2:2).eq.'c') freq=1764
+     if(msg(2:2).eq.'D' .or. msg(2:2).eq.'d') freq=2205
+     if(freq.eq.1000.0) then
+        call cs_lock('wsjtgen')
+        read(msg(2:),*,err=1) freq
+        goto 2
+1       txmsg='@1000'
+        nmsg=5
+        nmsg0=5
+2       call cs_unlock
+     endif
+     nwave=60*fsample_out
+     dpha=twopi*freq/fsample_out
+     do i=1,nwave
+        iwave(i)=32767.0*sin(i*dpha)
+     enddo
+     goto 900
+  endif
+
+!  We're in JT65 mode.
+  if(mode(5:5).eq.'A') mode65=1
+  if(mode(5:5).eq.'B') mode65=2
+  if(mode(5:5).eq.'C') mode65=4
+
+  call cs_lock('wsjtgen')
+  call gen65(msg,mode65,samfacout,iwave,nwave,sendingsh,msgsent)
+  call cs_unlock
+
+  if(lcwid) then
+!  Generate and insert the CW ID.
+     wpm=25.
+     freqcw=800.
+     idmsg=MyCall//'          '
+     call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
+     k=nwave
+     do i=1,ncwid
+        k=k+1
+        iwave(k)=icwid(i)
+     enddo
+     do i=1,2205                   !Add 0.2 s of silence
+        k=k+1
+        iwave(k)=0
+     enddo
+     nwave=k
+  endif
+
+900 sending=txmsg
+  if(sendingsh.ne.1) sending=msgsent
+  nmsg=nmsg0
+
+999  return
+end subroutine wsjtgen
+


Property changes on: branches/map65iq/wsjtgen.f90
___________________________________________________________________
Added: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001948.html">[WSJT-SVN] r2256 - branches/map65iq
</A></li>
	<LI>Next message: <A HREF="001950.html">[WSJT-SVN] r2258 - branches/map65iq
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1949">[ date ]</a>
              <a href="thread.html#1949">[ thread ]</a>
              <a href="subject.html#1949">[ subject ]</a>
              <a href="author.html#1949">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
