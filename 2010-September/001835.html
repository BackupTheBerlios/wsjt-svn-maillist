<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2143 - branches/wspr
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2010-September/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2143%20-%20branches/wspr&In-Reply-To=%3C20100913185908.CD170481034%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001834.html">
   <LINK REL="Next"  HREF="001836.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2143 - branches/wspr</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2143%20-%20branches/wspr&In-Reply-To=%3C20100913185908.CD170481034%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r2143 - branches/wspr">k1jt at mail.berlios.de
       </A><BR>
    <I>Mon Sep 13 20:59:08 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001834.html">[WSJT-SVN] r2142 - in branches/wspr: . DEB/DEBIAN WsprMod
</A></li>
        <LI>Next message: <A HREF="001836.html">[WSJT-SVN] r2144 - branches/wspr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1835">[ date ]</a>
              <a href="thread.html#1835">[ thread ]</a>
              <a href="subject.html#1835">[ subject ]</a>
              <a href="author.html#1835">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2010-09-13 20:59:08 +0200 (Mon, 13 Sep 2010)
New Revision: 2143

Added:
   branches/wspr/chklevel.f90
   branches/wspr/decode.f90
   branches/wspr/four2a.f
   branches/wspr/genwspr.f90
   branches/wspr/getfile.f90
   branches/wspr/mept162.f
   branches/wspr/rx.f90
   branches/wspr/spec162.f
   branches/wspr/startdec.f90
   branches/wspr/startrx.f90
   branches/wspr/starttx.f90
   branches/wspr/tx.f90
   branches/wspr/wfile5.f
   branches/wspr/wspr1.f90
   branches/wspr/wspr2.f90
Removed:
   branches/wspr/chklevel.F90
   branches/wspr/decode.F90
   branches/wspr/four2a.F
   branches/wspr/genwspr.F90
   branches/wspr/getfile.F90
   branches/wspr/mept162.F
   branches/wspr/rx.F90
   branches/wspr/spec162.F
   branches/wspr/startdec.F90
   branches/wspr/startrx.F90
   branches/wspr/starttx.F90
   branches/wspr/tx.F90
   branches/wspr/wfile5.F
   branches/wspr/wspr1.F90
   branches/wspr/wspr2.F90
Modified:
   branches/wspr/Makefile.in
   branches/wspr/wspr.py
Log:
Remove all &quot;#ifdef CVF&quot; stuff.


Modified: branches/wspr/Makefile.in
===================================================================
--- branches/wspr/Makefile.in	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/Makefile.in	2010-09-13 18:59:08 UTC (rev 2143)
@@ -47,9 +47,9 @@
 
 F2PYONLY = wspr1 getfile paterminate audiodev
 
-SRCS2F90 = wspr1.F90 wspr2.F90 decode.F90 getutc.f90 gran.f90 rx.F90 \
-	startdec.F90 startrx.F90 starttx.F90 tx.F90 getfile.F90 \
-	paterminate.f90 wqencode.f90 chklevel.F90 genwspr.F90 \
+SRCS2F90 = wspr1.f90 wspr2.f90 decode.f90 getutc.f90 gran.f90 rx.f90 \
+	startdec.f90 startrx.f90 starttx.f90 tx.f90 getfile.f90 \
+	paterminate.f90 wqencode.f90 chklevel.f90 genwspr.f90 \
 	wqdecode.f90 hash.f90 packname.f90 packtext2.f90 \
 	unpackname.f90 unpacktext2.f90 audiodev.f90 fil1.f90 \
 	packpfx.f90 packprop.f90 unpackpfx.f90 unpackprop.f90 \
@@ -57,11 +57,11 @@
 
 OBJS2F90 = ${SRCS2F90:.f90=.o}
 
-SRCS2F77 = mept162.F getrms.f wfile5.F mix162.f \
-	sync162.f decode162.f spec162.F set.f xfft.f \
+SRCS2F77 = mept162.f getrms.f wfile5.f mix162.f \
+	sync162.f decode162.f spec162.f set.f xfft.f \
 	ps162.f pctile.f xcor162.f peakup.f db.f \
 	inter_mept.f fano232.f unpack50.f unpackcall.f \
-	unpackgrid.f four2a.F flat3.f sort.f deg2grid.f \
+	unpackgrid.f four2a.f flat3.f sort.f deg2grid.f \
 	ssort.f gencwid.f morse.f \
 	packcall.f packgrid.f pack50.f encode232.f \
 	nchar.f grid2deg.f \

Deleted: branches/wspr/chklevel.F90
===================================================================
--- branches/wspr/chklevel.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/chklevel.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,42 +0,0 @@
-subroutine chklevel
-
-! Called from wspr2 at ~5 Hz rate.
-
-#ifdef CVF
-  use dfport
-#else
-  integer time
-#endif
-
-  include 'acom1.f90'
-
-  nsec3=time()
-  i2=48000*(nsec3-nsec1)
-  if(i2.gt.114*48000) i2=114*48000
-  i1=max(1,i2-48000+1)
-  do i=i2,i1,-1
-     if(kwave(i).ne.0) go to 10
-  enddo
-
-10  i4=i
-  i3=max(1,i4-48000+1)
-  npts=i4-i3+1
-  s=0.
-  do i=i3,i4
-     s=s+kwave(i)
-  enddo
-  ave=s/npts
-  sq=0.
-  do i=i3,i4
-     x=kwave(i)-ave
-     sq=sq + x*x
-  enddo
-  xdb1=-99.
-  rms1=-99.
-  if(sq.gt.0.0) then
-     rms1=sqrt(sq/npts)
-     xdb1=20.0*log10(rms1)
-  endif
-
-  return
-end subroutine chklevel

Added: branches/wspr/chklevel.f90
===================================================================
--- branches/wspr/chklevel.f90	                        (rev 0)
+++ branches/wspr/chklevel.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,38 @@
+subroutine chklevel
+
+! Called from wspr2 at ~5 Hz rate.
+
+  integer time
+
+  include 'acom1.f90'
+
+  nsec3=time()
+  i2=48000*(nsec3-nsec1)
+  if(i2.gt.114*48000) i2=114*48000
+  i1=max(1,i2-48000+1)
+  do i=i2,i1,-1
+     if(kwave(i).ne.0) go to 10
+  enddo
+
+10  i4=i
+  i3=max(1,i4-48000+1)
+  npts=i4-i3+1
+  s=0.
+  do i=i3,i4
+     s=s+kwave(i)
+  enddo
+  ave=s/npts
+  sq=0.
+  do i=i3,i4
+     x=kwave(i)-ave
+     sq=sq + x*x
+  enddo
+  xdb1=-99.
+  rms1=-99.
+  if(sq.gt.0.0) then
+     rms1=sqrt(sq/npts)
+     xdb1=20.0*log10(rms1)
+  endif
+
+  return
+end subroutine chklevel


Property changes on: branches/wspr/chklevel.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/decode.F90
===================================================================
--- branches/wspr/decode.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/decode.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,63 +0,0 @@
-subroutine decode
-
-!  Decode WSPR signals for one 2-minute sequence.
-
-#ifdef CVF
-  use dfport
-#endif
-  character*80 savefile
-  integer*2 jwave(114*12000)
-  real*8 df,fpeak
-  real x(65536)
-  complex c(0:32768)
-  equivalence (x,c)
-  include 'acom1.f90'
-
-  f0b=f0a
-  if(ncal.eq.2) then
-     fac=1.e-6
-     do i=1,65536
-        x(i)=fac*iwave(i)
-     enddo
-     call xfft(x,65536)
-     df=12000.d0/65536.d0
-     smax=0.
-     do i=1,16384
-        s=real(c(i))**2 + aimag(c(i))**2
-        if(s.gt.smax) then
-           smax=s
-           fpeak=i*df
-        endif
-     enddo
-
-     call cs_lock('decode')
-     write(*,1002) fpeak
-1002 format('Measured audio frequency:',f10.2,' Hz')
-     ncal=0
-     ndecoding=0
-     call cs_unlock
-
-     go to 900
-  else
-     minsync=1
-     if(nsave.gt.0 .and. ndiskdat.eq.0) jwave=iwave(1:114*12000)
-     call mept162(thisfile,appdir,nappdir,f0,minsync,iwave,NMAX,nbfo,ierr)
-     if(nsave.gt.0 .and. ndiskdat.eq.0 .and. ierr.eq.0) then
-        savefile=appdir(:nappdir)//'/save/'//thisfile
-        npts=114*12000
-        call wfile5(jwave,npts,12000,savefile)
-     endif
-  endif
-
-  call cs_lock('decode')
-  write(14,1100)
-1100 format('$EOF')
-  call flush(14)
-  rewind 14
-  ndecdone=1
-  ndiskdat=0
-  ndecoding=0
-  call cs_unlock
-
-900  return
-end subroutine decode

Added: branches/wspr/decode.f90
===================================================================
--- branches/wspr/decode.f90	                        (rev 0)
+++ branches/wspr/decode.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,60 @@
+subroutine decode
+
+!  Decode WSPR signals for one 2-minute sequence.
+
+  character*80 savefile
+  integer*2 jwave(114*12000)
+  real*8 df,fpeak
+  real x(65536)
+  complex c(0:32768)
+  equivalence (x,c)
+  include 'acom1.f90'
+
+  f0b=f0a
+  if(ncal.eq.2) then
+     fac=1.e-6
+     do i=1,65536
+        x(i)=fac*iwave(i)
+     enddo
+     call xfft(x,65536)
+     df=12000.d0/65536.d0
+     smax=0.
+     do i=1,16384
+        s=real(c(i))**2 + aimag(c(i))**2
+        if(s.gt.smax) then
+           smax=s
+           fpeak=i*df
+        endif
+     enddo
+
+     call cs_lock('decode')
+     write(*,1002) fpeak
+1002 format('Measured audio frequency:',f10.2,' Hz')
+     ncal=0
+     ndecoding=0
+     call cs_unlock
+
+     go to 900
+  else
+     minsync=1
+     if(nsave.gt.0 .and. ndiskdat.eq.0) jwave=iwave(1:114*12000)
+     call mept162(thisfile,appdir,nappdir,f0,minsync,iwave,NMAX,nbfo,ierr)
+     if(nsave.gt.0 .and. ndiskdat.eq.0 .and. ierr.eq.0) then
+        savefile=appdir(:nappdir)//'/save/'//thisfile
+        npts=114*12000
+        call wfile5(jwave,npts,12000,savefile)
+     endif
+  endif
+
+  call cs_lock('decode')
+  write(14,1100)
+1100 format('$EOF')
+  call flush(14)
+  rewind 14
+  ndecdone=1
+  ndiskdat=0
+  ndecoding=0
+  call cs_unlock
+
+900  return
+end subroutine decode


Property changes on: branches/wspr/decode.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/four2a.F
===================================================================
--- branches/wspr/four2a.F	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/four2a.F	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,111 +0,0 @@
-      subroutine four2a(a,nfft,ndim,isign,iform)
-
-C     IFORM = 1, 0 or -1, as data is
-C     complex, real, or the first half of a complex array.  Transform
-C     values are returned in array DATA.  They are complex, real, or
-C     the first half of a complex array, as IFORM = 1, -1 or 0.
-
-C     The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
-C     by ... will be returned in the same array, now considered to
-C     be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
-C     IFORM = 0 or -1, N(1) must be even, and enough room must be
-C     reserved.  The missing values may be obtained by complex conjuga-
-C     tion.  
-
-C     The reverse transformation of a half complex array dimensioned
-C     N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
-C     to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
-C     The transform will be real and returned to the input array.
-
-      parameter (NPMAX=100)
-      parameter (NSMALL=16384)
-      complex a(nfft)
-      complex aa(NSMALL)
-      integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
-      real*8 plan(NPMAX)             !Actually should be i*8, but no matter
-      data nplan/0/
-      include 'fftw3.f'
-      common/patience/npatience
-      save plan,nplan,nn,ns,nf,nl
-
-      if(nfft.lt.0 .or. ndim.lt.0) go to 999
-
-      nloc=loc(a)
-      do i=1,nplan
-         if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.
-     +      iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
-      enddo
-      if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
-      nplan=nplan+1
-      i=nplan
-      nn(i)=nfft
-      ns(i)=isign
-      nf(i)=iform
-      nl(i)=nloc
-
-C  Planning: FFTW_ESTIMATE, FFTW_ESTIMATE_PATIENT, FFTW_MEASURE, 
-C            FFTW_PATIENT,  FFTW_EXHAUSTIVE
-      nflags=FFTW_ESTIMATE
-      if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
-      if(npatience.eq.2) nflags=FFTW_MEASURE
-      if(npatience.eq.3) nflags=FFTW_PATIENT
-      if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
-      if(nfft.le.NSMALL) then
-         jz=nfft
-         if(iform.eq.0) jz=nfft/2
-         do j=1,jz
-            aa(j)=a(j)
-         enddo
-      endif
-!      call sleep_msec(0)
-      if(isign.eq.-1 .and. iform.eq.1) then
-#ifdef CVF
-         call sfftw_plan_dft_1d_(plan(i),nfft,a,a,FFTW_FORWARD,nflags)
-      else if(isign.eq.1 .and. iform.eq.1) then
-         call sfftw_plan_dft_1d_(plan(i),nfft,a,a,FFTW_BACKWARD,nflags)
-      else if(isign.eq.-1 .and. iform.eq.0) then
-         call sfftw_plan_dft_r2c_1d_(plan(i),nfft,a,a,nflags)
-      else if(isign.eq.1 .and. iform.eq.-1) then
-         call sfftw_plan_dft_c2r_1d_(plan(i),nfft,a,a,nflags)
-#else
-         call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_FORWARD,nflags)
-      else if(isign.eq.1 .and. iform.eq.1) then
-         call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_BACKWARD,nflags)
-      else if(isign.eq.-1 .and. iform.eq.0) then
-         call sfftw_plan_dft_r2c_1d(plan(i),nfft,a,a,nflags)
-      else if(isign.eq.1 .and. iform.eq.-1) then
-         call sfftw_plan_dft_c2r_1d(plan(i),nfft,a,a,nflags)
-#endif
-      else
-         stop 'Unsupported request in four2a'
-      endif
-!      call sleep_msec(0)
-      i=nplan
-      if(nfft.le.NSMALL) then
-         jz=nfft
-         if(iform.eq.0) jz=nfft/2
-         do j=1,jz
-            a(j)=aa(j)
-         enddo
-      endif
-
- 10   continue
-!      call sleep_msec(0)
-#ifdef CVF
-      call sfftw_execute_(plan(i))
-#else
-      call sfftw_execute(plan(i))
-#endif
-!      call sleep_msec(0)
-      return
-
- 999  do i=1,nplan
-#ifdef CVF
-         call sfftw_destroy_plan_(plan(i))
-#else
-         call sfftw_destroy_plan(plan(i))
-#endif
-      enddo
-
-      return
-      end

Added: branches/wspr/four2a.f
===================================================================
--- branches/wspr/four2a.f	                        (rev 0)
+++ branches/wspr/four2a.f	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,93 @@
+      subroutine four2a(a,nfft,ndim,isign,iform)
+
+C     IFORM = 1, 0 or -1, as data is
+C     complex, real, or the first half of a complex array.  Transform
+C     values are returned in array DATA.  They are complex, real, or
+C     the first half of a complex array, as IFORM = 1, -1 or 0.
+
+C     The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
+C     by ... will be returned in the same array, now considered to
+C     be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
+C     IFORM = 0 or -1, N(1) must be even, and enough room must be
+C     reserved.  The missing values may be obtained by complex conjuga-
+C     tion.  
+
+C     The reverse transformation of a half complex array dimensioned
+C     N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
+C     to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
+C     The transform will be real and returned to the input array.
+
+      parameter (NPMAX=100)
+      parameter (NSMALL=16384)
+      complex a(nfft)
+      complex aa(NSMALL)
+      integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
+      real*8 plan(NPMAX)             !Actually should be i*8, but no matter
+      data nplan/0/
+      include 'fftw3.f'
+      common/patience/npatience
+      save plan,nplan,nn,ns,nf,nl
+
+      if(nfft.lt.0 .or. ndim.lt.0) go to 999
+
+      nloc=loc(a)
+      do i=1,nplan
+         if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.
+     +      iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
+      enddo
+      if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
+      nplan=nplan+1
+      i=nplan
+      nn(i)=nfft
+      ns(i)=isign
+      nf(i)=iform
+      nl(i)=nloc
+
+C  Planning: FFTW_ESTIMATE, FFTW_ESTIMATE_PATIENT, FFTW_MEASURE, 
+C            FFTW_PATIENT,  FFTW_EXHAUSTIVE
+      nflags=FFTW_ESTIMATE
+      if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
+      if(npatience.eq.2) nflags=FFTW_MEASURE
+      if(npatience.eq.3) nflags=FFTW_PATIENT
+      if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
+      if(nfft.le.NSMALL) then
+         jz=nfft
+         if(iform.eq.0) jz=nfft/2
+         do j=1,jz
+            aa(j)=a(j)
+         enddo
+      endif
+!      call sleep_msec(0)
+      if(isign.eq.-1 .and. iform.eq.1) then
+         call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_FORWARD,nflags)
+      else if(isign.eq.1 .and. iform.eq.1) then
+         call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_BACKWARD,nflags)
+      else if(isign.eq.-1 .and. iform.eq.0) then
+         call sfftw_plan_dft_r2c_1d(plan(i),nfft,a,a,nflags)
+      else if(isign.eq.1 .and. iform.eq.-1) then
+         call sfftw_plan_dft_c2r_1d(plan(i),nfft,a,a,nflags)
+      else
+         stop 'Unsupported request in four2a'
+      endif
+!      call sleep_msec(0)
+      i=nplan
+      if(nfft.le.NSMALL) then
+         jz=nfft
+         if(iform.eq.0) jz=nfft/2
+         do j=1,jz
+            a(j)=aa(j)
+         enddo
+      endif
+
+ 10   continue
+!      call sleep_msec(0)
+      call sfftw_execute(plan(i))
+!      call sleep_msec(0)
+      return
+
+ 999  do i=1,nplan
+         call sfftw_destroy_plan(plan(i))
+      enddo
+
+      return
+      end


Property changes on: branches/wspr/four2a.f
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/genwspr.F90
===================================================================
--- branches/wspr/genwspr.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/genwspr.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,108 +0,0 @@
-subroutine genwspr(message,ntxdf,ntune,snrdb,appdir,nappdir,msg2,iwave)
-
-! Encode an MEPT_JT message and generate the corresponding wavefile.
-
-  parameter (NMAX=120*48000)     !Max length of wave file
-  character*22 message           !Message to be generated
-  character*22 msg2
-  character*80 appdir,alltxt
-  integer*2 iwave(NMAX)          !Generated wave file
-  parameter (MAXSYM=176)
-  integer*1 symbol(MAXSYM)
-  integer*1 data0(11),i1
-  integer npr3(162)
-  logical first
-  real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,tsymbol
-  character linetx*51,line*75
-  common/acom2/ntune2,linetx
-
-  equivalence(i1,i4)
-  data npr3/                                   &amp;
-    1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,   &amp;
-    0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,   &amp;
-    0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,   &amp;
-    1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,   &amp;
-    0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,   &amp;
-    0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,   &amp;
-    0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,   &amp;
-    0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,   &amp;
-    0,0/
-
-  data first/.true./,idum/0/
-  save first,idum,pi,twopi
-
-  if(first) then
-     pi=4.d0*atan(1.d0)
-     twopi=2.d0*pi
-     first=.false.
-  endif
-
-  call wqencode(message,ntype,data0)
-  nbytes=(50+31+7)/8
-  call encode232(data0,nbytes,symbol,MAXSYM)  !Convolutional encoding
-  call inter_mept(symbol,1)                   !Apply interleaving
-  do i=1,162
-     i4=0
-     i1=symbol(i)
-  enddo
-  call wqdecode(data0,msg2,ntype2)
-
-  if(ntune.eq.0) then
-
-     call cs_lock('genwspr')
-     alltxt=appdir(:nappdir)//'/ALL_WSPR.TXT'
-#ifdef CVF
-     open(13,file=alltxt,status='unknown',position='append',share='denynone')
-#else
-     open(13,file=alltxt,status='unknown',position='append')
-#endif
-     line=linetx//msg2
-     write(13,1010) line
-1010 format(a75)
-     close(13)
-     call cs_unlock
-
-  endif
-
-! Set up necessary constants
-  tsymbol=4.d0*8192.d0/48000.d0
-  dt=1.d0/48000.d0
-  f0=1500 + ntxdf
-  dfgen=1.d0/tsymbol                     !1.4649 Hz
-  snr=10.0**(0.05*(snrdb-6.5))   !Bandwidth correction?
-  fac=3000.0
-  if(snr.gt.1.0) fac=3000.0/snr
-  t=-1.d0
-  phi=0.d0
-  j0=0
-  f=f0
-  dphi=twopi*dt*f
-
-  do i=1,NMAX
-     t=t+dt
-     j=int(t/tsymbol) + 1                          !Symbol number
-     sig=0.
-     if(j.ge.1 .and. j.le.162) then
-        if(j.ne.j0 .and. ntune2.eq.0) then
-           f=f0 + dfgen*(npr3(j)+2*symbol(j)-1.5)
-           j0=j
-           dphi=twopi*dt*f
-        endif
-        sig=0.9999
-        phi=phi+dphi
-        if(snrdb.gt.50.0) then
-           n=32767.0*sin(phi)           !Normal transmission, signal only
-        else
-           n=fac*(gran(idum) + sig*snr*sin(phi))
-           if(n.gt.32767) n=32767
-           if(n.lt.-32767) n=-32767
-        endif
-        iwave(i)=n
-     else
-        iwave(i)=0
-     endif
-  enddo
-  ntune2=0
-
-  return
-end subroutine genwspr

Added: branches/wspr/genwspr.f90
===================================================================
--- branches/wspr/genwspr.f90	                        (rev 0)
+++ branches/wspr/genwspr.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,104 @@
+subroutine genwspr(message,ntxdf,ntune,snrdb,appdir,nappdir,msg2,iwave)
+
+! Encode an MEPT_JT message and generate the corresponding wavefile.
+
+  parameter (NMAX=120*48000)     !Max length of wave file
+  character*22 message           !Message to be generated
+  character*22 msg2
+  character*80 appdir,alltxt
+  integer*2 iwave(NMAX)          !Generated wave file
+  parameter (MAXSYM=176)
+  integer*1 symbol(MAXSYM)
+  integer*1 data0(11),i1
+  integer npr3(162)
+  logical first
+  real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,tsymbol
+  character linetx*51,line*75
+  common/acom2/ntune2,linetx
+
+  equivalence(i1,i4)
+  data npr3/                                   &amp;
+    1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,   &amp;
+    0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,   &amp;
+    0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,   &amp;
+    1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,   &amp;
+    0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,   &amp;
+    0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,   &amp;
+    0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,   &amp;
+    0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,   &amp;
+    0,0/
+
+  data first/.true./,idum/0/
+  save first,idum,pi,twopi
+
+  if(first) then
+     pi=4.d0*atan(1.d0)
+     twopi=2.d0*pi
+     first=.false.
+  endif
+
+  call wqencode(message,ntype,data0)
+  nbytes=(50+31+7)/8
+  call encode232(data0,nbytes,symbol,MAXSYM)  !Convolutional encoding
+  call inter_mept(symbol,1)                   !Apply interleaving
+  do i=1,162
+     i4=0
+     i1=symbol(i)
+  enddo
+  call wqdecode(data0,msg2,ntype2)
+
+  if(ntune.eq.0) then
+
+     call cs_lock('genwspr')
+     alltxt=appdir(:nappdir)//'/ALL_WSPR.TXT'
+     open(13,file=alltxt,status='unknown',position='append')
+     line=linetx//msg2
+     write(13,1010) line
+1010 format(a75)
+     close(13)
+     call cs_unlock
+
+  endif
+
+! Set up necessary constants
+  tsymbol=4.d0*8192.d0/48000.d0
+  dt=1.d0/48000.d0
+  f0=1500 + ntxdf
+  dfgen=1.d0/tsymbol                     !1.4649 Hz
+  snr=10.0**(0.05*(snrdb-6.5))   !Bandwidth correction?
+  fac=3000.0
+  if(snr.gt.1.0) fac=3000.0/snr
+  t=-1.d0
+  phi=0.d0
+  j0=0
+  f=f0
+  dphi=twopi*dt*f
+
+  do i=1,NMAX
+     t=t+dt
+     j=int(t/tsymbol) + 1                          !Symbol number
+     sig=0.
+     if(j.ge.1 .and. j.le.162) then
+        if(j.ne.j0 .and. ntune2.eq.0) then
+           f=f0 + dfgen*(npr3(j)+2*symbol(j)-1.5)
+           j0=j
+           dphi=twopi*dt*f
+        endif
+        sig=0.9999
+        phi=phi+dphi
+        if(snrdb.gt.50.0) then
+           n=32767.0*sin(phi)           !Normal transmission, signal only
+        else
+           n=fac*(gran(idum) + sig*snr*sin(phi))
+           if(n.gt.32767) n=32767
+           if(n.lt.-32767) n=-32767
+        endif
+        iwave(i)=n
+     else
+        iwave(i)=0
+     endif
+  enddo
+  ntune2=0
+
+  return
+end subroutine genwspr


Property changes on: branches/wspr/genwspr.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/getfile.F90
===================================================================
--- branches/wspr/getfile.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/getfile.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,52 +0,0 @@
-subroutine getfile(fname,len)
-!f2py threadsafe
-
-#ifdef CVF
-  use dflib
-#endif
-
-  character*(*) fname
-  include 'acom1.f90'
-  integer*1 hdr(44),n1
-  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-  character*4 ariff,awave,afmt,adata
-  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
-     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
-  equivalence (ariff,hdr),(n1,n4),(d1,d2)
-
-1 if(ndecoding.eq.0) go to 2
-  call msleep(100)
-  go to 1
-
-2 ndecoding=1
-  do i=len,1,-1
-     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
-  enddo
-  i=0
-10  continue
-
-  call cs_lock('getfile')
-#ifdef CVF
-  open(10,file=fname,form='binary',status='old')
-#else
-  open(10,file=fname,access='stream',status='old')
-#endif
-  read(10) hdr
-  npts=114*12000
-  read(10) (iwave(i),i=1,npts)
-  close(10)
-  call cs_unlock
-  n4=1
-  if (n1.eq.1) goto 8                     !skip byteswap if little endian
-  do i=1,npts
-     i4 = iwave(i)
-     iwave(i) = ishft(iand(i4,255),8) +  iand(ishft(i4,-8),255)
-  enddo    
-8 call getrms(iwave,npts,ave,rms)
-  ndecdone=0                              !??? ### ???
-  ndiskdat=1
-  outfile=fname
-  nrxdone=1
-
-  return
-end subroutine getfile

Added: branches/wspr/getfile.f90
===================================================================
--- branches/wspr/getfile.f90	                        (rev 0)
+++ branches/wspr/getfile.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,44 @@
+subroutine getfile(fname,len)
+!f2py threadsafe
+
+  character*(*) fname
+  include 'acom1.f90'
+  integer*1 hdr(44),n1
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
+  equivalence (ariff,hdr),(n1,n4),(d1,d2)
+
+1 if(ndecoding.eq.0) go to 2
+  call msleep(100)
+  go to 1
+
+2 ndecoding=1
+  do i=len,1,-1
+     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
+  enddo
+  i=0
+10  continue
+
+  call cs_lock('getfile')
+  open(10,file=fname,access='stream',status='old')
+  read(10) hdr
+  npts=114*12000
+  read(10) (iwave(i),i=1,npts)
+  close(10)
+  call cs_unlock
+  n4=1
+  if (n1.eq.1) goto 8                     !skip byteswap if little endian
+  do i=1,npts
+     i4 = iwave(i)
+     iwave(i) = ishft(iand(i4,255),8) +  iand(ishft(i4,-8),255)
+  enddo    
+8 call getrms(iwave,npts,ave,rms)
+  ndecdone=0                              !??? ### ???
+  ndiskdat=1
+  outfile=fname
+  nrxdone=1
+
+  return
+end subroutine getfile


Property changes on: branches/wspr/getfile.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/mept162.F
===================================================================
--- branches/wspr/mept162.F	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/mept162.F	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,109 +0,0 @@
-      subroutine mept162(outfile,appdir,nappdir,f0,minsync,id,npts,
-     +  nbfo,ierr)
-
-C  Orchestrates the process of finding, synchronizing, and decoding 
-C  WSPR signals.
-
-      integer*2 id(npts)
-      character*22 message
-      character*80 outfile,appdir,alltxt
-      character*11 datetime
-      character cdate*8,ctime*10
-      real*8 f0,freq,tsec
-      real ps(-256:256)
-      real sstf(5,275)
-      real a(5)
-      complex c2(65536)
-      complex c3(45000),c4(45000)
-
-C  Mix from &quot;nbfo&quot; +/- 100 Hz to baseband, and downsample by 1/32
-      call mix162(id,npts,nbfo,c2,jz,ps)
-
-C  Compute pixmap.dat
-      call spec162(c2,jz,appdir,nappdir)
-
-C  Look for sync patterns, get DF and DT
-      call sync162(c2,jz,ps,sstf,kz)
-      ierr = 0
-      if(kz.eq.0) go to 900
-      if (kz.gt.275 .or. kz.lt.0) then
-        call getutc(cdate,ctime,tsec)
-
-        call cs_lock('mept162')
-        write(*,1000) ctime,kz
- 1000   format('Time ',a8,'. Error from sync162: kz is',i10)
-        call cs_unlock
-
-        ierr = 1
-        return
-      endif
-      do k=1,kz
-         snrsync=sstf(1,k)
-         snrx=sstf(2,k)
-         dtx=sstf(3,k)
-         dfx=sstf(4,k)
-         drift=sstf(5,k)
-         a(1)=-dfx
-         a(2)=-0.5*drift
-         a(3)=0.
-         call twkfreq(c2,c3,jz,a)                    !Remove drift
-
-         minsync=1                                   !####
-         nsync=nint(snrsync)
-         nsnrx=nint(snrx)
-         if(nsnrx.lt.-33) nsnrx=-33
-         if(nsync.lt.0) nsync=0
-         freq=f0 + 1.d-6*(dfx+nbfo)
-         message='                      '
-         if(nsync.ge.minsync .and. nsnrx.ge.-33) then      !### -31 dB limit?
-
-            dt=1.0/375
-            do idt=0,128
-               ii=(idt+1)/2
-               if(mod(idt,2).eq.1) ii=-ii
-               i1=nint((dtx+2.0)/dt) + ii !Start index for synced symbols
-               if(i1.ge.1) then
-!  Fix this earlier!
-                  c4(1:jz-i1+1)=c3(i1:)
-                  c4(jz-i1+2:)=0.
-               else
-                  c4(:-i1+1)=0.
-                  c4(-i1+2:jz)=c3(:i1+jz-1)
-                  if(jz.lt.45000) c4(jz:)=0.
-               endif
-               call decode162(c4,45000,message,ncycles,metric,nerr)
-               if(message(1:6).ne.'      ' .and. 
-     +            message(1:6).ne.'000AAA' .and.
-     +            index(message,'A000AA').le.0) go to 23
-            enddo
-            go to 24
-
- 23         i2=index(outfile,'.wav')-1
-            if(i2.le.0) i2=index(outfile,'.WAV')-1
-            datetime=outfile(i2-10:i2)
-            datetime(7:7)=' '
-            nf1=nint(-a(2))
-            alltxt=appdir(:nappdir)//'/ALL_WSPR.TXT'
-
-            call cs_lock('mept162a')
-#ifdef CVF
-            open(13,file=alltxt,status='unknown',position='append',
-     +           share='denynone')
-#else
-            open(13,file=alltxt,status='unknown',position='append')
-#endif
-            write(13,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,
-     +           ncycles/81,ii
-            close(13)
-            write(14,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,
-     +           ncycles/81,ii
- 1010       format(a11,i4,i4,f5.1,f11.6,2x,a22,i3,i6,i5)
-            i1=index(message,' ')
-            call cs_unlock
-
-         endif
- 24      continue
-      enddo
-
- 900  return
-      end

Added: branches/wspr/mept162.f
===================================================================
--- branches/wspr/mept162.f	                        (rev 0)
+++ branches/wspr/mept162.f	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,104 @@
+      subroutine mept162(outfile,appdir,nappdir,f0,minsync,id,npts,
+     +  nbfo,ierr)
+
+C  Orchestrates the process of finding, synchronizing, and decoding 
+C  WSPR signals.
+
+      integer*2 id(npts)
+      character*22 message
+      character*80 outfile,appdir,alltxt
+      character*11 datetime
+      character cdate*8,ctime*10
+      real*8 f0,freq,tsec
+      real ps(-256:256)
+      real sstf(5,275)
+      real a(5)
+      complex c2(65536)
+      complex c3(45000),c4(45000)
+
+C  Mix from &quot;nbfo&quot; +/- 100 Hz to baseband, and downsample by 1/32
+      call mix162(id,npts,nbfo,c2,jz,ps)
+
+C  Compute pixmap.dat
+      call spec162(c2,jz,appdir,nappdir)
+
+C  Look for sync patterns, get DF and DT
+      call sync162(c2,jz,ps,sstf,kz)
+      ierr = 0
+      if(kz.eq.0) go to 900
+      if (kz.gt.275 .or. kz.lt.0) then
+        call getutc(cdate,ctime,tsec)
+
+        call cs_lock('mept162')
+        write(*,1000) ctime,kz
+ 1000   format('Time ',a8,'. Error from sync162: kz is',i10)
+        call cs_unlock
+
+        ierr = 1
+        return
+      endif
+      do k=1,kz
+         snrsync=sstf(1,k)
+         snrx=sstf(2,k)
+         dtx=sstf(3,k)
+         dfx=sstf(4,k)
+         drift=sstf(5,k)
+         a(1)=-dfx
+         a(2)=-0.5*drift
+         a(3)=0.
+         call twkfreq(c2,c3,jz,a)                    !Remove drift
+
+         minsync=1                                   !####
+         nsync=nint(snrsync)
+         nsnrx=nint(snrx)
+         if(nsnrx.lt.-33) nsnrx=-33
+         if(nsync.lt.0) nsync=0
+         freq=f0 + 1.d-6*(dfx+nbfo)
+         message='                      '
+         if(nsync.ge.minsync .and. nsnrx.ge.-33) then      !### -31 dB limit?
+
+            dt=1.0/375
+            do idt=0,128
+               ii=(idt+1)/2
+               if(mod(idt,2).eq.1) ii=-ii
+               i1=nint((dtx+2.0)/dt) + ii !Start index for synced symbols
+               if(i1.ge.1) then
+!  Fix this earlier!
+                  c4(1:jz-i1+1)=c3(i1:)
+                  c4(jz-i1+2:)=0.
+               else
+                  c4(:-i1+1)=0.
+                  c4(-i1+2:jz)=c3(:i1+jz-1)
+                  if(jz.lt.45000) c4(jz:)=0.
+               endif
+               call decode162(c4,45000,message,ncycles,metric,nerr)
+               if(message(1:6).ne.'      ' .and. 
+     +            message(1:6).ne.'000AAA' .and.
+     +            index(message,'A000AA').le.0) go to 23
+            enddo
+            go to 24
+
+ 23         i2=index(outfile,'.wav')-1
+            if(i2.le.0) i2=index(outfile,'.WAV')-1
+            datetime=outfile(i2-10:i2)
+            datetime(7:7)=' '
+            nf1=nint(-a(2))
+            alltxt=appdir(:nappdir)//'/ALL_WSPR.TXT'
+
+            call cs_lock('mept162a')
+            open(13,file=alltxt,status='unknown',position='append')
+            write(13,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,
+     +           ncycles/81,ii
+            close(13)
+            write(14,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,
+     +           ncycles/81,ii
+ 1010       format(a11,i4,i4,f5.1,f11.6,2x,a22,i3,i6,i5)
+            i1=index(message,' ')
+            call cs_unlock
+
+         endif
+ 24      continue
+      enddo
+
+ 900  return
+      end


Property changes on: branches/wspr/mept162.f
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/rx.F90
===================================================================
--- branches/wspr/rx.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/rx.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,38 +0,0 @@
-subroutine rx
-
-!  Receive and decode MEPT_JT signals for one 2-minute sequence.
-
-#ifdef CVF
-  use dfport
-#else
-  integer time
-#endif
-
-  integer soundin
-  include 'acom1.f90'
-
-  npts=114*12000
-  if(ncal.eq.1) npts=65536
-  nsec1=time()
-  f0a=f0                                   !Save rx frequency at start
-  ierr=soundin(ndevin,kwave,4*npts,iqmode)
-!  write(50) 8*npts,(kwave(i),i=1,8*npts)
-  if(ierr.ne.0) then
-     print*,'Error in soundin',ierr
-     stop
-  endif
-  if(iqmode.eq.1) then
-     call iqdemod(kwave,8*npts)
-  endif
-  call fil1(kwave,4*npts,iwave,n2)
-  npts=n2
-  nsec2=time()
-  call getrms(iwave,npts,ave,rms)          !### is this needed any more??
-  call cs_lock('rx')
-  nrxdone=1
-  if(ncal.eq.1) ncal=2
-  call cs_unlock
-
-  return
-end subroutine rx
-

Added: branches/wspr/rx.f90
===================================================================
--- branches/wspr/rx.f90	                        (rev 0)
+++ branches/wspr/rx.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,34 @@
+subroutine rx
+
+!  Receive and decode MEPT_JT signals for one 2-minute sequence.
+
+  integer time
+
+  integer soundin
+  include 'acom1.f90'
+
+  npts=114*12000
+  if(ncal.eq.1) npts=65536
+  nsec1=time()
+  f0a=f0                                   !Save rx frequency at start
+  ierr=soundin(ndevin,kwave,4*npts,iqmode)
+!  write(50) 8*npts,(kwave(i),i=1,8*npts)
+  if(ierr.ne.0) then
+     print*,'Error in soundin',ierr
+     stop
+  endif
+  if(iqmode.eq.1) then
+     call iqdemod(kwave,8*npts)
+  endif
+  call fil1(kwave,4*npts,iwave,n2)
+  npts=n2
+  nsec2=time()
+  call getrms(iwave,npts,ave,rms)          !### is this needed any more??
+  call cs_lock('rx')
+  nrxdone=1
+  if(ncal.eq.1) ncal=2
+  call cs_unlock
+
+  return
+end subroutine rx
+


Property changes on: branches/wspr/rx.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/spec162.F
===================================================================
--- branches/wspr/spec162.F	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/spec162.F	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,102 +0,0 @@
-      subroutine spec162(c2,jz,appdir,nappdir)
-
-      parameter(NX=500,NY=160)
-      complex c2(65536)
-      complex c(0:255)
-      character*80 appdir,pixmap
-      real s(120,0:255)
-      real ss(0:255)
-      real w(0:255)
-      real savg(0:255)
-      integer*2 a(NX,NY)
-      common/bcom/ntransmitted
-
-      nfft=256
-      twopi=6.2831853
-      pi=0.5*twopi
-      do i=0,nfft-1
-         w(i)=sin(i*pi/nfft)
-      enddo
-
-      nadd=9
-      call zero(s,120*256)
-      call zero(savg,256)
-      istep=nfft/2
-      nsteps=(jz-nfft)/(nadd*istep)
-      pixmap=appdir(:nappdir)//'/pixmap.dat'
-
-      call cs_lock('spec162')
-#ifdef CVF
-      open(16,file=pixmap,form='binary',status='unknown',err=1)
-#else
-      open(16,file=pixmap,access='stream',status='unknown',err=1)
-#endif
-      read(16,end=1) a
-      go to 2
- 1    call zero(a,NX*NY/2)
-
- 2    nmove=nsteps+1
-      call cs_unlock
-
-      do j=1,NY                 !Move waterfall left
-         do i=1,NX-nmove
-            a(i,j)=a(i+nmove,j)
-         enddo
-         a(NX-nmove+1,j)=255*ntransmitted
-      enddo
-      ntransmitted=0
-
-      i0=-istep+1
-      k=0
-      do n=1,nsteps
-         k=k+1
-         call zero(ss,256)
-         do m=1,nadd
-            i0=i0+istep
-            do i=0,nfft-1
-               c(i)=w(i)*c2(i0+i)
-            enddo
-            call four2a(c,nfft,1,-1,1)
-            do i=0,nfft-1
-               sq=real(c(i))**2 + imag(c(i))**2
-               ss(i)=ss(i) + sq
-               savg(i)=savg(i) + sq
-            enddo
-         enddo
-         call flat3(ss,256,nadd)
-         do i=0,nfft-1
-            s(k,i)=ss(i)
-         enddo
-      enddo
-      kz=k
-
-      gain=40
-      offset=-90.
-      fac=20.0/nadd
-
-      do k=1,kz
-         j=k-kz+NX
-         do i=-80,-1
-            x=fac*s(k,i+nfft)
-            n=0
-            if(x.gt.0.0) n=gain*log10(x) + offset
-            n=min(252,max(0,n))
-            a(j,NY-i-80)=n
-         enddo
-         do i=0,79
-            x=fac*s(k,i)
-            n=0
-            if(x.gt.0.0) n=gain*log10(x) + offset
-            n=min(252,max(0,n))
-            a(j,NY-i-80)=n
-         enddo
-      enddo
-
-      call cs_lock('spec162')
-      rewind 16
-      write(16) a
-      close(16)
-      call cs_unlock
-
-      return
-      end

Added: branches/wspr/spec162.f
===================================================================
--- branches/wspr/spec162.f	                        (rev 0)
+++ branches/wspr/spec162.f	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,98 @@
+      subroutine spec162(c2,jz,appdir,nappdir)
+
+      parameter(NX=500,NY=160)
+      complex c2(65536)
+      complex c(0:255)
+      character*80 appdir,pixmap
+      real s(120,0:255)
+      real ss(0:255)
+      real w(0:255)
+      real savg(0:255)
+      integer*2 a(NX,NY)
+      common/bcom/ntransmitted
+
+      nfft=256
+      twopi=6.2831853
+      pi=0.5*twopi
+      do i=0,nfft-1
+         w(i)=sin(i*pi/nfft)
+      enddo
+
+      nadd=9
+      call zero(s,120*256)
+      call zero(savg,256)
+      istep=nfft/2
+      nsteps=(jz-nfft)/(nadd*istep)
+      pixmap=appdir(:nappdir)//'/pixmap.dat'
+
+      call cs_lock('spec162')
+      open(16,file=pixmap,access='stream',status='unknown',err=1)
+      read(16,end=1) a
+      go to 2
+ 1    call zero(a,NX*NY/2)
+
+ 2    nmove=nsteps+1
+      call cs_unlock
+
+      do j=1,NY                 !Move waterfall left
+         do i=1,NX-nmove
+            a(i,j)=a(i+nmove,j)
+         enddo
+         a(NX-nmove+1,j)=255*ntransmitted
+      enddo
+      ntransmitted=0
+
+      i0=-istep+1
+      k=0
+      do n=1,nsteps
+         k=k+1
+         call zero(ss,256)
+         do m=1,nadd
+            i0=i0+istep
+            do i=0,nfft-1
+               c(i)=w(i)*c2(i0+i)
+            enddo
+            call four2a(c,nfft,1,-1,1)
+            do i=0,nfft-1
+               sq=real(c(i))**2 + imag(c(i))**2
+               ss(i)=ss(i) + sq
+               savg(i)=savg(i) + sq
+            enddo
+         enddo
+         call flat3(ss,256,nadd)
+         do i=0,nfft-1
+            s(k,i)=ss(i)
+         enddo
+      enddo
+      kz=k
+
+      gain=40
+      offset=-90.
+      fac=20.0/nadd
+
+      do k=1,kz
+         j=k-kz+NX
+         do i=-80,-1
+            x=fac*s(k,i+nfft)
+            n=0
+            if(x.gt.0.0) n=gain*log10(x) + offset
+            n=min(252,max(0,n))
+            a(j,NY-i-80)=n
+         enddo
+         do i=0,79
+            x=fac*s(k,i)
+            n=0
+            if(x.gt.0.0) n=gain*log10(x) + offset
+            n=min(252,max(0,n))
+            a(j,NY-i-80)=n
+         enddo
+      enddo
+
+      call cs_lock('spec162')
+      rewind 16
+      write(16) a
+      close(16)
+      call cs_unlock
+
+      return
+      end


Property changes on: branches/wspr/spec162.f
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/startdec.F90
===================================================================
--- branches/wspr/startdec.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/startdec.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,42 +0,0 @@
-subroutine startdec
-
-#ifdef CVF
-  use dfmt
-  integer Thread3
-#else
-  integer th_decode
-#endif
-  external decode
-  include 'acom1.f90'
-
-#ifdef CVF
-!  Priority classes (for processes):
-!     IDLE_PRIORITY_CLASS               64
-!     NORMAL_PRIORITY_CLASS             32
-!     HIGH_PRIORITY_CLASS              128
-
-!  Priority definitions (for threads):
-!     THREAD_PRIORITY_IDLE             -15
-!     THREAD_PRIORITY_LOWEST            -2
-!     THREAD_PRIORITY_BELOW_NORMAL      -1
-!     THREAD_PRIORITY_NORMAL             0
-!     THREAD_PRIORITY_ABOVE_NORMAL       1
-!     THREAD_PRIORITY_HIGHEST            2
-!     THREAD_PRIORITY_TIME_CRITICAL     15
-
-  ndecdone=0
-  m0=SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS)
-! Start a thread for playing audio data
-  Thread3=CreateThread(0,0,decode,0,CREATE_SUSPENDED,id1)
-  m1=SetThreadPriority(Thread3,THREAD_PRIORITY_BELOW_NORMAL)
-  m2=ResumeThread(Thread3)
-#else
-  ierr=th_decode()
-  if(ierr.ne.0) then
-     print*,'Error starting decode thread',ierr
-     stop
-  endif
-#endif
-
-  return
-end subroutine startdec

Added: branches/wspr/startdec.f90
===================================================================
--- branches/wspr/startdec.f90	                        (rev 0)
+++ branches/wspr/startdec.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,14 @@
+subroutine startdec
+
+  integer th_decode
+  external decode
+  include 'acom1.f90'
+
+  ierr=th_decode()
+  if(ierr.ne.0) then
+     print*,'Error starting decode thread',ierr
+     stop
+  endif
+
+  return
+end subroutine startdec


Property changes on: branches/wspr/startdec.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/startrx.F90
===================================================================
--- branches/wspr/startrx.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/startrx.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,43 +0,0 @@
-subroutine startrx
-
-#ifdef CVF
-  use dfmt
-  integer Thread1
-  external rx
-#else
-  integer th_rx
-#endif
-
-  include 'acom1.f90'
-
-#ifdef CVF
-!  Priority classes (for processes):
-!     IDLE_PRIORITY_CLASS               64
-!     NORMAL_PRIORITY_CLASS             32
-!     HIGH_PRIORITY_CLASS              128
-
-!  Priority definitions (for threads):
-!     THREAD_PRIORITY_IDLE             -15
-!     THREAD_PRIORITY_LOWEST            -2
-!     THREAD_PRIORITY_BELOW_NORMAL      -1
-!     THREAD_PRIORITY_NORMAL             0
-!     THREAD_PRIORITY_ABOVE_NORMAL       1
-!     THREAD_PRIORITY_HIGHEST            2
-!     THREAD_PRIORITY_TIME_CRITICAL     15
-
-  nrxdone=0
-  m0=SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS)
-! Start a thread for acquiring audio data
-  Thread1=CreateThread(0,0,rx,0,CREATE_SUSPENDED,id1)
-  m1=SetThreadPriority(Thread1,THREAD_PRIORITY_ABOVE_NORMAL)
-  m2=ResumeThread(Thread1)
-#else
-  ierr=th_rx()
-  if(ierr.ne.0) then
-     print*,'Error starting rx thread',ierr
-     stop
-  endif
-#endif
-
-  return
-end subroutine startrx

Added: branches/wspr/startrx.f90
===================================================================
--- branches/wspr/startrx.f90	                        (rev 0)
+++ branches/wspr/startrx.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,14 @@
+subroutine startrx
+
+  integer th_rx
+
+  include 'acom1.f90'
+
+  ierr=th_rx()
+  if(ierr.ne.0) then
+     print*,'Error starting rx thread',ierr
+     stop
+  endif
+
+  return
+end subroutine startrx


Property changes on: branches/wspr/startrx.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/starttx.F90
===================================================================
--- branches/wspr/starttx.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/starttx.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,43 +0,0 @@
-subroutine starttx
-
-#ifdef CVF
-  use dfmt
-  integer Thread2
-  external tx
-#else
-  integer th_tx
-#endif
-
-  include 'acom1.f90'
-
-#ifdef CVF
-!  Priority classes (for processes):
-!     IDLE_PRIORITY_CLASS               64
-!     NORMAL_PRIORITY_CLASS             32
-!     HIGH_PRIORITY_CLASS              128
-
-!  Priority definitions (for threads):
-!     THREAD_PRIORITY_IDLE             -15
-!     THREAD_PRIORITY_LOWEST            -2
-!     THREAD_PRIORITY_BELOW_NORMAL      -1
-!     THREAD_PRIORITY_NORMAL             0
-!     THREAD_PRIORITY_ABOVE_NORMAL       1
-!     THREAD_PRIORITY_HIGHEST            2
-!     THREAD_PRIORITY_TIME_CRITICAL     15
-
-  ntxdone=0
-  m0=SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS)
-! Start a thread for playing audio data
-  Thread2=CreateThread(0,0,tx,0,CREATE_SUSPENDED,id1)
-  m1=SetThreadPriority(Thread2,THREAD_PRIORITY_ABOVE_NORMAL)
-  m2=ResumeThread(Thread2)
-#else
-  ierr=th_tx()
-  if(ierr.ne.0) then
-     print*,'Error starting tx thread',ierr
-     stop
-  endif
-#endif
-
-  return
-end subroutine starttx

Added: branches/wspr/starttx.f90
===================================================================
--- branches/wspr/starttx.f90	                        (rev 0)
+++ branches/wspr/starttx.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,14 @@
+subroutine starttx
+
+  integer th_tx
+
+  include 'acom1.f90'
+
+  ierr=th_tx()
+  if(ierr.ne.0) then
+     print*,'Error starting tx thread',ierr
+     stop
+  endif
+
+  return
+end subroutine starttx


Property changes on: branches/wspr/starttx.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/tx.F90
===================================================================
--- branches/wspr/tx.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/tx.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,155 +0,0 @@
-subroutine tx
-
-!  Make one transmission of a WSPR message, or an unmodulated &quot;Tune&quot; sequence.
-
-#ifdef CVF
-  use dfport
-  use dflib
-#else
-  integer system
-#endif
-
-  parameter (NMAX2=120*48000)
-  parameter (NMAX3=4.5*48000)
-  character message*22,call1*12,cdbm*3
-  character*22 msg0,msg1,cwmsg
-  character crig*6,cbaud*6,cdata*1,cstop*1,chs*8
-  character cmnd*120,snrfile*80
-  integer*2 jwave,icwid
-  integer soundout,ptt,nt(9)
-  real*8 tsec1,tsec2
-  include 'acom1.f90'
-  common/bcom/ntransmitted
-  common/dcom/jwave(NMAX2),icwid(NMAX3)
-  data ntx/0/,ns0/0/
-  save ntx,ns0
-
-  ierr=0
-  call1=callsign
-  call cs_lock('tx')
-  if(pttmode.eq.'CAT') then
-     write(crig,'(i6)') nrig
-     write(cbaud,'(i6)') nbaud
-     write(cdata,'(i1)') ndatabits
-     write(cstop,'(i1)') nstopbits
-     chs='None'
-     if(nhandshake.eq.1) chs='XONXOFF'
-     if(nhandshake.eq.2) chs='Hardware'
-     cmnd='rigctl '//'-m'//crig//' -r'//catport//' -s'//cbaud//           &amp;
-          ' -C data_bits='//cdata//' -C stop_bits='//cstop//              &amp;
-          ' -C serial_handshake='//chs//' T 1'
-
-! Example rigctl command:
-! rigctl -m 1608 -r /dev/ttyUSB0 -s 57600 -C data_bits=8 -C stop_bits=1 \
-!   -C serial_handshake=Hardware T 1
-
-#ifdef CVF
-     iret=runqq('rigctl.exe',cmnd(8:))
-#else
-     iret=system(cmnd)
-#endif
-     if(iret.ne.0) then
-        print*,'Error executing rigctl command to set Tx mode:'
-        print*,cmnd
-     endif
-  else
-     if(nport.gt.0 .or. pttport(1:4).eq.'/dev') ierr=ptt(nport,pttport,1,iptt)
-  endif
-
-  write(cdbm,'(i3)'),ndbm
-  call cs_unlock
-
-  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-  ntx=1-ntx
-  i1=index(call1,' ')
-  i2=index(call1,'/')
-
-  if(i2.gt.0 .or. igrid6.ne.0) then
-! WSPR_2 message, in two parts
-     if(i2.le.0) then
-        msg1=call1(1:i1)//grid//' '//cdbm
-     else
-        msg1=call1(:i1)//cdbm
-     endif
-     msg0='&lt;'//call1(:i1-1)//'&gt; '//grid6//' '//cdbm
-     if(ntx.eq.1) message=msg1
-     if(ntx.eq.0) message=msg0
-
-  else
-! Normal WSPR message
-     message=call1(1:i1)//grid//' '//cdbm
-  endif
-
-  ntxdf=nint(1.e6*(ftx-f0)) - 1500
-  ctxmsg=message
-  snr=99.0
-  snrfile=appdir(:nappdir)//'/test.snr'
-
-  call cs_lock('tx')
-  open(18,file=snrfile,status='old',err=10)
-  read(18,*,err=10,end=10) snr
-10 close(18)
-  call cs_unlock
-  call gmtime2(nt,tsec1)
-  call genwspr(message,ntxdf,ntune,snr,appdir,nappdir,sending,jwave)
-  npts=114*48000
-  if(nsec.lt.ns0) ns0=nsec
-
-  if(idint.ne.0 .and. (nsec-ns0)/60.ge.idint) then
-!  Generate and insert the CW ID.
-     wpm=25.
-     freqcw=1500.0 + ntxdf
-     cwmsg=call1(:i1)//'                      '
-     icwid=0
-     call gencwid(cwmsg,wpm,freqcw,icwid,ncwid)
-     k0=112*48000
-     k1=k0+12000
-     k2=k1+4.5*48000
-     jwave(k0:k1)=0
-     jwave(k1+1:k2)=icwid
-     jwave(k2:)=0
-     npts=k2
-     ns0=nsec
-  endif
-
-  if(ntune.eq.0) then
-     call gmtime2(nt,tsec2)
-     istart=48000*(tsec2-tsec0)
-     ierr=soundout(ndevout,jwave(istart),npts)
-  else
-     npts=48000*pctx
-     ierr=soundout(ndevout,jwave(2*48000),npts)
-     ntune=0
-  endif
-  if(ierr.ne.0) then
-     print*,'Error in soundout',ierr
-     stop
-  endif
-
-  if(pttmode.eq.'CAT') then
-     cmnd='rigctl '//'-m'//crig//' -r'//catport//' -s'//cbaud//           &amp;
-          ' -C data_bits='//cdata//' -C stop_bits='//cstop//              &amp;
-          ' -C serial_handshake='//chs//' T 0'
-
-     call cs_lock('tx')
-#ifdef CVF
-     iret=runqq('rigctl.exe',cmnd(8:))
-#else
-     iret=system(cmnd)
-#endif
-     if(iret.ne.0) then
-        print*,'Error executing rigctl command to set Rx mode:'
-        print*,cmnd
-     endif
-     call cs_unlock
-
-  else
-     if(nport.gt.0 .or. pttport(1:4).eq.'/dev') ierr=ptt(nport,pttport,0,iptt)
-  endif
-
-  ntransmitted=1
-  ntxdone=1
-
-  return
-end subroutine tx

Added: branches/wspr/tx.f90
===================================================================
--- branches/wspr/tx.f90	                        (rev 0)
+++ branches/wspr/tx.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,142 @@
+subroutine tx
+
+!  Make one transmission of a WSPR message, or an unmodulated &quot;Tune&quot; sequence.
+
+  integer system
+
+  parameter (NMAX2=120*48000)
+  parameter (NMAX3=4.5*48000)
+  character message*22,call1*12,cdbm*3
+  character*22 msg0,msg1,cwmsg
+  character crig*6,cbaud*6,cdata*1,cstop*1,chs*8
+  character cmnd*120,snrfile*80
+  integer*2 jwave,icwid
+  integer soundout,ptt,nt(9)
+  real*8 tsec1,tsec2
+  include 'acom1.f90'
+  common/bcom/ntransmitted
+  common/dcom/jwave(NMAX2),icwid(NMAX3)
+  data ntx/0/,ns0/0/
+  save ntx,ns0
+
+  ierr=0
+  call1=callsign
+  call cs_lock('tx')
+  if(pttmode.eq.'CAT') then
+     write(crig,'(i6)') nrig
+     write(cbaud,'(i6)') nbaud
+     write(cdata,'(i1)') ndatabits
+     write(cstop,'(i1)') nstopbits
+     chs='None'
+     if(nhandshake.eq.1) chs='XONXOFF'
+     if(nhandshake.eq.2) chs='Hardware'
+     cmnd='rigctl '//'-m'//crig//' -r'//catport//' -s'//cbaud//           &amp;
+          ' -C data_bits='//cdata//' -C stop_bits='//cstop//              &amp;
+          ' -C serial_handshake='//chs//' T 1'
+
+! Example rigctl command:
+! rigctl -m 1608 -r /dev/ttyUSB0 -s 57600 -C data_bits=8 -C stop_bits=1 \
+!   -C serial_handshake=Hardware T 1
+
+     iret=system(cmnd)
+     if(iret.ne.0) then
+        print*,'Error executing rigctl command to set Tx mode:'
+        print*,cmnd
+     endif
+  else
+     if(nport.gt.0 .or. pttport(1:4).eq.'/dev') ierr=ptt(nport,pttport,1,iptt)
+  endif
+
+  write(cdbm,'(i3)'),ndbm
+  call cs_unlock
+
+  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+  ntx=1-ntx
+  i1=index(call1,' ')
+  i2=index(call1,'/')
+
+  if(i2.gt.0 .or. igrid6.ne.0) then
+! WSPR_2 message, in two parts
+     if(i2.le.0) then
+        msg1=call1(1:i1)//grid//' '//cdbm
+     else
+        msg1=call1(:i1)//cdbm
+     endif
+     msg0='&lt;'//call1(:i1-1)//'&gt; '//grid6//' '//cdbm
+     if(ntx.eq.1) message=msg1
+     if(ntx.eq.0) message=msg0
+
+  else
+! Normal WSPR message
+     message=call1(1:i1)//grid//' '//cdbm
+  endif
+
+  ntxdf=nint(1.e6*(ftx-f0)) - 1500
+  ctxmsg=message
+  snr=99.0
+  snrfile=appdir(:nappdir)//'/test.snr'
+
+  call cs_lock('tx')
+  open(18,file=snrfile,status='old',err=10)
+  read(18,*,err=10,end=10) snr
+10 close(18)
+  call cs_unlock
+  call gmtime2(nt,tsec1)
+  call genwspr(message,ntxdf,ntune,snr,appdir,nappdir,sending,jwave)
+  npts=114*48000
+  if(nsec.lt.ns0) ns0=nsec
+
+  if(idint.ne.0 .and. (nsec-ns0)/60.ge.idint) then
+!  Generate and insert the CW ID.
+     wpm=25.
+     freqcw=1500.0 + ntxdf
+     cwmsg=call1(:i1)//'                      '
+     icwid=0
+     call gencwid(cwmsg,wpm,freqcw,icwid,ncwid)
+     k0=112*48000
+     k1=k0+12000
+     k2=k1+4.5*48000
+     jwave(k0:k1)=0
+     jwave(k1+1:k2)=icwid
+     jwave(k2:)=0
+     npts=k2
+     ns0=nsec
+  endif
+
+  if(ntune.eq.0) then
+     call gmtime2(nt,tsec2)
+     istart=48000*(tsec2-tsec0)
+     ierr=soundout(ndevout,jwave(istart),npts)
+  else
+     npts=48000*pctx
+     ierr=soundout(ndevout,jwave(2*48000),npts)
+     ntune=0
+  endif
+  if(ierr.ne.0) then
+     print*,'Error in soundout',ierr
+     stop
+  endif
+
+  if(pttmode.eq.'CAT') then
+     cmnd='rigctl '//'-m'//crig//' -r'//catport//' -s'//cbaud//           &amp;
+          ' -C data_bits='//cdata//' -C stop_bits='//cstop//              &amp;
+          ' -C serial_handshake='//chs//' T 0'
+
+     call cs_lock('tx')
+     iret=system(cmnd)
+     if(iret.ne.0) then
+        print*,'Error executing rigctl command to set Rx mode:'
+        print*,cmnd
+     endif
+     call cs_unlock
+
+  else
+     if(nport.gt.0 .or. pttport(1:4).eq.'/dev') ierr=ptt(nport,pttport,0,iptt)
+  endif
+
+  ntransmitted=1
+  ntxdone=1
+
+  return
+end subroutine tx


Property changes on: branches/wspr/tx.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/wfile5.F
===================================================================
--- branches/wspr/wfile5.F	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/wfile5.F	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,93 +0,0 @@
-      subroutine wfile5(iwave,nmax,nfsample,outfile)
-
-C  Write a wavefile to disk.
-
-      integer*1 n4 
-      integer*2 iwave(nmax)
-      character*80 outfile
-
-      integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-      character*4 ariff,awave,afmt,adata
-      integer*1 hdr(44)
-      integer*2 iswap_short
-      common/hdr/ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,
-     +     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata
-      equivalence (hdr,ariff),(nfmt2,n4)
-
-C  Generate the header
-      ariff='RIFF'
-      awave='WAVE'
-      afmt='fmt '
-      adata='data'
-      lenfmt=16                             !Rest of this sub-chunk is 16 bytes long
-      nfmt2=1                               !PCM = 1
-      nchan2=1                              !1=mono, 2=stereo
-      nbitsam2=16                           !Bits per sample
-      nsamrate=nfsample
-      nbytesec=nfsample*nchan2*nbitsam2/8   !Bytes per second
-      nbytesam2=nchan2*nbitsam2/8           !Block-align               
-      ndata=nmax*nchan2*nbitsam2/8
-      nbytes=ndata+44
-      nchunk=nbytes-8
-
-      call cs_lock('wfile5')
-#ifdef CVF
-      open(12,file=outfile,form='binary',status='unknown')
-#else
-      open(12,file=outfile,access='stream',status='unknown')
-#endif
-      if (n4.ne.nfmt2) then
-        call change_endian                  !Change hdr to little-endian
-        do i=1,nmax
-            iwave(i) = iswap_short(iwave(i))!Change data to little-endian
-        enddo
-      endif
-      write(12) hdr
-      write(12) iwave
-      close(12)
-      call cs_unlock
-
-      return
-      end
-
-      subroutine change_endian
-
-      integer*1 hdr(44)
-      integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-      integer*2 iswap_short
-      character*4 ariff,awave,afmt,adata
-      common/hdr/ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2, 
-     +       nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata
-      equivalence (ariff,hdr)
-
-      nchunk = iswap_int(nchunk)
-      lenfmt = iswap_int(lenfmt)
-      nfmt2 = iswap_short(nfmt2)
-      nchan2 = iswap_short(nchan2)
-      nsamrate = iswap_int(nsamrate)
-      nbytesec = iswap_int(nbytesec)
-      nbytesam2 = iswap_short(nbytesam2)
-      nbitsam2 = iswap_short(nbitsam2)
-      ndata = iswap_int(ndata)
-
-      return
-      end subroutine change_endian
-
-      integer function iswap_int(idat)
-
-      itemp1 = ior(ishft(idat,24), iand(ishft(idat,8), z'00ff0000'))
-      itemp0 = ior(iand(ishft(idat,-8), z'0000ff00'), 
-     +             iand(ishft(idat,-24),z'000000ff'))
-      iswap_int = ior(itemp1,itemp0)
-      
-      end function iswap_int
-
-      integer*2 function iswap_short(idat)
-
-      integer*2 idat,m2
-      data m2/255/
-
-      iswap_short = ior(ishft(idat,8), iand(ishft(idat,-8), m2))
-
-      end function iswap_short
-

Added: branches/wspr/wfile5.f
===================================================================
--- branches/wspr/wfile5.f	                        (rev 0)
+++ branches/wspr/wfile5.f	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,89 @@
+      subroutine wfile5(iwave,nmax,nfsample,outfile)
+
+C  Write a wavefile to disk.
+
+      integer*1 n4 
+      integer*2 iwave(nmax)
+      character*80 outfile
+
+      integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+      character*4 ariff,awave,afmt,adata
+      integer*1 hdr(44)
+      integer*2 iswap_short
+      common/hdr/ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,
+     +     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata
+      equivalence (hdr,ariff),(nfmt2,n4)
+
+C  Generate the header
+      ariff='RIFF'
+      awave='WAVE'
+      afmt='fmt '
+      adata='data'
+      lenfmt=16                             !Rest of this sub-chunk is 16 bytes long
+      nfmt2=1                               !PCM = 1
+      nchan2=1                              !1=mono, 2=stereo
+      nbitsam2=16                           !Bits per sample
+      nsamrate=nfsample
+      nbytesec=nfsample*nchan2*nbitsam2/8   !Bytes per second
+      nbytesam2=nchan2*nbitsam2/8           !Block-align               
+      ndata=nmax*nchan2*nbitsam2/8
+      nbytes=ndata+44
+      nchunk=nbytes-8
+
+      call cs_lock('wfile5')
+      open(12,file=outfile,access='stream',status='unknown')
+      if (n4.ne.nfmt2) then
+        call change_endian                  !Change hdr to little-endian
+        do i=1,nmax
+            iwave(i) = iswap_short(iwave(i))!Change data to little-endian
+        enddo
+      endif
+      write(12) hdr
+      write(12) iwave
+      close(12)
+      call cs_unlock
+
+      return
+      end
+
+      subroutine change_endian
+
+      integer*1 hdr(44)
+      integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+      integer*2 iswap_short
+      character*4 ariff,awave,afmt,adata
+      common/hdr/ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2, 
+     +       nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata
+      equivalence (ariff,hdr)
+
+      nchunk = iswap_int(nchunk)
+      lenfmt = iswap_int(lenfmt)
+      nfmt2 = iswap_short(nfmt2)
+      nchan2 = iswap_short(nchan2)
+      nsamrate = iswap_int(nsamrate)
+      nbytesec = iswap_int(nbytesec)
+      nbytesam2 = iswap_short(nbytesam2)
+      nbitsam2 = iswap_short(nbitsam2)
+      ndata = iswap_int(ndata)
+
+      return
+      end subroutine change_endian
+
+      integer function iswap_int(idat)
+
+      itemp1 = ior(ishft(idat,24), iand(ishft(idat,8), z'00ff0000'))
+      itemp0 = ior(iand(ishft(idat,-8), z'0000ff00'), 
+     +             iand(ishft(idat,-24),z'000000ff'))
+      iswap_int = ior(itemp1,itemp0)
+      
+      end function iswap_int
+
+      integer*2 function iswap_short(idat)
+
+      integer*2 idat,m2
+      data m2/255/
+
+      iswap_short = ior(ishft(idat,8), iand(ishft(idat,-8), m2))
+
+      end function iswap_short
+


Property changes on: branches/wspr/wfile5.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/wspr/wspr.py
===================================================================
--- branches/wspr/wspr.py	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/wspr.py	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,4 +1,4 @@
-#------------------------------------------------------------------- WSPR
+#------------------------------------------------------------------ WSPR
 # $Date: 2008-03-17 08:29:04 -0400 (Mon, 17 Mar 2008) $ $Revision$
 #
 from Tkinter import *

Deleted: branches/wspr/wspr1.F90
===================================================================
--- branches/wspr/wspr1.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/wspr1.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,44 +0,0 @@
-subroutine wspr1
-
-#ifdef CVF
-  use dfmt
-  integer Thread0
-  external wspr2
-#else
-  integer th_wspr2
-#endif
-
-  include 'acom1.f90'
-
-#ifdef CVF
-!  Priority classes (for processes):
-!     IDLE_PRIORITY_CLASS               64
-!     NORMAL_PRIORITY_CLASS             32
-!     HIGH_PRIORITY_CLASS              128
-
-!  Priority definitions (for threads):
-!     THREAD_PRIORITY_IDLE             -15
-!     THREAD_PRIORITY_LOWEST            -2
-!     THREAD_PRIORITY_BELOW_NORMAL      -1
-!     THREAD_PRIORITY_NORMAL             0
-!     THREAD_PRIORITY_ABOVE_NORMAL       1
-!     THREAD_PRIORITY_HIGHEST            2
-!     THREAD_PRIORITY_TIME_CRITICAL     15
-
-  nrxdone=0
-  m0=SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS)
-! Start a thread for acquiring audio data
-  Thread0=CreateThread(0,0,wspr2,0,CREATE_SUSPENDED,id0)
-  m1=SetThreadPriority(Thread0,THREAD_PRIORITY_NORMAL)
-  m2=ResumeThread(Thread0)
-#else
-! Start a thread for acquiring audio data
-  ierr=th_wspr2()
-  if(ierr.ne.0) then
-     print*,'Error creating thread for wspr2',ierr
-     stop
-  endif
-#endif
-
-  return
-end subroutine wspr1

Added: branches/wspr/wspr1.f90
===================================================================
--- branches/wspr/wspr1.f90	                        (rev 0)
+++ branches/wspr/wspr1.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,15 @@
+subroutine wspr1
+
+  integer th_wspr2
+
+  include 'acom1.f90'
+
+! Start a thread for acquiring audio data
+  ierr=th_wspr2()
+  if(ierr.ne.0) then
+     print*,'Error creating thread for wspr2',ierr
+     stop
+  endif
+
+  return
+end subroutine wspr1


Property changes on: branches/wspr/wspr1.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: branches/wspr/wspr2.F90
===================================================================
--- branches/wspr/wspr2.F90	2010-09-13 18:36:11 UTC (rev 2142)
+++ branches/wspr/wspr2.F90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -1,155 +0,0 @@
-subroutine wspr2
-
-#ifdef CVF
-  use dfport
-#endif
-
-! Logical units:
-!  12  Audio data in *.wav file
-!  13  ALL_WSPR.TXT
-!  14  decoded.txt
-!  16  pixmap.dat
-!  17  audio_caps
-!  18  test.snr
-
-  character message*24,cdbm*4
-  real*8 tsec
-  include 'acom1.f90'
-  character linetx*51,dectxt*80
-  integer nt(9)
-  common/acom2/ntune2,linetx
-  common/patience/npatience
-  data receiving/.false./,transmitting/.false./
-  data ns1200/-999/,nrxnormal/0/
-
-  call cs_init
-  dectxt=appdir(:nappdir)//'/decoded.txt'
-
-  call cs_lock('wspr2')
-#ifdef CVF
-  open(14,file=dectxt,status='unknown',share='denynone')
-#else
-  open(14,file=dectxt,status='unknown')
-#endif
-  write(14,1002)
-1002 format('$EOF')
-  call flush(14)
-  rewind 14
-  call cs_unlock
-
-  npatience=1
-  call random_seed
-  nrx=1
-
-20 call cs_lock('wspr2')
-  call getutc(cdate,utctime,tsec)
-  nsec=tsec
-  ns120=mod(nsec,120)
-  rxavg=1.0
-  if(pctx.gt.0.0) rxavg=100.0/pctx - 1.0
-  call cs_unlock
-
-  if(nrxdone.gt.0) then
-
-     call cs_lock('wspr2')
-     receiving=.false.
-     nrxdone=0
-     ndecoding=1
-     thisfile=outfile
-     call cs_unlock
-
-     if((nrxnormal.eq.1 .and. ncal.eq.0) .or.                          &amp;
-        (nrxnormal.eq.0 .and. ncal.eq.2) .or.                          &amp;
-        ndiskdat.eq.1) then
-        call startdec
-     endif
-  endif
-
-  call cs_lock('wspr2')
-  if(ntxdone.gt.0) then
-     transmitting=.false.
-     ntxdone=0
-     ntr=0
-  endif
-  if(ns120.ge.114 .and. ntune.eq.0) then
-     transmitting=.false.
-     receiving=.false.
-     ntr=0
-  endif
-  if(pctx.lt.1.0) ntune=0
-  call cs_unlock
-
-  if (ntune.eq.1 .and. ndevsok.eq.1.and. (.not.transmitting) .and.   &amp;
-       (.not.receiving) .and. pctx.ge.1.0) then
-
-! Test transmission of length pctx seconds.
-     call cs_lock('wspr2')
-     nsectx=mod(nsec,86400)
-     ntune2=ntune
-     transmitting=.true.
-     call cs_unlock
-
-     call starttx
-  endif
-
-  if (ncal.eq.1 .and. ndevsok.eq.1.and. (.not.transmitting) .and.   &amp;
-       (.not.receiving)) then
-
-! Execute one receive sequence
-     call cs_lock('wspr2')
-     receiving=.true.
-     rxtime=utctime(1:4)
-     nrxnormal=0
-     call cs_unlock
-
-     call startrx
-  endif
-
-  if(ns120.eq.0 .and. (.not.transmitting) .and. (.not.receiving) .and. &amp;
-       (idle.eq.0)) go to 30
-
-  call chklevel
-  call msleep(200)
-  go to 20
-
-30 outfile=cdate(3:8)//'_'//utctime(1:4)//'.'//'wav'
-  if(pctx.eq.0.0) nrx=1
-
-  if(nrx.eq.0 .and. ntr.ne.-1) then
-
-     call cs_lock('wspr2')
-     transmitting=.true.
-     call random_number(x)
-     if(pctx.lt.50.0) then
-        nrx=nint(rxavg + 3.0*(x-0.5))
-     else
-        nrx=0
-        if(x.lt.rxavg) nrx=1
-     endif
-     write(cdbm,'(i4)') ndbm
-     message=callsign//grid//cdbm
-     call msgtrim(message,msglen)
-     write(linetx,1030) cdate(3:8),utctime(1:4),ftx
-1030 format(a6,1x,a4,14x,f11.6,2x,'Transmitting ')
-     ntr=-1
-     nsectx=mod(nsec,86400)
-     ntxdone=0
-     call cs_unlock
-
-     call gmtime2(nt,tsec0)
-     if(ndevsok.eq.1) call starttx
-
-  else
-     receiving=.true.
-     rxtime=utctime(1:4)
-     ntr=1
-     if(ndevsok.eq.1) then
-        nrxnormal=1
-        call startrx
-     endif
-     nrx=nrx-1
-  endif
-  go to 20
-
-  return
-end subroutine wspr2

Added: branches/wspr/wspr2.f90
===================================================================
--- branches/wspr/wspr2.f90	                        (rev 0)
+++ branches/wspr/wspr2.f90	2010-09-13 18:59:08 UTC (rev 2143)
@@ -0,0 +1,147 @@
+subroutine wspr2
+
+! Logical units:
+!  12  Audio data in *.wav file
+!  13  ALL_WSPR.TXT
+!  14  decoded.txt
+!  16  pixmap.dat
+!  17  audio_caps
+!  18  test.snr
+
+  character message*24,cdbm*4
+  real*8 tsec
+  include 'acom1.f90'
+  character linetx*51,dectxt*80
+  integer nt(9)
+  common/acom2/ntune2,linetx
+  common/patience/npatience
+  data receiving/.false./,transmitting/.false./
+  data ns1200/-999/,nrxnormal/0/
+
+  call cs_init
+  dectxt=appdir(:nappdir)//'/decoded.txt'
+
+  call cs_lock('wspr2')
+  open(14,file=dectxt,status='unknown')
+  write(14,1002)
+1002 format('$EOF')
+  call flush(14)
+  rewind 14
+  call cs_unlock
+
+  npatience=1
+  call random_seed
+  nrx=1
+
+20 call cs_lock('wspr2')
+  call getutc(cdate,utctime,tsec)
+  nsec=tsec
+  ns120=mod(nsec,120)
+  rxavg=1.0
+  if(pctx.gt.0.0) rxavg=100.0/pctx - 1.0
+  call cs_unlock
+
+  if(nrxdone.gt.0) then
+
+     call cs_lock('wspr2')
+     receiving=.false.
+     nrxdone=0
+     ndecoding=1
+     thisfile=outfile
+     call cs_unlock
+
+     if((nrxnormal.eq.1 .and. ncal.eq.0) .or.                          &amp;
+        (nrxnormal.eq.0 .and. ncal.eq.2) .or.                          &amp;
+        ndiskdat.eq.1) then
+        call startdec
+     endif
+  endif
+
+  call cs_lock('wspr2')
+  if(ntxdone.gt.0) then
+     transmitting=.false.
+     ntxdone=0
+     ntr=0
+  endif
+  if(ns120.ge.114 .and. ntune.eq.0) then
+     transmitting=.false.
+     receiving=.false.
+     ntr=0
+  endif
+  if(pctx.lt.1.0) ntune=0
+  call cs_unlock
+
+  if (ntune.eq.1 .and. ndevsok.eq.1.and. (.not.transmitting) .and.   &amp;
+       (.not.receiving) .and. pctx.ge.1.0) then
+
+! Test transmission of length pctx seconds.
+     call cs_lock('wspr2')
+     nsectx=mod(nsec,86400)
+     ntune2=ntune
+     transmitting=.true.
+     call cs_unlock
+
+     call starttx
+  endif
+
+  if (ncal.eq.1 .and. ndevsok.eq.1.and. (.not.transmitting) .and.   &amp;
+       (.not.receiving)) then
+
+! Execute one receive sequence
+     call cs_lock('wspr2')
+     receiving=.true.
+     rxtime=utctime(1:4)
+     nrxnormal=0
+     call cs_unlock
+
+     call startrx
+  endif
+
+  if(ns120.eq.0 .and. (.not.transmitting) .and. (.not.receiving) .and. &amp;
+       (idle.eq.0)) go to 30
+
+  call chklevel
+  call msleep(200)
+  go to 20
+
+30 outfile=cdate(3:8)//'_'//utctime(1:4)//'.'//'wav'
+  if(pctx.eq.0.0) nrx=1
+
+  if(nrx.eq.0 .and. ntr.ne.-1) then
+
+     call cs_lock('wspr2')
+     transmitting=.true.
+     call random_number(x)
+     if(pctx.lt.50.0) then
+        nrx=nint(rxavg + 3.0*(x-0.5))
+     else
+        nrx=0
+        if(x.lt.rxavg) nrx=1
+     endif
+     write(cdbm,'(i4)') ndbm
+     message=callsign//grid//cdbm
+     call msgtrim(message,msglen)
+     write(linetx,1030) cdate(3:8),utctime(1:4),ftx
+1030 format(a6,1x,a4,14x,f11.6,2x,'Transmitting ')
+     ntr=-1
+     nsectx=mod(nsec,86400)
+     ntxdone=0
+     call cs_unlock
+
+     call gmtime2(nt,tsec0)
+     if(ndevsok.eq.1) call starttx
+
+  else
+     receiving=.true.
+     rxtime=utctime(1:4)
+     ntr=1
+     if(ndevsok.eq.1) then
+        nrxnormal=1
+        call startrx
+     endif
+     nrx=nrx-1
+  endif
+  go to 20
+
+  return
+end subroutine wspr2


Property changes on: branches/wspr/wspr2.f90
___________________________________________________________________
Added: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001834.html">[WSJT-SVN] r2142 - in branches/wspr: . DEB/DEBIAN WsprMod
</A></li>
	<LI>Next message: <A HREF="001836.html">[WSJT-SVN] r2144 - branches/wspr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1835">[ date ]</a>
              <a href="thread.html#1835">[ thread ]</a>
              <a href="subject.html#1835">[ subject ]</a>
              <a href="author.html#1835">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
