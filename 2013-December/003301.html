<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r3607 - in branches/wsjtx_w: . lib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2013-December/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r3607%20-%20in%20branches/wsjtx_w%3A%20.%20lib&In-Reply-To=%3C20131220175510.F1BD755B10%40scm.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003299.html">
   <LINK REL="Next"  HREF="003300.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r3607 - in branches/wsjtx_w: . lib</H1>
    <B>k1jt at scm.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r3607%20-%20in%20branches/wsjtx_w%3A%20.%20lib&In-Reply-To=%3C20131220175510.F1BD755B10%40scm.berlios.de%3E"
       TITLE="[WSJT-SVN] r3607 - in branches/wsjtx_w: . lib">k1jt at scm.berlios.de
       </A><BR>
    <I>Fri Dec 20 18:55:10 CET 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="003299.html">[WSJT-SVN] r3606 - in branches/wsjtx_w: . lib
</A></li>
        <LI>Next message: <A HREF="003300.html">[WSJT-SVN] r3608 - in branches/wsjtx_w: . lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3301">[ date ]</a>
              <a href="thread.html#3301">[ thread ]</a>
              <a href="subject.html#3301">[ subject ]</a>
              <a href="author.html#3301">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2013-12-20 18:55:10 +0100 (Fri, 20 Dec 2013)
New Revision: 3607

Added:
   branches/wsjtx_w/lib/astro.f90
   branches/wsjtx_w/lib/astro0.f90
   branches/wsjtx_w/lib/astrosub.f90
   branches/wsjtx_w/lib/coord.f90
   branches/wsjtx_w/lib/dcoord.f90
   branches/wsjtx_w/lib/dot.f90
   branches/wsjtx_w/lib/geocentric.f90
   branches/wsjtx_w/lib/moon2.f90
   branches/wsjtx_w/lib/moondop.f90
   branches/wsjtx_w/lib/sun.f90
   branches/wsjtx_w/lib/tm2.f90
   branches/wsjtx_w/lib/tmoonsub.c
   branches/wsjtx_w/lib/toxyz.f90
Modified:
   branches/wsjtx_w/Modulator.cpp
   branches/wsjtx_w/Modulator.hpp
   branches/wsjtx_w/lib/Makefile.MinGW
   branches/wsjtx_w/lib/decoder.f90
   branches/wsjtx_w/mainwindow.cpp
   branches/wsjtx_w/mainwindow.h
   branches/wsjtx_w/mainwindow.ui
   branches/wsjtx_w/wsjtx.pro
Log:
Added the Astro Data window.


Modified: branches/wsjtx_w/Modulator.cpp
===================================================================
--- branches/wsjtx_w/Modulator.cpp	2013-12-19 15:39:38 UTC (rev 3606)
+++ branches/wsjtx_w/Modulator.cpp	2013-12-20 17:55:10 UTC (rev 3607)
@@ -77,6 +77,10 @@
 
 qint64 Modulator::readData (char * data, qint64 maxSize)
 {
+  static int j0=-1;
+  static double toneFrequency0;
+  double toneFrequency;
+
   Q_ASSERT (!(maxSize % static_cast&lt;qint64&gt; (bytesPerFrame ()))); // no torn frames
   Q_ASSERT (isOpen ());
 
@@ -162,16 +166,24 @@
     for (unsigned i = 0; i &lt; numFrames; ++i) {
       isym = m_tuning ? 0 : m_ic / (4.0 * m_nsps); //Actual fsample=48000
       if (isym != m_isym0) {
-        double toneFrequency = m_frequency + itone[isym] * baud;
-        int nfspread=0;
-        if(nfspread&gt;0) {
-          float x1=(float)rand()/RAND_MAX;
-          float x2=(float)rand()/RAND_MAX;
-          toneFrequency += nfspread*(x1+x2-1.0);
+        if(m_toneSpacing==0.0) {
+          toneFrequency0=m_frequency + itone[isym]*baud;
+        } else {
+          toneFrequency0=m_frequency + itone[isym]*m_toneSpacing;
         }
-        m_dphi = m_twoPi * toneFrequency / m_frameRate;
+        m_dphi = m_twoPi * toneFrequency0 / m_frameRate;
         m_isym0 = isym;
       }
+
+      int j=m_ic/480;
+      if(m_fSpread&gt;0.0 and j!=j0) {
+        float x1=(float)rand()/RAND_MAX;
+        float x2=(float)rand()/RAND_MAX;
+        toneFrequency = toneFrequency0 + 0.5*m_fSpread*(x1+x2-1.0);
+        m_dphi = m_twoPi * toneFrequency / m_frameRate;
+        j0=j;
+      }
+
       m_phi += m_dphi;
       if (m_phi &gt; m_twoPi) m_phi -= m_twoPi;
       if (m_ic &gt; i0) m_amp = 0.98 * m_amp;

Modified: branches/wsjtx_w/Modulator.hpp
===================================================================
--- branches/wsjtx_w/Modulator.hpp	2013-12-19 15:39:38 UTC (rev 3606)
+++ branches/wsjtx_w/Modulator.hpp	2013-12-20 17:55:10 UTC (rev 3607)
@@ -35,6 +35,7 @@
   bool isMuted () const {return m_muted;}
   unsigned frequency () const {return m_frequency;}
   bool isActive () const {return m_state != Idle;}
+  void setWide9(double d1, double d2) {m_toneSpacing=d1; m_fSpread=d2;}
 
 protected:
   qint64 readData (char * data, qint64 maxSize);
@@ -66,22 +67,28 @@
   static double const m_twoPi;
   static unsigned const m_nspd;	// CW ID WPM factor
 
-  int m_frameRate;
-  int m_period;
+  double m_phi;
+  double m_dphi;
+  double m_amp;
   double m_nsps;
   double volatile m_frequency;
   double m_snr;
+  double m_fac;
+  double m_toneSpacing;
+  double m_fSpread;
+
   qint64 m_silentFrames;
   qint64 m_framesSent;
+
+  int m_frameRate;
+  int m_period;
   ModulatorState volatile m_state;
+
   bool volatile m_tuning;
   bool volatile m_muted;
   bool m_addNoise;
-  double m_phi;
-  double m_dphi;
-  double m_amp;
+
   unsigned m_ic;
-  double m_fac;
   unsigned m_isym0;
   qint16 m_ramp;
 };

Modified: branches/wsjtx_w/lib/Makefile.MinGW
===================================================================
--- branches/wsjtx_w/lib/Makefile.MinGW	2013-12-19 15:39:38 UTC (rev 3606)
+++ branches/wsjtx_w/lib/Makefile.MinGW	2013-12-20 17:55:10 UTC (rev 3607)
@@ -32,7 +32,7 @@
 %.o: %.F90
 	${FC} ${FFLAGS} -c $&lt;
 
-all:    libjt9.a jt9sim.exe jt9.exe jt9code.exe jt65.exe
+all:    libjt9.a libastro.a jt9sim.exe jt9.exe jt9code.exe jt65.exe
 
 OBJS1 = pctile.o graycode.o sort.o ssort.o \
 	unpackmsg.o igray.o unpackcall.o unpackgrid.o \
@@ -50,7 +50,8 @@
 	filbig.o fil6521.o afc65b.o decode65b.o setup65.o \
 	extract.o fchisq65.o demod64a.o chkhist.o interleave63.o ccf2.o \
 	move.o indexx.o graycode65.o twkfreq65.o smo121.o \
-	wrapkarn.o init_rs.o encode_rs.o decode_rs.o gen65.o fil4.o
+	wrapkarn.o init_rs.o encode_rs.o decode_rs.o gen65.o fil4.o \
+	flat1.o smo.o
 
 libjt9.a: $(OBJS1)
 	ar cr libjt9.a $(OBJS1) 
@@ -76,6 +77,15 @@
 jt65.exe: $(OBJS5) libjt9.a 
 	$(FC) -o jt65.exe $(OBJS5) libjt9.a ../libfftw3f_win.a
 
+OBJS6 = astrosub.o astro0.o astro.o tm2.o grid2deg.o sun.o moondop.o \
+	coord.o dot.o moon2.o tmoonsub.o toxyz.o geocentric.o \
+	dcoord.o
+
+libastro.a: $(OBJS6)
+	ar cr libastro.a $(OBJS6)
+	ranlib libastro.a
+
+
 sync9.o: sync9.f90 jt9sync.f90
 	$(FC) $(FFLAGS) -c sync9.f90
 

Added: branches/wsjtx_w/lib/astro.f90
===================================================================
--- branches/wsjtx_w/lib/astro.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/astro.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,108 @@
+subroutine astro(nyear,month,nday,uth,nfreq,Mygrid,                    &amp;
+          NStation,MoonDX,AzSun,ElSun,AzMoon0,ElMoon0,                 &amp;
+          ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,    &amp;
+          poloffset,xnr,day,lon,lat,LST)
+
+! Computes astronomical quantities for display and tracking.
+! NB: may want to smooth the Tsky map to 10 degrees or so.
+
+  character*6 MyGrid,HisGrid
+  real LST
+  real lat,lon
+  integer*2 nt144(180)
+
+!      common/echo/xdop(2),techo,AzMoon,ElMoon,mjd
+  real xdop(2)
+
+  data rad/57.2957795/
+  data nt144/                                             &amp;
+       234, 246, 257, 267, 275, 280, 283, 286, 291, 298,  &amp;
+       305, 313, 322, 331, 341, 351, 361, 369, 376, 381,  &amp;
+       383, 382, 379, 374, 370, 366, 363, 361, 363, 368,  &amp;
+       376, 388, 401, 415, 428, 440, 453, 467, 487, 512,  &amp;
+       544, 579, 607, 618, 609, 588, 563, 539, 512, 482,  &amp;
+       450, 422, 398, 379, 363, 349, 334, 319, 302, 282,  &amp;
+       262, 242, 226, 213, 205, 200, 198, 197, 196, 197,  &amp;
+       200, 202, 204, 205, 204, 203, 202, 201, 203, 206,  &amp;
+       212, 218, 223, 227, 231, 236, 240, 243, 247, 257,  &amp;
+       276, 301, 324, 339, 346, 344, 339, 331, 323, 316,  &amp;
+       312, 310, 312, 317, 327, 341, 358, 375, 392, 407,  &amp;
+       422, 437, 451, 466, 480, 494, 511, 530, 552, 579,  &amp;
+       612, 653, 702, 768, 863,1008,1232,1557,1966,2385,  &amp;
+      2719,2924,3018,3038,2986,2836,2570,2213,1823,1461,  &amp;
+      1163, 939, 783, 677, 602, 543, 494, 452, 419, 392,  &amp;
+       373, 360, 353, 350, 350, 350, 350, 350, 350, 348,  &amp;
+       344, 337, 329, 319, 307, 295, 284, 276, 272, 272,  &amp;
+       273, 274, 274, 271, 266, 260, 252, 245, 238, 231/
+  save
+
+  call grid2deg(MyGrid,elon,lat)
+  lon=-elon
+  call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,      &amp;
+       AzSun,ElSun,mjd,day)
+
+  freq=nfreq*1.e6
+  if(nfreq.eq.2) freq=1.8e6
+  if(nfreq.eq.4) freq=3.5e6
+
+  call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,    &amp;
+       LST,HA,AzMoon,ElMoon,vr,dist)
+
+! Compute spatial polarization offset
+  xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*              &amp;
+       cos(AzMoon/rad)*sin(ElMoon/rad)
+  yy=cos(lat/rad)*sin(AzMoon/rad)
+  if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
+  if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
+
+  techo=2.0 * dist/2.99792458e5                 !Echo delay time
+  doppler=-freq*vr/2.99792458e5                 !One-way Doppler
+
+  call coord(0.,0.,-1.570796,1.161639,RAMoon/rad,DecMoon/rad,el,eb)
+  longecl_half=nint(rad*el/2.0)
+  if(longecl_half.lt.1 .or. longecl_half.gt.180) longecl_half=180
+  t144=nt144(longecl_half)
+  tsky=(t144-2.7)*(144.0/nfreq)**2.6 + 2.7      !Tsky for obs freq
+
+  xdop(NStation)=doppler
+  if(NStation.eq.2) then
+     HisGrid=MyGrid
+     go to 900
+  endif
+
+  doppler00=2.0*xdop(1)
+  doppler=xdop(1)+xdop(2)
+!      if(mode.eq.3) doppler=2.0*xdop(1)
+  dBMoon=-40.0*log10(dist/356903.)
+  sd=16.23*370152.0/dist
+
+!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
+!     +    (mode.eq.2 .or. mode.eq.5)) then
+  if(NStation.eq.1 .and. MoonDX.ne.0) then
+     poloffset=mod(poloffset2-poloffset1+720.0,180.0)
+     if(poloffset.gt.90.0) poloffset=poloffset-180.0
+     x1=abs(cos(2*poloffset/rad))
+     if(x1.lt.0.056234) x1=0.056234
+     xnr=-20.0*log10(x1)
+     if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'R') xnr=0
+  endif
+
+  tr=80.0                              !Good preamp
+  tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
+  tsysmin=tskymin+tr
+  tsys=tsky+tr
+  dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
+900 AzMoon0=Azmoon
+  ElMoon0=Elmoon
+  ntsky=nint(tsky)
+
+!      auxHA = 15.0*(LST-auxra)                       !HA in degrees
+!      pi=3.14159265
+!      pio2=0.5*pi
+!      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
+!     +  auxdec/rad,azaux,elaux)
+!      AzAux=azaux*rad
+!      ElAux=ElAux*rad
+
+  return
+end subroutine astro

Added: branches/wsjtx_w/lib/astro0.f90
===================================================================
--- branches/wsjtx_w/lib/astro0.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/astro0.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,81 @@
+subroutine astro0(nyear,month,nday,uth8,nfreq,mygrid,hisgrid,              &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,    &amp;
+     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,    &amp;
+     width1,width2,w501,w502,xlst8)
+
+  parameter (DEGS=57.2957795130823d0)
+  character*6 mygrid,hisgrid
+  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8
+  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0,dt
+  real*8 sd8,poloffset8,day8,width1,width2,w501,w502,xlst8
+  real*8 uth8
+  data uth8z/0.d0/
+  save
+
+  uth=uth8
+  call astro(nyear,month,nday,uth,nfreq,hisgrid,2,1,                 &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,               &amp;
+       day,xlon2,xlat2,xlst)
+  AzMoonB8=AzMoon
+  ElMoonB8=ElMoon
+  call astro(nyear,month,nday,uth,nfreq,mygrid,1,1,                  &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,               &amp;
+       day,xlon1,xlat1,xlst)
+
+  day8=day
+  xlst8=xlst
+  call tm2(day8,xlat1,xlon1,xl1,b1)
+  call tm2(day8,xlat2,xlon2,xl2,b2)
+  call tm2(day8+1.d0/1440.0,xlat1,xlon1,xl1a,b1a)
+  call tm2(day8+1.d0/1440.0,xlat2,xlon2,xl2a,b2a)
+  fghz=0.001*nfreq
+  dldt1=DEGS*(xl1a-xl1)
+  dbdt1=DEGS*(b1a-b1)
+  dldt2=DEGS*(xl2a-xl2)
+  dbdt2=DEGS*(b2a-b2)
+  rate1=2.0*sqrt(dldt1**2 + dbdt1**2)
+  width1=0.5*6741*fghz*rate1
+  rate2=sqrt((dldt1+dldt2)**2 + (dbdt1+dbdt2)**2)
+  width2=0.5*6741*fghz*rate2
+
+  fbend=0.7
+  a2=0.0045*log(fghz/fbend)/log(1.05)
+  if(fghz.lt.fbend) a2=0.0
+  f50=0.19 * (fghz/fbend)**a2
+  if(f50.gt.1.0) f50=1.0
+  w501=f50*width1
+  w502=f50*width2
+
+  AzSun8=AzSun
+  ElSun8=ElSun
+  AzMoon8=AzMoon
+  ElMoon8=ElMoon
+  dbMoon8=dbMoon
+  RAMoon8=RAMoon/15.0
+  DecMoon8=DecMoon
+  HA8=HA
+  Dgrd8=Dgrd
+  sd8=sd
+  poloffset8=poloffset
+  xnr8=xnr
+  ndop=nint(doppler)
+  ndop00=nint(doppler00)
+
+  if(uth8z.eq.0.d0) then
+     uth8z=uth8-1.d0/3600.d0
+     dopplerz=doppler
+     doppler00z=doppler00
+  endif
+     
+  dt=60.0*(uth8-uth8z)
+  if(dt.le.0) dt=1.d0/60.d0
+  dfdt=(doppler-dopplerz)/dt
+  dfdt0=(doppler00-doppler00z)/dt
+  uth8z=uth8
+  dopplerz=doppler
+  doppler00z=doppler00
+
+  return
+end subroutine astro0

Added: branches/wsjtx_w/lib/astrosub.f90
===================================================================
--- branches/wsjtx_w/lib/astrosub.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/astrosub.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,14 @@
+subroutine astrosub(nyear,month,nday,uth8,nfreq,mygrid,hisgrid,          &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
+     RAMoon8,DecMoon8,Dgrd8,poloffset8,xnr8)
+
+  implicit real*8 (a-h,o-z)
+  character*6 mygrid,hisgrid
+
+  call astro0(nyear,month,nday,uth8,nfreq,mygrid,hisgrid,                &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
+     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
+     width1,width2,w501,w502,xlst8)
+
+  return  
+end subroutine astrosub

Added: branches/wsjtx_w/lib/coord.f90
===================================================================
--- branches/wsjtx_w/lib/coord.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/coord.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,41 @@
+SUBROUTINE COORD(A0,B0,AP,BP,A1,B1,A2,B2)
+
+! Examples:
+! 1. From ha,dec to az,el:
+!      call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
+! 2. From az,el to ha,dec:
+!      call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
+! 3. From ra,dec to l,b
+!      call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
+!        ra,dec,l,b)
+! 4. From l,b to ra,dec
+!      call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
+!        0.478220215d0,l,b,ra,dec)
+! 5. From ra,dec to ecliptic latitude (eb) and longitude (el):
+!      call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
+! 6. From ecliptic latitude (eb) and longitude (el) to ra,dec:
+!      call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,el,eb,ra,dec)
+
+  SB0=sin(B0)
+  CB0=cos(B0)
+  SBP=sin(BP)
+  CBP=cos(BP)
+  SB1=sin(B1)
+  CB1=cos(B1)
+  SB2=SBP*SB1 + CBP*CB1*cos(AP-A1)
+  CB2=SQRT(1.e0-SB2**2)
+  B2=atan(SB2/CB2)
+  SAA=sin(AP-A1)*CB1/CB2
+  CAA=(SB1-SB2*SBP)/(CB2*CBP)
+  CBB=SB0/CBP
+  SBB=sin(AP-A0)*CB0
+  SA2=SAA*CBB-CAA*SBB
+  CA2=CAA*CBB+SAA*SBB
+  TA2O2=0.0 !Shut up compiler warnings. -db
+  IF(CA2.LE.0.e0) TA2O2=(1.e0-CA2)/SA2 
+  IF(CA2.GT.0.e0) TA2O2=SA2/(1.e0+CA2)
+  A2=2.e0*atan(TA2O2)
+  IF(A2.LT.0.e0) A2=A2+6.2831853
+
+  RETURN
+END SUBROUTINE COORD

Added: branches/wsjtx_w/lib/dcoord.f90
===================================================================
--- branches/wsjtx_w/lib/dcoord.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/dcoord.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,40 @@
+SUBROUTINE DCOORD(A0,B0,AP,BP,A1,B1,A2,B2)
+
+  implicit real*8 (a-h,o-z)
+! Examples:
+! 1. From ha,dec to az,el:
+!      call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
+! 2. From az,el to ha,dec:
+!      call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
+! 3. From ra,dec to l,b
+!      call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
+!        ra,dec,l,b)
+! 4. From l,b to ra,dec
+!      call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
+!        0.478220215d0,l,b,ra,dec)
+! 5. From ecliptic latitude (eb) and longitude (el) to ra, dec:
+!      call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
+
+  SB0=sin(B0)
+  CB0=cos(B0)
+  SBP=sin(BP)
+  CBP=cos(BP)
+  SB1=sin(B1)
+  CB1=cos(B1)
+  SB2=SBP*SB1 + CBP*CB1*cos(AP-A1)
+  CB2=SQRT(1.D0-SB2**2)
+  B2=atan(SB2/CB2)
+  SAA=sin(AP-A1)*CB1/CB2
+  CAA=(SB1-SB2*SBP)/(CB2*CBP)
+  CBB=SB0/CBP
+  SBB=sin(AP-A0)*CB0
+  SA2=SAA*CBB-CAA*SBB
+  CA2=CAA*CBB+SAA*SBB
+  TA2O2=0.0 !Shut up compiler warnings. -db
+  IF(CA2.LE.0.D0) TA2O2=(1.D0-CA2)/SA2 
+  IF(CA2.GT.0.D0) TA2O2=SA2/(1.D0+CA2)
+  A2=2.D0*atan(TA2O2)
+  IF(A2.LT.0.D0) A2=A2+6.2831853071795864D0
+  
+  RETURN
+END SUBROUTINE DCOORD

Modified: branches/wsjtx_w/lib/decoder.f90
===================================================================
--- branches/wsjtx_w/lib/decoder.f90	2013-12-19 15:39:38 UTC (rev 3606)
+++ branches/wsjtx_w/lib/decoder.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -31,7 +31,7 @@
   npts65=52*12000
   ntol65=20
   done65=.false.
-  if(nmode.ge.65 .and. ntxmode.eq.65) then
+  if((nmode.eq.65 .or. nmode.eq.65+9) .and. ntxmode.eq.65) then
      if(newdat.ne.0) dd(1:npts65)=id2(1:npts65)
      nf1=nfa
      nf2=nfb

Added: branches/wsjtx_w/lib/dot.f90
===================================================================
--- branches/wsjtx_w/lib/dot.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/dot.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,11 @@
+real*8 function dot(x,y)
+
+  real*8 x(3),y(3)
+
+  dot=0.d0
+  do i=1,3
+     dot=dot+x(i)*y(i)
+  enddo
+
+  return
+end function dot

Added: branches/wsjtx_w/lib/geocentric.f90
===================================================================
--- branches/wsjtx_w/lib/geocentric.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/geocentric.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,17 @@
+subroutine geocentric(alat,elev,hlt,erad)
+
+  implicit real*8 (a-h,o-z)
+
+! IAU 1976 flattening f, equatorial radius a
+  f = 1.d0/298.257d0
+  a = 6378140.d0
+  c = 1.d0/sqrt(1.d0 + (-2.d0 + f)*f*sin(alat)*sin(alat))
+  arcf = (a*c + elev)*cos(alat)
+  arsf = (a*(1.d0 - f)*(1.d0 - f)*c + elev)*sin(alat)
+  hlt = datan2(arsf,arcf)
+  erad = sqrt(arcf*arcf + arsf*arsf)
+  erad = 0.001d0*erad
+
+  return
+end subroutine geocentric
+

Added: branches/wsjtx_w/lib/moon2.f90
===================================================================
--- branches/wsjtx_w/lib/moon2.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/moon2.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,166 @@
+subroutine moon2(y,m,Day,UT,lon,lat,RA,Dec,topRA,topDec,              &amp;
+     LST,HA,Az,El,dist)
+
+  implicit none
+
+  integer y                           !Year
+  integer m                           !Month
+  integer Day                         !Day
+  real*8 UT                           !UTC in hours
+  real*8 RA,Dec                       !RA and Dec of moon
+
+! NB: Double caps are single caps in the writeup.
+
+  real*8 NN                           !Longitude of ascending node
+  real*8 i                            !Inclination to the ecliptic
+  real*8 w                            !Argument of perigee
+  real*8 a                            !Semi-major axis
+  real*8 e                            !Eccentricity
+  real*8 MM                           !Mean anomaly
+
+  real*8 v                            !True anomaly
+  real*8 EE                           !Eccentric anomaly
+  real*8 ecl                          !Obliquity of the ecliptic
+
+  real*8 d                            !Ephemeris time argument in days
+  real*8 r                            !Distance to sun, AU
+  real*8 xv,yv                        !x and y coords in ecliptic
+  real*8 lonecl,latecl                !Ecliptic long and lat of moon
+  real*8 xg,yg,zg                     !Ecliptic rectangular coords
+  real*8 Ms                           !Mean anomaly of sun
+  real*8 ws                           !Argument of perihelion of sun
+  real*8 Ls                           !Mean longitude of sun (Ns=0)
+  real*8 Lm                           !Mean longitude of moon
+  real*8 DD                           !Mean elongation of moon
+  real*8 FF                           !Argument of latitude for moon
+  real*8 xe,ye,ze                     !Equatorial geocentric coords of moon
+  real*8 mpar                         !Parallax of moon (r_E / d)
+  real*8 lat,lon                      !Station coordinates on earth
+  real*8 gclat                        !Geocentric latitude
+  real*8 rho                          !Earth radius factor
+  real*8 GMST0,LST,HA
+  real*8 g
+  real*8 topRA,topDec                 !Topocentric coordinates of Moon
+  real*8 Az,El
+  real*8 dist
+
+  real*8 rad,twopi,pi,pio2
+  data rad/57.2957795131d0/,twopi/6.283185307d0/
+
+  d=367*y - 7*(y+(m+9)/12)/4 + 275*m/9 + Day - 730530 + UT/24.d0
+  ecl = 23.4393d0 - 3.563d-7 * d
+
+! Orbital elements for Moon:  
+  NN = 125.1228d0 - 0.0529538083d0 * d
+  i = 5.1454d0
+  w = mod(318.0634d0 + 0.1643573223d0 * d + 360000.d0,360.d0)
+  a = 60.2666d0
+  e = 0.054900d0
+  MM = mod(115.3654d0 + 13.0649929509d0 * d + 360000.d0,360.d0)
+
+  EE = MM + e*rad*sin(MM/rad) * (1.d0 + e*cos(MM/rad))
+  EE = EE - (EE - e*rad*sin(EE/rad)-MM) / (1.d0 - e*cos(EE/rad))
+  EE = EE - (EE - e*rad*sin(EE/rad)-MM) / (1.d0 - e*cos(EE/rad))
+
+  xv = a * (cos(EE/rad) - e)
+  yv = a * (sqrt(1.d0-e*e) * sin(EE/rad))
+
+  v = mod(rad*atan2(yv,xv)+720.d0,360.d0)
+  r = sqrt(xv*xv + yv*yv)
+
+! Get geocentric position in ecliptic rectangular coordinates:
+
+  xg = r * (cos(NN/rad)*cos((v+w)/rad) -                          &amp;
+       sin(NN/rad)*sin((v+w)/rad)*cos(i/rad))
+  yg = r * (sin(NN/rad)*cos((v+w)/rad) +                          &amp;
+       cos(NN/rad)*sin((v+w)/rad)*cos(i/rad))
+  zg = r * (sin((v+w)/rad)*sin(i/rad))
+
+! Ecliptic longitude and latitude of moon:
+  lonecl = mod(rad*atan2(yg/rad,xg/rad)+720.d0,360.d0)
+  latecl = rad*atan2(zg/rad,sqrt(xg*xg + yg*yg)/rad)
+
+! Now include orbital perturbations:
+  Ms = mod(356.0470d0 + 0.9856002585d0 * d + 3600000.d0,360.d0)
+  ws = 282.9404d0 + 4.70935d-5*d
+  Ls = mod(Ms + ws + 720.d0,360.d0)
+  Lm = mod(MM + w + NN+720.d0,360.d0)
+  DD = mod(Lm - Ls + 360.d0,360.d0)
+  FF = mod(Lm - NN + 360.d0,360.d0)
+
+  lonecl = lonecl                                           &amp;
+       -1.274d0 * sin((MM-2.d0*DD)/rad)                     &amp;
+       +0.658d0 * sin(2.d0*DD/rad)                          &amp;
+       -0.186d0 * sin(Ms/rad)                               &amp;
+       -0.059d0 * sin((2.d0*MM-2.d0*DD)/rad)                &amp;
+       -0.057d0 * sin((MM-2.d0*DD+Ms)/rad)                  &amp;
+       +0.053d0 * sin((MM+2.d0*DD)/rad)                     &amp;
+       +0.046d0 * sin((2.d0*DD-Ms)/rad)                     &amp;
+       +0.041d0 * sin((MM-Ms)/rad)                          &amp;
+       -0.035d0 * sin(DD/rad)                               &amp;
+       -0.031d0 * sin((MM+Ms)/rad)                          &amp;
+       -0.015d0 * sin((2.d0*FF-2.d0*DD)/rad)                &amp;
+       +0.011d0 * sin((MM-4.d0*DD)/rad)
+
+  latecl = latecl                                           &amp;
+       -0.173d0 * sin((FF-2.d0*DD)/rad)                     &amp;
+       -0.055d0 * sin((MM-FF-2.d0*DD)/rad)                  &amp;
+       -0.046d0 * sin((MM+FF-2.d0*DD)/rad)                  &amp;
+       +0.033d0 * sin((FF+2.d0*DD)/rad)                     &amp;
+       +0.017d0 * sin((2.d0*MM+FF)/rad)
+
+  r = 60.36298d0                                            &amp;
+       - 3.27746d0*cos(MM/rad)                              &amp;
+       - 0.57994d0*cos((MM-2.d0*DD)/rad)                    &amp;
+       - 0.46357d0*cos(2.d0*DD/rad)                         &amp;
+       - 0.08904d0*cos(2.d0*MM/rad)                         &amp;
+       + 0.03865d0*cos((2.d0*MM-2.d0*DD)/rad)               &amp;
+       - 0.03237d0*cos((2.d0*DD-Ms)/rad)                    &amp;
+       - 0.02688d0*cos((MM+2.d0*DD)/rad)                    &amp;
+       - 0.02358d0*cos((MM-2.d0*DD+Ms)/rad)                 &amp;
+       - 0.02030d0*cos((MM-Ms)/rad)                         &amp;
+       + 0.01719d0*cos(DD/rad)                              &amp;
+       + 0.01671d0*cos((MM+Ms)/rad)
+
+  dist=r*6378.140d0
+
+! Geocentric coordinates:
+! Rectangular ecliptic coordinates of the moon:
+
+  xg = r * cos(lonecl/rad)*cos(latecl/rad)
+  yg = r * sin(lonecl/rad)*cos(latecl/rad)
+  zg = r *                 sin(latecl/rad)
+
+! Rectangular equatorial coordinates of the moon:
+  xe = xg
+  ye = yg*cos(ecl/rad) - zg*sin(ecl/rad)
+  ze = yg*sin(ecl/rad) + zg*cos(ecl/rad)
+   
+! Right Ascension, Declination:
+  RA = mod(rad*atan2(ye,xe)+360.d0,360.d0)
+  Dec = rad*atan2(ze,sqrt(xe*xe + ye*ye))
+
+! Now convert to topocentric system:
+  mpar=rad*asin(1.d0/r)
+!     alt_topoc = alt_geoc - mpar*cos(alt_geoc)
+  gclat = lat - 0.1924d0*sin(2.d0*lat/rad)
+  rho = 0.99883d0 + 0.00167d0*cos(2.d0*lat/rad)
+  GMST0 = (Ls + 180.d0)/15.d0
+  LST = mod(GMST0+UT+lon/15.d0+48.d0,24.d0)    !LST in hours
+  HA = 15.d0*LST - RA                          !HA in degrees
+  g = rad*atan(tan(gclat/rad)/cos(HA/rad))
+  topRA = RA - mpar*rho*cos(gclat/rad)*sin(HA/rad)/cos(Dec/rad)
+  topDec = Dec - mpar*rho*sin(gclat/rad)*sin((g-Dec)/rad)/sin(g/rad)
+
+  HA = 15.d0*LST - topRA                       !HA in degrees
+  if(HA.gt.180.d0) HA=HA-360.d0
+  if(HA.lt.-180.d0) HA=HA+360.d0
+
+  pi=0.5d0*twopi
+  pio2=0.5d0*pi
+  call dcoord(pi,pio2-lat/rad,0.d0,lat/rad,ha*twopi/360,topDec/rad,az,el)
+  Az=az*rad
+  El=El*rad
+
+  return
+end subroutine moon2

Added: branches/wsjtx_w/lib/moondop.f90
===================================================================
--- branches/wsjtx_w/lib/moondop.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/moondop.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,73 @@
+subroutine MoonDop(nyear,month,nday,uth4,lon4,lat4,RAMoon4,        &amp;
+     DecMoon4,LST4,HA4,AzMoon4,ElMoon4,vr4,dist4)
+
+  implicit real*8 (a-h,o-z)
+  real*4 uth4                    !UT in hours
+  real*4 lon4                    !West longitude, degrees
+  real*4 lat4                    !Latitude, degrees
+  real*4 RAMoon4                 !Topocentric RA of moon, hours
+  real*4 DecMoon4                !Topocentric Dec of Moon, degrees
+  real*4 LST4                    !Locat sidereal time, hours
+  real*4 HA4                     !Local Hour angle, degrees
+  real*4 AzMoon4                 !Topocentric Azimuth of moon, degrees
+  real*4 ElMoon4                 !Topocentric Elevation of moon, degrees
+  real*4 vr4                     !Radial velocity of moon wrt obs, km/s
+  real*4 dist4                   !Echo time, seconds
+
+  real*8 LST
+  real*8 RME(6)                  !Vector from Earth center to Moon
+  real*8 RAE(6)                  !Vector from Earth center to Obs
+  real*8 RMA(6)                  !Vector from Obs to Moon
+  real*8 pvsun(6)
+  real*8 rme0(6)
+  logical km,bary
+
+  data rad/57.2957795130823d0/,twopi/6.28310530717959d0/
+  
+  km=.true.
+  dlat=lat4/rad
+  dlong1=lon4/rad
+  elev1=200.d0
+  call geocentric(dlat,elev1,dlat1,erad1)
+
+  dt=100.d0                       !For numerical derivative, in seconds
+  UT=uth4
+
+! NB: geodetic latitude used here, but geocentric latitude used when 
+! determining Earth-rotation contribution to Doppler.
+
+  call moon2(nyear,month,nDay,UT-dt/3600.d0,dlong1*rad,dlat*rad,     &amp;
+       RA,Dec,topRA,topDec,LST,HA,Az0,El0,dist)
+  call toxyz(RA/rad,Dec/rad,dist,rme0)      !Convert to rectangular coords
+
+  call moon2(nyear,month,nDay,UT,dlong1*rad,dlat*rad,                &amp;
+       RA,Dec,topRA,topDec,LST,HA,Az,El,dist)
+  call toxyz(RA/rad,Dec/rad,dist,rme)       !Convert to rectangular coords
+
+  phi=LST*twopi/24.d0
+  call toxyz(phi,dlat1,erad1,rae)           !Gencentric numbers used here!
+  radps=twopi/(86400.d0/1.002737909d0)
+  rae(4)=-rae(2)*radps                      !Vel of Obs wrt Earth center
+  rae(5)=rae(1)*radps
+  rae(6)=0.d0
+
+  do i=1,3
+     rme(i+3)=(rme(i)-rme0(i))/dt
+     rma(i)=rme(i)-rae(i)
+     rma(i+3)=rme(i+3)-rae(i+3)
+  enddo
+
+  call fromxyz(rma,alpha1,delta1,dtopo0)     !Get topocentric coords
+  vr=dot(rma(4),rma)/dtopo0
+
+  RAMoon4=topRA
+  DecMoon4=topDec
+  LST4=LST
+  HA4=HA
+  AzMoon4=Az
+  ElMoon4=El
+  vr4=vr
+  dist4=dist
+
+  return
+end subroutine MoonDop

Added: branches/wsjtx_w/lib/sun.f90
===================================================================
--- branches/wsjtx_w/lib/sun.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/sun.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,88 @@
+subroutine sun(y,m,DD,UT,lon,lat,RA,Dec,LST,Az,El,mjd,day)
+
+  implicit none
+
+  integer y                         !Year
+  integer m                         !Month
+  integer DD                        !Day
+  integer mjd                       !Modified Julian Date
+  real UT                           !UT!in hours
+  real RA,Dec                       !RA and Dec of sun
+
+! NB: Double caps here are single caps in the writeup.
+
+! Orbital elements of the Sun (also N=0, i=0, a=1):
+  real w                            !Argument of perihelion
+  real e                            !Eccentricity
+  real MM                           !Mean anomaly
+  real Ls                           !Mean longitude
+
+! Other standard variables:
+  real v                            !True anomaly
+  real EE                           !Eccentric anomaly
+  real ecl                          !Obliquity of the ecliptic
+  real d                            !Ephemeris time argument in days
+  real r                            !Distance to sun, AU
+  real xv,yv                        !x and y coords in ecliptic
+  real lonsun                       !Ecliptic long and lat of sun
+!Ecliptic coords of sun (geocentric)
+  real xs,ys
+!Equatorial coords of sun (geocentric)
+  real xe,ye,ze
+  real lon,lat
+  real GMST0,LST,HA
+  real xx,yy,zz
+  real xhor,yhor,zhor
+  real Az,El
+
+  real day
+  real rad
+  data rad/57.2957795/
+
+! Time in days, with Jan 0, 2000 equal to 0.0:
+  d=367*y - 7*(y+(m+9)/12)/4 + 275*m/9 + DD - 730530 + UT/24.0
+  mjd=d + 51543
+  ecl = 23.4393 - 3.563e-7 * d
+
+! Compute updated orbital elements for Sun:
+  w = 282.9404 + 4.70935e-5 * d
+  e = 0.016709 - 1.151e-9 * d
+  MM = mod(356.0470d0 + 0.9856002585d0 * d + 360000.d0,360.d0)
+  Ls = mod(w+MM+720.0,360.0)
+
+  EE = MM + e*rad*sin(MM/rad) * (1.0 + e*cos(M/rad))
+  EE = EE - (EE - e*rad*sin(EE/rad)-MM) / (1.0 - e*cos(EE/rad))
+
+  xv = cos(EE/rad) - e
+  yv = sqrt(1.0-e*e) * sin(EE/rad)
+  v = rad*atan2(yv,xv)
+  r = sqrt(xv*xv + yv*yv)
+  lonsun = mod(v + w + 720.0,360.0)
+! Ecliptic coordinates of sun (rectangular):
+  xs = r * cos(lonsun/rad)
+  ys = r * sin(lonsun/rad)
+
+! Equatorial coordinates of sun (rectangular):
+  xe = xs
+  ye = ys * cos(ecl/rad)
+  ze = ys * sin(ecl/rad)
+
+! RA and Dec in degrees:
+  RA = rad*atan2(ye,xe)
+  Dec = rad*atan2(ze,sqrt(xe*xe + ye*ye))
+
+  GMST0 = (Ls + 180.0)/15.0
+  LST = mod(GMST0+UT+lon/15.0+48.0,24.0)    !LST in hours
+  HA = 15.0*LST - RA                        !HA in degrees
+  xx = cos(HA/rad)*cos(Dec/rad)
+  yy = sin(HA/rad)*cos(Dec/rad)
+  zz =             sin(Dec/rad)
+  xhor = xx*sin(lat/rad) - zz*cos(lat/rad)
+  yhor = yy
+  zhor = xx*cos(lat/rad) + zz*sin(lat/rad)
+  Az = mod(rad*atan2(yhor,xhor) + 180.0 + 360.0,360.0)
+  El = rad*asin(zhor)
+  day=d-1.5
+  
+  return
+end subroutine sun

Added: branches/wsjtx_w/lib/tm2.f90
===================================================================
--- branches/wsjtx_w/lib/tm2.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/tm2.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,14 @@
+subroutine tm2(day,xlat4,xlon4,xl4,b4)
+
+  implicit real*8 (a-h,o-z)
+  parameter (RADS=0.0174532925199433d0)
+
+  real*4 day4,xlat4,xlon4,xl4,b4
+
+  glat=xlat4*RADS
+  glong=xlon4*RADS
+  call tmoonsub(day,glat,glong,el,rv,xl,b,pax)
+  xl4=xl
+  b4=b
+
+end subroutine tm2

Added: branches/wsjtx_w/lib/tmoonsub.c
===================================================================
--- branches/wsjtx_w/lib/tmoonsub.c	                        (rev 0)
+++ branches/wsjtx_w/lib/tmoonsub.c	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,514 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+#define RADS 0.0174532925199433
+#define DEGS 57.2957795130823
+#define TPI 6.28318530717959
+#define PI 3.1415927
+
+/* ratio of     earth radius to astronomical unit */
+#define ER_OVER_AU 0.0000426352325194252
+
+/* all prototypes here */
+
+double getcoord(int coord);
+void getargs(int argc, char *argv[], int *y, int *m, double *tz, double *glong, double *glat);
+double range(double y);
+double rangerad(double y);
+double days(int y, int m, int dn, double hour);
+double days_(int *y, int *m, int *dn, double *hour);
+void moonpos(double, double *, double *, double *);
+void sunpos(double , double *, double *, double *);
+double moontransit(int y, int m, int d, double timezone, double glat, double glong, int *nt);
+double atan22(double y, double x);
+double epsilon(double d);
+void equatorial(double d, double *lon, double *lat, double *r);
+void ecliptic(double d, double *lon, double *lat, double *r);
+double gst(double d);
+void topo(double lst, double glat, double *alp, double *dec, double *r);
+double alt(double glat, double ha, double dec);
+void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p);
+void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill);
+int daysinmonth(int y, int m);
+int isleap(int y);
+void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
+   double *mrv, double *l, double *b, double *paxis);
+
+static const char
+*usage = &quot;  Usage: tmoon date[yyyymm] timz[+/-h.hh] long[+/-dddmm] lat[+/-ddmm]\n&quot;
+            &quot;example: tmoon 200009 0 -00155 5230\n&quot;;
+
+/*
+  getargs() gets the arguments from the command line, does some basic error
+  checking, and converts arguments into numerical form. Arguments are passed
+  back in pointers. Error messages print to stderr so re-direction of output
+  to file won't leave users blind. Error checking prints list of all errors
+  in a command line before quitting.
+*/
+void getargs(int argc, char *argv[], int *y, int *m, double *tz,
+             double *glong, double *glat) {
+
+  int date, latitude, longitude;
+  int mflag = 0, yflag = 0, longflag = 0, latflag = 0, tzflag = 0;
+  int longminflag = 0, latminflag = 0, dflag = 0;
+
+  /* if not right number of arguments, then print example command line */
+
+  if (argc !=5) {
+    fprintf(stderr, usage);
+    exit(EXIT_FAILURE);
+  }
+
+  date = atoi(argv[1]);
+  *y = date / 100;
+  *m = date - *y * 100;
+  *tz = (double) atof(argv[2]);
+  longitude = atoi(argv[3]);
+  latitude = atoi(argv[4]);
+  *glong = RADS * getcoord(longitude);
+  *glat = RADS * getcoord(latitude);
+
+  /* set a flag for each error found */
+
+  if (*m &gt; 12 || *m &lt; 1) mflag = 1;
+  if (*y &gt; 2500) yflag = 1;
+  if (date &lt; 150001) dflag = 1;
+  if (fabs((float) *glong) &gt; 180 * RADS) longflag = 1;
+  if (abs(longitude) % 100 &gt; 59) longminflag = 1;
+  if (fabs((float) *glat) &gt; 90 * RADS) latflag = 1;
+  if (abs(latitude) % 100 &gt; 59) latminflag = 1;
+  if (fabs((float) *tz) &gt; 12) tzflag = 1;
+
+  /* print all the errors found */
+  
+  if (dflag == 1) {
+    fprintf(stderr, &quot;date: dates must be in form yyyymm, gregorian, and later than 1500 AD\n&quot;);
+  }
+  if (yflag == 1) {
+    fprintf(stderr, &quot;date: too far in future - accurate from 1500 to 2500\n&quot;);
+  }
+  if (mflag == 1) {
+    fprintf(stderr, &quot;date: month must be in range 0 to 12, eg - August 2000 is entered as 200008\n&quot;);
+  }
+  if (tzflag == 1) {
+    fprintf(stderr, &quot;timz: must be in range +/- 12 hours, eg -6 for Chicago\n&quot;);
+  }
+  if (longflag == 1) {
+    fprintf(stderr, &quot;long: must be in range +/- 180 degrees\n&quot;);
+  }
+  if (longminflag == 1) {
+    fprintf(stderr, &quot;long: last two digits are arcmin - max 59\n&quot;);
+  }
+  if (latflag == 1) {
+    fprintf(stderr, &quot; lat: must be in range +/- 90 degrees\n&quot;);
+  }
+  if (latminflag == 1) {
+    fprintf(stderr, &quot; lat: last two digits are arcmin - max 59\n&quot;);
+  }
+
+  /* quits if one or more flags set */
+
+  if (dflag + mflag + yflag + longflag + latflag + tzflag + longminflag + latminflag &gt; 0) {
+    exit(EXIT_FAILURE);
+  }
+  
+}
+
+/*
+   returns coordinates in decimal degrees given the
+   coord as a ddmm value stored in an integer.
+*/
+double getcoord(int coord) {
+  int west = 1;
+  double glg, deg;
+  if (coord &lt; 0) west = -1;
+  glg = fabs((double) coord/100);
+  deg = floor(glg);
+  glg = west* (deg + (glg - deg)*100 / 60);
+  return(glg);
+}
+
+/*
+  days() takes the year, month, day in the month and decimal hours
+  in the day and returns the number of days since J2000.0.
+  Assumes Gregorian calendar.
+*/
+double days(int y, int m, int d, double h) {
+  int a, b;
+  double day;
+  
+  /*
+    The lines below work from 1900 march to feb 2100
+    a = 367 * y - 7 * (y + (m + 9) / 12) / 4 + 275 * m / 9 + d;
+    day = (double)a - 730531.5 + hour / 24;
+  */
+
+  /*  These lines work for any Gregorian date since 0 AD */
+  if (m ==1 || m==2) {
+    m +=12;
+    y -= 1;
+  }
+  a = y / 100;
+  b = 2 - a + a/4;
+  day = floor(365.25*(y + 4716)) + floor(30.6001*(m + 1))
+    + d + b - 1524.5 - 2451545 + h/24;
+  return(day);
+}
+double days_(int *y0, int *m0, int *d0, double *h0) 
+{
+  return days(*y0,*m0,*d0,*h0);
+}
+
+/*
+Returns 1 if y a leap year, and 0 otherwise, according
+to the Gregorian calendar
+*/
+int isleap(int y) {
+  int a = 0;
+  if(y % 4 == 0) a = 1;
+  if(y % 100 == 0) a = 0;
+  if(y % 400 == 0) a = 1;
+  return(a);
+}
+
+/*
+Given the year and the month, function returns the
+number of days in the month. Valid for Gregorian
+calendar.
+*/
+int daysinmonth(int y, int m) {
+  int b = 31;
+  if(m == 2) {
+    if(isleap(y) == 1) b= 29;
+    else b = 28;
+  }
+  if(m == 4 || m == 6 || m == 9 || m == 11) b = 30;
+  return(b);
+}
+
+/*
+moonpos() takes days from J2000.0 and returns ecliptic coordinates
+of moon in the pointers. Note call by reference.
+This function is within a couple of arcminutes most of the time,
+and is truncated from the Meeus Ch45 series, themselves truncations of
+ELP-2000. Returns moon distance in earth radii.
+Terms have been written out explicitly rather than using the
+table based method as only a small number of terms is
+retained.
+*/
+void moonpos(double d, double *lambda, double *beta, double *rvec) {
+  double dl, dB, dR, L, D, M, M1, F, e, lm, bm, rm, t;
+
+  t = d / 36525;
+
+  L = range(218.3164591  + 481267.88134236  * t) * RADS;
+  D = range(297.8502042  + 445267.1115168  * t) * RADS;
+  M = range(357.5291092  + 35999.0502909  * t) * RADS;
+  M1 = range(134.9634114  + 477198.8676313  * t - .008997 * t * t) * RADS;
+  F = range(93.27209929999999  + 483202.0175273  * t - .0034029*t*t)*RADS;
+  e = 1 - .002516 * t;
+
+  dl =      6288774 * sin(M1);
+  dl +=     1274027 * sin(2 * D - M1);
+  dl +=      658314 * sin(2 * D);
+  dl +=      213618 * sin(2 * M1);
+  dl -=  e * 185116 * sin(M);
+  dl -=      114332 * sin(2 * F) ;
+  dl +=       58793 * sin(2 * D - 2 * M1);
+  dl +=   e * 57066 * sin(2 * D - M - M1) ;
+  dl +=       53322 * sin(2 * D + M1);
+  dl +=   e * 45758 * sin(2 * D - M);
+  dl -=   e * 40923 * sin(M - M1);
+  dl -=       34720 * sin(D) ;
+  dl -=   e * 30383 * sin(M + M1) ;
+  dl +=       15327 * sin(2 * D - 2 * F) ;
+  dl -=       12528 * sin(M1 + 2 * F);
+  dl +=       10980 * sin(M1 - 2 * F);
+  lm = rangerad(L + dl / 1000000 * RADS);
+
+  dB =   5128122 * sin(F);
+  dB +=   280602 * sin(M1 + F);
+  dB +=   277693 * sin(M1 - F);
+  dB +=   173237 * sin(2 * D - F);
+  dB +=    55413 * sin(2 * D - M1 + F);
+  dB +=    46271 * sin(2 * D - M1 - F);
+  dB +=    32573 * sin(2 * D + F);
+  dB +=    17198 * sin(2 * M1 + F);
+  dB +=     9266 * sin(2 * D + M1 - F);
+  dB +=     8822 * sin(2 * M1 - F);
+  dB += e * 8216 * sin(2 * D - M - F);
+  dB +=     4324 * sin(2 * D - 2 * M1 - F);
+  bm = dB / 1000000 * RADS;
+
+  dR =    -20905355 * cos(M1);
+  dR -=     3699111 * cos(2 * D - M1);
+  dR -=     2955968 * cos(2 * D);
+  dR -=      569925 * cos(2 * M1);
+  dR +=   e * 48888 * cos(M);
+  dR -=        3149 * cos(2 * F);
+  dR +=      246158 * cos(2 * D - 2 * M1);
+  dR -=  e * 152138 * cos(2 * D - M - M1) ;
+  dR -=      170733 * cos(2 * D + M1);
+  dR -=  e * 204586 * cos(2 * D - M);
+  dR -=  e * 129620 * cos(M - M1);
+  dR +=      108743 * cos(D);
+  dR +=  e * 104755 * cos(M + M1);
+  dR +=       79661 * cos(M1 - 2 * F);
+  rm = 385000.56  + dR / 1000;
+
+  *lambda = lm;
+  *beta = bm;
+  /* distance to Moon must be in Earth radii */
+  *rvec = rm / 6378.14;
+}
+
+/*
+topomoon() takes the local siderial time, the geographical
+latitude of the observer, and pointers to the geocentric
+equatorial coordinates. The function overwrites the geocentric
+coordinates with topocentric coordinates on a simple spherical
+earth model (no polar flattening). Expects Moon-Earth distance in
+Earth radii.    Formulas scavenged from Astronomical Almanac 'low
+precision formulae for Moon position' page D46.
+*/
+
+void topo(double lst, double glat, double *alp, double *dec, double *r) {
+  double x, y, z, r1;
+  x = *r * cos(*dec) * cos(*alp) - cos(glat) * cos(lst);
+  y = *r * cos(*dec) * sin(*alp) - cos(glat) * sin(lst);
+  z = *r * sin(*dec)  - sin(glat);
+  r1 = sqrt(x*x + y*y + z*z);
+  *alp = atan22(y, x);
+  *dec = asin(z / r1);
+  *r = r1;
+}
+
+/*
+moontransit() takes date, the time zone and geographic longitude
+of observer and returns the time (decimal hours) of lunar transit
+on that day if there is one, and sets the notransit flag if there
+isn't. See Explanatory Supplement to Astronomical Almanac
+section 9.32 and 9.31 for the method.
+*/
+
+double moontransit(int y, int m, int d, double tz, double glat, double glong, int *notransit) {
+  double hm, ht, ht1, lon, lat, rv, dnew, lst;
+  int itcount;
+
+  ht1 = 180 * RADS;
+  ht = 0;
+  itcount = 0;
+  *notransit = 0;
+  do {
+    ht = ht1;
+    itcount++;
+    dnew = days(y, m, d, ht * DEGS/15) - tz/24;
+    lst = gst(dnew) + glong;
+    /* find the topocentric Moon ra (hence hour angle) and dec */
+    moonpos(dnew, &amp;lon, &amp;lat, &amp;rv);
+    equatorial(dnew, &amp;lon, &amp;lat, &amp;rv);
+    topo(lst, glat, &amp;lon, &amp;lat, &amp;rv);
+    hm = rangerad(lst -  lon);
+    ht1 = rangerad(ht - hm);
+    /* if no convergence, then no transit on that day */
+    if (itcount &gt; 30) {
+      *notransit = 1;
+      break;
+    }
+  }
+  while (fabs(ht - ht1) &gt; 0.04 * RADS);
+  return(ht1);
+}
+
+/*
+  Calculates the selenographic coordinates of either the sub Earth point
+  (optical libration) or the sub-solar point (selen. coords of centre of
+  bright hemisphere).  Based on Meeus chapter 51 but neglects physical
+  libration and nutation, with some simplification of the formulas.
+*/
+void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p) {
+  double i, f, omega, w, y, x, a, t, eps;
+  t = day / 36525;
+  i = 1.54242 * RADS;
+  eps = epsilon(day);
+  f = range(93.2720993 + 483202.0175273 * t - .0034029 * t * t) * RADS;
+  omega = range(125.044555 - 1934.1361849 * t + .0020762 * t * t) * RADS;
+  w = lambda - omega;
+  y = sin(w) * cos(beta) * cos(i) - sin(beta) * sin(i);
+  x = cos(w) * cos(beta);
+  a = atan22(y, x);
+  *l = a - f;
+
+  /*  kludge to catch cases of 'round the back' angles  */
+  if (*l &lt; -90 * RADS) *l += TPI;
+  if (*l &gt; 90 * RADS)  *l -= TPI;
+  *b = asin(-sin(w) * cos(beta) * sin(i) - sin(beta) * cos(i));
+
+  /*  pa pole axis - not used for Sun stuff */
+  x = sin(i) * sin(omega);
+  y = sin(i) * cos(omega) * cos(eps) - cos(i) * sin(eps);
+  w = atan22(x, y);
+  *p = rangerad(asin(sqrt(x*x + y*y) * cos(alpha - w) / cos(*b)));
+}
+
+/*
+  Takes: days since J2000.0, eq coords Moon, ratio of moon to sun distance,
+  eq coords Sun
+  Returns: position angle of bright limb wrt NCP, percentage illumination
+  of Sun
+*/
+void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill) {
+  double x, y, phi, i;
+  y = cos(sdec) * sin(sra - lra);
+  x = sin(sdec) * cos(ldec) - cos(sdec) * sin(ldec) * cos (sra - lra);
+  *pabl = atan22(y, x);
+  phi = acos(sin(sdec) * sin(ldec) + cos(sdec) * cos(ldec) * cos(sra-lra));
+  i = atan22(sin(phi) , (dr - cos(phi)));
+  *ill = 0.5*(1 + cos(i));
+}
+
+/*
+sunpos() takes days from J2000.0 and returns ecliptic longitude
+of Sun in the pointers. Latitude is zero at this level of precision,
+but pointer left in for consistency in number of arguments.
+This function is within 0.01 degree (1 arcmin) almost all the time
+for a century either side of J2000.0. This is from the 'low precision
+fomulas for the Sun' from C24 of Astronomical Alamanac
+*/
+void sunpos(double d, double *lambda, double *beta, double *rvec) {
+  double L, g, ls, bs, rs;
+
+  L = range(280.461 + .9856474 * d) * RADS;
+  g = range(357.528 + .9856003 * d) * RADS;
+  ls = L + (1.915 * sin(g) + .02 * sin(2 * g)) * RADS;
+  bs = 0;
+  rs = 1.00014 - .01671 * cos(g) - .00014 * cos(2 * g);
+  *lambda = ls;
+  *beta = bs;
+  *rvec = rs;
+}
+
+/*
+this routine returns the altitude given the days since J2000.0
+the hour angle and declination of the object and the latitude
+of the observer. Used to find the Sun's altitude to put a letter
+code on the transit time, and to find the Moon's altitude at
+transit just to make sure that the Moon is visible.
+*/
+double alt(double glat, double ha, double dec) {
+  return(asin(sin(dec) * sin(glat) + cos(dec) * cos(glat) * cos(ha)));
+}
+
+/* returns an angle in degrees in the range 0 to 360 */
+double range(double x) {
+  double a, b;
+  b = x / 360;
+  a = 360 * (b - floor(b));
+  if (a &lt; 0)
+    a = 360 + a;
+  return(a);
+}
+
+/* returns an angle in rads in the range 0 to two pi */
+double rangerad(double x) {
+  double a, b;
+  b = x / TPI;
+  a = TPI * (b - floor(b));
+  if (a &lt; 0)
+    a = TPI + a;
+  return(a);
+}
+
+/*
+gets the atan2 function returning angles in the right
+order and  range
+*/
+double atan22(double y, double x) {
+  double a;
+
+  a = atan2(y, x);
+  if (a &lt; 0) a += TPI;
+  return(a);
+}
+
+/*
+returns mean obliquity of ecliptic in radians given days since
+J2000.0.
+*/
+double epsilon(double d) {
+  double t = d/ 36525;
+  return((23.4392911111111 - (t* (46.8150 + 0.00059*t)/3600)) *RADS);
+}
+
+/*
+replaces ecliptic coordinates with equatorial coordinates
+note: call by reference destroys original values
+R is unchanged.
+*/
+void equatorial(double d, double *lon, double *lat, double *r) {
+  double  eps, ceps, seps, l, b;
+
+  l = *lon;
+  b = * lat;
+  eps = epsilon(d);
+  ceps = cos(eps);
+  seps = sin(eps);
+  *lon = atan22(sin(l)*ceps - tan(b)*seps, cos(l));
+  *lat = asin(sin(b)*ceps + cos(b)*seps*sin(l));
+}
+
+/*
+replaces equatorial coordinates with ecliptic ones. Inverse
+of above, but used to find topocentric ecliptic coords.
+*/
+void ecliptic(double d, double *lon, double *lat, double *r) {
+  double  eps, ceps, seps, alp, dec;
+  alp = *lon;
+  dec = *lat;
+  eps = epsilon(d);
+  ceps = cos(eps);
+  seps = sin(eps);
+  *lon = atan22(sin(alp)*ceps + tan(dec)*seps, cos(alp));
+  *lat = asin(sin(dec)*ceps - cos(dec)*seps*sin(alp));
+}
+
+/*
+returns the siderial time at greenwich meridian as
+an angle in radians given the days since J2000.0
+*/
+double gst( double d) {
+  double t = d / 36525;
+  double theta;
+  theta = range(280.46061837 + 360.98564736629 * d + 0.000387933 * t * t);
+  return(theta * RADS);
+}
+
+void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
+   double *mrv, double *l, double *b, double *paxis)
+{
+  double mlambda, mbeta;
+  double malpha, mdelta;
+  double lst, mhr;
+  double tlambda, tbeta, trv;
+
+  lst = gst(*day) + *glong;
+      
+  /* find Moon topocentric coordinates for libration calculations */
+
+  moonpos(*day, &amp;mlambda, &amp;mbeta, mrv);
+  malpha = mlambda;
+  mdelta = mbeta;
+  equatorial(*day, &amp;malpha, &amp;mdelta, mrv);
+  topo(lst, *glat, &amp;malpha, &amp;mdelta, mrv);
+  mhr = rangerad(lst - malpha);
+  *moonalt = alt(*glat, mhr, mdelta);
+      
+  /* Optical libration and Position angle of the Pole */
+
+  tlambda = malpha;
+  tbeta = mdelta;
+  trv = *mrv;
+  ecliptic(*day, &amp;tlambda, &amp;tbeta, &amp;trv);
+  libration(*day, tlambda, tbeta, malpha,  l, b, paxis);
+}

Added: branches/wsjtx_w/lib/toxyz.f90
===================================================================
--- branches/wsjtx_w/lib/toxyz.f90	                        (rev 0)
+++ branches/wsjtx_w/lib/toxyz.f90	2013-12-20 17:55:10 UTC (rev 3607)
@@ -0,0 +1,25 @@
+subroutine toxyz(alpha,delta,r,vec)
+
+  implicit real*8 (a-h,o-z)
+  real*8 vec(3)
+
+  vec(1)=r*cos(delta)*cos(alpha)
+  vec(2)=r*cos(delta)*sin(alpha)
+  vec(3)=r*sin(delta)
+
+  return
+end subroutine toxyz
+
+subroutine fromxyz(vec,alpha,delta,r)
+
+  implicit real*8 (a-h,o-z)
+  real*8 vec(3)
+  data twopi/6.283185307d0/
+
+  r=sqrt(vec(1)**2 + vec(2)**2 + vec(3)**2)
+  alpha=atan2(vec(2),vec(1))
+  if(alpha.lt.0.d0) alpha=alpha+twopi
+  delta=asin(vec(3)/r)
+
+  return
+end subroutine fromxyz

Modified: branches/wsjtx_w/mainwindow.cpp
===================================================================
--- branches/wsjtx_w/mainwindow.cpp	2013-12-19 15:39:38 UTC (rev 3606)
+++ branches/wsjtx_w/mainwindow.cpp	2013-12-20 17:55:10 UTC (rev 3607)
@@ -9,7 +9,7 @@
 #include &quot;devsetup.h&quot;
 #include &quot;plotter.h&quot;
 #include &quot;about.h&quot;
-//#include &quot;astro.h&quot;
+#include &quot;astro.h&quot;
 #include &quot;widegraph.h&quot;
 #include &quot;sleep.h&quot;
 #include &quot;getfile.h&quot;
@@ -28,7 +28,7 @@
 qint32  g_iptt;
 static int nc1=1;
 wchar_t buffer[256];
-//Astro*     g_pAstro = NULL;
+Astro*  g_pAstro = NULL;
 
 
 Rig* rig = NULL;
@@ -65,7 +65,6 @@
   connect (this, &amp;MainWindow::finished, this, &amp;MainWindow::close);
 
   // start audio thread and hook up slots &amp; signals for shutdown management
-
   // these objects need to be in the audio thread so that invoking
   // their slots is done in a thread safe way
   m_soundOutput.moveToThread (&amp;m_audioThread);
@@ -126,6 +125,7 @@
 
   QActionGroup* modeGroup = new QActionGroup(this);
   ui-&gt;actionJT9_1-&gt;setActionGroup(modeGroup);
+  ui-&gt;actionJT9W_1-&gt;setActionGroup(modeGroup);
   ui-&gt;actionJT65-&gt;setActionGroup(modeGroup);
   ui-&gt;actionJT9_JT65-&gt;setActionGroup(modeGroup);
 
@@ -370,9 +370,10 @@
   genStdMsgs(m_rpt);
   m_ntx=6;
   ui-&gt;txrb6-&gt;setChecked(true);
-  if(m_mode!=&quot;JT9&quot; and m_mode!=&quot;JT65&quot; and m_mode!=&quot;JT9+JT65&quot;) m_mode=&quot;JT9&quot;;
+  if(m_mode!=&quot;JT9&quot; and m_mode!=&quot;JT9W-1&quot; and m_mode!=&quot;JT65&quot; and
+      m_mode!=&quot;JT9+JT65&quot;) m_mode=&quot;JT9&quot;;
   on_actionWide_Waterfall_triggered();                   //###
-//  on_actionAstronomical_data_triggered();
+  on_actionAstronomical_data_triggered();
   m_wideGraph-&gt;setRxFreq(m_rxFreq);
   m_wideGraph-&gt;setTxFreq(m_txFreq);
   m_wideGraph-&gt;setLockTxFreq(m_lockTxFreq);
@@ -384,6 +385,7 @@
           SLOT(setFreq4(int,int)));
 
   if(m_mode==&quot;JT9&quot;) on_actionJT9_1_triggered();
+  if(m_mode==&quot;JT9W-1&quot;) on_actionJT9W_1_triggered();
   if(m_mode==&quot;JT65&quot;) on_actionJT65_triggered();
   if(m_mode==&quot;JT9+JT65&quot;) on_actionJT9_JT65_triggered();
 
@@ -462,6 +464,11 @@
   m_settings-&gt;setValue(&quot;TxFirst&quot;,m_txFirst);
   m_settings-&gt;setValue(&quot;DXcall&quot;,ui-&gt;dxCallEntry-&gt;text());
   m_settings-&gt;setValue(&quot;DXgrid&quot;,ui-&gt;dxGridEntry-&gt;text());
+
+  if(g_pAstro-&gt;isVisible()) {
+    m_astroGeom = g_pAstro-&gt;geometry();
+    m_settings-&gt;setValue(&quot;AstroGeom&quot;,m_astroGeom);
+  }
   m_settings-&gt;endGroup();
 
   m_settings-&gt;beginGroup(&quot;Common&quot;);
@@ -543,6 +550,7 @@
   restoreState (m_settings-&gt;value (&quot;state&quot;, saveState ()).toByteArray ());
   ui-&gt;dxCallEntry-&gt;setText(m_settings-&gt;value(&quot;DXcall&quot;,&quot;&quot;).toString());
   ui-&gt;dxGridEntry-&gt;setText(m_settings-&gt;value(&quot;DXgrid&quot;,&quot;&quot;).toString());
+  m_astroGeom = m_settings-&gt;value(&quot;AstroGeom&quot;, QRect(71,390,227,403)).toRect();
   m_path = m_settings-&gt;value(&quot;MRUdir&quot;, m_appDir + &quot;/save&quot;).toString();
   m_txFirst = m_settings-&gt;value(&quot;TxFirst&quot;,false).toBool();
   ui-&gt;txFirstCheckBox-&gt;setChecked(m_txFirst);
@@ -592,7 +600,7 @@
 
   m_mode=m_settings-&gt;value(&quot;Mode&quot;,&quot;JT9&quot;).toString();
   m_modeTx=m_settings-&gt;value(&quot;ModeTx&quot;,&quot;JT9&quot;).toString();
-  if(m_modeTx==&quot;JT9&quot;) ui-&gt;pbTxMode-&gt;setText(&quot;Tx JT9  @&quot;);
+  if(m_modeTx.mid(0,3)==&quot;JT9&quot;) ui-&gt;pbTxMode-&gt;setText(&quot;Tx JT9  @&quot;);
   if(m_modeTx==&quot;JT65&quot;) ui-&gt;pbTxMode-&gt;setText(&quot;Tx JT65  #&quot;);
   ui-&gt;actionNone-&gt;setChecked(m_settings-&gt;value(&quot;SaveNone&quot;,true).toBool());
   ui-&gt;actionSave_decoded-&gt;setChecked(m_settings-&gt;value(
@@ -1159,7 +1167,6 @@
   m_wideGraph-&gt;show();
 }
 
-/*
 void MainWindow::on_actionAstronomical_data_triggered()
 {
   if(g_pAstro==NULL) {
@@ -1170,9 +1177,9 @@
     g_pAstro-&gt;setWindowFlags(flags);
     g_pAstro-&gt;setGeometry(m_astroGeom);
   }
+  g_pAstro-&gt;setFontSize(18);
   g_pAstro-&gt;show();
 }
-*/
 
 void MainWindow::on_actionOpen_triggered()                     //Open File
 {
@@ -1390,8 +1397,9 @@
   jt9com_.ntxmode=9;
   if(m_modeTx==&quot;JT65&quot;) jt9com_.ntxmode=65;
   jt9com_.nmode=9;
+  if(m_mode==&quot;JT9W-1&quot;) jt9com_.nmode=91;
   if(m_mode==&quot;JT65&quot;) jt9com_.nmode=65;
-  if(m_mode==&quot;JT9+JT65&quot;) jt9com_.nmode=9+65;
+  if(m_mode==&quot;JT9+JT65&quot;) jt9com_.nmode=9+65;  // = 74
   jt9com_.ntrperiod=m_TRperiod;
   m_nsave=0;
   if(m_saveDecoded) m_nsave=2;
@@ -1773,6 +1781,12 @@
 
   if(nsec != m_sec0) {                                     //Once per second
     QDateTime t = QDateTime::currentDateTimeUtc();
+
+    int fQSO=144;
+    m_azelDir=m_appDir;
+    g_pAstro-&gt;astroUpdate(t, m_myGrid, m_hisGrid, fQSO, m_setftx,
+                          m_txFreq, m_azelDir);
+
     if(m_transmitting) {
       if(nsendingsh==1) {
         lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #66ffff}&quot;);
@@ -1822,8 +1836,14 @@
 void MainWindow::startTx2()
 {
   if (!m_modulator.isActive ()) {
-    QString t=ui-&gt;tx6-&gt;text();
-    double snr=t.mid(1,5).toDouble();
+    m_fSpread=0.0;
+    double snr=99.0;
+    QString t=ui-&gt;tx5-&gt;text();
+    if(t.mid(0,1)==&quot;#&quot;) m_fSpread=t.mid(1,5).toDouble();
+    m_modulator.setWide9(m_toneSpacing, m_fSpread);
+    t=ui-&gt;tx6-&gt;text();
+    if(t.mid(0,1)==&quot;#&quot;) snr=t.mid(1,5).toDouble();
+    qDebug() &lt;&lt; &quot;A&quot; &lt;&lt; m_toneSpacing &lt;&lt; m_fSpread &lt;&lt; snr;
     if(snr&gt;0.0 or snr &lt; -50.0) snr=99.0;
     transmit (snr);
     signalMeter-&gt;setValue(0);
@@ -2465,6 +2485,7 @@
   m_TRperiod=60;
   m_nsps=6912;
   m_hsymStop=173;
+  m_toneSpacing=0.0;
   lab2-&gt;setStyleSheet(&quot;QLabel{background-color: #ff6ec7}&quot;);
   lab2-&gt;setText(m_mode);
   ui-&gt;actionJT9_1-&gt;setChecked(true);
@@ -2474,6 +2495,25 @@
   ui-&gt;pbTxMode-&gt;setEnabled(false);
 }
 
+void MainWindow::on_actionJT9W_1_triggered()
+{
+  m_mode=&quot;JT9W-1&quot;;
+  if(m_modeTx!=&quot;JT9&quot;) on_pbTxMode_clicked();
+  statusChanged();
+  m_TRperiod=60;
+  m_nsps=6912;
+  m_hsymStop=173;
+  m_toneSpacing=32*12000.0/6912.0;  //55.5555... Hz
+//  m_toneSpacing=64*12000.0/6912.0;  //111.1111... Hz
+  lab2-&gt;setStyleSheet(&quot;QLabel{background-color: #ff6ec7}&quot;);
+  lab2-&gt;setText(m_mode);
+  ui-&gt;actionJT9W_1-&gt;setChecked(true);
+  m_wideGraph-&gt;setPeriod(m_TRperiod,m_nsps);
+  m_wideGraph-&gt;setMode(m_mode);
+  m_wideGraph-&gt;setModeTx(m_modeTx);
+  ui-&gt;pbTxMode-&gt;setEnabled(false);
+}
+
 void MainWindow::on_actionJT65_triggered()
 {
   m_mode=&quot;JT65&quot;;
@@ -3051,13 +3091,18 @@
 {
   if (m_modeTx == &quot;JT65&quot;)
     {
-      Q_EMIT sendMessage (NUM_JT65_SYMBOLS, 4096.0 * 12000.0 / 11025.0, m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0), m_audioOutputChannel, true, snr);
+      Q_EMIT sendMessage (NUM_JT65_SYMBOLS, 4096.0 * 12000.0 / 11025.0,
+                          m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0),
+                          m_audioOutputChannel, true, snr);
     }
   else
     {
-      Q_EMIT sendMessage (NUM_JT9_SYMBOLS, m_nsps, m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0), m_audioOutputChannel, true, snr);
+      Q_EMIT sendMessage (NUM_JT9_SYMBOLS, m_nsps,
+                          m_txFreq - (m_bSplit || m_bXIT ? m_XIT : 0),
+                          m_audioOutputChannel, true, snr);
     }
-  Q_EMIT startAudioOutputStream (m_audioOutputDevice, AudioDevice::Mono == m_audioOutputChannel ? 1 : 2, m_msAudioOutputBuffered);
+  Q_EMIT startAudioOutputStream (m_audioOutputDevice,
+  AudioDevice::Mono == m_audioOutputChannel ? 1 : 2, m_msAudioOutputBuffered);
 }
 
 void MainWindow::on_outAttenuation_valueChanged (int a)

Modified: branches/wsjtx_w/mainwindow.h
===================================================================
--- branches/wsjtx_w/mainwindow.h	2013-12-19 15:39:38 UTC (rev 3606)
+++ branches/wsjtx_w/mainwindow.h	2013-12-20 17:55:10 UTC (rev 3607)
@@ -179,8 +179,10 @@
   void on_actionTx2QSO_triggered(bool checked);  
   void on_cbPlus2kHz_toggled(bool checked);
   void on_outAttenuation_valueChanged (int);
-//  void on_actionAstronomical_data_triggered();
+  void on_actionAstronomical_data_triggered();
 
+  void on_actionJT9W_1_triggered();
+
 private:
   Q_SIGNAL void startAudioOutputStream (QAudioDeviceInfo, unsigned channels, unsigned msBuffered);
   Q_SIGNAL void stopAudioOutputStream ();
@@ -209,6 +211,8 @@
     QScopedPointer&lt;LogQSO&gt; m_logDlg;
 
     double  m_dialFreq;
+    double  m_toneSpacing;
+    double  m_fSpread;
 
     qint64  m_msErase;
     qint64  m_secBandChanged;
@@ -375,6 +379,7 @@
     QString m_cmnd;
     QString m_msgSent0;
     QString m_fileToSave;
+    QString m_azelDir;
 
     QStringList m_macro;
     QStringList m_dFreq;           // per band frequency in MHz as a string
@@ -382,6 +387,7 @@
     QStringList m_bandDescription; // per band description
 
     QDateTime m_dateTimeQSO;
+    QRect   m_astroGeom;
 
     QSharedMemory *mem_jt9;
  // Multiple instances:

Modified: branches/wsjtx_w/mainwindow.ui
===================================================================
--- branches/wsjtx_w/mainwindow.ui	2013-12-19 15:39:38 UTC (rev 3606)
+++ branches/wsjtx_w/mainwindow.ui	2013-12-20 17:55:10 UTC (rev 3607)
@@ -2366,6 +2366,7 @@
     &lt;addaction name=&quot;actionJT9_1&quot;/&gt;
     &lt;addaction name=&quot;actionJT65&quot;/&gt;
     &lt;addaction name=&quot;actionJT9_JT65&quot;/&gt;
+    &lt;addaction name=&quot;actionJT9W_1&quot;/&gt;
    &lt;/widget&gt;
    &lt;addaction name=&quot;menuFile&quot;/&gt;
    &lt;addaction name=&quot;menuSetup&quot;/&gt;
@@ -2680,6 +2681,14 @@
     &lt;string&gt;Astronomical data&lt;/string&gt;
    &lt;/property&gt;
   &lt;/action&gt;
+  &lt;action name=&quot;actionJT9W_1&quot;&gt;
+   &lt;property name=&quot;checkable&quot;&gt;
+    &lt;bool&gt;true&lt;/bool&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;text&quot;&gt;
+    &lt;string&gt;JT9W-1&lt;/string&gt;
+   &lt;/property&gt;
+  &lt;/action&gt;
  &lt;/widget&gt;
  &lt;layoutdefault spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
  &lt;customwidgets&gt;

Modified: branches/wsjtx_w/wsjtx.pro
===================================================================
--- branches/wsjtx_w/wsjtx.pro	2013-12-19 15:39:38 UTC (rev 3606)
+++ branches/wsjtx_w/wsjtx.pro	2013-12-20 17:55:10 UTC (rev 3607)
@@ -37,35 +37,18 @@
 #
 # Order matters here as the link is in this order so referrers need to be after referred
 #
-SOURCES += \
-	logbook/adif.cpp \
-	logbook/countrydat.cpp \
-	logbook/countriesworked.cpp \
-	logbook/logbook.cpp \
-	rigclass.cpp \
-	psk_reporter.cpp \
-	Modulator.cpp \
-	Detector.cpp \
-	logqso.cpp \
-	displaytext.cpp \
-	getfile.cpp \
-	soundout.cpp \
-	soundin.cpp \
-	meterwidget.cpp \
-	signalmeter.cpp \
-	plotter.cpp \
-	widegraph.cpp \
-	devsetup.cpp \
-	about.cpp \
-	mainwindow.cpp \
-	main.cpp \
-    decodedtext.cpp
+SOURCES += logbook/adif.cpp logbook/countrydat.cpp astro.cpp \
+  logbook/countriesworked.cpp logbook/logbook.cpp rigclass.cpp \
+  psk_reporter.cpp Modulator.cpp Detector.cpp logqso.cpp \
+  displaytext.cpp getfile.cpp soundout.cpp soundin.cpp \
+  meterwidget.cpp signalmeter.cpp plotter.cpp widegraph.cpp \
+  devsetup.cpp about.cpp mainwindow.cpp main.cpp decodedtext.cpp
 
 win32 {
 SOURCES += killbyname.cpp
 }
 
-HEADERS  += mainwindow.h plotter.h soundin.h soundout.h \
+HEADERS  += mainwindow.h plotter.h soundin.h soundout.h astro.h \
             about.h devsetup.h widegraph.h getfile.h \
             commons.h sleep.h displaytext.h logqso.h \
             AudioDevice.hpp Detector.hpp Modulator.hpp \
@@ -74,7 +57,7 @@
             logbook/countriesworked.h logbook/adif.h
 
 
-FORMS    += mainwindow.ui about.ui devsetup.ui widegraph.ui \
+FORMS    += mainwindow.ui about.ui devsetup.ui widegraph.ui astro.ui \
     logqso.ui
 
 RC_FILE = wsjtx.rc
@@ -88,7 +71,9 @@
 win32 {
 INCLUDEPATH += ../../hamlib-1.2.15.3/include
 LIBS += ../../hamlib-1.2.15.3/src/.libs/libhamlib.dll.a
-LIBS += ../wsjtx/lib/libjt9.a
+#LIBS += ../wsjtx/lib/libjt9.a
+LIBS += ../wsjtx_w/lib/libjt9.a
+LIBS += ../wsjtx_w/lib/libastro.a
 LIBS += ../wsjtx/libfftw3f_win.a
 LIBS += ../wsjtx/libpskreporter.a
 LIBS += ../wsjtx/libHRDInterface001.a

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003299.html">[WSJT-SVN] r3606 - in branches/wsjtx_w: . lib
</A></li>
	<LI>Next message: <A HREF="003300.html">[WSJT-SVN] r3608 - in branches/wsjtx_w: . lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3301">[ date ]</a>
              <a href="thread.html#3301">[ thread ]</a>
              <a href="subject.html#3301">[ subject ]</a>
              <a href="author.html#3301">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
