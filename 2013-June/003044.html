<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r3351 - in branches/wsjtx_k1jt_p1: . lib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2013-June/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r3351%20-%20in%20branches/wsjtx_k1jt_p1%3A%20.%20lib&In-Reply-To=%3C20130607200915.F0F0655B0C%40scm.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003042.html">
   <LINK REL="Next"  HREF="003043.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r3351 - in branches/wsjtx_k1jt_p1: . lib</H1>
    <B>k1jt at scm.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r3351%20-%20in%20branches/wsjtx_k1jt_p1%3A%20.%20lib&In-Reply-To=%3C20130607200915.F0F0655B0C%40scm.berlios.de%3E"
       TITLE="[WSJT-SVN] r3351 - in branches/wsjtx_k1jt_p1: . lib">k1jt at scm.berlios.de
       </A><BR>
    <I>Fri Jun  7 22:09:15 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="003042.html">[WSJT-SVN] r3350 - branches/wsjtx_k1jt_p1
</A></li>
        <LI>Next message: <A HREF="003043.html">[WSJT-SVN] r3352 - branches/wsjtx_k1jt_p1/lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3044">[ date ]</a>
              <a href="thread.html#3044">[ thread ]</a>
              <a href="subject.html#3044">[ subject ]</a>
              <a href="author.html#3044">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2013-06-07 22:09:15 +0200 (Fri, 07 Jun 2013)
New Revision: 3351

Added:
   branches/wsjtx_k1jt_p1/lib/afc65b.f90
   branches/wsjtx_k1jt_p1/lib/ccf2.f90
   branches/wsjtx_k1jt_p1/lib/ccf65.f90
   branches/wsjtx_k1jt_p1/lib/chkhist.f90
   branches/wsjtx_k1jt_p1/lib/decode1a.f90
   branches/wsjtx_k1jt_p1/lib/decode65b.f90
   branches/wsjtx_k1jt_p1/lib/demod64a.f90
   branches/wsjtx_k1jt_p1/lib/extract.f90
   branches/wsjtx_k1jt_p1/lib/fchisq65.f90
   branches/wsjtx_k1jt_p1/lib/fil6521.f90
   branches/wsjtx_k1jt_p1/lib/filbig.f90
   branches/wsjtx_k1jt_p1/lib/flat65.f90
   branches/wsjtx_k1jt_p1/lib/interleave63.f90
   branches/wsjtx_k1jt_p1/lib/jt65.f90
   branches/wsjtx_k1jt_p1/lib/jt65a.f90
   branches/wsjtx_k1jt_p1/lib/move.f90
   branches/wsjtx_k1jt_p1/lib/s3avg.f90
   branches/wsjtx_k1jt_p1/lib/setup65.f90
   branches/wsjtx_k1jt_p1/lib/symspec65.f90
Modified:
   branches/wsjtx_k1jt_p1/lib/Makefile.MinGW
   branches/wsjtx_k1jt_p1/mainwindow.cpp
Log:
1. Remove diagnostic prints.
2. Add some files for JT65.


Modified: branches/wsjtx_k1jt_p1/lib/Makefile.MinGW
===================================================================
--- branches/wsjtx_k1jt_p1/lib/Makefile.MinGW	2013-06-06 23:08:01 UTC (rev 3350)
+++ branches/wsjtx_k1jt_p1/lib/Makefile.MinGW	2013-06-07 20:09:15 UTC (rev 3351)
@@ -20,7 +20,7 @@
 %.o: %.F90
 	${FC} ${FFLAGS} -c $&lt;
 
-all:    libjt9.a jt9sim.exe jt9.exe jt9code.exe
+all:    libjt9.a jt9sim.exe jt9.exe jt9code.exe jt65.exe
 
 OBJS1 = pctile.o graycode.o sort.o ssort.o \
 	unpackmsg.o igray.o unpackcall.o unpackgrid.o \
@@ -30,7 +30,7 @@
 	symspec.o analytic.o db.o genjt9.o \
 	packbits.o unpackbits.o encode232.o interleave9.o \
 	entail.o fano232.o gran.o sync9.o decode9.o \
-	fil3.o redsync.o decoder.o grid2n.o n2grid.o timer.o \
+	fil3.o decoder.o grid2n.o n2grid.o timer.o \
 	softsym.o getlags.o afc9.o fchisq.o twkfreq.o downsam9.o \
 	peakdt9.o symspec2.o stdmsg.o morse.o azdist.o geodist.o \
 	fillcom.o chkss2.o zplot9.o
@@ -54,16 +54,13 @@
 jt9code.exe: $(OBJS4) libjt9.a
 	$(FC) -o jt9code.exe $(OBJS4) libjt9.a
 
-OBJS5 = test9.o 
-test9.exe: $(OBJS5) libjt9.a 
-	$(FC) -o test9.exe $(OBJS5) libjt9.a ../libfftw3f_win.a
+OBJS5 = jt65.o jt65a.o symspec65.o flat65.o ccf65.o decode1a.o \
+	filbig.o fil6521.o afc65b.o decode65b.o s3avg.o setup65.o \
+	extract.o fchisq65.o demod64a.o chkhist.o interleave63.o ccf2.o \
+	move.o indexx.o
+jt65.exe: $(OBJS5) libjt9.a 
+	$(FC) -o jt65.exe $(OBJS5) libjt9.a ../libfftw3f_win.a
 
-OBJS6 = wsjt24d.o wsjt24.o sync24.o decode24.o ps24.o flat1.o \
-	xcor24.o slope.o peakup.o interleave24.o getmet24.o smo.o \
-	deep24.o encode4.o chkmsg.o avemsg4.o extract4.o
-wsjt24d.exe: $(OBJS6) libjt9.a 
-	$(FC) -o wsjt24d.exe $(OBJS6) libjt9.a ../libfftw3f_win.a
-
 INCPATH = -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/include/QtCore' \
 	 -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/include' \
 	 -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/include/ActiveQt' \
@@ -75,9 +72,6 @@
 spec9.o: spec9.f90 jt9sync.f90
 	$(FC) $(FFLAGS) -c spec9.f90
 
-peakdf9.o: peakdf9.f90 jt9sync.f90
-	$(FC) $(FFLAGS) -c peakdf9.f90
-
 peakdt9.o: peakdt9.f90 jt9sync.f90
 	$(FC) $(FFLAGS) -c peakdt9.f90
 
@@ -108,4 +102,4 @@
 .PHONY : clean
 
 clean:
-	rm -f *.o libjt9.a wsjtx.exe jt9sim.exe jt9.exe jt9test.exe
+	rm -f *.o libjt9.a wsjtx.exe jt9sim.exe jt9.exe jt65.exe

Added: branches/wsjtx_k1jt_p1/lib/afc65b.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/afc65b.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/afc65b.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,59 @@
+subroutine afc65b(cx,npts,fsample,nflip,a,ccfbest,dtbest)
+
+  complex cx(npts)
+  real a(5),deltaa(5)
+
+  a(1)=0.
+  a(2)=0.
+  a(3)=0.
+  a(4)=0.
+  deltaa(1)=2.0
+  deltaa(2)=2.0
+  deltaa(3)=2.0
+  deltaa(4)=0.05
+  nterms=3
+
+!  Start the iteration
+  chisqr=0.
+  chisqr0=1.e6
+  do iter=1,3                               !One iteration is enough?
+     do j=1,nterms
+        chisq1=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
+        fn=0.
+        delta=deltaa(j)
+10      a(j)=a(j)+delta
+        chisq2=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
+        if(chisq2.eq.chisq1) go to 10
+        if(chisq2.gt.chisq1) then
+           delta=-delta                      !Reverse direction
+           a(j)=a(j)+delta
+           tmp=chisq1
+           chisq1=chisq2
+           chisq2=tmp
+        endif
+20      fn=fn+1.0
+        a(j)=a(j)+delta
+        chisq3=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
+        if(chisq3.lt.chisq2) then
+           chisq1=chisq2
+           chisq2=chisq3
+           go to 20
+        endif
+
+! Find minimum of parabola defined by last three points
+        delta=delta*(1./(1.+(chisq1-chisq2)/(chisq3-chisq2))+0.5)
+        a(j)=a(j)-delta
+        deltaa(j)=deltaa(j)*fn/3.
+        write(*,4001) iter,j,a(1),a(2),a(3),chisq3,cx(10000)
+4001    format(2i4,4f10.4,2e12.3)
+     enddo
+     chisqr=fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
+     if(chisqr/chisqr0.gt.0.9999) go to 30
+     chisqr0=chisqr
+  enddo
+
+30 ccfbest=ccfmax * (1378.125/fsample)**2
+  dtbest=dtmax
+
+  return
+end subroutine afc65b

Added: branches/wsjtx_k1jt_p1/lib/ccf2.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/ccf2.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/ccf2.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,45 @@
+subroutine ccf2(ss,nz,nflip,ccfbest,lagpk)
+
+!      parameter (LAGMAX=60)
+  parameter (LAGMAX=200)
+  real ss(nz)
+  real ccf(-LAGMAX:LAGMAX)
+  integer npr(126)
+
+! The JT65 pseudo-random sync pattern:
+  data npr/                                    &amp;
+      1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0, &amp;
+      0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1, &amp;
+      0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1, &amp;
+      0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1, &amp;
+      1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1, &amp;
+      0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1, &amp;
+      1,1,1,1,1,1/
+  save
+
+  ccfbest=0.
+  lag1=-LAGMAX
+  lag2=LAGMAX
+  do lag=lag1,lag2
+     s0=0.
+     s1=0.
+     do i=1,126
+        j=2*(8*i + 43) + lag
+        if(j.ge.1 .and. j.le.nz-8) then
+           x=ss(j)+ss(j+8)             !Add two half-symbol contributions
+           if(npr(i).eq.0) then
+              s0=s0 + x
+           else
+              s1=s1 + x
+           endif
+        endif
+     enddo
+     ccf(lag)=nflip*(s1-s0)
+     if(ccf(lag).gt.ccfbest) then
+        ccfbest=ccf(lag)
+        lagpk=lag
+     endif
+  enddo
+
+  return
+end subroutine ccf2

Added: branches/wsjtx_k1jt_p1/lib/ccf65.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/ccf65.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/ccf65.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,119 @@
+subroutine ccf65(ss,nhsym,ssmax,sync1,dt1,flipk,syncshort,snr2,dt2)
+
+  parameter (NFFT=512,NH=NFFT/2)
+  real ss(322)                     !Input: half-symbol normalized powers
+  real s(NFFT)                     !CCF = ss*pr
+  complex cs(0:NH)                 !Complex FT of s
+  real s2(NFFT)                    !CCF = ss*pr2
+  complex cs2(0:NH)                !Complex FT of s2
+  real pr(NFFT)                    !JT65 pseudo-random sync pattern
+  complex cpr(0:NH)                !Complex FT of pr
+  real pr2(NFFT)                   !JT65 shorthand pattern
+  complex cpr2(0:NH)               !Complex FT of pr2
+  real tmp1(322)
+  real ccf(-11:54)
+  logical first
+  integer npr(126)
+  data first/.true./
+  equivalence (s,cs),(pr,cpr),(s2,cs2),(pr2,cpr2)
+  save
+
+! The JT65 pseudo-random sync pattern:
+  data npr/                                        &amp;
+      1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,     &amp;
+      0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,     &amp;
+      0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,     &amp;
+      0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,     &amp;
+      1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,     &amp;
+      0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,     &amp;
+      1,1,1,1,1,1/
+
+  if(first) then
+! Initialize pr, pr2; compute cpr, cpr2.
+     fac=1.0/NFFT
+     do i=1,NFFT
+        pr(i)=0.
+        pr2(i)=0.
+        k=2*mod((i-1)/8,2)-1
+        if(i.le.NH) pr2(i)=fac*k
+     enddo
+     do i=1,126
+        j=2*i
+        pr(j)=fac*(2*npr(i)-1)
+! Not sure why, but it works significantly better without the following line:
+!        pr(j-1)=pr(j)
+     enddo
+     call four2a(cpr,NFFT,1,-1,0)
+     call four2a(cpr2,NFFT,1,-1,0)
+     first=.false.
+  endif
+
+! Look for JT65 sync pattern and shorthand square-wave pattern.
+  ccfbest=0.
+  ccfbest2=0.
+  do i=1,nhsym-1
+     s(i)=min(ssmax,ss(i)+ss(i+1))
+!     s(i)=ss(i)+ss(i+1)
+  enddo
+
+  call pctile(s,nhsym-1,50,base)
+  s(1:nhsym-1)=s(1:nhsym-1)-base
+  s(nhsym:NFFT)=0.
+  call four2a(cs,NFFT,1,-1,0)               !Real-to-complex FFT
+  do i=0,NH
+     cs2(i)=cs(i)*conjg(cpr2(i))            !Mult by complex FFT of pr2
+     cs(i)=cs(i)*conjg(cpr(i))              !Mult by complex FFT of pr
+  enddo
+  call four2a(cs,NFFT,1,1,-1)               !Complex-to-real inv-FFT
+  call four2a(cs2,NFFT,1,1,-1)              !Complex-to-real inv-FFT
+
+  do lag=-11,54                             !Check for best JT65 sync
+     j=lag
+     if(j.lt.1) j=j+NFFT
+     ccf(lag)=s(j)
+     if(abs(ccf(lag)).gt.ccfbest) then
+        ccfbest=abs(ccf(lag))
+        lagpk=lag
+        flipk=1.0
+        if(ccf(lag).lt.0.0) flipk=-1.0
+     endif
+  enddo
+
+  do lag=-11,54                             !Check for best shorthand
+     ccf2=s2(lag+28)
+     if(ccf2.gt.ccfbest2) then
+        ccfbest2=ccf2
+        lagpk2=lag
+     endif
+  enddo
+
+! Find rms level on baseline of &quot;ccfblue&quot;, for normalization.
+  sum=0.
+  do lag=-11,54
+     if(abs(lag-lagpk).gt.1) sum=sum + ccf(lag)
+  enddo
+  base=sum/50.0
+  sq=0.
+  do lag=-11,54
+     if(abs(lag-lagpk).gt.1) sq=sq + (ccf(lag)-base)**2
+  enddo
+  rms=sqrt(sq/49.0)
+  sync1=ccfbest/rms - 4.0
+  dt1=lagpk*(2048.0/11025.0) - 2.5
+
+! Find base level for normalizing snr2.
+  do i=1,nhsym
+     tmp1(i)=ss(i)
+  enddo
+  call pctile(tmp1,nhsym,40,base)
+  snr2=0.398107*ccfbest2/base                !### empirical
+  syncshort=0.5*ccfbest2/rms - 4.0           !### better normalizer than rms?
+  dt2=(2.5 + lagpk2*(2048.0/11025.0))
+
+!  do i=-11,54
+!     write(74,3001) i,ccf(i)
+!3001 format(i6,f10.3)
+!  enddo
+
+  return
+end subroutine ccf65

Added: branches/wsjtx_k1jt_p1/lib/chkhist.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/chkhist.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/chkhist.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,23 @@
+subroutine chkhist(mrsym,nmax,ipk)
+
+  integer mrsym(63)
+  integer hist(0:63)
+
+  do i=0,63
+     hist(i)=0
+  enddo
+  do j=1,63
+     i=mrsym(j)
+     hist(i)=hist(i)+1
+  enddo
+
+  nmax=0
+  do i=0,63
+     if(hist(i).gt.nmax) then
+        nmax=hist(i)
+        ipk=i+1
+     endif
+  enddo
+
+  return
+end subroutine chkhist

Added: branches/wsjtx_k1jt_p1/lib/decode1a.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/decode1a.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/decode1a.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,118 @@
+subroutine decode1a(dd,npts,newdat,f0,nflip,mode65,nqd,nutc,ntol,     &amp;
+     sync2,a,dt,nkv,nhist,decoded)
+
+! Apply AFC corrections to a candidate JT65 signal, then decode it.
+
+  parameter (NMAX=60*12000)          !Samples per 60 s
+  real*4  dd(NMAX)                   !92 MB: raw data from Linrad timf2
+  complex cx(NMAX/8)                 !Data at 1378.125 samples/s
+  complex c5x(NMAX/32)               !Data at 344.53125 Hz
+  complex c5a(512)
+  complex z
+  real s2(66,126)
+  real s3(64,63)
+  real a(5)
+  logical first
+  character decoded*22
+  character mycall*12,hiscall*12,hisgrid*6
+  data first/.true./,jjjmin/1000/,jjjmax/-1000/
+  data nutc0/-999/,nhz0/-9999999/
+  save
+
+! Mix sync tone to baseband, low-pass filter, downsample to 1378.125 Hz
+  dt00=dt
+  call timer('filbig  ',0)
+  call filbig(dd,npts,f0,newdat,cx,n5)
+
+! NB: cx has sample rate 12000*77125/672000 = 1378.125 Hz
+  call timer('filbig  ',1)
+  sq0=0.
+  do i=1,n5
+     sq0=sq0 + real(cx(i))**2 + aimag(cx(i))**2
+  enddo
+  sq0=sq0/n5
+
+! Find best DF, f1, f2, and DT.  Start by downsampling to 344.53125 Hz
+  call timer('fil6521 ',0)
+! Add some zeros at start of c5 arrays -- empirical fix for negative DT's
+  nadd=1089
+  c5x(:nadd)=0.
+  call fil6521(cx,n5,c5x(nadd+1),n6)
+  n6=n6+nadd
+  call timer('fil6521 ',1)
+
+  fsample=1378.125/4.
+  a(5)=dt00
+  i0=nint((a(5)+0.5)*fsample) - 2 + nadd
+  if(i0.lt.1) then
+     write(13,*) 'i0 too small in decode1a:',i0,f0
+     flush(13)
+     i0=1
+  endif
+  nz=n6+1-i0
+
+! We're looking only at sync tone here... so why not downsample by another
+! factor of 1/8, say?  Should be a significant execution speed-up.
+  call timer('afc65b  ',0)
+! Best fit for DF, f1, and f2
+  call afc65b(c5x(i0),nz,fsample,nflip,a,ccfbest,dtbest)
+  call timer('afc65b  ',1)
+
+  sync2=3.7*ccfbest/sq0
+
+! Apply AFC corrections to the time-domain signal
+! Now we are back to using the 1378.125 Hz sample rate, enough to 
+! accommodate the full JT65C bandwidth.
+
+!  call timer('twkfreq ',0)
+!  call twkfreq(cx,cy,n5,a)
+!  call timer('twkfreq ',1)
+
+! Compute spectrum for each half symbol.
+! Adding or subtracting a small number (e.g., 5) to j may make it decode.\
+! NB: might want to try computing full-symbol spectra (nfft=512, even for
+! submodes B and C).
+
+  nsym=126
+  nfft=512
+  j=(dt00+dtbest+2.685)*1378.125
+  if(j.lt.0) j=0
+
+  call timer('sh_ffts ',0)
+! Perhaps should try full-symbol-length FFTs even in B, C sub-modes?
+! (Tried this, found no significant difference in decodes.)
+
+  do k=1,nsym
+!         do n=1,mode65
+     do n=1,1
+        do i=1,nfft
+           j=j+1
+           c5a(i)=cx(j)
+        enddo
+        call four2a(c5a,nfft,1,1,1)
+        if(n.eq.1) then
+           do i=1,66
+!                  s2(i,k)=real(c5a(i))**2 + aimag(c5a(i))**2
+              jj=i
+              if(mode65.eq.2) jj=2*i-1
+              if(mode65.eq.4) jj=4*i-3
+              s2(i,k)=real(c5a(jj))**2 + aimag(c5a(jj))**2
+           enddo
+        else
+           do i=1,66
+              s2(i,k)=s2(i,k) + real(c5a(i))**2 + aimag(c5a(i))**2
+           enddo
+        endif
+     enddo
+  enddo
+
+  call timer('sh_ffts ',1)
+
+  flip=nflip
+  call timer('dec65b  ',0)
+  call decode65b(s2,flip,mode65,nqd,nkv,nhist,decoded,s3)
+  dt=dt00 + dtbest + 1.7
+  call timer('dec65b  ',1)
+
+  return
+end subroutine decode1a

Added: branches/wsjtx_k1jt_p1/lib/decode65b.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/decode65b.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/decode65b.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,37 @@
+subroutine decode65b(s2,flip,mode65,nqd,nkv,nhist,decoded,s3)
+
+  real s2(66,126)
+  real s3(64,63)
+  logical first,ltext
+  character decoded*22
+  common/prcom/pr(126),mdat(126),mref(126,2),mdat2(126),mref2(126,2)
+  data first/.true./
+  save
+
+  if(first) call setup65
+  first=.false.
+
+  do j=1,63
+     k=mdat(j)                       !Points to data symbol
+     if(flip.lt.0.0) k=mdat2(j)
+     do i=1,64
+        s3(i,j)=s2(i+2,k)
+     enddo
+     k=mdat2(j)                       !Points to data symbol
+     if(flip.lt.0.0) k=mdat(j)
+  enddo
+
+  nadd=mode65
+  call extract(s3,nadd,ncount,nhist,decoded,ltext)     !Extract the message
+! Suppress &quot;birdie messages&quot; and other garbage decodes:
+  if(decoded(1:7).eq.'000AAA ') ncount=-1
+  if(decoded(1:7).eq.'0L6MWK ') ncount=-1
+  if(flip.lt.0.0 .and. ltext) ncount=-1
+  nkv=1
+  if(ncount.lt.0) then 
+     nkv=0
+     decoded='                      '
+  endif
+
+  return
+end subroutine decode65b

Added: branches/wsjtx_k1jt_p1/lib/demod64a.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/demod64a.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/demod64a.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,72 @@
+subroutine demod64a(s3,nadd,mrsym,mrprob,mr2sym,mr2prob,ntest,nlow)
+
+! Demodulate the 64-bin spectra for each of 63 symbols in a frame.
+
+! Parameters
+!    nadd     number of spectra already summed
+!    mrsym    most reliable symbol value
+!    mr2sym   second most likely symbol value
+!    mrprob   probability that mrsym was the transmitted value
+!    mr2prob  probability that mr2sym was the transmitted value
+
+  implicit real*8 (a-h,o-z)
+  real*4 s3(64,63)
+  real*8 fs(64)
+  integer mrsym(63),mrprob(63),mr2sym(63),mr2prob(63)
+  common/mrscom/ mrs(63),mrs2(63)
+
+  afac=1.1 * float(nadd)**0.64
+  scale=255.999
+
+! Compute average spectral value
+  sum=0.
+  do j=1,63
+     do i=1,64
+        sum=sum+s3(i,j)
+     enddo
+  enddo
+  ave=sum/(64.*63.)
+  i1=1                                      !Silence warning
+  i2=1
+
+! Compute probabilities for most reliable symbol values
+  do j=1,63
+     s1=-1.e30
+     fsum=0.
+     do i=1,64
+        x=min(afac*s3(i,j)/ave,50.d0)
+        fs(i)=exp(x)
+        fsum=fsum+fs(i)
+        if(s3(i,j).gt.s1) then
+           s1=s3(i,j)
+           i1=i                              !Most reliable
+        endif
+     enddo
+
+     s2=-1.e30
+     do i=1,64
+        if(i.ne.i1 .and. s3(i,j).gt.s2) then
+           s2=s3(i,j)
+           i2=i                              !Second most reliable
+        endif
+     enddo
+     p1=fs(i1)/fsum                          !Normalized probabilities
+     p2=fs(i2)/fsum
+     mrsym(j)=i1-1
+     mr2sym(j)=i2-1
+     mrprob(j)=scale*p1
+     mr2prob(j)=scale*p2
+     mrs(j)=i1
+     mrs2(j)=i2
+  enddo
+
+  sum=0.
+  nlow=0
+  do j=1,63
+     sum=sum+mrprob(j)
+     if(mrprob(j).le.5) nlow=nlow+1
+  enddo
+  ntest=sum/63
+
+  return
+end subroutine demod64a

Added: branches/wsjtx_k1jt_p1/lib/extract.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/extract.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/extract.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,108 @@
+subroutine extract(s3,nadd,ncount,nhist,decoded,ltext)
+
+  real s3(64,63)
+  real tmp(4032)
+  character decoded*22
+  integer era(51),dat4(12),indx(64)
+  integer mrsym(63),mr2sym(63),mrprob(63),mr2prob(63)
+  logical first,ltext
+  data first/.true./,nsec1/0/
+  save
+
+  nfail=0
+1 continue
+!      call timer('demod64a',0)
+  call demod64a(s3,nadd,mrsym,mrprob,mr2sym,mr2prob,ntest,nlow)
+!      call timer('demod64a',1)
+  if(ntest.lt.50 .or. nlow.gt.20) then
+     ncount=-999                         !Flag bad data
+     go to 900
+  endif
+  call chkhist(mrsym,nhist,ipk)
+
+  if(nhist.ge.20) then
+     nfail=nfail+1
+     call pctile(s3,tmp,4032,50,base)     ! ### or, use ave from demod64a
+     do j=1,63
+        s3(ipk,j)=base
+     enddo
+     if(nfail.gt.30) then
+        decoded='                      '
+        ncount=-1
+        go to 900
+     endif
+     go to 1
+  endif
+
+  call graycode(mrsym,63,-1)
+  call interleave63(mrsym,-1)
+  call interleave63(mrprob,-1)
+
+  ndec=1
+  nemax=30                              !Was 200 (30)
+  maxe=8
+  xlambda=13.0                          !Was 12
+  
+  if(ndec.eq.1) then
+     call graycode(mr2sym,63,-1)
+     call interleave63(mr2sym,-1)
+     call interleave63(mr2prob,-1)
+
+     nsec1=nsec1+1
+     write(22,rec=1) nsec1,xlambda,maxe,200,mrsym,mrprob,mr2sym,mr2prob
+     call flush(22)
+!         call timer('kvasd   ',0)
+!#ifdef UNIX
+!     iret=system('./kvasd -q &gt; dev_null')
+!#else
+     iret=system('kvasd -q &gt; dev_null')
+!#endif
+!         call timer('kvasd   ',1)
+     if(iret.ne.0) then
+        if(first) write(*,1000) iret
+1000    format('Error in KV decoder, or no KV decoder present.'/        &amp;
+             'Return code:',i8,'.  Will use BM algorithm.')
+        ndec=0
+        first=.false.
+        go to 20
+     endif
+
+     read(22,rec=2) nsec2,ncount,dat4
+     j=nsec2                !Silence compiler warning
+     decoded='                      '
+     ltext=.false.
+     if(ncount.ge.0) then
+        call unpackmsg(dat4,decoded)     !Unpack the user message
+        if(iand(dat4(10),8).ne.0) ltext=.true.
+        do i=2,12
+           if(dat4(i).ne.dat4(1)) go to 20
+        enddo
+        write(13,*) 'Bad decode?',nhist,nfail,ipk,' ',dat4,decoded
+        ncount=-1           !Suppress supposedly bogus decodes
+        decoded='                      '
+     endif
+  endif
+20 if(ndec.eq.0) then
+     call indexx(63,mrprob,indx)
+     do i=1,nemax
+        j=indx(i)
+        if(mrprob(j).gt.120) then
+           ne2=i-1
+           go to 2
+        endif
+        era(i)=j-1
+     enddo
+     ne2=nemax
+2    decoded='                      '
+     print*,'BM decoder being called'
+!     do nerase=0,ne2,2
+!        call rs_decode(mrsym,era,nerase,dat4,ncount)
+!        if(ncount.ge.0) then
+!           call unpackmsg(dat4,decoded)
+!           go to 900
+!        endif
+!     enddo
+  endif
+
+900 return
+end subroutine extract

Added: branches/wsjtx_k1jt_p1/lib/fchisq65.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/fchisq65.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/fchisq65.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,68 @@
+real function fchisq65(cx,npts,fsample,nflip,a,ccfmax,dtmax)
+
+  parameter (NMAX=60*12000)          !Samples per 60 s
+  complex cx(npts)
+  real a(5)
+  complex w,wstep,za,zb,z
+  real ss(3000)
+  complex csx(0:NMAX/8)
+  data twopi/6.283185307/a1,a2,a3/99.,99.,99./
+  save
+
+  call timer('fchisq65',0)
+  baud=11025.0/4096.0
+  nsps=nint(fsample/baud)                  !Samples per symbol
+  nsph=nsps/2                              !Samples per half-symbol
+  ndiv=16                                  !Output ss() steps per symbol
+  nout=ndiv*npts/nsps
+  dtstep=1.0/(ndiv*baud)                   !Time per output step
+
+  if(a(1).ne.a1 .or. a(2).ne.a2 .or. a(3).ne.a3) then
+     a1=a(1)
+     a2=a(2)
+     a3=a(3)
+
+! Mix and integrate the complex signal
+     csx(0)=0.
+     w=1.0
+     x0=0.5*(npts+1)
+     s=2.0/npts
+     do i=1,npts
+        x=s*(i-x0)
+        if(mod(i,100).eq.1) then
+           p2=1.5*x*x - 0.5
+           dphi=(a(1) + x*a(2) + p2*a(3)) * (twopi/fsample)
+           wstep=cmplx(cos(dphi),sin(dphi))
+        endif
+        w=w*wstep
+        csx(i)=csx(i-1) + w*cx(i)
+     enddo
+  endif
+
+! Compute 1/2-symbol powers at 1/16-symbol steps.
+  fac=1.e-4
+  
+  do i=1,nout
+     j=i*nsps/ndiv
+     k=j-nsph
+     ss(i)=0.
+     if(k.ge.1) then
+        z=csx(j)-csx(k)
+        ss(i)=fac*(real(z)**2 + aimag(z)**2)
+     endif
+  enddo
+
+  ccfmax=0.
+  call timer('ccf2    ',0)
+  call ccf2(ss,nout,nflip,ccf,lagpk)
+  call timer('ccf2    ',1)
+  if(ccf.gt.ccfmax) then
+     ccfmax=ccf
+     dtmax=lagpk*dtstep
+  endif
+  fchisq65=-ccfmax
+
+  call timer('fchisq65',1)
+
+  return
+end function fchisq65

Added: branches/wsjtx_k1jt_p1/lib/fil6521.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/fil6521.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/fil6521.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,44 @@
+subroutine fil6521(c1,n1,c2,n2)
+
+! FIR lowpass filter designed using ScopeFIR
+
+!                  Pass #1   Pass #2  
+! -----------------------------------------------
+! fsample    (Hz)  1378.125   Input sample rate
+! Ntaps            21         Number of filter taps
+! fc         (Hz)  40         Cutoff frequency
+! fstop      (Hz)  172.266    Lower limit of stopband
+! Ripple     (dB)  0.1        Ripple in passband
+! Stop Atten (dB)  38         Stopband attenuation
+! fout       (Hz)  344.531    Output sample rate
+
+  parameter (NTAPS=21)
+  parameter (NH=NTAPS/2)
+  parameter (NDOWN=4)                !Downsample ratio = 1/4
+  complex c1(n1)
+  complex c2(n1/NDOWN)
+
+! Filter coefficients:
+  real a(-NH:NH)
+  data a/                                                                &amp;
+       -0.011958606980,-0.013888627387,-0.015601306443,-0.010602249570,  &amp;
+        0.003804023436, 0.028320058273, 0.060903935217, 0.096841904411,  &amp;
+        0.129639871228, 0.152644580853, 0.160917511283, 0.152644580853,  &amp;
+        0.129639871228, 0.096841904411, 0.060903935217, 0.028320058273,  &amp;
+        0.003804023436,-0.010602249570,-0.015601306443,-0.013888627387,  &amp;
+       -0.011958606980/
+
+  n2=(n1-NTAPS+NDOWN)/NDOWN
+  k0=NH-NDOWN+1
+
+! Loop over all output samples
+  do i=1,n2
+     c2(i)=0.
+     k=k0 + NDOWN*i
+     do j=-NH,NH
+        c2(i)=c2(i) + c1(j+k)*a(j)
+     enddo
+  enddo
+
+  return
+end subroutine fil6521

Added: branches/wsjtx_k1jt_p1/lib/filbig.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/filbig.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/filbig.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,120 @@
+subroutine filbig(dd,npts,f0,newdat,c4a,n4)
+
+! Filter and real data in array dd(npts), sampled at 12000 Hz.
+! Output is complex, sampled at 1375.125 Hz.
+
+  parameter (NFFT1=672000,NFFT2=77175)
+  real*4  dd(npts)                           !Input data
+  complex ca(NFFT1)                          !FFT of input
+  complex c4a(NFFT2)                         !Output data
+  real*8 df
+  real halfpulse(8)                 !Impulse response of filter (one sided)
+  complex cfilt(NFFT2)                       !Filter (complex; imag = 0)
+  real rfilt(NFFT2)                          !Filter (real)
+  integer*8 plan1,plan2,plan3
+  logical first
+  include 'fftw3.f90'
+  equivalence (rfilt,cfilt)
+  data first/.true./,npatience/1/
+  data halfpulse/114.97547150,36.57879257,-20.93789101,              &amp;
+       5.89886379,1.59355187,-2.49138308,0.60910773,-0.04248129/
+  save
+
+  if(npts.lt.0) go to 900
+
+  if(first) then
+     nflags=FFTW_ESTIMATE
+     if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
+     if(npatience.eq.2) nflags=FFTW_MEASURE
+     if(npatience.eq.3) nflags=FFTW_PATIENT
+     if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
+! Plan the FFTs just once
+     call timer('FFTplans ',0)
+     call sfftw_plan_dft_1d(plan1,nfft1,ca,ca,FFTW_BACKWARD,nflags)
+     call sfftw_plan_dft_1d(plan2,nfft2,c4a,c4a,FFTW_FORWARD,nflags)
+     call sfftw_plan_dft_1d(plan3,nfft2,cfilt,cfilt,FFTW_BACKWARD,nflags)
+     call timer('FFTplans ',1)
+
+! Convert impulse response to filter function
+     do i=1,nfft2
+        cfilt(i)=0.
+     enddo
+     fac=0.00625/nfft1
+     cfilt(1)=fac*halfpulse(1)
+     do i=2,8
+        cfilt(i)=fac*halfpulse(i)
+        cfilt(nfft2+2-i)=fac*halfpulse(i)
+     enddo
+     call timer('FFTfilt ',0)
+     call sfftw_execute(plan3)
+     call timer('FFTfilt ',1)
+
+     base=cfilt(nfft2/2+1)
+     do i=1,nfft2
+        rfilt(i)=real(cfilt(i))-base
+     enddo
+
+     df=12000.d0/nfft1
+     first=.false.
+  endif
+
+! When new data comes along, we need to compute a new &quot;big FFT&quot;
+! If we just have a new f0, continue with the existing ca and cb.
+
+  if(newdat.ne.0) then
+     nz=min(npts,nfft1)
+     ca(1:nz)=dd(1:nz)
+     ca(nz+1:)=0.                   !### Should change this to r2c FFT ###
+     call timer('FFTbig  ',0)
+     call sfftw_execute(plan1)
+     call timer('FFTbig  ',1)
+!###
+!     nadd=50
+!     iz=NFFT1/(2*nadd)
+!     df=nadd*12000.0/NFFT1
+!     k=0
+!     do i=1,iz
+!        ss=0.
+!        do j=1,nadd
+!           k=k+1
+!           ss=ss + real(ca(k))**2 + aimag(ca(k))**2
+!        enddo
+!        write(81,3001) i*df,ss,db(ss)
+!3001    format(f12.3,e12.3,f12.3)
+!     enddo
+!###        
+     newdat=0
+  endif
+
+! NB: f0 is the frequency at which we want our filter centered.
+!     i0 is the bin number in ca and cb closest to f0.
+
+  i0=nint(f0/df) + 1
+  nh=nfft2/2
+  do i=1,nh                                !Copy data into c4a and c4b,
+     j=i0+i-1                              !and apply the filter function
+     if(j.ge.1 .and. j.le.nfft1) then
+        c4a(i)=rfilt(i)*ca(j)
+     else
+        c4a(i)=0.
+     endif
+  enddo
+  do i=nh+1,nfft2
+     j=i0+i-1-nfft2
+     if(j.lt.1) j=j+nfft1                  !nfft1 was nfft2
+     c4a(i)=rfilt(i)*ca(j)
+  enddo
+
+! Do the short reverse transform, to go back to time domain.
+  call timer('FFTsmall',0)
+  call sfftw_execute(plan3)
+  call timer('FFTsmall',1)
+  n4=min(npts/8,nfft2)
+  return
+
+900 call sfftw_destroy_plan(plan1)
+  call sfftw_destroy_plan(plan2)
+  call sfftw_destroy_plan(plan3)
+  
+  return
+end subroutine filbig

Added: branches/wsjtx_k1jt_p1/lib/flat65.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/flat65.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/flat65.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,25 @@
+subroutine flat65(ss,nhsym,maxhsym,nsz,ref)
+
+  real stmp(nsz)
+  real ss(maxhsym,nsz)
+  real ref(nsz)
+
+  npct=28                                       !Somewhat arbitrary
+  do i=1,nsz
+     call pctile(ss(1,i),nhsym,npct,stmp(i))
+  enddo
+
+  nsmo=33
+  ia=nsmo/2 + 1
+  ib=nsz - nsmo/2 - 1
+  do i=ia,ib
+     call pctile(stmp(i-nsmo/2),nsmo,npct,ref(i))
+  enddo
+  ref(:ia-1)=ref(ia)
+  ref(ib+1:)=ref(ib)
+  ref=4.0*ref
+
+  return
+end subroutine flat65
+
+      

Added: branches/wsjtx_k1jt_p1/lib/interleave63.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/interleave63.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/interleave63.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,25 @@
+subroutine interleave63(d1,idir)
+
+! Interleave (idir=1) or de-interleave (idir=-1) the array d1.
+
+  integer d1(0:6,0:8)
+  integer d2(0:8,0:6)
+
+  if(idir.ge.0) then
+     do i=0,6
+        do j=0,8
+           d2(j,i)=d1(i,j)
+        enddo
+     enddo
+     call move(d2,d1,63)
+  else
+     call move(d1,d2,63)
+     do i=0,6
+        do j=0,8
+           d1(i,j)=d2(j,i)
+        enddo
+     enddo
+  endif
+         
+  return
+end subroutine interleave63

Added: branches/wsjtx_k1jt_p1/lib/jt65.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/jt65.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/jt65.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,61 @@
+program jt65
+
+! Test the JT65 decoder for WSJT-X
+
+  parameter (NZMAX=60*12000)
+  integer*4 ihdr(11)
+  integer*2 id2(NZMAX)
+  real*4 dd(NZMAX)
+  character*80 infile,infile0
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata
+  common/tracer/limtrace,lu
+  equivalence (ariff,ihdr)
+
+  nargs=iargc()
+  if(nargs.lt.1) then
+     print*,'Usage: jt65 &lt;infile&gt;'
+     go to 999
+  endif
+  call getarg(1,infile0)
+  limtrace=0
+  lu=12
+
+  newdat=1
+  ntol=50
+  nfa=500
+  nfb=2500
+  mousefqso=1500
+  nagain=0
+  ndiskdat=1
+
+  open(12,file='timer.out',status='unknown')
+  open(22,file='kvasd.dat',access='direct',recl=1024,status='unknown')
+
+  call timer('jt9     ',0)
+
+  infile='/users/joe/wsjt_k1jt/wsjtx_install/save/'//infile0
+  open(10,file=infile,access='stream',status='old',err=998)
+  read(10) ihdr
+  nutc=ihdr(1)                           !Silence compiler warning
+  i1=index(infile0,'.wav')
+  read(infile0(i1-4:i1-1),*,err=1) nutc
+  go to 2
+1 nutc=0
+2 npts=52*12000
+  read(10) id2(1:npts)
+  dd(1:npts)=id2(1:npts)
+  dd(npts+1:)=0.
+
+  call jt65a(dd,npts,newdat,nutc,ntol,nfa,nfb,mousefqso,nagain,ndiskdat)
+
+  call timer('jt9     ',1)
+  call timer('jt9     ',101)
+  go to 999
+
+998 print*,'Cannot open file:'
+  print*,infile
+
+999 end program jt65

Added: branches/wsjtx_k1jt_p1/lib/jt65a.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/jt65a.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/jt65a.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,92 @@
+subroutine jt65a(dd,npts,newdat,nutc,ntol,nfa,nfb,nfqso,nagain,ndiskdat)
+
+!  Process id2() data to find and decode JT65 signals.
+
+  parameter (NSZ=3413)
+  parameter (NZMAX=60*12000)
+  parameter (NFFT=8192)              !### ??? ###
+  real dd(NZMAX)
+  real*4 ss(322,NSZ),savg(NSZ)
+  real tavg(-50:50)                  !Temp for finding local base level
+  real tmp (200)                     !Temp storage for pctile sorting
+  real a(5)
+  character decoded*22,blank*22
+  data blank/'                      '/
+  save
+
+  call symspec65(dd,npts,ss,nhsym,savg)    !Get normalized symbol spectra
+
+  df=12000.0/NFFT                     !df = 12000.0/16384 = 0.732 Hz
+  ftol=10.0                           !Frequency tolerance (Hz)
+  fqso=nfqso                      !fqso at baseband (Hz)
+  mode65=1
+
+  do nqd=0,0,-1
+     if(nqd.eq.1) then                     !Quick decode, at fQSO
+        fa=nfqso - ntol
+        fb=nfqso + ntol
+     else                                  !Wideband decode at all freqs
+        fa=500.0
+        fb=2500.0
+     endif
+     ia=max(51,nint(fa/df))
+     ib=min(NSZ-51,nint(fb/df))
+
+     freq0=-999.
+     sync10=-999.
+     thresh0=1.5
+
+     ia=641
+     ib=641
+
+     do i=ia,ib                               !Search over freq range
+        freq=i*df
+        if(savg(i).lt.thresh0) cycle
+
+        call timer('ccf65   ',0)
+        call ccf65(ss(1,i),nhsym,savg(i),sync1,dt,flipk,syncshort,snr2,dt2)
+        call timer('ccf65   ',1)
+
+!        write(73,3003) i,freq,savg(i),sync1,dt,flipk
+!3003    format(i6,5f9.2)
+!        if(ia.gt.0) cycle
+
+! ########################### Search for Shorthand Messages #################
+!  include 'shorthand1.f90'
+
+! ########################### Search for Normal Messages ###########
+        thresh1=1.0
+!  Use lower thresh1 at fQSO
+        if(nqd.eq.1 .and. ntol.le.100) thresh1=0.
+!  Is sync1 above threshold?
+        if(sync1.lt.thresh1 .or. abs(noffset).gt.ntol) cycle
+
+!  Keep only the best candidate within ftol.
+        if(freq-freq0.lt.ftol .or. sync1.lt.sync10) cycle
+        nflip=nint(flipk)
+        f00=i*df                   !Freq of detected sync tone (0-5000 Hz)
+
+        call timer('decode1a',0)
+        call decode1a(dd,npts,newdat,f00,nflip,mode65,nqd,   &amp;
+             nutc,ntol,sync2,a,dt,nkv,nhist,decoded)
+        call timer('decode1a',1)
+
+        nfreq=nint(freq)
+        nsync1=sync1
+
+        s2db=10.0*log10(sync2) - 40             !### empirical ###
+        nsync2=nint(s2db)
+        if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
+             decoded(1:4).eq.'73  ') nsync2=nint(1.33*s2db + 2.0)
+
+        write(*,1010) nutc,nsync2,dt,nfreq,decoded,nflip,newdat
+1010    format(i4.4,i6,f6.1,i6,2x,a22,3x,2i3)
+     enddo
+     if(nagain.eq.1) go to 999
+  enddo
+
+999 close(23)
+  nagain=0
+
+  return
+end subroutine jt65a

Added: branches/wsjtx_k1jt_p1/lib/move.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/move.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/move.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,7 @@
+subroutine move(x,y,n)
+  real x(n),y(n)
+  do i=1,n
+     y(i)=x(i)
+  enddo
+  return
+end subroutine move

Added: branches/wsjtx_k1jt_p1/lib/s3avg.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/s3avg.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/s3avg.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,60 @@
+subroutine s3avg(nsave,mode65,nutc,nhz,xdt,npol,ntol,s3,nsum,nkv,decoded)
+
+! Save the current synchronized spectra, s3(64,63), for possible
+! decoding of average.
+
+  real s3(64,63)                        !Synchronized spectra for 63 symbols
+  real s3a(64,63,64)                    !Saved spectra
+  real s3b(64,63)                       !Average spectra
+  integer iutc(64),ihz(64),ipol(64)
+  real dt(64)
+  character*22 decoded
+  logical ltext,first
+  data first/.true./
+  save
+
+  if(first) then
+     iutc=-1
+     ihz=0
+     ipol=0
+     first=.false.
+     ihzdiff=min(100,ntol)
+     dtdiff=0.2
+  endif
+
+  do i=1,64
+     if(nutc.eq.iutc(i) .and. abs(nhz-ihz(i)).lt.ihzdiff) then
+        nsave=mod(nsave-1+64,64)+1
+        go to 10
+     endif
+  enddo
+  
+  iutc(nsave)=nutc                          !Save UTC
+  ihz(nsave)=nhz                            !Save freq in Hz
+  ipol(nsave)=npol                          !Save pol
+  dt(nsave)=xdt                             !Save DT
+  s3a(1:64,1:63,nsave)=s3                   !Save the spectra
+
+10 s3b=0.
+  do i=1,64                                 !Accumulate avg spectra
+     if(iutc(i).lt.0) cycle
+     if(mod(iutc(i),2).ne.mod(nutc,2)) cycle !Use only same sequence
+     if(abs(nhz-ihz(i)).gt.ihzdiff) cycle   !Freq must match
+     if(abs(xdt-dt(i)).gt.dtdiff) cycle     !DT must match
+     s3b=s3b + s3a(1:64,1:63,i)
+     nsum=nsum+1
+  enddo
+ 
+  decoded='                      '
+  if(nsum.ge.2) then                        !Try decoding the sverage
+     nadd=mode65*nsum
+     call extract(s3b,nadd,ncount,nhist,decoded,ltext)     !Extract the message
+     nkv=nsum
+     if(ncount.lt.0) then 
+        nkv=0
+        decoded='                      '
+     endif
+  endif
+
+  return
+end subroutine s3avg

Added: branches/wsjtx_k1jt_p1/lib/setup65.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/setup65.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/setup65.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,96 @@
+subroutine setup65
+
+! Defines arrays related to the JT65 pseudo-random synchronizing pattern.
+! Executed at program start.
+
+  integer nprc(126)
+  common/prcom/pr(126),mdat(126),mref(126,2),mdat2(126),mref2(126,2)
+
+! JT65
+  data nprc/                                   &amp;
+      1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0, &amp;
+      0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1, &amp;
+      0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1, &amp;
+      0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1, &amp;
+      1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1, &amp;
+      0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1, &amp;
+      1,1,1,1,1,1/
+  data mr2/0/                !Silence compiler warning
+
+! Put the appropriate pseudo-random sequence into pr
+  nsym=126
+  do i=1,nsym
+     pr(i)=2*nprc(i)-1
+  enddo
+
+! Determine locations of data and reference symbols
+  k=0
+  mr1=0
+  do i=1,nsym
+     if(pr(i).lt.0.0) then
+        k=k+1
+        mdat(k)=i
+     else
+        mr2=i
+        if(mr1.eq.0) mr1=i
+     endif
+  enddo
+  nsig=k
+
+! Determine the reference symbols for each data symbol.
+  do k=1,nsig
+     m=mdat(k)
+     mref(k,1)=mr1
+     do n=1,10                     !Get ref symbol before data
+        if((m-n).gt.0) then
+           if (pr(m-n).gt.0.0) go to 10
+        endif
+     enddo
+     go to 12
+10   mref(k,1)=m-n
+12   mref(k,2)=mr2
+     do n=1,10                     !Get ref symbol after data
+        if((m+n).le.nsym) then
+           if (pr(m+n).gt.0.0) go to 20
+        endif
+     enddo
+     go to 22
+20   mref(k,2)=m+n
+22 enddo
+
+! Now do it all again, using opposite logic on pr(i)
+  k=0
+  mr1=0
+  do i=1,nsym
+     if(pr(i).gt.0.0) then
+        k=k+1
+        mdat2(k)=i
+     else
+        mr2=i
+        if(mr1.eq.0) mr1=i
+     endif
+  enddo
+  nsig=k
+
+  do k=1,nsig
+     m=mdat2(k)
+     mref2(k,1)=mr1
+     do n=1,10
+        if((m-n).gt.0) then
+           if (pr(m-n).lt.0.0) go to 110
+        endif
+     enddo
+     go to 112
+110  mref2(k,1)=m-n
+112  mref2(k,2)=mr2
+     do n=1,10
+        if((m+n).le.nsym) then
+           if (pr(m+n).lt.0.0) go to 120
+        endif
+     enddo
+     go to 122
+120  mref2(k,2)=m+n
+122 enddo
+
+  return
+end subroutine setup65

Added: branches/wsjtx_k1jt_p1/lib/symspec65.f90
===================================================================
--- branches/wsjtx_k1jt_p1/lib/symspec65.f90	                        (rev 0)
+++ branches/wsjtx_k1jt_p1/lib/symspec65.f90	2013-06-07 20:09:15 UTC (rev 3351)
@@ -0,0 +1,52 @@
+subroutine symspec65(dd,npts,ss,nhsym,savg)
+
+  parameter (NFFT=8192)
+  parameter (NSZ=3413)                         !NFFT*5000/12000
+  parameter (MAXHSYM=322)
+  real*8 hstep
+  real*4 dd(npts)
+  real*4 ss(MAXHSYM,NSZ)
+  real*4 savg(NSZ)
+  real*4 ref(NSZ)
+  real*4 x(NFFT)
+  complex c(0:NFFT/2)
+  equivalence (x,c)
+
+  hstep=2048.d0*12000.d0/11025.d0              !half-symbol = 2229.116 samples
+  nsps=nint(2*hstep)
+  df=12000.0/NFFT
+  nhsym=npts/hstep - 1.0
+  savg=0.
+  fac1=1.e-3
+
+  do j=1,nhsym
+     i0=(j-1)*hstep
+     x(1:nsps)=fac1*dd(i0+1:i0+nsps)
+     x(nsps+1:)=0.
+     call four2a(c,NFFT,1,-1,0)                !r2c forward FFT
+     do i=1,NSZ
+        s=real(c(i))**2 + aimag(c(i))**2
+        ss(j,i)=s
+        savg(i)=savg(i)+s
+     enddo
+  enddo
+  savg=savg/nhsym
+
+  call flat65(ss,nhsym,MAXHSYM,NSZ,ref)
+
+!  do i=1,NSZ
+!     write(71,3001) i*df,savg(i),db(savg(i)),ref(i),db(ref(i))
+!3001 format(5f15.3)
+!  enddo
+
+  savg=savg/ref
+  do j=1,nhsym
+     ss(j,1:NSZ)=ss(j,1:NSZ)/ref
+  enddo
+
+!  do i=1,NSZ
+!     write(72,3001) i*df,savg(i),db(savg(i))
+!  enddo
+
+  return
+end subroutine symspec65

Modified: branches/wsjtx_k1jt_p1/mainwindow.cpp
===================================================================
--- branches/wsjtx_k1jt_p1/mainwindow.cpp	2013-06-06 23:08:01 UTC (rev 3350)
+++ branches/wsjtx_k1jt_p1/mainwindow.cpp	2013-06-07 20:09:15 UTC (rev 3351)
@@ -1324,7 +1324,6 @@
 {
   while(proc_jt9.canReadLine()) {
     QByteArray t=proc_jt9.readLine();
-    qDebug() &lt;&lt; &quot;A&quot; &lt;&lt; t;
     if(t.indexOf(&quot;&lt;DecodeFinished&gt;&quot;) &gt;= 0) {
       m_bsynced = (t.mid(19,1).toInt()==1);
       m_bdecoded = (t.mid(23,1).toInt()==1);
@@ -1370,8 +1369,6 @@
         m_blankLine=false;
       }
 
-      qDebug() &lt;&lt; &quot;B&quot;;
-
       QString bg=&quot;white&quot;;
       if(t.indexOf(&quot; CQ &quot;)&gt;0) bg=&quot;#66ff66&quot;;                          //green
       if(m_myCall!=&quot;&quot; and t.indexOf(&quot; &quot;+m_myCall+&quot; &quot;)&gt;0) bg=&quot;#ff6666&quot;; //red
@@ -1391,8 +1388,6 @@
         m_QSOmsg=t1;
       }
 
-      qDebug() &lt;&lt; &quot;C&quot;;
-
       if(jt9com_.nagain==0) {
         if(t.indexOf(&quot; CQ &quot;)&gt;0) bg=&quot;#66ff66&quot;;                          //green
         if(m_myCall!=&quot;&quot; and t.indexOf(&quot; &quot;+m_myCall+&quot; &quot;)&gt;0) bg=&quot;#ff6666&quot;; //red
@@ -1406,8 +1401,6 @@
         ui-&gt;decodedTextBrowser-&gt;setTextCursor(cursor);
       }
 
-      qDebug() &lt;&lt; &quot;D&quot;;
-
       QString msg=t.mid(34);
       int i1=msg.indexOf(&quot;\r&quot;);
       if(i1&gt;0) msg=msg.mid(0,i1-1) + &quot;                      &quot;;
@@ -1433,8 +1426,6 @@
       int nsec=QDateTime::currentMSecsSinceEpoch()/1000-m_secBandChanged;
       bool okToPost=(nsec&gt;50);
 
-      qDebug() &lt;&lt; &quot;E&quot;;
-
 #ifdef WIN32
       if(m_pskReporterInit and b and !m_diskData and okToPost) {
         int i1=msg.indexOf(&quot; &quot;);
@@ -1457,7 +1448,6 @@
             &quot;my_gridsquare#&quot; + m_myGrid + &quot;#&quot;;
         if(m_pskAntenna!=&quot;&quot;) local += &quot;my_antenna#&quot; + m_pskAntenna + &quot;#&quot;;
         local += &quot;programid#WSJT-X#programversion#&quot; + rev.mid(6,4) + &quot;##&quot;;
-        qDebug() &lt;&lt; &quot;F: &quot; &lt;&lt; local;
         wchar_t tlocal[256];
         local.toWCharArray(tlocal);
 
@@ -1996,8 +1986,6 @@
   if(ui-&gt;dxGridEntry-&gt;text()==&quot;&quot;) lookup();
   m_hisGrid=ui-&gt;dxGridEntry-&gt;text();
 
-  qDebug() &lt;&lt; &quot;A&quot; &lt;&lt; ui-&gt;dxGridEntry-&gt;text();
-
   int n = 60*t2.mid(0,2).toInt() + t2.mid(2,2).toInt();
   int nmod=n%(m_TRperiod/30);
   m_txFirst=(nmod!=0);

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003042.html">[WSJT-SVN] r3350 - branches/wsjtx_k1jt_p1
</A></li>
	<LI>Next message: <A HREF="003043.html">[WSJT-SVN] r3352 - branches/wsjtx_k1jt_p1/lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3044">[ date ]</a>
              <a href="thread.html#3044">[ thread ]</a>
              <a href="subject.html#3044">[ subject ]</a>
              <a href="author.html#3044">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
