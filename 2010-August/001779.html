<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2087 - in wsjt7a: . WsjtMod
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2010-August/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2087%20-%20in%20wsjt7a%3A%20.%20WsjtMod&In-Reply-To=%3C20100805181240.D06CE480EFA%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001778.html">
   <LINK REL="Next"  HREF="001780.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2087 - in wsjt7a: . WsjtMod</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2087%20-%20in%20wsjt7a%3A%20.%20WsjtMod&In-Reply-To=%3C20100805181240.D06CE480EFA%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r2087 - in wsjt7a: . WsjtMod">k1jt at mail.berlios.de
       </A><BR>
    <I>Thu Aug  5 20:12:40 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001778.html">[WSJT-SVN] r2086 - wsjt7a/WsjtMod
</A></li>
        <LI>Next message: <A HREF="001780.html">[WSJT-SVN] r2088 - wsjt7a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1779">[ date ]</a>
              <a href="thread.html#1779">[ thread ]</a>
              <a href="subject.html#1779">[ subject ]</a>
              <a href="author.html#1779">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2010-08-05 20:12:40 +0200 (Thu, 05 Aug 2010)
New Revision: 2087

Added:
   wsjt7a/tmoonsub.c
Modified:
   wsjt7a/CALL3.TXT
   wsjt7a/Makefile.MinGW
   wsjt7a/Makefile.in
   wsjt7a/WsjtMod/astro.py
   wsjt7a/WsjtMod/options.py
   wsjt7a/astro.f
   wsjt7a/astro0.f90
   wsjt7a/gen24.f
   wsjt7a/gen65.f
   wsjt7a/iscat.f90
   wsjt7a/jtms.f90
   wsjt7a/sun.f
   wsjt7a/wsjt.py
   wsjt7a/wsjtgen.f90
Log:
Remove from main screen controls not used in current mode, rather than
greying themn out.
Some general cleanup of code and of screen appearance.
Removed end-of-line numbers in new modes.
Added libration width to Astro screen.


Modified: wsjt7a/CALL3.TXT
===================================================================
--- wsjt7a/CALL3.TXT	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/CALL3.TXT	2010-08-05 18:12:40 UTC (rev 2087)
@@ -1414,6 +1414,7 @@
 G3NAQ,IO91HL,,,,,50: 400W 3el - 4: 100W 2el - 144: 400W 17el - 70: 250W 21el,08/05
 G3UTS,IO94CU,,,,,144: 400W  9el M2  BF981,02/04
 G3WCS,IO83RH,,,,,144: TS430S HB Transverter  HB Amp 2x4CX250B 20el DJ9BV  70: 100W 4el   50: 100W 4el,01/05
+G3WDG,IO92rg,EME,,
 G3WZT,IO90UX,EME,,,,IC756PRO  50: 7el 400W - TS2000 144: 2x12el 400W - 432: 1x19el 50W,03/07
 G3YNN,JO00EU,,,,,50:  2-5W 5el - 144: FT736 100W 14el - 432: FT736 25W 11el,05/04
 G3YYD,IO91TR,,,,,FT1000MP Transverter 4CX400 400w to 3wl yagi at 22m AGL,04/05

Modified: wsjt7a/Makefile.MinGW
===================================================================
--- wsjt7a/Makefile.MinGW	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/Makefile.MinGW	2010-08-05 18:12:40 UTC (rev 2087)
@@ -50,7 +50,7 @@
 	thnix.f90 tweak1.f90 smo.f90 analytic.f90 geniscat.f90 \
 	iscat.f90 four2a.f90 hipass.f90 msdf.f90 syncms.f90 lenms.f90 \
 	jtms.f90 foldms.f90 avecho.f90 echogen.f90 alignmsg.f90 \
-	chk441.f90 gen441.f90
+	chk441.f90 gen441.f90 tm2.f90
 
 
 SRCS2F77 = avesp2.f bzap.f spec441.f spec2d.f mtdecode.f \
@@ -73,7 +73,8 @@
 	rfile2.f 
 
 SRCS2C   = resample.c ptt.c igray.c wrapkarn.c start_threads.c \
-	cutil.c fthread.c
+	cutil.c fthread.c tmoonsub.c
+
 WSJT9.EXE: WsjtMod/Audio.pyd wsjt.spec
 	c:/python25/python c:/python25/pyinstaller-1.3/Build.py wsjt.spec
 	mv wsjt.exe WSJT9.EXE

Modified: wsjt7a/Makefile.in
===================================================================
--- wsjt7a/Makefile.in	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/Makefile.in	2010-08-05 18:12:40 UTC (rev 2087)
@@ -75,7 +75,7 @@
 	thnix.f90 tweak1.f90 smo.f90 analytic.f90 \
 	geniscat.f90 iscat.f90 four2a.f90 hipass.f90 \
 	msdf.f90 syncms.f90 lenms.f90 jtms.f90 foldms.f90 avecho.f90 \
-	echogen.f90 alignmsg.f90 chk441.f90 gen441.f90 
+	echogen.f90 alignmsg.f90 chk441.f90 gen441.f90 tm2.f90
 
 OBJS2F90 = ${SRCS2F90:.f90=.o}
 
@@ -102,7 +102,7 @@
 OBJS2F77 = ${SRCS2F77:.f=.o} deep65.o
 
 SRCS2C	= init_rs.c encode_rs.c decode_rs.c fano.c tab.c nhash.c \
-	cutil.c fthread.c
+	cutil.c fthread.c tmoonsub.c
 OBJS2C  = ${SRCS2C:.c=.o}
 
 SRCS3C	= ptt_unix.c igray.c wrapkarn.c

Modified: wsjt7a/WsjtMod/astro.py
===================================================================
--- wsjt7a/WsjtMod/astro.py	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/WsjtMod/astro.py	2010-08-05 18:12:40 UTC (rev 2087)
@@ -26,9 +26,10 @@
     t3= &quot;Moon/DX: %6.2f  %6.2f\n&quot; % (g.AzMoonB,g.ElMoonB)
     t4= &quot;Sun:     %6.2f  %6.2f\n&quot; % (g.AzSun,g.ElSun)
     t4a=&quot;Source:  %6.2f  %6.2f\n\n&quot; % (g.AzAux,g.ElAux)
-    t5= &quot;        Doppler   df/dt\n&quot;
-    t6= &quot;DX:     %7d %7.2f\n&quot; % (g.ndop,g.dfdt)
-    t7= &quot;Self:   %7d %7.2f\n\n&quot; % (g.ndop00,g.dfdt0)
+    t5= &quot;           Self     DX\n&quot;
+    t6= &quot;Dop:    %7d %7d\n&quot; % (g.ndop,g.ndop00)
+    t7= &quot;df/dt:  %7.2f %7.2f\n&quot; % (g.dfdt,g.dfdt0)
+    t7aa=&quot;Width:  %7.1f %7.1f\n\n&quot; % (g.w1,g.w2)
     t7a=&quot;            RA      DEC\n&quot;
     irah=int(g.RAMoon)
     iram=int(60.0*(g.RAMoon-irah))
@@ -36,12 +37,12 @@
     irah=int(g.RaAux)
     iram=int(60.0*(g.RaAux-irah))
     t7c=&quot;Source:   %2.2d:%2.2d  %6.2f\n\n&quot; % (irah,iram,g.DecAux)
-    t8= &quot;Freq: %4d  Tsky:%6d\n&quot; % (g.nfreq,g.ntsky)
+    t8= &quot;Freq:%5d  Tsky:%6d\n&quot; % (g.nfreq,g.ntsky)
     if g.nfreq==2: t8=&quot;Freq:  1.8 Tsky:%6d\n&quot; % (g.ntsky)
     if g.nfreq==4: t8=&quot;Freq:  3.5 Tsky:%6d\n&quot; % (g.ntsky)
     t9= &quot;MNR: %5.1f  Dgrd:%6.1f\n&quot; % (g.MaxNR,g.Dgrd)
     t10=&quot;DPol: %4d  SD:%8.2f\n&quot; % (g.poloffset,g.sd)
-    t=t1+t2+t3+t4+t4a+t5+t6+t7+t7a+t7b+t7c+t8+t9+t10
+    t=t1+t2+t3+t4+t4a+t5+t6+t7+t7aa+t7a+t7b+t7c+t8+t9+t10
     lab1.configure(text=t)
     g.astro_geom=root.geometry()
     frame.after(1000,update)

Modified: wsjt7a/WsjtMod/options.py
===================================================================
--- wsjt7a/WsjtMod/options.py	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/WsjtMod/options.py	2010-08-05 18:12:40 UTC (rev 2087)
@@ -191,7 +191,7 @@
 f2.pack()
 
 f3=Frame(g2.interior(),width=100,height=20)
-Button(f3,text=&quot;Reset Templates&quot;,command=defaults).pack(side=LEFT,padx=6,pady=6)
+Button(f3,text=&quot;   Reset   &quot;,command=defaults).pack(side=LEFT,padx=6,pady=6)
 Button(f3,text=&quot;Reset and Gen Msgs&quot;,command=resetgen).pack(side=LEFT,padx=6,pady=6)
 f3.pack()
 

Modified: wsjt7a/astro.f
===================================================================
--- wsjt7a/astro.f	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/astro.f	2010-08-05 18:12:40 UTC (rev 2087)
@@ -1,7 +1,7 @@
       subroutine astro(nyear,month,nday,uth,nfreq,Mygrid,
      +     NStation,mode,MoonDX,AzSun,ElSun,AzMoon,ElMoon0,
      +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
-     +     poloffset,xnr,auxra,auxdec,azaux,elaux)
+     +     poloffset,xnr,auxra,auxdec,azaux,elaux,day,lon,lat)
 
 C  Computes astronomical quantities for display in JT65, CW, and EME Echo mode.
 C  NB: may want to smooth the Tsky map to 10 degrees or so.
@@ -22,7 +22,7 @@
       call grid2deg(MyGrid,elon,lat)
       lon=-elon
       call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
-     +    AzSun,ElSun,mjd)
+     +    AzSun,ElSun,mjd,day)
 
       freq=nfreq*1.e6
       if(nfreq.eq.2) freq=1.8e6

Modified: wsjt7a/astro0.f90
===================================================================
--- wsjt7a/astro0.f90	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/astro0.f90	2010-08-05 18:12:40 UTC (rev 2087)
@@ -1,17 +1,18 @@
 subroutine astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
      AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
      dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
-     RaAux8,DecAux8,AzAux8,ElAux8)
+     RaAux8,DecAux8,AzAux8,ElAux8,width1,width2)
 
 !f2py threadsafe
 !f2py intent(in) nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec
-!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8
+!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8,width1,width2
 
+  parameter (DEGS=57.2957795130823d0)
   character grid*6
   character*9 cauxra,cauxdec
   real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,AzAux8,ElAux8
   real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0,dt
-  real*8 sd8,poloffset8
+  real*8 sd8,poloffset8,day8,width1,width2
   include 'gcom2.f90'
   data uth8z/0.d0/,imin0/-99/
   save
@@ -57,14 +58,29 @@
   call astro(nyear,month,nday,uth,nfreq,hisgrid,2,nmode,1,    &amp;
        AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
        dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
+       AzAux,ElAux,day,xlon2,xlat2)
   AzMoonB8=AzMoon
   ElMoonB8=ElMoon
   call astro(nyear,month,nday,uth,nfreq,grid,1,nmode,1,       &amp;
        AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
        dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
+       AzAux,ElAux,day,xlon1,xlat1)
 
+  day8=day
+  call tm2(day8,xlat1,xlon1,xl1,b1)
+  call tm2(day8,xlat2,xlon2,xl2,b2)
+  call tm2(day8+1.d0/1440.0,xlat1,xlon1,xl1a,b1a)
+  call tm2(day8+1.d0/1440.0,xlat2,xlon2,xl2a,b2a)
+  fghz=0.001*nfreq
+  dldt1=DEGS*(xl1a-xl1)
+  dbdt1=DEGS*(b1a-b1)
+  dldt2=DEGS*(xl2a-xl2)
+  dbdt2=DEGS*(b2a-b2)
+  rate1=2.0*sqrt(dldt1**2 + dbdt1**2)
+  width1=0.5*6741*fghz*rate1
+  rate2=sqrt((dldt1+dldt2)**2 + (dbdt1+dbdt2)**2)
+  width2=0.5*6741*fghz*rate2
+
   RaAux8=auxra
   DecAux8=auxdec
   AzSun8=AzSun

Modified: wsjt7a/gen24.f
===================================================================
--- wsjt7a/gen24.f	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/gen24.f	2010-08-05 18:12:40 UTC (rev 2087)
@@ -1,5 +1,5 @@
-      subroutine gen24(message,mode4,samfac,ntxdf,ndebug,
-     +    iwave,nwave,sendingsh,msgsent,nmsg)
+      subroutine gen24(message,mode4,samfac,ntxdf,iwave,nwave,
+     +  sendingsh,msgsent,nmsg)
 
 C  Encode a JT4 message into a wavefile.
 
@@ -39,14 +39,6 @@
       if(iand(dgen(10),8).ne.0) sendingsh=-1 !Plain text flag
       call interleave24(symbol(2),1)         !Apply JT4 interleaving
 
-      if(ndebug.ne.0) then
-         rewind 51
-         do i=1,nsym
-            write(51,3001) i,symbol(i),npr2(i),npr2(i)+2*symbol(i)
- 3001       format(4i5)
-         enddo
-      endif
-
 C  Set up necessary constants
       tsymbol=2520.d0/11025.d0
       dt=1.d0/(samfac*11025.d0)

Modified: wsjt7a/gen65.f
===================================================================
--- wsjt7a/gen65.f	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/gen65.f	2010-08-05 18:12:40 UTC (rev 2087)
@@ -1,4 +1,4 @@
-      subroutine gen65(message,mode65,samfac,ntxdf,ndebug,iwave,nwave,
+      subroutine gen65(message,mode65,samfac,ntxdf,iwave,nwave,
      +  sendingsh,msgsent,nmsg)
 
 C  Encodes a JT65 message into a wavefile.
@@ -29,11 +29,6 @@
          call rs_encode(dgen,sent)
          call interleave63(sent,1)           !Apply interleaving
          call graycode(sent,63,1)            !Apply Gray code
-         if(ndebug.ne.0) then
-            rewind 51
-            write(51,1050) sent
- 1050       format('Channel symbols, including FEC:'/(i5,20i3))
-         endif
          tsymbol=4096.d0/11025.d0
          nsym=126                            !Symbols per transmission
       else

Modified: wsjt7a/iscat.f90
===================================================================
--- wsjt7a/iscat.f90	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/iscat.f90	2010-08-05 18:12:40 UTC (rev 2087)
@@ -211,8 +211,8 @@
   if(navg.le.0) msg=' '
 
   call cs_lock('iscat')
-  write(11,1020) cfile6,nsig,ndf0,msg,msglen,nworst,navg
-  write(21,1020) cfile6,nsig,ndf0,msg,msglen,nworst,navg
+  write(11,1020) cfile6,nsig,ndf0,msg        !,msglen,nworst,navg
+  write(21,1020) cfile6,nsig,ndf0,msg        !,msglen,nworst,navg
 1020 format(a6,i5,i5,6x,a28,i4,2i3)
   call cs_unlock
 

Modified: wsjt7a/jtms.f90
===================================================================
--- wsjt7a/jtms.f90	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/jtms.f90	2010-08-05 18:12:40 UTC (rev 2087)
@@ -73,8 +73,8 @@
      if(nline.le.99) nline=nline+1
      tping(nline)=t2
      call cs_lock('decodems')
-     write(line(nline),1120) cfile6,t2,mswidth,ndb,nrpt,ndf,msg29,msglen
-1120 format(a6,f5.1,i5,i3,1x,i2.2,i5,5x,a29,8x,i3,'*',i3)
+     write(line(nline),1120) cfile6,t2,mswidth,ndb,nrpt,ndf,msg29
+1120 format(a6,f5.1,i5,i3,1x,i2.2,i5,5x,a29,11x,'*')
      call cs_unlock
    endif
 

Modified: wsjt7a/sun.f
===================================================================
--- wsjt7a/sun.f	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/sun.f	2010-08-05 18:12:40 UTC (rev 2087)
@@ -1,4 +1,4 @@
-      subroutine sun(y,m,DD,UT,lon,lat,RA,Dec,LST,Az,El,mjd)
+      subroutine sun(y,m,DD,UT,lon,lat,RA,Dec,LST,Az,El,mjd,day)
 
       implicit none
 
@@ -35,6 +35,7 @@
       real xhor,yhor,zhor
       real Az,El
 
+      real day
       real rad
       data rad/57.2957795/
 
@@ -81,6 +82,7 @@
       zhor = xx*cos(lat/rad) + zz*sin(lat/rad)
       Az = mod(rad*atan2(yhor,xhor) + 180.0 + 360.0,360.0)
       El = rad*asin(zhor)
+      day=d-1.5
 
       return
       end

Added: wsjt7a/tmoonsub.c
===================================================================
--- wsjt7a/tmoonsub.c	                        (rev 0)
+++ wsjt7a/tmoonsub.c	2010-08-05 18:12:40 UTC (rev 2087)
@@ -0,0 +1,514 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+#define RADS 0.0174532925199433
+#define DEGS 57.2957795130823
+#define TPI 6.28318530717959
+#define PI 3.1415927
+
+/* ratio of     earth radius to astronomical unit */
+#define ER_OVER_AU 0.0000426352325194252
+
+/* all prototypes here */
+
+double getcoord(int coord);
+void getargs(int argc, char *argv[], int *y, int *m, double *tz, double *glong, double *glat);
+double range(double y);
+double rangerad(double y);
+double days(int y, int m, int dn, double hour);
+double days_(int *y, int *m, int *dn, double *hour);
+void moonpos(double, double *, double *, double *);
+void sunpos(double , double *, double *, double *);
+double moontransit(int y, int m, int d, double timezone, double glat, double glong, int *nt);
+double atan22(double y, double x);
+double epsilon(double d);
+void equatorial(double d, double *lon, double *lat, double *r);
+void ecliptic(double d, double *lon, double *lat, double *r);
+double gst(double d);
+void topo(double lst, double glat, double *alp, double *dec, double *r);
+double alt(double glat, double ha, double dec);
+void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p);
+void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill);
+int daysinmonth(int y, int m);
+int isleap(int y);
+void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
+   double *mrv, double *l, double *b, double *paxis);
+
+static const char
+*usage = &quot;  Usage: tmoon date[yyyymm] timz[+/-h.hh] long[+/-dddmm] lat[+/-ddmm]\n&quot;
+            &quot;example: tmoon 200009 0 -00155 5230\n&quot;;
+
+/*
+  getargs() gets the arguments from the command line, does some basic error
+  checking, and converts arguments into numerical form. Arguments are passed
+  back in pointers. Error messages print to stderr so re-direction of output
+  to file won't leave users blind. Error checking prints list of all errors
+  in a command line before quitting.
+*/
+void getargs(int argc, char *argv[], int *y, int *m, double *tz,
+             double *glong, double *glat) {
+
+  int date, latitude, longitude;
+  int mflag = 0, yflag = 0, longflag = 0, latflag = 0, tzflag = 0;
+  int longminflag = 0, latminflag = 0, dflag = 0;
+
+  /* if not right number of arguments, then print example command line */
+
+  if (argc !=5) {
+    fprintf(stderr, usage);
+    exit(EXIT_FAILURE);
+  }
+
+  date = atoi(argv[1]);
+  *y = date / 100;
+  *m = date - *y * 100;
+  *tz = (double) atof(argv[2]);
+  longitude = atoi(argv[3]);
+  latitude = atoi(argv[4]);
+  *glong = RADS * getcoord(longitude);
+  *glat = RADS * getcoord(latitude);
+
+  /* set a flag for each error found */
+
+  if (*m &gt; 12 || *m &lt; 1) mflag = 1;
+  if (*y &gt; 2500) yflag = 1;
+  if (date &lt; 150001) dflag = 1;
+  if (fabs((float) *glong) &gt; 180 * RADS) longflag = 1;
+  if (abs(longitude) % 100 &gt; 59) longminflag = 1;
+  if (fabs((float) *glat) &gt; 90 * RADS) latflag = 1;
+  if (abs(latitude) % 100 &gt; 59) latminflag = 1;
+  if (fabs((float) *tz) &gt; 12) tzflag = 1;
+
+  /* print all the errors found */
+  
+  if (dflag == 1) {
+    fprintf(stderr, &quot;date: dates must be in form yyyymm, gregorian, and later than 1500 AD\n&quot;);
+  }
+  if (yflag == 1) {
+    fprintf(stderr, &quot;date: too far in future - accurate from 1500 to 2500\n&quot;);
+  }
+  if (mflag == 1) {
+    fprintf(stderr, &quot;date: month must be in range 0 to 12, eg - August 2000 is entered as 200008\n&quot;);
+  }
+  if (tzflag == 1) {
+    fprintf(stderr, &quot;timz: must be in range +/- 12 hours, eg -6 for Chicago\n&quot;);
+  }
+  if (longflag == 1) {
+    fprintf(stderr, &quot;long: must be in range +/- 180 degrees\n&quot;);
+  }
+  if (longminflag == 1) {
+    fprintf(stderr, &quot;long: last two digits are arcmin - max 59\n&quot;);
+  }
+  if (latflag == 1) {
+    fprintf(stderr, &quot; lat: must be in range +/- 90 degrees\n&quot;);
+  }
+  if (latminflag == 1) {
+    fprintf(stderr, &quot; lat: last two digits are arcmin - max 59\n&quot;);
+  }
+
+  /* quits if one or more flags set */
+
+  if (dflag + mflag + yflag + longflag + latflag + tzflag + longminflag + latminflag &gt; 0) {
+    exit(EXIT_FAILURE);
+  }
+  
+}
+
+/*
+   returns coordinates in decimal degrees given the
+   coord as a ddmm value stored in an integer.
+*/
+double getcoord(int coord) {
+  int west = 1;
+  double glg, deg;
+  if (coord &lt; 0) west = -1;
+  glg = fabs((double) coord/100);
+  deg = floor(glg);
+  glg = west* (deg + (glg - deg)*100 / 60);
+  return(glg);
+}
+
+/*
+  days() takes the year, month, day in the month and decimal hours
+  in the day and returns the number of days since J2000.0.
+  Assumes Gregorian calendar.
+*/
+double days(int y, int m, int d, double h) {
+  int a, b;
+  double day;
+  
+  /*
+    The lines below work from 1900 march to feb 2100
+    a = 367 * y - 7 * (y + (m + 9) / 12) / 4 + 275 * m / 9 + d;
+    day = (double)a - 730531.5 + hour / 24;
+  */
+
+  /*  These lines work for any Gregorian date since 0 AD */
+  if (m ==1 || m==2) {
+    m +=12;
+    y -= 1;
+  }
+  a = y / 100;
+  b = 2 - a + a/4;
+  day = floor(365.25*(y + 4716)) + floor(30.6001*(m + 1))
+    + d + b - 1524.5 - 2451545 + h/24;
+  return(day);
+}
+double days_(int *y0, int *m0, int *d0, double *h0) 
+{
+  return days(*y0,*m0,*d0,*h0);
+}
+
+/*
+Returns 1 if y a leap year, and 0 otherwise, according
+to the Gregorian calendar
+*/
+int isleap(int y) {
+  int a = 0;
+  if(y % 4 == 0) a = 1;
+  if(y % 100 == 0) a = 0;
+  if(y % 400 == 0) a = 1;
+  return(a);
+}
+
+/*
+Given the year and the month, function returns the
+number of days in the month. Valid for Gregorian
+calendar.
+*/
+int daysinmonth(int y, int m) {
+  int b = 31;
+  if(m == 2) {
+    if(isleap(y) == 1) b= 29;
+    else b = 28;
+  }
+  if(m == 4 || m == 6 || m == 9 || m == 11) b = 30;
+  return(b);
+}
+
+/*
+moonpos() takes days from J2000.0 and returns ecliptic coordinates
+of moon in the pointers. Note call by reference.
+This function is within a couple of arcminutes most of the time,
+and is truncated from the Meeus Ch45 series, themselves truncations of
+ELP-2000. Returns moon distance in earth radii.
+Terms have been written out explicitly rather than using the
+table based method as only a small number of terms is
+retained.
+*/
+void moonpos(double d, double *lambda, double *beta, double *rvec) {
+  double dl, dB, dR, L, D, M, M1, F, e, lm, bm, rm, t;
+
+  t = d / 36525;
+
+  L = range(218.3164591  + 481267.88134236  * t) * RADS;
+  D = range(297.8502042  + 445267.1115168  * t) * RADS;
+  M = range(357.5291092  + 35999.0502909  * t) * RADS;
+  M1 = range(134.9634114  + 477198.8676313  * t - .008997 * t * t) * RADS;
+  F = range(93.27209929999999  + 483202.0175273  * t - .0034029*t*t)*RADS;
+  e = 1 - .002516 * t;
+
+  dl =      6288774 * sin(M1);
+  dl +=     1274027 * sin(2 * D - M1);
+  dl +=      658314 * sin(2 * D);
+  dl +=      213618 * sin(2 * M1);
+  dl -=  e * 185116 * sin(M);
+  dl -=      114332 * sin(2 * F) ;
+  dl +=       58793 * sin(2 * D - 2 * M1);
+  dl +=   e * 57066 * sin(2 * D - M - M1) ;
+  dl +=       53322 * sin(2 * D + M1);
+  dl +=   e * 45758 * sin(2 * D - M);
+  dl -=   e * 40923 * sin(M - M1);
+  dl -=       34720 * sin(D) ;
+  dl -=   e * 30383 * sin(M + M1) ;
+  dl +=       15327 * sin(2 * D - 2 * F) ;
+  dl -=       12528 * sin(M1 + 2 * F);
+  dl +=       10980 * sin(M1 - 2 * F);
+  lm = rangerad(L + dl / 1000000 * RADS);
+
+  dB =   5128122 * sin(F);
+  dB +=   280602 * sin(M1 + F);
+  dB +=   277693 * sin(M1 - F);
+  dB +=   173237 * sin(2 * D - F);
+  dB +=    55413 * sin(2 * D - M1 + F);
+  dB +=    46271 * sin(2 * D - M1 - F);
+  dB +=    32573 * sin(2 * D + F);
+  dB +=    17198 * sin(2 * M1 + F);
+  dB +=     9266 * sin(2 * D + M1 - F);
+  dB +=     8822 * sin(2 * M1 - F);
+  dB += e * 8216 * sin(2 * D - M - F);
+  dB +=     4324 * sin(2 * D - 2 * M1 - F);
+  bm = dB / 1000000 * RADS;
+
+  dR =    -20905355 * cos(M1);
+  dR -=     3699111 * cos(2 * D - M1);
+  dR -=     2955968 * cos(2 * D);
+  dR -=      569925 * cos(2 * M1);
+  dR +=   e * 48888 * cos(M);
+  dR -=        3149 * cos(2 * F);
+  dR +=      246158 * cos(2 * D - 2 * M1);
+  dR -=  e * 152138 * cos(2 * D - M - M1) ;
+  dR -=      170733 * cos(2 * D + M1);
+  dR -=  e * 204586 * cos(2 * D - M);
+  dR -=  e * 129620 * cos(M - M1);
+  dR +=      108743 * cos(D);
+  dR +=  e * 104755 * cos(M + M1);
+  dR +=       79661 * cos(M1 - 2 * F);
+  rm = 385000.56  + dR / 1000;
+
+  *lambda = lm;
+  *beta = bm;
+  /* distance to Moon must be in Earth radii */
+  *rvec = rm / 6378.14;
+}
+
+/*
+topomoon() takes the local siderial time, the geographical
+latitude of the observer, and pointers to the geocentric
+equatorial coordinates. The function overwrites the geocentric
+coordinates with topocentric coordinates on a simple spherical
+earth model (no polar flattening). Expects Moon-Earth distance in
+Earth radii.    Formulas scavenged from Astronomical Almanac 'low
+precision formulae for Moon position' page D46.
+*/
+
+void topo(double lst, double glat, double *alp, double *dec, double *r) {
+  double x, y, z, r1;
+  x = *r * cos(*dec) * cos(*alp) - cos(glat) * cos(lst);
+  y = *r * cos(*dec) * sin(*alp) - cos(glat) * sin(lst);
+  z = *r * sin(*dec)  - sin(glat);
+  r1 = sqrt(x*x + y*y + z*z);
+  *alp = atan22(y, x);
+  *dec = asin(z / r1);
+  *r = r1;
+}
+
+/*
+moontransit() takes date, the time zone and geographic longitude
+of observer and returns the time (decimal hours) of lunar transit
+on that day if there is one, and sets the notransit flag if there
+isn't. See Explanatory Supplement to Astronomical Almanac
+section 9.32 and 9.31 for the method.
+*/
+
+double moontransit(int y, int m, int d, double tz, double glat, double glong, int *notransit) {
+  double hm, ht, ht1, lon, lat, rv, dnew, lst;
+  int itcount;
+
+  ht1 = 180 * RADS;
+  ht = 0;
+  itcount = 0;
+  *notransit = 0;
+  do {
+    ht = ht1;
+    itcount++;
+    dnew = days(y, m, d, ht * DEGS/15) - tz/24;
+    lst = gst(dnew) + glong;
+    /* find the topocentric Moon ra (hence hour angle) and dec */
+    moonpos(dnew, &amp;lon, &amp;lat, &amp;rv);
+    equatorial(dnew, &amp;lon, &amp;lat, &amp;rv);
+    topo(lst, glat, &amp;lon, &amp;lat, &amp;rv);
+    hm = rangerad(lst -  lon);
+    ht1 = rangerad(ht - hm);
+    /* if no convergence, then no transit on that day */
+    if (itcount &gt; 30) {
+      *notransit = 1;
+      break;
+    }
+  }
+  while (fabs(ht - ht1) &gt; 0.04 * RADS);
+  return(ht1);
+}
+
+/*
+  Calculates the selenographic coordinates of either the sub Earth point
+  (optical libration) or the sub-solar point (selen. coords of centre of
+  bright hemisphere).  Based on Meeus chapter 51 but neglects physical
+  libration and nutation, with some simplification of the formulas.
+*/
+void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p) {
+  double i, f, omega, w, y, x, a, t, eps;
+  t = day / 36525;
+  i = 1.54242 * RADS;
+  eps = epsilon(day);
+  f = range(93.2720993 + 483202.0175273 * t - .0034029 * t * t) * RADS;
+  omega = range(125.044555 - 1934.1361849 * t + .0020762 * t * t) * RADS;
+  w = lambda - omega;
+  y = sin(w) * cos(beta) * cos(i) - sin(beta) * sin(i);
+  x = cos(w) * cos(beta);
+  a = atan22(y, x);
+  *l = a - f;
+
+  /*  kludge to catch cases of 'round the back' angles  */
+  if (*l &lt; -90 * RADS) *l += TPI;
+  if (*l &gt; 90 * RADS)  *l -= TPI;
+  *b = asin(-sin(w) * cos(beta) * sin(i) - sin(beta) * cos(i));
+
+  /*  pa pole axis - not used for Sun stuff */
+  x = sin(i) * sin(omega);
+  y = sin(i) * cos(omega) * cos(eps) - cos(i) * sin(eps);
+  w = atan22(x, y);
+  *p = rangerad(asin(sqrt(x*x + y*y) * cos(alpha - w) / cos(*b)));
+}
+
+/*
+  Takes: days since J2000.0, eq coords Moon, ratio of moon to sun distance,
+  eq coords Sun
+  Returns: position angle of bright limb wrt NCP, percentage illumination
+  of Sun
+*/
+void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill) {
+  double x, y, phi, i;
+  y = cos(sdec) * sin(sra - lra);
+  x = sin(sdec) * cos(ldec) - cos(sdec) * sin(ldec) * cos (sra - lra);
+  *pabl = atan22(y, x);
+  phi = acos(sin(sdec) * sin(ldec) + cos(sdec) * cos(ldec) * cos(sra-lra));
+  i = atan22(sin(phi) , (dr - cos(phi)));
+  *ill = 0.5*(1 + cos(i));
+}
+
+/*
+sunpos() takes days from J2000.0 and returns ecliptic longitude
+of Sun in the pointers. Latitude is zero at this level of precision,
+but pointer left in for consistency in number of arguments.
+This function is within 0.01 degree (1 arcmin) almost all the time
+for a century either side of J2000.0. This is from the 'low precision
+fomulas for the Sun' from C24 of Astronomical Alamanac
+*/
+void sunpos(double d, double *lambda, double *beta, double *rvec) {
+  double L, g, ls, bs, rs;
+
+  L = range(280.461 + .9856474 * d) * RADS;
+  g = range(357.528 + .9856003 * d) * RADS;
+  ls = L + (1.915 * sin(g) + .02 * sin(2 * g)) * RADS;
+  bs = 0;
+  rs = 1.00014 - .01671 * cos(g) - .00014 * cos(2 * g);
+  *lambda = ls;
+  *beta = bs;
+  *rvec = rs;
+}
+
+/*
+this routine returns the altitude given the days since J2000.0
+the hour angle and declination of the object and the latitude
+of the observer. Used to find the Sun's altitude to put a letter
+code on the transit time, and to find the Moon's altitude at
+transit just to make sure that the Moon is visible.
+*/
+double alt(double glat, double ha, double dec) {
+  return(asin(sin(dec) * sin(glat) + cos(dec) * cos(glat) * cos(ha)));
+}
+
+/* returns an angle in degrees in the range 0 to 360 */
+double range(double x) {
+  double a, b;
+  b = x / 360;
+  a = 360 * (b - floor(b));
+  if (a &lt; 0)
+    a = 360 + a;
+  return(a);
+}
+
+/* returns an angle in rads in the range 0 to two pi */
+double rangerad(double x) {
+  double a, b;
+  b = x / TPI;
+  a = TPI * (b - floor(b));
+  if (a &lt; 0)
+    a = TPI + a;
+  return(a);
+}
+
+/*
+gets the atan2 function returning angles in the right
+order and  range
+*/
+double atan22(double y, double x) {
+  double a;
+
+  a = atan2(y, x);
+  if (a &lt; 0) a += TPI;
+  return(a);
+}
+
+/*
+returns mean obliquity of ecliptic in radians given days since
+J2000.0.
+*/
+double epsilon(double d) {
+  double t = d/ 36525;
+  return((23.4392911111111 - (t* (46.8150 + 0.00059*t)/3600)) *RADS);
+}
+
+/*
+replaces ecliptic coordinates with equatorial coordinates
+note: call by reference destroys original values
+R is unchanged.
+*/
+void equatorial(double d, double *lon, double *lat, double *r) {
+  double  eps, ceps, seps, l, b;
+
+  l = *lon;
+  b = * lat;
+  eps = epsilon(d);
+  ceps = cos(eps);
+  seps = sin(eps);
+  *lon = atan22(sin(l)*ceps - tan(b)*seps, cos(l));
+  *lat = asin(sin(b)*ceps + cos(b)*seps*sin(l));
+}
+
+/*
+replaces equatorial coordinates with ecliptic ones. Inverse
+of above, but used to find topocentric ecliptic coords.
+*/
+void ecliptic(double d, double *lon, double *lat, double *r) {
+  double  eps, ceps, seps, alp, dec;
+  alp = *lon;
+  dec = *lat;
+  eps = epsilon(d);
+  ceps = cos(eps);
+  seps = sin(eps);
+  *lon = atan22(sin(alp)*ceps + tan(dec)*seps, cos(alp));
+  *lat = asin(sin(dec)*ceps - cos(dec)*seps*sin(alp));
+}
+
+/*
+returns the siderial time at greenwich meridian as
+an angle in radians given the days since J2000.0
+*/
+double gst( double d) {
+  double t = d / 36525;
+  double theta;
+  theta = range(280.46061837 + 360.98564736629 * d + 0.000387933 * t * t);
+  return(theta * RADS);
+}
+
+void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
+   double *mrv, double *l, double *b, double *paxis)
+{
+  double mlambda, mbeta;
+  double malpha, mdelta;
+  double lst, mhr;
+  double tlambda, tbeta, trv;
+
+  lst = gst(*day) + *glong;
+      
+  /* find Moon topocentric coordinates for libration calculations */
+
+  moonpos(*day, &amp;mlambda, &amp;mbeta, mrv);
+  malpha = mlambda;
+  mdelta = mbeta;
+  equatorial(*day, &amp;malpha, &amp;mdelta, mrv);
+  topo(lst, *glat, &amp;malpha, &amp;mdelta, mrv);
+  mhr = rangerad(lst - malpha);
+  *moonalt = alt(*glat, mhr, mdelta);
+      
+  /* Optical libration and Position angle of the Pole */
+
+  tlambda = malpha;
+  tbeta = mdelta;
+  trv = *mrv;
+  ecliptic(*day, &amp;tlambda, &amp;tbeta, &amp;trv);
+  libration(*day, tlambda, tbeta, malpha,  l, b, paxis);
+}


Property changes on: wsjt7a/tmoonsub.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/wsjt.py
===================================================================
--- wsjt7a/wsjt.py	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/wsjt.py	2010-08-05 18:12:40 UTC (rev 2087)
@@ -575,15 +575,19 @@
         lab6.configure(bg=&quot;green&quot;)
         isync=isync441
         slabel=&quot;S      &quot;
+        f5b1.grid(column=0,row=0,padx=2,sticky='EW')
         lsync.configure(text=slabel+str(isync))
         iframe4b.pack_forget()
         textheight=9
         text.configure(height=textheight)
-        bclravg.configure(state=DISABLED)
-        binclude.configure(state=DISABLED)
-        bexclude.configure(state=DISABLED)
+        bclravg.pack_forget()
+        binclude.pack_forget()
+        bexclude.pack_forget()
         cbfreeze.grid_forget()
         cbafc.grid_forget()
+        lsync.grid(column=0,row=0,padx=8,sticky='EW')
+        ltol.grid(column=0,row=1,padx=8,sticky='EW')
+        cbzap.grid(column=1,row=0,padx=2,sticky='W')
         nfreeze.set(0)
         shrx.grid(column=1,row=1,sticky='W',padx=2)
         shmsg.grid(column=1,row=0,sticky='W',padx=2)
@@ -613,10 +617,17 @@
     text.configure(height=textheight)
     isync=isync65
     slabel=&quot;Sync   &quot;
+    f5b1.grid(column=0,row=0,padx=2,sticky='EW')
     lsync.configure(text=slabel+str(isync))
-    bclravg.configure(state=NORMAL)
-    binclude.configure(state=NORMAL)
-    bexclude.configure(state=NORMAL)
+    lsync.grid(column=0,row=0,padx=2,sticky='EW')
+    ltol.grid(column=0,row=1,padx=2,sticky='EW')
+    cbzap.grid(column=1,row=0,padx=2,sticky='W')
+    btxstop.pack_forget()
+    bclravg.pack(side=LEFT,expand=1,fill=X)
+    binclude.pack(side=LEFT,expand=1,fill=X)
+    bexclude.pack(side=LEFT,expand=1,fill=X)
+    btxstop.pack(side=LEFT,expand=1,fill=X)
+
     cbfreeze.grid(column=0,row=2,padx=2,sticky='W')
     cbafc.grid(column=1,row=1,padx=2,sticky='W')
     if ltxdf: toggletxdf()
@@ -662,7 +673,7 @@
     if g.mode != &quot;JTMS&quot;:
         if lauto: toggleauto()
     ModeFSK441()
-    cbfreeze.grid(column=0,row=2,padx=2,sticky='W')
+    cbfreeze.grid(column=0,row=2,padx=4,sticky='W')
     mode.set(&quot;JTMS&quot;)
     
 #------------------------------------------------------ ModeISCAT
@@ -696,15 +707,17 @@
     if g.mode != &quot;CW&quot;:
         if lauto: toggleauto()
         cleartext()
+        ModeJT65B()
         mode.set(&quot;CW&quot;)
         Audio.gcom1.trperiod=ncwtrperiod
         iframe4b.pack_forget()
         text.configure(height=9)
-        bclravg.configure(state=DISABLED)
-        binclude.configure(state=DISABLED)
-        bexclude.configure(state=DISABLED)
         cbfreeze.grid_forget()
         cbafc.grid_forget()
+        lsync.grid_forget()
+        ltol.grid_forget()
+        cbzap.grid_forget()
+        f5b1.grid_forget()
         if ltxdf: toggletxdf()
         ntx.set(1)
         GenStdMsgs()
@@ -714,13 +727,18 @@
 def ModeJT4():
     global slabel,isync,isync65,textheight,itol
     ModeJT65()
+    bclravg.pack_forget()
+    binclude.pack_forget()
+    bexclude.pack_forget()
 
+
 #------------------------------------------------------ ModeJT4A
 def ModeJT4A():
     global slabel,isync,isync65,textheight,itol
     ModeJT4()
     mode.set(&quot;JT4A&quot;)
     Audio.gcom2.mode4=1
+    btxdf.grid(column=1,row=0,sticky='EW',padx=4)
 
 #------------------------------------------------------ ModeJT4B
 def ModeJT4B():
@@ -794,13 +812,14 @@
 WSJT is a weak signal communications program.  It supports
 these operating modes:
 
-  1. FSK441 - fast mode for meteor scatter
-  2. JTMS   - fast mode for meteor scatter
-  3. ISCAT  - for meteor and ionospheric scatter on 50 MHz
-  4. JT65   - for HF, EME, and troposcatter
-  5. JT4    - for HF and EME
-  6. CW     - 15 WPM Morse code, messages structured for EME
-  7. Echo   - EME Echo testing
+  1. FSK441 -  meteor scatter
+  2. JTMS     -  meteor scatter (experimental)
+  3. ISCAT    -  for tropo- and iono-scatter, weak Es/F2 on 50 MHz
+                       (replaces JT6M)
+  4. JT65      -  for HF, EME, and troposcatter
+  5. JT4        -  HF, microwave beacons, 10 GHz EME and rainscatter
+  6. CW        -  15 WPM Morse code, messages structured for EME
+  7. Echo      -  EME Echo testing
 
 Copy (c) 2001-2010 by Joseph H. Taylor, Jr., K1JT, with
 contributions from additional authors.  WSJT is Open Source 
@@ -831,6 +850,7 @@
 Shift+F5	Examples of minimal JT65 QSOs
 F6	Open next file in directory
 Shift+F6	Decode all wave files in directory
+F9	Online Supplement to User's Guide
 F10	Show SpecJT
 Shift+F10  Show astronomical data
 F11	Decrement Freeze DF
@@ -1559,11 +1579,11 @@
             g.AzSun,g.ElSun,g.AzMoon,g.ElMoon,g.AzMoonB,g.ElMoonB,g.ntsky, \
                 g.ndop,g.ndop00,g.dbMoon,g.RAMoon,g.DecMoon,g.HA8,g.Dgrd,  \
                 g.sd,g.poloffset,g.MaxNR,g.dfdt,g.dfdt0,g.RaAux,g.DecAux, \
-                g.AzAux,g.ElAux = Audio.astro0(utc[0],utc[1],utc[2],  \
+                g.AzAux,g.ElAux,g.w1,g.w2 = Audio.astro0(utc[0],utc[1],utc[2],  \
                 utchours,nfreq.get(),options.MyGrid.get().upper(), \
                     options.auxra.get()+(' '*9)[:9],     \
                     options.auxdec.get()+(' '*9)[:9])
-
+            
             if len(HisGrid.get().strip())&lt;4:
                 g.ndop=g.ndop00
                 g.dfdt=g.dfdt0
@@ -1667,22 +1687,25 @@
         bdecode.configure(bg='#66FFFF',activebackground='#66FFFF')
         if (sys.platform == 'darwin'):
            bdecode.configure(text='*Decode*')
-    if mode.get()==&quot;CW&quot; or mode.get()=='FSK441' or mode.get()=='JTMS' or \
-           mode.get()=='ISCAT':
-        msg5.configure(text=&quot;TR Period: %d s&quot; % (Audio.gcom1.trperiod,), \
-                       bg='white')
+    msg5.configure(text=&quot;T/R Period: %d s&quot; % (Audio.gcom1.trperiod,))
+    if mode.get()==&quot;CW&quot;: color='white'
+    elif mode.get()=='FSK441' or mode.get()=='JTMS' or mode.get()=='ISCAT':
+        if(Audio.gcom1.trperiod==15): color='yellow'
+        else: color='white'
     else:
-        msg5.configure(text=&quot;TR Period: %d s&quot; % (Audio.gcom1.trperiod,), \
-                       bg='gray85')
-##    t=&quot;%d&quot; % (int(Audio.mtxcom.mtxstate),)
-##    msg6.configure(text=t)
+        color='gray85'
+    msg5.configure(bg=color)
 
     tx1.configure(bg='white')
     tx2.configure(bg='white')
     tx3.configure(bg='white')
     tx4.configure(bg='white')
     tx5.configure(bg='white')
-    if len(tx5.get())&gt;13: tx5.configure(bg='pink')
+    if len(tx5.get())&gt;13 and \
+            (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4'):
+        Audio.gcom2.t0msg=(tx5.get()+' '*22)[:22]
+        nplain,naddon,ndiff=Audio.chkt0()
+        if nplain==1: tx5.configure(bg='pink')
     tx6.configure(bg='white')
     if tx6.get()[:1]=='#':
         try:
@@ -2055,7 +2078,8 @@
    helpmenu = Menu(mbar, tearoff=0)
 helpmenu.add('command', label = 'Keyboard shortcuts', command = shortcuts, \
              accelerator='F1')
-helpmenu.add('command',label=&quot;Online User's Guide&quot;,command=usersguide)
+helpmenu.add('command',label=&quot;Online Supplement to User's Guide&quot;, \
+             command=usersguide, accelerator='F9')
 helpmenu.add('command', label = 'Special mouse commands', \
              command = mouse_commands, accelerator='Shift+F1')
 helpmenu.add('command', label = 'What message to send?', \
@@ -2125,6 +2149,7 @@
 root.bind_all('&lt;Shift-F5&gt;', minimal_qso)
 root.bind_all('&lt;F6&gt;', opennext)
 root.bind_all('&lt;Shift-F6&gt;', decodeall)
+root.bind_all('&lt;F9&gt;', usersguide)
 root.bind_all('&lt;F10&gt;', showspecjt)
 root.bind_all('&lt;Shift-F10&gt;', astro1)
 root.bind_all('&lt;F11&gt;', left_arrow)

Modified: wsjt7a/wsjtgen.f90
===================================================================
--- wsjt7a/wsjtgen.f90	2010-08-04 21:00:50 UTC (rev 2086)
+++ wsjt7a/wsjtgen.f90	2010-08-05 18:12:40 UTC (rev 2087)
@@ -121,7 +121,7 @@
         if(mode(5:5).eq.'A') mode65=1
         if(mode(5:5).eq.'B') mode65=2
         if(mode(5:5).eq.'C') mode65=4
-        call gen65(msg,mode65,samfacout,ntxdf,ndebug,iwave,nwave,sendingsh,   &amp;
+        call gen65(msg,mode65,samfacout,ntxdf,iwave,nwave,sendingsh,   &amp;
              msgsent,nmsg0)
      else if(mode(1:5).eq.'ISCAT') then
         call geniscat(msg,nmsg,samfacout,iwave,nwave,msgsent)
@@ -136,7 +136,7 @@
         sendingsh=0
         msgsent=msg
      else if(mode(1:3).eq.'JT4' ) then
-        call gen24(msg,mode4,samfacout,ntxdf,ndebug,iwave,nwave,      &amp;
+        call gen24(msg,mode4,samfacout,ntxdf,iwave,nwave,                 &amp;
              sendingsh,msgsent,nmsg0)
      else
         stop 'Unknown Tx mode requested.'


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001778.html">[WSJT-SVN] r2086 - wsjt7a/WsjtMod
</A></li>
	<LI>Next message: <A HREF="001780.html">[WSJT-SVN] r2088 - wsjt7a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1779">[ date ]</a>
              <a href="thread.html#1779">[ thread ]</a>
              <a href="subject.html#1779">[ subject ]</a>
              <a href="author.html#1779">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
