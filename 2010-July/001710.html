<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2018 - wsjt7a
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2018%20-%20wsjt7a&In-Reply-To=%3C20100722122223.C82C2480BE7%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001709.html">
   <LINK REL="Next"  HREF="001711.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2018 - wsjt7a</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2018%20-%20wsjt7a&In-Reply-To=%3C20100722122223.C82C2480BE7%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r2018 - wsjt7a">k1jt at mail.berlios.de
       </A><BR>
    <I>Thu Jul 22 14:22:23 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001709.html">[WSJT-SVN] r2017 - wsjt7a
</A></li>
        <LI>Next message: <A HREF="001711.html">[WSJT-SVN] r2019 - wsjt7a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1710">[ date ]</a>
              <a href="thread.html#1710">[ thread ]</a>
              <a href="subject.html#1710">[ subject ]</a>
              <a href="author.html#1710">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2010-07-22 14:22:23 +0200 (Thu, 22 Jul 2010)
New Revision: 2018

Modified:
   wsjt7a/analytic.f90
   wsjt7a/astro.f
   wsjt7a/dec441.f90
   wsjt7a/decodems.f90
   wsjt7a/enc441.f90
   wsjt7a/fivehz.f90
   wsjt7a/four2b.f90
   wsjt7a/gen441.f90
   wsjt7a/geniscat.f90
   wsjt7a/genms.f90
   wsjt7a/genscat6.f90
   wsjt7a/iscat.f90
   wsjt7a/makepings.f90
   wsjt7a/pp441.f90
   wsjt7a/t72.f90
   wsjt7a/t73.f90
   wsjt7a/t74.f90
   wsjt7a/token.f90
   wsjt7a/unpackpfx.f90
Log:
Changed properties to eol-style native.


Modified: wsjt7a/analytic.f90
===================================================================
--- wsjt7a/analytic.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/analytic.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,25 +1,25 @@
-subroutine analytic(d,npts,nfft1,s,c)
-
-  parameter (NMAX=512*1024)
-  real d(npts)
-  real s(NMAX)
-  complex c(NMAX)
-
-  nh=nfft1/2
-  fac=2.0/nfft1
-  do i=1,npts
-     c(i)=fac*d(i)
-  enddo
-  c(npts+1:nfft1)=0.
-  call four2a(c,nfft1,1,-1,1)
-
-  do i=1,nh
-     s(i)=real(c(i))**2 + aimag(c(i))**2
-  enddo
-
-  c(1)=0.5*c(1)
-  c(nh+2:nfft1)=0.
-  call four2a(c,nfft1,1,1,1)
-
-  return
-end subroutine analytic
+subroutine analytic(d,npts,nfft1,s,c)
+
+  parameter (NMAX=512*1024)
+  real d(npts)
+  real s(NMAX)
+  complex c(NMAX)
+
+  nh=nfft1/2
+  fac=2.0/nfft1
+  do i=1,npts
+     c(i)=fac*d(i)
+  enddo
+  c(npts+1:nfft1)=0.
+  call four2a(c,nfft1,1,-1,1)
+
+  do i=1,nh
+     s(i)=real(c(i))**2 + aimag(c(i))**2
+  enddo
+
+  c(1)=0.5*c(1)
+  c(nh+2:nfft1)=0.
+  call four2a(c,nfft1,1,1,1)
+
+  return
+end subroutine analytic


Property changes on: wsjt7a/analytic.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/astro.f
===================================================================
--- wsjt7a/astro.f	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/astro.f	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,88 +1,88 @@
-      subroutine astro(nyear,month,nday,uth,nfreq,Mygrid,
-     +     NStation,mode,MoonDX,AzSun,ElSun,AzMoon,ElMoon0,
-     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
-     +     poloffset,xnr,auxra,auxdec,azaux,elaux)
-
-C  Computes astronomical quantities for display in JT65, CW, and EME Echo mode.
-C  NB: may want to smooth the Tsky map to 10 degrees or so.
-
-      character*6 MyGrid,HisGrid
-      logical ltsky
-      real LST
-      real lat,lon
-      real ldeg
-      integer*2 nsky
-      common/sky/ nsky(360,180)
-      common/echo/xdop(2),techo,ElMoon,mjd
-      data rad/57.2957795/
-      save
-
-      ltsky=nsky(1,1).eq.192
-
-      call grid2deg(MyGrid,elon,lat)
-      lon=-elon
-      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
-     +    AzSun,ElSun,mjd)
-
-      freq=nfreq*1.e6
-      if(nfreq.eq.2) freq=1.8e6
-      if(nfreq.eq.4) freq=3.5e6
-
-      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
-     +  LST,HA,AzMoon,ElMoon,ldeg,bdeg,vr,dist)
-
-C  Compute spatial polarization offset
-      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
-     +     cos(AzMoon/rad)*sin(ElMoon/rad)
-      yy=cos(lat/rad)*sin(AzMoon/rad)
-      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
-      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
-
-      techo=2.0 * dist/2.99792458e5                 !Echo delay time
-      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
-      t408=ftsky(ldeg,bdeg)                         !Read sky map
-      tsky=t408*(408.0/nfreq)**2.6                  !Tsky for obs freq
-      if(ltsky.and.(tsky.lt.3.0)) tsky=3.0          !Minimum = 3 Kelvin
-
-      xdop(NStation)=doppler
-      if(NStation.eq.2) then
-         HisGrid=MyGrid
-         go to 900
-      endif
-
-      doppler00=2.0*xdop(1)
-      if(mode.eq.2 .or. mode.eq.5) doppler=xdop(1)+xdop(2)
-      if(mode.eq.3) doppler=2.0*xdop(1)
-      dBMoon=-40.0*log10(dist/356903.)
-      sd=16.23*370152.0/dist
-
-!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
-!     +    (mode.eq.2 .or. mode.eq.5)) then
-      if(NStation.eq.1 .and. MoonDX.ne.0) then
-         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
-         if(poloffset.gt.90.0) poloffset=poloffset-180.0
-         x1=abs(cos(2*poloffset/rad))
-         if(x1.lt.0.056234) x1=0.056234
-         xnr=-20.0*log10(x1)
-         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'Z') xnr=0
-      endif
-
-      tr=80.0                              !Good preamp
-      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
-      tsysmin=tskymin+tr
-      tsys=tsky+tr
-      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
- 900  ElMoon0=Elmoon
-      ntsky=nint(tsky)
-
-      auxHA = 15.0*(LST-auxra)                       !HA in degrees
-      pi=3.14159265
-      pio2=0.5*pi
-      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
-     +  auxdec/rad,azaux,elaux)
-      AzAux=azaux*rad
-      ElAux=ElAux*rad
-
-      return
-
-      end
+      subroutine astro(nyear,month,nday,uth,nfreq,Mygrid,
+     +     NStation,mode,MoonDX,AzSun,ElSun,AzMoon,ElMoon0,
+     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
+     +     poloffset,xnr,auxra,auxdec,azaux,elaux)
+
+C  Computes astronomical quantities for display in JT65, CW, and EME Echo mode.
+C  NB: may want to smooth the Tsky map to 10 degrees or so.
+
+      character*6 MyGrid,HisGrid
+      logical ltsky
+      real LST
+      real lat,lon
+      real ldeg
+      integer*2 nsky
+      common/sky/ nsky(360,180)
+      common/echo/xdop(2),techo,ElMoon,mjd
+      data rad/57.2957795/
+      save
+
+      ltsky=nsky(1,1).eq.192
+
+      call grid2deg(MyGrid,elon,lat)
+      lon=-elon
+      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
+     +    AzSun,ElSun,mjd)
+
+      freq=nfreq*1.e6
+      if(nfreq.eq.2) freq=1.8e6
+      if(nfreq.eq.4) freq=3.5e6
+
+      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
+     +  LST,HA,AzMoon,ElMoon,ldeg,bdeg,vr,dist)
+
+C  Compute spatial polarization offset
+      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
+     +     cos(AzMoon/rad)*sin(ElMoon/rad)
+      yy=cos(lat/rad)*sin(AzMoon/rad)
+      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
+      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
+
+      techo=2.0 * dist/2.99792458e5                 !Echo delay time
+      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
+      t408=ftsky(ldeg,bdeg)                         !Read sky map
+      tsky=t408*(408.0/nfreq)**2.6                  !Tsky for obs freq
+      if(ltsky.and.(tsky.lt.3.0)) tsky=3.0          !Minimum = 3 Kelvin
+
+      xdop(NStation)=doppler
+      if(NStation.eq.2) then
+         HisGrid=MyGrid
+         go to 900
+      endif
+
+      doppler00=2.0*xdop(1)
+      if(mode.eq.2 .or. mode.eq.5) doppler=xdop(1)+xdop(2)
+      if(mode.eq.3) doppler=2.0*xdop(1)
+      dBMoon=-40.0*log10(dist/356903.)
+      sd=16.23*370152.0/dist
+
+!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
+!     +    (mode.eq.2 .or. mode.eq.5)) then
+      if(NStation.eq.1 .and. MoonDX.ne.0) then
+         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
+         if(poloffset.gt.90.0) poloffset=poloffset-180.0
+         x1=abs(cos(2*poloffset/rad))
+         if(x1.lt.0.056234) x1=0.056234
+         xnr=-20.0*log10(x1)
+         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'Z') xnr=0
+      endif
+
+      tr=80.0                              !Good preamp
+      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
+      tsysmin=tskymin+tr
+      tsys=tsky+tr
+      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
+ 900  ElMoon0=Elmoon
+      ntsky=nint(tsky)
+
+      auxHA = 15.0*(LST-auxra)                       !HA in degrees
+      pi=3.14159265
+      pio2=0.5*pi
+      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
+     +  auxdec/rad,azaux,elaux)
+      AzAux=azaux*rad
+      ElAux=ElAux*rad
+
+      return
+
+      end


Property changes on: wsjt7a/astro.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/dec441.f90
===================================================================
--- wsjt7a/dec441.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/dec441.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,52 +1,52 @@
-subroutine dec441(msg1,n2,msg2)
-
-! Decode the &quot;++&quot; enhancements from an FSK441 message
-
-  character*28 msg1,msg2
-  character*4 tok(12)
-  character*12 ctok
-  integer ntok(12)
-  integer len(12)
-
-  data tok(1) /'CQ ' /,ntok(1)/3/              !001 1  Tokens and token lengths
-  data tok(2) /'QRZ '/,ntok(2)/4/              !012 6
-  data tok(3) /'TNX '/,ntok(3)/4/              !020 8
-  data tok(4) /' 26' /,ntok(4)/3/              !033 _
-  data tok(5) /' 27' /,ntok(5)/3/              !100 $
-  data tok(6) /' 38' /,ntok(6)/3/              !113 G
-  data tok(7) /' R26'/,ntok(7)/4/              !121 I
-  data tok(8) /' R27'/,ntok(8)/4/              !132 N
-  data tok(9) /' R38'/,ntok(9)/4/              !202 R
-  data tok(10)/' RRR'/,ntok(10)/4/             !210 T
-  data tok(11)/' 73' /,ntok(11)/3/             !223 O
-  data tok(12)/'   ' /,ntok(12)/3/             !231 Z
-  data len/4,7,9,11,13,14,15,17,19,21,23,28/   !Permissible message lengths
-  data ctok/'168_$GINRTOZ'/                    !Token indexes, as characters
-
-  len0=0
-  do j=1,12
-     if(msg1(3:3).eq.ctok(j:j)) len0=len(j)
-  enddo
-
-  iz=0
-  do i=1,12
-     if(msg1(4:4).eq.ctok(i:i)) iz=i
-  enddo
-  if(msg1(4:4).eq.' ') iz=4
-
-  if(iz.eq.0) then
-     msg2=msg1
-     if(msg1(1:2).eq.'$!') msg2=msg1(5:)
-  else if(iz.le.3) then
-     msg2=tok(iz)(1:ntok(iz))//msg1(5:)
-  else
-     if(n2.eq.4) then
-        msg2=tok(iz)(2:)
-     else
-        msg2=msg1(5:n2)//tok(iz)
-     endif
-  endif
-
-  return
-end subroutine dec441
-
+subroutine dec441(msg1,n2,msg2)
+
+! Decode the &quot;++&quot; enhancements from an FSK441 message
+
+  character*28 msg1,msg2
+  character*4 tok(12)
+  character*12 ctok
+  integer ntok(12)
+  integer len(12)
+
+  data tok(1) /'CQ ' /,ntok(1)/3/              !001 1  Tokens and token lengths
+  data tok(2) /'QRZ '/,ntok(2)/4/              !012 6
+  data tok(3) /'TNX '/,ntok(3)/4/              !020 8
+  data tok(4) /' 26' /,ntok(4)/3/              !033 _
+  data tok(5) /' 27' /,ntok(5)/3/              !100 $
+  data tok(6) /' 38' /,ntok(6)/3/              !113 G
+  data tok(7) /' R26'/,ntok(7)/4/              !121 I
+  data tok(8) /' R27'/,ntok(8)/4/              !132 N
+  data tok(9) /' R38'/,ntok(9)/4/              !202 R
+  data tok(10)/' RRR'/,ntok(10)/4/             !210 T
+  data tok(11)/' 73' /,ntok(11)/3/             !223 O
+  data tok(12)/'   ' /,ntok(12)/3/             !231 Z
+  data len/4,7,9,11,13,14,15,17,19,21,23,28/   !Permissible message lengths
+  data ctok/'168_$GINRTOZ'/                    !Token indexes, as characters
+
+  len0=0
+  do j=1,12
+     if(msg1(3:3).eq.ctok(j:j)) len0=len(j)
+  enddo
+
+  iz=0
+  do i=1,12
+     if(msg1(4:4).eq.ctok(i:i)) iz=i
+  enddo
+  if(msg1(4:4).eq.' ') iz=4
+
+  if(iz.eq.0) then
+     msg2=msg1
+     if(msg1(1:2).eq.'$!') msg2=msg1(5:)
+  else if(iz.le.3) then
+     msg2=tok(iz)(1:ntok(iz))//msg1(5:)
+  else
+     if(n2.eq.4) then
+        msg2=tok(iz)(2:)
+     else
+        msg2=msg1(5:n2)//tok(iz)
+     endif
+  endif
+
+  return
+end subroutine dec441
+


Property changes on: wsjt7a/dec441.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/decodems.f90
===================================================================
--- wsjt7a/decodems.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/decodems.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,164 +1,158 @@
-subroutine decodems(dat,npts,cfile6,t2,mswidth,ndb,nrpt,Nfreeze,       &amp;
-     DFTolerance,MouseDF)
-
-! Decode a JTMS ping
-
-  parameter (NZ=30*11025)
-  real dat(npts)                        !Raw data
-  integer DFTolerance
-  character*6 cfile6
-  complex cdat(NZ)                      !Analytic form of signal
-  real s(NZ)
-  real fs(56)
-  real sm(0:63)
-  real r(40000)
-  complex c(NZ)
-  complex cw(56,0:63)                   !Complex waveforms for codewords
-  complex cwb(56)                       !Complex waveform for 'space'
-  complex z
-  logical first
-  character msg*400,msg28*28
-  character*90 line
-  character cc*64
-!                    1         2         3         4         5         6
-!          0123456789012345678901234567890123456789012345678901234567890123
-  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ./?-                 _     @'/
-  data first/.true./
-  save first,smax,cw,cwb           !Why is this needed for save?  But it is!
-  common/ccom/nline,tping(100),line(100)
-
-  if(first) call setupms(cw,cwb)        !Calculate waveforms for codewords
-  first=.false.
-
-  nsps=8
-  f0=1155.46875
-  xn=log(float(npts))/log(2.0)
-  n=xn
-  if(xn-n .gt.0.001) n=n+1
-  nfft1=2**n
-  nh1=nfft1/2
-  nq1=nfft1/4
-  df1=11025.0/nfft1
-  ia=nint(11025.0/(3.0*nsps*df1))
-  ib=nint(dftolerance/df1)
-  i0=nint(f0/df1)
-
-  call analytic(dat,npts,nfft1,s,cdat)        !Convert to analytic signal
-
-  fac=1.0/(nfft1**2)
-  do i=1,npts
-     c(i)=fac*cdat(i)**2
-  enddo
-  c(npts+1:nfft1)=0.
-  call four2a(c,nfft1,1,-1,1)
-
-! In the &quot;doubled-frequencies&quot; spectrum of squared cdat:
-  fa=2.0*(f0-400)
-  fb=2.0*(f0+400)
-  if(NFreeze.gt.0) then
-     fa=2.0*(f0+MouseDF-DFtolerance)
-     fb=2.0*(f0+MouseDF+DFtolerance)
-  endif  
-  ja=nint(fa/df1)
-  jb=nint(fb/df1)
-  jd=nint(1378.125/df1)
-
-  smax=0.
-  do j=ja,jb
-     ss=real(c(j))**2 + aimag(c(j))**2 + real(c(j+jd))**2 + aimag(c(j+jd))**2
-     if(ss.gt.smax) then
-        smax=ss
-        fpk=(j-1)*df1
-     endif
-  enddo
-  dfx=0.5*fpk-f0
-
-! Should have a test here to reject non-JTMS signals
-
-! We know DF, now find character sync.
-  r=0.
-  rmax=0.
-  do i1=1,npts-55
-     z=0.
-     ss=0.
-     do i=1,56
-        ss=ss + abs(cdat(i+i1-1))
-        z=z + cdat(i+i1-1)*conjg(cwb(i))
-     enddo
-     r(i1)=abs(z)/ss
-     if(r(i1).gt.0.85) then
-        j=mod(i1-1,56)+1
-        if(r(i1).gt.rmax) then
-           rmax=r(i1)
-           jpk=j
-        endif
-!        write(51,3009) i1,j,r(i1)
-!3009    format(2i5,f12.3)
-     endif
-  enddo
-
-  i1=jpk-1
-  if(i1.lt.1) i1=i1+56
-
-  acfmax=0.
-  acf0=dot_product(r(1:npts),r(1:npts))
-  do k=8,28*56
-     fac=float(npts)/(npts-k)
-     acf=fac*dot_product(r(1:npts),r(1+k:npts+k))/acf0
-     if(acf.gt.acfmax) then
-        acfmax=acf
-        kpk=k
-     endif
-!     write(52,3008) k/56.0,acf
-!3008 format(2f12.3)
-  enddo
-!  print*,jpk,kpk,kpk/56.0
-
-  msg=' '
-  nchar=(npts-55-i1)/56
-  if(nchar.gt.400) nchar=400
-  do j=1,nchar
-     ia=i1 + (j-1)*56
-     smax=0.
-     do k=0,63
-        z=0.
-        do i=1,56
-           z=z + cdat(ia+i)*conjg(cw(i,k))
-        enddo
-        ss=abs(z)
-        sm(k)=ss
-        if(ss.gt.smax) then
-           smax=ss
-           phapk=atan2(aimag(z),real(z))
-           kpk=k
-        endif
-     enddo
-     sm(kpk)=0.
-     smax2=0.
-     do k=0,63
-        smax2=max(smax2,sm(k))
-     enddo
-     if(kpk.lt.1) then
-        kpk=64
-     endif
-     msg(j:j)=cc(kpk:kpk)
-     if(kpk.eq.58) msg(j:j)=' '
-!     if(smax/smax2.lt.1.05) msg(j:j)=' '               !Threshold test
-!     write(51,3007) j,smax,phapk,phapk+6.283185307
-!3007 format(i5,3f12.3)
-  enddo
-!  call flush(51)
-
-  ia=max(1,nchar/3)
-  ib=min(ia+27,nchar)
-  msg28=msg(ia:ib)
-  ndf=nint(dfx)
-
-  if(nline.le.99) nline=nline+1
-  tping(nline)=t2
-!  write(*,1110) cfile6,t2,mswidth,ndb,nrpt,ndf,msg28
-  write(line(nline),1110) cfile6,t2,mswidth,ndb,nrpt,ndf,msg28
-1110 format(a6,f5.1,i5,i3,1x,i2.2,i5,5x,a28,f8.1,f6.2,i3,a2)
-
-  return
-end subroutine decodems
+subroutine decodems(dat,npts,cfile6,t2,mswidth,ndb,nrpt,Nfreeze,       &amp;
+     DFTolerance,MouseDF)
+
+! Decode a JTMS ping
+
+  parameter (NZ=30*11025)
+  real dat(npts)                        !Raw data
+  complex cdat(NZ)                      !Analytic form of signal
+  character*6 cfile6                    !FileID
+  integer DFTolerance
+  real s(NZ)                            !Power spectrum
+  real sm(0:63)
+  real r(40000)
+  complex c(NZ)
+  complex cw(56,0:63)                   !Complex waveforms for codewords
+  complex cwb(56)                       !Complex waveform for 'space'
+  complex z
+  logical first
+  character msg*400,msg28*28
+  character*90 line
+  character cc*64
+!                    1         2         3         4         5         6
+!          0123456789012345678901234567890123456789012345678901234567890123
+  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ./?-                 _     @'/
+  data first/.true./
+  save first,smax,cw,cwb           !Why is this needed for save?  But it is!
+  common/ccom/nline,tping(100),line(100)
+
+  if(first) call setupms(cw,cwb)        !Calculate waveforms for codewords
+  first=.false.
+
+  nsps=8                                !Samples per symbol
+  f0=1155.46875                         !Nominal frequency for bit=0
+  xn=log(float(npts))/log(2.0)
+  n=xn
+  if(xn-n .gt.0.001) n=n+1
+  nfft1=2**n
+  df1=11025.0/nfft1
+
+  call analytic(dat,npts,nfft1,s,cdat)        !Convert to analytic signal
+
+  fac=1.0/(nfft1**2)
+  do i=1,npts
+     c(i)=fac*cdat(i)**2
+  enddo
+  c(npts+1:nfft1)=0.
+  call four2a(c,nfft1,1,-1,1)
+
+! In the &quot;doubled-frequencies&quot; spectrum of squared cdat:
+  fa=2.0*(f0-400)
+  fb=2.0*(f0+400)
+  if(NFreeze.gt.0) then
+     fa=2.0*(f0+MouseDF-DFtolerance)
+     fb=2.0*(f0+MouseDF+DFtolerance)
+  endif  
+  ja=nint(fa/df1)
+  jb=nint(fb/df1)
+  jd=nfft1/nsps
+
+  smax=0.
+  do j=ja,jb
+     ss=real(c(j))**2 + aimag(c(j))**2 + real(c(j+jd))**2 + aimag(c(j+jd))**2
+     if(ss.gt.smax) then
+        smax=ss
+        fpk=(j-1)*df1
+     endif
+  enddo
+  dfx=0.5*fpk-f0
+
+! Should have a test here to reject non-JTMS signals
+
+! DF is known, now find character sync.
+  r=0.
+  rmax=0.
+  do i1=1,npts-55
+     z=0.
+     ss=0.
+     do i=1,56
+        ss=ss + abs(cdat(i+i1-1))
+        z=z + cdat(i+i1-1)*conjg(cwb(i))
+     enddo
+     r(i1)=abs(z)/ss
+     if(r(i1).gt.0.85) then
+        j=mod(i1-1,56)+1
+        if(r(i1).gt.rmax) then
+           rmax=r(i1)
+           jpk=j
+        endif
+!        write(51,3009) i1,j,r(i1)
+!3009    format(2i5,f12.3)
+     endif
+  enddo
+
+  i1=jpk-1
+  if(i1.lt.1) i1=i1+56
+
+  acfmax=0.
+  acf0=dot_product(r(1:npts),r(1:npts))
+  do k=8,28*56
+     fac=float(npts)/(npts-k)
+     acf=fac*dot_product(r(1:npts),r(1+k:npts+k))/acf0
+     if(acf.gt.acfmax) then
+        acfmax=acf
+        kpk=k
+     endif
+!     write(52,3008) k/56.0,acf
+!3008 format(2f12.3)
+  enddo
+!  print*,jpk,kpk,kpk/56.0
+
+  msg=' '
+  nchar=(npts-55-i1)/56
+  if(nchar.gt.400) nchar=400
+  do j=1,nchar
+     ia=i1 + (j-1)*56
+     smax=0.
+     do k=0,63
+        z=0.
+        do i=1,56
+           z=z + cdat(ia+i)*conjg(cw(i,k))
+        enddo
+        ss=abs(z)
+        sm(k)=ss
+        if(ss.gt.smax) then
+           smax=ss
+           phapk=atan2(aimag(z),real(z))
+           kpk=k
+        endif
+     enddo
+     sm(kpk)=0.
+     smax2=0.
+     do k=0,63
+        smax2=max(smax2,sm(k))
+     enddo
+     if(kpk.lt.1) then
+        kpk=64
+     endif
+     msg(j:j)=cc(kpk:kpk)
+     if(kpk.eq.58) msg(j:j)=' '
+!     if(smax/smax2.lt.1.05) msg(j:j)=' '               !Threshold test
+!     write(51,3007) j,smax,phapk,phapk+6.283185307
+!3007 format(i5,3f12.3)
+  enddo
+!  call flush(51)
+
+  ia=max(1,nchar/3)
+  ib=min(ia+27,nchar)
+  msg28=msg(ia:ib)
+  ndf=nint(dfx)
+
+  if(nline.le.99) nline=nline+1
+  tping(nline)=t2
+  write(*,1110) cfile6,t2,mswidth,ndb,nrpt,ndf,msg28
+  write(line(nline),1110) cfile6,t2,mswidth,ndb,nrpt,ndf,msg28
+1110 format(a6,f5.1,i5,i3,1x,i2.2,i5,5x,a28,f8.1,f6.2,i3,a2)
+
+  return
+end subroutine decodems


Property changes on: wsjt7a/decodems.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/enc441.f90
===================================================================
--- wsjt7a/enc441.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/enc441.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,75 +1,75 @@
-subroutine enc441(msg0,msg2,len2)
-
-! Encode an FSK441++ message
-
-  character*28 msg,msg0,msg1,msg2
-  character*4 tok(12)
-  character*12 ctok
-  integer ntok(12)
-  integer len(12)
-
-  data tok(1) /'CQ ' /,ntok(1)/3/              !001 1   Tokens and token lengths
-  data tok(2) /'QRZ '/,ntok(2)/4/              !012 6
-  data tok(3) /'TNX '/,ntok(3)/4/              !020 8
-  data tok(4) /' 26' /,ntok(4)/3/              !033 _
-  data tok(5) /' 27' /,ntok(5)/3/              !100 $
-  data tok(6) /' 38' /,ntok(6)/3/              !113 G
-  data tok(7) /' R26'/,ntok(7)/4/              !121 I
-  data tok(8) /' R27'/,ntok(8)/4/              !132 N
-  data tok(9) /' R38'/,ntok(9)/4/              !202 R
-  data tok(10)/' RRR'/,ntok(10)/4/             !210 T
-  data tok(11)/' 73' /,ntok(11)/3/             !223 O
-  data tok(12)/'   ' /,ntok(12)/3/             !231 Z
-  data len/4,7,9,11,13,14,15,17,19,21,23,28/   !Permissible message lengths
-  data ctok/'168_$GINRTOZ'/                    !Token indexes as characters
-
-  msg=msg0
-  do i=28,1,-1
-     if(msg(i:i).ne.' ') go to 10
-  enddo
-10 len0=min(i,24)                        !User's message length
-  i1=0
-  iz=0
-
-  i2=max(len0+1,6)
-  if(msg(1:3).eq.'26 ')  msg=msg0(4:i2)//'26'
-  if(msg(1:3).eq.'27 ')  msg=msg0(4:i2)//'27'
-  if(msg(1:3).eq.'38 ')  msg=msg0(4:i2)//'38'
-  if(msg(1:4).eq.'R26 ') msg=msg0(5:i2)//'R26'
-  if(msg(1:4).eq.'R27 ') msg=msg0(5:i2)//'R27'
-  if(msg(1:4).eq.'R38 ') msg=msg0(5:i2)//'R38'
-  if(msg(1:4).eq.'RRR ') msg=msg0(5:i2)//'RRR'
-  if(msg(1:3).eq.'73 ')  msg=msg0(4:i2)//'73'
-
-  do i=1,11
-     i1=index(msg,tok(i)(1:ntok(i)))   !i1 marks start of token in msg
-     if(i1.gt.0) go to 20
-  enddo
-
-20 iz=i                                !iz is token number (0 if none)
-
-  if(i1.le.0) then                     !No token found
-     jz=12
-     do j=12,1,-1
-        if(len(j).ge.len0+4) jz=j        !jz is index of msg length
-     enddo
-     len2=len(jz)
-     msg2='$!'//ctok(jz:jz)//ctok(12:12)//msg
-     go to 900
-  endif
-
-  jz=12
-  do j=12,1,-1
-     if(len(j).ge.len0+4-ntok(iz)) jz=j        !jz is index of msg length
-  enddo
-  len2=len(jz)
-
-  if(iz.le.3 .or. len0.le.3) then
-     msg2='$!'//ctok(jz:jz)//ctok(iz:iz)//msg(ntok(iz)+1:)
-  else
-     msg2='$!'//ctok(jz:jz)//ctok(iz:iz)//msg(1:i1-1)
-  endif
-
-900 return
-end subroutine enc441
-
+subroutine enc441(msg0,msg2,len2)
+
+! Encode an FSK441++ message
+
+  character*28 msg,msg0,msg1,msg2
+  character*4 tok(12)
+  character*12 ctok
+  integer ntok(12)
+  integer len(12)
+
+  data tok(1) /'CQ ' /,ntok(1)/3/              !001 1   Tokens and token lengths
+  data tok(2) /'QRZ '/,ntok(2)/4/              !012 6
+  data tok(3) /'TNX '/,ntok(3)/4/              !020 8
+  data tok(4) /' 26' /,ntok(4)/3/              !033 _
+  data tok(5) /' 27' /,ntok(5)/3/              !100 $
+  data tok(6) /' 38' /,ntok(6)/3/              !113 G
+  data tok(7) /' R26'/,ntok(7)/4/              !121 I
+  data tok(8) /' R27'/,ntok(8)/4/              !132 N
+  data tok(9) /' R38'/,ntok(9)/4/              !202 R
+  data tok(10)/' RRR'/,ntok(10)/4/             !210 T
+  data tok(11)/' 73' /,ntok(11)/3/             !223 O
+  data tok(12)/'   ' /,ntok(12)/3/             !231 Z
+  data len/4,7,9,11,13,14,15,17,19,21,23,28/   !Permissible message lengths
+  data ctok/'168_$GINRTOZ'/                    !Token indexes as characters
+
+  msg=msg0
+  do i=28,1,-1
+     if(msg(i:i).ne.' ') go to 10
+  enddo
+10 len0=min(i,24)                        !User's message length
+  i1=0
+  iz=0
+
+  i2=max(len0+1,6)
+  if(msg(1:3).eq.'26 ')  msg=msg0(4:i2)//'26'
+  if(msg(1:3).eq.'27 ')  msg=msg0(4:i2)//'27'
+  if(msg(1:3).eq.'38 ')  msg=msg0(4:i2)//'38'
+  if(msg(1:4).eq.'R26 ') msg=msg0(5:i2)//'R26'
+  if(msg(1:4).eq.'R27 ') msg=msg0(5:i2)//'R27'
+  if(msg(1:4).eq.'R38 ') msg=msg0(5:i2)//'R38'
+  if(msg(1:4).eq.'RRR ') msg=msg0(5:i2)//'RRR'
+  if(msg(1:3).eq.'73 ')  msg=msg0(4:i2)//'73'
+
+  do i=1,11
+     i1=index(msg,tok(i)(1:ntok(i)))   !i1 marks start of token in msg
+     if(i1.gt.0) go to 20
+  enddo
+
+20 iz=i                                !iz is token number (0 if none)
+
+  if(i1.le.0) then                     !No token found
+     jz=12
+     do j=12,1,-1
+        if(len(j).ge.len0+4) jz=j        !jz is index of msg length
+     enddo
+     len2=len(jz)
+     msg2='$!'//ctok(jz:jz)//ctok(12:12)//msg
+     go to 900
+  endif
+
+  jz=12
+  do j=12,1,-1
+     if(len(j).ge.len0+4-ntok(iz)) jz=j        !jz is index of msg length
+  enddo
+  len2=len(jz)
+
+  if(iz.le.3 .or. len0.le.3) then
+     msg2='$!'//ctok(jz:jz)//ctok(iz:iz)//msg(ntok(iz)+1:)
+  else
+     msg2='$!'//ctok(jz:jz)//ctok(iz:iz)//msg(1:i1-1)
+  endif
+
+900 return
+end subroutine enc441
+


Property changes on: wsjt7a/enc441.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/fivehz.f90
===================================================================
--- wsjt7a/fivehz.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/fivehz.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,254 +1,254 @@
-subroutine fivehz
-
-!  Called at interrupt level from the PortAudio callback routine.
-!  For nspb=2048 the callback rate is nfsample/nspb = 5.38 Hz.
-!  Thus, we should be able to control the timing of T/R sequence events
-!  here to within about 0.2 s.
-
-!  Do not do anything very time consuming in this routine!!
-!  Disk I/O is a bad idea.  Writing to stdout (for diagnostic purposes)
-!  seems to be OK.
-
-  integer time
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,txtime,filled
-  integer ptt
-  integer TxOKz
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  data first/.true./,nc0/1/,nc1/1/,nsec0/-99/
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     rxdelay=0.2
-     txdelay=0.4
-     tlatency=1.0
-     first=.false.
-     iptt=0
-     ntr0=-99
-     rxdone=.false.
-     ibuf00=-99
-     ncall=-1
-     u=0.05d0
-     fsample=11025.d0
-     mfsample=110250
-     filled=.false.
-  endif
-
-  if(txdelay.lt.0.2d0) txdelay=0.2d0
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-!  if(ncall.ge.10 .and. mod(ncall,2).eq.1) then
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample=nint(10.d0*fsample)
-     endif
-  endif
-
-  if(trperiod.le.0) trperiod=30
-  tx1=0.0                              !Time to start a TX sequence
-  tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4') then
-     if(nwave.lt.126*4096) nwave=126*4096
-     tx2=txdelay + nwave/11025.0
-     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
-  endif
-
-  if(TxFirst.eq.0) then
-     tx1=tx1+trperiod
-     tx2=tx2+trperiod
-  endif
-
-  t=mod(Tsec,2.d0*trperiod)
-  txtime = t.ge.tx1 .and. t.lt.tx2
-
-! If we're transmitting, freeze the input buffer pointers where they were.
-  receiving=1
-  if(((txtime .and. (lauto.eq.1)) .or. TxOK.eq.1 .or. transmitting.eq.1) &amp; 
-       .and. (mute.eq.0)) then
-     receiving=0
-     ibuf=ibuf000
-     iwrite=iwrite000
-  endif
-  ibuf000=ibuf
-  iwrite000=iwrite
-  nsec=Tsec
-  ntr=mod(nsec/trperiod,2)             !ntr=0 in 1st sequence, 1 in 2nd
-
-  if(ntr.ne.ntr0) then
-     ibuf0=ibuf                        !Start of new sequence, save ibuf
-!     if(mode(1:4).ne.'JT65') then
-!        ibuf0=ibuf0+3                  !So we don't copy our own Tx
-!        if(ibuf0.gt.1024) ibuf0=ibuf0-1024
-!     endif
-     ntime=time()                      !Save start time
-     if(mantx.eq.1 .and. iptt.eq.1) then
-        mantx=0
-        TxOK=0
-     endif
-  endif
-
-! Switch PTT line and TxOK appropriately
-  if(lauto.eq.1) then
-     if(txtime .and. iptt.eq.0 .and.          &amp;
-          mute.eq.0) i1=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(.not.txtime .or. mute.eq.1) TxOK=0               !Lower TxOK
-  else
-     if(mantx.eq.1 .and. iptt.eq.0 .and.      &amp;
-          mute.eq.0) i2=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(mantx.eq.0 .or. mute.eq.1) TxOK=0                !Lower TxOK
-  endif
-
-! Calculate Tx waveform as needed
-  if((iptt.eq.1 .and. iptt0.eq.0) .or. nrestart.eq.1) then
-     call wsjtgen
-     nrestart=0
-  endif
-
-! If PTT was just raised, start a countdown for raising TxOK:
-  nc1a=txdelay/0.18576
-  if(nc1a.lt.2) nc1a=2
-  if(iptt.eq.1 .and. iptt0.eq.0) nc1=-nc1a-1
-  if(nc1.le.0) nc1=nc1+1
-  if(nc1.eq.0) TxOK=1                               ! We are transmitting
-
-! If TxOK was just lowered, start a countdown for lowering PTT:
-  nc0a=(tlatency+txdelay)/0.18576
-  if(nc0a.lt.5) nc0a=5
-  if(TxOK.eq.0 .and. TxOKz.eq.1 .and. iptt.eq.1) nc0=-nc0a-1
-  if(nc0.le.0) nc0=nc0+1
-  if(nc0.eq.0) i3=ptt(nport,pttport,0,iptt)
-
-  if(iptt.eq.0 .and.TxOK.eq.0) then
-     sending=&quot;                      &quot;
-     sendingsh=0
-  endif
-
-  nbufs=i1+i2+i3                             !Silence g95 warning
-  nbufs=ibuf-ibuf0
-  if(nbufs.lt.0) nbufs=nbufs+1024
-  tdata=nbufs*2048.0/11025.0
-
-  if((mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4'                      &amp;
-       .or. mode(1:2).eq.'CW') .and. monitoring.eq.1                   &amp;
-       .and. tdata.gt.float(ntdecode) .and. ibuf0.ne.ibuf00) then
-     rxdone=.true.
-     ibuf00=ibuf0
-  endif
-
-! Diagnostic timing information:
-!  t60=mod(tsec,60.d0)
-!  if(TxOK.ne.TxOKz) then
-!     if(TxOK.eq.1) write(*,1101) 'D2:',t
-!1101 format(a3,f8.1,i8)
-!     if(TxOK.eq.0) then
-!        tstop=tsec
-!        write(*,1101) 'D3:',t,nc0a
-!     endif
-!  endif
-!  if(iptt.ne.iptt0) then
-!     if(iptt.eq.1) then
-!        tstart=tsec
-!        write(*,1101) 'D1:',t,nc1a
-!     endif
-!     if(iptt.eq.0) write(*,1101) 'D4:',t
-!  endif
-
-  iptt0=iptt
-  TxOKz=TxOK
-  ntr0=ntr
-
-  return
-end subroutine fivehz
-
-subroutine fivehztx
-
-!  Called at interrupt level from the PortAudio output callback.
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,filled
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  data first/.true./
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     first=.false.
-     ncall=-1
-     fsample=11025.d0
-     u=0.05d0
-     mfsample2=110250
-     filled=.false.
-  endif
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample2=nint(10.d0*fsample)
-     endif
-  endif
-
-  return
-end subroutine fivehztx
-
-subroutine addnoise(n)
-  integer*2 n
-  real*8 txsnrdb0
-  include 'gcom1.f90'
-  data idum/0/
-  save
-
-  if(txsnrdb.gt.40.0) return
-  if(txsnrdb.ne.txsnrdb0) then
-     snr=10.0**(0.05*(txsnrdb-1))
-     fac=3000.0
-     if(snr.gt.1.0) fac=3000.0/snr
-     txsnrdb0=txsnrdb
-  endif
-  i=fac*(gran(idum) + n*snr/32768.0)
-  if(i&gt;32767) i=32767;
-  if(i&lt;-32767) i=-32767;
-  n=i
-
-  return
-end subroutine addnoise
+subroutine fivehz
+
+!  Called at interrupt level from the PortAudio callback routine.
+!  For nspb=2048 the callback rate is nfsample/nspb = 5.38 Hz.
+!  Thus, we should be able to control the timing of T/R sequence events
+!  here to within about 0.2 s.
+
+!  Do not do anything very time consuming in this routine!!
+!  Disk I/O is a bad idea.  Writing to stdout (for diagnostic purposes)
+!  seems to be OK.
+
+  integer time
+
+  parameter (NTRING=64)
+  real*8 tt1(0:NTRING-1)
+  logical first,txtime,filled
+  integer ptt
+  integer TxOKz
+  real*8 fs,fsample,tt,u
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  data first/.true./,nc0/1/,nc1/1/,nsec0/-99/
+  save
+
+  n1=time()
+  n2=mod(n1,86400)
+  tt=n1-n2+tsec-0.1d0*ndsec
+
+  if(first) then
+     rxdelay=0.2
+     txdelay=0.4
+     tlatency=1.0
+     first=.false.
+     iptt=0
+     ntr0=-99
+     rxdone=.false.
+     ibuf00=-99
+     ncall=-1
+     u=0.05d0
+     fsample=11025.d0
+     mfsample=110250
+     filled=.false.
+  endif
+
+  if(txdelay.lt.0.2d0) txdelay=0.2d0
+
+! Measure average sampling frequency over a recent interval
+  ncall=ncall+1
+  if(ncall.eq.9) then
+     ntt0=0
+     ntt1=0
+     tt1(ntt1)=tt
+  endif
+!  if(ncall.ge.10 .and. mod(ncall,2).eq.1) then
+  if(ncall.ge.10) then
+     ntt1=iand(ntt1+1,NTRING-1)
+     tt1(ntt1)=tt
+     if(ntt1.eq.NTRING-1) filled=.true.
+     if(filled) ntt0=iand(ntt1+1,NTRING-1)
+     if(mod(ncall,2).eq.1) then
+        nd=ntt1-ntt0
+        if(nd.lt.0) nd=nd+NTRING
+        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
+        fsample=u*fs + (1.d0-u)*fsample
+        mfsample=nint(10.d0*fsample)
+     endif
+  endif
+
+  if(trperiod.le.0) trperiod=30
+  tx1=0.0                              !Time to start a TX sequence
+  tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
+  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4') then
+     if(nwave.lt.126*4096) nwave=126*4096
+     tx2=txdelay + nwave/11025.0
+     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
+  endif
+
+  if(TxFirst.eq.0) then
+     tx1=tx1+trperiod
+     tx2=tx2+trperiod
+  endif
+
+  t=mod(Tsec,2.d0*trperiod)
+  txtime = t.ge.tx1 .and. t.lt.tx2
+
+! If we're transmitting, freeze the input buffer pointers where they were.
+  receiving=1
+  if(((txtime .and. (lauto.eq.1)) .or. TxOK.eq.1 .or. transmitting.eq.1) &amp; 
+       .and. (mute.eq.0)) then
+     receiving=0
+     ibuf=ibuf000
+     iwrite=iwrite000
+  endif
+  ibuf000=ibuf
+  iwrite000=iwrite
+  nsec=Tsec
+  ntr=mod(nsec/trperiod,2)             !ntr=0 in 1st sequence, 1 in 2nd
+
+  if(ntr.ne.ntr0) then
+     ibuf0=ibuf                        !Start of new sequence, save ibuf
+!     if(mode(1:4).ne.'JT65') then
+!        ibuf0=ibuf0+3                  !So we don't copy our own Tx
+!        if(ibuf0.gt.1024) ibuf0=ibuf0-1024
+!     endif
+     ntime=time()                      !Save start time
+     if(mantx.eq.1 .and. iptt.eq.1) then
+        mantx=0
+        TxOK=0
+     endif
+  endif
+
+! Switch PTT line and TxOK appropriately
+  if(lauto.eq.1) then
+     if(txtime .and. iptt.eq.0 .and.          &amp;
+          mute.eq.0) i1=ptt(nport,pttport,1,iptt)        !Raise PTT
+     if(.not.txtime .or. mute.eq.1) TxOK=0               !Lower TxOK
+  else
+     if(mantx.eq.1 .and. iptt.eq.0 .and.      &amp;
+          mute.eq.0) i2=ptt(nport,pttport,1,iptt)        !Raise PTT
+     if(mantx.eq.0 .or. mute.eq.1) TxOK=0                !Lower TxOK
+  endif
+
+! Calculate Tx waveform as needed
+  if((iptt.eq.1 .and. iptt0.eq.0) .or. nrestart.eq.1) then
+     call wsjtgen
+     nrestart=0
+  endif
+
+! If PTT was just raised, start a countdown for raising TxOK:
+  nc1a=txdelay/0.18576
+  if(nc1a.lt.2) nc1a=2
+  if(iptt.eq.1 .and. iptt0.eq.0) nc1=-nc1a-1
+  if(nc1.le.0) nc1=nc1+1
+  if(nc1.eq.0) TxOK=1                               ! We are transmitting
+
+! If TxOK was just lowered, start a countdown for lowering PTT:
+  nc0a=(tlatency+txdelay)/0.18576
+  if(nc0a.lt.5) nc0a=5
+  if(TxOK.eq.0 .and. TxOKz.eq.1 .and. iptt.eq.1) nc0=-nc0a-1
+  if(nc0.le.0) nc0=nc0+1
+  if(nc0.eq.0) i3=ptt(nport,pttport,0,iptt)
+
+  if(iptt.eq.0 .and.TxOK.eq.0) then
+     sending=&quot;                      &quot;
+     sendingsh=0
+  endif
+
+  nbufs=i1+i2+i3                             !Silence g95 warning
+  nbufs=ibuf-ibuf0
+  if(nbufs.lt.0) nbufs=nbufs+1024
+  tdata=nbufs*2048.0/11025.0
+
+  if((mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4'                      &amp;
+       .or. mode(1:2).eq.'CW') .and. monitoring.eq.1                   &amp;
+       .and. tdata.gt.float(ntdecode) .and. ibuf0.ne.ibuf00) then
+     rxdone=.true.
+     ibuf00=ibuf0
+  endif
+
+! Diagnostic timing information:
+!  t60=mod(tsec,60.d0)
+!  if(TxOK.ne.TxOKz) then
+!     if(TxOK.eq.1) write(*,1101) 'D2:',t
+!1101 format(a3,f8.1,i8)
+!     if(TxOK.eq.0) then
+!        tstop=tsec
+!        write(*,1101) 'D3:',t,nc0a
+!     endif
+!  endif
+!  if(iptt.ne.iptt0) then
+!     if(iptt.eq.1) then
+!        tstart=tsec
+!        write(*,1101) 'D1:',t,nc1a
+!     endif
+!     if(iptt.eq.0) write(*,1101) 'D4:',t
+!  endif
+
+  iptt0=iptt
+  TxOKz=TxOK
+  ntr0=ntr
+
+  return
+end subroutine fivehz
+
+subroutine fivehztx
+
+!  Called at interrupt level from the PortAudio output callback.
+
+  parameter (NTRING=64)
+  real*8 tt1(0:NTRING-1)
+  logical first,filled
+  real*8 fs,fsample,tt,u
+  include 'gcom1.f90'
+  data first/.true./
+  save
+
+  n1=time()
+  n2=mod(n1,86400)
+  tt=n1-n2+tsec-0.1d0*ndsec
+
+  if(first) then
+     first=.false.
+     ncall=-1
+     fsample=11025.d0
+     u=0.05d0
+     mfsample2=110250
+     filled=.false.
+  endif
+
+! Measure average sampling frequency over a recent interval
+  ncall=ncall+1
+  if(ncall.eq.9) then
+     ntt0=0
+     ntt1=0
+     tt1(ntt1)=tt
+  endif
+  if(ncall.ge.10) then
+     ntt1=iand(ntt1+1,NTRING-1)
+     tt1(ntt1)=tt
+     if(ntt1.eq.NTRING-1) filled=.true.
+     if(filled) ntt0=iand(ntt1+1,NTRING-1)
+     if(mod(ncall,2).eq.1) then
+        nd=ntt1-ntt0
+        if(nd.lt.0) nd=nd+NTRING
+        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
+        fsample=u*fs + (1.d0-u)*fsample
+        mfsample2=nint(10.d0*fsample)
+     endif
+  endif
+
+  return
+end subroutine fivehztx
+
+subroutine addnoise(n)
+  integer*2 n
+  real*8 txsnrdb0
+  include 'gcom1.f90'
+  data idum/0/
+  save
+
+  if(txsnrdb.gt.40.0) return
+  if(txsnrdb.ne.txsnrdb0) then
+     snr=10.0**(0.05*(txsnrdb-1))
+     fac=3000.0
+     if(snr.gt.1.0) fac=3000.0/snr
+     txsnrdb0=txsnrdb
+  endif
+  i=fac*(gran(idum) + n*snr/32768.0)
+  if(i&gt;32767) i=32767;
+  if(i&lt;-32767) i=-32767;
+  n=i
+
+  return
+end subroutine addnoise


Property changes on: wsjt7a/fivehz.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/four2b.f90
===================================================================
--- wsjt7a/four2b.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/four2b.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,93 +1,93 @@
-subroutine four2a(a,nfft,ndim,isign,iform)
-
-! IFORM = 1, 0 or -1, as data is
-! complex, real, or the first half of a complex array.  Transform
-! values are returned in array DATA.  They are complex, real, or
-! the first half of a complex array, as IFORM = 1, -1 or 0.
-
-! The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
-! by ... will be returned in the same array, now considered to
-! be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
-! IFORM = 0 or -1, N(1) must be even, and enough room must be
-! reserved.  The missing values may be obtained by complex conjuga-
-! tion.  
-
-! The reverse transformation of a half complex array dimensioned
-! N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
-! to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
-! The transform will be real and returned to the input array.
-
-  parameter (NPMAX=100)
-  parameter (NSMALL=16384)
-  complex a(nfft)
-  complex aa(NSMALL)
-  integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
-  real*8 plan(NPMAX)             !Actually should be i*8, but no matter
-  data nplan/0/
-  include 'fftw3.f'
-  save plan,nplan,nn,ns,nf,nl
-
-  if(nfft.lt.0) go to 999
-
-  nloc=loc(a)
-  do i=1,nplan
-     if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.                         &amp;
-          iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
-  enddo
-  if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
-  nplan=nplan+1
-  i=nplan
-  nn(i)=nfft
-  ns(i)=isign
-  nf(i)=iform
-  nl(i)=nloc
-
-! Planning: FFTW_ESTIMATE, FFTW_ESTIMATE_PATIENT, FFTW_MEASURE, 
-!           FFTW_PATIENT,  FFTW_EXHAUSTIVE
-  npatience=1
-  nflags=FFTW_ESTIMATE
-  if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
-  if(npatience.eq.2) nflags=FFTW_MEASURE
-  if(npatience.eq.3) nflags=FFTW_PATIENT
-  if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
-  if(nfft.le.NSMALL) then
-     jz=nfft
-     if(iform.eq.0) jz=nfft/2
-     do j=1,jz
-        aa(j)=a(j)
-     enddo
-  endif
-!      call sleep_msec(0)
-  if(isign.eq.-1 .and. iform.eq.1) then
-     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_FORWARD,nflags)
-  else if(isign.eq.1 .and. iform.eq.1) then
-     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_BACKWARD,nflags)
-  else if(isign.eq.-1 .and. iform.eq.0) then
-     call sfftw_plan_dft_r2c_1d(plan(i),nfft,a,a,nflags)
-  else if(isign.eq.1 .and. iform.eq.-1) then
-     call sfftw_plan_dft_c2r_1d(plan(i),nfft,a,a,nflags)
-  else
-     stop 'Unsupported request in four2a'
-  endif
-!      call sleep_msec(0)
-  i=nplan
-  if(nfft.le.NSMALL) then
-     jz=nfft
-     if(iform.eq.0) jz=nfft/2
-     do j=1,jz
-        a(j)=aa(j)
-     enddo
-  endif
-
-10 continue
-!      call sleep_msec(0)
-  call sfftw_execute(plan(i))
-!      call sleep_msec(0)
-  return
-
-999 do i=1,nplan
-     call sfftw_destroy_plan(plan(i))
-  enddo
-
-  return
-end subroutine four2a
+subroutine four2a(a,nfft,ndim,isign,iform)
+
+! IFORM = 1, 0 or -1, as data is
+! complex, real, or the first half of a complex array.  Transform
+! values are returned in array DATA.  They are complex, real, or
+! the first half of a complex array, as IFORM = 1, -1 or 0.
+
+! The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
+! by ... will be returned in the same array, now considered to
+! be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
+! IFORM = 0 or -1, N(1) must be even, and enough room must be
+! reserved.  The missing values may be obtained by complex conjuga-
+! tion.  
+
+! The reverse transformation of a half complex array dimensioned
+! N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
+! to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
+! The transform will be real and returned to the input array.
+
+  parameter (NPMAX=100)
+  parameter (NSMALL=16384)
+  complex a(nfft)
+  complex aa(NSMALL)
+  integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
+  real*8 plan(NPMAX)             !Actually should be i*8, but no matter
+  data nplan/0/
+  include 'fftw3.f'
+  save plan,nplan,nn,ns,nf,nl
+
+  if(nfft.lt.0) go to 999
+
+  nloc=loc(a)
+  do i=1,nplan
+     if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.                         &amp;
+          iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
+  enddo
+  if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
+  nplan=nplan+1
+  i=nplan
+  nn(i)=nfft
+  ns(i)=isign
+  nf(i)=iform
+  nl(i)=nloc
+
+! Planning: FFTW_ESTIMATE, FFTW_ESTIMATE_PATIENT, FFTW_MEASURE, 
+!           FFTW_PATIENT,  FFTW_EXHAUSTIVE
+  npatience=1
+  nflags=FFTW_ESTIMATE
+  if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
+  if(npatience.eq.2) nflags=FFTW_MEASURE
+  if(npatience.eq.3) nflags=FFTW_PATIENT
+  if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
+  if(nfft.le.NSMALL) then
+     jz=nfft
+     if(iform.eq.0) jz=nfft/2
+     do j=1,jz
+        aa(j)=a(j)
+     enddo
+  endif
+!      call sleep_msec(0)
+  if(isign.eq.-1 .and. iform.eq.1) then
+     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_FORWARD,nflags)
+  else if(isign.eq.1 .and. iform.eq.1) then
+     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_BACKWARD,nflags)
+  else if(isign.eq.-1 .and. iform.eq.0) then
+     call sfftw_plan_dft_r2c_1d(plan(i),nfft,a,a,nflags)
+  else if(isign.eq.1 .and. iform.eq.-1) then
+     call sfftw_plan_dft_c2r_1d(plan(i),nfft,a,a,nflags)
+  else
+     stop 'Unsupported request in four2a'
+  endif
+!      call sleep_msec(0)
+  i=nplan
+  if(nfft.le.NSMALL) then
+     jz=nfft
+     if(iform.eq.0) jz=nfft/2
+     do j=1,jz
+        a(j)=aa(j)
+     enddo
+  endif
+
+10 continue
+!      call sleep_msec(0)
+  call sfftw_execute(plan(i))
+!      call sleep_msec(0)
+  return
+
+999 do i=1,nplan
+     call sfftw_destroy_plan(plan(i))
+  enddo
+
+  return
+end subroutine four2a


Property changes on: wsjt7a/four2b.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/gen441.f90
===================================================================
--- wsjt7a/gen441.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/gen441.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,24 +1,24 @@
-subroutine gen441(itone,ndits,cfrag)
-
-  integer itone(84)
-  complex cfrag(2100)
-
-! Generate iwave
-  twopi=8*atan(1.0)
-  dt=1.0/11025.0
-  k=0
-  NSPD=25
-  df=11025.0/NSPD
-  pha=0.
-  do m=1,ndits
-     freq=(itone(m)+1)*df
-     dpha=twopi*freq*dt
-     do i=1,NSPD
-        k=k+1
-        pha=pha+dpha
-        cfrag(k)=cmplx(cos(pha),-sin(pha))
-     enddo
-  enddo
-
-  return
-end subroutine gen441
+subroutine gen441(itone,ndits,cfrag)
+
+  integer itone(84)
+  complex cfrag(2100)
+
+! Generate iwave
+  twopi=8*atan(1.0)
+  dt=1.0/11025.0
+  k=0
+  NSPD=25
+  df=11025.0/NSPD
+  pha=0.
+  do m=1,ndits
+     freq=(itone(m)+1)*df
+     dpha=twopi*freq*dt
+     do i=1,NSPD
+        k=k+1
+        pha=pha+dpha
+        cfrag(k)=cmplx(cos(pha),-sin(pha))
+     enddo
+  enddo
+
+  return
+end subroutine gen441


Property changes on: wsjt7a/gen441.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/geniscat.f90
===================================================================
--- wsjt7a/geniscat.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/geniscat.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,105 +1,105 @@
-subroutine geniscat(msg,nmsg,shok,iwave,nwave,sendingsh,msgsent)
-
-! Generate an ISCAT_2 waveform.
-
-  parameter (NMAX=30*11025,NSZ=1291,NSPS=256)
-  character msg*28,msgsent*22
-  integer*2 iwave(NMAX)
-  integer sendingsh
-  logical first
-  integer shok
-  integer imsg(30)
-  integer itone(NSZ)
-  character c*42
-  real*8 twopi,dt,f0,f,df,pha,dpha
-  integer icos(4)
-  integer irpt(31)
-  data icos/0,1,3,2/
-  data nsync/4/,nlen/2/,ndat/18/,jz/645/
-  data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ /.?@-'/
-  data irpt/1,2,3,4,6,7,8,9,11,12,13,14,15,16,17,18,19,21,22,23,24,     &amp;
-       25,26,27,28,29,31,32,33,34,35/
-
-  twopi=8.d0*atan(1.d0)
-  df=11025.d0/NSPS
-  dt=1.d0/11025.d0
-  f0=13*df
-  nsym=NMAX/NSPS
-  sendingsh=0
-
-  if(shok.eq.1 .and. nmsg.le.4 .and.                                   &amp;
-       (msg(1:1).eq.'R' .or. msg(1:1).eq.'7')) then        !Check for shorthand
-     n=0
-     m=0
-     if(nmsg.eq.2 .and. msg(1:3).eq.'RO') n=5
-     if(nmsg.eq.3 .and. msg(1:3).eq.'R26') n=10
-     if(nmsg.eq.3 .and. msg(1:3).eq.'R27') n=20
-     if(nmsg.eq.3 .and. msg(1:3).eq.'RRR') n=30
-     if(nmsg.eq.2 .and. msg(1:2).eq.'73') n=40
-     if(n.eq.0 .and. msg(1:1).eq.'R') then
-        read(msg(2:4),*,err=10) m
-        if(m.lt.-20) m=-20
-        if(m.gt.10) m=10
-        write(msgsent,1002) m
-1002    format('R',i3)
-        if(msgsent(2:2).eq.' ') msgsent=msgsent(1:1)//msgsent(3:)
-        if(msgsent(2:2).eq.' ') msgsent=msgsent(1:1)//msgsent(3:)
-        n=irpt(m+21)
-     endif
-
-     if(n.ne.0) then
-        do i=1,nsym-1,2
-           itone(i)=0
-           itone(i+1)=n
-        enddo
-        sendingsh=1
-     endif
-
-  else
-10   nblk=nsync+nlen+ndat           !Normal message (NOT shorthand)
-     msglen=nmsg+1
-     k=0
-     kk=1
-     imsg(1)=40
-     do i=1,nmsg                                 !Define the tone sequence
-        imsg(i+1)=36
-        do j=1,42
-           if(msg(i:i).eq.c(j:j)) imsg(i+1)=j-1
-        enddo
-     enddo
-
-     do i=1,nsym                                 !Total symbols in 30 s 
-        j=mod(i-1,nblk)+1
-        if(j.le.nsync) then
-           itone(i)=icos(j)
-        else if(j.gt.nsync .and. j.le.nsync+nlen) then
-           itone(i)=msglen
-           if(j.ge.nsync+2) then
-              n=msglen + 5*(j-nsync-1)
-              if(n.gt.41) n=n-42
-              itone(i)=n
-           endif
-        else
-           k=k+1
-           kk=mod(k-1,msglen)+1
-           itone(i)=imsg(kk)
-        endif
-     enddo
-     msgsent=msg
-  endif
-
-  k=0
-  pha=0.
-  do m=1,nsym                                    !Generate iwave
-     f=f0 + itone(m)*df
-     dpha=twopi*f*dt
-     do i=1,NSPS
-        k=k+1
-        pha=pha+dpha
-        iwave(k)=nint(32767.0*sin(pha))
-     enddo
-  enddo
-  nwave=k
-
-  return
-end subroutine geniscat
+subroutine geniscat(msg,nmsg,shok,iwave,nwave,sendingsh,msgsent)
+
+! Generate an ISCAT_2 waveform.
+
+  parameter (NMAX=30*11025,NSZ=1291,NSPS=256)
+  character msg*28,msgsent*22
+  integer*2 iwave(NMAX)
+  integer sendingsh
+  logical first
+  integer shok
+  integer imsg(30)
+  integer itone(NSZ)
+  character c*42
+  real*8 twopi,dt,f0,f,df,pha,dpha
+  integer icos(4)
+  integer irpt(31)
+  data icos/0,1,3,2/
+  data nsync/4/,nlen/2/,ndat/18/,jz/645/
+  data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ /.?@-'/
+  data irpt/1,2,3,4,6,7,8,9,11,12,13,14,15,16,17,18,19,21,22,23,24,     &amp;
+       25,26,27,28,29,31,32,33,34,35/
+
+  twopi=8.d0*atan(1.d0)
+  df=11025.d0/NSPS
+  dt=1.d0/11025.d0
+  f0=13*df
+  nsym=NMAX/NSPS
+  sendingsh=0
+
+  if(shok.eq.1 .and. nmsg.le.4 .and.                                   &amp;
+       (msg(1:1).eq.'R' .or. msg(1:1).eq.'7')) then        !Check for shorthand
+     n=0
+     m=0
+     if(nmsg.eq.2 .and. msg(1:3).eq.'RO') n=5
+     if(nmsg.eq.3 .and. msg(1:3).eq.'R26') n=10
+     if(nmsg.eq.3 .and. msg(1:3).eq.'R27') n=20
+     if(nmsg.eq.3 .and. msg(1:3).eq.'RRR') n=30
+     if(nmsg.eq.2 .and. msg(1:2).eq.'73') n=40
+     if(n.eq.0 .and. msg(1:1).eq.'R') then
+        read(msg(2:4),*,err=10) m
+        if(m.lt.-20) m=-20
+        if(m.gt.10) m=10
+        write(msgsent,1002) m
+1002    format('R',i3)
+        if(msgsent(2:2).eq.' ') msgsent=msgsent(1:1)//msgsent(3:)
+        if(msgsent(2:2).eq.' ') msgsent=msgsent(1:1)//msgsent(3:)
+        n=irpt(m+21)
+     endif
+
+     if(n.ne.0) then
+        do i=1,nsym-1,2
+           itone(i)=0
+           itone(i+1)=n
+        enddo
+        sendingsh=1
+     endif
+
+  else
+10   nblk=nsync+nlen+ndat           !Normal message (NOT shorthand)
+     msglen=nmsg+1
+     k=0
+     kk=1
+     imsg(1)=40
+     do i=1,nmsg                                 !Define the tone sequence
+        imsg(i+1)=36
+        do j=1,42
+           if(msg(i:i).eq.c(j:j)) imsg(i+1)=j-1
+        enddo
+     enddo
+
+     do i=1,nsym                                 !Total symbols in 30 s 
+        j=mod(i-1,nblk)+1
+        if(j.le.nsync) then
+           itone(i)=icos(j)
+        else if(j.gt.nsync .and. j.le.nsync+nlen) then
+           itone(i)=msglen
+           if(j.ge.nsync+2) then
+              n=msglen + 5*(j-nsync-1)
+              if(n.gt.41) n=n-42
+              itone(i)=n
+           endif
+        else
+           k=k+1
+           kk=mod(k-1,msglen)+1
+           itone(i)=imsg(kk)
+        endif
+     enddo
+     msgsent=msg
+  endif
+
+  k=0
+  pha=0.
+  do m=1,nsym                                    !Generate iwave
+     f=f0 + itone(m)*df
+     dpha=twopi*f*dt
+     do i=1,NSPS
+        k=k+1
+        pha=pha+dpha
+        iwave(k)=nint(32767.0*sin(pha))
+     enddo
+  enddo
+  nwave=k
+
+  return
+end subroutine geniscat


Property changes on: wsjt7a/geniscat.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/genms.f90
===================================================================
--- wsjt7a/genms.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/genms.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,76 +1,76 @@
-subroutine genms(msg,iwave,nwave)
-
-! Generate a JTMS wavefile.
-
-  parameter (NMAX=30*11025)     !Max length of wave file
-  character*28 msg              !Message to be generated
-  character cc*64
-  integer sent(196)
-  real*8 dt,phi,f,f0,dfgen,dphi,twopi,foffset
-  integer*2 iwave(NMAX)         !Generated wave file
-!                   1         2         3         4         5         6
-!          0123456789012345678901234567890123456789012345678901234567890123
-  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ./?-                 _     @'/
-
-  do i=28,1,-1                                 !Find user's message length
-     if(msg(i:i).ne.' ') go to 1
-  enddo
-1 msglen=i+1                                   !Add one for space at EOM
-  if(msglen.gt.28) msglen=28
-
-! Convert message to a bit sequence, 7 bits per character (6 + even parity)
-  sent=0
-  k=0
-  do j=1,msglen
-     if(msg(j:j).eq.' ') then
-        i=58
-        go to 5
-     else
-        do i=1,64
-           if(msg(j:j).eq.cc(i:i)) go to 5
-        enddo
-     endif
-5    m=0
-     do n=5,0,-1                            !Each character gets 6 bits
-        k=k+1
-        sent(k)=iand(1,ishft(i-1,-n))
-        m=m+sent(k)
-     enddo
-     k=k+1
-     sent(k)=iand(m,1)                      !Insert parity bit
-  enddo
-  nsym=k
-
- ! Set up necessary constants
-  twopi=8.d0*atan(1.d0)
-  nsps=8
-  dt=1.d0/11025.d0
-  f0=11025.d0/nsps                               ! 1575.0 Hz
-  dfgen=0.5d0*f0                                 !  787.5 Hz
-  foffset=1500.d0 - f0
-  t=0.d0
-  k=0
-  phi=0.d0
-  nrpt=NMAX/(nsym*nsps)
-
-  do irpt=1,nrpt
-     do j=1,nsym
-        if(sent(j).eq.1) then
-           f=f0 + 0.5d0*dfgen + foffset
-        else
-           f=f0 - 0.5d0*dfgen + foffset
-        endif
-        dphi=twopi*f*dt
-        do i=1,nsps
-           k=k+1
-           phi=phi+dphi
-           iwave(k)=nint(32767.0*sin(phi))
-        enddo
-     enddo
-  enddo
-
-900 iwave(k+1:)=0
-  nwave=k
-
-  return
-end subroutine genms
+subroutine genms(msg,iwave,nwave)
+
+! Generate a JTMS wavefile.
+
+  parameter (NMAX=30*11025)     !Max length of wave file
+  character*28 msg              !Message to be generated
+  character cc*64
+  integer sent(196)
+  real*8 dt,phi,f,f0,dfgen,dphi,twopi,foffset
+  integer*2 iwave(NMAX)         !Generated wave file
+!                   1         2         3         4         5         6
+!          0123456789012345678901234567890123456789012345678901234567890123
+  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ./?-                 _     @'/
+
+  do i=28,1,-1                                 !Find user's message length
+     if(msg(i:i).ne.' ') go to 1
+  enddo
+1 msglen=i+1                                   !Add one for space at EOM
+  if(msglen.gt.28) msglen=28
+
+! Convert message to a bit sequence, 7 bits per character (6 + even parity)
+  sent=0
+  k=0
+  do j=1,msglen
+     if(msg(j:j).eq.' ') then
+        i=58
+        go to 5
+     else
+        do i=1,64
+           if(msg(j:j).eq.cc(i:i)) go to 5
+        enddo
+     endif
+5    m=0
+     do n=5,0,-1                            !Each character gets 6 bits
+        k=k+1
+        sent(k)=iand(1,ishft(i-1,-n))
+        m=m+sent(k)
+     enddo
+     k=k+1
+     sent(k)=iand(m,1)                      !Insert parity bit
+  enddo
+  nsym=k
+
+ ! Set up necessary constants
+  twopi=8.d0*atan(1.d0)
+  nsps=8
+  dt=1.d0/11025.d0
+  f0=11025.d0/nsps                               ! 1575.0 Hz
+  dfgen=0.5d0*f0                                 !  787.5 Hz
+  foffset=1500.d0 - f0
+  t=0.d0
+  k=0
+  phi=0.d0
+  nrpt=NMAX/(nsym*nsps)
+
+  do irpt=1,nrpt
+     do j=1,nsym
+        if(sent(j).eq.1) then
+           f=f0 + 0.5d0*dfgen + foffset
+        else
+           f=f0 - 0.5d0*dfgen + foffset
+        endif
+        dphi=twopi*f*dt
+        do i=1,nsps
+           k=k+1
+           phi=phi+dphi
+           iwave(k)=nint(32767.0*sin(phi))
+        enddo
+     enddo
+  enddo
+
+900 iwave(k+1:)=0
+  nwave=k
+
+  return
+end subroutine genms


Property changes on: wsjt7a/genms.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/genscat6.f90
===================================================================
--- wsjt7a/genscat6.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/genscat6.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,41 +1,41 @@
-subroutine genscat6(msg,itone)
-
-  character msg*28,msg1*29
-  character c*43
-  integer imsg(29)
-  integer itone(645)
-  integer icos6(6)
-  data icos6/0,1,4,3,5,2/
-  data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ .,?/#$'/  !1-43
-  data nsync/7/,ndat/14/
-
-  do i=28,1,-1
-     if(msg(i:i).ne.' ') go to 10
-  enddo
-10 msglen=i+1                      !Message length, including leading '$'
-  msg1='$'//msg
-
-  do i=1,msglen
-     i1=index(c,msg1(i:i))
-     imsg(i)=i1-1
-  enddo
-
-  ntot=ndat+nsync
-  k=0
-  kk=1
-  do i=1,645
-     j=mod(i-1,ntot)+1
-     if(j.lt.nsync) then
-        itone(i)=icos6(j)
-     else if(j.eq.nsync) then
-        itone(i)=msglen
-     else
-        k=k+1
-        kk=mod(k-1,msglen)+1
-        itone(i)=imsg(kk)
-     endif
-  enddo
-
-  return
-
-end subroutine genscat6
+subroutine genscat6(msg,itone)
+
+  character msg*28,msg1*29
+  character c*43
+  integer imsg(29)
+  integer itone(645)
+  integer icos6(6)
+  data icos6/0,1,4,3,5,2/
+  data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ .,?/#$'/  !1-43
+  data nsync/7/,ndat/14/
+
+  do i=28,1,-1
+     if(msg(i:i).ne.' ') go to 10
+  enddo
+10 msglen=i+1                      !Message length, including leading '$'
+  msg1='$'//msg
+
+  do i=1,msglen
+     i1=index(c,msg1(i:i))
+     imsg(i)=i1-1
+  enddo
+
+  ntot=ndat+nsync
+  k=0
+  kk=1
+  do i=1,645
+     j=mod(i-1,ntot)+1
+     if(j.lt.nsync) then
+        itone(i)=icos6(j)
+     else if(j.eq.nsync) then
+        itone(i)=msglen
+     else
+        k=k+1
+        kk=mod(k-1,msglen)+1
+        itone(i)=imsg(kk)
+     endif
+  enddo
+
+  return
+
+end subroutine genscat6


Property changes on: wsjt7a/genscat6.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/iscat.f90
===================================================================
--- wsjt7a/iscat.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/iscat.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,223 +1,223 @@
-subroutine iscat(dat,npts,cfile6,MinSigdB,DFTolerance,NFreeze,MouseDF,ccf,psavg)
-
-! Decode an ISCAT_2 signal
-
-  parameter (NMAX=512*1024)
-  parameter (NSZ=4*1292)
-  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
-  character cfile6*6                      !File time
-  character c42*42
-  character msg*28,msg1*28
-  real x(NSZ),x2(NSZ)
-  complex c(0:512)
-  real s0(128,NSZ)
-  real fs0(128,108)                       !108 = 96 + 3*4
-  real fs1(0:41,30)
-  real savg(128)
-  real savg2(128)
-  real b(128)
-  real ccfred(-10:10)
-  real ccfblue(0:95)
-  real ccf(-5:540)
-  real psavg(450)         !Average spectrum of the whole file
-  integer dftolerance
-  integer icos(4)
-  equivalence (x,c)
-  data icos/0,1,3,2/
-  data nsps/256/,nsync/4/,nlen/2/,ndat/18/
-  data c42/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ /.?@-'/
-  
-  nsym=npts/nsps
-  nblk=nsync+nlen+ndat
-  nfft=512                             !FFTs at twice the symbol length
-  kstep=nsps/4                         !Step by 1/4 symbol
-  nh=nfft/2
-  nq=nfft/4
-  df=11025.0/nfft
-  fac=1.0/1000.0                      !Somewhat arbitrary
-  savg=0.
-
-  ia=1-kstep
-  do j=1,4*nsym
-     ia=ia+kstep
-     ib=ia+nsps-1
-     if(ib.gt.npts) go to 10
-     x(1:nsps)=fac*dat(ia:ib)
-     x(nsps+1:nfft)=0.
-     call four2a(x,nfft,1,-1,0)
-     do i=1,nq
-        s0(i,j)=real(c(i))**2 + aimag(c(i))**2
-        savg(i)=savg(i) + s0(i,j)
-     enddo
-  enddo
-
-10 jsym=j-1
-
-  savg=savg/jsym
-  do i=1,nq
-     x(1:jsym)=s0(i,1:jsym)
-     call pctile(x,x2,jsym,30,b(i))
-  enddo
-  b(1:10)=b(11)
-  do i=1,nq/2
-     psavg(i)=2*db(savg(2*i)) + 10.0
-  enddo
-
-  do j=1,jsym
-     s0(1:nq,j)=s0(1:nq,j)/b(1:nq)
-  enddo
-
-  fs0=0.
-  jb=(jsym-4*nblk+1)/4
-  jb=4*jb
-  do j=1,jb                                  !Fold s0 modulo 4*nblk into fs0
-     k=mod(j-1,4*nblk)+1
-     fs0(1:nq,k)=fs0(1:nq,k) + s0(1:nq,j)
-  enddo
-
-  do j=1,12
-     fs0(1:nq,96+j)=fs0(1:nq,j)
-  enddo
-
-  i0=2*13
-  smax=0.
-  ipk=9999
-  jpk=9999
-  ia=-10
-  ib=10
-  if(nfreeze.eq.1) then
-     ia=(mousedf-dftolerance)/df
-     ib=(mousedf+dftolerance)/df
-  endif
-
-  do j=0,4*nblk-1                            !Find sync pattern, lags 0-95
-     do i=ia,ib
-        ss=0.
-        do n=1,4
-           k=j+4*n-3
-           if(k.gt.4*nblk) k=k-4*nblk
-           ss=ss + fs0(i0+i+2*icos(n),k)
-        enddo
-        if(ss.gt.smax) then
-           smax=ss
-           ipk=i0+i                          !Frequency offset, DF
-           jpk=j+1                           !Time offset, DT
-        endif
-     enddo
-  enddo
-
-  ref=fs0(ipk+2,jpk) + fs0(ipk+4,jpk) + fs0(ipk+6,jpk)  +        &amp;
-      fs0(ipk,jpk+4) + fs0(ipk+4,jpk+4) + fs0(ipk+6,jpk+4) +     &amp;
-      fs0(ipk,jpk+8) + fs0(ipk+2,jpk+8) + fs0(ipk+4,jpk+8) +     &amp;
-      fs0(ipk,jpk+12) + fs0(ipk+2,jpk+12) + fs0(ipk+6,jpk+12)
-  ref=ref/3.0
-
-  kk=0
-  do j=0,4*nblk-1
-     ss=0.
-     do n=1,4
-        k=j+4*n-3
-        if(k.gt.4*nblk) k=k-4*nblk
-        ss=ss + fs0(ipk+2*icos(n),k)
-     enddo
-     kk=kk+1
-     ccf(kk)=ss/ref
-  enddo
-
-  tping=jpk*kstep/11025.0
-  xsync=smax/ref
-  nsig=nint(db(smax/ref - 1.0) -15.0)
-  if(nsig.lt.-20) nsig=-20
-  ndf0=nint((ipk-i0) * 11025.0/nfft)
-  if(nsig.lt.MinSigdB) go to 800
-
-  if(ipk.gt.100 .or. jpk.gt.96) then
-     print*,'ipk:',ipk,'   jpk:',jpk
-     go to 900
-  endif
-  smax=0.
-  ja=jpk+16
-  if(ja.gt.4*nblk) ja=ja-4*nblk
-  jb=jpk+20
-  if(jb.gt.4*nblk) jb=jb-4*nblk
-  do i=ipk,ipk+60,2                         !Find User's message length
-     ss=fs0(i,ja) + fs0(i+10,jb)
-     if(ss.gt.smax) then
-        smax=ss
-        ipk2=i
-     endif
-  enddo
-
-  msglen=(ipk2-ipk)/2
-  if(msglen.lt.1 .or. msglen.gt.28) msglen=2         !### tests only ###
-  fs1=0.
-  jb=(jsym-4*nblk+1)/4
-  jb=4*jb
-  k=0
-  n=0
-  do j=jpk,jsym,4                         !Fold information symbols into fs1
-     k=k+1
-     if(mod(k-1,nblk)+1.gt.6) then
-        n=n+1
-        m=mod(n-1,msglen)+1
-        do i=0,41
-           fs1(i,m)=fs1(i,m) + s0(ipk+2*i,j)
-        enddo
-     endif
-  enddo
-
-! Read out the message:
-  msg1='                            '
-  mpk=0
-  worst=9999.
-  sum=0.
-  do m=1,msglen
-     smax=0.
-     smax2=0.
-     do i=0,41
-        if(fs1(i,m).gt.smax) then
-           smax=fs1(i,m)
-           ipk3=i
-        endif
-     enddo
-     do i=0,41
-        if(fs1(i,m).gt.smax2 .and. i.ne.ipk3) smax2=fs1(i,m)
-     enddo
-     rr=smax/smax2
-     sum=sum + rr
-     if(rr.lt.worst) worst=rr
-     if(ipk3.eq.40) mpk=m
-     msg1(m:m)=c42(ipk3+1:ipk3+1)
-  enddo
-
-  avg=sum/msglen
-  if(mpk.eq.1) then
-     msg=msg1(2:)
-  else if(mpk.lt.msglen) then
-     msg=msg1(mpk+1:msglen)//msg1(1:mpk-1)
-  else
-     msg=msg1(1:msglen-1)
-  endif
-
-800 continue
-  if(nsig.lt.MinSigdB) then
-     msglen=0
-     worst=1.
-     avg=1.
-  endif
-  nworst=10.0*(worst-1.0)
-  navg=10.0*(avg-1.0)
-  if(nworst.gt.10) nworst=10
-  if(navg.gt.10) navg=10
-  xsync=xsync-0.3
-  isync=xsync
-  if(navg.le.0) msg=' '
-
-  write(11,1020) cfile6,nsig,ndf0,msg,msglen,nworst,navg
-  write(21,1020) cfile6,nsig,ndf0,msg,msglen,nworst,navg
-1020 format(a6,i5,i5,6x,a28,i4,2i3)
-  call flush(11)
-  call flush(21)
-
-900 return
-end subroutine iscat
+subroutine iscat(dat,npts,cfile6,MinSigdB,DFTolerance,NFreeze,MouseDF,ccf,psavg)
+
+! Decode an ISCAT_2 signal
+
+  parameter (NMAX=512*1024)
+  parameter (NSZ=4*1292)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  character cfile6*6                      !File time
+  character c42*42
+  character msg*28,msg1*28
+  real x(NSZ),x2(NSZ)
+  complex c(0:512)
+  real s0(128,NSZ)
+  real fs0(128,108)                       !108 = 96 + 3*4
+  real fs1(0:41,30)
+  real savg(128)
+  real savg2(128)
+  real b(128)
+  real ccfred(-10:10)
+  real ccfblue(0:95)
+  real ccf(-5:540)
+  real psavg(450)         !Average spectrum of the whole file
+  integer dftolerance
+  integer icos(4)
+  equivalence (x,c)
+  data icos/0,1,3,2/
+  data nsps/256/,nsync/4/,nlen/2/,ndat/18/
+  data c42/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ /.?@-'/
+  
+  nsym=npts/nsps
+  nblk=nsync+nlen+ndat
+  nfft=512                             !FFTs at twice the symbol length
+  kstep=nsps/4                         !Step by 1/4 symbol
+  nh=nfft/2
+  nq=nfft/4
+  df=11025.0/nfft
+  fac=1.0/1000.0                      !Somewhat arbitrary
+  savg=0.
+
+  ia=1-kstep
+  do j=1,4*nsym
+     ia=ia+kstep
+     ib=ia+nsps-1
+     if(ib.gt.npts) go to 10
+     x(1:nsps)=fac*dat(ia:ib)
+     x(nsps+1:nfft)=0.
+     call four2a(x,nfft,1,-1,0)
+     do i=1,nq
+        s0(i,j)=real(c(i))**2 + aimag(c(i))**2
+        savg(i)=savg(i) + s0(i,j)
+     enddo
+  enddo
+
+10 jsym=j-1
+
+  savg=savg/jsym
+  do i=1,nq
+     x(1:jsym)=s0(i,1:jsym)
+     call pctile(x,x2,jsym,30,b(i))
+  enddo
+  b(1:10)=b(11)
+  do i=1,nq/2
+     psavg(i)=2*db(savg(2*i)) + 10.0
+  enddo
+
+  do j=1,jsym
+     s0(1:nq,j)=s0(1:nq,j)/b(1:nq)
+  enddo
+
+  fs0=0.
+  jb=(jsym-4*nblk+1)/4
+  jb=4*jb
+  do j=1,jb                                  !Fold s0 modulo 4*nblk into fs0
+     k=mod(j-1,4*nblk)+1
+     fs0(1:nq,k)=fs0(1:nq,k) + s0(1:nq,j)
+  enddo
+
+  do j=1,12
+     fs0(1:nq,96+j)=fs0(1:nq,j)
+  enddo
+
+  i0=2*13
+  smax=0.
+  ipk=9999
+  jpk=9999
+  ia=-10
+  ib=10
+  if(nfreeze.eq.1) then
+     ia=(mousedf-dftolerance)/df
+     ib=(mousedf+dftolerance)/df
+  endif
+
+  do j=0,4*nblk-1                            !Find sync pattern, lags 0-95
+     do i=ia,ib
+        ss=0.
+        do n=1,4
+           k=j+4*n-3
+           if(k.gt.4*nblk) k=k-4*nblk
+           ss=ss + fs0(i0+i+2*icos(n),k)
+        enddo
+        if(ss.gt.smax) then
+           smax=ss
+           ipk=i0+i                          !Frequency offset, DF
+           jpk=j+1                           !Time offset, DT
+        endif
+     enddo
+  enddo
+
+  ref=fs0(ipk+2,jpk) + fs0(ipk+4,jpk) + fs0(ipk+6,jpk)  +        &amp;
+      fs0(ipk,jpk+4) + fs0(ipk+4,jpk+4) + fs0(ipk+6,jpk+4) +     &amp;
+      fs0(ipk,jpk+8) + fs0(ipk+2,jpk+8) + fs0(ipk+4,jpk+8) +     &amp;
+      fs0(ipk,jpk+12) + fs0(ipk+2,jpk+12) + fs0(ipk+6,jpk+12)
+  ref=ref/3.0
+
+  kk=0
+  do j=0,4*nblk-1
+     ss=0.
+     do n=1,4
+        k=j+4*n-3
+        if(k.gt.4*nblk) k=k-4*nblk
+        ss=ss + fs0(ipk+2*icos(n),k)
+     enddo
+     kk=kk+1
+     ccf(kk)=ss/ref
+  enddo
+
+  tping=jpk*kstep/11025.0
+  xsync=smax/ref
+  nsig=nint(db(smax/ref - 1.0) -15.0)
+  if(nsig.lt.-20) nsig=-20
+  ndf0=nint((ipk-i0) * 11025.0/nfft)
+  if(nsig.lt.MinSigdB) go to 800
+
+  if(ipk.gt.100 .or. jpk.gt.96) then
+     print*,'ipk:',ipk,'   jpk:',jpk
+     go to 900
+  endif
+  smax=0.
+  ja=jpk+16
+  if(ja.gt.4*nblk) ja=ja-4*nblk
+  jb=jpk+20
+  if(jb.gt.4*nblk) jb=jb-4*nblk
+  do i=ipk,ipk+60,2                         !Find User's message length
+     ss=fs0(i,ja) + fs0(i+10,jb)
+     if(ss.gt.smax) then
+        smax=ss
+        ipk2=i
+     endif
+  enddo
+
+  msglen=(ipk2-ipk)/2
+  if(msglen.lt.1 .or. msglen.gt.28) msglen=2         !### tests only ###
+  fs1=0.
+  jb=(jsym-4*nblk+1)/4
+  jb=4*jb
+  k=0
+  n=0
+  do j=jpk,jsym,4                         !Fold information symbols into fs1
+     k=k+1
+     if(mod(k-1,nblk)+1.gt.6) then
+        n=n+1
+        m=mod(n-1,msglen)+1
+        do i=0,41
+           fs1(i,m)=fs1(i,m) + s0(ipk+2*i,j)
+        enddo
+     endif
+  enddo
+
+! Read out the message:
+  msg1='                            '
+  mpk=0
+  worst=9999.
+  sum=0.
+  do m=1,msglen
+     smax=0.
+     smax2=0.
+     do i=0,41
+        if(fs1(i,m).gt.smax) then
+           smax=fs1(i,m)
+           ipk3=i
+        endif
+     enddo
+     do i=0,41
+        if(fs1(i,m).gt.smax2 .and. i.ne.ipk3) smax2=fs1(i,m)
+     enddo
+     rr=smax/smax2
+     sum=sum + rr
+     if(rr.lt.worst) worst=rr
+     if(ipk3.eq.40) mpk=m
+     msg1(m:m)=c42(ipk3+1:ipk3+1)
+  enddo
+
+  avg=sum/msglen
+  if(mpk.eq.1) then
+     msg=msg1(2:)
+  else if(mpk.lt.msglen) then
+     msg=msg1(mpk+1:msglen)//msg1(1:mpk-1)
+  else
+     msg=msg1(1:msglen-1)
+  endif
+
+800 continue
+  if(nsig.lt.MinSigdB) then
+     msglen=0
+     worst=1.
+     avg=1.
+  endif
+  nworst=10.0*(worst-1.0)
+  navg=10.0*(avg-1.0)
+  if(nworst.gt.10) nworst=10
+  if(navg.gt.10) navg=10
+  xsync=xsync-0.3
+  isync=xsync
+  if(navg.le.0) msg=' '
+
+  write(11,1020) cfile6,nsig,ndf0,msg,msglen,nworst,navg
+  write(21,1020) cfile6,nsig,ndf0,msg,msglen,nworst,navg
+1020 format(a6,i5,i5,6x,a28,i4,2i3)
+  call flush(11)
+  call flush(21)
+
+900 return
+end subroutine iscat


Property changes on: wsjt7a/iscat.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/makepings.f90
===================================================================
--- wsjt7a/makepings.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/makepings.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,28 +1,28 @@
-subroutine makepings(iwave,nwave)
-
-  integer*2 iwave(nwave)
-  real*8 t
-
-  iping0=-999
-  dt=1.0/11025.0
-  do i=1,nwave
-     iping=i/(3*11025)
-     if(iping.ne.iping0) then
-        ip=mod(iping,3)
-        w=0.015*(4-ip)
-        ig=(iping-1)/3
-        amp=sqrt((3.0-ig)/3.0)
-        t0=dt*(iping+0.5)*(3*11025)
-        iping0=iping
-     endif
-     t=(i*dt-t0)/w
-     if(t.lt.0.d0 .and. t.lt.10.0) then
-        fac=0.
-     else
-        fac=2.718*t*dexp(-t)
-     endif
-     iwave(i)=nint(fac*amp*iwave(i))
-  enddo
-
-  return
-end subroutine makepings
+subroutine makepings(iwave,nwave)
+
+  integer*2 iwave(nwave)
+  real*8 t
+
+  iping0=-999
+  dt=1.0/11025.0
+  do i=1,nwave
+     iping=i/(3*11025)
+     if(iping.ne.iping0) then
+        ip=mod(iping,3)
+        w=0.015*(4-ip)
+        ig=(iping-1)/3
+        amp=sqrt((3.0-ig)/3.0)
+        t0=dt*(iping+0.5)*(3*11025)
+        iping0=iping
+     endif
+     t=(i*dt-t0)/w
+     if(t.lt.0.d0 .and. t.lt.10.0) then
+        fac=0.
+     else
+        fac=2.718*t*dexp(-t)
+     endif
+     iwave(i)=nint(fac*amp*iwave(i))
+  enddo
+
+  return
+end subroutine makepings


Property changes on: wsjt7a/makepings.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/pp441.f90
===================================================================
--- wsjt7a/pp441.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/pp441.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,296 +1,296 @@
-subroutine pp441(dat,jz,cfile6,tstart,t2,width,npeak,nrpt,     &amp;
-     dftolerance,frag,ncon)
-
-! FSK441++ decoder
-
-  parameter (NMAX=512*1024)
-  parameter (MAXFFT=8192)
-  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
-  complex cdat(NMAX)                      !Analytic form of signal
-  character cfile6*6                      !File time
-  character frag*28,frag0*28              !Message fragment to be matched
-  character msg*40
-  character*28 msg0,msg1,msg2,msg3
-  character c1*1,tok1*4,tok2*4
-  complex cfrag(2100)                     !Complex waveform of message fragment
-  complex ct0(25)
-  complex ct1(25)
-  complex ct2(25)
-  complex ct3(25)
-  complex z
-  complex zz(0:3)
-  real r(0:3)
-  real rf(0:3)
-  real spec(0:3)
-  integer nspec(0:3)
-  integer itone(84)                       !Generated tones for msg fragment
-  real s(NMAX)
-  real ccf(-6000:6000)
-  integer dftolerance
-  integer dit(-3000:3000)
-  real y(0:3,-3000:3000)
-  complex za(0:3,-3000:3000)
-  real yf(0:3,0:86)
-  integer nf(0:86)
-  integer ditf(0:86)
-  character c*48
-  character*90 line
-  common/ccom/nline,tping(100),line(100)
-  common/scratch/work(NMAX)
-  data c/' 123456789.,?/# $ABCD FGHIJKLMNOPQRSTUVWXY 0EZ*!'/
-  data frag0/'xxxxx'/
-  save frag0,cfrag,ct0,ct1,ct2,ct3,ndits
-
-  if(frag.ne.frag0) then
-     do i=28,1,-1                          !Get length of message fragment
-        if(frag(i:i).ne.' ') go to 10
-     enddo
-10   nfrag=1000+i
-     call abc441(frag,nfrag,itone,ndits)
-     call gen441(itone,ndits,cfrag)        !Generate complex waveform
-
-     call gen441(1,1,ct0)                  !Generate complex symbol waveforms
-     call gen441(2,1,ct1)
-     call gen441(3,1,ct2)
-     call gen441(4,1,ct3)
-     frag0=frag
-  endif
-
-  nsps=25                                  !Initialize variables
-  nsam=nsps*ndits
-  mswidth=10*nint(100.0*width)
-  dt=1.0/11025.0
-  i0=(tstart-0.02)/dt
-  if(i0.lt.1) i0=1
-  npts=nint((width+0.02)/dt)+1
-  npts=min(npts,jz+1-i0)
-  xn=log(float(npts))/log(2.0)
-  n=xn
-  if(xn-n .gt.0.001) n=n+1
-  nfft1=2**n
-  df1=11025.0/nfft1
-
-  call analytic(dat(i0),npts,nfft1,s,cdat)    !Convert to analytic signal
-
-  ia=dftolerance/df1
-  ccfmax=0.
-  do i=-ia,ia                                 !Find DF
-     ccf(i)=s(i+nint(882.0/df1)) + s(i+nint(1323.0/df1)) +           &amp;
-          s(i+nint(1764.0/df1)) + s(i+nint(2205.0/df1))
-  enddo
-  ccf(:-ia-1)=0.
-  ccf(ia+1:)=0.
-  nadd=2*nint(5.0/df1)+1
-  call smo(ccf(-ia),2*ia+1,work,nadd)         !Smooth CCF by nadd
-
-  do i=-ia,ia                                 !Fin max of smoothed CCF
-     if(ccf(i).gt.ccfmax) then
-        ccfmax=ccf(i)
-        ipk=i
-        dfx=i*df1
-     endif
-  enddo
-  ib=min(nint(220.5/df1),ia)                  !Search range +/- 220.5 Hz
-  call pctile(ccf(ipk-ib),work,2*ib+1,50,base)
-  ccfmax=ccfmax/base
-  if(ccfmax.lt.4.0) go to 800                 !Is CCF search successful?
-
-! We seem to have an FSK441 ping, and we know DF; now find DT.
-  call tweak1(cdat,npts,-dfx,cdat)            !Mix to standard frequency
-
-! Look for best match to &quot;frag&quot;, find its DT
-  sbest=0.
-  fac=1.e-6/base
-  do i=1,npts-nsam
-     z=0.
-     do j=1,nsam
-        z=z + cdat(j+i-1)*cfrag(j)
-     enddo
-     ss=(real(z)**2 + aimag(z)**2)*fac
-     if(ss.gt.sbest) then
-        sbest=ss
-        ibest=i
-        tbest=(i+i0-1)*dt
-     endif
-  enddo
-
-  if(sbest.lt.0.25*ccfmax) go to 800     !Skip if not decodable FSK441++ data
-
-! We know DF and DT; now demodulate and decode.
-  spec=0.
-  nspec=0
-  n=ibest/nsps - 1
-  i1a=ibest-n*nsps
-  n=(npts-nsps+1)/nsps - 1
-  i1b=i1a+n*nsps
-
-! Full range of potentially useful symbols is is1 to is2:
-  is1=(1-ibest)/nsps
-  is2=(npts-nsps+1-ibest)/nsps
-
-! Demodulate the symbols
-  do i1=i1a,i1b,nsps                      
-     is=(i1-ibest)/nsps
-     sq=dot_product(cdat(i1:i1+nsps-1),cdat(i1:i1+nsps-1))
-     rms=sqrt(sq)
-     zz(0)=dot_product(cdat(i1:i1+nsps-1),conjg(ct0))/rms
-     zz(1)=dot_product(cdat(i1:i1+nsps-1),conjg(ct1))/rms
-     zz(2)=dot_product(cdat(i1:i1+nsps-1),conjg(ct2))/rms
-     zz(3)=dot_product(cdat(i1:i1+nsps-1),conjg(ct3))/rms
-     
-     rmax=0.
-     do i=0,3
-        r(i)=abs(zz(i))
-        za(i,is)=zz(i)
-        if(r(i).gt.rmax) then
-           rmax=r(i)                        !Non-coherent demodulation
-           ipk=i
-        endif
-     enddo
-     do i=0,3
-        if(i.ne.ipk) then
-           spec(i)=spec(i)+r(i)             !Accumulate an avg 4-pt spectrum
-           nspec(i)=nspec(i)+1
-        endif
-     enddo
-  enddo
-  
-  do i=0,3                                  !Normalize the 4-pt spectrum
-     if(nspec(i).gt.0) then
-        spec(i)=spec(i)/nspec(i)
-     else
-        spec(i)=1.0
-     endif
-  enddo
-  
-  do i1=i1a,i1b,nsps                     !Get the dit values
-     is=(i1-ibest)/nsps
-     rmax=0.
-     do i=0,3
-        za(i,is)=za(i,is)/spec(i)
-        zz(i)=za(i,is)
-        r(i)=abs(zz(i))                  !Non-coherent amplitude
-        y(i,is)=r(i)
-        if(r(i).gt.rmax) then
-           rmax=r(i)
-           ipk=i
-        endif
-     enddo
-     dit(is)=ipk
-  enddo
-
-  nc=16*dit(6) + 4*dit(7) +dit(8)
-  c1=' '
-  if(nc.ge.0 .and. nc.le.47) c1=c(nc+1:nc+1)
-  if(c1.eq.' ') c1='_'
-  call token(c1,n1,tok1,n2)                     !Get length encoded in msg, n2
-  if(n2.eq.0) go to 800
-  nc=16*dit(9) + 4*dit(10) +dit(11)
-  c1=' '
-  if(nc.ge.0 .and. nc.le.47) c1=c(nc+1:nc+1)
-  if(c1.eq.' ') c1='_'
-  call token(c1,n3,tok2,n4)                     !Get encoded token, if any
-
-  msg='                                        '
-  msglen=min((is2-is1+1)/3,40)         !Legth of potentially decodable text
-  j=is1/3                              !Set starting location
-  j=3*j
-
-  do i=1,msglen                        !Read off the hard-decision message
-     j=j+3
-     nc=16*dit(j) + 4*dit(j+1) +dit(j+2)
-     msg(i:i)=' '
-     if(nc.le.47 .and. nc.ge.0) msg(i:i)=c(nc+1:nc+1)
-  enddo
-
-  call cs_lock('pp441')
-! Probably shouldn't write multiple times, just use the best one:
-  msg0='@'
-  do i=1,msglen-n2-1
-     if(msg(i:i+1).eq.'$!') then
-        msg1=msg(i:i+n2-1)
-        call dec441(msg1,n2,msg2)
-        i3=index(msg2,'$')
-        if(i3.gt.3) msg2=msg2(:i3-1)
-        i4=index(msg2,'!')
-        if(i4.gt.4) msg2=msg2(:i4-2)
-        call msgtrim(msg2,junk)
-        if(msg2.ne.msg0) then
-           if(ncon.ne.0) write(*,1110) cfile6,tbest,mswidth,npeak,     &amp;
-                nrpt,nint(dfx),msg2,ccfmax,sbest/ccfmax,n2,'+ '
-1110       format(a6,f5.1,i5,i3,1x,i2.2,i5,5x,a28,f8.1,f6.2,i3,a2)
-           if(nline.le.99) nline=nline+1
-           tping(nline)=t2
-           write(line(nline),1110) cfile6,t2,mswidth,npeak,        &amp;
-                nrpt,nint(dfx),msg2,ccfmax,sbest/ccfmax,n2,'+ '
-           msg0=msg2
-        endif
-     endif
-  enddo
-  call cs_unlock
-
-  if(n2.ge.4) then
-! Fold the y() array to get average message
-     yf=0.
-     nf=0
-     do j=is1,is2                          !Use weighted averages ?
-        k=mod(j+300*n2,3*n2)
-        yf(0,k)=yf(0,k) + y(0,j)
-        yf(1,k)=yf(1,k) + y(1,j)
-        yf(2,k)=yf(2,k) + y(2,j)
-        yf(3,k)=yf(3,k) + y(3,j)
-        nf(k)=nf(k)+1
-     enddo
-
-     do k=0,3*n2-1                     !Get dit values for averaged spectrum
-        if(nf(k).gt.0) then
-           rmax=0.
-           do i=0,3
-              rf(i)=yf(i,k)/nf(k)
-              if(rf(i).gt.rmax) then
-                 rmax=rf(i)
-                 ipk=i
-              endif
-           enddo
-        endif
-        ditf(k)=ipk
-     enddo
-
-     j=-3
-     msg='                                        '
-     do i=1,n2                                !Read off the averaged message
-        j=j+3
-        nc=16*ditf(j) + 4*ditf(j+1) +ditf(j+2)
-        msg(i:i)=' '
-        if(nc.le.47 .and. nc.ge.0) msg(i:i)=c(nc+1:nc+1)
-     enddo
-     c1=msg(4:4)
-     if(c1.eq.' ') c1='_'
-     call token(c1,n3,tok2,n4)              !Get encoded token, if any
-     msg3=msg(5:n2)
-     if(n3.ge.1 .and. n3.le.3) then
-        if(tok2(3:3).eq.' ') msg3=tok2(1:3)//msg3
-        if(tok2(3:3).ne.' ') msg3=tok2//msg3
-     endif
-     if(n3.ge.4 .and. n3.le.11) then
-        do i=n2,1,-1
-           if(msg3(i:i).ne.' ') go to 100
-        enddo
-100     msg3=msg3(1:i)//tok2
-        if(i.eq.0) msg3=msg3(1:i)//tok2(2:)
-     endif
-
-     call cs_lock('pp441')
-     if(ncon.ne.0) write(*,1110) cfile6,tbest,mswidth,npeak,nrpt,     &amp;
-          nint(dfx),msg3,ccfmax,sbest/ccfmax,n2,'++'
-        if(nline.le.99) nline=nline+1
-        tping(nline)=t2
-        write(line(nline),1110) cfile6,t2,mswidth,npeak,              &amp;
-             nrpt,nint(dfx),msg3,ccfmax,sbest/ccfmax,n2,'++'
-     call cs_unlock
-  endif
-
-800 continue
-
-  return
-end subroutine pp441
+subroutine pp441(dat,jz,cfile6,tstart,t2,width,npeak,nrpt,     &amp;
+     dftolerance,frag,ncon)
+
+! FSK441++ decoder
+
+  parameter (NMAX=512*1024)
+  parameter (MAXFFT=8192)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  complex cdat(NMAX)                      !Analytic form of signal
+  character cfile6*6                      !File time
+  character frag*28,frag0*28              !Message fragment to be matched
+  character msg*40
+  character*28 msg0,msg1,msg2,msg3
+  character c1*1,tok1*4,tok2*4
+  complex cfrag(2100)                     !Complex waveform of message fragment
+  complex ct0(25)
+  complex ct1(25)
+  complex ct2(25)
+  complex ct3(25)
+  complex z
+  complex zz(0:3)
+  real r(0:3)
+  real rf(0:3)
+  real spec(0:3)
+  integer nspec(0:3)
+  integer itone(84)                       !Generated tones for msg fragment
+  real s(NMAX)
+  real ccf(-6000:6000)
+  integer dftolerance
+  integer dit(-3000:3000)
+  real y(0:3,-3000:3000)
+  complex za(0:3,-3000:3000)
+  real yf(0:3,0:86)
+  integer nf(0:86)
+  integer ditf(0:86)
+  character c*48
+  character*90 line
+  common/ccom/nline,tping(100),line(100)
+  common/scratch/work(NMAX)
+  data c/' 123456789.,?/# $ABCD FGHIJKLMNOPQRSTUVWXY 0EZ*!'/
+  data frag0/'xxxxx'/
+  save frag0,cfrag,ct0,ct1,ct2,ct3,ndits
+
+  if(frag.ne.frag0) then
+     do i=28,1,-1                          !Get length of message fragment
+        if(frag(i:i).ne.' ') go to 10
+     enddo
+10   nfrag=1000+i
+     call abc441(frag,nfrag,itone,ndits)
+     call gen441(itone,ndits,cfrag)        !Generate complex waveform
+
+     call gen441(1,1,ct0)                  !Generate complex symbol waveforms
+     call gen441(2,1,ct1)
+     call gen441(3,1,ct2)
+     call gen441(4,1,ct3)
+     frag0=frag
+  endif
+
+  nsps=25                                  !Initialize variables
+  nsam=nsps*ndits
+  mswidth=10*nint(100.0*width)
+  dt=1.0/11025.0
+  i0=(tstart-0.02)/dt
+  if(i0.lt.1) i0=1
+  npts=nint((width+0.02)/dt)+1
+  npts=min(npts,jz+1-i0)
+  xn=log(float(npts))/log(2.0)
+  n=xn
+  if(xn-n .gt.0.001) n=n+1
+  nfft1=2**n
+  df1=11025.0/nfft1
+
+  call analytic(dat(i0),npts,nfft1,s,cdat)    !Convert to analytic signal
+
+  ia=dftolerance/df1
+  ccfmax=0.
+  do i=-ia,ia                                 !Find DF
+     ccf(i)=s(i+nint(882.0/df1)) + s(i+nint(1323.0/df1)) +           &amp;
+          s(i+nint(1764.0/df1)) + s(i+nint(2205.0/df1))
+  enddo
+  ccf(:-ia-1)=0.
+  ccf(ia+1:)=0.
+  nadd=2*nint(5.0/df1)+1
+  call smo(ccf(-ia),2*ia+1,work,nadd)         !Smooth CCF by nadd
+
+  do i=-ia,ia                                 !Fin max of smoothed CCF
+     if(ccf(i).gt.ccfmax) then
+        ccfmax=ccf(i)
+        ipk=i
+        dfx=i*df1
+     endif
+  enddo
+  ib=min(nint(220.5/df1),ia)                  !Search range +/- 220.5 Hz
+  call pctile(ccf(ipk-ib),work,2*ib+1,50,base)
+  ccfmax=ccfmax/base
+  if(ccfmax.lt.4.0) go to 800                 !Is CCF search successful?
+
+! We seem to have an FSK441 ping, and we know DF; now find DT.
+  call tweak1(cdat,npts,-dfx,cdat)            !Mix to standard frequency
+
+! Look for best match to &quot;frag&quot;, find its DT
+  sbest=0.
+  fac=1.e-6/base
+  do i=1,npts-nsam
+     z=0.
+     do j=1,nsam
+        z=z + cdat(j+i-1)*cfrag(j)
+     enddo
+     ss=(real(z)**2 + aimag(z)**2)*fac
+     if(ss.gt.sbest) then
+        sbest=ss
+        ibest=i
+        tbest=(i+i0-1)*dt
+     endif
+  enddo
+
+  if(sbest.lt.0.25*ccfmax) go to 800     !Skip if not decodable FSK441++ data
+
+! We know DF and DT; now demodulate and decode.
+  spec=0.
+  nspec=0
+  n=ibest/nsps - 1
+  i1a=ibest-n*nsps
+  n=(npts-nsps+1)/nsps - 1
+  i1b=i1a+n*nsps
+
+! Full range of potentially useful symbols is is1 to is2:
+  is1=(1-ibest)/nsps
+  is2=(npts-nsps+1-ibest)/nsps
+
+! Demodulate the symbols
+  do i1=i1a,i1b,nsps                      
+     is=(i1-ibest)/nsps
+     sq=dot_product(cdat(i1:i1+nsps-1),cdat(i1:i1+nsps-1))
+     rms=sqrt(sq)
+     zz(0)=dot_product(cdat(i1:i1+nsps-1),conjg(ct0))/rms
+     zz(1)=dot_product(cdat(i1:i1+nsps-1),conjg(ct1))/rms
+     zz(2)=dot_product(cdat(i1:i1+nsps-1),conjg(ct2))/rms
+     zz(3)=dot_product(cdat(i1:i1+nsps-1),conjg(ct3))/rms
+     
+     rmax=0.
+     do i=0,3
+        r(i)=abs(zz(i))
+        za(i,is)=zz(i)
+        if(r(i).gt.rmax) then
+           rmax=r(i)                        !Non-coherent demodulation
+           ipk=i
+        endif
+     enddo
+     do i=0,3
+        if(i.ne.ipk) then
+           spec(i)=spec(i)+r(i)             !Accumulate an avg 4-pt spectrum
+           nspec(i)=nspec(i)+1
+        endif
+     enddo
+  enddo
+  
+  do i=0,3                                  !Normalize the 4-pt spectrum
+     if(nspec(i).gt.0) then
+        spec(i)=spec(i)/nspec(i)
+     else
+        spec(i)=1.0
+     endif
+  enddo
+  
+  do i1=i1a,i1b,nsps                     !Get the dit values
+     is=(i1-ibest)/nsps
+     rmax=0.
+     do i=0,3
+        za(i,is)=za(i,is)/spec(i)
+        zz(i)=za(i,is)
+        r(i)=abs(zz(i))                  !Non-coherent amplitude
+        y(i,is)=r(i)
+        if(r(i).gt.rmax) then
+           rmax=r(i)
+           ipk=i
+        endif
+     enddo
+     dit(is)=ipk
+  enddo
+
+  nc=16*dit(6) + 4*dit(7) +dit(8)
+  c1=' '
+  if(nc.ge.0 .and. nc.le.47) c1=c(nc+1:nc+1)
+  if(c1.eq.' ') c1='_'
+  call token(c1,n1,tok1,n2)                     !Get length encoded in msg, n2
+  if(n2.eq.0) go to 800
+  nc=16*dit(9) + 4*dit(10) +dit(11)
+  c1=' '
+  if(nc.ge.0 .and. nc.le.47) c1=c(nc+1:nc+1)
+  if(c1.eq.' ') c1='_'
+  call token(c1,n3,tok2,n4)                     !Get encoded token, if any
+
+  msg='                                        '
+  msglen=min((is2-is1+1)/3,40)         !Legth of potentially decodable text
+  j=is1/3                              !Set starting location
+  j=3*j
+
+  do i=1,msglen                        !Read off the hard-decision message
+     j=j+3
+     nc=16*dit(j) + 4*dit(j+1) +dit(j+2)
+     msg(i:i)=' '
+     if(nc.le.47 .and. nc.ge.0) msg(i:i)=c(nc+1:nc+1)
+  enddo
+
+  call cs_lock('pp441')
+! Probably shouldn't write multiple times, just use the best one:
+  msg0='@'
+  do i=1,msglen-n2-1
+     if(msg(i:i+1).eq.'$!') then
+        msg1=msg(i:i+n2-1)
+        call dec441(msg1,n2,msg2)
+        i3=index(msg2,'$')
+        if(i3.gt.3) msg2=msg2(:i3-1)
+        i4=index(msg2,'!')
+        if(i4.gt.4) msg2=msg2(:i4-2)
+        call msgtrim(msg2,junk)
+        if(msg2.ne.msg0) then
+           if(ncon.ne.0) write(*,1110) cfile6,tbest,mswidth,npeak,     &amp;
+                nrpt,nint(dfx),msg2,ccfmax,sbest/ccfmax,n2,'+ '
+1110       format(a6,f5.1,i5,i3,1x,i2.2,i5,5x,a28,f8.1,f6.2,i3,a2)
+           if(nline.le.99) nline=nline+1
+           tping(nline)=t2
+           write(line(nline),1110) cfile6,t2,mswidth,npeak,        &amp;
+                nrpt,nint(dfx),msg2,ccfmax,sbest/ccfmax,n2,'+ '
+           msg0=msg2
+        endif
+     endif
+  enddo
+  call cs_unlock
+
+  if(n2.ge.4) then
+! Fold the y() array to get average message
+     yf=0.
+     nf=0
+     do j=is1,is2                          !Use weighted averages ?
+        k=mod(j+300*n2,3*n2)
+        yf(0,k)=yf(0,k) + y(0,j)
+        yf(1,k)=yf(1,k) + y(1,j)
+        yf(2,k)=yf(2,k) + y(2,j)
+        yf(3,k)=yf(3,k) + y(3,j)
+        nf(k)=nf(k)+1
+     enddo
+
+     do k=0,3*n2-1                     !Get dit values for averaged spectrum
+        if(nf(k).gt.0) then
+           rmax=0.
+           do i=0,3
+              rf(i)=yf(i,k)/nf(k)
+              if(rf(i).gt.rmax) then
+                 rmax=rf(i)
+                 ipk=i
+              endif
+           enddo
+        endif
+        ditf(k)=ipk
+     enddo
+
+     j=-3
+     msg='                                        '
+     do i=1,n2                                !Read off the averaged message
+        j=j+3
+        nc=16*ditf(j) + 4*ditf(j+1) +ditf(j+2)
+        msg(i:i)=' '
+        if(nc.le.47 .and. nc.ge.0) msg(i:i)=c(nc+1:nc+1)
+     enddo
+     c1=msg(4:4)
+     if(c1.eq.' ') c1='_'
+     call token(c1,n3,tok2,n4)              !Get encoded token, if any
+     msg3=msg(5:n2)
+     if(n3.ge.1 .and. n3.le.3) then
+        if(tok2(3:3).eq.' ') msg3=tok2(1:3)//msg3
+        if(tok2(3:3).ne.' ') msg3=tok2//msg3
+     endif
+     if(n3.ge.4 .and. n3.le.11) then
+        do i=n2,1,-1
+           if(msg3(i:i).ne.' ') go to 100
+        enddo
+100     msg3=msg3(1:i)//tok2
+        if(i.eq.0) msg3=msg3(1:i)//tok2(2:)
+     endif
+
+     call cs_lock('pp441')
+     if(ncon.ne.0) write(*,1110) cfile6,tbest,mswidth,npeak,nrpt,     &amp;
+          nint(dfx),msg3,ccfmax,sbest/ccfmax,n2,'++'
+        if(nline.le.99) nline=nline+1
+        tping(nline)=t2
+        write(line(nline),1110) cfile6,t2,mswidth,npeak,              &amp;
+             nrpt,nint(dfx),msg3,ccfmax,sbest/ccfmax,n2,'++'
+     call cs_unlock
+  endif
+
+800 continue
+
+  return
+end subroutine pp441


Property changes on: wsjt7a/pp441.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/t72.f90
===================================================================
--- wsjt7a/t72.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/t72.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,72 +1,72 @@
-program t72
-
-! Tests experimental FSK441 decoder
-
-  parameter (NMAX=512*1024)
-  parameter (MAXFFT=8192)
-  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
-  character arg*12                        !Command-line argument
-  character cfile6*6                      !File time
-  character frag*28                       !Message fragment to be matched
-  character infile*40
-  integer dftolerance
-  logical pick
-  real pingdat(3,100)                     !Detected pings
-  character c*48
-  common/scratch/work(NMAX)
-  data c/' 123456789.,?/# $ABCD FGHIJKLMNOPQRSTUVWXY 0EZ*!'/
-
-  nargs=iargc()
-  if(nargs.ne.3) then
-     print*,'Usage: t72 infile nrec frag'
-     go to 999
-  endif
-  call getarg(1,infile)
-  call getarg(2,arg)
-  read(arg,*) nrec
-  call getarg(3,frag)
-  open(72,file=infile,form='unformatted',status='old')
-
-! Initialize variables
-  minsigdb=2
-  minwidth=40
-  dftolerance=400
-  pick=.false.
-  nsps=25
-  nsam=nsps*ndits
-  xn=log(float(nsam))/log(2.0)
-  n=xn
-  if(xn-n .gt.0.001) n=n+1
-  cfile6='441++'
-
-  do irec=1,nrec
-     read(72,end=999) jz,nz,cfile6,(dat(j),j=1,jz)
-     if(irec.ne.nrec .and. nrec.ne.999) go to 900
-
-     call ping441(dat,jz,nz,MinSigdB,MinWidth,pick,pingdat,nping)   !Find pings
-
-     do iping=1,nping                        !Process each ping
-        tstart=pingdat(1,iping)
-        width=pingdat(2,iping)
-        peak=pingdat(3,iping)
-        npeak=peak
-!  Assemble a signal report:
-        nwidth=0
-        if(width.ge.0.04) nwidth=1     !These might depend on NSPD
-        if(width.ge.0.12) nwidth=2
-        if(width.gt.1.00) nwidth=3
-        nstrength=6
-        if(peak.ge.11.0) nstrength=7
-        if(peak.ge.17.0) nstrength=8
-        if(peak.ge.23.0) nstrength=9
-        nrpt=10*nwidth + nstrength
-
-        t2=tstart
-        call pp441(dat,jz,cfile6,tstart,t2,width,npeak,nrpt,           &amp;
-             dftolerance,frag,1)
-     enddo
-
-900  continue
-  enddo
-
-999 end program t72
+program t72
+
+! Tests experimental FSK441 decoder
+
+  parameter (NMAX=512*1024)
+  parameter (MAXFFT=8192)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  character arg*12                        !Command-line argument
+  character cfile6*6                      !File time
+  character frag*28                       !Message fragment to be matched
+  character infile*40
+  integer dftolerance
+  logical pick
+  real pingdat(3,100)                     !Detected pings
+  character c*48
+  common/scratch/work(NMAX)
+  data c/' 123456789.,?/# $ABCD FGHIJKLMNOPQRSTUVWXY 0EZ*!'/
+
+  nargs=iargc()
+  if(nargs.ne.3) then
+     print*,'Usage: t72 infile nrec frag'
+     go to 999
+  endif
+  call getarg(1,infile)
+  call getarg(2,arg)
+  read(arg,*) nrec
+  call getarg(3,frag)
+  open(72,file=infile,form='unformatted',status='old')
+
+! Initialize variables
+  minsigdb=2
+  minwidth=40
+  dftolerance=400
+  pick=.false.
+  nsps=25
+  nsam=nsps*ndits
+  xn=log(float(nsam))/log(2.0)
+  n=xn
+  if(xn-n .gt.0.001) n=n+1
+  cfile6='441++'
+
+  do irec=1,nrec
+     read(72,end=999) jz,nz,cfile6,(dat(j),j=1,jz)
+     if(irec.ne.nrec .and. nrec.ne.999) go to 900
+
+     call ping441(dat,jz,nz,MinSigdB,MinWidth,pick,pingdat,nping)   !Find pings
+
+     do iping=1,nping                        !Process each ping
+        tstart=pingdat(1,iping)
+        width=pingdat(2,iping)
+        peak=pingdat(3,iping)
+        npeak=peak
+!  Assemble a signal report:
+        nwidth=0
+        if(width.ge.0.04) nwidth=1     !These might depend on NSPD
+        if(width.ge.0.12) nwidth=2
+        if(width.gt.1.00) nwidth=3
+        nstrength=6
+        if(peak.ge.11.0) nstrength=7
+        if(peak.ge.17.0) nstrength=8
+        if(peak.ge.23.0) nstrength=9
+        nrpt=10*nwidth + nstrength
+
+        t2=tstart
+        call pp441(dat,jz,cfile6,tstart,t2,width,npeak,nrpt,           &amp;
+             dftolerance,frag,1)
+     enddo
+
+900  continue
+  enddo
+
+999 end program t72


Property changes on: wsjt7a/t72.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/t73.f90
===================================================================
--- wsjt7a/t73.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/t73.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,139 +1,139 @@
-program t73
-
-! Tests experimental JT6M decoder
-
-  parameter (NMAX=512*1024)
-  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
-  complex cdat(NMAX)                      !Analytic form of signal
-  complex z
-  character arg*12                        !Command-line argument
-  character cfile6*6                      !File time
-  character frag*28                       !Message fragment to be matched
-!  character msg*40
-!  complex cfrag(2100)                     !Complex waveform of message fragment
-  real s(NMAX)
-  real sym(646)
-  real fsym(0:2)
-  real ccf(-20000:20000)
-  integer dftolerance
-  real*8 twopi8,dt8,f08
-  common/scratch/work(NMAX)
-
-  nargs=iargc()
-  if(nargs.ne.2) then
-     print*,'Usage: t73 nfile frag'
-     go to 999
-  endif
-  call getarg(1,arg)
-  read(arg,*) nfile
-  call getarg(2,frag)
-  open(73,file='dat.73',form='unformatted',status='old')
-
-  do i=28,1,-1                          !Get length of fragment
-     if(frag(i:i).ne.' ') go to 10
-  enddo
-10 nfrag=i
-
-  nsps=512
-  twopi8=8.d0*atan(1.d0)
-  dt8=1.d0/11025.d0
-  f08=50*11025.d0/nsps
-  f0=f08
-  dftolerance=40
-  ipk=0
-  
-  do ifile=1,nfile
-     read(73,end=999) jz,nz,cfile6,(dat(j),j=1,jz)
-     if(ifile.ne.nfile .and. nfile.ne.999) go to 900
-
-!     do i=1,jz
-!        j=(i-1)/512
-!        dat(i)=0.
-!        if(mod(j,3).eq.1) dat(i)=sin(twopi8*i*dt8*f08)
-!     enddo
-
-     npts=jz
-     xn=log(float(npts))/log(2.0)
-     n=xn
-     if(xn-n .gt.0.001) n=n+1
-     nfft1=2**n
-     nh1=nfft1/2
-     nq1=nfft1/4
-     df1=11025.0/nfft1
-     ia=nint(11025.0/(3.0*nsps*df1))
-     ib=nint(dftolerance/df1)
-     i0=nint(f0/df1)
-
-     call analytic(dat,npts,nfft1,s,cdat)        !Convert to analytic signal
-
-     do i=-ib,ib
-        ccf(i)=0.46*s(i0+i) + 0.27*(s(i0+i-ia)+s(i0+i+ia))
-     enddo
-
-     nadd=nint(1.0/df1)
-     call smo(ccf(-ib),2*ib+1,work,nadd)
-
-     ccfmax=0.
-     do i=-ib,ib
-        if(ccf(i).gt.ccfmax) then
-           ccfmax=ccf(i)
-           ipk=i
-        endif
-        freq=i*df1
-        write(13,3001) i,freq,1000.0*ccf(i)
-3001    format(i8,2f12.3)
-     enddo
-
-     dfx=ipk*df1
-
-! DF is known, now find symbol sync.
-     call tweak1(cdat,npts,-f0-dfx,cdat)
-
-     nrpt=npts/1536-1
-     ymax=0.
-     jpk=0
-     do j=0,1535
-        y=0.
-        do n=0,nrpt-1
-           k=n*1536 + j
-           z=0.
-           do i=1,512
-              k=k+1
-              z=z+cdat(k)
-           enddo
-           y=y + abs(z)
-        enddo
-        write(14,3002) j,y
-3002    format(i8,f12.3)
-        if(y.gt.ymax) then
-           ymax=y
-           i1=j
-        endif
-     enddo
-
-! OK, we have DF and starting sample, i1.  Compute symbol amplitudes.
-        nsym=(npts-i1+1)/(3*512)
-        nsym=3*nsym
-        fsym=0.
-        k=i1-1
-        do j=1,nsym
-           z=0.
-           do i=1,512
-              k=k+1
-              z=z+cdat(k)
-           enddo
-           sym(j)=abs(z)
-           i=mod(j-1,3)
-           fsym(i)=fsym(i)+sym(j)
-           write(16,3005) j,sym(j)
-3005       format(i4,f12.3)
-        enddo
-        fsmin=min(fsym(0),fsym(1),fsym(2))
-        print*,fsym/fsmin
-
-     print*,ifile,f0,dfx,jpk
-
-900  continue
-  enddo
-
-999 end program t73
+program t73
+
+! Tests experimental JT6M decoder
+
+  parameter (NMAX=512*1024)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  complex cdat(NMAX)                      !Analytic form of signal
+  complex z
+  character arg*12                        !Command-line argument
+  character cfile6*6                      !File time
+  character frag*28                       !Message fragment to be matched
+!  character msg*40
+!  complex cfrag(2100)                     !Complex waveform of message fragment
+  real s(NMAX)
+  real sym(646)
+  real fsym(0:2)
+  real ccf(-20000:20000)
+  integer dftolerance
+  real*8 twopi8,dt8,f08
+  common/scratch/work(NMAX)
+
+  nargs=iargc()
+  if(nargs.ne.2) then
+     print*,'Usage: t73 nfile frag'
+     go to 999
+  endif
+  call getarg(1,arg)
+  read(arg,*) nfile
+  call getarg(2,frag)
+  open(73,file='dat.73',form='unformatted',status='old')
+
+  do i=28,1,-1                          !Get length of fragment
+     if(frag(i:i).ne.' ') go to 10
+  enddo
+10 nfrag=i
+
+  nsps=512
+  twopi8=8.d0*atan(1.d0)
+  dt8=1.d0/11025.d0
+  f08=50*11025.d0/nsps
+  f0=f08
+  dftolerance=40
+  ipk=0
+  
+  do ifile=1,nfile
+     read(73,end=999) jz,nz,cfile6,(dat(j),j=1,jz)
+     if(ifile.ne.nfile .and. nfile.ne.999) go to 900
+
+!     do i=1,jz
+!        j=(i-1)/512
+!        dat(i)=0.
+!        if(mod(j,3).eq.1) dat(i)=sin(twopi8*i*dt8*f08)
+!     enddo
+
+     npts=jz
+     xn=log(float(npts))/log(2.0)
+     n=xn
+     if(xn-n .gt.0.001) n=n+1
+     nfft1=2**n
+     nh1=nfft1/2
+     nq1=nfft1/4
+     df1=11025.0/nfft1
+     ia=nint(11025.0/(3.0*nsps*df1))
+     ib=nint(dftolerance/df1)
+     i0=nint(f0/df1)
+
+     call analytic(dat,npts,nfft1,s,cdat)        !Convert to analytic signal
+
+     do i=-ib,ib
+        ccf(i)=0.46*s(i0+i) + 0.27*(s(i0+i-ia)+s(i0+i+ia))
+     enddo
+
+     nadd=nint(1.0/df1)
+     call smo(ccf(-ib),2*ib+1,work,nadd)
+
+     ccfmax=0.
+     do i=-ib,ib
+        if(ccf(i).gt.ccfmax) then
+           ccfmax=ccf(i)
+           ipk=i
+        endif
+        freq=i*df1
+        write(13,3001) i,freq,1000.0*ccf(i)
+3001    format(i8,2f12.3)
+     enddo
+
+     dfx=ipk*df1
+
+! DF is known, now find symbol sync.
+     call tweak1(cdat,npts,-f0-dfx,cdat)
+
+     nrpt=npts/1536-1
+     ymax=0.
+     jpk=0
+     do j=0,1535
+        y=0.
+        do n=0,nrpt-1
+           k=n*1536 + j
+           z=0.
+           do i=1,512
+              k=k+1
+              z=z+cdat(k)
+           enddo
+           y=y + abs(z)
+        enddo
+        write(14,3002) j,y
+3002    format(i8,f12.3)
+        if(y.gt.ymax) then
+           ymax=y
+           i1=j
+        endif
+     enddo
+
+! OK, we have DF and starting sample, i1.  Compute symbol amplitudes.
+        nsym=(npts-i1+1)/(3*512)
+        nsym=3*nsym
+        fsym=0.
+        k=i1-1
+        do j=1,nsym
+           z=0.
+           do i=1,512
+              k=k+1
+              z=z+cdat(k)
+           enddo
+           sym(j)=abs(z)
+           i=mod(j-1,3)
+           fsym(i)=fsym(i)+sym(j)
+           write(16,3005) j,sym(j)
+3005       format(i4,f12.3)
+        enddo
+        fsmin=min(fsym(0),fsym(1),fsym(2))
+        print*,fsym/fsmin
+
+     print*,ifile,f0,dfx,jpk
+
+900  continue
+  enddo
+
+999 end program t73


Property changes on: wsjt7a/t73.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/t74.f90
===================================================================
--- wsjt7a/t74.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/t74.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,37 +1,37 @@
-program t74
-
-! Tests experimental ISCAT_2 decoder
-
-  parameter (NMAX=512*1024)
-  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
-  character arg*12                        !Command-line argument
-  character cfile6*6                      !File time
-  character msg*28
-  character*40 infile
-  real ccf(-5:540)                        !blue line
-  real psavg(450)                         !Average spectrum of the whole file
-
-  nargs=iargc()
-  if(nargs.ne.2) then
-     print*,'Usage: t74 infile nrec'
-     go to 999
-  endif
-  call getarg(1,infile)
-  call getarg(2,arg)
-  read(arg,*) nrec
-  open(74,file=infile,form='unformatted',status='old')
-
-  MinSigdB=0
-  DFTolerance=400
-  NFreeze=1
-  MouseDF=0
-
-  do irec=1,nrec
-     read(74,end=999) jz,cfile6,(dat(j),j=1,jz)
-     if(irec.ne.nrec .and. nrec.ne.999) go to 900
-
-     call iscat(dat,jz,cfile6,MinSigdB,DFTolerance,NFreeze,MouseDF,ccf,psavg)
-900  continue
-  enddo
-
-999 end program t74
+program t74
+
+! Tests experimental ISCAT_2 decoder
+
+  parameter (NMAX=512*1024)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  character arg*12                        !Command-line argument
+  character cfile6*6                      !File time
+  character msg*28
+  character*40 infile
+  real ccf(-5:540)                        !blue line
+  real psavg(450)                         !Average spectrum of the whole file
+
+  nargs=iargc()
+  if(nargs.ne.2) then
+     print*,'Usage: t74 infile nrec'
+     go to 999
+  endif
+  call getarg(1,infile)
+  call getarg(2,arg)
+  read(arg,*) nrec
+  open(74,file=infile,form='unformatted',status='old')
+
+  MinSigdB=0
+  DFTolerance=400
+  NFreeze=1
+  MouseDF=0
+
+  do irec=1,nrec
+     read(74,end=999) jz,cfile6,(dat(j),j=1,jz)
+     if(irec.ne.nrec .and. nrec.ne.999) go to 900
+
+     call iscat(dat,jz,cfile6,MinSigdB,DFTolerance,NFreeze,MouseDF,ccf,psavg)
+900  continue
+  enddo
+
+999 end program t74


Property changes on: wsjt7a/t74.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/token.f90
===================================================================
--- wsjt7a/token.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/token.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,43 +1,43 @@
-subroutine token(c1,i1,tok1,n1)
-
-  character c1*1,tok1*4
-  character*4 tok(12)
-  character*12 ctok
-  integer ntok(12)
-  integer len(12)
-
-! Define tokens and token lengths
-  data tok(1) /'CQ ' /,ntok(1)/3/                !001 1
-  data tok(2) /'QRZ '/,ntok(2)/4/                !012 6
-  data tok(3) /'TNX '/,ntok(3)/4/                !020 8
-  data tok(4) /' 26' /,ntok(4)/3/                !033 _
-  data tok(5) /' 27' /,ntok(5)/3/                !100 $
-  data tok(6) /' 38' /,ntok(6)/3/                !113 G
-  data tok(7) /' R26'/,ntok(7)/4/                !121 I
-  data tok(8) /' R27'/,ntok(8)/4/                !132 N
-  data tok(9) /' R38'/,ntok(9)/4/                !202 R
-  data tok(10)/' RRR'/,ntok(10)/4/               !210 T
-  data tok(11)/' 73' /,ntok(11)/3/               !223 O
-  data tok(12)/'   ' /,ntok(12)/3/               !231 Z
-
-! Permissible message lengths
-  data len/4,7,9,11,13,14,15,17,19,21,23,28/
-
-! Token indexes, as characters
-  data ctok/'168_$GINRTOZ'/
-
-  i1=0
-  do i=1,12
-     if(ctok(i:i).eq.c1) go to 10
-  enddo
-  tok1='    '
-  n1=0
-  go to 900
-
-10 i1=i
-  tok1=tok(i1)
-  n1=len(i1)
-
-900 return
-end subroutine token
-
+subroutine token(c1,i1,tok1,n1)
+
+  character c1*1,tok1*4
+  character*4 tok(12)
+  character*12 ctok
+  integer ntok(12)
+  integer len(12)
+
+! Define tokens and token lengths
+  data tok(1) /'CQ ' /,ntok(1)/3/                !001 1
+  data tok(2) /'QRZ '/,ntok(2)/4/                !012 6
+  data tok(3) /'TNX '/,ntok(3)/4/                !020 8
+  data tok(4) /' 26' /,ntok(4)/3/                !033 _
+  data tok(5) /' 27' /,ntok(5)/3/                !100 $
+  data tok(6) /' 38' /,ntok(6)/3/                !113 G
+  data tok(7) /' R26'/,ntok(7)/4/                !121 I
+  data tok(8) /' R27'/,ntok(8)/4/                !132 N
+  data tok(9) /' R38'/,ntok(9)/4/                !202 R
+  data tok(10)/' RRR'/,ntok(10)/4/               !210 T
+  data tok(11)/' 73' /,ntok(11)/3/               !223 O
+  data tok(12)/'   ' /,ntok(12)/3/               !231 Z
+
+! Permissible message lengths
+  data len/4,7,9,11,13,14,15,17,19,21,23,28/
+
+! Token indexes, as characters
+  data ctok/'168_$GINRTOZ'/
+
+  i1=0
+  do i=1,12
+     if(ctok(i:i).eq.c1) go to 10
+  enddo
+  tok1='    '
+  n1=0
+  go to 900
+
+10 i1=i
+  tok1=tok(i1)
+  n1=len(i1)
+
+900 return
+end subroutine token
+


Property changes on: wsjt7a/token.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: wsjt7a/unpackpfx.f90
===================================================================
--- wsjt7a/unpackpfx.f90	2010-07-21 20:28:56 UTC (rev 2017)
+++ wsjt7a/unpackpfx.f90	2010-07-22 12:22:23 UTC (rev 2018)
@@ -1,35 +1,35 @@
-subroutine unpackpfx(ng,call1)
-
-  character*12 call1
-  character*3 pfx
-
-  if(ng.lt.60000) then
-! Add-on prefix of 1 to 3 characters
-     n=ng
-     do i=3,1,-1
-        nc=mod(n,37)
-        if(nc.ge.0 .and. nc.le.9) then
-           pfx(i:i)=char(nc+48)
-        else if(nc.ge.10 .and. nc.le.35) then
-           pfx(i:i)=char(nc+55)
-        else
-           pfx(i:i)=' '
-        endif
-        n=n/37
-     enddo
-     call1=pfx//'/'//call1
-     if(call1(1:1).eq.' ') call1=call1(2:)
-     if(call1(1:1).eq.' ') call1=call1(2:)
-  else
-! Add-on suffix, one character
-     i1=index(call1,' ')
-     nc=ng-60000
-     if(nc.ge.0 .and. nc.le.9) then
-        call1=call1(:i1-1)//'/'//char(nc+48)
-     else if(nc.ge.10 .and. nc.le.35) then
-        call1=call1(:i1-1)//'/'//char(nc+55)
-     endif
-  endif
-
-  return
-end subroutine unpackpfx
+subroutine unpackpfx(ng,call1)
+
+  character*12 call1
+  character*3 pfx
+
+  if(ng.lt.60000) then
+! Add-on prefix of 1 to 3 characters
+     n=ng
+     do i=3,1,-1
+        nc=mod(n,37)
+        if(nc.ge.0 .and. nc.le.9) then
+           pfx(i:i)=char(nc+48)
+        else if(nc.ge.10 .and. nc.le.35) then
+           pfx(i:i)=char(nc+55)
+        else
+           pfx(i:i)=' '
+        endif
+        n=n/37
+     enddo
+     call1=pfx//'/'//call1
+     if(call1(1:1).eq.' ') call1=call1(2:)
+     if(call1(1:1).eq.' ') call1=call1(2:)
+  else
+! Add-on suffix, one character
+     i1=index(call1,' ')
+     nc=ng-60000
+     if(nc.ge.0 .and. nc.le.9) then
+        call1=call1(:i1-1)//'/'//char(nc+48)
+     else if(nc.ge.10 .and. nc.le.35) then
+        call1=call1(:i1-1)//'/'//char(nc+55)
+     endif
+  endif
+
+  return
+end subroutine unpackpfx


Property changes on: wsjt7a/unpackpfx.f90
___________________________________________________________________
Added: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001709.html">[WSJT-SVN] r2017 - wsjt7a
</A></li>
	<LI>Next message: <A HREF="001711.html">[WSJT-SVN] r2019 - wsjt7a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1710">[ date ]</a>
              <a href="thread.html#1710">[ thread ]</a>
              <a href="subject.html#1710">[ subject ]</a>
              <a href="author.html#1710">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
