<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r1976 - wsjt7a
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1976%20-%20wsjt7a&In-Reply-To=%3C20100711175825.4D2FE4802CB%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001667.html">
   <LINK REL="Next"  HREF="001669.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r1976 - wsjt7a</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1976%20-%20wsjt7a&In-Reply-To=%3C20100711175825.4D2FE4802CB%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r1976 - wsjt7a">k1jt at mail.berlios.de
       </A><BR>
    <I>Sun Jul 11 19:58:25 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001667.html">[WSJT-SVN] r1975 - wsjt7a
</A></li>
        <LI>Next message: <A HREF="001669.html">[WSJT-SVN] r1977 - wsjt7a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1668">[ date ]</a>
              <a href="thread.html#1668">[ thread ]</a>
              <a href="subject.html#1668">[ subject ]</a>
              <a href="author.html#1668">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2010-07-11 19:58:24 +0200 (Sun, 11 Jul 2010)
New Revision: 1976

Added:
   wsjt7a/abc441.f90
   wsjt7a/astro0.f90
   wsjt7a/audio_init.f90
   wsjt7a/decode1.f90
   wsjt7a/decode3.f90
   wsjt7a/deep65.f90
   wsjt7a/ftn_init.f90
   wsjt7a/get_fname.f90
   wsjt7a/getfile.f90
   wsjt7a/savedata.f90
   wsjt7a/wsjtgen.f90
Removed:
   wsjt7a/abc441.F90
   wsjt7a/astro0.F90
   wsjt7a/audio_init.F90
   wsjt7a/decode1.F90
   wsjt7a/decode3.F90
   wsjt7a/deep65.F
   wsjt7a/extract.f
   wsjt7a/fivehz.F90
   wsjt7a/ftn_init.F90
   wsjt7a/get_fname.F90
   wsjt7a/getfile.F90
   wsjt7a/runqqq.F90
   wsjt7a/savedata.F90
   wsjt7a/wsjtgen.F90
Modified:
   wsjt7a/CALL3.TXT
   wsjt7a/Makefile.MinGW
   wsjt7a/spec.f90
   wsjt7a/wsjt.py
   wsjt7a/wsjt1.f90
   wsjt7a/wsjt24.f
   wsjt7a/wsjt65.f
Log:
cc


Modified: wsjt7a/CALL3.TXT
===================================================================
--- wsjt7a/CALL3.TXT	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/CALL3.TXT	2010-07-11 17:58:24 UTC (rev 1976)
@@ -4546,6 +4546,7 @@
 UN7TQ,MN52VV,EME,,,,,09/98
 UN8AG,LN53PH,,,ex UL7AAX,,,07/96
 UN8BA,MO51RD,EME,,,,,01/92
+UN9L,MO13tf,EME,,
 UP7QP,MN83FD,,,,,,10/08
 UR3CTB,KN59RS,,,,,IC-820H  40W dk7zb 10 el LNA Gafest,09/07
 UR3EE,KN88DC,EME,,,,,11/02

Modified: wsjt7a/Makefile.MinGW
===================================================================
--- wsjt7a/Makefile.MinGW	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/Makefile.MinGW	2010-07-11 17:58:24 UTC (rev 1976)
@@ -24,30 +24,30 @@
 
 F2PYONLY = ftn_init ftn_quit audio_init spec getfile azdist0 astro0 chkt0
 
-SRCS2F90 = a2d.f90 abc441.f90 astro0.f90 audio_init.f90 azdist0.f90 \
+SRCS2F90 = wsjt1.f90 a2d.f90 abc441.f90 astro0.f90 audio_init.f90 azdist0.f90 \
 	blanker.f90 decode1.f90 decode2.f90 decode3.f90 ftn_init.f90 \
 	ftn_quit.f90 get_fname.f90 getfile.F90 horizspec.f90 hscroll.f90 \
-	pix2d.f90 pix2d65.f90 rfile.f90 savedata.f90 spec.f90 \
-	wsjtgen.f90 runqqq.f90 fivehz.f90 chkt0.f90 \
+	pix2d.f90 pix2d65.f90 rfile.f90 savedata.f90 spec.f90 extract.f90 \
+	wsjtgen.f90 fivehz.f90 chkt0.f90 deep65.f90 astro.f90 \
 	packpfx.f90 unpackpfx.f90 \
 	thnix.f90 enc441.f90 pp441.f90 tweak1.f90 smo.f90 analytic.f90 \
 	gen441.f90 dec441.f90 token.f90 msgtrim.f90 gen41.f90
 
 
-SRCS2F77 = wsjt1.f avesp2.f bzap.f spec441.f spec2d.f mtdecode.f \
+SRCS2F77 = avesp2.f bzap.f spec441.f spec2d.f mtdecode.f \
 	stdecode.f indexx.f s2shape.f flat2.f gen65.f gen24.f entail.f \
 	genmet.f wsjt24.f sync24.f ps24.f xcor24.f decode24.f\
 	chkmsg.f gen6m.f interleave24.f \
 	gentone.f syncf0.f syncf1.f synct.f decode6m.f avemsg6m.f \
 	set.f flatten.f db.f pctile.f sort.f ssort.f ps.f smooth.f ping.f \
 	longx.f peakup.f sync.f detect.f avemsg65.f decode65.f demod64a.f \
-	encode65.f extract.f chkhist.f flat1.f four2a.f gencw.f \
+	encode65.f chkhist.f flat1.f four2a.f gencw.f \
 	gencwid.f msgtype.f getpfx1.f \
 	getpfx2.f getsnr.f graycode.f grid2k.f interleave63.f k2grid.f \
-	limit.f lpf1.f deep65.f morse.f nchar.f packcall.f packgrid.f \
+	limit.f lpf1.f morse.f nchar.f packcall.f packgrid.f \
 	packmsg.f packtext.f setup65.f short65.f slope.f spec2d65.f \
 	sync65.f unpackcall.f unpackgrid.f unpackmsg.f unpacktext.f \
-	xcor.f xfft.f xfft2.f wsjt65.f astro.f azdist.f coord.f dcoord.f \
+	xcor.f xfft.f xfft2.f wsjt65.f azdist.f coord.f dcoord.f \
 	deg2grid.f dot.f ftsky.f geocentric.f GeoDist.f grid2deg.f \
 	moon2.f MoonDop.f sun.f toxyz.f pfxdump.f \
 	ftpeak65.f fil651.f fil652.f fil653.f symsync65.f \

Deleted: wsjt7a/abc441.F90
===================================================================
--- wsjt7a/abc441.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/abc441.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,36 +0,0 @@
-subroutine abc441(msg0,nmsg0,itone,ndits)
-
-  character msg*28,msg0*28
-  integer itone(84)
-  integer lookup(0:91)
-  character cc*43
-  data cc/' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ.,?/#$'/
-  data lookup/13, 15, 17, 46, 47, 45, 44, 12, 11, 14, &amp;
-               1,  2,  3,  4,  5,  6,  7,  8,  9, 10, &amp;
-              16, 48, 18, 19, 20, 21, 22, 23, 24, 25, &amp;
-              26, 27, 15, 47, 30, 14, 16, 42, 46, 35, &amp;
-              36, 37, 21,  0, 11, 41, 10, 13, 43,  1, &amp;
-               2,  3,  4,  5,  6,  7,  8,  9, 49, 56, &amp;
-              52, 55, 54, 12, 63, 17, 18, 19, 20, 44, &amp;
-              22, 23, 24, 25, 26, 27, 28, 29, 30, 31, &amp;
-              32, 33, 34, 35, 36, 37, 38, 39, 40, 41, &amp;
-              45, 63/
-
-  if(nmsg0.gt.1000) then
-     msg=msg0
-     nmsg=nmsg0-1000
-  else
-     call enc441(msg0,msg,nmsg)
-  endif
-
-  do i=1,nmsg
-     j=ichar(msg(i:i))
-     if(j.lt.0 .or. j.gt.91) j=32 !Replace illegal char with blank 
-     n=lookup(j)
-     itone(3*i-2)=n/16 + 1
-     itone(3*i-1)=mod(n/4,4) + 1
-     itone(3*i)=mod(n,4) + 1
-  enddo
-  ndits=3*nmsg
-  return
-end subroutine abc441

Copied: wsjt7a/abc441.f90 (from rev 1974, wsjt7a/abc441.F90)
===================================================================
--- wsjt7a/abc441.f90	                        (rev 0)
+++ wsjt7a/abc441.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,36 @@
+subroutine abc441(msg0,nmsg0,itone,ndits)
+
+  character msg*28,msg0*28
+  integer itone(84)
+  integer lookup(0:91)
+  character cc*43
+  data cc/' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ.,?/#$'/
+  data lookup/13, 15, 17, 46, 47, 45, 44, 12, 11, 14, &amp;
+               1,  2,  3,  4,  5,  6,  7,  8,  9, 10, &amp;
+              16, 48, 18, 19, 20, 21, 22, 23, 24, 25, &amp;
+              26, 27, 15, 47, 30, 14, 16, 42, 46, 35, &amp;
+              36, 37, 21,  0, 11, 41, 10, 13, 43,  1, &amp;
+               2,  3,  4,  5,  6,  7,  8,  9, 49, 56, &amp;
+              52, 55, 54, 12, 63, 17, 18, 19, 20, 44, &amp;
+              22, 23, 24, 25, 26, 27, 28, 29, 30, 31, &amp;
+              32, 33, 34, 35, 36, 37, 38, 39, 40, 41, &amp;
+              45, 63/
+
+  if(nmsg0.gt.1000) then
+     msg=msg0
+     nmsg=nmsg0-1000
+  else
+     call enc441(msg0,msg,nmsg)
+  endif
+
+  do i=1,nmsg
+     j=ichar(msg(i:i))
+     if(j.lt.0 .or. j.gt.91) j=32 !Replace illegal char with blank 
+     n=lookup(j)
+     itone(3*i-2)=n/16 + 1
+     itone(3*i-1)=mod(n/4,4) + 1
+     itone(3*i)=mod(n,4) + 1
+  enddo
+  ndits=3*nmsg
+  return
+end subroutine abc441

Deleted: wsjt7a/astro0.F90
===================================================================
--- wsjt7a/astro0.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/astro0.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,127 +0,0 @@
-subroutine astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
-     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
-     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
-     RaAux8,DecAux8,AzAux8,ElAux8)
-
-!f2py threadsafe
-!f2py intent(in) nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec
-!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8
-
-  character grid*6
-  character*9 cauxra,cauxdec
-  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,AzAux8,ElAux8
-  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0,dt
-  real*8 sd8,poloffset8
-  include 'gcom2.f90'
-  data uth8z/0.d0/,imin0/-99/
-  save
-
-  call cs_lock('astro0a')
-  auxra=0.
-  i=index(cauxra,':')
-  if(i.eq.0) then
-     read(cauxra,*,err=1,end=1) auxra
-  else
-     read(cauxra(1:i-1),*,err=1,end=1) ih
-     read(cauxra(i+1:i+2),*,err=1,end=1) im
-     read(cauxra(i+4:i+5),*,err=1,end=1) is
-     auxra=ih + im/60.0 + is/3600.0
-  endif
-1 auxdec=0.
-  i=index(cauxdec,':')
-  if(i.eq.0) then
-     read(cauxdec,*,err=2,end=2) auxdec
-  else
-     read(cauxdec(1:i-1),*,err=2,end=2) id
-     read(cauxdec(i+1:i+2),*,err=2,end=2) im
-     read(cauxdec(i+4:i+5),*,err=2,end=2) is
-     auxdec=id + im/60.0 + is/3600.0
-  endif
-
-2 nmode=1
-  if(mode(1:4).eq.'JT65') then
-     nmode=2
-     if(mode(5:5).eq.'A') mode65=1
-     if(mode(5:5).eq.'B') mode65=2
-     if(mode(5:5).eq.'C') mode65=4
-  endif
-  if(mode(1:4).eq.'Echo') nmode=3
-  if(mode(1:4).eq.'JT6M') nmode=4
-  if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:4).eq.'JT41') then
-     nmode=9
-  else if(mode(1:3).eq.'JT4') then
-     nmode=7
-  endif
-
-  uth=uth8
-  call cs_unlock
-
-  call astro(nyear,month,nday,uth,nfreq,hisgrid,2,nmode,1,    &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
-  AzMoonB8=AzMoon
-  ElMoonB8=ElMoon
-  call astro(nyear,month,nday,uth,nfreq,grid,1,nmode,1,       &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
-
-  RaAux8=auxra
-  DecAux8=auxdec
-  AzSun8=AzSun
-  ElSun8=ElSun
-  AzMoon8=AzMoon
-  ElMoon8=ElMoon
-  dbMoon8=dbMoon
-  RAMoon8=RAMoon/15.0
-  DecMoon8=DecMoon
-  HA8=HA
-  Dgrd8=Dgrd
-  sd8=sd
-  poloffset8=poloffset
-  xnr8=xnr
-  AzAux8=AzAux
-  ElAux8=ElAux
-  ndop=nint(doppler)
-  ndop00=nint(doppler00)
-
-  if(uth8z.eq.0.d0) then
-     uth8z=uth8-1.d0/3600.d0
-     dopplerz=doppler
-     doppler00z=doppler00
-  endif
-     
-  dt=60.0*(uth8-uth8z)
-  if(dt.le.0) dt=1.d0/60.d0
-  dfdt=(doppler-dopplerz)/dt
-  dfdt0=(doppler00-doppler00z)/dt
-  uth8z=uth8
-  dopplerz=doppler
-  doppler00z=doppler00
-
-  imin=60*uth8
-  isec=3600*uth8
-
-  if(isec.ne.isec0 .and. ndecoding.eq.0) then
-     call cs_lock('astro0b')
-     ih=uth8
-     im=mod(imin,60)
-     is=mod(isec,60)
-     rewind 14
-     write(14,1010,err=800) ih,im,is,AzMoon,ElMoon,                          &amp;
-        ih,im,is,AzSun,ElSun,                                        &amp;
-        ih,im,is,AzAux,ElAux,                                        &amp;
-        nfreq,doppler,dfdt,doppler00,dfdt0
-1010 format(i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Moon'/        &amp;
-            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Sun'/         &amp;
-            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Source'/      &amp;
-            i5,',',f8.1,',',f8.2,',',f8.1,',',f8.2,',Doppler')
-     rewind 14
-800  isec0=isec
-     call cs_unlock
-  endif
-
-  return
-end subroutine astro0

Copied: wsjt7a/astro0.f90 (from rev 1975, wsjt7a/astro0.F90)
===================================================================
--- wsjt7a/astro0.f90	                        (rev 0)
+++ wsjt7a/astro0.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,127 @@
+subroutine astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
+     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
+     RaAux8,DecAux8,AzAux8,ElAux8)
+
+!f2py threadsafe
+!f2py intent(in) nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec
+!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8
+
+  character grid*6
+  character*9 cauxra,cauxdec
+  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,AzAux8,ElAux8
+  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0,dt
+  real*8 sd8,poloffset8
+  include 'gcom2.f90'
+  data uth8z/0.d0/,imin0/-99/
+  save
+
+  call cs_lock('astro0a')
+  auxra=0.
+  i=index(cauxra,':')
+  if(i.eq.0) then
+     read(cauxra,*,err=1,end=1) auxra
+  else
+     read(cauxra(1:i-1),*,err=1,end=1) ih
+     read(cauxra(i+1:i+2),*,err=1,end=1) im
+     read(cauxra(i+4:i+5),*,err=1,end=1) is
+     auxra=ih + im/60.0 + is/3600.0
+  endif
+1 auxdec=0.
+  i=index(cauxdec,':')
+  if(i.eq.0) then
+     read(cauxdec,*,err=2,end=2) auxdec
+  else
+     read(cauxdec(1:i-1),*,err=2,end=2) id
+     read(cauxdec(i+1:i+2),*,err=2,end=2) im
+     read(cauxdec(i+4:i+5),*,err=2,end=2) is
+     auxdec=id + im/60.0 + is/3600.0
+  endif
+
+2 nmode=1
+  if(mode(1:4).eq.'JT65') then
+     nmode=2
+     if(mode(5:5).eq.'A') mode65=1
+     if(mode(5:5).eq.'B') mode65=2
+     if(mode(5:5).eq.'C') mode65=4
+  endif
+  if(mode(1:4).eq.'Echo') nmode=3
+  if(mode(1:4).eq.'JT6M') nmode=4
+  if(mode(1:2).eq.'CW') nmode=5
+  if(mode(1:4).eq.'JT41') then
+     nmode=9
+  else if(mode(1:3).eq.'JT4') then
+     nmode=7
+  endif
+
+  uth=uth8
+  call cs_unlock
+
+  call astro(nyear,month,nday,uth,nfreq,hisgrid,2,nmode,1,    &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
+       AzAux,ElAux)
+  AzMoonB8=AzMoon
+  ElMoonB8=ElMoon
+  call astro(nyear,month,nday,uth,nfreq,grid,1,nmode,1,       &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
+       AzAux,ElAux)
+
+  RaAux8=auxra
+  DecAux8=auxdec
+  AzSun8=AzSun
+  ElSun8=ElSun
+  AzMoon8=AzMoon
+  ElMoon8=ElMoon
+  dbMoon8=dbMoon
+  RAMoon8=RAMoon/15.0
+  DecMoon8=DecMoon
+  HA8=HA
+  Dgrd8=Dgrd
+  sd8=sd
+  poloffset8=poloffset
+  xnr8=xnr
+  AzAux8=AzAux
+  ElAux8=ElAux
+  ndop=nint(doppler)
+  ndop00=nint(doppler00)
+
+  if(uth8z.eq.0.d0) then
+     uth8z=uth8-1.d0/3600.d0
+     dopplerz=doppler
+     doppler00z=doppler00
+  endif
+     
+  dt=60.0*(uth8-uth8z)
+  if(dt.le.0) dt=1.d0/60.d0
+  dfdt=(doppler-dopplerz)/dt
+  dfdt0=(doppler00-doppler00z)/dt
+  uth8z=uth8
+  dopplerz=doppler
+  doppler00z=doppler00
+
+  imin=60*uth8
+  isec=3600*uth8
+
+  if(isec.ne.isec0 .and. ndecoding.eq.0) then
+     call cs_lock('astro0b')
+     ih=uth8
+     im=mod(imin,60)
+     is=mod(isec,60)
+     rewind 14
+     write(14,1010,err=800) ih,im,is,AzMoon,ElMoon,                          &amp;
+        ih,im,is,AzSun,ElSun,                                        &amp;
+        ih,im,is,AzAux,ElAux,                                        &amp;
+        nfreq,doppler,dfdt,doppler00,dfdt0
+1010 format(i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Moon'/        &amp;
+            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Sun'/         &amp;
+            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Source'/      &amp;
+            i5,',',f8.1,',',f8.2,',',f8.1,',',f8.2,',Doppler')
+     rewind 14
+800  isec0=isec
+     call cs_unlock
+  endif
+
+  return
+end subroutine astro0

Deleted: wsjt7a/audio_init.F90
===================================================================
--- wsjt7a/audio_init.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/audio_init.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,78 +0,0 @@
-subroutine audio_init(ndin,ndout)
-!f2py threadsafe
-
-#ifdef CVF
-  use dfmt
-  integer Thread1,Thread2,ABOVE_NORMAL_PRIORITY_CLASS
-  parameter (ABOVE_NORMAL_PRIORITY_CLASS=32768)
-  external a2d,decode1
-#endif
-  integer start_threads
-
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  nmode=1
-  if(mode(1:4).eq.'JT65') then
-     nmode=2
-     if(mode(5:5).eq.'A') mode65=1
-     if(mode(5:5).eq.'B') mode65=2
-     if(mode(5:5).eq.'C') mode65=4
-  endif
-  if(mode(1:4).eq.'Echo') nmode=3
-  if(mode(1:4).eq.'JT6M') nmode=4
-  if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:4).eq.'JT41') then
-     nmode=9
-  else if(mode(1:3).eq.'JT4') then
-     nmode=7
-  endif
-  ndevin=ndin
-  ndevout=ndout
-  TxOK=0
-  Transmitting=0
-  nfsample=11025
-  nspb=1024
-  nbufs=2048
-  nmax=nbufs*nspb
-  nwave=60*nfsample
-  ngo=1
-  f0=800.0
-  do i=1,nwave
-     iwave(i)=nint(32767.0*sin(6.283185307*i*f0/nfsample))
-  enddo
-
-#ifdef CVF
-!  Priority classes (for processes):
-!     IDLE_PRIORITY_CLASS               64
-!     NORMAL_PRIORITY_CLASS             32
-!     HIGH_PRIORITY_CLASS              128
-
-!  Priority definitions (for threads):
-!     THREAD_PRIORITY_IDLE             -15
-!     THREAD_PRIORITY_LOWEST            -2
-!     THREAD_PRIORITY_BELOW_NORMAL      -1
-!     THREAD_PRIORITY_NORMAL             0
-!     THREAD_PRIORITY_ABOVE_NORMAL       1
-!     THREAD_PRIORITY_HIGHEST            2
-!     THREAD_PRIORITY_TIME_CRITICAL     15
-
-  npri=NORMAL_PRIORITY_CLASS
-  if(nhighpri.ne.0) npri=ABOVE_NORMAL_PRIORITY_CLASS
-  m0=SetPriorityClass(GetCurrentProcess(),npri)
-
-! Start a thread for doing A/D and D/A with sound card.
-  Thread1=CreateThread(0,0,a2d,0,CREATE_SUSPENDED,id1)
-  m1=SetThreadPriority(Thread1,THREAD_PRIORITY_ABOVE_NORMAL)
-  m2=ResumeThread(Thread1)
-
-! Start a thread for background decoding.
-  Thread2=CreateThread(0,0,decode1,0,CREATE_SUSPENDED,id2)
-  m3=SetThreadPriority(Thread2,THREAD_PRIORITY_BELOW_NORMAL)
-  m4=ResumeThread(Thread2)
-#else
-  ierr=start_threads()
-#endif
-
-  return
-end subroutine audio_init

Copied: wsjt7a/audio_init.f90 (from rev 1975, wsjt7a/audio_init.F90)
===================================================================
--- wsjt7a/audio_init.f90	                        (rev 0)
+++ wsjt7a/audio_init.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,42 @@
+subroutine audio_init(ndin,ndout)
+!f2py threadsafe
+
+  integer start_threads
+
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+
+  nmode=1
+  if(mode(1:4).eq.'JT65') then
+     nmode=2
+     if(mode(5:5).eq.'A') mode65=1
+     if(mode(5:5).eq.'B') mode65=2
+     if(mode(5:5).eq.'C') mode65=4
+  endif
+  if(mode(1:4).eq.'Echo') nmode=3
+  if(mode(1:4).eq.'JT6M') nmode=4
+  if(mode(1:2).eq.'CW') nmode=5
+  if(mode(1:4).eq.'JT41') then
+     nmode=9
+  else if(mode(1:3).eq.'JT4') then
+     nmode=7
+  endif
+  ndevin=ndin
+  ndevout=ndout
+  TxOK=0
+  Transmitting=0
+  nfsample=11025
+  nspb=1024
+  nbufs=2048
+  nmax=nbufs*nspb
+  nwave=60*nfsample
+  ngo=1
+  f0=800.0
+  do i=1,nwave
+     iwave(i)=nint(32767.0*sin(6.283185307*i*f0/nfsample))
+  enddo
+
+  ierr=start_threads()
+
+  return
+end subroutine audio_init

Deleted: wsjt7a/decode1.F90
===================================================================
--- wsjt7a/decode1.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/decode1.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,90 +0,0 @@
-subroutine decode1(iarg)
-
-! Get data and parameters from gcom, then call the decoders when needed.
-! This routine runs in a background thread and will never return.
-
-#ifdef CVF
-  use dflib
-#endif
-
-  character sending0*28,mode0*6,cshort*11
-  integer sendingsh0
-  integer*8 mtx
-  
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  include 'gcom4.f90'
-  common/mtxcom/mtx,ltrace,mtxstate,csub0
-
-  data sending0/'                      '/
-
-  ntr0=iarg                                    !Silence compiler warning
-  ntr0=ntr
-  ns0=999999
-  sendingsh0=-3
-
-10 ltrace=ndebug
-  if(mode(1:4).eq.'JT65' .or.                                    &amp;
-       (mode(1:3).eq.'JT4' .and. mode(1:4).ne.'JT41')            &amp;
-       .or. mode(1:2).eq.'CW') then
-     if(rxdone) then
-        call savedata
-        newdat2=1
-        rxdone=.false.
-     endif
-  else
-     if(ntr.ne.ntr0 .and. monitoring.gt.0) then
-        if(ntr.ne.TxFirst .or. (lauto.eq.0)) call savedata
-        ntr0=ntr
-     endif
-  endif
-
-  if(ndecoding.gt.0) then
-     ndecdone=0
-     call decode2
-     ndecdone=1
-     if(mousebutton.eq.0) ndecoding0=ndecoding
-     ndecoding=0
-  endif
-
-  if(ns0.lt.0) then
-     rewind 21
-     ns0=999999
-  endif
-  n=Tsec
-  if(n.lt.ns0 .and. utcdate(1:1).eq.'2') then
-     call cs_lock('decode1a')
-     write(21,1001) utcdate(:11)
-1001 format(/'UTC Date: ',a11/'---------------------')
-     call flushqqq(21)
-     call cs_unlock
-     ns0=n
-  endif
-
-  if(transmitting.eq.1 .and. (sending.ne.sending0 .or.       &amp;
-       sendingsh.ne.sendingsh0 .or. mode.ne.mode0)) then
-     ih=n/3600
-     im=mod(n/60,60)
-     is=mod(n,60)
-     cshort='           '
-     if(sendingsh.eq.1) cshort='(Shorthand)'
-     call cs_lock('decode1b')
-     write(21,1010) ih,im,is,mode,sending,cshort
-1010 format(3i2.2,'  Transmitting: ',a6,2x,a28,2x,a11)
-     call flushqqq(21)
-     call cs_unlock
-     sending0=sending
-     sendingsh0=sendingsh
-     mode0=mode
-  endif
-       
-#ifdef CVF
-  call sleepqq(100)
-#else
-  call usleep(100*1000)
-#endif
-
-  go to 10
-
-end subroutine decode1

Copied: wsjt7a/decode1.f90 (from rev 1975, wsjt7a/decode1.F90)
===================================================================
--- wsjt7a/decode1.f90	                        (rev 0)
+++ wsjt7a/decode1.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,81 @@
+subroutine decode1(iarg)
+
+! Get data and parameters from gcom, then call the decoders when needed.
+! This routine runs in a background thread and will never return.
+
+  character sending0*28,mode0*6,cshort*11
+  integer sendingsh0
+  integer*8 mtx
+  
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  include 'gcom4.f90'
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+
+  data sending0/'                      '/
+
+  ntr0=iarg                                    !Silence compiler warning
+  ntr0=ntr
+  ns0=999999
+  sendingsh0=-3
+
+10 ltrace=ndebug
+  if(mode(1:4).eq.'JT65' .or.                                    &amp;
+       (mode(1:3).eq.'JT4' .and. mode(1:4).ne.'JT41')            &amp;
+       .or. mode(1:2).eq.'CW') then
+     if(rxdone) then
+        call savedata
+        newdat2=1
+        rxdone=.false.
+     endif
+  else
+     if(ntr.ne.ntr0 .and. monitoring.gt.0) then
+        if(ntr.ne.TxFirst .or. (lauto.eq.0)) call savedata
+        ntr0=ntr
+     endif
+  endif
+
+  if(ndecoding.gt.0) then
+     ndecdone=0
+     call decode2
+     ndecdone=1
+     if(mousebutton.eq.0) ndecoding0=ndecoding
+     ndecoding=0
+  endif
+
+  if(ns0.lt.0) then
+     rewind 21
+     ns0=999999
+  endif
+  n=Tsec
+  if(n.lt.ns0 .and. utcdate(1:1).eq.'2') then
+     call cs_lock('decode1a')
+     write(21,1001) utcdate(:11)
+1001 format(/'UTC Date: ',a11/'---------------------')
+     call flush(21)
+     call cs_unlock
+     ns0=n
+  endif
+
+  if(transmitting.eq.1 .and. (sending.ne.sending0 .or.       &amp;
+       sendingsh.ne.sendingsh0 .or. mode.ne.mode0)) then
+     ih=n/3600
+     im=mod(n/60,60)
+     is=mod(n,60)
+     cshort='           '
+     if(sendingsh.eq.1) cshort='(Shorthand)'
+     call cs_lock('decode1b')
+     write(21,1010) ih,im,is,mode,sending,cshort
+1010 format(3i2.2,'  Transmitting: ',a6,2x,a28,2x,a11)
+     call flush(21)
+     call cs_unlock
+     sending0=sending
+     sendingsh0=sendingsh
+     mode0=mode
+  endif
+       
+  call usleep(100*1000)
+  go to 10
+
+end subroutine decode1

Deleted: wsjt7a/decode3.F90
===================================================================
--- wsjt7a/decode3.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/decode3.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,107 +0,0 @@
-subroutine decode3(d2,jz,istart,filename)
-
-#ifdef CVF
-  use dfport
-#endif
-
-  integer*2 d2(jz),d2d(125*11025)
-  character*24 filename
-  character FileID*40
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  
-  if(ichar(filename(1:1)).eq.0) go to 999
-    
-  FileID=filename
-  decodedfile=filename
-  lumsg=11
-  nqrn=nclip+5
-  nmode=1
-  if(mode(1:4).eq.'JT65') then
-     nmode=2
-     if(mode(5:5).eq.'A') mode65=1
-     if(mode(5:5).eq.'B') mode65=2
-     if(mode(5:5).eq.'C') mode65=4
-  endif
-  if(mode(1:4).eq.'Echo') nmode=3
-  if(mode(1:4).eq.'JT6M') nmode=4
-  if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:4).eq.'JT41') then
-     nmode=9
-  else if(mode(1:3).eq.'JT4') then
-     nmode=7
-  endif
-  sum=0.
-  do i=1,jz
-     sum=sum+d2(i)
-  enddo
-  nave=nint(sum/jz)
-  do i=1,jz
-     d2(i)=d2(i)-nave
-     d2d(i)=d2(i)
-  enddo
-
-  if(nblank.ne.0) call blanker(d2d,jz)
-
-  nseg=1
-  if(mode(1:4).eq.'JT65' .or. nmode.ge.6) then
-     i=index(FileID,'.')-3
-     if(FileID(i:i).eq.'1'.or.FileID(i:i).eq.'3'.or.FileID(i:i).eq.'5'  &amp;
-          .or.FileID(i:i).eq.'7'.or.FileID(i:i).eq.'9') nseg=2
-  endif
-
-  open(23,file=appdir(:lenappdir)//'/CALL3.TXT',status='unknown')
-  if(nadd5.eq.1) then
-!  Insert 5 s of zeroes at start of data.
-     nzero=5*11025
-     do i=jz,nzero+1,-1
-        d2d(i)=d2d(i-nzero)
-     enddo
-     do i=1,nzero
-        d2d(i)=0
-     enddo
-     jz=min(60*11025,jz+nzero)
-  endif
-  call wsjt1(d2d,jz,istart,samfacin,FileID,ndepth,                     &amp;
-       MinSigdB,NQRN,DFTolerance,MouseButton,NClearAve,nforce,         &amp;
-       nMode,NFreeze,NAFC,NZap,mode65,mode4,idf,ntdecode,              &amp;
-       MyCall,HisCall,HisGrid,neme,ntx2,s2,                            &amp;
-       ps0,npkept,lumsg,basevb,rmspower,nslim2,psavg,ccf,Nseg,         &amp;
-       MouseDF,NAgain,LDecoded,nspecial,ndf,ss1,ss2)
-  nforce=0
-  ntx2=0
-  close(23)
-  if(basevb.le.-98.0) go to 999
-
-! See whether this file should be saved or erased from disk
-  if(nsave.eq.1 .and. ldecoded) filetokilla=''
-  if(nsave.eq.3 .or. (nsave.eq.2 .and. lauto.eq.1)) then
-     filetokilla=''
-     filetokillb=''
-  endif
-  if(nsavelast.eq.1) filetokillb=''
-  nsavelast=0
-  ierr=unlink(filetokillb)
-  
-  nclearave=0
-  nagain=0
-  if(mode(1:4).eq.'JT65') then
-     call pix2d65(d2d,jz)
-  else if(mode.eq.'FSK441') then
-     nz=s2(1,1)
-     call pix2d(d2d,jz,mousebutton,MouseDF,NFreeze,mode,s2,64,nz,b)
-  else if(mode(1:4).eq.'JT6M' .and. mousebutton.eq.0) then
-     nz=s2(1,1)
-     call pix2d(d2d,jz,mousebutton,MouseDF,NFreeze,mode,s2,64,nz,b)
-  endif
-
-! Compute red and magenta cutves for small plot area, FSK441/JT6M only
-  if(mode.eq.'FSK441' .or. mode.eq.'JT6M') then
-     do i=1,128
-        if(mode.eq.'FSK441' .and. ps0(i).gt.0.0) ps0(i)=10.0*log10(ps0(i))
-        if(psavg(i).gt.0.0) psavg(i)=10.0*log10(psavg(i))
-     enddo
-  endif
-
-999 return
-end subroutine decode3

Copied: wsjt7a/decode3.f90 (from rev 1975, wsjt7a/decode3.F90)
===================================================================
--- wsjt7a/decode3.f90	                        (rev 0)
+++ wsjt7a/decode3.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,103 @@
+subroutine decode3(d2,jz,istart,filename)
+
+  integer*2 d2(jz),d2d(125*11025)
+  character*24 filename
+  character FileID*40
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  
+  if(ichar(filename(1:1)).eq.0) go to 999
+    
+  FileID=filename
+  decodedfile=filename
+  lumsg=11
+  nqrn=nclip+5
+  nmode=1
+  if(mode(1:4).eq.'JT65') then
+     nmode=2
+     if(mode(5:5).eq.'A') mode65=1
+     if(mode(5:5).eq.'B') mode65=2
+     if(mode(5:5).eq.'C') mode65=4
+  endif
+  if(mode(1:4).eq.'Echo') nmode=3
+  if(mode(1:4).eq.'JT6M') nmode=4
+  if(mode(1:2).eq.'CW') nmode=5
+  if(mode(1:4).eq.'JT41') then
+     nmode=9
+  else if(mode(1:3).eq.'JT4') then
+     nmode=7
+  endif
+  sum=0.
+  do i=1,jz
+     sum=sum+d2(i)
+  enddo
+  nave=nint(sum/jz)
+  do i=1,jz
+     d2(i)=d2(i)-nave
+     d2d(i)=d2(i)
+  enddo
+
+  if(nblank.ne.0) call blanker(d2d,jz)
+
+  nseg=1
+  if(mode(1:4).eq.'JT65' .or. nmode.ge.6) then
+     i=index(FileID,'.')-3
+     if(FileID(i:i).eq.'1'.or.FileID(i:i).eq.'3'.or.FileID(i:i).eq.'5'  &amp;
+          .or.FileID(i:i).eq.'7'.or.FileID(i:i).eq.'9') nseg=2
+  endif
+
+  open(23,file=appdir(:lenappdir)//'/CALL3.TXT',status='unknown')
+  if(nadd5.eq.1) then
+!  Insert 5 s of zeroes at start of data.
+     nzero=5*11025
+     do i=jz,nzero+1,-1
+        d2d(i)=d2d(i-nzero)
+     enddo
+     do i=1,nzero
+        d2d(i)=0
+     enddo
+     jz=min(60*11025,jz+nzero)
+  endif
+  call wsjt1(d2d,jz,istart,samfacin,FileID,ndepth,                     &amp;
+       MinSigdB,NQRN,DFTolerance,MouseButton,NClearAve,nforce,         &amp;
+       nMode,NFreeze,NAFC,NZap,mode65,mode4,idf,ntdecode,              &amp;
+       MyCall,HisCall,HisGrid,neme,ntx2,s2,                            &amp;
+       ps0,npkept,lumsg,basevb,rmspower,nslim2,psavg,ccf,Nseg,         &amp;
+       MouseDF,NAgain,LDecoded,nspecial,ndf,ss1,ss2)
+  nforce=0
+  ntx2=0
+  close(23)
+  if(basevb.le.-98.0) go to 999
+
+! See whether this file should be saved or erased from disk
+  if(nsave.eq.1 .and. ldecoded) filetokilla=''
+  if(nsave.eq.3 .or. (nsave.eq.2 .and. lauto.eq.1)) then
+     filetokilla=''
+     filetokillb=''
+  endif
+  if(nsavelast.eq.1) filetokillb=''
+  nsavelast=0
+  ierr=unlink(filetokillb)
+  
+  nclearave=0
+  nagain=0
+  if(mode(1:4).eq.'JT65') then
+     call pix2d65(d2d,jz)
+  else if(mode.eq.'FSK441') then
+     nz=s2(1,1)
+     call pix2d(d2d,jz,mousebutton,MouseDF,NFreeze,mode,s2,64,nz,b)
+  else if(mode(1:4).eq.'JT6M' .and. mousebutton.eq.0) then
+     nz=s2(1,1)
+     call pix2d(d2d,jz,mousebutton,MouseDF,NFreeze,mode,s2,64,nz,b)
+  endif
+
+! Compute red and magenta cutves for small plot area, FSK441/JT6M only
+  if(mode.eq.'FSK441' .or. mode.eq.'JT6M') then
+     do i=1,128
+        if(mode.eq.'FSK441' .and. ps0(i).gt.0.0) ps0(i)=10.0*log10(ps0(i))
+        if(psavg(i).gt.0.0) psavg(i)=10.0*log10(psavg(i))
+     enddo
+  endif
+
+999 return
+end subroutine decode3

Deleted: wsjt7a/deep65.F
===================================================================
--- wsjt7a/deep65.F	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/deep65.F	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,176 +0,0 @@
-      subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,
-     +  hisgrid,decoded,qual)
-
-      parameter (MAXCALLS=7000,MAXRPT=63)
-      real s3(64,63)
-      character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
-      character*12 mycall,hiscall
-      character*22 decoded
-      character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
-      character*15 callgrid(MAXCALLS)
-      character*180 line
-      character*4 rpt(MAXRPT)
-      integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
-!      character*1 cflag
-      character*36 cc
-      integer dgen(12)
-      common/tmp8/ mcode(63)
-      common/tmp9/ mrs(63),mrs2(63)
-      data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
-#ifdef CVF
-C  This prevents some optimizations that break this subroutine.
-      volatile p1,p2,bias
-#endif
-
-      data neme0/-99/
-      data rpt/'-01','-02','-03','-04','-05',
-     +         '-06','-07','-08','-09','-10',
-     +         '-11','-12','-13','-14','-15',
-     +         '-16','-17','-18','-19','-20',
-     +         '-21','-22','-23','-24','-25',
-     +         '-26','-27','-28','-29','-30',
-     +         'R-01','R-02','R-03','R-04','R-05',
-     +         'R-06','R-07','R-08','R-09','R-10',
-     +         'R-11','R-12','R-13','R-14','R-15',
-     +         'R-16','R-17','R-18','R-19','R-20',
-     +         'R-21','R-22','R-23','R-24','R-25',
-     +         'R-26','R-27','R-28','R-29','R-30',
-     +         'RO','RRR','73'/
-      data iseed/1000000001/,dgen(1)/999/
-      save
-
-      call cs_lock('deep65')
-      rewind 23
-      k=0
-      icall=0
-      do n=1,MAXCALLS
-         if(n.eq.1) then
-            callsign=hiscall
-            do i=4,12
-               if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
-            enddo
-            grid=hisgrid(1:4)
-            if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
-            if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
-         else
-            read(23,1002,end=20) line
- 1002       format (A80)
-            if(line(1:4).eq.'ZZZZ') go to 20
-            if(line(1:2).eq.'//') go to 10
-            i1=index(line,',')
-            if(i1.lt.4) go to 10
-            i2=index(line(i1+1:),',')
-            if(i2.lt.5) go to 10
-            i2=i2+i1
-            i3=index(line(i2+1:),',')
-            if(i3.lt.1) i3=index(line(i2+1:),' ')
-            i3=i2+i3
-            callsign=line(1:i1-1)
-            grid=line(i1+1:i2-1)
-            ceme=line(i2+1:i3-1)
-            if(callsign.eq.hiscall .and. grid.eq.hisgrid(1:4)) go to 10
-            if(neme.eq.1 .and. ceme.ne.'EME') go to 10
-         endif
-
-         icall=icall+1
-         j1=index(mycall,' ') - 1
-         if(j1.le.-1) j1=12
-         if(j1.lt.3) j1=6
-         j2=index(callsign,' ') - 1
-         if(j2.le.-1) j2=12
-         if(j2.lt.3) j2=6
-         j3=index(mycall,'/')
-         j4=index(callsign,'/')
-         callgrid(icall)=callsign(1:j2)
-
-         mz=1
-         if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.
-     +      flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
-C  Test for messages with MyCall + HisCall + report
-         do m=1,mz
-            if(m.gt.1) grid=rpt(m-1)
-            if(j3.lt.1 .and.j4.lt.1) 
-     +         callgrid(icall)=callsign(1:j2)//' '//grid
-            message=mycall(1:j1)//' '//callgrid(icall)
-            k=k+1
-            testmsg(k)=message
-            call encode65(message,ncode(1,k))
-C  Insert CQ message unless sync=OOO (flip=-1).
-            if(m.eq.1 .and. flip.gt.0.0) then
-               message='CQ '//callgrid(icall)
-               k=k+1
-               testmsg(k)=message
-               call encode65(message,ncode(1,k))
-            endif
-         enddo
- 10      continue
-      enddo
- 20   ntot=k
-      call cs_unlock
-      neme0=neme
-
-      ref0=0.
-      do j=1,63
-         ref0=ref0 + s3(mrs(j),j)
-      enddo
-
-      p1=0.
-      p2=0.
-      do k=1,ntot
-         sum=0.
-         ref=ref0
-         do j=1,63
-            i=ncode(j,k)+1
-            sum=sum + s3(i,j)
-            if(i.eq.mrs(j)) then
-               ref=ref - s3(i,j) + s3(mrs2(j),j)
-            endif
-         enddo
-         p=sum/ref
-         if(p.gt.p2) then
-            if(p.gt.p1) then
-               p2=p1
-!               ip2=ip1
-               p1=p
-               ip1=k
-            else
-               p2=p
-!               ip2=k
-            endif
-         endif
-      enddo
-
-      if(mode65.eq.1) bias=max(1.12*p2,0.335)
-      if(mode65.eq.2) bias=max(1.08*p2,0.405)
-      if(mode65.ge.4) bias=max(1.04*p2,0.505)
-      qual=100.0*(p1-bias)
-      if(qual.lt.0.0) qual=0.0
-      decoded='                      '
-      c=' '
-
-      if(qual.gt.1.0) then
-         if(ip1.le.ntot) then
-            if(qual.lt.6.0) c='?'
-            decoded=testmsg(ip1)
-            do j=1,63
-               mcode(j)=ncode(j,ip1)+1
-            enddo
-         else
-            i=ip1-ntot-1
-            i1=i/(36**3)
-            i2=(i - i1*36**3)/(36**2)
-            i3=(i - i1*36**3 - i2*36**2)/36
-            i4=mod(i,36)
-            decoded=cc(i1+1:i1+1)//cc(i2+1:i2+1)//cc(i3+1:i3+1)//
-     +           cc(i4+1:i4+1)//'                  '
-         endif
-
-      endif
-      decoded(22:22)=c
-
-C  Neutralize the SM2CEW foolishness
-      call packmsg(decoded,dgen)
-      call unpackmsg(dgen,decoded)
-
-      return
-      end

Copied: wsjt7a/deep65.f90 (from rev 1974, wsjt7a/deep65.F)
===================================================================
--- wsjt7a/deep65.f90	                        (rev 0)
+++ wsjt7a/deep65.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,171 @@
+subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,                  &amp;
+     hisgrid,decoded,qual)
+
+  parameter (MAXCALLS=7000,MAXRPT=63)
+  real s3(64,63)
+  character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
+  character*12 mycall,hiscall
+  character*22 decoded
+  character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
+  character*15 callgrid(MAXCALLS)
+  character*180 line
+  character*4 rpt(MAXRPT)
+  integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
+  character*36 cc
+  integer dgen(12)
+  common/tmp8/ mcode(63)
+  common/tmp9/ mrs(63),mrs2(63)
+  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
+
+  data neme0/-99/
+  data rpt/'-01','-02','-03','-04','-05',                      &amp;
+              '-06','-07','-08','-09','-10',                   &amp;
+              '-11','-12','-13','-14','-15',                   &amp;
+              '-16','-17','-18','-19','-20',                   &amp;
+              '-21','-22','-23','-24','-25',                   &amp;
+              '-26','-27','-28','-29','-30',                   &amp;
+              'R-01','R-02','R-03','R-04','R-05',              &amp;
+              'R-06','R-07','R-08','R-09','R-10',              &amp;
+              'R-11','R-12','R-13','R-14','R-15',              &amp;
+              'R-16','R-17','R-18','R-19','R-20',              &amp;
+              'R-21','R-22','R-23','R-24','R-25',              &amp;
+              'R-26','R-27','R-28','R-29','R-30',              &amp;
+              'RO','RRR','73'/
+  data iseed/1000000001/,dgen(1)/999/
+  save
+
+  call cs_lock('deep65')
+  rewind 23
+  k=0
+  icall=0
+  do n=1,MAXCALLS
+     if(n.eq.1) then
+        callsign=hiscall
+        do i=4,12
+           if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
+        enddo
+        grid=hisgrid(1:4)
+        if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
+        if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
+     else
+        read(23,1002,end=20) line
+1002    format (A80)
+        if(line(1:4).eq.'ZZZZ') go to 20
+        if(line(1:2).eq.'//') go to 10
+        i1=index(line,',')
+        if(i1.lt.4) go to 10
+        i2=index(line(i1+1:),',')
+        if(i2.lt.5) go to 10
+        i2=i2+i1
+        i3=index(line(i2+1:),',')
+        if(i3.lt.1) i3=index(line(i2+1:),' ')
+        i3=i2+i3
+        callsign=line(1:i1-1)
+        grid=line(i1+1:i2-1)
+        ceme=line(i2+1:i3-1)
+        if(callsign.eq.hiscall .and. grid.eq.hisgrid(1:4)) go to 10
+        if(neme.eq.1 .and. ceme.ne.'EME') go to 10
+     endif
+
+     icall=icall+1
+     j1=index(mycall,' ') - 1
+     if(j1.le.-1) j1=12
+     if(j1.lt.3) j1=6
+     j2=index(callsign,' ') - 1
+     if(j2.le.-1) j2=12
+     if(j2.lt.3) j2=6
+     j3=index(mycall,'/')
+     j4=index(callsign,'/')
+     callgrid(icall)=callsign(1:j2)
+
+     mz=1
+     if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.                        &amp;
+          flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
+! Test for messages with MyCall + HisCall + report
+     do m=1,mz
+        if(m.gt.1) grid=rpt(m-1)
+        if(j3.lt.1 .and.j4.lt.1)                                        &amp;
+             callgrid(icall)=callsign(1:j2)//' '//grid
+        message=mycall(1:j1)//' '//callgrid(icall)
+        k=k+1
+        testmsg(k)=message
+        call encode65(message,ncode(1,k))
+! Insert CQ message unless sync=OOO (flip=-1).
+        if(m.eq.1 .and. flip.gt.0.0) then
+           message='CQ '//callgrid(icall)
+           k=k+1
+           testmsg(k)=message
+           call encode65(message,ncode(1,k))
+        endif
+     enddo
+10   continue
+  enddo
+20 ntot=k
+  call cs_unlock
+  neme0=neme
+
+  ref0=0.
+  do j=1,63
+     ref0=ref0 + s3(mrs(j),j)
+  enddo
+
+  p1=0.
+  p2=0.
+  do k=1,ntot
+     sum=0.
+     ref=ref0
+     do j=1,63
+        i=ncode(j,k)+1
+        sum=sum + s3(i,j)
+        if(i.eq.mrs(j)) then
+           ref=ref - s3(i,j) + s3(mrs2(j),j)
+        endif
+     enddo
+     p=sum/ref
+     if(p.gt.p2) then
+        if(p.gt.p1) then
+           p2=p1
+!               ip2=ip1
+           p1=p
+           ip1=k
+        else
+           p2=p
+!               ip2=k
+        endif
+     endif
+  enddo
+  
+  if(mode65.eq.1) bias=max(1.12*p2,0.335)
+  if(mode65.eq.2) bias=max(1.08*p2,0.405)
+  if(mode65.ge.4) bias=max(1.04*p2,0.505)
+  qual=100.0*(p1-bias)
+  if(qual.lt.0.0) qual=0.0
+  decoded='                      '
+  c=' '
+
+  if(qual.gt.1.0) then
+     if(ip1.le.ntot) then
+        if(qual.lt.6.0) c='?'
+        decoded=testmsg(ip1)
+        do j=1,63
+           mcode(j)=ncode(j,ip1)+1
+        enddo
+     else
+        i=ip1-ntot-1
+        i1=i/(36**3)
+        i2=(i - i1*36**3)/(36**2)
+        i3=(i - i1*36**3 - i2*36**2)/36
+        i4=mod(i,36)
+        decoded=cc(i1+1:i1+1)//cc(i2+1:i2+1)//cc(i3+1:i3+1)//        &amp;
+             cc(i4+1:i4+1)//'                  '
+     endif
+     
+  endif
+  decoded(22:22)=c
+
+! Neutralize the SM2CEW foolishness
+  call packmsg(decoded,dgen)
+  call unpackmsg(dgen,decoded)
+
+  return
+end subroutine deep65

Deleted: wsjt7a/extract.f
===================================================================
--- wsjt7a/extract.f	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/extract.f	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,100 +0,0 @@
-      subroutine extract(s3,nadd,ncount,decoded)
-
-      real s3(64,63)
-      real tmp(4032)
-      character decoded*22
-      integer era(51),dat4(12),indx(64)
-      integer mrsym(63),mr2sym(63),mrprob(63),mr2prob(63)
-      logical first
-      common/extcom/ntdecode
-      data first/.true./,nsec1/0/
-      save
-
-      nfail=0
- 1    call demod64a(s3,nadd,mrsym,mrprob,mr2sym,mr2prob,ntest,nlow)
-
-      if(ntest.lt.50 .or. nlow.gt.20) then
-         ncount=-999                         !Flag bad data
-         go to 900
-      endif
-
-      call chkhist(mrsym,nhist,ipk)
-      if(nhist.ge.20) then
-         nfail=nfail+1
-         call pctile(s3,tmp,4032,50,base)     ! ### or, use ave from demod64a ?
-         do j=1,63
-            s3(ipk,j)=base
-         enddo
-         go to 1
-      endif
-
-      call graycode(mrsym,63,-1)
-      call interleave63(mrsym,-1)
-      call interleave63(mrprob,-1)
-
-      ndec=1
-      nemax=30
-      maxe=8
-      xlambda=15.0
-      naddsynd=200
-      if(ntdecode.eq.48) then
-         xlambda=12.0
-         naddsynd=50
-      endif
-
-      if(ndec.eq.1) then
-         call graycode(mr2sym,63,-1)
-         call interleave63(mr2sym,-1)
-         call interleave63(mr2prob,-1)
-
-         nsec1=nsec1+1
-
-         call cs_lock('extract')
-         write(22,rec=1) nsec1,xlambda,maxe,naddsynd,
-     +        mrsym,mrprob,mr2sym,mr2prob
-         call flushqqq(22)
-         call cs_unlock
-
-         call runqqq('kvasd.exe','-q',iret)
-
-         call cs_lock('extract')
-         if(iret.ne.0) then
-            if(first) write(*,1000) iret
- 1000       format('Error in KV decoder, or no KV decoder present.'/
-     +         'Return code:',i8,'.  Will use BM algorithm.')
-            ndec=0
-            first=.false.
-            go to 20
-         endif
-         read(22,rec=2,err=20) nsec2,ncount,dat4
-
-         decoded='                      '
-         if(ncount.ge.0) then
-            call unpackmsg(dat4,decoded) !Unpack the user message
-         endif
- 20      call cs_unlock
-      endif
-
-      if(ndec.eq.0) then
-         call indexx(63,mrprob,indx)
-         do i=1,nemax
-            j=indx(i)
-            if(mrprob(j).gt.120) then
-               ne2=i-1
-               go to 2
-            endif
-            era(i)=j-1
-         enddo
-         ne2=nemax
- 2       decoded='                      '
-         do nerase=0,ne2,2
-            call rs_decode(mrsym,era,nerase,dat4,ncount)
-            if(ncount.ge.0) then
-               call unpackmsg(dat4,decoded)
-               go to 900
-            endif
-         enddo
-      endif
-
- 900  return
-      end

Deleted: wsjt7a/fivehz.F90
===================================================================
--- wsjt7a/fivehz.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/fivehz.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,258 +0,0 @@
-subroutine fivehz
-
-!  Called at interrupt level from the PortAudio callback routine.
-!  For nspb=2048 the callback rate is nfsample/nspb = 5.38 Hz.
-!  Thus, we should be able to control the timing of T/R sequence events
-!  here to within about 0.2 s.
-
-!  Do not do anything very time consuming in this routine!!
-!  Disk I/O is a bad idea.  Writing to stdout (for diagnostic purposes)
-!  seems to be OK.
-
-#ifdef CVF
-  use dflib
-  use dfport
-#else
-  integer time
-#endif
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,txtime,filled
-  integer ptt
-  integer TxOKz
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  data first/.true./,nc0/1/,nc1/1/,nsec0/-99/
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     rxdelay=0.2
-     txdelay=0.4
-     tlatency=1.0
-     first=.false.
-     iptt=0
-     ntr0=-99
-     rxdone=.false.
-     ibuf00=-99
-     ncall=-1
-     u=0.05d0
-     fsample=11025.d0
-     mfsample=110250
-     filled=.false.
-  endif
-
-  if(txdelay.lt.0.2d0) txdelay=0.2d0
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-!  if(ncall.ge.10 .and. mod(ncall,2).eq.1) then
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample=nint(10.d0*fsample)
-     endif
-  endif
-
-  if(trperiod.le.0) trperiod=30
-  tx1=0.0                              !Time to start a TX sequence
-  tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
-  if(mode(1:4).eq.'JT65' .or.                   &amp;
-       (mode(1:3).eq.'JT4' .and. mode(1:4).ne.'JT41')) then
-     if(nwave.lt.126*4096) nwave=126*4096
-     tx2=txdelay + nwave/11025.0
-     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
-  endif
-
-  if(TxFirst.eq.0) then
-     tx1=tx1+trperiod
-     tx2=tx2+trperiod
-  endif
-
-  t=mod(Tsec,2.d0*trperiod)
-  txtime = t.ge.tx1 .and. t.lt.tx2
-
-! If we're transmitting, freeze the input buffer pointers where they were.
-  receiving=1
-  if(((txtime .and. (lauto.eq.1)) .or. TxOK.eq.1 .or. transmitting.eq.1) &amp; 
-       .and. (mute.eq.0)) then
-     receiving=0
-     ibuf=ibuf000
-     iwrite=iwrite000
-  endif
-  ibuf000=ibuf
-  iwrite000=iwrite
-  nsec=Tsec
-  ntr=mod(nsec/trperiod,2)             !ntr=0 in 1st sequence, 1 in 2nd
-
-  if(ntr.ne.ntr0) then
-     ibuf0=ibuf                        !Start of new sequence, save ibuf
-!     if(mode(1:4).ne.'JT65') then
-!        ibuf0=ibuf0+3                  !So we don't copy our own Tx
-!        if(ibuf0.gt.1024) ibuf0=ibuf0-1024
-!     endif
-     ntime=time()                      !Save start time
-     if(mantx.eq.1 .and. iptt.eq.1) then
-        mantx=0
-        TxOK=0
-     endif
-  endif
-
-! Switch PTT line and TxOK appropriately
-  if(lauto.eq.1) then
-     if(txtime .and. iptt.eq.0 .and.          &amp;
-          mute.eq.0) i1=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(.not.txtime .or. mute.eq.1) TxOK=0               !Lower TxOK
-  else
-     if(mantx.eq.1 .and. iptt.eq.0 .and.      &amp;
-          mute.eq.0) i2=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(mantx.eq.0 .or. mute.eq.1) TxOK=0                !Lower TxOK
-  endif
-
-! Calculate Tx waveform as needed
-  if((iptt.eq.1 .and. iptt0.eq.0) .or. nrestart.eq.1) then
-     call wsjtgen
-     nrestart=0
-  endif
-
-! If PTT was just raised, start a countdown for raising TxOK:
-  nc1a=txdelay/0.18576
-  if(nc1a.lt.2) nc1a=2
-  if(iptt.eq.1 .and. iptt0.eq.0) nc1=-nc1a-1
-  if(nc1.le.0) nc1=nc1+1
-  if(nc1.eq.0) TxOK=1                               ! We are transmitting
-
-! If TxOK was just lowered, start a countdown for lowering PTT:
-  nc0a=(tlatency+txdelay)/0.18576
-  if(nc0a.lt.5) nc0a=5
-  if(TxOK.eq.0 .and. TxOKz.eq.1 .and. iptt.eq.1) nc0=-nc0a-1
-  if(nc0.le.0) nc0=nc0+1
-  if(nc0.eq.0) i3=ptt(nport,pttport,0,iptt)
-
-  if(iptt.eq.0 .and.TxOK.eq.0) then
-     sending=&quot;                      &quot;
-     sendingsh=0
-  endif
-
-  nbufs=i1+i2+i3                             !Silence g95 warning
-  nbufs=ibuf-ibuf0
-  if(nbufs.lt.0) nbufs=nbufs+1024
-  tdata=nbufs*2048.0/11025.0
-
-  if((mode(1:4).eq.'JT65' .or.                                      &amp;
-       (mode(1:3).eq.'JT4' .and. mode(1:4).ne.'JT41')               &amp;
-       .or. mode(1:2).eq.'CW') .and. monitoring.eq.1                &amp;
-       .and. tdata.gt.float(ntdecode) .and. ibuf0.ne.ibuf00) then
-     rxdone=.true.
-     ibuf00=ibuf0
-  endif
-
-  iptt0=iptt
-  TxOKz=TxOK
-  ntr0=ntr
-
-  return
-end subroutine fivehz
-
-subroutine fivehztx
-
-!  Called at interrupt level from the PortAudio output callback.
-
-#ifdef CVF
-  use dflib
-  use dfport
-#endif
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,filled
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  data first/.true./
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     first=.false.
-     ncall=-1
-     fsample=11025.d0
-     u=0.05d0
-     mfsample2=110250
-     filled=.false.
-  endif
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample2=nint(10.d0*fsample)
-     endif
-  endif
-
-  return
-end subroutine fivehztx
-
-subroutine addnoise(n)
-  integer*2 n
-  real*8 txsnrdb0
-  include 'gcom1.f90'
-  data idum/0/
-  save
-
-  if(txsnrdb.gt.40.0) return
-  if(txsnrdb.ne.txsnrdb0) then
-     snr=10.0**(0.05*(txsnrdb-1))
-     fac=3000.0
-     if(snr.gt.1.0) fac=3000.0/snr
-     txsnrdb0=txsnrdb
-  endif
-  i=fac*(gran(idum) + n*snr/32768.0)
-  if(i&gt;32767) i=32767;
-  if(i&lt;-32767) i=-32767;
-  n=i
-
-  return
-end subroutine addnoise
-
-real function gran(idum)
-  real r(12)
-  if(idum.lt.0) then
-     call random_seed
-     idum=0
-  endif
-  call random_number(r)
-  gran=sum(r)-6.0
-end function gran

Deleted: wsjt7a/ftn_init.F90
===================================================================
--- wsjt7a/ftn_init.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/ftn_init.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,130 +0,0 @@
-! Fortran logical units used in WSJT6
-!
-!   10  wave files read from disk
-!   11  decoded.txt
-!   12  decoded.ave
-!   13  tsky.dat
-!   14  azel.dat
-!   15  debug.txt
-!   16  c:/wsjt.reg 
-!   17  wave files written to disk
-!   18  test file to be transmitted (wsjtgen.f90)
-!   19  dmet_* files
-!   20  prefixes.txt
-!   21  ALL.TXT
-!   22  kvasd.dat
-!   23  CALL3.TXT
-
-!------------------------------------------------ ftn_init
-subroutine ftn_init
-!f2py threadsafe
-
-  character*1 fname*80
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  include 'gcom4.f90'
-  character*12 csub0
-  integer*8 mtx
-  integer*2 nsky
-  common/sky/ nsky(360,180)
-  common/mtxcom/mtx,ltrace,mtxstate,csub0
-
-  call cs_init
-  call cs_lock('ftn_init')
-  i=ptt(nport,pttport,0,iptt)                       !Clear the PTT line
-  addpfx='    '
-
-  do i=80,1,-1
-     if(AppDir(i:i).ne.' ') goto 1
-  enddo
-1 iz=i
-  lenappdir=iz
-  call pfxdump(appdir(:iz)//'/prefixes.txt')
-
-#ifdef CVF
-  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
-       share='denynone',err=910)
-#else
-  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
-       err=910)
-#endif
-  endfile 11
-
-#ifdef CVF
-  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
-       share='denynone',err=920)
-#else
-  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
-       err=920)
-#endif
-  endfile 12
-
-#ifdef CVF
-  open(14,file=appdir(:iz)//'/azel.dat',status='unknown',                 &amp;
-       share='denynone',err=930)
-#else
-  open(14,file=appdir(:iz)//'/azel.dat',status='unknown',                 &amp;
-       err=930)
-#endif
-
-#ifdef CVF
-  open(15,file=appdir(:iz)//'/debug.txt',status='unknown',                 &amp;
-       share='denynone',err=940)
-#else
-  open(15,file=appdir(:iz)//'/debug.txt',status='unknown',                 &amp;
-       err=940)
-#endif
-
-#ifdef CVF
-  open(21,file=appdir(:iz)//'/ALL.TXT',status='unknown',                   &amp;
-       access='append',share='denynone',err=950)
-#else
-  open(21,file=appdir(:iz)//'/ALL.TXT',status='unknown',                   &amp;
-       position='append',err=950)
-#endif
-
-#ifdef CVF
-  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
-       status='unknown',share='denynone')
-#else
-  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
-       status='unknown')
-#endif
-
-  call zero(nsky,180*180)
-  fname=appdir(:iz)//'/TSKY.DAT'
-#ifdef CVF
-  open(13,file=fname,status='old',form='binary',err=10)
-  read(13) nsky
-  close(13)
-#else
-  call rfile2(fname,nsky,129600,nr)
-  if(nr.ne.129600) go to 10
-  nsky4=nsky(1,1)
-  if (iabs(nsky4).gt.500) then
-     write(*,1000)
-1000 format('Converting TSKY.DAT')
-     do i=1,360
-        do j=1,180
-           nsky(i,j) = iswap_short(nsky(i,j))
-        enddo
-     enddo
-  endif
-#endif
-
-10 call cs_unlock
-  return
-
-910 print*,'Error opening DECODED.TXT'
-  stop
-920 print*,'Error opening DECODED.AVE'
-  stop
-930 print*,'Error opening azel.dat'
-  stop
-940 print*,'Error opening DEBUG.TXT'
-  stop
-950 print*,'Error opening ALL.TXT'
-  stop
-
-end subroutine ftn_init

Copied: wsjt7a/ftn_init.f90 (from rev 1974, wsjt7a/ftn_init.F90)
===================================================================
--- wsjt7a/ftn_init.f90	                        (rev 0)
+++ wsjt7a/ftn_init.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,95 @@
+! Fortran logical units used in WSJT6
+!
+!   10  wave files read from disk
+!   11  decoded.txt
+!   12  decoded.ave
+!   13  tsky.dat
+!   14  azel.dat
+!   15  debug.txt
+!   16  c:/wsjt.reg 
+!   17  wave files written to disk
+!   18  test file to be transmitted (wsjtgen.f90)
+!   19  dmet_* files
+!   20  prefixes.txt
+!   21  ALL.TXT
+!   22  kvasd.dat
+!   23  CALL3.TXT
+
+!------------------------------------------------ ftn_init
+subroutine ftn_init
+!f2py threadsafe
+
+  character*1 fname*80
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  include 'gcom4.f90'
+  character*12 csub0
+  integer*8 mtx
+  integer*2 nsky
+  common/sky/ nsky(360,180)
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+
+  call cs_init
+  call cs_lock('ftn_init')
+  i=ptt(nport,pttport,0,iptt)                       !Clear the PTT line
+  addpfx='    '
+
+  do i=80,1,-1
+     if(AppDir(i:i).ne.' ') goto 1
+  enddo
+1 iz=i
+  lenappdir=iz
+  call pfxdump(appdir(:iz)//'/prefixes.txt')
+
+  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
+       err=910)
+  endfile 11
+
+  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
+       err=920)
+  endfile 12
+
+  open(14,file=appdir(:iz)//'/azel.dat',status='unknown',                 &amp;
+       err=930)
+
+  open(15,file=appdir(:iz)//'/debug.txt',status='unknown',                 &amp;
+       err=940)
+
+  open(21,file=appdir(:iz)//'/ALL.TXT',status='unknown',                   &amp;
+       position='append',err=950)
+
+  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
+       status='unknown')
+
+  call zero(nsky,180*180)
+  fname=appdir(:iz)//'/TSKY.DAT'
+
+  call rfile2(fname,nsky,129600,nr)
+  if(nr.ne.129600) go to 10
+  nsky4=nsky(1,1)
+  if (iabs(nsky4).gt.500) then
+     write(*,1000)
+1000 format('Converting TSKY.DAT')
+     do i=1,360
+        do j=1,180
+           nsky(i,j) = iswap_short(nsky(i,j))
+        enddo
+     enddo
+  endif
+
+10 call cs_unlock
+  return
+
+910 print*,'Error opening DECODED.TXT'
+  stop
+920 print*,'Error opening DECODED.AVE'
+  stop
+930 print*,'Error opening azel.dat'
+  stop
+940 print*,'Error opening DEBUG.TXT'
+  stop
+950 print*,'Error opening ALL.TXT'
+  stop
+
+end subroutine ftn_init

Deleted: wsjt7a/get_fname.F90
===================================================================
--- wsjt7a/get_fname.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/get_fname.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,23 +0,0 @@
-subroutine get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname)
-
-  character hiscall*12,fname*24,tag*7
-  integer ntime
-
-  nsec=mod(ntime,86400)
-  ihr=nsec/3600
-  imin=mod(nsec/60,60)
-  isec=mod(nsec,60)
-  call cs_lock('get_fname')
-  write(fname,1000) iyr-2000,imo,ida,ihr,imin,isec
-1000 format('_',3i2.2,'_',3i2.2,'.WAV')
-  call cs_unlock
-  tag=hiscall(1:7)
-  i=index(hiscall,'/')
-  if(i.ge.5) tag=hiscall(1:i-1)
-  if(i.ge.2.and.i.le.4) tag=hiscall(i+1:)
-  if(hiscall(1:1).eq.' ' .or. lauto.eq.0) tag='Mon'
-  i=index(tag,' ')
-  fname=tag(1:i-1)//fname
-  
-  return
-end subroutine get_fname

Copied: wsjt7a/get_fname.f90 (from rev 1974, wsjt7a/get_fname.F90)
===================================================================
--- wsjt7a/get_fname.f90	                        (rev 0)
+++ wsjt7a/get_fname.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,23 @@
+subroutine get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname)
+
+  character hiscall*12,fname*24,tag*7
+  integer ntime
+
+  nsec=mod(ntime,86400)
+  ihr=nsec/3600
+  imin=mod(nsec/60,60)
+  isec=mod(nsec,60)
+  call cs_lock('get_fname')
+  write(fname,1000) iyr-2000,imo,ida,ihr,imin,isec
+1000 format('_',3i2.2,'_',3i2.2,'.WAV')
+  call cs_unlock
+  tag=hiscall(1:7)
+  i=index(hiscall,'/')
+  if(i.ge.5) tag=hiscall(1:i-1)
+  if(i.ge.2.and.i.le.4) tag=hiscall(i+1:)
+  if(hiscall(1:1).eq.' ' .or. lauto.eq.0) tag='Mon'
+  i=index(tag,' ')
+  fname=tag(1:i-1)//fname
+  
+  return
+end subroutine get_fname

Deleted: wsjt7a/getfile.F90
===================================================================
--- wsjt7a/getfile.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/getfile.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,144 +0,0 @@
-subroutine getfile(fname,len)
-!f2py threadsafe
-
-#ifdef CVF
-  use dflib
-#endif
-
-  parameter (NDMAX=120*11025)
-  character*(*) fname
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom4.f90'
-
-
-  integer*1 d1(NDMAX)
-  integer*1 hdr(44)
-  integer*2 d2(NDMAX)
-  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-  character*4 ariff,awave,afmt,adata
-  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
-     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
-  equivalence (ariff,hdr),(d1,d2)
-
-1 if(ndecoding.eq.0) go to 2
-#ifdef CVF
-  call sleepqq(100)
-#else
-  call usleep(100*1000)
-#endif
-
-  go to 1
-
-2 do i=len,1,-1
-     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
-  enddo
-  i=0
-10 filename=fname(i+1:)
-  ierr=0
-
-  call cs_lock('getfile')
-#ifdef CVF
-  open(10,file=fname,form='binary',status='old',err=997)
-  read(10,end=997) hdr
-#else
-  call rfile2(fname,hdr,44+2*NDMAX,nr)
-#endif
-
-  call check_endian
-  if(nbitsam2.eq.8) then
-     if(ndata.gt.NDMAX) ndata=NDMAX
-
-#ifdef CVF
-     call rfile(10,d1,ndata,ierr)
-     if(ierr.ne.0) go to 998
-#endif
-
-     do i=1,ndata
-        n4=d1(i)
-        if (n4.lt.0) n4=256+n4
-        d2c(i)=250*(n4-128)
-     enddo
-     jzc=ndata
-
-  else if(nbitsam2.eq.16) then
-     if(ndata.gt.2*NDMAX) ndata=2*NDMAX
-#ifdef CVF
-     call rfile(10,d2c,ndata,ierr)
-     jzc=ndata/2
-     if(ierr.ne.0) go to 998
-#else
-     jzc=ndata/2
-     do i=1,jzc
-        d2c(i)=d2(i)
-     enddo
-#endif
-  endif
-
-  ndiskdat=1
-  mousebutton=0
-  close(10)
-  go to 999
-
-#ifdef CVF
-997 ierr=1001
-998 close(10)
-#endif
-
-999 call cs_unlock
-  return
-
-end subroutine getfile
-
-subroutine check_endian
-
-  parameter (NDMAX=120*11025)
-
-  integer*1 d1(NDMAX)
-  integer*1 hdr(44)
-  integer*2 d2(NDMAX)
-  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-  integer*2 iswap_short
-  character*4 ariff,awave,afmt,adata
-  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
-     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
-  equivalence (ariff,hdr),(d1,d2)
-
-  if (nfmt2.eq.1) return             ! correct endianess for this CPU
-  write(*,1000)
-1000 format('Converting file to big-endian',i10)
-  lenfile = iswap_int(lenfile)
-  lenfmt = iswap_int(lenfmt)
-  nfmt2 = iswap_short(nfmt2)
-  nchan2 = iswap_short(nchan2)
-  nsamrate = iswap_int(nsamrate)
-  nbytesec = iswap_int(nbytesec)
-  nbytesam2 = iswap_short(nbytesam2)
-  nbitsam2 = iswap_short(nbitsam2)
-  ndata = iswap_int(ndata)
-  if (nbitsam2.eq.8) return           ! header converted.   Data are bytes
-
-  do i=1,ndata/2
-    d2(i) = iswap_short(d2(i))
-  enddo
-
-
-  return
-end subroutine check_endian
-
-integer function iswap_int(idat)
-
-  itemp1 = ior(ishft(idat,24), iand(ishft(idat,8), z'00ff0000'))
-  itemp0 = ior(iand(ishft(idat,-8), z'0000ff00'), iand(ishft(idat,-24),z'000000ff'))
-  iswap_int = ior(itemp1,itemp0)
-  
-end function iswap_int
-
-integer*2 function iswap_short(idat)
-
-  integer*2 idat,m2
-  data m2/255/
-
-  iswap_short = ior(ishft(idat,8), iand(ishft(idat,-8), m2))
-
-end function iswap_short

Copied: wsjt7a/getfile.f90 (from rev 1974, wsjt7a/getfile.F90)
===================================================================
--- wsjt7a/getfile.f90	                        (rev 0)
+++ wsjt7a/getfile.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,114 @@
+subroutine getfile(fname,len)
+!f2py threadsafe
+
+  parameter (NDMAX=120*11025)
+  character*(*) fname
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom4.f90'
+
+
+  integer*1 d1(NDMAX)
+  integer*1 hdr(44)
+  integer*2 d2(NDMAX)
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
+  equivalence (ariff,hdr),(d1,d2)
+
+1 if(ndecoding.eq.0) go to 2
+  call usleep(100*1000)
+
+  go to 1
+
+2 do i=len,1,-1
+     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
+  enddo
+  i=0
+10 filename=fname(i+1:)
+  ierr=0
+
+  call cs_lock('getfile')
+  call rfile2(fname,hdr,44+2*NDMAX,nr)
+
+  call check_endian
+  if(nbitsam2.eq.8) then
+     if(ndata.gt.NDMAX) ndata=NDMAX
+
+     do i=1,ndata
+        n4=d1(i)
+        if (n4.lt.0) n4=256+n4
+        d2c(i)=250*(n4-128)
+     enddo
+     jzc=ndata
+
+  else if(nbitsam2.eq.16) then
+     if(ndata.gt.2*NDMAX) ndata=2*NDMAX
+     jzc=ndata/2
+     do i=1,jzc
+        d2c(i)=d2(i)
+     enddo
+  endif
+
+  ndiskdat=1
+  mousebutton=0
+  close(10)
+
+999 call cs_unlock
+  return
+
+end subroutine getfile
+
+subroutine check_endian
+
+  parameter (NDMAX=120*11025)
+
+  integer*1 d1(NDMAX)
+  integer*1 hdr(44)
+  integer*2 d2(NDMAX)
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  integer*2 iswap_short
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
+  equivalence (ariff,hdr),(d1,d2)
+
+  if (nfmt2.eq.1) return             ! correct endianess for this CPU
+  write(*,1000)
+1000 format('Converting file to big-endian',i10)
+  lenfile = iswap_int(lenfile)
+  lenfmt = iswap_int(lenfmt)
+  nfmt2 = iswap_short(nfmt2)
+  nchan2 = iswap_short(nchan2)
+  nsamrate = iswap_int(nsamrate)
+  nbytesec = iswap_int(nbytesec)
+  nbytesam2 = iswap_short(nbytesam2)
+  nbitsam2 = iswap_short(nbitsam2)
+  ndata = iswap_int(ndata)
+  if (nbitsam2.eq.8) return           ! header converted.   Data are bytes
+
+  do i=1,ndata/2
+    d2(i) = iswap_short(d2(i))
+  enddo
+
+
+  return
+end subroutine check_endian
+
+integer function iswap_int(idat)
+
+  itemp1 = ior(ishft(idat,24), iand(ishft(idat,8), z'00ff0000'))
+  itemp0 = ior(iand(ishft(idat,-8), z'0000ff00'), iand(ishft(idat,-24),z'000000ff'))
+  iswap_int = ior(itemp1,itemp0)
+  
+end function iswap_int
+
+integer*2 function iswap_short(idat)
+
+  integer*2 idat,m2
+  data m2/255/
+
+  iswap_short = ior(ishft(idat,8), iand(ishft(idat,-8), m2))
+
+end function iswap_short

Deleted: wsjt7a/runqqq.F90
===================================================================
--- wsjt7a/runqqq.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/runqqq.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,41 +0,0 @@
-subroutine runqqq(fname,cmnd,iret)
-
-#ifdef CVF
-  use dflib
-#endif
-  integer system
-
-  character*(*) fname,cmnd
-
-  iret=ichar(fname(1:1)) + ichar(cmnd(1:1))    !Silence compiler warning
-#ifdef CVF
-  iret=runqq(fname,cmnd)
-#else
-  iret=system('KVASD_g95 -q &gt; dev_null')
-#endif
-
-  return
-end subroutine runqqq
-
-subroutine flushqqq(lu)
-
-#ifdef CVF
-  use dfport
-#endif
-
-  call flush(lu)
-
-  return
-end subroutine flushqqq
-
-subroutine sleepqqq(n)
-#ifdef CVF
-  use dflib
-      call sleepqq(n)
-#else
-      call usleep(n*1000)
-#endif
-
-  return
-
-end subroutine sleepqqq

Deleted: wsjt7a/savedata.F90
===================================================================
--- wsjt7a/savedata.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/savedata.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,162 +0,0 @@
-subroutine savedata
-
-#ifdef CVF
-  use dfport
-#endif
-
-  integer*1 n4
-  integer*2 iswap_short
-  character fname*24,longname*80
-  data ibuf0z/1/
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  equivalence (nfmt2,n4)
-  save
-
-  if(mode(1:4).eq.'JT65' .or.                                       &amp;
-       (mode(1:3).eq.'JT4' .and. mode(1:4).ne.'JT41')               &amp;
-       .or. mode(1:2).eq.'CW') then
-     call get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname0)
-     ibuf1=ibuf0
-     ibuf2=ibuf
-     go to 1
-  else
-     call get_fname(hiscall,iyr,imo,ida,ntime-trperiod,lauto,fname0)
-  endif
-
-  if(ibuf0.eq.ibuf0z) go to 999         !Startup condition, do not save
-  if(ntrbuf(ibuf0z).eq.1) go to 999     !We were transmitting, do not save
-
-! Get buffer pointers, then copy completed Rx sequence from y1 to d2a:
-  ibuf1=ibuf0z
-  ibuf2=ibuf0-1
-1 jza=2048*(ibuf2-ibuf1)
-  if(jza.lt.0) jza=jza+NRxMax
-  if(jza.lt.110250) go to 999           !Don't save files less than 10 s
-  if(jza.gt.120*11025) go to 999         !Don't save if something's fishy
-  k=2048*(ibuf1-1)
-  if(mode(1:4).ne.'JT65' .and.                                      &amp;
-       (mode(1:3).ne.'JT4' .or. mode(1:4).eq.'JT41')                &amp;
-       .and. mode(1:2).ne.'CW') k=k+3*2048
-  if(mode(1:4).ne.'JT65' .and.                                      &amp;
-       (mode(1:3).ne.'JT4' .or. mode(1:4).eq.'JT41')                &amp;
-       .and. mode(1:2).ne.'CW' .and. jza.gt.30*11025) then
-     k=k + (jza-30*11025)
-     if(k.gt.NRxMax) k=k-NRxMax
-     jza=30*11025
-  endif
-
-! Check timestamps of buffers used for this data
-  msbig=0
-  i=k/2048
-  if(msmax.eq.0) i=i+1
-  nz=jza/2048
-  if(msmax.eq.0) then
-     i=i+1
-     nz=nz-1
-  endif
-  do n=1,nz
-     i=i+1
-     if(i.gt.1024) i=i-1024
-     i0=i-1
-     if(i0.lt.1) i0=i0+1024
-     dtt=tbuf(i)-tbuf(i0)
-     ms=0
-     if(dtt.gt.0.d0 .and. dtt.lt.80000.0) ms=1000.d0*dtt
-     msbig=max(ms,msbig)
-  enddo
-
-  if(ndebug.gt.0 .and. msbig.gt.msmax .and. msbig.gt.330) then
-     call cs_lock('savedata')
-     write(*,1020) msbig
-1020 format('Warning: interrupt service interval',i11,' ms.')
-     call cs_unlock
-  endif
-  msmax=max(msbig,msmax)
-
-  do i=1,jza
-     k=k+1
-     if(k.gt.NRxMax) k=k-NRxMax
-     xx=dgain*y1(k)
-     xx=min(32767.0,max(-32767.0,xx))
-     d2a(i)=nint(xx)
-  enddo
-  fnamea=fname0
-
-  npingtime=0
-  fname=fnamea                   !Save filename for output to disk
-  nagain=0
-  ndecoding=1                    !Request decoding
-  
-! Generate file name and write data to file
-!    if(nsave.ge.2 .and. ichar(fname(1:1)).ne.0) then
-  if(ichar(fname(1:1)).ne.0) then
-
-! Generate header for wavefile:
-     ariff='RIFF'
-     awave='WAVE'
-     afmt='fmt '
-     adata='data'
-     lenfmt=16
-     nfmt2=1
-     nchan2=1
-     nsamrate=11025
-     nbytesam2=2
-     nbytesec=nchan2*nsamrate*nbytesam2
-     nbitsam2=16
-     ndata=2*jza
-     nbytes=ndata+44
-     nchunk=nbytes-8
-     
-     do i=80,1,-1
-        if(appdir(i:i).ne.' ') go to 10
-     enddo
-10   longname=AppDir(1:i)//'/RxWav/'//fname
-
-
-     call cs_lock('savedata')
-#ifdef CVF
-     open(17,file=longname,status='unknown',form='binary',err=20)
-     write(17) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
-          nbytesec,nbytesam2,nbitsam2,adata,ndata,(d2a(j),j=1,jza)
-     close(17)
-#else
-     open(17,file=longname,status='unknown',form='unformatted',      &amp;
-          access='direct',recl=nbytes,err=20)
-     if (n4.ne.nfmt2) then
-       nchunk = iswap_int(nchunk)
-       lenfmt = iswap_int(lenfmt)
-       nfmt2 = iswap_short(nfmt2)
-       nchan2 = iswap_short(nchan2)
-       nsamrate = iswap_int(nsamrate)
-       nbytesec = iswap_int(nbytesec)
-       nbytesam2 = iswap_short(nbytesam2)
-       nbitsam2 = iswap_short(nbitsam2)
-       ndata = iswap_int(ndata)
-       write(17,rec=1) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
-            nbytesec,nbytesam2,nbitsam2,adata,ndata,(iswap_short(d2a(j)),j=1,jza)
-     else
-       write(17,rec=1) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
-            nbytesec,nbytesam2,nbitsam2,adata,ndata,(d2a(j),j=1,jza)
-     endif
-     close(17)     
-#endif
-     filetokillb=filetokilla
-     filetokilla=longname
-     go to 30
-20   print*,'Error opening Fortran unit 17.'
-     print*,longname
-30   continue
-     call cs_unlock
-  endif
-
-999 if(mode(1:4).ne.'JT65' .and.                                          &amp;
-         (mode(1:3).ne.'JT4' .or. mode(1:4).eq.'JT41')                    &amp;
-         .and. mode(1:2).ne.'CW') then
-     ibuf0z=ibuf0
-     call get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname0)
-  endif
-
-  return
-end subroutine savedata

Copied: wsjt7a/savedata.f90 (from rev 1975, wsjt7a/savedata.F90)
===================================================================
--- wsjt7a/savedata.f90	                        (rev 0)
+++ wsjt7a/savedata.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,152 @@
+subroutine savedata
+
+  integer*1 n4
+  integer*2 iswap_short
+  character fname*24,longname*80
+  data ibuf0z/1/
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  equivalence (nfmt2,n4)
+  save
+
+  if(mode(1:4).eq.'JT65' .or.                                       &amp;
+       (mode(1:3).eq.'JT4' .and. mode(1:4).ne.'JT41')               &amp;
+       .or. mode(1:2).eq.'CW') then
+     call get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname0)
+     ibuf1=ibuf0
+     ibuf2=ibuf
+     go to 1
+  else
+     call get_fname(hiscall,iyr,imo,ida,ntime-trperiod,lauto,fname0)
+  endif
+
+  if(ibuf0.eq.ibuf0z) go to 999         !Startup condition, do not save
+  if(ntrbuf(ibuf0z).eq.1) go to 999     !We were transmitting, do not save
+
+! Get buffer pointers, then copy completed Rx sequence from y1 to d2a:
+  ibuf1=ibuf0z
+  ibuf2=ibuf0-1
+1 jza=2048*(ibuf2-ibuf1)
+  if(jza.lt.0) jza=jza+NRxMax
+  if(jza.lt.110250) go to 999           !Don't save files less than 10 s
+  if(jza.gt.120*11025) go to 999         !Don't save if something's fishy
+  k=2048*(ibuf1-1)
+  if(mode(1:4).ne.'JT65' .and.                                      &amp;
+       (mode(1:3).ne.'JT4' .or. mode(1:4).eq.'JT41')                &amp;
+       .and. mode(1:2).ne.'CW') k=k+3*2048
+  if(mode(1:4).ne.'JT65' .and.                                      &amp;
+       (mode(1:3).ne.'JT4' .or. mode(1:4).eq.'JT41')                &amp;
+       .and. mode(1:2).ne.'CW' .and. jza.gt.30*11025) then
+     k=k + (jza-30*11025)
+     if(k.gt.NRxMax) k=k-NRxMax
+     jza=30*11025
+  endif
+
+! Check timestamps of buffers used for this data
+  msbig=0
+  i=k/2048
+  if(msmax.eq.0) i=i+1
+  nz=jza/2048
+  if(msmax.eq.0) then
+     i=i+1
+     nz=nz-1
+  endif
+  do n=1,nz
+     i=i+1
+     if(i.gt.1024) i=i-1024
+     i0=i-1
+     if(i0.lt.1) i0=i0+1024
+     dtt=tbuf(i)-tbuf(i0)
+     ms=0
+     if(dtt.gt.0.d0 .and. dtt.lt.80000.0) ms=1000.d0*dtt
+     msbig=max(ms,msbig)
+  enddo
+
+  if(ndebug.gt.0 .and. msbig.gt.msmax .and. msbig.gt.330) then
+     call cs_lock('savedata')
+     write(*,1020) msbig
+1020 format('Warning: interrupt service interval',i11,' ms.')
+     call cs_unlock
+  endif
+  msmax=max(msbig,msmax)
+
+  do i=1,jza
+     k=k+1
+     if(k.gt.NRxMax) k=k-NRxMax
+     xx=dgain*y1(k)
+     xx=min(32767.0,max(-32767.0,xx))
+     d2a(i)=nint(xx)
+  enddo
+  fnamea=fname0
+
+  npingtime=0
+  fname=fnamea                   !Save filename for output to disk
+  nagain=0
+  ndecoding=1                    !Request decoding
+  
+! Generate file name and write data to file
+!    if(nsave.ge.2 .and. ichar(fname(1:1)).ne.0) then
+  if(ichar(fname(1:1)).ne.0) then
+
+! Generate header for wavefile:
+     ariff='RIFF'
+     awave='WAVE'
+     afmt='fmt '
+     adata='data'
+     lenfmt=16
+     nfmt2=1
+     nchan2=1
+     nsamrate=11025
+     nbytesam2=2
+     nbytesec=nchan2*nsamrate*nbytesam2
+     nbitsam2=16
+     ndata=2*jza
+     nbytes=ndata+44
+     nchunk=nbytes-8
+     
+     do i=80,1,-1
+        if(appdir(i:i).ne.' ') go to 10
+     enddo
+10   longname=AppDir(1:i)//'/RxWav/'//fname
+
+
+     call cs_lock('savedata')
+     open(17,file=longname,status='unknown',form='unformatted',      &amp;
+          access='direct',recl=nbytes,err=20)
+     if (n4.ne.nfmt2) then
+       nchunk = iswap_int(nchunk)
+       lenfmt = iswap_int(lenfmt)
+       nfmt2 = iswap_short(nfmt2)
+       nchan2 = iswap_short(nchan2)
+       nsamrate = iswap_int(nsamrate)
+       nbytesec = iswap_int(nbytesec)
+       nbytesam2 = iswap_short(nbytesam2)
+       nbitsam2 = iswap_short(nbitsam2)
+       ndata = iswap_int(ndata)
+       write(17,rec=1) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
+            nbytesec,nbytesam2,nbitsam2,adata,ndata,(iswap_short(d2a(j)),j=1,jza)
+     else
+       write(17,rec=1) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
+            nbytesec,nbytesam2,nbitsam2,adata,ndata,(d2a(j),j=1,jza)
+     endif
+     close(17)     
+
+     filetokillb=filetokilla
+     filetokilla=longname
+     go to 30
+20   print*,'Error opening Fortran unit 17.'
+     print*,longname
+30   continue
+     call cs_unlock
+  endif
+
+999 if(mode(1:4).ne.'JT65' .and.                                          &amp;
+         (mode(1:3).ne.'JT4' .or. mode(1:4).eq.'JT41')                    &amp;
+         .and. mode(1:2).ne.'CW') then
+     ibuf0z=ibuf0
+     call get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname0)
+  endif
+
+  return
+end subroutine savedata

Modified: wsjt7a/spec.f90
===================================================================
--- wsjt7a/spec.f90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/spec.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -57,8 +57,11 @@
   if(mode(1:4).eq.'Echo') nmode=3
   if(mode(1:4).eq.'JT6M') nmode=4
   if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:3).eq.'JT4') nmode=7
-  if(mode(1:4).eq.'JT41') nmode=9
+  if(mode(1:4).eq.'JT41') then
+     nmode=9
+  else if(mode(1:3).eq.'JT4') then
+     nmode=7
+  endif
 
   nlines=0
   newdat=0

Modified: wsjt7a/wsjt.py
===================================================================
--- wsjt7a/wsjt.py	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/wsjt.py	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,5 +1,5 @@
 #!/usr/bin/env python
-#----------------------------------------------------------------- WSJT
+#---------------------------------------------------------------- WSJT
 # $Date$ $Revision$
 #
 from Tkinter import *

Modified: wsjt7a/wsjt1.f90
===================================================================
--- wsjt7a/wsjt1.f90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/wsjt1.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -359,9 +359,9 @@
   
 900 LDecoded = ((NSyncOK.gt.0) .or. npkept.gt.0)
   endfile 11
-  call flushqqq(11)
-  call flushqqq(12)
-  call flushqqq(21)
+  call flush(11)
+  call flush(12)
+  call flush(21)
 
   return
 end subroutine wsjt1

Modified: wsjt7a/wsjt24.f
===================================================================
--- wsjt7a/wsjt24.f	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/wsjt24.f	2010-07-11 17:58:24 UTC (rev 1976)
@@ -167,7 +167,7 @@
       if(ave2(31:40).eq.'          ') ave2=ave2(:30)
       write(12,1011) ave1
       write(12,1011) ave2
-      call flushqqq(12)
+      call flush(12)
  
       if(lumsg.ne.6) end file 11
       call cs_unlock

Modified: wsjt7a/wsjt65.f
===================================================================
--- wsjt7a/wsjt65.f	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/wsjt65.f	2010-07-11 17:58:24 UTC (rev 1976)
@@ -206,7 +206,7 @@
       if(ave2(31:40).eq.'          ') ave2=ave2(:30)
       write(12,1011) ave1
       write(12,1011) ave2
-      call flushqqq(12)
+      call flush(12)
  
       if(lumsg.ne.6) end file 11
 

Deleted: wsjt7a/wsjtgen.F90
===================================================================
--- wsjt7a/wsjtgen.F90	2010-07-11 15:57:22 UTC (rev 1975)
+++ wsjt7a/wsjtgen.F90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -1,259 +0,0 @@
-subroutine wsjtgen
-
-! Compute the waveform to be transmitted.  
-
-! Input:    txmsg        message to be transmitted, up to 28 characters
-!           samfacout    fsample_out/11025.d0
-
-! Output:   iwave        waveform data, i*2 format
-!           nwave        number of samples
-!           sendingsh    0=normal; 1=shorthand; -1=plain text; 2=test file
-
-  parameter (NMSGMAX=28)             !Max characters per message
-  parameter (NSPD=25)                !Samples per dit
-  parameter (NDPC=3)                 !Dits per character
-  parameter (NWMAX=150*12000)        !Max length of Tx waveform
-  parameter (NTONES=4)               !Number of FSK tones
-
-  integer   itone(84)
-  character msg*28,msgsent*22,idmsg*22
-  real*8 freq,pha,dpha,twopi,dt
-  character testfile*27,tfile2*80
-  logical lcwid
-  integer*2 icwid(110250),jwave(NWMAX)
-
-  integer*1 hdr(44)
-  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-  character*4 ariff,awave,afmt,adata
-  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
-     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,jwave
-  equivalence (ariff,hdr)
-
-  data twopi/6.28318530718d0/
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  call cs_lock('wsjtgen')
-  fsample_out=11025.d0*samfacout
-  lcwid=.false.
-  if(idinterval.gt.0) then
-     n=(mod(int(tsec/60.d0),idinterval))
-     if(n.eq.(1-txfirst)) lcwid=.true.
-     if(idinterval.eq.1) lcwid=.true.
-  endif
-
-  msg=txmsg
-  ntxnow=ntxreq
-! Convert all letters to upper case
-  do i=1,28
-     if(msg(i:i).ge.'a' .and. msg(i:i).le.'z')                  &amp;
-          msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
-  enddo
-  txmsg=msg
-
-! Find message length
-  do i=NMSGMAX,1,-1
-     if(msg(i:i).ne.' ') go to 10
-  enddo
-  i=1
-10 nmsg=i
-  nmsg0=nmsg
-
-  if(msg(1:1).eq.'@') then
-     if(msg(2:2).eq.'/' .or. ichar(msg(2:2)).eq.92) then
-        txmsg=msg
-        testfile=msg(2:)
-#ifdef CVF
-        open(18,file=testfile,form='binary',status='old',err=12)
-        go to 14
-12      print*,'Cannot open test file ',msg(2:)
-        go to 999
-14      read(18) hdr
-        if(ndata.gt.NTxMax) ndata=NTxMax
-        call rfile(18,iwave,ndata,ierr)
-        close(18)
-        if(ierr.ne.0) print*,'Error reading test file ',msg(2:)
-
-#else
-        tfile2=testfile
-        call rfile2(tfile2,hdr,44+2*120*12000,nr)
-        if(nr.le.0) then
-           print*,'Error reading ',testfile
-           stop
-        endif
-        do i=1,ndata/2
-           iwave(i)=jwave(i)
-        enddo
-#endif
-        nwave=ndata/2
-        do i=nwave,NTXMAX
-           iwave(i)=0
-        enddo
-        sending=txmsg
-        sendingsh=2
-        go to 999
-     endif
-
-! Transmit a fixed tone at specified frequency
-     freq=1000.0
-     if(msg(2:2).eq.'A' .or. msg(2:2).eq.'a') freq=882
-     if(msg(2:2).eq.'B' .or. msg(2:2).eq.'b') freq=1323
-     if(msg(2:2).eq.'C' .or. msg(2:2).eq.'c') freq=1764
-     if(msg(2:2).eq.'D' .or. msg(2:2).eq.'d') freq=2205
-     if(freq.eq.1000.0) then
-        read(msg(2:),*,err=1) freq
-        goto 2
-1       txmsg='@1000'
-        nmsg=5
-        nmsg0=5
-     endif
-2    nwave=60*fsample_out
-     dpha=twopi*freq/fsample_out
-     do i=1,nwave
-        iwave(i)=32767.0*sin(i*dpha)
-     enddo
-     goto 900
-  endif
-
-  dt=1.d0/fsample_out
-  LTone=2
-
-  if(mode(1:4).eq.'JT65' .or.                                          &amp;
-       (mode(1:3).eq.'JT4' .and. mode(1:4).ne.'JT41')) then
-
-     if(mode(1:4).eq.'JT65') then
-!  We're in JT65 mode.
-        if(mode(5:5).eq.'A') mode65=1
-        if(mode(5:5).eq.'B') mode65=2
-        if(mode(5:5).eq.'C') mode65=4
-        call gen65(msg,mode65,samfacout,ntxdf,ndebug,iwave,nwave,sendingsh,   &amp;
-             msgsent,nmsg0)
-     else if(mode(1:4).eq.'JT41') then
-        call gen41(msg,nmsg,iwave,nwave,sendingsh,msgsent)
-     else if(mode(1:3).eq.'JT4' ) then
-        call gen24(msg,mode,mode4,samfacout,ntxdf,ndebug,iwave,nwave,      &amp;
-             sendingsh,msgsent,nmsg0)
-     else
-        stop 'Unknown Tx mode requested.'
-     endif
-
-     if(lcwid) then
-!  Generate and insert the CW ID.
-        wpm=25.
-        freqcw=800.
-        idmsg=MyCall//'          '
-        call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
-        k=nwave
-        do i=1,ncwid
-           k=k+1
-           iwave(k)=icwid(i)
-        enddo
-        do i=1,2205                   !Add 0.2 s of silence
-           k=k+1
-           iwave(k)=0
-        enddo
-        nwave=k
-     endif
-
-     goto 900
-  endif
-
-  if(mode(1:4).eq.'Echo') then
-!  We're in Echo mode.
-!     dither=AmpA
-!     call echogen(dither,wavefile,nbytes,f1)
-!     AmpB=f1
-     goto 900
-  endif
-
-  if(mode(1:4).eq.'JT6M') then
-!  We're in JT6M mode.
-     call gen6m(msg,samfacout,iwave,nwave)
-     goto 900
-  endif
-
-  if(mode(1:2).eq.'CW') then
-!  We're in CW mode
-!     wpm=15.
-     wpm=17.
-     freqcw=800.
-     call gencw(msg,wpm,freqcw,samfacout,iwave,nwave)
-     goto 900
-  endif
-
-!  We're in FSK441 mode.
-  if(nmsg.lt.28) nmsg=nmsg+1          !Add trailing blank if nmsg &lt; 28
-
-!  Check for shorthand messages
-  sendingsh = 0
-  if(shok.eq.1 .and. nmsg.le.4) then
-     if (msg(1:3).eq.'R26') then
-        msg='++'
-        nmsg=2
-        sendingsh = 1
-     else if (msg(1:3).eq.'R27') then
-        msg='**'
-        nmsg=2
-        sendingsh = 1
-     else if (msg(1:3).eq.'RRR') then
-        msg='%%'
-        nmsg=2
-        sendingsh = 1
-     else if (msg(1:2).eq.'73') then
-        msg='@@'
-        nmsg=2
-        sendingsh = 1
-     endif
-  endif
-  if(nmsg.eq.2) nmsg=nmsg+1000
-
-!  Encode the message
-  call abc441(msg,nmsg,itone,ndits)
-  ndata=ndits*nspd
-
-! Generate iwave
-  k=0
-  df=11025.0/NSPD
-  pha=0.
-  do m=1,ndits
-     freq=(LTone-1+itone(m))*df
-     dpha=twopi*freq*dt
-     do i=1,NSPD
-        k=k+1
-        pha=pha+dpha
-        iwave(k)=nint(32767.0*sin(pha))
-     enddo
-  enddo
-  nwave=k
-  
-900 sending=txmsg
-  if(mode(1:4).eq.'JT65' .and. sendingsh.ne.1) sending=msgsent
-  do i=NMSGMAX,1,-1
-     if(sending(i:i).ne.' '.and. ichar(sending(i:i)).ne.0) go to 910
-  enddo
-  i=1
-910 nmsg=i
-
-  if(lcwid .and. (mode.eq.'FSK441' .or. mode(1:4).eq.'JT6M')) then
-!  Generate and insert the CW ID.
-     wpm=25.
-     freqcw=440.
-     idmsg=MyCall//'          '
-     call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
-     k=0
-     do i=ncwid+1,int(trperiod*fsample_out)
-        k=k+1
-        if(k.gt.nwave) k=k-nwave
-        iwave(i)=iwave(k)
-     enddo
-     do i=1,ncwid
-        iwave(i)=icwid(i)
-     enddo
-     nwave=trperiod*fsample_out
-  endif
-
-999 continue
-  call cs_unlock
-  return
-end subroutine wsjtgen
-

Copied: wsjt7a/wsjtgen.f90 (from rev 1975, wsjt7a/wsjtgen.F90)
===================================================================
--- wsjt7a/wsjtgen.f90	                        (rev 0)
+++ wsjt7a/wsjtgen.f90	2010-07-11 17:58:24 UTC (rev 1976)
@@ -0,0 +1,247 @@
+subroutine wsjtgen
+
+! Compute the waveform to be transmitted.  
+
+! Input:    txmsg        message to be transmitted, up to 28 characters
+!           samfacout    fsample_out/11025.d0
+
+! Output:   iwave        waveform data, i*2 format
+!           nwave        number of samples
+!           sendingsh    0=normal; 1=shorthand; -1=plain text; 2=test file
+
+  parameter (NMSGMAX=28)             !Max characters per message
+  parameter (NSPD=25)                !Samples per dit
+  parameter (NDPC=3)                 !Dits per character
+  parameter (NWMAX=150*12000)        !Max length of Tx waveform
+  parameter (NTONES=4)               !Number of FSK tones
+
+  integer   itone(84)
+  character msg*28,msgsent*22,idmsg*22
+  real*8 freq,pha,dpha,twopi,dt
+  character testfile*27,tfile2*80
+  logical lcwid
+  integer*2 icwid(110250),jwave(NWMAX)
+
+  integer*1 hdr(44)
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,jwave
+  equivalence (ariff,hdr)
+
+  data twopi/6.28318530718d0/
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+
+  call cs_lock('wsjtgen')
+  fsample_out=11025.d0*samfacout
+  lcwid=.false.
+  if(idinterval.gt.0) then
+     n=(mod(int(tsec/60.d0),idinterval))
+     if(n.eq.(1-txfirst)) lcwid=.true.
+     if(idinterval.eq.1) lcwid=.true.
+  endif
+
+  msg=txmsg
+  ntxnow=ntxreq
+! Convert all letters to upper case
+  do i=1,28
+     if(msg(i:i).ge.'a' .and. msg(i:i).le.'z')                  &amp;
+          msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
+  enddo
+  txmsg=msg
+
+! Find message length
+  do i=NMSGMAX,1,-1
+     if(msg(i:i).ne.' ') go to 10
+  enddo
+  i=1
+10 nmsg=i
+  nmsg0=nmsg
+
+  if(msg(1:1).eq.'@') then
+     if(msg(2:2).eq.'/' .or. ichar(msg(2:2)).eq.92) then
+        txmsg=msg
+        testfile=msg(2:)
+        tfile2=testfile
+        call rfile2(tfile2,hdr,44+2*120*12000,nr)
+        if(nr.le.0) then
+           print*,'Error reading ',testfile
+           stop
+        endif
+        do i=1,ndata/2
+           iwave(i)=jwave(i)
+        enddo
+
+        nwave=ndata/2
+        do i=nwave,NTXMAX
+           iwave(i)=0
+        enddo
+        sending=txmsg
+        sendingsh=2
+        go to 999
+     endif
+
+! Transmit a fixed tone at specified frequency
+     freq=1000.0
+     if(msg(2:2).eq.'A' .or. msg(2:2).eq.'a') freq=882
+     if(msg(2:2).eq.'B' .or. msg(2:2).eq.'b') freq=1323
+     if(msg(2:2).eq.'C' .or. msg(2:2).eq.'c') freq=1764
+     if(msg(2:2).eq.'D' .or. msg(2:2).eq.'d') freq=2205
+     if(freq.eq.1000.0) then
+        read(msg(2:),*,err=1) freq
+        goto 2
+1       txmsg='@1000'
+        nmsg=5
+        nmsg0=5
+     endif
+2    nwave=60*fsample_out
+     dpha=twopi*freq/fsample_out
+     do i=1,nwave
+        iwave(i)=32767.0*sin(i*dpha)
+     enddo
+     goto 900
+  endif
+
+  dt=1.d0/fsample_out
+  LTone=2
+
+  if(mode(1:4).eq.'JT65' .or.                                          &amp;
+       (mode(1:3).eq.'JT4' .and. mode(1:4).ne.'JT41')) then
+
+     if(mode(1:4).eq.'JT65') then
+!  We're in JT65 mode.
+        if(mode(5:5).eq.'A') mode65=1
+        if(mode(5:5).eq.'B') mode65=2
+        if(mode(5:5).eq.'C') mode65=4
+        call gen65(msg,mode65,samfacout,ntxdf,ndebug,iwave,nwave,sendingsh,   &amp;
+             msgsent,nmsg0)
+     else if(mode(1:4).eq.'JT41') then
+        call gen41(msg,nmsg,iwave,nwave,sendingsh,msgsent)
+     else if(mode(1:3).eq.'JT4' ) then
+        call gen24(msg,mode,mode4,samfacout,ntxdf,ndebug,iwave,nwave,      &amp;
+             sendingsh,msgsent,nmsg0)
+     else
+        stop 'Unknown Tx mode requested.'
+     endif
+
+     if(lcwid) then
+!  Generate and insert the CW ID.
+        wpm=25.
+        freqcw=800.
+        idmsg=MyCall//'          '
+        call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
+        k=nwave
+        do i=1,ncwid
+           k=k+1
+           iwave(k)=icwid(i)
+        enddo
+        do i=1,2205                   !Add 0.2 s of silence
+           k=k+1
+           iwave(k)=0
+        enddo
+        nwave=k
+     endif
+
+     goto 900
+  endif
+
+  if(mode(1:4).eq.'Echo') then
+!  We're in Echo mode.
+!     dither=AmpA
+!     call echogen(dither,wavefile,nbytes,f1)
+!     AmpB=f1
+     goto 900
+  endif
+
+  if(mode(1:4).eq.'JT6M') then
+!  We're in JT6M mode.
+     call gen6m(msg,samfacout,iwave,nwave)
+     goto 900
+  endif
+
+  if(mode(1:2).eq.'CW') then
+!  We're in CW mode
+!     wpm=15.
+     wpm=17.
+     freqcw=800.
+     call gencw(msg,wpm,freqcw,samfacout,iwave,nwave)
+     goto 900
+  endif
+
+!  We're in FSK441 mode.
+  if(nmsg.lt.28) nmsg=nmsg+1          !Add trailing blank if nmsg &lt; 28
+
+!  Check for shorthand messages
+  sendingsh = 0
+  if(shok.eq.1 .and. nmsg.le.4) then
+     if (msg(1:3).eq.'R26') then
+        msg='++'
+        nmsg=2
+        sendingsh = 1
+     else if (msg(1:3).eq.'R27') then
+        msg='**'
+        nmsg=2
+        sendingsh = 1
+     else if (msg(1:3).eq.'RRR') then
+        msg='%%'
+        nmsg=2
+        sendingsh = 1
+     else if (msg(1:2).eq.'73') then
+        msg='@@'
+        nmsg=2
+        sendingsh = 1
+     endif
+  endif
+  if(nmsg.eq.2) nmsg=nmsg+1000
+
+!  Encode the message
+  call abc441(msg,nmsg,itone,ndits)
+  ndata=ndits*nspd
+
+! Generate iwave
+  k=0
+  df=11025.0/NSPD
+  pha=0.
+  do m=1,ndits
+     freq=(LTone-1+itone(m))*df
+     dpha=twopi*freq*dt
+     do i=1,NSPD
+        k=k+1
+        pha=pha+dpha
+        iwave(k)=nint(32767.0*sin(pha))
+     enddo
+  enddo
+  nwave=k
+  
+900 sending=txmsg
+  if(mode(1:4).eq.'JT65' .and. sendingsh.ne.1) sending=msgsent
+  do i=NMSGMAX,1,-1
+     if(sending(i:i).ne.' '.and. ichar(sending(i:i)).ne.0) go to 910
+  enddo
+  i=1
+910 nmsg=i
+
+  if(lcwid .and. (mode.eq.'FSK441' .or. mode(1:4).eq.'JT6M')) then
+!  Generate and insert the CW ID.
+     wpm=25.
+     freqcw=440.
+     idmsg=MyCall//'          '
+     call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
+     k=0
+     do i=ncwid+1,int(trperiod*fsample_out)
+        k=k+1
+        if(k.gt.nwave) k=k-nwave
+        iwave(i)=iwave(k)
+     enddo
+     do i=1,ncwid
+        iwave(i)=icwid(i)
+     enddo
+     nwave=trperiod*fsample_out
+  endif
+
+999 continue
+  call cs_unlock
+  return
+end subroutine wsjtgen
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001667.html">[WSJT-SVN] r1975 - wsjt7a
</A></li>
	<LI>Next message: <A HREF="001669.html">[WSJT-SVN] r1977 - wsjt7a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1668">[ date ]</a>
              <a href="thread.html#1668">[ thread ]</a>
              <a href="subject.html#1668">[ subject ]</a>
              <a href="author.html#1668">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
