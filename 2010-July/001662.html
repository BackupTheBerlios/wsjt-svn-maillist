<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r1970 - wsjt7a
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1970%20-%20wsjt7a&In-Reply-To=%3C20100709155745.A313C48026C%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001661.html">
   <LINK REL="Next"  HREF="001663.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r1970 - wsjt7a</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1970%20-%20wsjt7a&In-Reply-To=%3C20100709155745.A313C48026C%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r1970 - wsjt7a">k1jt at mail.berlios.de
       </A><BR>
    <I>Fri Jul  9 17:57:45 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001661.html">[WSJT-SVN] r1969 - wsjt7a
</A></li>
        <LI>Next message: <A HREF="001663.html">[WSJT-SVN] r1971 - wsjt7a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1662">[ date ]</a>
              <a href="thread.html#1662">[ thread ]</a>
              <a href="subject.html#1662">[ subject ]</a>
              <a href="author.html#1662">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2010-07-09 17:57:45 +0200 (Fri, 09 Jul 2010)
New Revision: 1970

Removed:
   wsjt7a/ccf2.f
   wsjt7a/decode162.f
   wsjt7a/fano232.f
   wsjt7a/fchisq.f
   wsjt7a/gen64.f90
   wsjt7a/genwspr.f90
   wsjt7a/mept162a.f
   wsjt7a/ps162.f
   wsjt7a/sync162.f
   wsjt7a/sync64.f
   wsjt7a/wqdecode.f90
   wsjt7a/wqencode.f90
   wsjt7a/wsjt64.f
   wsjt7a/wsjtwspr.f90
Modified:
   wsjt7a/astro0.F90
   wsjt7a/audio_init.F90
   wsjt7a/decode1.F90
   wsjt7a/decode2.f90
   wsjt7a/decode24.f
   wsjt7a/decode3.F90
   wsjt7a/fivehz.F90
   wsjt7a/gcom2.f90
   wsjt7a/gen24.f
   wsjt7a/genmet.f
   wsjt7a/pix2d65.f90
   wsjt7a/savedata.F90
   wsjt7a/spec.f90
   wsjt7a/sync24.f
   wsjt7a/wsjt.py
   wsjt7a/wsjt1.F
   wsjt7a/wsjt24.f
   wsjt7a/wsjtgen.F90
   wsjt7a/xcor24.f
Log:
Supposedly removed all JT2 and WSPR-mode stuff.  Changed JT64 to JT43,
but JT43 is not yet implemented.


Modified: wsjt7a/astro0.F90
===================================================================
--- wsjt7a/astro0.F90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/astro0.F90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -48,10 +48,8 @@
   if(mode(1:4).eq.'Echo') nmode=3
   if(mode(1:4).eq.'JT6M') nmode=4
   if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:3).eq.'JT2') nmode=6
   if(mode(1:3).eq.'JT4') nmode=7
-  if(mode(1:4).eq.'WSPR') nmode=8
-  if(mode(1:4).eq.'JT64') nmode=9
+  if(mode(1:4).eq.'JT43') nmode=9
   uth=uth8
   call cs_unlock
 

Modified: wsjt7a/audio_init.F90
===================================================================
--- wsjt7a/audio_init.F90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/audio_init.F90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -22,10 +22,8 @@
   if(mode(1:4).eq.'Echo') nmode=3
   if(mode(1:4).eq.'JT6M') nmode=4
   if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:3).eq.'JT2') nmode=6
   if(mode(1:3).eq.'JT4') nmode=7
-  if(mode(1:4).eq.'WSPR') nmode=8
-  if(mode(1:4).eq.'JT64') nmode=9
+  if(mode(1:4).eq.'JT43') nmode=9
 
   ndevin=ndin
   ndevout=ndout

Deleted: wsjt7a/ccf2.f
===================================================================
--- wsjt7a/ccf2.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/ccf2.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,64 +0,0 @@
-      subroutine ccf2(ss,nz,lag1,lag2,ccfbest,lagpk)
-
-      parameter (LAGMAX=200)
-      real ss(nz)
-      real ccf(-LAGMAX:LAGMAX)
-      real pr(162)
-      logical first
-
-C  The WSPR pseudo-random sync pattern:
-      integer npr(162)
-      data npr/
-     +       1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     +       0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     +       0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     +       1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     +       0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     +       0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     +       0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     +       0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     +       0,0/
-      data first/.true./
-      save first,pr,nsym
-
-      if(first) then
-         nsym=162
-         do i=1,nsym
-            pr(i)=2*npr(i)-1
-         enddo
-      endif
-
-      ccfbest=0.
-
-      do lag=lag1,lag2
-         x=0.
-         do i=1,nsym
-            j=16*i + lag
-            if(j.ge.1 .and. j.le.nz) x=x+ss(j)*pr(i)
-         enddo
-         ccf(lag)=x
-         if(x.gt.ccfbest) then
-            ccfbest=x
-            lagpk=lag
-         endif
-      enddo
-
-      sum=0.
-      nsum=0
-      do i=lag1,lag2
-         if(abs(i-lagpk).gt.16) then
-            sum=sum+ccf(i)
-            nsum=nsum+1
-         endif
-      enddo
-      ave=sum/nsum
-
-      sq=0.
-      do i=lag1,lag2
-         if(abs(i-lagpk).gt.16) sq=sq + (ccf(i)-ave)**2
-      enddo
-      rms=sqrt(sq/(nsum-1))
-      ccfbest=(ccfbest-ave)/rms
-
-      return
-      end

Modified: wsjt7a/decode1.F90
===================================================================
--- wsjt7a/decode1.F90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/decode1.F90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -25,9 +25,8 @@
   sendingsh0=-3
 
 10 ltrace=ndebug
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or. mode(1:3).eq.'JT4'  &amp;
-       .or. mode(1:2).eq.'CW' .or. mode(1:4).eq.'WSPR' .or.               &amp;
-       mode(1:4).eq.'JT64') then
+  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4'  &amp;
+       .or. mode(1:2).eq.'CW' .or. mode(1:4).eq.'JT64') then
      if(rxdone) then
         call savedata
         newdat2=1

Deleted: wsjt7a/decode162.f
===================================================================
--- wsjt7a/decode162.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/decode162.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,137 +0,0 @@
-      subroutine decode162(c4,npts,ndwspr,message,ncycles,metric,nerr)
-
-C  Decode MEPT_JT data, assuming that DT and DF have already been determined.
-
-      complex c4(npts)
-      character*22 message
-      real*8 dt,df,twopi,f0,f1,dphi0,dphi1
-      complex*16 c0,c1
-      complex*16 w0,w1,ws0,ws1
-      integer*1 symbol(162)
-      integer*1 data1(11)
-      integer amp
-      integer mettab(0:255,0:1)
-      integer npr3(162)
-      common/ccom/rr(162)
-      data npr3/
-     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     + 0,0/
-      data mettab/
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
-     +   2,   2,   2,   2,   1,   1,   1,   1,   0,   0,
-     +  -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,
-     +  -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,
-     + -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,
-     + -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,
-     + -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,
-     + -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,
-     + -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,
-     + -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,
-     + -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,
-     + -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,
-     + -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,
-     + -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,
-     + -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,
-     + -84, -87, -86, -87, -88, -89, -89, -89, -88, -87,
-     + -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,
-     + -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,
-     + -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,
-     + -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,
-     + -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,
-     + -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,
-     + -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,
-     + -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,
-     + -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,
-     + -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,
-     + -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,
-     + -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,
-     +  -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,
-     +  -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,
-     +   2,   2,   2,   2,   3,   3,   3,   3,   3,   3,
-     +   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5/
-
-      twopi=8*atan(1.d0)
-      dt=1.d0/375.d0            !Sample interval
-      df=375.d0/256.d0
-      nsym=162
-      nbits=50+31
-      amp=20                    !### 32 ??? ###
-      ndelta=50
-
-      limit=20000
-      if(ndwspr.eq.0) limit=10000
-C  Should amp be adjusted according to signal strength?
-C  Compute soft symbols
-      k=0
-      nsps=256
-      fac2=0.001
-      w0=1.0
-      w1=1.0
-
-      do j=1,nsym
-         f0=(npr3(j)-1.5)*df
-         f1=(2+npr3(j)-1.5)*df
-         dphi0=twopi*dt*f0
-         dphi1=twopi*dt*f1
-         ws0=dcmplx(cos(dphi0),-sin(dphi0))
-         ws1=dcmplx(cos(dphi1),-sin(dphi1))
-         c0=0.
-         c1=0.
-         do i=1,nsps
-            k=k+1
-            w0=w0*ws0
-            w1=w1*ws1
-            c0=c0 + w0*c4(k)
-            c1=c1 + w1*c4(k)
-         enddo
-
-         sq0=fac2*(real(c0)**2 + aimag(c0)**2)
-         sq1=fac2*(real(c1)**2 + aimag(c1)**2)
-         rsym=amp*(sq1-sq0)
-!         write(55,3003) j,rsym,rr(j)
-! 3003    format(i5,3f10.3)
-!         rsym=rr(j)
-
-         r=rsym+128.
-         if(r.gt.255.0) r=255.0
-         if(r.lt.0.0) r=0.0
-         i4=nint(r)
-         if(i4.gt.127) i4=i4-256
-         symbol(j)=i4
-      enddo
-
-      call inter_mept(symbol,-1)                      !Remove interleaving
-      call fano232(symbol,nbits,mettab,ndelta,limit,
-     +     data1,ncycles,metric,nerr)
-      message='                      '
-      if(nerr.ge.0) call wqdecode(data1,message,ntype2)
-
-      return
-      end

Modified: wsjt7a/decode2.f90
===================================================================
--- wsjt7a/decode2.f90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/decode2.f90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -85,7 +85,6 @@
         if(istart.lt.2) istart=2
         if(istart+jzz.gt.jzc) istart=jzc-jzz
      endif
-     if(mode(1:4).eq.'WSPR') newdat2=1
      call decode3(d2c(istart),jzz,istart,filename)
 
   else if(ndecoding.eq.5) then

Modified: wsjt7a/decode24.f
===================================================================
--- wsjt7a/decode24.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/decode24.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -53,85 +53,6 @@
       phi1=0.d0
       ang0=0.
 
-      if(mode.eq.6) then                   !JT2
-         nhmax=0
-         do idf=-20,20,2
-            c0=amp
-            k=istart
-            phi=0.d0
-            nh=0
-            do j=1,nsym+1
-               if(flip.gt.0.0) then
-                  f0=1270.46 + dfx + npr2(j)*df
-               else
-                  f0=1270.46 + dfx + (1-npr2(j))*df
-               endif
-               f0=f0 + 0.1*idf
-               dphi=twopi*dt*f0
-               c1=0.
-               do i=1,1260
-                  k=k+1
-                  phi=phi+dphi
-                  cz=dcmplx(cos(phi),-sin(phi))
-                  if(k.le.npts) c1=c1 + dat(k)*cz
-               enddo
-               rsym=amp*(real(c1)*real(c0) + aimag(c1)*aimag(c0))
-               ang=atan2(aimag(c1),real(c1))
-               ndang=nint(57.1957795131d0*(ang-ang0))
-               ang0=ang
-               if(ndang.le.-180) ndang=ndang+360
-               if(ndang.gt.180) ndang=ndang-360
-               if(ndang.lt.-90) ndang=ndang+180
-               if(ndang.gt. 90) ndang=ndang-180
-               if(rsym.ge.0.05 .and. abs(ndang).lt.20)nh=nh+1
-            enddo
-            if(nh.gt.nhmax) then
-               nhmax=nh
-               idfbest=idf
-            endif
-         enddo
-
-         c0=0
-         k=istart
-         phi=0.d0
-         do j=1,nsym+1
-            if(flip.gt.0.0) then
-               f0=1270.46 + dfx + npr2(j)*df
-            else
-               f0=1270.46 + dfx + (1-npr2(j))*df
-            endif
-            f0=f0 + 0.1*idfbest
-            dphi=twopi*dt*f0
-            c1=0.
-            do i=1,1260
-               k=k+1
-               phi=phi+dphi
-               cz=dcmplx(cos(phi),-sin(phi))
-               if(k.le.npts) c1=c1 + dat(k)*cz
-            enddo
-            c1=fac*c1
-            rsym=amp*(real(c1)*real(c0) + aimag(c1)*aimag(c0))
-
-C  NB: It may be possible to track phase.  In that case, remove the 
-C  average phase and then use:
-!            rsym=amp*real(c1)*real(c0)
-
-            ang=atan2(aimag(c1),real(c1))
-            ndang=nint(57.1957795131d0*(ang-ang0))
-            if(ndang.le.-180) ndang=ndang+360
-            if(ndang.gt.180) ndang=ndang-360
-            c0=c1
-            r=rsym+128.
-            if(r.gt.255.0) r=255.0
-            if(r.lt.0.0) r=0.0
-            i4=nint(r)
-            if(i4.gt.127) i4=i4-256
-            if(j.ge.1) symbol(j)=i4
-            ang0=ang
-         enddo
-         go to 50
-      endif
-
 ! JT4 mode
       ich=0
  40   ich=ich+1
@@ -189,23 +110,9 @@
       ncycles=0
       call interleave24(symbol(2),-1)         !Remove the interleaving
 
-C  This is a kludge:
-      iters=1
-      if(mode.eq.6) iters=2
-      do iter=1,iters
-         if(iter.eq.2) then
-            do i=2,207
-               i4=symbol(i)
-               if(i4.lt.0) i4=i4+256
-               i4=255-i4
-               if(i4.gt.127) i4=i4-256
-               symbol(i)=i4
-            enddo
-         endif
-         ncount=fano(metric,ncycles,data1,symbol(2),nbits,mettab,
-     +        delta,limit)
-         if(ncount.ge.0) go to 100
-      enddo
+      ncount=fano(metric,ncycles,data1,symbol(2),nbits,mettab,
+     +     delta,limit)
+      if(ncount.ge.0) go to 100
       if(mode.eq.7 .and. nchips.lt.mode4) go to 40
 
  100  do i=1,9

Modified: wsjt7a/decode3.F90
===================================================================
--- wsjt7a/decode3.F90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/decode3.F90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -26,7 +26,6 @@
   if(mode(1:4).eq.'Echo') nmode=3
   if(mode(1:4).eq.'JT6M') nmode=4
   if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:3).eq.'JT2') nmode=6
   if(mode(1:3).eq.'JT4') nmode=7
   if(mode(1:4).eq.'WSPR') nmode=8
   if(mode(1:4).eq.'JT64') nmode=9
@@ -85,7 +84,7 @@
   
   nclearave=0
   nagain=0
-  if(mode(1:4).eq.'JT65' .or. nmode.ge.6) then
+  if(mode(1:4).eq.'JT65') then
      call pix2d65(d2d,jz)
   else if(mode.eq.'FSK441') then
      nz=s2(1,1)

Deleted: wsjt7a/fano232.f
===================================================================
--- wsjt7a/fano232.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/fano232.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,159 +0,0 @@
-      subroutine fano232(symbol,nbits,mettab,ndelta,maxcycles,
-     +   dat,ncycles,metric,ierr)
-
-C  Sequential decoder for K=32, r=1/2 convolutional code using 
-C  the Fano algorithm.  Translated from C routine for same purpose
-C  written by Phil Karn, KA9Q.
-
-      parameter (MAXBITS=103)
-      parameter (MAXDAT=(MAXBITS+7)/8)
-      integer*1 symbol(0:2*MAXBITS-1)
-      integer*1 dat(MAXDAT)               !Decoded user data, 8 bits per byte
-      integer*1 i1
-      integer mettab(0:255,0:1)           !Metric table
-
-C  These were the &quot;node&quot; structure in Karn's C code:
-      integer nstate(0:MAXBITS-1)      !Encoder state of next node
-      integer gamma(0:MAXBITS-1)       !Cumulative metric to this node
-      integer metrics(0:3,0:MAXBITS-1) !Metrics indexed by all possible Tx syms
-      integer tm(0:1,0:MAXBITS-1)      !Sorted metrics for current hypotheses
-      integer ii(0:MAXBITS-1)          !Current branch being tested
-
-      logical noback
-      equivalence(i1,i4)
-      include 'conv232.f'
-
-      ntail=nbits-31
-
-C  Compute all possible branch metrics for each symbol pair.
-C  This is the only place we actually look at the raw input symbols
-      i4a=0
-      i4b=0
-      do np=0,nbits-1
-         j=2*np
-         i4a=symbol(j)
-         i4b=symbol(j+1)
-         if (i4a.lt.0) i4a=i4a+256
-         if (i4b.lt.0) i4b=i4b+256
-         metrics(0,np) = mettab(i4a,0) + mettab(i4b,0)
-         metrics(1,np) = mettab(i4a,0) + mettab(i4b,1)
-         metrics(2,np) = mettab(i4a,1) + mettab(i4b,0)
-         metrics(3,np) = mettab(i4a,1) + mettab(i4b,1)
-      enddo
-
-      np=0
-      nstate(np)=0
-
-C  Compute and sort branch metrics from the root node
-      n=iand(nstate(np),npoly1)
-      n=ieor(n,ishft(n,-16))
-      lsym=partab(iand(ieor(n,ishft(n,-8)),255))
-      n=iand(nstate(np),npoly2)
-      n=ieor(n,ishft(n,-16))
-      lsym=lsym+lsym+partab(iand(ieor(n,ishft(n,-8)),255))
-      m0=metrics(lsym,np)
-      m1=metrics(ieor(3,lsym),np)
-      if(m0.gt.m1) then
-         tm(0,np)=m0                      !0-branch has better metric
-         tm(1,np)=m1
-      else
-         tm(0,np)=m1                      !1-branch is better
-         tm(1,np)=m0
-         nstate(np)=nstate(np) + 1        !Set low bit
-      endif
-
-C  Start with best branch
-      ii(np)=0
-      gamma(np)=0
-      nt=0
-
-C  Start the Fano decoder
-      do i=1,nbits*maxcycles
-C  Look forward
-         ngamma=gamma(np) + tm(ii(np),np)
-         if(ngamma.ge.nt) then
-
-C  Node is acceptable.  If first time visiting this node, tighten threshold:
-            if(gamma(np).lt.(nt+ndelta)) nt=nt + 
-     +                            ndelta * ((ngamma-nt)/ndelta)
-
-C  Move forward
-            gamma(np+1)=ngamma
-            nstate(np+1)=ishft(nstate(np),1)
-            np=np+1
-            if(np.eq.nbits-1) go to 100     !We're done!
-
-            n=iand(nstate(np),npoly1)
-            n=ieor(n,ishft(n,-16))
-            lsym=partab(iand(ieor(n,ishft(n,-8)),255))
-            n=iand(nstate(np),npoly2)
-            n=ieor(n,ishft(n,-16))
-            lsym=lsym+lsym+partab(iand(ieor(n,ishft(n,-8)),255))
-            
-            if(np.ge.ntail) then
-               tm(0,np)=metrics(lsym,np)      !We're in the tail, all zeros
-            else
-               m0=metrics(lsym,np)
-               m1=metrics(ieor(3,lsym),np)
-               if(m0.gt.m1) then
-                  tm(0,np)=m0                 !0-branch has better metric
-                  tm(1,np)=m1
-               else
-                  tm(0,np)=m1                 !1-branch is better
-                  tm(1,np)=m0
-                  nstate(np)=nstate(np) + 1   !Set low bit
-               endif
-            endif
-
-            ii(np)=0                          !Start with best branch
-            go to 99
-         endif
-
-C  Threshold violated, can't go forward
- 10      noback=.false.
-         if(np.eq.0) noback=.true.
-         if(np.gt.0) then
-            if(gamma(np-1).lt.nt) noback=.true.
-         endif
-
-         if(noback) then
-C  Can't back up, either.  Relax threshold and look forward again 
-C  to a better branch.
-            nt=nt-ndelta
-            if(ii(np).ne.0) then
-               ii(np)=0
-               nstate(np)=ieor(nstate(np),1)
-            endif
-            go to 99
-         endif
-
-C  Back up
-         np=np-1
-         if(np.lt.ntail .and. ii(np).ne.1) then
-C  Search the next best branch
-            ii(np)=ii(np)+1
-            nstate(np)=ieor(nstate(np),1)
-            go to 99
-         endif
-         go to 10
- 99      continue
-      enddo
-      i=nbits*maxcycles
-
- 100  metric=gamma(np)                       !Final path metric
-
-C  Copy decoded data to user's buffer
-      nbytes=(nbits+7)/8
-      np=7
-      do j=1,nbytes-1
-         i4=nstate(np)
-         dat(j)=i1
-         np=np+8
-      enddo
-      dat(nbytes)=0
-      ncycles=i+1
-      ierr=0
-      if(i.ge.maxcycles*nbits) ierr=-1
-
-      return
-      end

Deleted: wsjt7a/fchisq.f
===================================================================
--- wsjt7a/fchisq.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/fchisq.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,101 +0,0 @@
-      real function fchisq(cx,npts,fsample,a,lag1,lag2,ccfmax,dtmax)
-
-      parameter (NMAX=120*375)
-      complex cx(npts)
-      real a(5)
-      complex*16 w1,ws1
-      complex*16 w2,ws2
-      complex*16 w3,ws3
-      complex*16 w4,ws4
-      complex*16 cs1(0:NMAX)
-      complex*16 cs2(0:NMAX)
-      complex*16 cs3(0:NMAX)
-      complex*16 cs4(0:NMAX)
-      complex z1,z2,z3,z4
-      real*8 twopi,baud,p2
-!      real ss(2812)
-      real ss(5624)
-
-      twopi=8.d0*atan(1.d0)
-      baud=12000.d0/8192
-
-C  Mix and integrate four channels
-      cs1(0)=0.
-      cs2(0)=0.
-      cs3(0)=0.
-      cs4(0)=0.
-      w1=1.0
-      w2=1.0
-      w3=1.0
-      w4=1.0
-      ws1=1.0
-      ws2=1.0
-      ws3=1.0
-      ws4=1.0
-      x0=0.5*(npts+1)           !Middle sample
-      s=2.0/npts
-      dt=1.0/fsample
-      do i=1,npts
-         x=s*(i-x0)             !x runs from -1 to +1
-         if(mod(i,100).eq.1) then
-            p2=1.5*x*x - 0.5
-!           p3=2.5*(x**3) - 1.5*x
-!           p4=4.375*(x**4) - 3.75*(x**2) + 0.375
-            dphi1=twopi*dt*(a(1) + x*a(2) + p2*a(3) - 1.5*baud)
-            dphi2=twopi*dt*(a(1) + x*a(2) + p2*a(3) - 0.5*baud)
-            dphi3=twopi*dt*(a(1) + x*a(2) + p2*a(3) + 0.5*baud)
-            dphi4=twopi*dt*(a(1) + x*a(2) + p2*a(3) + 1.5*baud)
-            ws1=cmplx(cos(dphi1),sin(dphi1))
-            ws2=cmplx(cos(dphi2),sin(dphi2))
-            ws3=cmplx(cos(dphi3),sin(dphi3))
-            ws4=cmplx(cos(dphi4),sin(dphi4))
-         endif
-         w1=w1*ws1
-         w2=w2*ws2
-         w3=w3*ws3
-         w4=w4*ws4
-         cs1(i)=cs1(i-1) + w1*cx(i)
-         cs2(i)=cs2(i-1) + w2*cx(i)
-         cs3(i)=cs3(i-1) + w3*cx(i)
-         cs4(i)=cs4(i-1) + w4*cx(i)
-      enddo
-
-C  Compute full-symbol powers at 1/16-symbol steps.
-      nsps=nint(fsample/baud)                  !Samples per symbol
-      ndiv=16                                  !Steps per symbol
-      nout=ndiv*npts/nsps                      !Total steps
-      dtstep=1.0/(ndiv*baud)                   !Time per output step
-      fac=1.e-5
-
-      ss=0.
-      do i=1,nout
-         j=i*nsps/ndiv
-         k=j - nsps
-         ss(i)=0.
-         if(k.ge.1) then
-            z1=cs1(j)-cs1(k)
-            z2=cs2(j)-cs2(k)
-            z3=cs3(j)-cs3(k)
-            z4=cs4(j)-cs4(k)
-
-            p1=real(z1)**2 + aimag(z1)**2
-            p2=real(z2)**2 + aimag(z2)**2
-            p3=real(z3)**2 + aimag(z3)**2
-            p4=real(z4)**2 + aimag(z4)**2
-
-!            ss(i)=fac*(max(p2,p4) - max(p1,p3))
-            ss(i)=fac*((p2+p4) - (p1+p3))
-         endif
-      enddo
-
-      ccfmax=0.
-      call ccf2(ss,nout,lag1,lag2,ccf,lagpk)
-      if(ccf.gt.ccfmax) then
-         ccfmax=ccf
-         dtmax=lagpk*dtstep
-      endif
-! Reverse sign (and offset!) because we will be minimizing fchisq
-      fchisq=-ccfmax + 100.0
-
-      return
-      end

Modified: wsjt7a/fivehz.F90
===================================================================
--- wsjt7a/fivehz.F90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/fivehz.F90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -74,14 +74,11 @@
   if(trperiod.le.0) trperiod=30
   tx1=0.0                              !Time to start a TX sequence
   tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or.                   &amp;
+  if(mode(1:4).eq.'JT65' .or.                   &amp;
        mode(1:3).eq.'JT4' .or. mode(1:4).eq.'JT64') then
      if(nwave.lt.126*4096) nwave=126*4096
      tx2=txdelay + nwave/11025.0
      if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
-  else if(mode(1:4).eq.'WSPR') then
-     tx2=txdelay + nwave/11025.0
-     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
   endif
 
   if(TxFirst.eq.0) then
@@ -159,7 +156,7 @@
   if(nbufs.lt.0) nbufs=nbufs+1024
   tdata=nbufs*2048.0/11025.0
 
-  if((mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or. mode(1:3).eq.'JT4' &amp;
+  if((mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4' &amp;
        .or. mode(1:2).eq.'CW' .or. mode(1:4).eq.'WSPR' .or.               &amp;
        mode(1:4).eq.'JT64') .and. monitoring.eq.1 &amp;
        .and. tdata.gt.float(ntdecode) .and. ibuf0.ne.ibuf00) then
@@ -167,24 +164,6 @@
      ibuf00=ibuf0
   endif
 
-! Diagnostic timing information:
-!  t60=mod(tsec,60.d0)
-!  if(TxOK.ne.TxOKz) then
-!     if(TxOK.eq.1) write(*,1101) 'D2:',t
-!1101 format(a3,f8.1,i8)
-!     if(TxOK.eq.0) then
-!        tstop=tsec
-!        write(*,1101) 'D3:',t,nc0a
-!     endif
-!  endif
-!  if(iptt.ne.iptt0) then
-!     if(iptt.eq.1) then
-!        tstart=tsec
-!        write(*,1101) 'D1:',t,nc1a
-!     endif
-!     if(iptt.eq.0) write(*,1101) 'D4:',t
-!  endif
-
   iptt0=iptt
   TxOKz=TxOK
   ntr0=ntr

Modified: wsjt7a/gcom2.f90
===================================================================
--- wsjt7a/gcom2.f90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/gcom2.f90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -33,7 +33,6 @@
 integer nsavecum       !(why is this here?)
 integer minsigdb       !Decoder threshold setting               GUI
 integer nclearave      !Set to 1 to clear JT65 avg         GUI,Decoder
-integer newdat2        !Set to 1 when new WSPR data           Decoder
 integer nfreeze        !Is Freeze checked?                      GUI
 integer nafc           !Is AFC checked?                         GUI
 integer nmode          !Which WSJT mode?                   GUI,Decoder
@@ -75,7 +74,6 @@
 integer ntxreq         !Tx msg# requested                       GUI
 integer ntxnow         !Tx msg# being sent now                  GUI
 integer ndepth         !Requested &quot;depth&quot; of JT65 decoding      GUI
-integer ndwspr         !Requested &quot;depth&quot; of WSPR decoding      GUI
 integer nspecial       !JT65 shorthand msg#: RO=2 RRR=3 73=4    Decoder
 integer ndf            !Measured DF in Hz                       Decoder
 real ss1               !Magenta curve for JT65 shorthand msg    Decoder
@@ -109,7 +107,7 @@
      mousedf,neme,nsked,naggressive,ntx2,nslim2,nagain,nsavelast,ntxdf, &amp;
      shok,sendingsh,d2a(ND2MAX),d2b(ND2MAX),b(60000),jza,jzb,ntime,   &amp;
      idinterval,msmax,lenappdir,idf,ndiskdat,nfsam,nlines,nflat,      &amp;
-     ntdecode,ntxreq,ntxnow,nchallenge,ndepth,ndwspr,nspecial,ndf,    &amp;
+     ntdecode,ntxreq,ntxnow,nchallenge,ndepth,nspecial,ndf,           &amp;
      nfmid,nforce,nfrange,ss1(-224:224),ss2(-224:224),                &amp;
      mycall,hiscall,hisgrid,txmsg,sending,mode,fname0,fnamea,         &amp;
      fnameb,decodedfile,AppDir,AzElDir,filetokilla,filetokillb,       &amp;

Modified: wsjt7a/gen24.f
===================================================================
--- wsjt7a/gen24.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/gen24.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -58,39 +58,19 @@
       j0=0
       ndata=(nsym*11025.d0*samfac*tsymbol)/2
       ndata=2*ndata
-      if(mode(1:3).eq.'JT2') then                 !JT2 mode
-         ss=1.0
-         s=0.0
-         u=0.04
-         do i=1,ndata
-            t=t+dt
-            j=int(t/tsymbol) + 1                  !Symbol number, 1-207
-            if(j.ne.j0) then
-               f=f0 + npr2(j)*dfgen
-               if(flip.lt.0.0) f=f0 + (1-npr2(j))*dfgen
-               dphi=twopi*dt*f
-               if(symbol(j).gt.0) ss=-ss
-               j0=j
-            endif
-            phi=phi+dphi
-            s=s + u*(ss-s)
-            iwave(i)=32767.0 * s * sin(phi)
-         enddo
-      else                                        !JT4x mode
-         do i=1,ndata
-            t=t+dt
-            j=int(t/tsymbol) + 1                  !Symbol number, 1-207
-            if(j.ne.j0) then
-               f=f0 + (npr2(j)+2*symbol(j)-1.5) * dfgen * mode4
-               if(flip.lt.0.0) 
-     +              f=f0+((1-npr2(j))+2*symbol(j)-1.5)*dfgen*mode4
-               dphi=twopi*dt*f
-               j0=j
-            endif
-            phi=phi+dphi
-            iwave(i)=32767.0*sin(phi)
-         enddo
-      endif
+      do i=1,ndata
+         t=t+dt
+         j=int(t/tsymbol) + 1   !Symbol number, 1-207
+         if(j.ne.j0) then
+            f=f0 + (npr2(j)+2*symbol(j)-1.5) * dfgen * mode4
+            if(flip.lt.0.0) 
+     +           f=f0+((1-npr2(j))+2*symbol(j)-1.5)*dfgen*mode4
+            dphi=twopi*dt*f
+            j0=j
+         endif
+         phi=phi+dphi
+         iwave(i)=32767.0*sin(phi)
+      enddo
 
       do j=1,5512                !Put another 0.5 sec of silence at end
          i=i+1

Deleted: wsjt7a/gen64.f90
===================================================================
--- wsjt7a/gen64.f90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/gen64.f90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,103 +0,0 @@
-subroutine gen64(message,mode64,samfac,ntxdf,iwave,nwave,  &amp;
-     sendingsh,msgsent,nmsg)
-
-! Encodes a JT64 message into a wavefile.
-
-  parameter (NMAX=60*11025)     !Max length of wave file
-  character*22 message          !Message to be generated
-  character*22 msgsent          !Message as it will be received
-  real*8 t,dt,phi,f,f0,dfgen,dphi,twopi,samfac,tsymbol
-  integer*2 iwave(NMAX)  !Generated wave file
-  integer sent(63)
-  integer sendingsh
-  integer ic6(6)
-  integer isync(63)
-  data ic6/0,1,4,3,5,2/,idum/-1/
-  data twopi/6.283185307d0/
-  save
-
-! Set up the JT64 sync pattern
-! Insert the 6x6 Costas array 3 times at low-frequency edge.
-  isync=-1
-  do n=1,3
-     i0=0
-     if(n.eq.2) i0=28
-     if(n.eq.3) i0=57
-     do i=1,6
-        isync(i0+i)=ic6(i)
-     enddo
-  enddo
-
-  nspecial=0
-  if(nspecial.eq.0) then
-!         call wqencode(message,ntype,data0)
-
-! Must do rs_init for RS(45,9)
-!         call rs_encode(dgen,sent)
-
-! Temporary: correct sync plus random data
-     do i=1,63
-        if(isync(i).lt.0) then
-           call random_number(x)
-           sent(i)=63.99999*x
-        else
-           sent(i)=isync(i)
-        endif
-     enddo
-
-     tsymbol=8192.d0/11025.d0
-     nsym=63                            !Symbols per transmission
-  else
-     tsymbol=16384.d0/11025.d0
-     nsym=32
-     sendingsh=1                         !Flag for shorthand message
-  endif
-
-! Set up necessary constants
-  dt=1.0/(samfac*11025.0)
-  f0=118*11025.d0/1024 + ntxdf
-  dfgen=mode64*11025.0/4096.0
-  t=0.d0
-  phi=0.d0
-  k=0
-  j0=0
-  ndata=(nsym*11025.d0*samfac*tsymbol)/2
-  ndata=2*ndata
-  do i=1,ndata
-     t=t+dt
-     j=int(t/tsymbol) + 1                    !Symbol number, 1-63
-     if(j.ne.j0) then
-        f=f0
-        if(nspecial.ne.0) f=f0+10*nspecial*dfgen
-        if(nspecial.eq.0) then
-           k=k+1
-           f=f0+(sent(k))*dfgen
-        endif
-        dphi=twopi*dt*f
-        j0=j
-     endif
-     phi=phi+dphi
-     iwave(i)=32767.0*sin(phi)
-  enddo
-
-  do j=1,5512                !Put another 0.5 sec of silence at end
-     i=i+1
-     iwave(i)=0
-  enddo
-  nwave=i
-!      call unpackmsg(dgen,msgsent)
-!      if(flip.lt.0.0) then
-!         do i=22,1,-1
-!            if(msgsent(i:i).ne.' ') goto 10
-!         enddo
-! 10      msgsent=msgsent(1:i)//' OOO'
-!      endif
-  msgsent=message
-  do i=22,1,-1
-     if(msgsent(i:i).ne.' ') goto 20
-  enddo
-20 nmsg=i
-
-  return
-end subroutine gen64
-

Modified: wsjt7a/genmet.f
===================================================================
--- wsjt7a/genmet.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/genmet.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -10,10 +10,7 @@
       call cs_lock('genmet')
       bias=0.5
       scale=10
-      if(mode.eq.6) then       !JT2, DBPSK
-         open(19,file='dmet_20_-2_2.dat',status='old')
-         scale=20
-      else if(mode.eq.7) then  !Non-coherent 2FSK
+      if(mode.eq.7) then  !Non-coherent 2FSK
          open(19,file='dmet_10_-1_3.dat',status='old')
       else
          print*,'Unsupported mode:',mode,' in genmet.'

Deleted: wsjt7a/genwspr.f90
===================================================================
--- wsjt7a/genwspr.f90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/genwspr.f90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,101 +0,0 @@
-subroutine genwspr(message,samfacout,ntxdf,iwave,nwave,nbad,msgsent)
-
-!  Encode a WSPR message and generate the corresponding wavefile.
-
-  parameter (NMAX=120*12000)     !Max length of wave file
-  parameter (MAXSYM=176)
-  character*22 message           !Message to be generated
-  integer*2 iwave(NMAX)          !Generated wave file
-  real*8 samfacout,fsample
-  integer*1 symbol(MAXSYM)
-  integer*1 data0(11)
-  integer npr3(162)
-  logical first
-  real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,tsymbol
-  character*22 msgsent           !Message sent
-  data npr3/                                    &amp;
-       1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0, &amp;
-       0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1, &amp;
-       0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1, &amp;
-       1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1, &amp;
-       0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0, &amp;
-       0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1, &amp;
-       0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1, &amp;
-       0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0, &amp;
-       0,0/
-
-  data first/.true./,idum/0/
-  save
-
-  if(first) then
-     pi=4.d0*atan(1.d0)
-     twopi=2.d0*pi
-     fsample=11025.d0
-     first=.false.
-  endif
-
-  call wqencode(message,ntype,data0)
-  nbytes=(50+31+7)/8
-  call encode232(data0,nbytes,symbol,MAXSYM)  !Convolutional encoding
-  call inter_mept(symbol,1)                   !Apply interleaving
-  call wqdecode(data0,msgsent,ntype2)
-  nbad=0
-  if(ntype2.ne.ntype .or. msgsent.ne.message) nbad=-1
-  if(ntype2.eq.ntype .and. index(msgsent,'&lt;...&gt;').gt.0) then
-     nbad=0
-     msgsent=message
-  endif
-
-  tsymbol=8192.d0/12000.d0
-  
-  dt=1.d0/(fsample*samfacout)
-  f0=1500 + ntxdf
-  dfgen=12000.d0/8192.d0                     !1.4649 Hz
-  nsigs=1
-  snrdb=99.
-  if(snrdb.eq.10.0) nsigs=10
-  nwave=111*fsample
-  if(snrdb.le.10.0) nwave=NMAX
-
-  do isig=1,nsigs
-     if(nsigs.eq.1) snr=10.0**(0.05*(snrdb-1))   !Bandwidth correction?
-     fac=3000.0
-     if(snr.gt.1.0) fac=3000.0/snr
-     if(nsigs.eq.10) then
-        snr=10.0**(0.05*(-20-isig-1))
-        f0=1390 + 20*isig
-     endif
-!     t=-2.d0 - 0.1*(isig-1)
-     t=-0.2d0
-     phi=0.d0
-     j0=0
-
-     do i=1,nwave
-        t=t+dt
-        j=int(t/tsymbol) + 1                          !Symbol number
-        sig=0.
-        if(j.ge.1 .and. j.le.162) then
-           if(j.ne.j0) then
-              f=f0 + dfgen*(npr3(j)+2*symbol(j)-1.5)
-              j0=j
-              dphi=twopi*dt*f
-           endif
-           sig=0.9999
-        endif
-        phi=phi+dphi
-        if(snrdb.gt.50.0) then
-           n=32767.0*sin(phi)           !Normal transmission, signal only
-        else
-           if(isig.eq.1) then
-              n=fac*(gran(idum) + sig*snr*sin(phi))
-           else
-              n=iwave(i) + fac*sig*snr*sin(phi)
-           endif
-           if(n.gt.32767) n=32767
-           if(n.lt.-32767) n=-32767
-        endif
-        iwave(i)=n
-     enddo
-  enddo
-  return
-end subroutine genwspr

Deleted: wsjt7a/mept162a.f
===================================================================
--- wsjt7a/mept162a.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/mept162a.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,106 +0,0 @@
-      subroutine mept162a(c2,jz,f0,cfile6,ndiag,minsync,mousedf,ndftol,
-     +    ndwspr,ccfblue,ccfred)
-
-C  Orchestrates the process of finding, synchronizing, and decoding 
-C  WSPR signals.
-
-      character*22 message
-      character*8 cfile6
-      real ccfblue(-5:540)
-      real ccfred(-224:224)
-      logical first
-      real ps(-256:256)
-      real sstf(5,275)
-      real a(5)
-      complex c2(jz)
-      complex c2a(0:65535)
-      complex c3(45000),c4(45000)
-      data first/.true./
-      save
-
-C  Mix 1500 Hz +/- 100 Hz to baseband, and downsample by 1/32
-!      call mix162(id,npts,c2,jz,ps)
-      c2a(0:jz-1)=c2
-      c2a(jz:)=0.
-      nfft0=65536
-      call four2a(c2a,65536,1,-1,1)
-      do k=-256,256
-         i=128*k
-         sq=0.
-         do n=-64,63
-            j=i+n
-            if(j.lt.0) j=j+nfft0
-            sq=sq + real(c2a(j))**2 + aimag(c2a(j))**2
-         enddo
-         ps(k)=1.e-8*sq
-      enddo
-
-C  Compute pixmap.dat
-!      call spec162(c2,jz)
-
-C  Look for sync patterns, get DF and DT
-      call sync162(c2,jz,mousedf,ndftol,ccfblue,ccfred,ps,sstf,kz)
-
-      idtmax=64
-      idtstep=1
-      if(ndwspr.eq.0) then
-         idtstep=8
-      endif
-      do k=1,kz
-         snrsync=sstf(1,k)
-         snrx=sstf(2,k)
-         dtx=sstf(3,k)
-         dfx=sstf(4,k)
-         drift=sstf(5,k)
-         ndf=nint(f0-1500.0+dfx)
-         a(1)=-dfx
-         a(2)=-0.5*drift
-         a(3)=0.
-         call twkfreq(c2,c3,jz,a)                    !Remove drift
-
-         nsync=nint(snrsync-4.0)
-         nsnrx=nint(snrx)
-         if(nsnrx.lt.-33) nsnrx=-33
-         if(nsync.lt.0) nsync=0
-         message='                      '
-         if(nsync.ge.minsync .and. nsnrx.ge.-30) then      !### -31 dB limit?
-            dt=1.0/375
-            do idt=0,idtmax,idtstep
-               do isign=-1,1,2
-                  ii=idt*isign
-                  i1=nint((dtx+2.0)/dt) + ii !Start index for synced symbols
-                  if(i1.ge.1) then
-                     c4(1:jz-i1+1)=c3(i1:jz)
-                     c4(jz-i1+2:)=0.
-                  else
-                     c4(:-i1+1)=0.
-                     jzz=min(jz,45000)
-                     c4(-i1+2:jzz)=c3(1:i1+jzz-1)
-                     if(jzz.lt.45000) c4(jzz:45000)=0.
-                  endif
-                  call decode162(c4,45000,ndwspr,message,ncycles,metric,
-     +                           nerr)
-                  if(message(1:6).ne.'      ' .and.
-     +               message(1:6).ne.'000AAA') go to 23
-               enddo
-            enddo
-
- 23         nf1=nint(-a(2))
-            if(ndiag.ne.0) then
-               call cs_lock('mept162a')
-               write(11,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message,
-     +              ii,ncycles/81
-               write(21,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message,
-     +              ii,ncycles/81
-            else
-               write(11,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message
-               write(21,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message
-            endif
- 1012       format(a6,i4,i4,f5.1,i6,i3,2x,a22,15x,i4,i6)
-            i1=index(message,' ')
-            call cs_unlock
-         endif
-      enddo
-
-      return
-      end

Modified: wsjt7a/pix2d65.f90
===================================================================
--- wsjt7a/pix2d65.f90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/pix2d65.f90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -11,7 +11,6 @@
   enddo
   nave=nint(sum/jz)
   nadd=nint(53.0*11025.0/500.0)
-  if(mode(1:4).eq.'WSPR') nadd=nint(114.0*11025.0/500.0)
   ngreen=min(jz/nadd,500)
   k=0
   do i=1,ngreen

Deleted: wsjt7a/ps162.f
===================================================================
--- wsjt7a/ps162.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/ps162.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,27 +0,0 @@
-      subroutine ps162(c2,s)
-
-      parameter (NFFT=512,NH=256)
-      complex c2(0:NFFT)
-      real s(-NH:NH)
-!      real work(2*NMAX)
-      complex c(0:NFFT)
-
-      do i=0,NH-1
-         c(i)=c2(i)
-      enddo
-      do i=nh,nfft-1
-         c(i)=0.
-      enddo
-
-      call four2a(c,nfft,1,-1,1)
-
-      fac=1.0/nfft
-      do i=0,NFFT-1
-         j=i
-         if(j.gt.NH) j=j-NFFT
-         s(j)=fac*(real(c(i))**2 + aimag(c(i))**2)
-      enddo
-      s(-NH)=s(-NH+1)
-
-      return
-      end

Modified: wsjt7a/savedata.F90
===================================================================
--- wsjt7a/savedata.F90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/savedata.F90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -14,9 +14,8 @@
   equivalence (nfmt2,n4)
   save
 
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or. mode(1:3).eq.'JT4'   &amp;
-       .or. mode(1:2).eq.'CW' .or. mode(1:4).eq.'WSPR' .or.                &amp;
-       mode(1:4).eq.'JT64') then
+  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4'   &amp;
+       .or. mode(1:2).eq.'CW' .or. mode(1:4).eq.'JT64') then
      call get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname0)
      ibuf1=ibuf0
      ibuf2=ibuf
@@ -36,11 +35,11 @@
   if(jza.lt.110250) go to 999           !Don't save files less than 10 s
   if(jza.gt.120*11025) go to 999         !Don't save if something's fishy
   k=2048*(ibuf1-1)
-  if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT2' .and. mode(1:3).ne.'JT4'   &amp;
-       .and. mode(1:4).ne.'WSPR' .and. mode(1:2).ne.'CW' .and.               &amp;
+  if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT4'   &amp;
+       .and. mode(1:2).ne.'CW' .and.               &amp;
        mode(1:4).ne.'JT64') k=k+3*2048
-  if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT2' .and. mode(1:3).ne.'JT4'   &amp;
-       .and. mode(1:4).ne.'WSPR' .and. mode(1:2).ne.'CW' .and.               &amp;
+  if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT4'   &amp;
+       .and. mode(1:2).ne.'CW' .and.               &amp;
        mode(1:4).ne.'JT64' .and. jza.gt.30*11025) then
      k=k + (jza-30*11025)
      if(k.gt.NRxMax) k=k-NRxMax
@@ -151,7 +150,7 @@
      call cs_unlock
   endif
 
-999 if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT2' .and. mode(1:3).ne.'JT2' &amp;
+999 if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT2' &amp;
          .and. mode(1:3).ne.'JT4' .and. mode(1:2).ne.'CW' .and.              &amp;
          mode(1:4).ne.'JT64') then
      ibuf0z=ibuf0

Modified: wsjt7a/spec.f90
===================================================================
--- wsjt7a/spec.f90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/spec.f90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -57,10 +57,8 @@
   if(mode(1:4).eq.'Echo') nmode=3
   if(mode(1:4).eq.'JT6M') nmode=4
   if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:3).eq.'JT2') nmode=6
   if(mode(1:3).eq.'JT4') nmode=7
-  if(mode(1:4).eq.'WSPR') nmode=8
-  if(mode(1:4).eq.'JT64') nmode=9
+  if(mode(1:4).eq.'JT43') nmode=9
 
   nlines=0
   newdat=0

Deleted: wsjt7a/sync162.f
===================================================================
--- wsjt7a/sync162.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/sync162.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,211 +0,0 @@
-      subroutine sync162(c2,jz,mousedf,ndftol,ccfblue,ccfred,ps,sstf,kz)
-
-C  Find WSPR sync signals, with best-fit DT and DF.  
-
-      complex c2(jz)
-      parameter (NFFT=512)             !Length of FFTs
-      parameter (NH=NFFT/2)            !Length of power spectra
-      parameter (NSMAX=351)            !Number of half-symbol steps
-      parameter (NF0=136,NF1=10)
-      parameter (LAGMAX=26)
-      real ccfblue(-5:540)
-      real ccfred(-224:224)
-      real psavg(-NH:NH)               !Average spectrum of whole record
-      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
-      real ps(-NH:NH)
-      real psmo(-NH:NH)
-      real freq(-NH:NH)
-      real p1(-NH:NH)
-      real drift(-NH:NH)
-      real dtx(-NH:NH)
-      integer keep0(-NH:NH)
-      integer keep(-NH:NH)
-      real a(5)
-      real sstf(5,275)
-      real tmp(275)
-      integer npr3(162)
-      real pr3(162)
-      data npr3/
-     +  1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     +  0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     +  0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     +  1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     +  0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     +  0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     +  0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     +  0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     +  0,0/
-      save
-
-      call zero(ccfblue,546)
-      call zero(ccfred,449)
-      nsym=162
-      do i=1,nsym
-         pr3(i)=2*npr3(i)-1
-      enddo
-      if(ndftol.eq.-999) go to 999            !Silence compiler warning
-
-C  Do FFTs of twice symbol length, stepped by half symbols.  
-      nq=NFFT/4
-      nsteps=jz/nq - 1
-      df=375.0/NFFT
-      dt=1.0/375.0
-      call zero(psavg,NFFT+1)
-
-C  Compute power spectrum for each step, and get average
-      do j=1,nsteps
-         k=(j-1)*nq + 1
-         call ps162(c2(k),s2(-NH,j))
-         call add(psavg,s2(-NH,j),psavg,NFFT)
-      enddo
-
-! Normalize and subtract baseline from psavg.
-      call pctile(psavg(-136),tmp,273,35,base)
-      psavg=psavg/base - 1.0
-      base=base/351.0
-      s2=s2/base - 1.0
-
-! Boxcar-smooth the average spectrum over the WSPR signal bandwidth.
-      do i=-NH+3,NH-3
-         psmo(i)=0.
-         do k=-3,3
-            psmo(i)=psmo(i)+ps(i+k)
-         enddo
-         psmo(i)=psmo(i)/7.0
-      enddo
-
-! Mark potential suspects for WSPR signals.  
-! (Keep only the best one within a surrounding range of +/- 8 bins.)
-
-      plimit=0.                      !### Are the plimit values OK? ###
-      i0=0
-      nfa=i0-nint(ndftol/df)
-      nfb=i0+nint(ndftol/df)
-!      do i=-NF0,NF0
-      do i=nfa,nfb
-         keep0(i)=0
-         keep(i)=0
-         ia=i-4
-         ib=i+4
-         pmax=-1.e30
-         do ii=ia,ib
-            if(psmo(ii).gt.pmax) then
-               ipk=ii
-               pmax=psmo(ii)
-            endif
-         enddo
-         if(ipk.eq.i .and. pmax.ge.plimit) then
-            keep0(i)=1
-! Kill all smaller peaks leading up to this maximum.
-            do ii=ia,i-1
-               keep0(ii)=0
-            enddo
-         endif
-      enddo
-
-! Now mark the bins +/- 1 from each one already marked.
-      do i=nfa+1,nfb-1
-         if(keep0(i).eq.1) then
-            keep(i-1)=1
-            keep(i)=1
-            keep(i+1)=1
-         endif
-      enddo
-
-! Now do the main search over DT, DF, and drift.  (Do CCFs in all marked
-! frequency bins and over a range of reasonable fdot values and lags.)
-      i00=nint(mousedf/df)
-      p1=0.
-      do i=nfa,nfb
-         if(keep(i).eq.0) go to 10
-         smax=0.
-         do k=-NF1,NF1
-            if(abs(k).ne.1) then
-               do lag=0,LAGMAX
-                  sum=0.
-                  n=lag-1
-                  do j=1,162
-                     n=n+2
-                     ii=i + nint(k*(j-81)/162.0)
-                     x=max(s2(ii-1,n),s2(ii+3,n)) - 
-     +                    max(s2(ii-3,n),s2(ii+1,n))
-                     sum=sum + x*pr3(j)
-                  enddo
-                  if(sum.gt.smax) then
-                     kpk=k
-                     lagpk=lag
-                     smax=sum
-                  endif
-               enddo
-            endif
-         enddo
-
-! Save the CCF value, frequency, drift rate, and DT.
-         p1(i)=smax
-         freq(i)=df*i
-         drift(i)=df*kpk
-         dtx(i)=128.0*dt*lagpk
-         spk=db(smax)-22.0
-         if(spk.gt.0.0 .and. abs(i+i00).le.224) ccfred(i+i00)=0.25*spk
- 10      continue
-      enddo
-
-! Eliminate potential duplicates and peaks smaller than plimit.
-      keep=0
-      plimit=10.0*plimit                             !### ??? ###
-      do i=nfa,nfb
-         ia=max(nfa,i-8)
-         ib=min(nfb,i+8)
-         pmax=-1.e30
-         do ii=ia,ib
-            if(p1(ii).gt.pmax) then
-               ipk=ii
-               pmax=p1(ii)
-            endif
-         enddo
-         if(ipk.eq.i .and. pmax.ge.plimit) then
-            keep(i)=1
-            do ii=ia,i-1
-               keep(ii)=0
-            enddo
-         endif
-      enddo
-
-! Compress the candidate list, saving only the potentially important ones.
-! Recalibrate sync indicator p1 on a dB scale.  
-! (NB: p1 sould be compared with snrx!)
-      k=0
-      do i=nfa,nfb
-         if(keep(i).ne.0) then
-            x=db(p1(i)) - 22       !### ??? ###
-            if(x.ge.0.5) then
-               k=k+1
-               p1(k)=x
-               freq(k)=freq(i)
-               drift(k)=drift(i)
-               dtx(k)=dtx(i) - 2.0
-            endif
-         endif
-      enddo
-      kz=k
-
-      do k=1,kz
-         a(1)=-freq(k) + 1.4648   !### Why is this offset necessary? ###
-         a(2)=-0.5*drift(k)
-         a(3)=0.
-         lagpk=nint((dtx(k)+2)/(128*dt))
-         lag1=-200
-         lag2=200
-         ccf=-fchisq(c2,jz,375.0,a,lag1,lag2,ccfbest,dtbest)
-         ipk=nint(freq(k)/df)
-         snrx=db(max(psavg(ipk),0.0001)) - 26.5         !Empirical
-         sstf(1,k)=ccfbest
-         sstf(2,k)=snrx
-         sstf(3,k)=dtbest-2.0
-         sstf(4,k)=freq(k)
-         sstf(5,k)=drift(k)
-      enddo
-      
- 999  return
-      end
-

Modified: wsjt7a/sync24.f
===================================================================
--- wsjt7a/sync24.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/sync24.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,7 +1,7 @@
       subroutine sync24(dat,jz,DFTolerance,NFreeze,MouseDF,
      +  mode,mode4,dtx,dfx,snrx,snrsync,ccfblue,ccfred1,flip,width)
 
-C  Synchronizes JT2 and JT4 data, finding the best-fit DT and DF.  
+C  Synchronizes JT4 data, finding the best-fit DT and DF.  
 
       parameter (NFFTMAX=2520)         !Max length of FFTs
       parameter (NHMAX=NFFTMAX/2)      !Max length of power spectra

Deleted: wsjt7a/sync64.f
===================================================================
--- wsjt7a/sync64.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/sync64.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,148 +0,0 @@
-      subroutine sync64(dat,jz,DFTolerance,NFreeze,MouseDF,
-     +  mode64,dtx,dfx,snrx,snrsync,ccfblue,ccfred1,flip,width)
-
-C  Synchronizes JT64 data, finding the best-fit DT and DF.  
-C  NB: at this stage, submodes ABC are processed in the same way.
-
-      parameter (NP2=30*11025)         !Size of data array
-      parameter (NFFTMAX=4096)         !Max length of FFTs
-      parameter (NHMAX=NFFTMAX/2)      !Max length of power spectra
-      parameter (NSMAX=160)            !Max number of half-symbol steps
-      integer DFTolerance              !Range of DF search
-      real dat(jz)
-      real psavg(NHMAX)                !Average spectrum of whole record
-      real s2(NHMAX,NSMAX)             !2d spectrum, stepped by half-symbols
-      real ccfblue(-5:540)             !CCF with pseudorandom sequence
-
-C  The value 450 is empirical:
-      real ccfred1(-224:224)           !Peak of ccfblue, as function of freq
-      real ccf64(-224:224)
-      integer ic6(6)
-      integer isync(63)
-      data ic6/0,1,4,3,5,2/,idum/-1/
-      save
-
-C  Do FFTs of symbol length, stepped by half symbols.  Note that we have
-C  already downsampled the data by factor of 2.
-      nsym=63
-      nfft=4096
-      nsteps=2*jz/nfft - 1
-      nh=nfft/2
-      df=0.5*11025.0/nfft
-! Set up the JT64 sync pattern
-      isync=-1
-      do n=1,3
-         i0=0
-         if(n.eq.2) i0=28
-         if(n.eq.3) i0=57
-         do i=1,6
-            isync(i0+i)=ic6(i)
-         enddo
-      enddo
-      nsync=18
-
-C  Compute power spectrum for each step and get average
-      call zero(psavg,nh)
-      do j=1,nsteps
-         k=(j-1)*nh + 1
-         call limit(dat(k),nfft)
-         call ps(dat(k),nfft,s2(1,j))
-         if(mode64.eq.4) call smooth(s2(1,j),nh)
-         call add(psavg,s2(1,j),psavg,nh)
-      enddo
-
-!      call flat1(psavg,s2,nh,nsteps,NHMAX,NSMAX)        !Flatten the spectra
-!      do i=1,nh
-!         write(42,4001) i*df,psavg(i)
-! 4001    format(2f10.3)
-!      enddo
-
-C  Find the best frequency channel for CCF
-      famin=3.
-      fbmax=2700.
-
-      fa=famin
-      fb=fbmax
-      if(NFreeze.eq.1) then
-         fa=max(famin,1270.46+MouseDF-DFTolerance)
-         fb=min(fbmax,1270.46+MouseDF+DFTolerance)
-      else
-         fa=max(famin,1270.46+MouseDF-600)
-         fb=min(fbmax,1270.46+MouseDF+600)
-      endif
-      ia=fa/df
-      ib=fb/df
-      i0=nint(1270.46/df)
-      syncbest=-1.e30
-      call zero(ccfred1,449)
-
-C### Following code probably needs work!
-      ss=0.
-      nss=0
-      do i=ia,ib
-         smax=-1.e30
-         do lag=-20,20
-            sum=0.
-            do j=1,nsym
-               if(isync(j).ge.0) then
-                  j0=2*j -1 + lag
-                  if(j0.ge.1 .and. j0.le.nsteps) then
-                     sum=sum + s2(2*isync(j)+i,j0)
-                  endif
-               endif
-            enddo
-            ccf64(lag)=sum/nsync
-            if(ccf64(lag).gt.smax) smax=ccf64(lag)
-         enddo
-         j=i-i0
-         if(abs(j).le.224) then
-            ccfred1(i-i0)=smax
-            ss=ss+smax
-            nss=nss+1
-         endif
-         if(smax.gt.syncbest) then
-            syncbest=smax
-            ipk=i
-         endif
-      enddo
-      ave=ss/nss
-      syncbest=syncbest-ave
-      do j=-224,224
-         if(ccfred1(j).ne.0.0) ccfred1(j)=0.2*(ccfred1(j)-ave)
-      enddo
-
-! Once more, at the best frequency
-      i=ipk
-      syncbest=-1.e30
-      rewind 41
-
-      dtstep=0.37151927
-      do lag=-20,20
-         sum=0.
-         do j=1,nsym
-            if(isync(j).ge.0) then
-               j0=2*j - 1 + lag
-               if(j0.ge.1 .and. j0.le.nsteps) then
-                  sum=sum + s2(2*isync(j)+i,j0)
-               endif
-            endif
-         enddo
-         ccf64(lag)=sum/nsync
-            if(ccf64(lag).gt.syncbest) then
-               lagpk=lag
-               syncbest=ccf64(lag)
-            endif
-!         write(41,3001) lag,dtstep*lag,ccf64(lag)
-! 3001    format(i5,2f10.3)
-         ccfblue(lag+15)=ccf64(lag)
-      enddo
-
-      snrsync=syncbest
-      snrx=-30
-      if(syncbest.gt.2.0) snrx=db(syncbest) - 34.0
-      dtx=dtstep*lagpk
-      dfx=(ipk-i0)*df
-
-      return
-      end
-

Deleted: wsjt7a/wqdecode.f90
===================================================================
--- wsjt7a/wqdecode.f90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/wqdecode.f90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,312 +0,0 @@
-subroutine wqdecode(data0,message,ntype)
-
-  parameter (N15=32768)
-  integer*1 data0(11)
-  character*22 message
-  character*12 callsign
-  character*3 cdbm,cf
-  character*2 crpt
-  character*4 grid
-  character*9 name
-  character*36 fmt
-  character*6 cwx(4)
-  character*7 cwind(5)
-  character ccur*4,cxp*2
-  logical first
-  character*12 dcall(0:N15-1)
-  data first/.true./
-  data cwx/'CLEAR','CLOUDY','RAIN','SNOW'/
-  data cwind/'CALM','BREEZES','WINDY','DRY','HUMID'/
-  save first,dcall
-
-  call cs_lock('wqdecode')
-  if(first) then
-     dcall='            '
-     first=.false.
-  endif
-
-  message='                      '
-  call unpack50(data0,n1,n2)
-  call unpackcall(n1,callsign)
-  i1=index(callsign,' ')
-  call unpackgrid(n2/128,grid)
-  ntype=iand(n2,127) -64
-
-! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
-  nu=mod(ntype,10)
-  if(ntype.ge.0 .and. ntype.le.60 .and. (nu.eq.0 .or. nu.eq.3 .or.   &amp;
-       nu.eq.7)) then
-     write(cdbm,'(i3)'),ntype
-     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-     message=callsign(1:i1)//grid//' '//cdbm
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1)
-
-! &quot;Best DX&quot; WSPR response (type 1)
-  else if(ntype.eq.1) then
-     message=grid//' DE '//callsign
-
-! CQ (msg 3; types 2,4,5)
-  else if(ntype.eq.2) then
-     message='CQ '//callsign(:i1)//grid
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1)
-  else if(ntype.eq.4 .or. ntype.eq.5) then
-     ng=n2/128 + 32768*(ntype-4)
-     call unpackpfx(ng,callsign)
-     message='CQ '//callsign
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1)
-
-! Reply to CQ (msg #2; type 6)
-  else if(ntype.eq.6) then
-     ih=(n2-64-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '//callsign(:i1-1)
-     else
-        message='&lt;...&gt; '//callsign
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Reply to CQ (msg #2; type 8)
-  else if(ntype.eq.8) then
-     message='DE '//callsign(:i1)//grid
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Reply to CQ, DE pfx/call (msg #2; types 9, 11)
-  else if(ntype.eq.9 .or. ntype.eq.11) then
-     ng=n2/128 + 32768*(ntype-9)/2
-     call unpackpfx(ng,callsign)
-     message='DE '//callsign
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and report (msg #3; types -1 to -9)
-  else if(ntype.le.-1 .and. ntype.ge.-9) then
-     write(crpt,1010) -ntype
-1010 format('S',i1)
-     ih=(n2-62-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; '//crpt
-     else
-        message=callsign(:i1)//'&lt;...&gt; '//crpt
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! pfx/call and report (msg #3; types -10 to -27)
-  else if(ntype.le.-10 .and. ntype.ge.-27) then
-     ng=n2/128
-     nrpt=-ntype-9
-     if(ntype.le.-19) then
-        ng=ng + 32768
-        nrpt=-ntype-18
-     endif
-     write(crpt,1010) nrpt
-     call unpackpfx(ng,callsign)
-     message=callsign//' '//crpt
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and R and report (msg #4; types -28 to -36)
-  else if(ntype.le.-28 .and. ntype.ge.-36) then
-     write(crpt,1010) -(ntype+27)
-     ih=(n2-64+28-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; '//'R '//crpt
-     else
-        message=callsign(:i1)//'&lt;...&gt; '//'R '//crpt
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! pfx/call R and report (msg #4; types -37 to -54)
-  else if(ntype.le.-37 .and. ntype.ge.-54) then
-     ng=n2/128
-     nrpt=-ntype-36
-     if(ntype.le.-46) then
-        ng=ng + 32768
-        nrpt=-ntype-45
-     endif
-     write(crpt,1010) nrpt
-     call unpackpfx(ng,callsign)
-     message=callsign//' R '//crpt
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and RRR (msg#5; type 12)
-  else if(ntype.eq.12) then
-     ih=(n2-64+28-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; RRR'
-     else
-        message=callsign(:i1)//'&lt;...&gt; RRR'
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and RRR (msg#5; type 14)
-  else if(ntype.eq.14) then
-     ih=(n2-64+28-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '//callsign(:i1)//'RRR'
-     else
-        message='&lt;...&gt; '//callsign(:i1)//' RRR'
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! DE pfx/call and RRR (msg#5; types 15, 16)
-  else if(ntype.eq.15 .or. ntype.eq.16) then
-     ng=n2/128 + 32768*(ntype-15)
-     call unpackpfx(ng,callsign)
-     message='DE '//callsign//' RRR'
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! TNX [name] 73 GL (msg #6; type 18)
-  else if(ntype.eq.18) then
-     ng=(n2-18-64)/128
-     call unpackname(n1,ng,name,len)
-     message='TNX '//name(:len)//' 73 GL'
-
-! OP [name] 73 GL (msg #6; type 18)
-  else if(ntype.eq.-56) then
-     ng=(n2+56-64)/128
-     call unpackname(n1,ng,name,len)
-     message='OP '//name(:len)//' 73 GL'
-
-! 73 DE [call] [grid] (msg #6; type 19)
-  else if(ntype.eq.19) then
-     ng=(n2-19-64)/128
-     message='73 DE '//callsign(:i1)//grid
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! 73 DE pfx/call (msg #6; type 21, 22)
-  else if(ntype.eq.21 .or. ntype.eq.22) then
-     ng=n2/128 + (ntype-21)*32768
-     call unpackpfx(ng,callsign)
-     i1=index(callsign,' ')
-     message='73 DE '//callsign
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! [power] W [gain] DBD 73 GL (msg#6; type 24, 25)
-  else if(ntype.eq.24 .or. ntype.eq.25) then
-     ng=(n2-24-64)/128 - 32
-     i1=1
-     if(n1.gt.0) i1=log10(float(n1)) + 1
-     i2=1
-     if(ng.ge.10) i2=2
-     if(ng.lt.0) i2=i2+1
-     if(n1.le.3000) then
-        if(ntype.eq.24) fmt=&quot;(i4,' W ',i2,' DBD 73 GL')&quot;
-        if(ntype.eq.25) fmt=&quot;(i4,' W ',i2,' DBD      ')&quot;
-        fmt(3:3)=char(48+i1)
-        fmt(12:12)=char(48+i2)
-        if(ng.le.100) then
-           write(message,fmt) n1,ng
-        else
-           if(ng.eq.30000) fmt=fmt(1:8)//&quot;DIPOLE')&quot;
-           if(ng.eq.30001) fmt=fmt(1:8)//&quot;VERTICAL')&quot;
-           write(message,fmt) n1
-        endif
-     else
-        mw=n1-3000
-        if(ntype.eq.24) fmt=&quot;('0.',i3.3,' W ',i2,' DBD 73 GL')&quot;
-        if(ntype.eq.25) fmt=&quot;('0.',i3.3,' W ',i2,' DBD      ')&quot;
-        fmt(19:19)=char(48+i2)
-        if(ng.le.100) then
-           write(message,fmt) mw,ng
-        else
-           if(ng.eq.30000) fmt=fmt(1:15)//&quot;DIPOLE')&quot;
-           if(ng.eq.30001) fmt=fmt(1:15)//&quot;VERTICAL')&quot;
-           write(message,fmt) n1
-        endif
-        if(index(message,'***').gt.0) go to 700
-     endif
-
-! QRZ call (msg #3; type 26)
-  else if(ntype.eq.26) then
-     ng=(n2-24-64)/128 - 32
-     message='QRZ '//callsign
-
-! PSE QSY [nnn] KHZ (msg #6; type 28)
-  else if(ntype.eq.28) then
-     if(n1.gt.0) i1=log10(float(n1)) + 1
-     fmt=&quot;('PSE QSY ',i2,' KHZ')&quot;
-     fmt(14:14)=char(48+i1)
-     write(message,fmt) n1        
-
-! WX wx temp C/F wind (msg #6; type 29)
-  else if(ntype.eq.29) then
-     nwx=n1/10000
-     ntemp=mod(n1,10000) - 100
-     cf=' F '
-     if(ntemp.gt.800) then
-        ntemp=ntemp-1000
-        cf=' C '
-     endif
-     write(message,1020) cwx(nwx),ntemp,cf,cwind(n2/128)
-1020 format('WX ',a6,i3,a3,a7)
-
-! Hexadecimal data (type 62)
-  else if(ntype.eq.62) then
-     ng=n2/128
-     write(message,'(z4.4,z7.7)') ng,n1
-     
-! Solar/geomagnetic/ionospheric data (type 63)
-  else if(ntype.eq.63) then
-     ih=(n2-64-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '
-     else
-        message='&lt;...&gt; '
-     endif
-     call unpackprop(n1,k,muf,ccur,cxp)
-     i2=index(message,'&gt;')
-     write(message(i2+1:),'(i3,i3)') k,muf
-     message=message(:i2+7)//ccur//' '//cxp
-     
-! [plain text] (msg #6; type -57)
-  else if(ntype.eq.-57) then
-     ng=n2/128
-     call unpacktext2(n1,ng,message)
-  else
-     go to 700
-  endif
-  go to 750
-
-!     message='&lt;Unknown message type&gt;'
-700 i1=index(callsign,' ')
-  if(i1.lt.1) i1=12
-  message=callsign(:i1)//' (BadMsg)'
-
-750 do i=1,22
-     if(ichar(message(i:i)).eq.0) message(i:i)=' '
-  enddo
-
-  do i=22,1,-1
-     if(message(i:i).ne.' ') go to 800
-  enddo
-800 i2=i
-  do n=1,20
-     i1=index(message(:i2),'  ')
-     if(i1.le.0) go to 900
-     message=message(1:i1)//message(i1+2:)
-     i2=i2-1
-  enddo
-
-900 call cs_unlock
-  return
-end subroutine wqdecode

Deleted: wsjt7a/wqencode.f90
===================================================================
--- wsjt7a/wqencode.f90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/wqencode.f90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,347 +0,0 @@
-subroutine wqencode(msg,ntype,data0)
-
-!  Parse and encode a WSPR message.
-
-  parameter (MASK15=32767)
-  character*22 msg
-  character*12 call1,call2
-  character*4 grid
-!  character*9 name
-  character ccur*4,cxp*2
-  logical lbad1,lbad2
-  integer*1 data0(11)
-  integer nu(0:9)
-  data nu/0,-1,1,0,-1,2,1,0,-1,1/
-
-  nwatts=0
-  i1=0
-  call cs_lock('wqencode')
-  read(msg,1001,end=1,err=1) ng,n1
-1001 format(z4,z7)
-  ntype=62
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)             !Pack 8 bits per byte, add tail
-  go to 900
-
-1  if(msg(1:6).eq.'73 DE ') go to 80
-  if(index(msg,' W ').gt.0 .and. index(msg,' DBD ').gt.0) go to 90
-  if(msg(1:4).eq.'QRZ ') go to 100
-  if(msg(1:8).eq.'PSE QSY ') go to 110
-  if(msg(1:3).eq.'WX ') go to 120
-
-! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
-  i1=index(msg,' ')
-  if(i1.lt.4 .or. i1.gt.7) go to 10
-  call1=msg(:i1-1)
-  grid=msg(i1+1:i1+4)
-  call packcall(call1,n1,lbad1)
-  call packgrid(grid,ng,lbad2)
-  if(lbad1 .or. lbad2) go to 10
-  ndbm=0
-  read(msg(i1+5:),*,err=10,end=800) ndbm
-  if(ndbm.lt.0 .or. ndbm.gt.60) go to 800
-  ndbm=ndbm+nu(mod(ndbm,10))
-  n2=128*ng + (ndbm+64)
-  call pack50(n1,n2,data0)
-  ntype=ndbm
-  go to 900
-
-! &quot;BestDX&quot; automated WSPR reply (type 1)
-10 if(i1.ne.5 .or. msg(5:8).ne.' DE ') go to 20
-  grid=msg(1:4)
-  call packgrid(grid,ng,lbad2)
-  if(lbad2) go to 800
-  call1=msg(9:)
-  call packcall(call1,n1,lbad1)
-  if(lbad1) go to 800
-  ntype=1
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)             !Pack 8 bits per byte, add tail
-  go to 900
-
-! CQ (msg #1; types 2, 4, 5)
-20  if(msg(1:3).ne.'CQ ') go to 30
-  if(index(msg,'/').le.0) then
-     i2=index(msg(4:),' ')
-     call1=msg(4:i2+3)
-     grid=msg(i2+4:)
-     call packcall(call1,n1,lbad1)
-     if(lbad1) go to 30
-     call packgrid(grid,ng,lbad2)
-     if(lbad2) go to 30
-     ntype=2
-     n2=128*ng + (ntype+64)
-     call pack50(n1,n2,data0)
-  else
-     ntype=4                                     ! or 5
-     call1=msg(4:)
-     call packpfx(call1,n1,ng,nadd)
-     ntype=ntype+nadd
-     n2=128*ng + ntype + 64
-     call pack50(n1,n2,data0)
-  endif
-  go to 900
-
-! Reply to CQ (msg #2; types 6,8,9,11)
-30 if(msg(1:1).ne.'&lt;' .and. msg(1:3).ne.'DE ') go to 40
-  if(index(msg,' RRR ').gt.0) go to 50
-  if(msg(1:1).eq.'&lt;') then
-     ntype=6
-     i1=index(msg,'&gt;')
-     call1=msg(2:i1-1)
-     read(msg(i1+1:),*,err=31,end=31) k,muf,ccur,cxp
-     go to 130
-31   call2=msg(i1+2:)
-     call hash(call1,i1-2,ih)
-     call packcall(call2,n1,lbad1)
-     n2=128*ih + (ntype+64)
-     call pack50(n1,n2,data0)
-  else
-     i1=index(msg(4:),' ')
-     call1=msg(4:i1+2)
-     if(index(msg,'/').le.0) then
-        ntype=8
-        ih=0
-        call packcall(call1,n1,lbad1)
-        grid=msg(i1+4:i1+7)
-        call packgrid(grid,ng,lbad2)
-        n2=128*ng + (ntype+64)
-        call pack50(n1,n2,data0)
-     else
-        ntype=9                                   ! or 11
-        call1=msg(4:)
-        call packpfx(call1,n1,ng,nadd)
-        ntype=ntype + 2*nadd
-        n2=128*ng + ntype + 64
-        call pack50(n1,n2,data0)
-     endif
-  endif
-  go to 900
-
-! Call(s) + report (msg #3; types -1 to -27)
-! Call(s) + R + report (msg #4; types -28 to -54)
-40 if(index(msg,' RRR').gt.0) go to 50
-  i1=index(msg,'&lt;')
-  if(i1.gt.0 .and. (i1.lt.5 .or. i1.gt.8)) go to 50
-  i2=index(msg,'/')
-  if(i2.gt.0 .and.i2.le.4) then
-     ntype=-10                                   ! -10 to -27
-     i0=index(msg,' ')
-     call1=msg(:i0-1)
-     call packpfx(call1,n1,ng,nadd)
-     ntype=ntype - 9*nadd
-     i2=index(msg,' ')
-     i3=index(msg,' R ')
-     if(i3.gt.0) i2=i2+2                            !-28 to -36
-     read(msg(i2+2:i2+2),*,end=800,err=800) nrpt
-     ntype=ntype - (nrpt-1)
-     if(i3.gt.0) ntype=ntype-27
-     n2=128*ng + ntype + 64
-     call pack50(n1,n2,data0)
-     go to 900
-  else if(i1.eq.0) then
-     go to 50
-  endif
-  call1=msg(:i1-2)                               !-1 to -9
-  i2=index(msg,'&gt;')
-  call2=msg(i1+1:i2-1)
-  call hash(call2,i2-i1-1,ih)
-  i3=index(msg,' R ')
-  if(i3.gt.0) i2=i2+2                            !-28 to -36
-  read(msg(i2+3:i2+3),*,end=42,err=42) nrpt
-  go to 43
-42 nrpt=1
-43 ntype=-nrpt
-  if(i3.gt.0) ntype=-(nrpt+27)
-  call packcall(call1,n1,lbad1)
-  n2=128*ih + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-50 i0=index(msg,'&lt;')
-  if(i0.le.0 .and. msg(1:3).ne.'DE ') go to 60
-  i3=index(msg,' RRR')
-  if(i3.le.0) go to 60
-! Call or calls and RRR (msg#5; type2 12,14,15,16)
-  i0=index(msg,'&lt;')
-  if(i0.eq.1) then
-     if(index(msg,'/').le.0) then
-        ntype=14
-        i1=index(msg,'&gt;')
-        call1=msg(2:i1-1)
-        call2=msg(i1+2:)
-        i2=index(call2,' ')
-        call2=call2(:i2-1)
-        call packcall(call2,n1,lbad1)
-        call hash(call1,i1-2,ih)
-        n2=128*ih + (ntype+64)
-        call pack50(n1,n2,data0)
-     else
-        stop '0002'
-     endif
-  else if(i0.ge.5 .and. i0.le.8) then
-     if(index(msg,'/').le.0) then
-        ntype=12
-        i1=index(msg,'&gt;')
-        call1=msg(:i0-2)
-        call2=msg(i0+1:i1-1)
-        call packcall(call1,n1,lbad1)
-        call hash(call2,i1-i0-1,ih)
-        n2=128*ih + (ntype+64)
-        call pack50(n1,n2,data0)
-     else
-        stop '0002'
-     endif
-  else
-     i1=index(msg(4:),' ')
-     call1=msg(4:i1+2)
-     if(index(msg,'/').le.0) then
-        ntype=9
-        grid=msg(i1+4:i1+7)
-     else
-        ntype=15                                   ! or 16
-        call1=msg(4:)
-        i0=index(call1,' ')
-        call1=call1(:i0-1)
-        call packpfx(call1,n1,ng,nadd)
-        ntype=ntype+nadd
-        n2=128*ng + ntype + 64
-        call pack50(n1,n2,data0)
-     endif
-  endif
-  go to 900
-
-! TNX &lt;name&gt; 73 GL (msg #6; type 18 ...)
-60 if(msg(1:4).ne.'TNX ') go to 70
-  ntype=18
-  n1=0
-  i2=index(msg(5:),' ')
-  call packname(msg(5:i2+4),i2-1,n1,ng)
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! TNX name 73 GL (msg #6; type -56 ...)
-70 if(msg(1:3).ne.'OP ') go to 80
-  ntype=-56
-  n1=0
-  i2=index(msg(4:),' ')
-  call packname(msg(4:i2+3),i2-1,n1,ng)
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! 73 DE call grid (msg #6; type 19)
-80 if(msg(1:6).ne.'73 DE ') go to 90
-  ntype=19
-  i1=index(msg(7:),' ')
-  call1=msg(7:)
-  if(index(call1,'/').le.0) then
-     i1=index(call1,' ')
-     grid=call1(i1+1:)
-     call1=call1(:i1-1)
-     call packcall(call1,n1,lbad1)
-     call packgrid(grid,ng,lbad2)
-     if(lbad1 .or. lbad2) go to 800
-     n2=128*ng + (ntype+64)
-     call pack50(n1,n2,data0)
-     go to 900
-  else
-     ntype=21                                   ! or 22
-     call packpfx(call1,n1,ng,nadd)
-     ntype=ntype + nadd
-     n2=128*ng + ntype + 64
-     call pack50(n1,n2,data0)
-     go to 900
-  endif
-
-! [pwr] W [gain] DBD [73 GL] (msg #6; types 24, 25)
-90  if(index(msg,' W ').le.0) go to 140
-  ntype=25
-  if(index(msg,' DBD 73 GL').gt.0) ntype=24
-  i1=index(msg,' ')
-  read(msg(:i1-1),*,end=800,err=800) watts
-  if(watts.ge.1.0) nwatts=watts
-  if(watts.lt.1.0) nwatts=3000 + nint(1000.*watts)
-  if(index(msg,'DIPOLE').gt.0) then
-     ndbd=30000
-  else if(index(msg,'VERTICAL').gt.0) then
-     ndbd=30001
-  else
-     i2=index(msg(i1+3:),' ')
-     read(msg(i1+3:i1+i2+1),*,end=800,err=800) ndbd
-  endif
-  n1=nwatts
-  ng=ndbd + 32
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! QRZ call (msg #3; type 26)
-100 call1=msg(5:)
-  call packcall(call1,n1,lbad1)
-  if(lbad1) go to 800
-  ntype=26
-  n2=ntype+64
-  call pack50(n1,n2,data0)
-  go to 900
-
-! PSE QSY [nnn] KHZ (msg #6; type 28)
-110 ntype=28
-  read(msg(9:),*,end=800,err=800) n1
-  n2=ntype+64
-  call pack50(n1,n2,data0)
-  go to 900
-
-! WX wx temp C|F wind (msg #6; type 29)
-120 ntype=29
-  if(index(msg,' CLEAR ').gt.0) then
-     i1=10
-     n1=10000
-  else if(index(msg,' CLOUDY ').gt.0) then
-     i1=11
-     n1=20000
-  else if(index(msg,' RAIN ').gt.0) then
-     i1=9
-     n1=30000
-  else if(index(msg,' SNOW ').gt.0) then
-     i1=9
-     n1=40000
-  endif
-  read(msg(i1:),*,err=800,end=800) ntemp
-  ntemp=ntemp+100
-  i1=index(msg,' C ')
-  if(i1.gt.0) ntemp=ntemp+1000
-  n1=n1+ntemp
-  if(index(msg,' CALM').gt.0) ng=1
-  if(index(msg,' BREEZES').gt.0) ng=2
-  if(index(msg,' WINDY').gt.0) ng=3
-  if(index(msg,' DRY').gt.0) ng=4
-  if(index(msg,' HUMID').gt.0) ng=5
-
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-
-  go to 900
-
-! Solar/geomagnetic/ionospheric data
-130 ntype=63
-  call packprop(k,muf,ccur,cxp,n1)
-  call hash(call1,i1-2,ih)
-  n2=128*ih + ntype + 64 
-  call pack50(n1,n2,data0)
-  go to 900
-
-140 continue
-
-! Plain text
-800 ntype=-57
-  call packtext2(msg(:8),n1,ng)
-  n2=128*ng + ntype + 64
-  call pack50(n1,n2,data0)
-  go to 900
-
-900 continue
-  call cs_unlock
-  return
-end subroutine wqencode

Modified: wsjt7a/wsjt.py
===================================================================
--- wsjt7a/wsjt.py	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/wsjt.py	2010-07-09 15:57:45 UTC (rev 1970)
@@ -193,9 +193,7 @@
     if textheight &lt;= 9:
         textheight=21
     else:
-        if mode.get()[:4]=='JT65' or \
-               mode.get()[:3]=='JT2' or mode.get()[:3]=='JT4' \
-               or mode.get()[:4]=='JT43':
+        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4':
             textheight=7
         else:
             textheight=9
@@ -235,8 +233,7 @@
 
 #------------------------------------------------------ dbl_click3_text
 def dbl_click3_text(event):
-    if mode.get()[:4]=='JT65' or \
-           mode.get()[:3]=='JT2' or mode.get()[:3]=='JT4' \
+    if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4' \
            or mode.get()[:4]=='JT43':
         t=text.get('1.0',END)           #Entire contents of text box
         t1=text.get('1.0',CURRENT)      #Contents from start to mouse pointer
@@ -270,7 +267,7 @@
         if setseq.get(): TxFirst.set((nsec/Audio.gcom1.trperiod)%2)
         lookup()
         GenStdMsgs()
-        if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
+        if (mode.get()[:4]=='JT65' or \
            mode.get()[:3]=='JT4') and rpt &lt;&gt; &quot;OOO&quot;:
             n=tx1.get().rfind(&quot; &quot;)
             t2=tx1.get()[0:n+1]
@@ -688,12 +685,6 @@
         GenStdMsgs()
         erase()
 
-#------------------------------------------------------ ModeJT2
-def ModeJT2():
-    global slabel,isync,isync65,textheight,itol
-    ModeJT65()
-    mode.set(&quot;JT2&quot;)
-
 #------------------------------------------------------ ModeJT4
 def ModeJT4():
     global slabel,isync,isync65,textheight,itol
@@ -777,9 +768,8 @@
   2. JT6M   - for meteor and ionospheric scatter on 50 MHz
   3. JT65   - for HF, EME, and troposcatter
   4. CW     - 15 WPM Morse code, messages structured for EME
-  5. JT2    - for HF and EME
-  6. JT4    - for HF and EME
-  7. JT43   - for meteor and ionospheric scatter on 50 MHz
+  5. JT4    - for HF and EME
+  6. JT43   - for meteor and ionospheric scatter on 50 MHz
 
 Copyright (c) 2001-2010 by Joseph H. Taylor, Jr., K1JT, with
 contributions from additional authors.  WSJT is Open Source 
@@ -969,7 +959,7 @@
         labHotAB.configure(text=&quot;&quot;,bg='gray85')
         labDist.configure(text=&quot;&quot;)
     else:
-        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
+        if mode.get()[:4]=='JT65' or \
                mode.get()[:3]=='JT4' or mode.get()[:2]==&quot;CW&quot; or \
                mode.get()[:4]=='JT43':
             labAz.configure(text=&quot;Az: %d&quot; % (naz,))
@@ -1077,7 +1067,6 @@
 def erase(event=NONE):
     graph1.delete(ALL)
     if mode.get()[:4]!=&quot;JT65&quot; and mode.get()[:2]!=&quot;CW&quot; and \
-            mode.get()[:3]!='JT2' and \
             mode.get()[:3]!='JT4' and mode.get()[:4]!='JT43':
         graph2.delete(ALL)
     text.configure(state=NORMAL)
@@ -1163,8 +1152,7 @@
 #----------------------------------------------------- dtdf_change
 # Readout of graphical cursor location
 def dtdf_change(event):
-    if mode.get()[:4]!='JT65' and mode.get()[:3]!='JT2' and \
-               mode.get()[:3]!='JT4' \
+    if mode.get()[:4]!='JT65' and mode.get()[:3]!='JT4' \
                and mode.get()[:4]!='JT43':
         t=&quot;%.1f&quot; % (event.x*30.0/500.0,)
         lab6.configure(text=t,bg='green')
@@ -1188,7 +1176,7 @@
 def mouse_click_g1(event):
     global nopen
     if not nopen:
-        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
+        if mode.get()[:4]=='JT65' or \
                mode.get()[:3]=='JT4' or mode.get()[:4]=='JT43':
             Audio.gcom2.mousedf=int(Audio.gcom2.idf+(event.x-250)*2.4)
         else:
@@ -1204,8 +1192,7 @@
 
 #------------------------------------------------------ double-click_g1
 def double_click_g1(event):
-    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-        mode.get()[:3]=='JT4' \
+    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4' \
         or mode.get()[:4]=='JT43') and Audio.gcom2.ndecoding==0:
         g.freeze_decode=1
     
@@ -1245,8 +1232,7 @@
         tx4.insert(0,setmsg(options.tx4.get(),r))
         tx5.insert(0,setmsg(options.tx5.get(),r))
         tx6.insert(0,setmsg(options.tx6.get(),r))
-    elif mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-               mode.get()[:3]=='JT4':
+    elif mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4':
         if options.MyCall.get()!= MyCall0 or \
                options.addpfx.get()!= addpfx0 or ToRadio.get()!=ToRadio0:
             MyCall0=options.MyCall.get()
@@ -1298,7 +1284,7 @@
     ToRadio.insert(0,t)
     if k2txb.get()!=0: ntx.set(1)
     Audio.gcom2.hiscall=(ToRadio.get()+(' '*12))[:12]
-    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
+    if (mode.get()[:4]=='JT65' or \
         mode.get()[:3]=='JT4') and ToRadio.get().find(&quot;/&quot;) == -1 and \
                options.MyCall.get().find(&quot;/&quot;) == -1:
         for m in (tx1, tx2, tx3, tx4, tx5, tx6):
@@ -1360,8 +1346,7 @@
             xy.append(n)
         graph1.create_line(xy,fill=&quot;green&quot;)
 
-        if Audio.gcom2.nspecial==0 or mode.get()[:3]=='JT2' or \
-                mode.get()[:3]=='JT4':
+        if Audio.gcom2.nspecial==0 or mode.get()[:3]=='JT4':
             y=[]
             for i in range(446):                #Find ymax for red curve
                 psavg=Audio.gcom2.psavg[i+1]
@@ -1373,7 +1358,7 @@
             fac=500.0/446.0
             for i in range(446):                #Make xy list for red curve
                 x=i*fac
-                if mode.get()[:3]=='JT2' or mode.get()[:3]=='JT4':
+                if mode.get()[:3]=='JT4':
                     x=i*500.0/548.571 + 47                      #empirical
                 psavg=Audio.gcom2.psavg[i+1]
                 n=int(90.0-yfac*psavg)
@@ -1428,7 +1413,7 @@
             fac=500.0/64.6
             for i in range(65):             #Make xy list for blue curve
                 x=(i+0.5)*fac
-                if mode.get()[:3]=='JT2' or mode.get()[:3]=='JT4':
+                if mode.get()[:3]=='JT4':
                     x=(i+0.5)*500.0/105.0 + 15     #15 is empirical
                 ccf=Audio.gcom2.ccf[i]
                 n=int(60.0-yfac*ccf)
@@ -1549,7 +1534,7 @@
             else:
                 Audio.gcom2.ntx2=0
 
-        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
+        if mode.get()[:4]=='JT65' or \
                mode.get()[:3]=='JT4' or mode.get()[:2]=='CW' or \
                mode.get()[:4]=='JT43':
             graph2.delete(ALL)
@@ -1559,8 +1544,7 @@
             graph2.create_text(13,85,anchor=W, text=&quot;Dop:%6d&quot; % g.ndop,font=g2font)
             graph2.create_text(13,109,anchor=W,text=&quot;Dgrd:%5.1f&quot; % g.Dgrd,font=g2font)
 
-    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-        mode.get()[:3]=='JT4' \
+    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4' \
         or mode.get()[:4]=='JT43') and g.freeze_decode:
         itol=2
         ltol.configure(text='Tol    '+str(50))
@@ -1603,8 +1587,6 @@
             msg2.configure(bg='#00FF00')
         elif mode.get()[:4]==&quot;JT43&quot;:
             msg2.configure(bg='#CCFFFF')
-        elif mode.get()==&quot;JT2&quot;:
-            msg2.configure(bg='#8888FF')
         elif mode.get()[:3]==&quot;JT4&quot;:
             msg2.configure(bg='#88FF88')
 #        elif mode.get()==&quot;Echo&quot;:
@@ -1735,7 +1717,7 @@
             im.putpalette(g.palette)
             cmap0=g.cmap
 
-        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
+        if mode.get()[:4]=='JT65' or \
                 mode.get()[:3]=='JT4' or mode.get()[:4]=='JT43':
             plot_large()
         else:    
@@ -1924,7 +1906,6 @@
     modemenu.add_radiobutton(label = 'JT65C', variable=mode, command = ModeJT65C,accelerator='Ctrl+F8')
     modemenu.add_radiobutton(label = 'CW', variable=mode, command = ModeCW,accelerator='Shift+Ctrl+F8')
 
-modemenu.add_radiobutton(label = 'JT2', variable=mode, command = ModeJT2)
 modemenu.add_radiobutton(label = 'JT4A', variable=mode, command = ModeJT4A)
 modemenu.add_radiobutton(label = 'JT4B', variable=mode, command = ModeJT4B)
 modemenu.add_radiobutton(label = 'JT4C', variable=mode, command = ModeJT4C)
@@ -2418,8 +2399,6 @@
                 ModeCW()
             elif value=='JT43':
                 ModeJT43()
-            elif value=='JT2':
-                ModeJT2()
             elif value[:3]=='JT4':
                 ModeJT4()
         elif key == 'MyCall': options.MyCall.set(value)

Modified: wsjt7a/wsjt1.F
===================================================================
--- wsjt7a/wsjt1.F	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/wsjt1.F	2010-07-09 15:57:45 UTC (rev 1970)
@@ -271,8 +271,8 @@
            go to 900
         endif
 
-!  If we're in JT2 or JT4 mode, call the decode24 routines.
-        if(mode.eq.6 .or. mode.eq.7) then
+!  If we're in JT4 mode, call the decode24 routines.
+        if(mode.eq.7) then
 !  Lowpass filter and decimate by 2
            call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
            idf=mousedf-mousedf2
@@ -299,51 +299,9 @@
            goto 900
         endif
 
-!  If we're in WSPR mode, call the wspr routines.
-        if(mode.eq.8) then
-           i=index(MyCall,char(0))
-           if(i.le.0) i=index(MyCall,' ')
-           mycall=MyCall(1:i-1)//'            '
-           call wsjtwspr(dat,jz,cfile6,ndiag,ccf,psavg)
-           ccf(-5)=-9999.0
-           goto 900
-        endif
-
 !  JT64 mode:
         if(mode.eq.9) then
-           mode64=1
-           nstest=0
-           if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
-     +        DFTolerance,mode64,nspecial,nstest,dfsh,iderrsh,
-     +        idriftsh,snrsh,ss1,ss2,nwsh,idfsh)
-!  Lowpass filter and decimate by 2
-           call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
-           idf=mousedf-mousedf2
-           jz=jz2
-           nadd=1
-           fzap(1)=0.
-           if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
-     +       DFTolerance,fzap)
-      if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
-
-           i=index(MyCall,char(0))
-           if(i.le.0) i=index(MyCall,' ')
-           mycall=MyCall(1:i-1)//'            '
-           i=index(HisCall,char(0))
-           if(i.le.0) i=index(HisCall,' ')
-           hiscall=HisCall(1:i-1)//'            '
-
-!  Offset data by about 1 s.
-!           jztest=126*2048
-           jztest=11025*ntdecode/2 - 2755
-           if(jz.ge.jztest) call wsjt64(dat(4097),jz-4096,cfile6,
-     +        NClearAve,MinSigdB,DFTolerance,NFreeze,NAFC,mode64,Nseg,
-     +        MouseDF2,NAgain,ndepth,nchallenge,neme,idf,idfsh,
-     +        mycall,hiscall,hisgrid,lumsg,lcum,nspecial,ndf,
-     +        nstest,dfsh,snrsh,
-     +        NSyncOK,ccf,psavg,ndiag,nwsh)
            goto 900
-
         endif
 
 !  We're in FSK441 mode. Compute the 2D spectrum.

Modified: wsjt7a/wsjt24.f
===================================================================
--- wsjt7a/wsjt24.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/wsjt24.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -2,7 +2,7 @@
      +  DFTolerance,NFreeze,mode,mode4,Nseg,MouseDF,NAgain,
      +  idf,lumsg,lcum,nspecial,ndf,NSyncOK,ccfblue,ccfred,ndiag)
 
-C  Orchestrates the process of decoding JT2 and JT4 messages, using 
+C  Orchestrates the process of decoding JT4 messages, using 
 C  data that have been 2x downsampled.  
 
       real dat(npts)                        !Raw data

Deleted: wsjt7a/wsjt64.f
===================================================================
--- wsjt7a/wsjt64.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/wsjt64.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,123 +0,0 @@
-      subroutine wsjt64(dat,npts,cfile6,NClearAve,MinSigdB,
-     +  DFTolerance,NFreeze,NAFC,mode64,Nseg,MouseDF,NAgain,
-     +  ndepth,nchallenge,neme,idf,idfsh,mycall,hiscall,hisgrid,
-     +  lumsg,lcum,nspecial,ndf,nstest,dfsh,
-     +  snrsh,NSyncOK,ccfblue,ccfred,ndiag,nwsh)
-
-C  Orchestrates the process of decoding JT64 messages, using data that
-C  have been 2x downsampled.  The search for shorthand messages has
-C  already been done.
-
-      real dat(npts)                        !Raw data
-      integer DFTolerance
-      logical first
-      logical lcum
-      character decoded*22,cfile6*6,special*5,cooo*3
-      character*22 deepmsg
-      character*67 ave1,ave2
-      character*1 csync
-      character*12 mycall
-      character*12 hiscall
-      character*6 hisgrid
-      real ccfblue(-5:540),ccfred(-224:224)
-      integer itf(2,9)
-      include 'avecom.h'
-      data first/.true./,ns10/0/,ns20/0/
-      data itf/0,0, 1,0, -1,0, 0,-1, 0,1, 1,-1, 1,1, -1,-1, -1,1/
-      save
-
-      if(first) then
-         nsave=0
-         first=.false.
-         ave1=' '
-         ave2=' '
-      endif
-
-      nspecial=0
-      nstest=0
-      naggressive=0
-      if(ndepth.ge.2) naggressive=1
-      nq1=3
-      nq2=6
-      if(naggressive.eq.1) nq1=1
-
-      if(NClearAve.ne.0) then
-         nsave=0                        !Clear the averaging accumulators
-         ns10=0
-         ns20=0
-         ave1=' '
-         ave2=' '
-      endif
-      if(MinSigdB.eq.99 .or. MinSigdB.eq.-99) then
-         ns10=0                         !For Include/Exclude ?
-         ns20=0
-      endif
-
-C  Attempt to synchronize: look for sync tone, get DF and DT.
-      call sync64(dat,npts,DFTolerance,NFreeze,MouseDF,
-     +    mode64,dtx,dfx,snrx,snrsync,ccfblue,ccfred,flip,width)
-      nsync=nint(snrsync-2.0)
-      if(nsync.lt.0) nsync=0
-      nsnr=nint(snrx)
-      jdf=nint(dfx)
-      write(11,1010) cfile6,nsync,nsnr,dtx-1.0,jdf
- 1010 format(a6,i3,i5,f5.1,i5,i3,1x,a1,1x,a5,a19,1x,a3,i4,i4)
-      write(21,1010) cfile6,nsync,nsnr,dtx-1.0,jdf
-
-      csync=' '
-      decoded='                      '
-      deepmsg='                      '
-      special='     '
-      cooo='   '
-      ncount=-1             !Flag for RS decode of current record
-      ncount1=-1            !Flag for RS Decode of ave1
-      ncount2=-1            !Flag for RS Decode of ave2
-      NSyncOK=0
-      nqual1=0
-      nqual2=0
-
-      if(nsave.lt.MAXAVE .and. (NAgain.eq.0 .or. NClearAve.eq.1)) 
-     +  nsave=nsave+1
-      if(nsave.le.0) go to 900          !Prevent bounds error
-
-      nflag(nsave)=0                    !Clear the &quot;good sync&quot; flag
-      iseg(nsave)=Nseg                  !Set the RX segment to 1 or 2
-      nsync=nint(snrsync-3.0)
-      nsnr=nint(snrx)
-      if(nsnr.lt.-30 .or. nsync.lt.0) nsync=0
-      nsnrlim=-32
-
-C  Good Sync takes precedence over a shorthand message:
-      if(nsync.ge.MinSigdB .and. nsnr.ge.nsnrlim .and.
-     +   nsync.ge.nstest) nstest=0
-
-      if(nstest.gt.0) then
-         dfx=dfsh
-         nsync=nstest
-         nsnr=snrsh
-         dtx=1.
-         ccfblue(-5)=-999.0
-         if(nspecial.eq.1) special='ATT  '
-         if(nspecial.eq.2) special='RO   '
-         if(nspecial.eq.3) special='RRR  '
-         if(nspecial.eq.4) special='73   '
-         NSyncOK=1              !Mark this RX file as good (for &quot;Save Decoded&quot;)
-         if(NFreeze.eq.0 .or. DFTolerance.ge.200) special(5:5)='?'
-         width=nwsh
-         idf=idfsh
-         go to 200
-      endif
-
-      if(nsync.lt.MinSigdB .or. nsnr.lt.nsnrlim) go to 200
-
-C  If we get here, we have achieved sync!
-
-C### From here onward, code from wsjt65.f was deleted.  Must restore
-C### and modify.
-
- 200  continue
-
- 900  continue
-
-      return
-      end

Modified: wsjt7a/wsjtgen.F90
===================================================================
--- wsjt7a/wsjtgen.F90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/wsjtgen.F90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -118,9 +118,8 @@
   dt=1.d0/fsample_out
   LTone=2
 
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or.                  &amp;
-       mode(1:3).eq.'JT4' .or. mode(1:4).eq.'WSPR' .or.                &amp;
-       mode(1:4).eq.'JT64') then
+  if(mode(1:4).eq.'JT65' .or.                                          &amp;
+       mode(1:3).eq.'JT4' .or. mode(1:4).eq.'JT64') then
 
      if(mode(1:4).eq.'JT65') then
 !  We're in JT65 mode.
@@ -129,17 +128,11 @@
         if(mode(5:5).eq.'C') mode65=4
         call gen65(msg,mode65,samfacout,ntxdf,ndebug,iwave,nwave,sendingsh,   &amp;
              msgsent,nmsg0)
-     else if(mode(1:4).eq.'WSPR') then
-        call cs_unlock                            !genwspr calls cs_lock
-        call genwspr(msg,samfacout,ntxdf,iwave,nwave,sendingsh,msgsent)
-        call cs_lock('wsjtgen')
-     else if(mode(1:3).eq.'JT2' .or. mode(1:3).eq.'JT4' ) then
+     else if(mode(1:3).eq.'JT4' ) then
         call gen24(msg,mode,mode4,samfacout,ntxdf,ndebug,iwave,nwave,      &amp;
              sendingsh,msgsent,nmsg0)
-     else if(mode(1:4).eq.'JT64') then
-        mode64=1
-        call gen64(msg,mode64,samfacout,ntxdf,iwave,nwave,sendingsh,   &amp;
-             msgsent,nmsg0)
+     else if(mode(1:4).eq.'JT43') then
+        continue
      else
         stop 'Unknown Tx mode requested.'
      endif
@@ -234,8 +227,8 @@
   nwave=k
   
 900 sending=txmsg
-  if((mode(1:4).eq.'JT65' .or. mode(1:4).eq.'JT64' .or. &amp;
-       mode(1:4).eq.'WSPR') .and. sendingsh.ne.1) sending=msgsent
+  if((mode(1:4).eq.'JT65' .or. mode(1:4).eq.'JT64') .and.              &amp;
+       sendingsh.ne.1) sending=msgsent
   do i=NMSGMAX,1,-1
      if(sending(i:i).ne.' '.and. ichar(sending(i:i)).ne.0) go to 910
   enddo

Deleted: wsjt7a/wsjtwspr.f90
===================================================================
--- wsjt7a/wsjtwspr.f90	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/wsjtwspr.f90	2010-07-09 15:57:45 UTC (rev 1970)
@@ -1,18 +0,0 @@
-subroutine wsjtwspr(dat,jz,cfile6,ndiag,ccfblue,ccfred)
-
-  real dat(jz)
-  real ccfblue(-5:540)
-  real ccfred(-224:224)
-  character cfile6*6
-  complex c2(45000)
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  f0=1500 + mousedf
-  if(nagain.eq.1) newdat2=0
-  if(nforce.eq.1) newdat2=1
-  call filbig2(dat,jz,f0,newdat2,c2,n4)
-  call mept162a(c2,n4,f0,cfile6,ndiag,minsigdb,mousedf,DFTolerance,ndwspr, &amp;
-       ccfblue,ccfred)
-  return
-end subroutine wsjtwspr

Modified: wsjt7a/xcor24.f
===================================================================
--- wsjt7a/xcor24.f	2010-07-09 14:53:33 UTC (rev 1969)
+++ wsjt7a/xcor24.f	2010-07-09 15:57:45 UTC (rev 1970)
@@ -35,34 +35,30 @@
       endif
 
       do j=1,nsteps
-         if(mode.eq.6) then
-            a(j)=s2(ipk+2,j) - s2(ipk,j)             !JT2
-         else                                        !JT4
-            n=2*mode4
-            if(mode4.eq.1) then
-               a(j)=max(s2(ipk+n,j),s2(ipk+3*n,j)) - 
-     +              max(s2(ipk  ,j),s2(ipk+2*n,j))
-            else
-               kz=mode4/2
-               ss0=0.
-               ss1=0.
-               ss2=0.
-               ss3=0.
-               wsum=0.
-               do k=-kz+1,kz-1
-                  w=float(kz-iabs(k))/mode4
-                  wsum=wsum+w
-                  if(ipk+k.lt.1 .or. ipk+3*n+k.gt.1260) then
-                     print*,'xcor24:',ipk,n,k
-                  else
-                     ss0=ss0 + w*s2(ipk    +k,j)
-                     ss1=ss1 + w*s2(ipk+  n+k,j)
-                     ss2=ss2 + w*s2(ipk+2*n+k,j)
-                     ss3=ss3 + w*s2(ipk+3*n+k,j)
-                  endif
-               enddo
-               a(j)=(max(ss1,ss3) - max(ss0,ss2))/sqrt(wsum)
-            endif
+         n=2*mode4
+         if(mode4.eq.1) then
+            a(j)=max(s2(ipk+n,j),s2(ipk+3*n,j)) - 
+     +           max(s2(ipk  ,j),s2(ipk+2*n,j))
+         else
+            kz=mode4/2
+            ss0=0.
+            ss1=0.
+            ss2=0.
+            ss3=0.
+            wsum=0.
+            do k=-kz+1,kz-1
+               w=float(kz-iabs(k))/mode4
+               wsum=wsum+w
+               if(ipk+k.lt.1 .or. ipk+3*n+k.gt.1260) then
+                  print*,'xcor24:',ipk,n,k
+               else
+                  ss0=ss0 + w*s2(ipk    +k,j)
+                  ss1=ss1 + w*s2(ipk+  n+k,j)
+                  ss2=ss2 + w*s2(ipk+2*n+k,j)
+                  ss3=ss3 + w*s2(ipk+3*n+k,j)
+               endif
+            enddo
+            a(j)=(max(ss1,ss3) - max(ss0,ss2))/sqrt(wsum)
          endif
       enddo
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001661.html">[WSJT-SVN] r1969 - wsjt7a
</A></li>
	<LI>Next message: <A HREF="001663.html">[WSJT-SVN] r1971 - wsjt7a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1662">[ date ]</a>
              <a href="thread.html#1662">[ thread ]</a>
              <a href="subject.html#1662">[ subject ]</a>
              <a href="author.html#1662">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
