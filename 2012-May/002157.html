<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2464 - in branches/map65: . libm65
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2012-May/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2464%20-%20in%20branches/map65%3A%20.%20libm65&In-Reply-To=%3C20120522170952.39C0EBF401%40scm.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002155.html">
   <LINK REL="Next"  HREF="002156.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2464 - in branches/map65: . libm65</H1>
    <B>k1jt at scm.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2464%20-%20in%20branches/map65%3A%20.%20libm65&In-Reply-To=%3C20120522170952.39C0EBF401%40scm.berlios.de%3E"
       TITLE="[WSJT-SVN] r2464 - in branches/map65: . libm65">k1jt at scm.berlios.de
       </A><BR>
    <I>Tue May 22 19:09:51 CEST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="002155.html">[WSJT-SVN] r2463 - branches/map65
</A></li>
        <LI>Next message: <A HREF="002156.html">[WSJT-SVN] r2465 - branches/map65
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2157">[ date ]</a>
              <a href="thread.html#2157">[ thread ]</a>
              <a href="subject.html#2157">[ subject ]</a>
              <a href="author.html#2157">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2012-05-22 19:09:48 +0200 (Tue, 22 May 2012)
New Revision: 2464

Modified:
   branches/map65/about.cpp
   branches/map65/about.h
   branches/map65/astro.cpp
   branches/map65/astro.h
   branches/map65/bandmap.cpp
   branches/map65/bandmap.h
   branches/map65/commons.h
   branches/map65/devsetup.cpp
   branches/map65/devsetup.h
   branches/map65/displaytext.cpp
   branches/map65/displaytext.h
   branches/map65/ffft.f
   branches/map65/fftw3.f
   branches/map65/getdev.cpp
   branches/map65/getfile.cpp
   branches/map65/getfile.h
   branches/map65/killbyname.cpp
   branches/map65/libm65/JT65code.f90
   branches/map65/libm65/Makefile.MinGW
   branches/map65/libm65/Makefile.linux
   branches/map65/libm65/afc65b.f
   branches/map65/libm65/astro.f
   branches/map65/libm65/astro0.f90
   branches/map65/libm65/astrosub.f90
   branches/map65/libm65/ccf2.f
   branches/map65/libm65/ccf65.f90
   branches/map65/libm65/chkhist.f
   branches/map65/libm65/chkmsg.f
   branches/map65/libm65/coord.f
   branches/map65/libm65/cutil.c
   branches/map65/libm65/dcoord.f
   branches/map65/libm65/decode0.f90
   branches/map65/libm65/decode1a.f
   branches/map65/libm65/decode65b.f
   branches/map65/libm65/decode_rs.c
   branches/map65/libm65/deep65.f90
   branches/map65/libm65/deg2grid.f
   branches/map65/libm65/demod64a.f
   branches/map65/libm65/display.f90
   branches/map65/libm65/dot.f
   branches/map65/libm65/dpol.f90
   branches/map65/libm65/encode65.f
   branches/map65/libm65/encode_rs.c
   branches/map65/libm65/extract.F
   branches/map65/libm65/f77_wisdom.f
   branches/map65/libm65/fchisq.f
   branches/map65/libm65/fftw3.f
   branches/map65/libm65/fil6521.f
   branches/map65/libm65/filbig.f
   branches/map65/libm65/four2a.f90
   branches/map65/libm65/ftninit.f90
   branches/map65/libm65/ftnquit.f90
   branches/map65/libm65/gen65.f90
   branches/map65/libm65/geocentric.f
   branches/map65/libm65/getdphi.f90
   branches/map65/libm65/getpfx1.f
   branches/map65/libm65/getpfx2.f
   branches/map65/libm65/graycode.f
   branches/map65/libm65/grid2deg.f
   branches/map65/libm65/grid2k.f
   branches/map65/libm65/igray.c
   branches/map65/libm65/indexx.f
   branches/map65/libm65/init_rs.c
   branches/map65/libm65/int.h
   branches/map65/libm65/interleave63.f
   branches/map65/libm65/ipcomm.cpp
   branches/map65/libm65/iqcal.f90
   branches/map65/libm65/iqfix.f90
   branches/map65/libm65/k2grid.f
   branches/map65/libm65/m65.f90
   branches/map65/libm65/m65a.F90
   branches/map65/libm65/map65a.f90
   branches/map65/libm65/moon2.f
   branches/map65/libm65/moondop.f
   branches/map65/libm65/nchar.f
   branches/map65/libm65/packcall.f
   branches/map65/libm65/packdxcc.f
   branches/map65/libm65/packgrid.f
   branches/map65/libm65/packmsg.f
   branches/map65/libm65/packtext.f
   branches/map65/libm65/pctile.f
   branches/map65/libm65/pfx.f
   branches/map65/libm65/pfxdump.f
   branches/map65/libm65/ptt.c
   branches/map65/libm65/ptt_unix.c
   branches/map65/libm65/recvpkt.f90
   branches/map65/libm65/rfile3a.f90
   branches/map65/libm65/rs.h
   branches/map65/libm65/s3avg.f90
   branches/map65/libm65/sec_midn.f90
   branches/map65/libm65/set.f
   branches/map65/libm65/setup65.f
   branches/map65/libm65/sleep.h
   branches/map65/libm65/sleep_msec.f90
   branches/map65/libm65/sort.f
   branches/map65/libm65/ssort.f
   branches/map65/libm65/sun.f
   branches/map65/libm65/symspec.f90
   branches/map65/libm65/tastro.f90
   branches/map65/libm65/timer.f90
   branches/map65/libm65/timeval.h
   branches/map65/libm65/timf2.f90
   branches/map65/libm65/tm2.f90
   branches/map65/libm65/tmoonsub.c
   branches/map65/libm65/toxyz.f
   branches/map65/libm65/trimlist.f
   branches/map65/libm65/twkfreq.f
   branches/map65/libm65/unpackcall.f
   branches/map65/libm65/unpackgrid.f
   branches/map65/libm65/unpackmsg.f
   branches/map65/libm65/unpacktext.f
   branches/map65/libm65/wrapkarn.c
   branches/map65/main.cpp
   branches/map65/mainwindow.cpp
   branches/map65/mainwindow.h
   branches/map65/map65.pro
   branches/map65/messages.cpp
   branches/map65/messages.h
   branches/map65/paInputDevice.c
   branches/map65/pa_get_device_info.c
   branches/map65/plotter.cpp
   branches/map65/plotter.h
   branches/map65/set570.cpp
   branches/map65/sleep.h
   branches/map65/soundin.cpp
   branches/map65/soundin.h
   branches/map65/soundout.cpp
   branches/map65/soundout.h
   branches/map65/widegraph.cpp
Log:
Set properties for native eol style and the &quot;Rev&quot; keyword.


Modified: branches/map65/about.cpp
===================================================================
--- branches/map65/about.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/about.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,23 +1,23 @@
-#include &quot;about.h&quot;
-#include &quot;ui_about.h&quot;
-
-CAboutDlg::CAboutDlg(QWidget *parent, QString Revision) :
-  QDialog(parent),
-  m_Revision(Revision),
-  ui(new Ui::CAboutDlg)
-{
-  ui-&gt;setupUi(this);
-  ui-&gt;labelTxt-&gt;clear();
-  m_Str  = &quot;&lt;html&gt;&lt;h2&gt;&quot; + m_Revision + &quot;&lt;/h2&gt;\n\n&quot;;
-  m_Str += &quot;MAP65 implements a wideband polarization-matching receiver &lt;br&gt;&quot;;
-  m_Str += &quot;for the JT65 protocol, with a matching transmitting facility. &lt;br&gt;&quot;;
-  m_Str += &quot;It is primarily intended for amateur radio EME communication. &lt;br&gt;&lt;br&gt;&quot;;
-  m_Str += &quot;Copyright 2001-2012 by Joe Taylor, K1JT.   Additional &lt;br&gt;&quot;;
-  m_Str += &quot;acknowledgments are contained in the source code. &lt;br&gt;&quot;;
-  ui-&gt;labelTxt-&gt;setText(m_Str);
-}
-
-CAboutDlg::~CAboutDlg()
-{
-  delete ui;
-}
+#include &quot;about.h&quot;
+#include &quot;ui_about.h&quot;
+
+CAboutDlg::CAboutDlg(QWidget *parent, QString Revision) :
+  QDialog(parent),
+  m_Revision(Revision),
+  ui(new Ui::CAboutDlg)
+{
+  ui-&gt;setupUi(this);
+  ui-&gt;labelTxt-&gt;clear();
+  m_Str  = &quot;&lt;html&gt;&lt;h2&gt;&quot; + m_Revision + &quot;&lt;/h2&gt;\n\n&quot;;
+  m_Str += &quot;MAP65 implements a wideband polarization-matching receiver &lt;br&gt;&quot;;
+  m_Str += &quot;for the JT65 protocol, with a matching transmitting facility. &lt;br&gt;&quot;;
+  m_Str += &quot;It is primarily intended for amateur radio EME communication. &lt;br&gt;&lt;br&gt;&quot;;
+  m_Str += &quot;Copyright 2001-2012 by Joe Taylor, K1JT.   Additional &lt;br&gt;&quot;;
+  m_Str += &quot;acknowledgments are contained in the source code. &lt;br&gt;&quot;;
+  ui-&gt;labelTxt-&gt;setText(m_Str);
+}
+
+CAboutDlg::~CAboutDlg()
+{
+  delete ui;
+}


Property changes on: branches/map65/about.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/about.h
===================================================================
--- branches/map65/about.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/about.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,24 +1,24 @@
-#ifndef ABOUTDLG_H
-#define ABOUTDLG_H
-
-#include &lt;QDialog&gt;
-
-namespace Ui {
-    class CAboutDlg;
-}
-
-class CAboutDlg : public QDialog
-{
-    Q_OBJECT
-
-public:
-	explicit CAboutDlg(QWidget *parent=0, QString Revision=&quot;&quot;);
-    ~CAboutDlg();
-
-private:
-	QString m_Revision;
-	Ui::CAboutDlg *ui;
-	QString m_Str;
-};
-
-#endif // ABOUTDLG_H
+#ifndef ABOUTDLG_H
+#define ABOUTDLG_H
+
+#include &lt;QDialog&gt;
+
+namespace Ui {
+    class CAboutDlg;
+}
+
+class CAboutDlg : public QDialog
+{
+    Q_OBJECT
+
+public:
+	explicit CAboutDlg(QWidget *parent=0, QString Revision=&quot;&quot;);
+    ~CAboutDlg();
+
+private:
+	QString m_Revision;
+	Ui::CAboutDlg *ui;
+	QString m_Str;
+};
+
+#endif // ABOUTDLG_H


Property changes on: branches/map65/about.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/astro.cpp
===================================================================
--- branches/map65/astro.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/astro.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,102 +1,102 @@
-#include &quot;astro.h&quot;
-#include &quot;ui_astro.h&quot;
-#include &lt;QDebug&gt;
-#include &lt;QFile&gt;
-#include &lt;QMessageBox&gt;
-#include &lt;stdio.h&gt;
-#include &quot;commons.h&quot;
-
-Astro::Astro(QWidget *parent) :
-  QWidget(parent),
-  ui(new Ui::Astro)
-{
-  ui-&gt;setupUi(this);
-  ui-&gt;astroTextBrowser-&gt;setStyleSheet(
-        &quot;QTextBrowser { background-color : cyan; color : black; }&quot;);
-  ui-&gt;astroTextBrowser-&gt;clear();
-}
-
-Astro::~Astro()
-{
-    delete ui;
-}
-
-void Astro::astroUpdate(QDateTime t, QString mygrid, QString hisgrid,
-                        int fQSO, int nsetftx, int ntxFreq, QString azelDir)
-{
-  static int ntxFreq0=-99;
-  static bool astroBusy=false;
-  char cc[300];
-  double azsun,elsun,azmoon,elmoon,azmoondx,elmoondx;
-  double ramoon,decmoon,dgrd,poloffset,xnr;
-  int ntsky,ndop,ndop00;
-  QString date = t.date().toString(&quot;yyyy MMM dd&quot;);
-  QString utc = t.time().toString();
-  int nyear=t.date().year();
-  int month=t.date().month();
-  int nday=t.date().day();
-  int nhr=t.time().hour();
-  int nmin=t.time().minute();
-  double sec=t.time().second() + 0.001*t.time().msec();
-  int isec=sec;
-  double uth=nhr + nmin/60.0 + sec/3600.0;
-  int nfreq=(int)datcom_.fcenter;
-  if(nfreq&lt;10 or nfreq &gt; 50000) nfreq=144;
-
-  if(!astroBusy) {
-    astroBusy=true;
-    astrosub_(&amp;nyear, &amp;month, &amp;nday, &amp;uth, &amp;nfreq, mygrid.toAscii(),
-            hisgrid.toAscii(), &amp;azsun, &amp;elsun, &amp;azmoon, &amp;elmoon,
-            &amp;azmoondx, &amp;elmoondx, &amp;ntsky, &amp;ndop, &amp;ndop00,&amp;ramoon, &amp;decmoon,
-            &amp;dgrd, &amp;poloffset, &amp;xnr, 6, 6);
-    astroBusy=false;
-  }
-
-  sprintf(cc,&quot;Az:    %6.1f\n&quot;
-          &quot;El:    %6.1f\n&quot;
-          &quot;Dop:   %6d\n&quot;
-          &quot;DxAz:  %6.1f\n&quot;
-          &quot;DxEl:  %6.1f\n&quot;
-          &quot;DxDop: %6d\n&quot;
-          &quot;Dec:   %6.1f\n&quot;
-          &quot;SunAz: %6.1f\n&quot;
-          &quot;SunEl: %6.1f\n&quot;
-          &quot;Tsky:  %6d\n&quot;
-          &quot;MNR:   %6.1f\n&quot;
-          &quot;Dgrd:  %6.1f&quot;,
-          azmoon,elmoon,ndop00,azmoondx,elmoondx,ndop,decmoon,azsun,elsun,
-          ntsky,xnr,dgrd);
-  ui-&gt;astroTextBrowser-&gt;setText(&quot; &quot;+ date + &quot;\nUTC: &quot; + utc + &quot;\n&quot; + cc);
-
-  QString fname=azelDir+&quot;/azel.dat&quot;;
-  QFile f(fname);
-  if(!f.open(QIODevice::WriteOnly | QIODevice::Text)) {
-    QMessageBox mb;
-    mb.setText(&quot;Cannot open &quot; + fname);
-    mb.exec();
-    return;
-  }
-  int ndiff=0;
-  if(ntxFreq != ntxFreq0) ndiff=1;
-  ntxFreq0=ntxFreq;
-  QTextStream out(&amp;f);
-  sprintf(cc,&quot;%2.2d:%2.2d:%2.2d,%5.1f,%5.1f,Moon\n&quot;
-          &quot;%2.2d:%2.2d:%2.2d,%5.1f,%5.1f,Sun\n&quot;
-          &quot;%2.2d:%2.2d:%2.2d,%5.1f,%5.1f,Source\n&quot;
-          &quot;%4d,%6d,Doppler\n&quot;
-          &quot;%3d,%1d,fQSO\n&quot;
-          &quot;%3d,%1d,fQSO2\n&quot;,
-          nhr,nmin,isec,azmoon,elmoon,
-          nhr,nmin,isec,azsun,elsun,
-          nhr,nmin,isec,0.0,0.0,
-          nfreq,ndop,
-          fQSO,nsetftx,
-          ntxFreq,ndiff);
-  out &lt;&lt; cc;
-  f.close();
-}
-
-void Astro::setFontSize(int n)
-{
-  ui-&gt;astroTextBrowser-&gt;setFontPointSize(n);
-}
+#include &quot;astro.h&quot;
+#include &quot;ui_astro.h&quot;
+#include &lt;QDebug&gt;
+#include &lt;QFile&gt;
+#include &lt;QMessageBox&gt;
+#include &lt;stdio.h&gt;
+#include &quot;commons.h&quot;
+
+Astro::Astro(QWidget *parent) :
+  QWidget(parent),
+  ui(new Ui::Astro)
+{
+  ui-&gt;setupUi(this);
+  ui-&gt;astroTextBrowser-&gt;setStyleSheet(
+        &quot;QTextBrowser { background-color : cyan; color : black; }&quot;);
+  ui-&gt;astroTextBrowser-&gt;clear();
+}
+
+Astro::~Astro()
+{
+    delete ui;
+}
+
+void Astro::astroUpdate(QDateTime t, QString mygrid, QString hisgrid,
+                        int fQSO, int nsetftx, int ntxFreq, QString azelDir)
+{
+  static int ntxFreq0=-99;
+  static bool astroBusy=false;
+  char cc[300];
+  double azsun,elsun,azmoon,elmoon,azmoondx,elmoondx;
+  double ramoon,decmoon,dgrd,poloffset,xnr;
+  int ntsky,ndop,ndop00;
+  QString date = t.date().toString(&quot;yyyy MMM dd&quot;);
+  QString utc = t.time().toString();
+  int nyear=t.date().year();
+  int month=t.date().month();
+  int nday=t.date().day();
+  int nhr=t.time().hour();
+  int nmin=t.time().minute();
+  double sec=t.time().second() + 0.001*t.time().msec();
+  int isec=sec;
+  double uth=nhr + nmin/60.0 + sec/3600.0;
+  int nfreq=(int)datcom_.fcenter;
+  if(nfreq&lt;10 or nfreq &gt; 50000) nfreq=144;
+
+  if(!astroBusy) {
+    astroBusy=true;
+    astrosub_(&amp;nyear, &amp;month, &amp;nday, &amp;uth, &amp;nfreq, mygrid.toAscii(),
+            hisgrid.toAscii(), &amp;azsun, &amp;elsun, &amp;azmoon, &amp;elmoon,
+            &amp;azmoondx, &amp;elmoondx, &amp;ntsky, &amp;ndop, &amp;ndop00,&amp;ramoon, &amp;decmoon,
+            &amp;dgrd, &amp;poloffset, &amp;xnr, 6, 6);
+    astroBusy=false;
+  }
+
+  sprintf(cc,&quot;Az:    %6.1f\n&quot;
+          &quot;El:    %6.1f\n&quot;
+          &quot;Dop:   %6d\n&quot;
+          &quot;DxAz:  %6.1f\n&quot;
+          &quot;DxEl:  %6.1f\n&quot;
+          &quot;DxDop: %6d\n&quot;
+          &quot;Dec:   %6.1f\n&quot;
+          &quot;SunAz: %6.1f\n&quot;
+          &quot;SunEl: %6.1f\n&quot;
+          &quot;Tsky:  %6d\n&quot;
+          &quot;MNR:   %6.1f\n&quot;
+          &quot;Dgrd:  %6.1f&quot;,
+          azmoon,elmoon,ndop00,azmoondx,elmoondx,ndop,decmoon,azsun,elsun,
+          ntsky,xnr,dgrd);
+  ui-&gt;astroTextBrowser-&gt;setText(&quot; &quot;+ date + &quot;\nUTC: &quot; + utc + &quot;\n&quot; + cc);
+
+  QString fname=azelDir+&quot;/azel.dat&quot;;
+  QFile f(fname);
+  if(!f.open(QIODevice::WriteOnly | QIODevice::Text)) {
+    QMessageBox mb;
+    mb.setText(&quot;Cannot open &quot; + fname);
+    mb.exec();
+    return;
+  }
+  int ndiff=0;
+  if(ntxFreq != ntxFreq0) ndiff=1;
+  ntxFreq0=ntxFreq;
+  QTextStream out(&amp;f);
+  sprintf(cc,&quot;%2.2d:%2.2d:%2.2d,%5.1f,%5.1f,Moon\n&quot;
+          &quot;%2.2d:%2.2d:%2.2d,%5.1f,%5.1f,Sun\n&quot;
+          &quot;%2.2d:%2.2d:%2.2d,%5.1f,%5.1f,Source\n&quot;
+          &quot;%4d,%6d,Doppler\n&quot;
+          &quot;%3d,%1d,fQSO\n&quot;
+          &quot;%3d,%1d,fQSO2\n&quot;,
+          nhr,nmin,isec,azmoon,elmoon,
+          nhr,nmin,isec,azsun,elsun,
+          nhr,nmin,isec,0.0,0.0,
+          nfreq,ndop,
+          fQSO,nsetftx,
+          ntxFreq,ndiff);
+  out &lt;&lt; cc;
+  f.close();
+}
+
+void Astro::setFontSize(int n)
+{
+  ui-&gt;astroTextBrowser-&gt;setFontPointSize(n);
+}


Property changes on: branches/map65/astro.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/astro.h
===================================================================
--- branches/map65/astro.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/astro.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,35 +1,35 @@
-#ifndef ASTRO_H
-#define ASTRO_H
-
-#include &lt;QWidget&gt;
-#include &lt;QDateTime&gt;
-
-namespace Ui {
-  class Astro;
-}
-
-class Astro : public QWidget
-{
-  Q_OBJECT
-
-public:
-  explicit Astro(QWidget *parent = 0);
-  void astroUpdate(QDateTime t, QString mygrid, QString hisgrid,
-                   int fQSO, int nsetftx, int ntxFreq, QString azelDir);
-  void setFontSize(int n);
-  ~Astro();
-
-private:
-    Ui::Astro *ui;
-};
-
-extern &quot;C&quot; {
-  void astrosub_(int* nyear, int* month, int* nday, double* uth, int* nfreq,
-     const char* mygrid, const char* hisgrid, double* azsun,
-     double* elsun, double* azmoon, double* elmoon, double* azmoondx,
-     double* elmoondx, int* ntsky, int* ndop, int* ndop00,
-     double* ramoon, double* decmoon, double* dgrd, double* poloffset,
-     double* xnr, int len1, int len2);
-}
-
-#endif // ASTRO_H
+#ifndef ASTRO_H
+#define ASTRO_H
+
+#include &lt;QWidget&gt;
+#include &lt;QDateTime&gt;
+
+namespace Ui {
+  class Astro;
+}
+
+class Astro : public QWidget
+{
+  Q_OBJECT
+
+public:
+  explicit Astro(QWidget *parent = 0);
+  void astroUpdate(QDateTime t, QString mygrid, QString hisgrid,
+                   int fQSO, int nsetftx, int ntxFreq, QString azelDir);
+  void setFontSize(int n);
+  ~Astro();
+
+private:
+    Ui::Astro *ui;
+};
+
+extern &quot;C&quot; {
+  void astrosub_(int* nyear, int* month, int* nday, double* uth, int* nfreq,
+     const char* mygrid, const char* hisgrid, double* azsun,
+     double* elsun, double* azmoon, double* elmoon, double* azmoondx,
+     double* elmoondx, int* ntsky, int* ndop, int* ndop00,
+     double* ramoon, double* decmoon, double* dgrd, double* poloffset,
+     double* xnr, int len1, int len2);
+}
+
+#endif // ASTRO_H


Property changes on: branches/map65/astro.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/bandmap.cpp
===================================================================
--- branches/map65/bandmap.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/bandmap.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,89 +1,89 @@
-#include &quot;bandmap.h&quot;
-#include &quot;ui_bandmap.h&quot;
-#include &lt;QDebug&gt;
-
-BandMap::BandMap(QWidget *parent) :
-  QWidget(parent),
-  ui(new Ui::BandMap)
-{
-  ui-&gt;setupUi(this);
-  ui-&gt;bmTextBrowser-&gt;setStyleSheet(
-        &quot;QTextBrowser { background-color : #000066; color : red; }&quot;);
-  m_bandMapText=&quot;&quot;;
-  ui-&gt;bmTextBrowser-&gt;clear();
-}
-
-BandMap::~BandMap()
-{
-  delete ui;
-}
-
-void BandMap::setText(QString t)
-{
-  m_bandMapText=t;
-  int w=ui-&gt;bmTextBrowser-&gt;size().width();
-  int ncols=1;
-  if(w&gt;220) ncols=2;
-  QString s=&quot;QTextBrowser{background-color: &quot;+m_colorBackground+&quot;}&quot;;
-  ui-&gt;bmTextBrowser-&gt;setStyleSheet(s);
-  QString t0=&quot;&lt;html style=\&quot; font-family:'Courier New';&quot;
-      &quot;font-size:9pt; background-color:#000066\&quot;&gt;&quot;
-      &quot;&lt;table border=0 cellspacing=7&gt;&lt;tr&gt;&lt;td&gt;\n&quot;;
-  QString tfreq,tspace,tcall;
-  QString s0,s1,s2,s3,bg;
-  bg=&quot;&lt;span style=color:&quot;+m_colorBackground+&quot;;&gt;.&lt;/span&gt;&quot;;
-  s0=&quot;&lt;span style=color:&quot;+m_color0+&quot;;&gt;&quot;;
-  s1=&quot;&lt;span style=color:&quot;+m_color1+&quot;;&gt;&quot;;
-  s2=&quot;&lt;span style=color:&quot;+m_color2+&quot;;&gt;&quot;;
-  s3=&quot;&lt;span style=color:&quot;+m_color3+&quot;;&gt;&quot;;
-
-  ui-&gt;bmTextBrowser-&gt;clear();
-  QStringList lines = t.split( &quot;\n&quot;, QString::SkipEmptyParts );
-  int nrows=(lines.length()+ncols-1)/ncols;
-
-  for(int i=0; i&lt;nrows; i++) {
-    tfreq=lines[i].mid(0,3);
-    tspace=lines[i].mid(4,1);
-    if(tspace==&quot; &quot;) tspace=bg;
-    tcall=lines[i].mid(5,7);
-    int n=lines[i].mid(13,1).toInt();
-    if(n==0) t0 += s0;
-    if(n==1) t0 += s1;
-    if(n==2) t0 += s2;
-    if(n&gt;=3) t0 += s3;
-    t0 += (tfreq + tspace + tcall + &quot;&lt;/span&gt;&lt;br&gt;\n&quot;);
-  }
-
-  if(ncols==2) {                                  //2-column display
-    t0 += &quot;&lt;td&gt;&lt;br&gt;&lt;td&gt;\n&quot;;
-    for(int i=nrows; i&lt;lines.length(); i++) {
-      tfreq=lines[i].mid(0,3);
-      tspace=lines[i].mid(4,1);
-      if(tspace==&quot;  &quot;) tspace=bg;
-      tcall=lines[i].mid(5,7);
-      int n=lines[i].mid(13,1).toInt();
-      if(n==0) t0 += s0;
-      if(n==1) t0 += s1;
-      if(n==2) t0 += s2;
-      if(n&gt;=3) t0 += s3;
-      t0 += (tfreq + tspace + tcall + &quot;&lt;/span&gt;&lt;br&gt;\n&quot;);
-    }
-    if(2*nrows&gt;lines.length()) t0 += (s0 + &quot;&lt;/span&gt;&lt;br&gt;\n&quot;);
-  }
-  ui-&gt;bmTextBrowser-&gt;setHtml(t0);
-}
-
-void BandMap::resizeEvent(QResizeEvent* )
-{
-  setText(m_bandMapText);
-}
-
-void BandMap::setColors(QString t)
-{
-  m_colorBackground = &quot;#&quot;+t.mid(0,6);
-  m_color0 = &quot;#&quot;+t.mid(6,6);
-  m_color1 = &quot;#&quot;+t.mid(12,6);
-  m_color2 = &quot;#&quot;+t.mid(18,6);
-  m_color3 = &quot;#&quot;+t.mid(24,6);
-  setText(m_bandMapText);
-}
+#include &quot;bandmap.h&quot;
+#include &quot;ui_bandmap.h&quot;
+#include &lt;QDebug&gt;
+
+BandMap::BandMap(QWidget *parent) :
+  QWidget(parent),
+  ui(new Ui::BandMap)
+{
+  ui-&gt;setupUi(this);
+  ui-&gt;bmTextBrowser-&gt;setStyleSheet(
+        &quot;QTextBrowser { background-color : #000066; color : red; }&quot;);
+  m_bandMapText=&quot;&quot;;
+  ui-&gt;bmTextBrowser-&gt;clear();
+}
+
+BandMap::~BandMap()
+{
+  delete ui;
+}
+
+void BandMap::setText(QString t)
+{
+  m_bandMapText=t;
+  int w=ui-&gt;bmTextBrowser-&gt;size().width();
+  int ncols=1;
+  if(w&gt;220) ncols=2;
+  QString s=&quot;QTextBrowser{background-color: &quot;+m_colorBackground+&quot;}&quot;;
+  ui-&gt;bmTextBrowser-&gt;setStyleSheet(s);
+  QString t0=&quot;&lt;html style=\&quot; font-family:'Courier New';&quot;
+      &quot;font-size:9pt; background-color:#000066\&quot;&gt;&quot;
+      &quot;&lt;table border=0 cellspacing=7&gt;&lt;tr&gt;&lt;td&gt;\n&quot;;
+  QString tfreq,tspace,tcall;
+  QString s0,s1,s2,s3,bg;
+  bg=&quot;&lt;span style=color:&quot;+m_colorBackground+&quot;;&gt;.&lt;/span&gt;&quot;;
+  s0=&quot;&lt;span style=color:&quot;+m_color0+&quot;;&gt;&quot;;
+  s1=&quot;&lt;span style=color:&quot;+m_color1+&quot;;&gt;&quot;;
+  s2=&quot;&lt;span style=color:&quot;+m_color2+&quot;;&gt;&quot;;
+  s3=&quot;&lt;span style=color:&quot;+m_color3+&quot;;&gt;&quot;;
+
+  ui-&gt;bmTextBrowser-&gt;clear();
+  QStringList lines = t.split( &quot;\n&quot;, QString::SkipEmptyParts );
+  int nrows=(lines.length()+ncols-1)/ncols;
+
+  for(int i=0; i&lt;nrows; i++) {
+    tfreq=lines[i].mid(0,3);
+    tspace=lines[i].mid(4,1);
+    if(tspace==&quot; &quot;) tspace=bg;
+    tcall=lines[i].mid(5,7);
+    int n=lines[i].mid(13,1).toInt();
+    if(n==0) t0 += s0;
+    if(n==1) t0 += s1;
+    if(n==2) t0 += s2;
+    if(n&gt;=3) t0 += s3;
+    t0 += (tfreq + tspace + tcall + &quot;&lt;/span&gt;&lt;br&gt;\n&quot;);
+  }
+
+  if(ncols==2) {                                  //2-column display
+    t0 += &quot;&lt;td&gt;&lt;br&gt;&lt;td&gt;\n&quot;;
+    for(int i=nrows; i&lt;lines.length(); i++) {
+      tfreq=lines[i].mid(0,3);
+      tspace=lines[i].mid(4,1);
+      if(tspace==&quot;  &quot;) tspace=bg;
+      tcall=lines[i].mid(5,7);
+      int n=lines[i].mid(13,1).toInt();
+      if(n==0) t0 += s0;
+      if(n==1) t0 += s1;
+      if(n==2) t0 += s2;
+      if(n&gt;=3) t0 += s3;
+      t0 += (tfreq + tspace + tcall + &quot;&lt;/span&gt;&lt;br&gt;\n&quot;);
+    }
+    if(2*nrows&gt;lines.length()) t0 += (s0 + &quot;&lt;/span&gt;&lt;br&gt;\n&quot;);
+  }
+  ui-&gt;bmTextBrowser-&gt;setHtml(t0);
+}
+
+void BandMap::resizeEvent(QResizeEvent* )
+{
+  setText(m_bandMapText);
+}
+
+void BandMap::setColors(QString t)
+{
+  m_colorBackground = &quot;#&quot;+t.mid(0,6);
+  m_color0 = &quot;#&quot;+t.mid(6,6);
+  m_color1 = &quot;#&quot;+t.mid(12,6);
+  m_color2 = &quot;#&quot;+t.mid(18,6);
+  m_color3 = &quot;#&quot;+t.mid(24,6);
+  setText(m_bandMapText);
+}


Property changes on: branches/map65/bandmap.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/bandmap.h
===================================================================
--- branches/map65/bandmap.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/bandmap.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,34 +1,34 @@
-#ifndef BANDMAP_H
-#define BANDMAP_H
-
-#include &lt;QWidget&gt;
-
-namespace Ui {
-    class BandMap;
-}
-
-class BandMap : public QWidget
-{
-    Q_OBJECT
-
-public:
-  explicit BandMap(QWidget *parent = 0);
-  void setText(QString t);
-  void setColors(QString t);
-
-  ~BandMap();
-
-protected:
-  void resizeEvent(QResizeEvent* event);
-
-private:
-    Ui::BandMap *ui;
-    QString m_bandMapText;
-    QString m_colorBackground;
-    QString m_color0;
-    QString m_color1;
-    QString m_color2;
-    QString m_color3;
-};
-
-#endif // BANDMAP_H
+#ifndef BANDMAP_H
+#define BANDMAP_H
+
+#include &lt;QWidget&gt;
+
+namespace Ui {
+    class BandMap;
+}
+
+class BandMap : public QWidget
+{
+    Q_OBJECT
+
+public:
+  explicit BandMap(QWidget *parent = 0);
+  void setText(QString t);
+  void setColors(QString t);
+
+  ~BandMap();
+
+protected:
+  void resizeEvent(QResizeEvent* event);
+
+private:
+    Ui::BandMap *ui;
+    QString m_bandMapText;
+    QString m_colorBackground;
+    QString m_color0;
+    QString m_color1;
+    QString m_color2;
+    QString m_color3;
+};
+
+#endif // BANDMAP_H


Property changes on: branches/map65/bandmap.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/commons.h
===================================================================
--- branches/map65/commons.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/commons.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,42 +1,42 @@
-#ifndef COMMONS_H
-#define COMMONS_H
-
-#define NFFT 32768
-
-extern &quot;C&quot; {
-
-extern struct {                     //This is &quot;common/datcom/...&quot; in Fortran
-  float d4[4*5760000];              //Raw I/Q data from Linrad
-  float ss[4*322*NFFT];             //Half-symbol spectra at 0,45,90,135 deg pol
-  float savg[4*NFFT];               //Avg spectra at 0,45,90,135 deg pol
-  double fcenter;                   //Center freq from Linrad (MHz)
-  int nutc;                         //UTC as integer, HHMM
-  int idphi;                        //Phase correction for Y pol'n, degrees
-  int mousedf;                      //User-selected DF
-  int mousefqso;                    //User-selected QSO freq (kHz)
-  int nagain;                       //1 ==&gt; decode only at fQSO +/- Tol
-  int ndepth;                       //How much hinted decoding to do?
-  int ndiskdat;                     //1 ==&gt; data read from *.tf2 or *.iq file
-  int neme;                         //Hinted decoding tries only for EME calls
-  int newdat;                       //1 ==&gt; new data, must do long FFT
-  int nfa;                          //Low decode limit (kHz)
-  int nfb;                          //High decode limit (kHz)
-  int nfcal;                        //Frequency correction, for calibration (Hz)
-  int nfshift;                      //Shift of displayed center freq (kHz)
-  int mcall3;                       //1 ==&gt; CALL3.TXT has been modified
-  int ntimeout;                     //Max for timeouts in Messages and BandMap
-  int ntol;                         //+/- decoding range around fQSO (Hz)
-  int nxant;                        //1 ==&gt; add 45 deg to measured pol angle
-  int map65RxLog;                   //Flags to control log files
-  int nfsample;                     //Input sample rate
-  int nxpol;                        //1 if using xpol antennas, 0 otherwise
-  int mode65;                       //JT65 sub-mode: A=1, B=2, C=4
-  char mycall[12];
-  char mygrid[6];
-  char hiscall[12];
-  char hisgrid[6];
-  char datetime[20];
-} datcom_;
-}
-
-#endif // COMMONS_H
+#ifndef COMMONS_H
+#define COMMONS_H
+
+#define NFFT 32768
+
+extern &quot;C&quot; {
+
+extern struct {                     //This is &quot;common/datcom/...&quot; in Fortran
+  float d4[4*5760000];              //Raw I/Q data from Linrad
+  float ss[4*322*NFFT];             //Half-symbol spectra at 0,45,90,135 deg pol
+  float savg[4*NFFT];               //Avg spectra at 0,45,90,135 deg pol
+  double fcenter;                   //Center freq from Linrad (MHz)
+  int nutc;                         //UTC as integer, HHMM
+  int idphi;                        //Phase correction for Y pol'n, degrees
+  int mousedf;                      //User-selected DF
+  int mousefqso;                    //User-selected QSO freq (kHz)
+  int nagain;                       //1 ==&gt; decode only at fQSO +/- Tol
+  int ndepth;                       //How much hinted decoding to do?
+  int ndiskdat;                     //1 ==&gt; data read from *.tf2 or *.iq file
+  int neme;                         //Hinted decoding tries only for EME calls
+  int newdat;                       //1 ==&gt; new data, must do long FFT
+  int nfa;                          //Low decode limit (kHz)
+  int nfb;                          //High decode limit (kHz)
+  int nfcal;                        //Frequency correction, for calibration (Hz)
+  int nfshift;                      //Shift of displayed center freq (kHz)
+  int mcall3;                       //1 ==&gt; CALL3.TXT has been modified
+  int ntimeout;                     //Max for timeouts in Messages and BandMap
+  int ntol;                         //+/- decoding range around fQSO (Hz)
+  int nxant;                        //1 ==&gt; add 45 deg to measured pol angle
+  int map65RxLog;                   //Flags to control log files
+  int nfsample;                     //Input sample rate
+  int nxpol;                        //1 if using xpol antennas, 0 otherwise
+  int mode65;                       //JT65 sub-mode: A=1, B=2, C=4
+  char mycall[12];
+  char mygrid[6];
+  char hiscall[12];
+  char hisgrid[6];
+  char datetime[20];
+} datcom_;
+}
+
+#endif // COMMONS_H


Property changes on: branches/map65/commons.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/devsetup.cpp
===================================================================
--- branches/map65/devsetup.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/devsetup.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,325 +1,325 @@
-#include &quot;devsetup.h&quot;
-#include &quot;mainwindow.h&quot;
-#include &lt;QDebug&gt;
-#include &lt;portaudio.h&gt;
-
-#define MAXDEVICES 100
-
-//----------------------------------------------------------- DevSetup()
-DevSetup::DevSetup(QWidget *parent) :	QDialog(parent)
-{
-  ui.setupUi(this);	//setup the dialog form
-  m_restartSoundIn=false;
-  m_restartSoundOut=false;
-}
-
-DevSetup::~DevSetup()
-{
-}
-
-void DevSetup::initDlg()
-{
-  int k,id;
-  int valid_devices=0;
-  int minChan[MAXDEVICES];
-  int maxChan[MAXDEVICES];
-  int minSpeed[MAXDEVICES];
-  int maxSpeed[MAXDEVICES];
-  char hostAPI_DeviceName[MAXDEVICES][50];
-  char s[60];
-  int numDevices=Pa_GetDeviceCount();
-  getDev(&amp;numDevices,hostAPI_DeviceName,minChan,maxChan,minSpeed,maxSpeed);
-  k=0;
-  for(id=0; id&lt;numDevices; id++)  {
-    if(96000 &gt;= minSpeed[id] &amp;&amp; 96000 &lt;= maxSpeed[id]) {
-      m_inDevList[k]=id;
-      k++;
-      sprintf(s,&quot;%2d   %d  %-49s&quot;,id,maxChan[id],hostAPI_DeviceName[id]);
-      QString t(s);
-      ui.comboBoxSndIn-&gt;addItem(t);
-      valid_devices++;
-    }
-  }
-
-  const PaDeviceInfo *pdi;
-  int nchout;
-  char *p,*p1;
-  char p2[50];
-  char pa_device_name[128];
-  char pa_device_hostapi[128];
-
-  k=0;
-  for(id=0; id&lt;numDevices; id++ )  {
-    pdi=Pa_GetDeviceInfo(id);
-    nchout=pdi-&gt;maxOutputChannels;
-    if(nchout&gt;=2) {
-      m_outDevList[k]=id;
-      k++;
-      sprintf((char*)(pa_device_name),&quot;%s&quot;,pdi-&gt;name);
-      sprintf((char*)(pa_device_hostapi),&quot;%s&quot;,
-              Pa_GetHostApiInfo(pdi-&gt;hostApi)-&gt;name);
-
-      p1=(char*)&quot;&quot;;
-      p=strstr(pa_device_hostapi,&quot;MME&quot;);
-      if(p!=NULL) p1=(char*)&quot;MME&quot;;
-      p=strstr(pa_device_hostapi,&quot;Direct&quot;);
-      if(p!=NULL) p1=(char*)&quot;DirectX&quot;;
-      p=strstr(pa_device_hostapi,&quot;WASAPI&quot;);
-      if(p!=NULL) p1=(char*)&quot;WASAPI&quot;;
-      p=strstr(pa_device_hostapi,&quot;ASIO&quot;);
-      if(p!=NULL) p1=(char*)&quot;ASIO&quot;;
-      p=strstr(pa_device_hostapi,&quot;WDM-KS&quot;);
-      if(p!=NULL) p1=(char*)&quot;WDM-KS&quot;;
-
-      sprintf(p2,&quot;%2d   %-8s  %-39s&quot;,id,p1,pa_device_name);
-      QString t(p2);
-      ui.comboBoxSndOut-&gt;addItem(t);
-    }
-  }
-
-  ui.myCallEntry-&gt;setText(m_myCall);
-  ui.myGridEntry-&gt;setText(m_myGrid);
-  ui.idIntSpinBox-&gt;setValue(m_idInt);
-  ui.pttComboBox-&gt;setCurrentIndex(m_pttPort);
-  ui.astroFont-&gt;setValue(m_astroFont);
-  ui.cbXpol-&gt;setChecked(m_xpol);
-  ui.rbAntennaX-&gt;setChecked(m_xpolx);
-  ui.saveDirEntry-&gt;setText(m_saveDir);
-  ui.azelDirEntry-&gt;setText(m_azelDir);
-  ui.dxccEntry-&gt;setText(m_dxccPfx);
-  ui.timeoutSpinBox-&gt;setValue(m_timeout);
-  ui.dPhiSpinBox-&gt;setValue(m_dPhi);
-  ui.fCalSpinBox-&gt;setValue(m_fCal);
-  ui.faddEntry-&gt;setText(QString::number(m_fAdd,'f',3));
-  ui.networkRadioButton-&gt;setChecked(m_network);
-  ui.soundCardRadioButton-&gt;setChecked(!m_network);
-  ui.rb96000-&gt;setChecked(m_fs96000);
-  ui.rb95238-&gt;setChecked(!m_fs96000);
-  ui.comboBoxSndIn-&gt;setEnabled(!m_network);
-  ui.comboBoxSndIn-&gt;setCurrentIndex(m_nDevIn);
-  ui.comboBoxSndOut-&gt;setCurrentIndex(m_nDevOut);
-  ui.sbPort-&gt;setValue(m_udpPort);
-  ui.cbIQswap-&gt;setChecked(m_IQswap);
-  ui.cb10db-&gt;setChecked(m_10db);
-  ui.cbInitIQplus-&gt;setChecked(m_initIQplus);
-  ui.mult570SpinBox-&gt;setValue(m_mult570);
-  ui.cal570SpinBox-&gt;setValue(m_cal570);
-  sscanf(m_colors.toAscii(),&quot;%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x&quot;,
-         &amp;r,&amp;g,&amp;b,&amp;r0,&amp;g0,&amp;b0,&amp;r1,&amp;g1,&amp;b1,&amp;r2,&amp;g2,&amp;b2,&amp;r3,&amp;g3,&amp;b3);
-  updateColorLabels();
-  ui.sbBackgroundRed-&gt;setValue(r);
-  ui.sbBackgroundGreen-&gt;setValue(g);
-  ui.sbBackgroundBlue-&gt;setValue(b);
-  ui.sbRed0-&gt;setValue(r0);
-  ui.sbRed1-&gt;setValue(r1);
-  ui.sbRed2-&gt;setValue(r2);
-  ui.sbRed3-&gt;setValue(r3);
-  ui.sbGreen0-&gt;setValue(g0);
-  ui.sbGreen1-&gt;setValue(g1);
-  ui.sbGreen2-&gt;setValue(g2);
-  ui.sbGreen3-&gt;setValue(g3);
-  ui.sbBlue0-&gt;setValue(b0);
-  ui.sbBlue1-&gt;setValue(b1);
-  ui.sbBlue2-&gt;setValue(b2);
-  ui.sbBlue3-&gt;setValue(b3);
-
-  m_paInDevice=m_inDevList[m_nDevIn];
-  m_paOutDevice=m_outDevList[m_nDevOut];
-
-}
-
-//------------------------------------------------------- accept()
-void DevSetup::accept()
-{
-  // Called when OK button is clicked.
-  // Check to see whether SoundInThread must be restarted,
-  // and save user parameters.
-
-  if(m_network!=ui.networkRadioButton-&gt;isChecked() or
-     m_nDevIn!=ui.comboBoxSndIn-&gt;currentIndex() or
-     m_paInDevice!=m_inDevList[m_nDevIn] or
-     m_xpol!=ui.cbXpol-&gt;isChecked() or
-     m_udpPort!=ui.sbPort-&gt;value()) m_restartSoundIn=true;
-
-  if(m_nDevOut!=ui.comboBoxSndOut-&gt;currentIndex() or
-     m_paOutDevice!=m_outDevList[m_nDevOut]) m_restartSoundOut=true;
-
-  m_myCall=ui.myCallEntry-&gt;text();
-  m_myGrid=ui.myGridEntry-&gt;text();
-  m_idInt=ui.idIntSpinBox-&gt;value();
-  m_pttPort=ui.pttComboBox-&gt;currentIndex();
-  m_astroFont=ui.astroFont-&gt;value();
-  m_xpol=ui.cbXpol-&gt;isChecked();
-  m_xpolx=ui.rbAntennaX-&gt;isChecked();
-  m_saveDir=ui.saveDirEntry-&gt;text();
-  m_azelDir=ui.azelDirEntry-&gt;text();
-  m_dxccPfx=ui.dxccEntry-&gt;text();
-  m_timeout=ui.timeoutSpinBox-&gt;value();
-  m_dPhi=ui.dPhiSpinBox-&gt;value();
-  m_fCal=ui.fCalSpinBox-&gt;value();
-  m_fAdd=ui.faddEntry-&gt;text().toDouble();
-  m_network=ui.networkRadioButton-&gt;isChecked();
-  m_fs96000=ui.rb96000-&gt;isChecked();
-  m_nDevIn=ui.comboBoxSndIn-&gt;currentIndex();
-  m_paInDevice=m_inDevList[m_nDevIn];
-  m_nDevOut=ui.comboBoxSndOut-&gt;currentIndex();
-  m_paOutDevice=m_outDevList[m_nDevOut];
-  m_udpPort=ui.sbPort-&gt;value();
-  m_IQswap=ui.cbIQswap-&gt;isChecked();
-  m_10db=ui.cb10db-&gt;isChecked();
-  m_initIQplus=ui.cbInitIQplus-&gt;isChecked();
-  m_mult570=ui.mult570SpinBox-&gt;value();
-  m_cal570=ui.cal570SpinBox-&gt;value();
-
-  QDialog::accept();
-}
-
-void DevSetup::on_soundCardRadioButton_toggled(bool checked)
-{
-  ui.comboBoxSndIn-&gt;setEnabled(ui.soundCardRadioButton-&gt;isChecked());
-  ui.rb96000-&gt;setChecked(checked);
-  ui.rb95238-&gt;setEnabled(!checked);
-  ui.label_InputDev-&gt;setEnabled(checked);
-  ui.label_Port-&gt;setEnabled(!checked);
-  ui.sbPort-&gt;setEnabled(!checked);
-  ui.cbIQswap-&gt;setEnabled(checked);
-  ui.cb10db-&gt;setEnabled(checked);
-}
-
-void DevSetup::on_cbXpol_stateChanged(int n)
-{
-  m_xpol = (n!=0);
-  ui.rbAntenna-&gt;setEnabled(m_xpol);
-  ui.rbAntennaX-&gt;setEnabled(m_xpol);
-  ui.dPhiSpinBox-&gt;setEnabled(m_xpol);
-  ui.labelDphi-&gt;setEnabled(m_xpol);
-}
-
-void DevSetup::on_cal570SpinBox_valueChanged(double ppm)
-{
-  m_cal570=ppm;
-}
-
-void DevSetup::on_mult570SpinBox_valueChanged(int mult)
-{
-  m_mult570=mult;
-}
-
-void DevSetup::updateColorLabels()
-{
-  QString t;
-  int r=ui.sbBackgroundRed-&gt;value();
-  int g=ui.sbBackgroundGreen-&gt;value();
-  int b=ui.sbBackgroundBlue-&gt;value();
-  int r0=ui.sbRed0-&gt;value();
-  int r1=ui.sbRed1-&gt;value();
-  int r2=ui.sbRed2-&gt;value();
-  int r3=ui.sbRed3-&gt;value();
-  int g0=ui.sbGreen0-&gt;value();
-  int g1=ui.sbGreen1-&gt;value();
-  int g2=ui.sbGreen2-&gt;value();
-  int g3=ui.sbGreen3-&gt;value();
-  int b0=ui.sbBlue0-&gt;value();
-  int b1=ui.sbBlue1-&gt;value();
-  int b2=ui.sbBlue2-&gt;value();
-  int b3=ui.sbBlue3-&gt;value();
-
-  t.sprintf(&quot;QLabel{background-color: #%2.2x%2.2x%2.2x;&quot;
-            &quot;color: #%2.2x%2.2x%2.2x}&quot;,r,g,b,r0,g0,b0);
-  ui.lab0-&gt;setStyleSheet(t);
-  t.sprintf(&quot;QLabel{background-color: #%2.2x%2.2x%2.2x;&quot;
-            &quot;color: #%2.2x%2.2x%2.2x}&quot;,r,g,b,r1,g1,b1);
-  ui.lab1-&gt;setStyleSheet(t);
-  t.sprintf(&quot;QLabel{background-color: #%2.2x%2.2x%2.2x;&quot;
-            &quot;color: #%2.2x%2.2x%2.2x}&quot;,r,g,b,r2,g2,b2);
-  ui.lab2-&gt;setStyleSheet(t);
-  t.sprintf(&quot;QLabel{background-color: #%2.2x%2.2x%2.2x;&quot;
-            &quot;color: #%2.2x%2.2x%2.2x}&quot;,r,g,b,r3,g3,b3);
-  ui.lab3-&gt;setStyleSheet(t);
-
-  m_colors.sprintf(&quot;%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x&quot;
-            &quot;%2.2x%2.2x%2.2x&quot;,r,g,b,r0,g0,b0,r1,g1,b1,r2,g2,b2,r3,g3,b3);
-}
-
-void DevSetup::on_sbBackgroundRed_valueChanged(int r)
-{
-  updateColorLabels();
-}
-
-void DevSetup::on_sbBackgroundGreen_valueChanged(int g)
-{
-  updateColorLabels();
-}
-
-void DevSetup::on_sbBackgroundBlue_valueChanged(int b)
-{
-  updateColorLabels();
-}
-
-
-void DevSetup::on_sbRed0_valueChanged(int arg1)
-{
-  updateColorLabels();
-}
-
-void DevSetup::on_sbGreen0_valueChanged(int arg1)
-{
-  updateColorLabels();
-}
-
-void DevSetup::on_sbBlue0_valueChanged(int arg1)
-{
-  updateColorLabels();
-}
-
-void DevSetup::on_sbRed1_valueChanged(int arg1)
-{
-   updateColorLabels();
-}
-
-void DevSetup::on_sbGreen1_valueChanged(int arg1)
-{
-  updateColorLabels();
-}
-
-void DevSetup::on_sbBlue1_valueChanged(int arg1)
-{
-   updateColorLabels();
-}
-
-void DevSetup::on_sbRed2_valueChanged(int arg1)
-{
-   updateColorLabels();
-}
-
-void DevSetup::on_sbGreen2_valueChanged(int arg1)
-{
-   updateColorLabels();
-}
-
-void DevSetup::on_sbBlue2_valueChanged(int arg1)
-{
-   updateColorLabels();
-}
-
-void DevSetup::on_sbRed3_valueChanged(int arg1)
-{
-  updateColorLabels();
-}
-
-void DevSetup::on_sbGreen3_valueChanged(int arg1)
-{
-  updateColorLabels();
-}
-
-void DevSetup::on_sbBlue3_valueChanged(int arg1)
-{
-  updateColorLabels();
-}
-
-void DevSetup::on_pushButton_5_clicked()
-{
-  QColor color = QColorDialog::getColor(Qt::green, this);
-  if (color.isValid()) {
-  }
-}
+#include &quot;devsetup.h&quot;
+#include &quot;mainwindow.h&quot;
+#include &lt;QDebug&gt;
+#include &lt;portaudio.h&gt;
+
+#define MAXDEVICES 100
+
+//----------------------------------------------------------- DevSetup()
+DevSetup::DevSetup(QWidget *parent) :	QDialog(parent)
+{
+  ui.setupUi(this);	//setup the dialog form
+  m_restartSoundIn=false;
+  m_restartSoundOut=false;
+}
+
+DevSetup::~DevSetup()
+{
+}
+
+void DevSetup::initDlg()
+{
+  int k,id;
+  int valid_devices=0;
+  int minChan[MAXDEVICES];
+  int maxChan[MAXDEVICES];
+  int minSpeed[MAXDEVICES];
+  int maxSpeed[MAXDEVICES];
+  char hostAPI_DeviceName[MAXDEVICES][50];
+  char s[60];
+  int numDevices=Pa_GetDeviceCount();
+  getDev(&amp;numDevices,hostAPI_DeviceName,minChan,maxChan,minSpeed,maxSpeed);
+  k=0;
+  for(id=0; id&lt;numDevices; id++)  {
+    if(96000 &gt;= minSpeed[id] &amp;&amp; 96000 &lt;= maxSpeed[id]) {
+      m_inDevList[k]=id;
+      k++;
+      sprintf(s,&quot;%2d   %d  %-49s&quot;,id,maxChan[id],hostAPI_DeviceName[id]);
+      QString t(s);
+      ui.comboBoxSndIn-&gt;addItem(t);
+      valid_devices++;
+    }
+  }
+
+  const PaDeviceInfo *pdi;
+  int nchout;
+  char *p,*p1;
+  char p2[50];
+  char pa_device_name[128];
+  char pa_device_hostapi[128];
+
+  k=0;
+  for(id=0; id&lt;numDevices; id++ )  {
+    pdi=Pa_GetDeviceInfo(id);
+    nchout=pdi-&gt;maxOutputChannels;
+    if(nchout&gt;=2) {
+      m_outDevList[k]=id;
+      k++;
+      sprintf((char*)(pa_device_name),&quot;%s&quot;,pdi-&gt;name);
+      sprintf((char*)(pa_device_hostapi),&quot;%s&quot;,
+              Pa_GetHostApiInfo(pdi-&gt;hostApi)-&gt;name);
+
+      p1=(char*)&quot;&quot;;
+      p=strstr(pa_device_hostapi,&quot;MME&quot;);
+      if(p!=NULL) p1=(char*)&quot;MME&quot;;
+      p=strstr(pa_device_hostapi,&quot;Direct&quot;);
+      if(p!=NULL) p1=(char*)&quot;DirectX&quot;;
+      p=strstr(pa_device_hostapi,&quot;WASAPI&quot;);
+      if(p!=NULL) p1=(char*)&quot;WASAPI&quot;;
+      p=strstr(pa_device_hostapi,&quot;ASIO&quot;);
+      if(p!=NULL) p1=(char*)&quot;ASIO&quot;;
+      p=strstr(pa_device_hostapi,&quot;WDM-KS&quot;);
+      if(p!=NULL) p1=(char*)&quot;WDM-KS&quot;;
+
+      sprintf(p2,&quot;%2d   %-8s  %-39s&quot;,id,p1,pa_device_name);
+      QString t(p2);
+      ui.comboBoxSndOut-&gt;addItem(t);
+    }
+  }
+
+  ui.myCallEntry-&gt;setText(m_myCall);
+  ui.myGridEntry-&gt;setText(m_myGrid);
+  ui.idIntSpinBox-&gt;setValue(m_idInt);
+  ui.pttComboBox-&gt;setCurrentIndex(m_pttPort);
+  ui.astroFont-&gt;setValue(m_astroFont);
+  ui.cbXpol-&gt;setChecked(m_xpol);
+  ui.rbAntennaX-&gt;setChecked(m_xpolx);
+  ui.saveDirEntry-&gt;setText(m_saveDir);
+  ui.azelDirEntry-&gt;setText(m_azelDir);
+  ui.dxccEntry-&gt;setText(m_dxccPfx);
+  ui.timeoutSpinBox-&gt;setValue(m_timeout);
+  ui.dPhiSpinBox-&gt;setValue(m_dPhi);
+  ui.fCalSpinBox-&gt;setValue(m_fCal);
+  ui.faddEntry-&gt;setText(QString::number(m_fAdd,'f',3));
+  ui.networkRadioButton-&gt;setChecked(m_network);
+  ui.soundCardRadioButton-&gt;setChecked(!m_network);
+  ui.rb96000-&gt;setChecked(m_fs96000);
+  ui.rb95238-&gt;setChecked(!m_fs96000);
+  ui.comboBoxSndIn-&gt;setEnabled(!m_network);
+  ui.comboBoxSndIn-&gt;setCurrentIndex(m_nDevIn);
+  ui.comboBoxSndOut-&gt;setCurrentIndex(m_nDevOut);
+  ui.sbPort-&gt;setValue(m_udpPort);
+  ui.cbIQswap-&gt;setChecked(m_IQswap);
+  ui.cb10db-&gt;setChecked(m_10db);
+  ui.cbInitIQplus-&gt;setChecked(m_initIQplus);
+  ui.mult570SpinBox-&gt;setValue(m_mult570);
+  ui.cal570SpinBox-&gt;setValue(m_cal570);
+  sscanf(m_colors.toAscii(),&quot;%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x&quot;,
+         &amp;r,&amp;g,&amp;b,&amp;r0,&amp;g0,&amp;b0,&amp;r1,&amp;g1,&amp;b1,&amp;r2,&amp;g2,&amp;b2,&amp;r3,&amp;g3,&amp;b3);
+  updateColorLabels();
+  ui.sbBackgroundRed-&gt;setValue(r);
+  ui.sbBackgroundGreen-&gt;setValue(g);
+  ui.sbBackgroundBlue-&gt;setValue(b);
+  ui.sbRed0-&gt;setValue(r0);
+  ui.sbRed1-&gt;setValue(r1);
+  ui.sbRed2-&gt;setValue(r2);
+  ui.sbRed3-&gt;setValue(r3);
+  ui.sbGreen0-&gt;setValue(g0);
+  ui.sbGreen1-&gt;setValue(g1);
+  ui.sbGreen2-&gt;setValue(g2);
+  ui.sbGreen3-&gt;setValue(g3);
+  ui.sbBlue0-&gt;setValue(b0);
+  ui.sbBlue1-&gt;setValue(b1);
+  ui.sbBlue2-&gt;setValue(b2);
+  ui.sbBlue3-&gt;setValue(b3);
+
+  m_paInDevice=m_inDevList[m_nDevIn];
+  m_paOutDevice=m_outDevList[m_nDevOut];
+
+}
+
+//------------------------------------------------------- accept()
+void DevSetup::accept()
+{
+  // Called when OK button is clicked.
+  // Check to see whether SoundInThread must be restarted,
+  // and save user parameters.
+
+  if(m_network!=ui.networkRadioButton-&gt;isChecked() or
+     m_nDevIn!=ui.comboBoxSndIn-&gt;currentIndex() or
+     m_paInDevice!=m_inDevList[m_nDevIn] or
+     m_xpol!=ui.cbXpol-&gt;isChecked() or
+     m_udpPort!=ui.sbPort-&gt;value()) m_restartSoundIn=true;
+
+  if(m_nDevOut!=ui.comboBoxSndOut-&gt;currentIndex() or
+     m_paOutDevice!=m_outDevList[m_nDevOut]) m_restartSoundOut=true;
+
+  m_myCall=ui.myCallEntry-&gt;text();
+  m_myGrid=ui.myGridEntry-&gt;text();
+  m_idInt=ui.idIntSpinBox-&gt;value();
+  m_pttPort=ui.pttComboBox-&gt;currentIndex();
+  m_astroFont=ui.astroFont-&gt;value();
+  m_xpol=ui.cbXpol-&gt;isChecked();
+  m_xpolx=ui.rbAntennaX-&gt;isChecked();
+  m_saveDir=ui.saveDirEntry-&gt;text();
+  m_azelDir=ui.azelDirEntry-&gt;text();
+  m_dxccPfx=ui.dxccEntry-&gt;text();
+  m_timeout=ui.timeoutSpinBox-&gt;value();
+  m_dPhi=ui.dPhiSpinBox-&gt;value();
+  m_fCal=ui.fCalSpinBox-&gt;value();
+  m_fAdd=ui.faddEntry-&gt;text().toDouble();
+  m_network=ui.networkRadioButton-&gt;isChecked();
+  m_fs96000=ui.rb96000-&gt;isChecked();
+  m_nDevIn=ui.comboBoxSndIn-&gt;currentIndex();
+  m_paInDevice=m_inDevList[m_nDevIn];
+  m_nDevOut=ui.comboBoxSndOut-&gt;currentIndex();
+  m_paOutDevice=m_outDevList[m_nDevOut];
+  m_udpPort=ui.sbPort-&gt;value();
+  m_IQswap=ui.cbIQswap-&gt;isChecked();
+  m_10db=ui.cb10db-&gt;isChecked();
+  m_initIQplus=ui.cbInitIQplus-&gt;isChecked();
+  m_mult570=ui.mult570SpinBox-&gt;value();
+  m_cal570=ui.cal570SpinBox-&gt;value();
+
+  QDialog::accept();
+}
+
+void DevSetup::on_soundCardRadioButton_toggled(bool checked)
+{
+  ui.comboBoxSndIn-&gt;setEnabled(ui.soundCardRadioButton-&gt;isChecked());
+  ui.rb96000-&gt;setChecked(checked);
+  ui.rb95238-&gt;setEnabled(!checked);
+  ui.label_InputDev-&gt;setEnabled(checked);
+  ui.label_Port-&gt;setEnabled(!checked);
+  ui.sbPort-&gt;setEnabled(!checked);
+  ui.cbIQswap-&gt;setEnabled(checked);
+  ui.cb10db-&gt;setEnabled(checked);
+}
+
+void DevSetup::on_cbXpol_stateChanged(int n)
+{
+  m_xpol = (n!=0);
+  ui.rbAntenna-&gt;setEnabled(m_xpol);
+  ui.rbAntennaX-&gt;setEnabled(m_xpol);
+  ui.dPhiSpinBox-&gt;setEnabled(m_xpol);
+  ui.labelDphi-&gt;setEnabled(m_xpol);
+}
+
+void DevSetup::on_cal570SpinBox_valueChanged(double ppm)
+{
+  m_cal570=ppm;
+}
+
+void DevSetup::on_mult570SpinBox_valueChanged(int mult)
+{
+  m_mult570=mult;
+}
+
+void DevSetup::updateColorLabels()
+{
+  QString t;
+  int r=ui.sbBackgroundRed-&gt;value();
+  int g=ui.sbBackgroundGreen-&gt;value();
+  int b=ui.sbBackgroundBlue-&gt;value();
+  int r0=ui.sbRed0-&gt;value();
+  int r1=ui.sbRed1-&gt;value();
+  int r2=ui.sbRed2-&gt;value();
+  int r3=ui.sbRed3-&gt;value();
+  int g0=ui.sbGreen0-&gt;value();
+  int g1=ui.sbGreen1-&gt;value();
+  int g2=ui.sbGreen2-&gt;value();
+  int g3=ui.sbGreen3-&gt;value();
+  int b0=ui.sbBlue0-&gt;value();
+  int b1=ui.sbBlue1-&gt;value();
+  int b2=ui.sbBlue2-&gt;value();
+  int b3=ui.sbBlue3-&gt;value();
+
+  t.sprintf(&quot;QLabel{background-color: #%2.2x%2.2x%2.2x;&quot;
+            &quot;color: #%2.2x%2.2x%2.2x}&quot;,r,g,b,r0,g0,b0);
+  ui.lab0-&gt;setStyleSheet(t);
+  t.sprintf(&quot;QLabel{background-color: #%2.2x%2.2x%2.2x;&quot;
+            &quot;color: #%2.2x%2.2x%2.2x}&quot;,r,g,b,r1,g1,b1);
+  ui.lab1-&gt;setStyleSheet(t);
+  t.sprintf(&quot;QLabel{background-color: #%2.2x%2.2x%2.2x;&quot;
+            &quot;color: #%2.2x%2.2x%2.2x}&quot;,r,g,b,r2,g2,b2);
+  ui.lab2-&gt;setStyleSheet(t);
+  t.sprintf(&quot;QLabel{background-color: #%2.2x%2.2x%2.2x;&quot;
+            &quot;color: #%2.2x%2.2x%2.2x}&quot;,r,g,b,r3,g3,b3);
+  ui.lab3-&gt;setStyleSheet(t);
+
+  m_colors.sprintf(&quot;%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x&quot;
+            &quot;%2.2x%2.2x%2.2x&quot;,r,g,b,r0,g0,b0,r1,g1,b1,r2,g2,b2,r3,g3,b3);
+}
+
+void DevSetup::on_sbBackgroundRed_valueChanged(int r)
+{
+  updateColorLabels();
+}
+
+void DevSetup::on_sbBackgroundGreen_valueChanged(int g)
+{
+  updateColorLabels();
+}
+
+void DevSetup::on_sbBackgroundBlue_valueChanged(int b)
+{
+  updateColorLabels();
+}
+
+
+void DevSetup::on_sbRed0_valueChanged(int arg1)
+{
+  updateColorLabels();
+}
+
+void DevSetup::on_sbGreen0_valueChanged(int arg1)
+{
+  updateColorLabels();
+}
+
+void DevSetup::on_sbBlue0_valueChanged(int arg1)
+{
+  updateColorLabels();
+}
+
+void DevSetup::on_sbRed1_valueChanged(int arg1)
+{
+   updateColorLabels();
+}
+
+void DevSetup::on_sbGreen1_valueChanged(int arg1)
+{
+  updateColorLabels();
+}
+
+void DevSetup::on_sbBlue1_valueChanged(int arg1)
+{
+   updateColorLabels();
+}
+
+void DevSetup::on_sbRed2_valueChanged(int arg1)
+{
+   updateColorLabels();
+}
+
+void DevSetup::on_sbGreen2_valueChanged(int arg1)
+{
+   updateColorLabels();
+}
+
+void DevSetup::on_sbBlue2_valueChanged(int arg1)
+{
+   updateColorLabels();
+}
+
+void DevSetup::on_sbRed3_valueChanged(int arg1)
+{
+  updateColorLabels();
+}
+
+void DevSetup::on_sbGreen3_valueChanged(int arg1)
+{
+  updateColorLabels();
+}
+
+void DevSetup::on_sbBlue3_valueChanged(int arg1)
+{
+  updateColorLabels();
+}
+
+void DevSetup::on_pushButton_5_clicked()
+{
+  QColor color = QColorDialog::getColor(Qt::green, this);
+  if (color.isValid()) {
+  }
+}


Property changes on: branches/map65/devsetup.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/devsetup.h
===================================================================
--- branches/map65/devsetup.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/devsetup.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,83 +1,83 @@
-#ifndef DEVSETUP_H
-#define DEVSETUP_H
-
-#include &lt;QDialog&gt;
-#include &quot;ui_devsetup.h&quot;
-
-class DevSetup : public QDialog
-{
-  Q_OBJECT
-public:
-  DevSetup(QWidget *parent=0);
-  ~DevSetup();
-
-  void initDlg();
-  qint32  m_idInt;
-  qint32  m_pttPort;
-  qint32  m_nDevIn;
-  qint32  m_nDevOut;
-  qint32  m_inDevList[100];
-  qint32  m_outDevList[100];
-  qint32  m_paInDevice;
-  qint32  m_paOutDevice;
-  qint32  m_timeout;
-  qint32  m_dPhi;
-  qint32  m_fCal;
-  qint32  m_udpPort;
-  qint32  m_astroFont;
-  qint32  m_mult570;
-
-  double  m_fAdd;
-  double  m_cal570;
-
-  bool    m_xpolx;
-  bool    m_network;
-  bool    m_fs96000;
-  bool    m_xpol;
-  bool    m_IQswap;
-  bool    m_restartSoundIn;
-  bool    m_restartSoundOut;
-  bool    m_10db;
-  bool    m_initIQplus;
-
-  QString m_myCall;
-  QString m_myGrid;
-  QString m_saveDir;
-  QString m_azelDir;
-  QString m_dxccPfx;
-  QString m_colors;
-
-  QColor  m_colorBackground;
-
-public slots:
-  void accept();
-
-private slots:
-  void on_soundCardRadioButton_toggled(bool checked);
-  void on_cbXpol_stateChanged(int arg1);
-  void on_cal570SpinBox_valueChanged(double ppm);
-  void on_mult570SpinBox_valueChanged(int mult);
-  void on_sbBackgroundRed_valueChanged(int arg1);
-  void on_sbBackgroundGreen_valueChanged(int arg1);
-  void on_sbBackgroundBlue_valueChanged(int arg1);
-  void updateColorLabels(void);
-  void on_sbRed0_valueChanged(int arg1);
-  void on_sbGreen0_valueChanged(int arg1);
-  void on_sbBlue0_valueChanged(int arg1);
-  void on_sbRed1_valueChanged(int arg1);
-  void on_sbGreen1_valueChanged(int arg1);
-  void on_sbBlue1_valueChanged(int arg1);
-  void on_sbRed2_valueChanged(int arg1);
-  void on_sbGreen2_valueChanged(int arg1);
-  void on_sbBlue2_valueChanged(int arg1);
-  void on_sbRed3_valueChanged(int arg1);
-  void on_sbGreen3_valueChanged(int arg1);
-  void on_sbBlue3_valueChanged(int arg1);
-  void on_pushButton_5_clicked();
-
-private:
-  int r,g,b,r0,g0,b0,r1,g1,b1,r2,g2,b2,r3,g3,b3;
-  Ui::DialogSndCard ui;
-};
-
-#endif // DEVSETUP_H
+#ifndef DEVSETUP_H
+#define DEVSETUP_H
+
+#include &lt;QDialog&gt;
+#include &quot;ui_devsetup.h&quot;
+
+class DevSetup : public QDialog
+{
+  Q_OBJECT
+public:
+  DevSetup(QWidget *parent=0);
+  ~DevSetup();
+
+  void initDlg();
+  qint32  m_idInt;
+  qint32  m_pttPort;
+  qint32  m_nDevIn;
+  qint32  m_nDevOut;
+  qint32  m_inDevList[100];
+  qint32  m_outDevList[100];
+  qint32  m_paInDevice;
+  qint32  m_paOutDevice;
+  qint32  m_timeout;
+  qint32  m_dPhi;
+  qint32  m_fCal;
+  qint32  m_udpPort;
+  qint32  m_astroFont;
+  qint32  m_mult570;
+
+  double  m_fAdd;
+  double  m_cal570;
+
+  bool    m_xpolx;
+  bool    m_network;
+  bool    m_fs96000;
+  bool    m_xpol;
+  bool    m_IQswap;
+  bool    m_restartSoundIn;
+  bool    m_restartSoundOut;
+  bool    m_10db;
+  bool    m_initIQplus;
+
+  QString m_myCall;
+  QString m_myGrid;
+  QString m_saveDir;
+  QString m_azelDir;
+  QString m_dxccPfx;
+  QString m_colors;
+
+  QColor  m_colorBackground;
+
+public slots:
+  void accept();
+
+private slots:
+  void on_soundCardRadioButton_toggled(bool checked);
+  void on_cbXpol_stateChanged(int arg1);
+  void on_cal570SpinBox_valueChanged(double ppm);
+  void on_mult570SpinBox_valueChanged(int mult);
+  void on_sbBackgroundRed_valueChanged(int arg1);
+  void on_sbBackgroundGreen_valueChanged(int arg1);
+  void on_sbBackgroundBlue_valueChanged(int arg1);
+  void updateColorLabels(void);
+  void on_sbRed0_valueChanged(int arg1);
+  void on_sbGreen0_valueChanged(int arg1);
+  void on_sbBlue0_valueChanged(int arg1);
+  void on_sbRed1_valueChanged(int arg1);
+  void on_sbGreen1_valueChanged(int arg1);
+  void on_sbBlue1_valueChanged(int arg1);
+  void on_sbRed2_valueChanged(int arg1);
+  void on_sbGreen2_valueChanged(int arg1);
+  void on_sbBlue2_valueChanged(int arg1);
+  void on_sbRed3_valueChanged(int arg1);
+  void on_sbGreen3_valueChanged(int arg1);
+  void on_sbBlue3_valueChanged(int arg1);
+  void on_pushButton_5_clicked();
+
+private:
+  int r,g,b,r0,g0,b0,r1,g1,b1,r2,g2,b2,r3,g3,b3;
+  Ui::DialogSndCard ui;
+};
+
+#endif // DEVSETUP_H


Property changes on: branches/map65/devsetup.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/displaytext.cpp
===================================================================
--- branches/map65/displaytext.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/displaytext.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,15 +1,15 @@
-#include &quot;displaytext.h&quot;
-#include &lt;QDebug&gt;
-#include &lt;QMouseEvent&gt;
-
-DisplayText::DisplayText(QWidget *parent) :
-    QTextBrowser(parent)
-{
-}
-
-void DisplayText::mouseDoubleClickEvent(QMouseEvent *e)
-{
-  bool ctrl = (e-&gt;modifiers() &amp; 0x4000000);
-  emit(selectCallsign(ctrl));
-  QTextBrowser::mouseDoubleClickEvent(e);
-}
+#include &quot;displaytext.h&quot;
+#include &lt;QDebug&gt;
+#include &lt;QMouseEvent&gt;
+
+DisplayText::DisplayText(QWidget *parent) :
+    QTextBrowser(parent)
+{
+}
+
+void DisplayText::mouseDoubleClickEvent(QMouseEvent *e)
+{
+  bool ctrl = (e-&gt;modifiers() &amp; 0x4000000);
+  emit(selectCallsign(ctrl));
+  QTextBrowser::mouseDoubleClickEvent(e);
+}


Property changes on: branches/map65/displaytext.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/displaytext.h
===================================================================
--- branches/map65/displaytext.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/displaytext.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,22 +1,22 @@
-#ifndef DISPLAYTEXT_H
-#define DISPLAYTEXT_H
-
-#include &lt;QTextBrowser&gt;
-
-class DisplayText : public QTextBrowser
-{
-    Q_OBJECT
-public:
-    explicit DisplayText(QWidget *parent = 0);
-
-signals:
-  void selectCallsign(bool ctrl);
-
-public slots:
-
-protected:
-  void mouseDoubleClickEvent(QMouseEvent *e);
-
-};
-
-#endif // DISPLAYTEXT_H
+#ifndef DISPLAYTEXT_H
+#define DISPLAYTEXT_H
+
+#include &lt;QTextBrowser&gt;
+
+class DisplayText : public QTextBrowser
+{
+    Q_OBJECT
+public:
+    explicit DisplayText(QWidget *parent = 0);
+
+signals:
+  void selectCallsign(bool ctrl);
+
+public slots:
+
+protected:
+  void mouseDoubleClickEvent(QMouseEvent *e);
+
+};
+
+#endif // DISPLAYTEXT_H


Property changes on: branches/map65/displaytext.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/ffft.f
===================================================================
--- branches/map65/ffft.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/ffft.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,69 +1,69 @@
-	subroutine ffft(d,npts,isign,ireal)
-
-C  Fourier transform of length npts=2**k, performed in place.
-C  Input data in array d, treated as complex if ireal=0, and as real if ireal=1.
-C  In either case the transform values are returned in array d, treated as
-C  complex. The DC term is d(1), and d(npts/2+1) is the term at the Nyquist
-C  frequency.  The basic algorithm is the same as Norm Brenner's FOUR1, and
-C  uses radix-2 transforms.
-
-C  J. H. Taylor, Princeton University.
-
-	complex d(npts),t,w,wstep,tt,uu
-	data pi/3.14159265359/
-
-C  Shuffle the data to bit-reversed order.
-
-	imax=npts/(ireal+1)
-	irev=1
-	do 5 i=1,imax
-	if(i.ge.irev) go to 2
-	t=d(i)
-	d(i)=d(irev)
-	d(irev)=t
-2	mmax=imax/2
-3	if(irev.le.mmax) go to 5
-	irev=irev-mmax
-	mmax=mmax/2
-	if(mmax.ge.1) go to 3
-5	irev=irev+mmax
-
-C  The radix-2 transform begins here.
-
-	api=isign*pi/2.
-	mmax=1
-6	istep=2*mmax
-	wstep=cmplx(-2.*sin(api/mmax)**2,sin(2.*api/mmax))
-	w=1.
-	do 9 m=1,mmax
-
-C  This in the inner-most loop -- optimization here is important!
-	do 8 i=m,imax,istep
-	t=w*d(i+mmax)
-	d(i+mmax)=d(i)-t
-8	d(i)=d(i)+t
-
-9	w=w*(1.+wstep)
-	mmax=istep
-	if(mmax.lt.imax) go to 6
-
-	if(ireal.eq.0) return
-
-C  Now complete the last stage of a doubled-up real transform.
-
-	jmax=imax/2 + 1
-	wstep=cmplx(-2.*sin(isign*pi/npts)**2,sin(isign*pi/imax))
-	w=1.0
-	d(imax+1)=d(1)
-
-	do 10 j=1,jmax
-	uu=cmplx(real(d(j))+real(d(2+imax-j)),aimag(d(j)) - 
-     +    aimag(d(2+imax-j)))
-	tt=w*cmplx(aimag(d(j))+aimag(d(2+imax-j)),-real(d(j)) +
-     +    real(d(2+imax-j)))
-	d(j)=uu+tt
-	d(2+imax-j)=conjg(uu-tt)
-10	w=w*(1.+wstep)
-
-	return
-	end
+	subroutine ffft(d,npts,isign,ireal)
+
+C  Fourier transform of length npts=2**k, performed in place.
+C  Input data in array d, treated as complex if ireal=0, and as real if ireal=1.
+C  In either case the transform values are returned in array d, treated as
+C  complex. The DC term is d(1), and d(npts/2+1) is the term at the Nyquist
+C  frequency.  The basic algorithm is the same as Norm Brenner's FOUR1, and
+C  uses radix-2 transforms.
+
+C  J. H. Taylor, Princeton University.
+
+	complex d(npts),t,w,wstep,tt,uu
+	data pi/3.14159265359/
+
+C  Shuffle the data to bit-reversed order.
+
+	imax=npts/(ireal+1)
+	irev=1
+	do 5 i=1,imax
+	if(i.ge.irev) go to 2
+	t=d(i)
+	d(i)=d(irev)
+	d(irev)=t
+2	mmax=imax/2
+3	if(irev.le.mmax) go to 5
+	irev=irev-mmax
+	mmax=mmax/2
+	if(mmax.ge.1) go to 3
+5	irev=irev+mmax
+
+C  The radix-2 transform begins here.
+
+	api=isign*pi/2.
+	mmax=1
+6	istep=2*mmax
+	wstep=cmplx(-2.*sin(api/mmax)**2,sin(2.*api/mmax))
+	w=1.
+	do 9 m=1,mmax
+
+C  This in the inner-most loop -- optimization here is important!
+	do 8 i=m,imax,istep
+	t=w*d(i+mmax)
+	d(i+mmax)=d(i)-t
+8	d(i)=d(i)+t
+
+9	w=w*(1.+wstep)
+	mmax=istep
+	if(mmax.lt.imax) go to 6
+
+	if(ireal.eq.0) return
+
+C  Now complete the last stage of a doubled-up real transform.
+
+	jmax=imax/2 + 1
+	wstep=cmplx(-2.*sin(isign*pi/npts)**2,sin(isign*pi/imax))
+	w=1.0
+	d(imax+1)=d(1)
+
+	do 10 j=1,jmax
+	uu=cmplx(real(d(j))+real(d(2+imax-j)),aimag(d(j)) - 
+     +    aimag(d(2+imax-j)))
+	tt=w*cmplx(aimag(d(j))+aimag(d(2+imax-j)),-real(d(j)) +
+     +    real(d(2+imax-j)))
+	d(j)=uu+tt
+	d(2+imax-j)=conjg(uu-tt)
+10	w=w*(1.+wstep)
+
+	return
+	end


Property changes on: branches/map65/ffft.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/fftw3.f
===================================================================
--- branches/map65/fftw3.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/fftw3.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,64 +1,64 @@
-      INTEGER FFTW_R2HC
-      PARAMETER (FFTW_R2HC=0)
-      INTEGER FFTW_HC2R
-      PARAMETER (FFTW_HC2R=1)
-      INTEGER FFTW_DHT
-      PARAMETER (FFTW_DHT=2)
-      INTEGER FFTW_REDFT00
-      PARAMETER (FFTW_REDFT00=3)
-      INTEGER FFTW_REDFT01
-      PARAMETER (FFTW_REDFT01=4)
-      INTEGER FFTW_REDFT10
-      PARAMETER (FFTW_REDFT10=5)
-      INTEGER FFTW_REDFT11
-      PARAMETER (FFTW_REDFT11=6)
-      INTEGER FFTW_RODFT00
-      PARAMETER (FFTW_RODFT00=7)
-      INTEGER FFTW_RODFT01
-      PARAMETER (FFTW_RODFT01=8)
-      INTEGER FFTW_RODFT10
-      PARAMETER (FFTW_RODFT10=9)
-      INTEGER FFTW_RODFT11
-      PARAMETER (FFTW_RODFT11=10)
-      INTEGER FFTW_FORWARD
-      PARAMETER (FFTW_FORWARD=-1)
-      INTEGER FFTW_BACKWARD
-      PARAMETER (FFTW_BACKWARD=+1)
-      INTEGER FFTW_MEASURE
-      PARAMETER (FFTW_MEASURE=0)
-      INTEGER FFTW_DESTROY_INPUT
-      PARAMETER (FFTW_DESTROY_INPUT=1)
-      INTEGER FFTW_UNALIGNED
-      PARAMETER (FFTW_UNALIGNED=2)
-      INTEGER FFTW_CONSERVE_MEMORY
-      PARAMETER (FFTW_CONSERVE_MEMORY=4)
-      INTEGER FFTW_EXHAUSTIVE
-      PARAMETER (FFTW_EXHAUSTIVE=8)
-      INTEGER FFTW_PRESERVE_INPUT
-      PARAMETER (FFTW_PRESERVE_INPUT=16)
-      INTEGER FFTW_PATIENT
-      PARAMETER (FFTW_PATIENT=32)
-      INTEGER FFTW_ESTIMATE
-      PARAMETER (FFTW_ESTIMATE=64)
-      INTEGER FFTW_ESTIMATE_PATIENT
-      PARAMETER (FFTW_ESTIMATE_PATIENT=128)
-      INTEGER FFTW_BELIEVE_PCOST
-      PARAMETER (FFTW_BELIEVE_PCOST=256)
-      INTEGER FFTW_DFT_R2HC_ICKY
-      PARAMETER (FFTW_DFT_R2HC_ICKY=512)
-      INTEGER FFTW_NONTHREADED_ICKY
-      PARAMETER (FFTW_NONTHREADED_ICKY=1024)
-      INTEGER FFTW_NO_BUFFERING
-      PARAMETER (FFTW_NO_BUFFERING=2048)
-      INTEGER FFTW_NO_INDIRECT_OP
-      PARAMETER (FFTW_NO_INDIRECT_OP=4096)
-      INTEGER FFTW_ALLOW_LARGE_GENERIC
-      PARAMETER (FFTW_ALLOW_LARGE_GENERIC=8192)
-      INTEGER FFTW_NO_RANK_SPLITS
-      PARAMETER (FFTW_NO_RANK_SPLITS=16384)
-      INTEGER FFTW_NO_VRANK_SPLITS
-      PARAMETER (FFTW_NO_VRANK_SPLITS=32768)
-      INTEGER FFTW_NO_VRECURSE
-      PARAMETER (FFTW_NO_VRECURSE=65536)
-      INTEGER FFTW_NO_SIMD
-      PARAMETER (FFTW_NO_SIMD=131072)
+      INTEGER FFTW_R2HC
+      PARAMETER (FFTW_R2HC=0)
+      INTEGER FFTW_HC2R
+      PARAMETER (FFTW_HC2R=1)
+      INTEGER FFTW_DHT
+      PARAMETER (FFTW_DHT=2)
+      INTEGER FFTW_REDFT00
+      PARAMETER (FFTW_REDFT00=3)
+      INTEGER FFTW_REDFT01
+      PARAMETER (FFTW_REDFT01=4)
+      INTEGER FFTW_REDFT10
+      PARAMETER (FFTW_REDFT10=5)
+      INTEGER FFTW_REDFT11
+      PARAMETER (FFTW_REDFT11=6)
+      INTEGER FFTW_RODFT00
+      PARAMETER (FFTW_RODFT00=7)
+      INTEGER FFTW_RODFT01
+      PARAMETER (FFTW_RODFT01=8)
+      INTEGER FFTW_RODFT10
+      PARAMETER (FFTW_RODFT10=9)
+      INTEGER FFTW_RODFT11
+      PARAMETER (FFTW_RODFT11=10)
+      INTEGER FFTW_FORWARD
+      PARAMETER (FFTW_FORWARD=-1)
+      INTEGER FFTW_BACKWARD
+      PARAMETER (FFTW_BACKWARD=+1)
+      INTEGER FFTW_MEASURE
+      PARAMETER (FFTW_MEASURE=0)
+      INTEGER FFTW_DESTROY_INPUT
+      PARAMETER (FFTW_DESTROY_INPUT=1)
+      INTEGER FFTW_UNALIGNED
+      PARAMETER (FFTW_UNALIGNED=2)
+      INTEGER FFTW_CONSERVE_MEMORY
+      PARAMETER (FFTW_CONSERVE_MEMORY=4)
+      INTEGER FFTW_EXHAUSTIVE
+      PARAMETER (FFTW_EXHAUSTIVE=8)
+      INTEGER FFTW_PRESERVE_INPUT
+      PARAMETER (FFTW_PRESERVE_INPUT=16)
+      INTEGER FFTW_PATIENT
+      PARAMETER (FFTW_PATIENT=32)
+      INTEGER FFTW_ESTIMATE
+      PARAMETER (FFTW_ESTIMATE=64)
+      INTEGER FFTW_ESTIMATE_PATIENT
+      PARAMETER (FFTW_ESTIMATE_PATIENT=128)
+      INTEGER FFTW_BELIEVE_PCOST
+      PARAMETER (FFTW_BELIEVE_PCOST=256)
+      INTEGER FFTW_DFT_R2HC_ICKY
+      PARAMETER (FFTW_DFT_R2HC_ICKY=512)
+      INTEGER FFTW_NONTHREADED_ICKY
+      PARAMETER (FFTW_NONTHREADED_ICKY=1024)
+      INTEGER FFTW_NO_BUFFERING
+      PARAMETER (FFTW_NO_BUFFERING=2048)
+      INTEGER FFTW_NO_INDIRECT_OP
+      PARAMETER (FFTW_NO_INDIRECT_OP=4096)
+      INTEGER FFTW_ALLOW_LARGE_GENERIC
+      PARAMETER (FFTW_ALLOW_LARGE_GENERIC=8192)
+      INTEGER FFTW_NO_RANK_SPLITS
+      PARAMETER (FFTW_NO_RANK_SPLITS=16384)
+      INTEGER FFTW_NO_VRANK_SPLITS
+      PARAMETER (FFTW_NO_VRANK_SPLITS=32768)
+      INTEGER FFTW_NO_VRECURSE
+      PARAMETER (FFTW_NO_VRECURSE=65536)
+      INTEGER FFTW_NO_SIMD
+      PARAMETER (FFTW_NO_SIMD=131072)


Property changes on: branches/map65/fftw3.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/getdev.cpp
===================================================================
--- branches/map65/getdev.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/getdev.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,259 +1,259 @@
-#include &lt;stdio.h&gt;
-#define MAXDEVICES 100
-#include &lt;string.h&gt;
-#include &lt;portaudio.h&gt;
-#include &lt;QDebug&gt;
-
-//------------------------------------------------------- pa_get_device_info
-int pa_get_device_info (int  n,
-                        void *pa_device_name,
-                        void *pa_device_hostapi,
-                        double *pa_device_max_speed,
-                        double *pa_device_min_speed,
-                        int *pa_device_max_bytes,
-                        int *pa_device_min_bytes,
-                        int *pa_device_max_channels,
-                        int *pa_device_min_channels )
-{
-
-  (void) n ;
-  (void) pa_device_name;
-  (void) pa_device_hostapi;
-  (void) pa_device_max_speed;
-  (void) pa_device_min_speed;
-  (void) pa_device_max_bytes;
-  (void) pa_device_min_bytes;
-  (void) pa_device_max_channels;
-  (void) pa_device_min_channels;
-  const PaDeviceInfo *deviceInfo;
-  PaError pa_err;
-  PaStreamParameters inputParameters;
-  int i,j, speed_warning;
-  int minBytes, maxBytes;
-  double maxStandardSampleRate;
-  double minStandardSampleRate;
-  int minInputChannels;
-  int maxInputChannels;
-
-// negative terminated  list
-  static double standardSampleRates[] = {8000.0, 9600.0,
-        11025.0, 12000.0, 16000.0, 22050.0, 24000.0, 32000.0,
-        44100.0, 48000.0, 88200.0, 96000.0, 192000.0, -1};
-// *******************************************************
-
-
-  *pa_device_max_speed=0;
-  *pa_device_min_speed=0;
-  *pa_device_max_bytes=0;
-  *pa_device_min_bytes=0;
-  *pa_device_max_channels=0;
-  *pa_device_min_channels=0;
-  minInputChannels=0;
-  if(n &gt;= Pa_GetDeviceCount() ) return -1;
-  deviceInfo = Pa_GetDeviceInfo(n);
-  if (deviceInfo-&gt;maxInputChannels==0) return -1;
-  sprintf((char*)(pa_device_name),&quot;%s&quot;,deviceInfo-&gt;name);
-  sprintf((char*)(pa_device_hostapi),&quot;%s&quot;,
-          Pa_GetHostApiInfo( deviceInfo-&gt;hostApi )-&gt;name);
-  speed_warning=0;
-
-// bypass bug in Juli@ ASIO driver:
-// this driver hangs after a Pa_IsFormatSupported call
-  i = strncmp(deviceInfo-&gt;name, &quot;ASIO 2.0 - ESI Juli@&quot;, 19);
-  if (i == 0) {
-    minStandardSampleRate=44100;
-    maxStandardSampleRate=192000;
-    minBytes=1;
-    maxBytes=4;
-    maxInputChannels= deviceInfo-&gt;maxInputChannels;
-    minInputChannels= 1;
-    goto end_pa_get_device_info;
-  }
-
-// Investigate device capabilities.
-// Check min and max samplerates  with 16 bit data.
-  maxStandardSampleRate=0;
-  minStandardSampleRate=0;
-  inputParameters.device = n;
-  inputParameters.channelCount = deviceInfo-&gt;maxInputChannels;
-  inputParameters.sampleFormat = paInt16;
-  inputParameters.suggestedLatency = 0;
-  inputParameters.hostApiSpecificStreamInfo = NULL;
-
-// ************************************************************************
-//filter for portaudio Windows hostapi's with non experts.
-//only allow ASIO or WASAPI or WDM-KS
-  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name, &quot;ASIO&quot;, 4);
-  if (i==0 ) goto end_filter_hostapi;
-  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name,
-              &quot;Windows WASAPI&quot;, 14);
-  if (i==0 ) goto end_filter_hostapi;
-  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name,
-              &quot;Windows WDM-KS&quot;, 14);
-  if (i==0 ) goto end_filter_hostapi;
-  speed_warning=1;
-end_filter_hostapi:;
-
-// ************************************************************************
-  i=0;
-  while(standardSampleRates[i] &gt; 0 &amp;&amp; minStandardSampleRate==0) {
-    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
-                                standardSampleRates[i] );
-    if(pa_err == paDeviceUnavailable) return -1;
-    if(pa_err == paInvalidDevice) return -1;
-    if(pa_err == paFormatIsSupported ) {
-      minStandardSampleRate=standardSampleRates[i];
-    }
-    i++;
-  }
-  if(minStandardSampleRate == 0) return -1;
-  j=i;
-  while(standardSampleRates[i] &gt; 0 ) i++;
-  i--;
-
-  while(i &gt;= j &amp;&amp; maxStandardSampleRate==0) {
-    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
-                                  standardSampleRates[i] );
-    if(pa_err == paDeviceUnavailable) return -1;
-    if(pa_err == paInvalidDevice) return -1;
-    if( pa_err == paFormatIsSupported ) {
-      maxStandardSampleRate=standardSampleRates[i];
-    }
-    i--;
-  }
-
-// check if min SampleRate  = max SampleRate
-  if(maxStandardSampleRate==0 &amp;&amp; (minStandardSampleRate != 0)) {
-    maxStandardSampleRate= minStandardSampleRate;
-  }
-
-// check min and max bytes
-  minBytes=2;
-  maxBytes=2;
-  inputParameters.sampleFormat = paUInt8;
-  pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
-                                maxStandardSampleRate );
-  if( pa_err == paFormatIsSupported ) {
-    minBytes=1;
-  }
-    inputParameters.sampleFormat = paInt32;
-    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
-                                maxStandardSampleRate );
-  if( pa_err == paFormatIsSupported ) {
-    maxBytes=4;
-  }
-
-// check min channel count
-  maxInputChannels= deviceInfo-&gt;maxInputChannels;
-  inputParameters.channelCount = 1;
-  inputParameters.sampleFormat = paInt16;
-  pa_err=paFormatIsSupported+32000;
-  while(pa_err != paFormatIsSupported &amp;&amp;
-          ( inputParameters.channelCount &lt; (maxInputChannels+1)) ) {
-    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
-                                maxStandardSampleRate );
-    inputParameters.channelCount++;
-  }
-  if( pa_err == paFormatIsSupported ) {
-    minInputChannels=inputParameters.channelCount-1;
-  } else {
-    return -1;
-  }
-
-end_pa_get_device_info:;
-
-  *pa_device_max_speed=maxStandardSampleRate;
-  *pa_device_min_speed=minStandardSampleRate;
-  *pa_device_max_bytes=maxBytes;
-  *pa_device_min_bytes=minBytes;
-  *pa_device_max_channels= maxInputChannels;
-  *pa_device_min_channels= minInputChannels;
-
-  return speed_warning;
-}
-
-
-void paInputDevice(int id, char* hostAPI_DeviceName, int* minChan,
-                   int* maxChan, int* minSpeed, int* maxSpeed)
-{
-  int i;
-  char pa_device_name[128];
-  char pa_device_hostapi[128];
-  double pa_device_max_speed;
-  double pa_device_min_speed;
-  int pa_device_max_bytes;
-  int pa_device_min_bytes;
-  int pa_device_max_channels;
-  int pa_device_min_channels;
-  char p2[50];
-  char *p,*p1;
-  static int iret, valid_dev_cnt;
-
-  iret=pa_get_device_info (id,
-                          &amp;pa_device_name,
-                          &amp;pa_device_hostapi,
-                          &amp;pa_device_max_speed,
-                          &amp;pa_device_min_speed,
-                          &amp;pa_device_max_bytes,
-                          &amp;pa_device_min_bytes,
-                          &amp;pa_device_max_channels,
-                          &amp;pa_device_min_channels);
-
-  if (iret &gt;= 0 ) {
-    valid_dev_cnt++;
-
-    p1=(char*)&quot;&quot;;
-    p=strstr(pa_device_hostapi,&quot;MME&quot;);
-    if(p!=NULL) p1=(char*)&quot;MME&quot;;
-    p=strstr(pa_device_hostapi,&quot;Direct&quot;);
-    if(p!=NULL) p1=(char*)&quot;DirectX&quot;;
-    p=strstr(pa_device_hostapi,&quot;WASAPI&quot;);
-    if(p!=NULL) p1=(char*)&quot;WASAPI&quot;;
-    p=strstr(pa_device_hostapi,&quot;ASIO&quot;);
-    if(p!=NULL) p1=(char*)&quot;ASIO&quot;;
-    p=strstr(pa_device_hostapi,&quot;WDM-KS&quot;);
-    if(p!=NULL) p1=(char*)&quot;WDM-KS&quot;;
-
-    sprintf(p2,&quot;%-8s %-39s&quot;,p1,pa_device_name);
-    for(i=0; i&lt;50; i++) {
-      hostAPI_DeviceName[i]=p2[i];
-      if(p2[i]==0) break;
-    }
-    *minChan=pa_device_min_channels;
-    *maxChan=pa_device_max_channels;
-    *minSpeed=(int)pa_device_min_speed;
-    *maxSpeed=(int)pa_device_max_speed;
-  } else {
-    for(i=0; i&lt;50; i++) {
-      hostAPI_DeviceName[i]=0;
-    }
-    *minChan=0;
-    *maxChan=0;
-    *minSpeed=0;
-    *maxSpeed=0;
-  }
-}
-
-void getDev(int* numDevices0, char hostAPI_DeviceName[][50],
-            int minChan[], int maxChan[],
-            int minSpeed[], int maxSpeed[])
-{
-  int i,id,numDevices;
-  int minch,maxch,minsp,maxsp;
-  char apidev[256];
-
-  numDevices=Pa_GetDeviceCount();
-  *numDevices0=numDevices;
-
-  for(id=0; id&lt;numDevices; id++)  {
-    paInputDevice(id,apidev,&amp;minch,&amp;maxch,&amp;minsp,&amp;maxsp);
-    for(i=0; i&lt;50; i++) {
-      hostAPI_DeviceName[id][i]=apidev[i];
-    }
-    hostAPI_DeviceName[id][49]=0;
-    minChan[id]=minch;
-    maxChan[id]=maxch;
-    minSpeed[id]=minsp;
-    maxSpeed[id]=maxsp;
-  }
-}
+#include &lt;stdio.h&gt;
+#define MAXDEVICES 100
+#include &lt;string.h&gt;
+#include &lt;portaudio.h&gt;
+#include &lt;QDebug&gt;
+
+//------------------------------------------------------- pa_get_device_info
+int pa_get_device_info (int  n,
+                        void *pa_device_name,
+                        void *pa_device_hostapi,
+                        double *pa_device_max_speed,
+                        double *pa_device_min_speed,
+                        int *pa_device_max_bytes,
+                        int *pa_device_min_bytes,
+                        int *pa_device_max_channels,
+                        int *pa_device_min_channels )
+{
+
+  (void) n ;
+  (void) pa_device_name;
+  (void) pa_device_hostapi;
+  (void) pa_device_max_speed;
+  (void) pa_device_min_speed;
+  (void) pa_device_max_bytes;
+  (void) pa_device_min_bytes;
+  (void) pa_device_max_channels;
+  (void) pa_device_min_channels;
+  const PaDeviceInfo *deviceInfo;
+  PaError pa_err;
+  PaStreamParameters inputParameters;
+  int i,j, speed_warning;
+  int minBytes, maxBytes;
+  double maxStandardSampleRate;
+  double minStandardSampleRate;
+  int minInputChannels;
+  int maxInputChannels;
+
+// negative terminated  list
+  static double standardSampleRates[] = {8000.0, 9600.0,
+        11025.0, 12000.0, 16000.0, 22050.0, 24000.0, 32000.0,
+        44100.0, 48000.0, 88200.0, 96000.0, 192000.0, -1};
+// *******************************************************
+
+
+  *pa_device_max_speed=0;
+  *pa_device_min_speed=0;
+  *pa_device_max_bytes=0;
+  *pa_device_min_bytes=0;
+  *pa_device_max_channels=0;
+  *pa_device_min_channels=0;
+  minInputChannels=0;
+  if(n &gt;= Pa_GetDeviceCount() ) return -1;
+  deviceInfo = Pa_GetDeviceInfo(n);
+  if (deviceInfo-&gt;maxInputChannels==0) return -1;
+  sprintf((char*)(pa_device_name),&quot;%s&quot;,deviceInfo-&gt;name);
+  sprintf((char*)(pa_device_hostapi),&quot;%s&quot;,
+          Pa_GetHostApiInfo( deviceInfo-&gt;hostApi )-&gt;name);
+  speed_warning=0;
+
+// bypass bug in Juli@ ASIO driver:
+// this driver hangs after a Pa_IsFormatSupported call
+  i = strncmp(deviceInfo-&gt;name, &quot;ASIO 2.0 - ESI Juli@&quot;, 19);
+  if (i == 0) {
+    minStandardSampleRate=44100;
+    maxStandardSampleRate=192000;
+    minBytes=1;
+    maxBytes=4;
+    maxInputChannels= deviceInfo-&gt;maxInputChannels;
+    minInputChannels= 1;
+    goto end_pa_get_device_info;
+  }
+
+// Investigate device capabilities.
+// Check min and max samplerates  with 16 bit data.
+  maxStandardSampleRate=0;
+  minStandardSampleRate=0;
+  inputParameters.device = n;
+  inputParameters.channelCount = deviceInfo-&gt;maxInputChannels;
+  inputParameters.sampleFormat = paInt16;
+  inputParameters.suggestedLatency = 0;
+  inputParameters.hostApiSpecificStreamInfo = NULL;
+
+// ************************************************************************
+//filter for portaudio Windows hostapi's with non experts.
+//only allow ASIO or WASAPI or WDM-KS
+  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name, &quot;ASIO&quot;, 4);
+  if (i==0 ) goto end_filter_hostapi;
+  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name,
+              &quot;Windows WASAPI&quot;, 14);
+  if (i==0 ) goto end_filter_hostapi;
+  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name,
+              &quot;Windows WDM-KS&quot;, 14);
+  if (i==0 ) goto end_filter_hostapi;
+  speed_warning=1;
+end_filter_hostapi:;
+
+// ************************************************************************
+  i=0;
+  while(standardSampleRates[i] &gt; 0 &amp;&amp; minStandardSampleRate==0) {
+    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
+                                standardSampleRates[i] );
+    if(pa_err == paDeviceUnavailable) return -1;
+    if(pa_err == paInvalidDevice) return -1;
+    if(pa_err == paFormatIsSupported ) {
+      minStandardSampleRate=standardSampleRates[i];
+    }
+    i++;
+  }
+  if(minStandardSampleRate == 0) return -1;
+  j=i;
+  while(standardSampleRates[i] &gt; 0 ) i++;
+  i--;
+
+  while(i &gt;= j &amp;&amp; maxStandardSampleRate==0) {
+    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
+                                  standardSampleRates[i] );
+    if(pa_err == paDeviceUnavailable) return -1;
+    if(pa_err == paInvalidDevice) return -1;
+    if( pa_err == paFormatIsSupported ) {
+      maxStandardSampleRate=standardSampleRates[i];
+    }
+    i--;
+  }
+
+// check if min SampleRate  = max SampleRate
+  if(maxStandardSampleRate==0 &amp;&amp; (minStandardSampleRate != 0)) {
+    maxStandardSampleRate= minStandardSampleRate;
+  }
+
+// check min and max bytes
+  minBytes=2;
+  maxBytes=2;
+  inputParameters.sampleFormat = paUInt8;
+  pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
+                                maxStandardSampleRate );
+  if( pa_err == paFormatIsSupported ) {
+    minBytes=1;
+  }
+    inputParameters.sampleFormat = paInt32;
+    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
+                                maxStandardSampleRate );
+  if( pa_err == paFormatIsSupported ) {
+    maxBytes=4;
+  }
+
+// check min channel count
+  maxInputChannels= deviceInfo-&gt;maxInputChannels;
+  inputParameters.channelCount = 1;
+  inputParameters.sampleFormat = paInt16;
+  pa_err=paFormatIsSupported+32000;
+  while(pa_err != paFormatIsSupported &amp;&amp;
+          ( inputParameters.channelCount &lt; (maxInputChannels+1)) ) {
+    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL,
+                                maxStandardSampleRate );
+    inputParameters.channelCount++;
+  }
+  if( pa_err == paFormatIsSupported ) {
+    minInputChannels=inputParameters.channelCount-1;
+  } else {
+    return -1;
+  }
+
+end_pa_get_device_info:;
+
+  *pa_device_max_speed=maxStandardSampleRate;
+  *pa_device_min_speed=minStandardSampleRate;
+  *pa_device_max_bytes=maxBytes;
+  *pa_device_min_bytes=minBytes;
+  *pa_device_max_channels= maxInputChannels;
+  *pa_device_min_channels= minInputChannels;
+
+  return speed_warning;
+}
+
+
+void paInputDevice(int id, char* hostAPI_DeviceName, int* minChan,
+                   int* maxChan, int* minSpeed, int* maxSpeed)
+{
+  int i;
+  char pa_device_name[128];
+  char pa_device_hostapi[128];
+  double pa_device_max_speed;
+  double pa_device_min_speed;
+  int pa_device_max_bytes;
+  int pa_device_min_bytes;
+  int pa_device_max_channels;
+  int pa_device_min_channels;
+  char p2[50];
+  char *p,*p1;
+  static int iret, valid_dev_cnt;
+
+  iret=pa_get_device_info (id,
+                          &amp;pa_device_name,
+                          &amp;pa_device_hostapi,
+                          &amp;pa_device_max_speed,
+                          &amp;pa_device_min_speed,
+                          &amp;pa_device_max_bytes,
+                          &amp;pa_device_min_bytes,
+                          &amp;pa_device_max_channels,
+                          &amp;pa_device_min_channels);
+
+  if (iret &gt;= 0 ) {
+    valid_dev_cnt++;
+
+    p1=(char*)&quot;&quot;;
+    p=strstr(pa_device_hostapi,&quot;MME&quot;);
+    if(p!=NULL) p1=(char*)&quot;MME&quot;;
+    p=strstr(pa_device_hostapi,&quot;Direct&quot;);
+    if(p!=NULL) p1=(char*)&quot;DirectX&quot;;
+    p=strstr(pa_device_hostapi,&quot;WASAPI&quot;);
+    if(p!=NULL) p1=(char*)&quot;WASAPI&quot;;
+    p=strstr(pa_device_hostapi,&quot;ASIO&quot;);
+    if(p!=NULL) p1=(char*)&quot;ASIO&quot;;
+    p=strstr(pa_device_hostapi,&quot;WDM-KS&quot;);
+    if(p!=NULL) p1=(char*)&quot;WDM-KS&quot;;
+
+    sprintf(p2,&quot;%-8s %-39s&quot;,p1,pa_device_name);
+    for(i=0; i&lt;50; i++) {
+      hostAPI_DeviceName[i]=p2[i];
+      if(p2[i]==0) break;
+    }
+    *minChan=pa_device_min_channels;
+    *maxChan=pa_device_max_channels;
+    *minSpeed=(int)pa_device_min_speed;
+    *maxSpeed=(int)pa_device_max_speed;
+  } else {
+    for(i=0; i&lt;50; i++) {
+      hostAPI_DeviceName[i]=0;
+    }
+    *minChan=0;
+    *maxChan=0;
+    *minSpeed=0;
+    *maxSpeed=0;
+  }
+}
+
+void getDev(int* numDevices0, char hostAPI_DeviceName[][50],
+            int minChan[], int maxChan[],
+            int minSpeed[], int maxSpeed[])
+{
+  int i,id,numDevices;
+  int minch,maxch,minsp,maxsp;
+  char apidev[256];
+
+  numDevices=Pa_GetDeviceCount();
+  *numDevices0=numDevices;
+
+  for(id=0; id&lt;numDevices; id++)  {
+    paInputDevice(id,apidev,&amp;minch,&amp;maxch,&amp;minsp,&amp;maxsp);
+    for(i=0; i&lt;50; i++) {
+      hostAPI_DeviceName[id][i]=apidev[i];
+    }
+    hostAPI_DeviceName[id][49]=0;
+    minChan[id]=minch;
+    maxChan[id]=maxch;
+    minSpeed[id]=minsp;
+    maxSpeed[id]=maxsp;
+  }
+}


Property changes on: branches/map65/getdev.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/getfile.cpp
===================================================================
--- branches/map65/getfile.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/getfile.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,105 +1,105 @@
-#include &quot;getfile.h&quot;
-#include &lt;QDir&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;math.h&gt;
-
-extern qint16 id[4*60*96000];
-
-void getfile(QString fname, bool xpol, int dbDgrd)
-{
-  int npts=2*52*96000;
-  if(xpol) npts=2*npts;
-
-// Degrade S/N by dbDgrd dB -- for tests only!!
-  float dgrd=0.0;
-  if(dbDgrd&lt;0) dgrd = 23.0*sqrt(pow(10.0,-0.1*(double)dbDgrd) - 1.0);
-  float fac=23.0/sqrt(dgrd*dgrd + 23.0*23.0);
-
-  memset(id,0,2*npts);
-  char name[80];
-  strcpy(name,fname.toAscii());
-  FILE* fp=fopen(name,&quot;rb&quot;);
-
-  if(fp != NULL) {
-    fread(&amp;datcom_.fcenter,sizeof(datcom_.fcenter),1,fp);
-    fread(id,2,npts,fp);
-    int j=0;
-
-    if(dbDgrd&lt;0) {
-      for(int i=0; i&lt;npts; i+=2) {
-        datcom_.d4[j++]=fac*((float)id[i] + dgrd*gran());
-        datcom_.d4[j++]=fac*((float)id[i+1] + dgrd*gran());
-        if(!xpol) j+=2;               //Skip over d4(3,x) and d4(4,x)
-      }
-    } else {
-      for(int i=0; i&lt;npts; i+=2) {
-        datcom_.d4[j++]=(float)id[i];
-        datcom_.d4[j++]=(float)id[i+1];
-        if(!xpol) j+=2;               //Skip over d4(3,x) and d4(4,x)
-      }
-    }
-    fclose(fp);
-
-    datcom_.ndiskdat=1;
-    int nfreq=(int)datcom_.fcenter;
-    if(nfreq!=144 and nfreq != 432 and nfreq != 1296) datcom_.fcenter=144.125;
-    int i0=fname.indexOf(&quot;.tf2&quot;);
-    if(i0&lt;0) i0=fname.indexOf(&quot;.iq&quot;);
-    datcom_.nutc=0;
-    if(i0&gt;0) datcom_.nutc=100*fname.mid(i0-4,2).toInt() +
-        fname.mid(i0-2,2).toInt();
-  }
-}
-
-void savetf2(QString fname, bool xpol)
-{
-  int npts=2*52*96000;
-  if(xpol) npts=2*npts;
-
-  qint16* buf=(qint16*)malloc(2*npts);
-  char name[80];
-  strcpy(name,fname.toAscii());
-  FILE* fp=fopen(name,&quot;wb&quot;);
-
-  if(fp != NULL) {
-    fwrite(&amp;datcom_.fcenter,sizeof(datcom_.fcenter),1,fp);
-    int j=0;
-    for(int i=0; i&lt;npts; i+=2) {
-      buf[i]=(qint16)datcom_.d4[j++];
-      buf[i+1]=(qint16)datcom_.d4[j++];
-      if(!xpol) j+=2;               //Skip over d4(3,x) and d4(4,x)
-    }
-    fwrite(buf,2,npts,fp);
-    fclose(fp);
-  }
-  free(buf);
-}
-
-//#define	MAX_RANDOM	0x7fffffff
-
-/* Generate gaussian random float with mean=0 and std_dev=1 */
-float gran()
-{
-  float fac,rsq,v1,v2;
-  static float gset;
-  static int iset;
-
-  if(iset){
-    /* Already got one */
-    iset = 0;
-    return gset;
-  }
-  /* Generate two evenly distributed numbers between -1 and +1
-   * that are inside the unit circle
-   */
-  do {
-    v1 = 2.0 * (float)rand() / RAND_MAX - 1;
-    v2 = 2.0 * (float)rand() / RAND_MAX - 1;
-    rsq = v1*v1 + v2*v2;
-  } while(rsq &gt;= 1.0 || rsq == 0.0);
-  fac = sqrt(-2.0*log(rsq)/rsq);
-  gset = v1*fac;
-  iset++;
-  return v2*fac;
-}
+#include &quot;getfile.h&quot;
+#include &lt;QDir&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+extern qint16 id[4*60*96000];
+
+void getfile(QString fname, bool xpol, int dbDgrd)
+{
+  int npts=2*52*96000;
+  if(xpol) npts=2*npts;
+
+// Degrade S/N by dbDgrd dB -- for tests only!!
+  float dgrd=0.0;
+  if(dbDgrd&lt;0) dgrd = 23.0*sqrt(pow(10.0,-0.1*(double)dbDgrd) - 1.0);
+  float fac=23.0/sqrt(dgrd*dgrd + 23.0*23.0);
+
+  memset(id,0,2*npts);
+  char name[80];
+  strcpy(name,fname.toAscii());
+  FILE* fp=fopen(name,&quot;rb&quot;);
+
+  if(fp != NULL) {
+    fread(&amp;datcom_.fcenter,sizeof(datcom_.fcenter),1,fp);
+    fread(id,2,npts,fp);
+    int j=0;
+
+    if(dbDgrd&lt;0) {
+      for(int i=0; i&lt;npts; i+=2) {
+        datcom_.d4[j++]=fac*((float)id[i] + dgrd*gran());
+        datcom_.d4[j++]=fac*((float)id[i+1] + dgrd*gran());
+        if(!xpol) j+=2;               //Skip over d4(3,x) and d4(4,x)
+      }
+    } else {
+      for(int i=0; i&lt;npts; i+=2) {
+        datcom_.d4[j++]=(float)id[i];
+        datcom_.d4[j++]=(float)id[i+1];
+        if(!xpol) j+=2;               //Skip over d4(3,x) and d4(4,x)
+      }
+    }
+    fclose(fp);
+
+    datcom_.ndiskdat=1;
+    int nfreq=(int)datcom_.fcenter;
+    if(nfreq!=144 and nfreq != 432 and nfreq != 1296) datcom_.fcenter=144.125;
+    int i0=fname.indexOf(&quot;.tf2&quot;);
+    if(i0&lt;0) i0=fname.indexOf(&quot;.iq&quot;);
+    datcom_.nutc=0;
+    if(i0&gt;0) datcom_.nutc=100*fname.mid(i0-4,2).toInt() +
+        fname.mid(i0-2,2).toInt();
+  }
+}
+
+void savetf2(QString fname, bool xpol)
+{
+  int npts=2*52*96000;
+  if(xpol) npts=2*npts;
+
+  qint16* buf=(qint16*)malloc(2*npts);
+  char name[80];
+  strcpy(name,fname.toAscii());
+  FILE* fp=fopen(name,&quot;wb&quot;);
+
+  if(fp != NULL) {
+    fwrite(&amp;datcom_.fcenter,sizeof(datcom_.fcenter),1,fp);
+    int j=0;
+    for(int i=0; i&lt;npts; i+=2) {
+      buf[i]=(qint16)datcom_.d4[j++];
+      buf[i+1]=(qint16)datcom_.d4[j++];
+      if(!xpol) j+=2;               //Skip over d4(3,x) and d4(4,x)
+    }
+    fwrite(buf,2,npts,fp);
+    fclose(fp);
+  }
+  free(buf);
+}
+
+//#define	MAX_RANDOM	0x7fffffff
+
+/* Generate gaussian random float with mean=0 and std_dev=1 */
+float gran()
+{
+  float fac,rsq,v1,v2;
+  static float gset;
+  static int iset;
+
+  if(iset){
+    /* Already got one */
+    iset = 0;
+    return gset;
+  }
+  /* Generate two evenly distributed numbers between -1 and +1
+   * that are inside the unit circle
+   */
+  do {
+    v1 = 2.0 * (float)rand() / RAND_MAX - 1;
+    v2 = 2.0 * (float)rand() / RAND_MAX - 1;
+    rsq = v1*v1 + v2*v2;
+  } while(rsq &gt;= 1.0 || rsq == 0.0);
+  fac = sqrt(-2.0*log(rsq)/rsq);
+  gset = v1*fac;
+  iset++;
+  return v2*fac;
+}


Property changes on: branches/map65/getfile.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/getfile.h
===================================================================
--- branches/map65/getfile.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/getfile.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,12 +1,12 @@
-#ifndef GETFILE_H
-#define GETFILE_H
-#include &lt;QString&gt;
-#include &lt;QFile&gt;
-#include &lt;QDebug&gt;
-#include &quot;commons.h&quot;
-
-void getfile(QString fname, bool xpol, int dbDgrd);
-void savetf2(QString fname, bool xpol);
-float gran();
-
-#endif // GETFILE_H
+#ifndef GETFILE_H
+#define GETFILE_H
+#include &lt;QString&gt;
+#include &lt;QFile&gt;
+#include &lt;QDebug&gt;
+#include &quot;commons.h&quot;
+
+void getfile(QString fname, bool xpol, int dbDgrd);
+void savetf2(QString fname, bool xpol);
+float gran();
+
+#endif // GETFILE_H


Property changes on: branches/map65/getfile.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/killbyname.cpp
===================================================================
--- branches/map65/killbyname.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/killbyname.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,282 +1,282 @@
-#include &lt;windows.h&gt;
-#include &lt;tlhelp32.h&gt;
-#include &lt;iostream&gt;
-
-int killbyname(const char *szToTerminate)
-// Created: 6/23/2000  (Ravi Kochhar)
-// Last modified: 3/10/2002  (RK)
-// Please report any problems or bugs to <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">kochhar at physiology.wisc.edu</A>
-// The latest version of this routine can be found at:
-//     <A HREF="http://www.neurophys.wisc.edu/ravi/software/killproc/">http://www.neurophys.wisc.edu/ravi/software/killproc/</A>
-// Terminate the process &quot;szToTerminate&quot; if it is currently running
-// This works for Win/95/98/ME and also Win/NT/2000/XP
-// The process name is case-insensitive, i.e. &quot;notepad.exe&quot; and &quot;NOTEPAD.EXE&quot;
-// will both work (for szToTerminate)
-// Return codes are as follows:
-//   0   = Process was successfully terminated
-//   602 = Unable to terminate process for some other reason
-//   603 = Process was not currently running
-//   604 = No permission to terminate process
-//   605 = Unable to load PSAPI.DLL
-//   606 = Unable to identify system type
-//   607 = Unsupported OS
-//   632 = Invalid process name
-//   700 = Unable to get procedure address from PSAPI.DLL
-//   701 = Unable to get process list, EnumProcesses failed
-//   702 = Unable to load KERNEL32.DLL
-//   703 = Unable to get procedure address from KERNEL32.DLL
-//   704 = CreateToolhelp32Snapshot failed
-
-{
-  BOOL bResult,bResultm;
-  DWORD aiPID[1000],iCb=1000,iNumProc;  //,iV2000=0;
-  DWORD iCbneeded,i,iFound=0;
-  char szName[MAX_PATH],szToTermUpper[MAX_PATH];
-  HANDLE hProc,hSnapShot,hSnapShotm;
-  OSVERSIONINFO osvi;
-  HINSTANCE hInstLib;
-  int iLen,iLenP,indx;
-  HMODULE hMod;
-  PROCESSENTRY32 procentry;
-  MODULEENTRY32 modentry;
-
-  // Transfer Process name into &quot;szToTermUpper&quot; and convert to upper case
-  iLenP=strlen(szToTerminate);
-  if(iLenP&lt;1 || iLenP&gt;MAX_PATH) return 632;
-  for(indx=0;indx&lt;iLenP;indx++)
-    szToTermUpper[indx]=toupper(szToTerminate[indx]);
-  szToTermUpper[iLenP]=0;
-
-  // PSAPI Function Pointers.
-  BOOL (WINAPI *lpfEnumProcesses)( DWORD *, DWORD cb, DWORD * );
-  BOOL (WINAPI *lpfEnumProcessModules)( HANDLE, HMODULE *,
-                                        DWORD, LPDWORD );
-  DWORD (WINAPI *lpfGetModuleBaseName)( HANDLE, HMODULE,
-                                        LPTSTR, DWORD );
-
-  // ToolHelp Function Pointers.
-  HANDLE (WINAPI *lpfCreateToolhelp32Snapshot)(DWORD,DWORD) ;
-  BOOL (WINAPI *lpfProcess32First)(HANDLE,LPPROCESSENTRY32) ;
-  BOOL (WINAPI *lpfProcess32Next)(HANDLE,LPPROCESSENTRY32) ;
-  BOOL (WINAPI *lpfModule32First)(HANDLE,LPMODULEENTRY32) ;
-  BOOL (WINAPI *lpfModule32Next)(HANDLE,LPMODULEENTRY32) ;
-
-  // First check what version of Windows we're in
-  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
-  bResult=GetVersionEx(&amp;osvi);
-  if(!bResult) return 606;    // Unable to identify system version
-
-  // At Present we only support Win/NT/2000/XP or Win/9x/ME
-  // Seems to work OK in Win7
-  if((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) &amp;&amp;
-     (osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)) return 607;
-
-  if(osvi.dwPlatformId==VER_PLATFORM_WIN32_NT)
-  {
-    // Win/NT or 2000 or XP
-
-    // Load library and get the procedures explicitly. We do
-    // this so that we don't have to worry about modules using
-    // this code failing to load under Windows 9x, because
-    // it can't resolve references to the PSAPI.DLL.
-    hInstLib = LoadLibraryA(&quot;PSAPI.DLL&quot;);
-    if(hInstLib == NULL) return 605;
-
-    // Get procedure addresses.
-    lpfEnumProcesses = (BOOL(WINAPI *)(DWORD *,DWORD,DWORD*))
-        GetProcAddress( hInstLib, &quot;EnumProcesses&quot; ) ;
-    lpfEnumProcessModules = (BOOL(WINAPI *)(HANDLE, HMODULE *,
-        DWORD, LPDWORD)) GetProcAddress( hInstLib,                                                                     &quot;EnumProcessModules&quot; ) ;
-        lpfGetModuleBaseName =(DWORD (WINAPI *)(HANDLE, HMODULE, LPTSTR,
-        DWORD )) GetProcAddress( hInstLib, &quot;GetModuleBaseNameA&quot; ) ;
-
-    if(lpfEnumProcesses == NULL || lpfEnumProcessModules == NULL ||
-         lpfGetModuleBaseName == NULL) {
-      FreeLibrary(hInstLib);
-      return 700;
-    }
-
-    bResult=lpfEnumProcesses(aiPID,iCb,&amp;iCbneeded);
-    if(!bResult) {
-      // Unable to get process list, EnumProcesses failed
-      FreeLibrary(hInstLib);
-      return 701;
-    }
-
-    // How many processes are there?
-    iNumProc=iCbneeded/sizeof(DWORD);
-
-    // Get and match the name of each process
-    for(i=0;i&lt;iNumProc;i++) {
-      // Get the (module) name for this process
-      strcpy(szName,&quot;Unknown&quot;);
-      // First, get a handle to the process
-      hProc=OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,
-                        aiPID[i]);
-      // Now, get the process name
-      if(hProc) {
-        if(lpfEnumProcessModules(hProc,&amp;hMod,sizeof(hMod),&amp;iCbneeded) ) {
-          iLen=lpfGetModuleBaseName(hProc,hMod,szName,MAX_PATH);
-        }
-      }
-      CloseHandle(hProc);
-      // We will match regardless of lower or upper case
-      if(strcmp(_strupr(szName),szToTermUpper)==0) {
-        // Process found, now terminate it
-        iFound=1;
-        // First open for termination
-        hProc=OpenProcess(PROCESS_TERMINATE,FALSE,aiPID[i]);
-        if(hProc) {
-          if(TerminateProcess(hProc,0)) {
-            // process terminated
-            CloseHandle(hProc);
-            FreeLibrary(hInstLib);
-            return 0;
-          } else {
-            // Unable to terminate process
-            CloseHandle(hProc);
-            FreeLibrary(hInstLib);
-            return 602;
-          }
-        } else {
-          // Unable to open process for termination
-          FreeLibrary(hInstLib);
-          return 604;
-        }
-      }
-    }
-  }
-
-  if(osvi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)
-  {
-    // Win/95 or 98 or ME
-
-    hInstLib = LoadLibraryA(&quot;Kernel32.DLL&quot;);
-    if( hInstLib == NULL )
-      return 702;
-
-    // Get procedure addresses.
-    // We are linking to these functions of Kernel32
-    // explicitly, because otherwise a module using
-    // this code would fail to load under Windows NT,
-    // which does not have the Toolhelp32
-    // functions in the Kernel 32.
-    lpfCreateToolhelp32Snapshot=
-        (HANDLE(WINAPI *)(DWORD,DWORD))
-        GetProcAddress( hInstLib,
-                        &quot;CreateToolhelp32Snapshot&quot; ) ;
-    lpfProcess32First=
-        (BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32))
-        GetProcAddress( hInstLib, &quot;Process32First&quot; ) ;
-    lpfProcess32Next=
-        (BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32))
-        GetProcAddress( hInstLib, &quot;Process32Next&quot; ) ;
-    lpfModule32First=
-        (BOOL(WINAPI *)(HANDLE,LPMODULEENTRY32))
-        GetProcAddress( hInstLib, &quot;Module32First&quot; ) ;
-    lpfModule32Next=
-        (BOOL(WINAPI *)(HANDLE,LPMODULEENTRY32))
-        GetProcAddress( hInstLib, &quot;Module32Next&quot; ) ;
-    if( lpfProcess32Next == NULL ||
-        lpfProcess32First == NULL ||
-        lpfModule32Next == NULL ||
-        lpfModule32First == NULL ||
-        lpfCreateToolhelp32Snapshot == NULL )
-    {
-      FreeLibrary(hInstLib);
-      return 703;
-    }
-
-    // The Process32.. and Module32.. routines return names in all uppercase
-
-    // Get a handle to a Toolhelp snapshot of all the systems processes.
-
-    hSnapShot = lpfCreateToolhelp32Snapshot(
-          TH32CS_SNAPPROCESS, 0 ) ;
-    if( hSnapShot == INVALID_HANDLE_VALUE )
-    {
-      FreeLibrary(hInstLib);
-      return 704;
-    }
-
-    // Get the first process' information.
-    procentry.dwSize = sizeof(PROCESSENTRY32);
-    bResult=lpfProcess32First(hSnapShot,&amp;procentry);
-
-    // While there are processes, keep looping and checking.
-    while(bResult)
-    {
-      // Get a handle to a Toolhelp snapshot of this process.
-      hSnapShotm = lpfCreateToolhelp32Snapshot(
-            TH32CS_SNAPMODULE, procentry.th32ProcessID) ;
-      if( hSnapShotm == INVALID_HANDLE_VALUE )
-      {
-        CloseHandle(hSnapShot);
-        FreeLibrary(hInstLib);
-        return 704;
-      }
-      // Get the module list for this process
-      modentry.dwSize=sizeof(MODULEENTRY32);
-      bResultm=lpfModule32First(hSnapShotm,&amp;modentry);
-
-      // While there are modules, keep looping and checking
-      while(bResultm)
-      {
-        if(strcmp(modentry.szModule,szToTermUpper)==0)
-        {
-          // Process found, now terminate it
-          iFound=1;
-          // First open for termination
-          hProc=OpenProcess(PROCESS_TERMINATE,FALSE,procentry.th32ProcessID);
-          if(hProc)
-          {
-            if(TerminateProcess(hProc,0))
-            {
-              // process terminated
-              CloseHandle(hSnapShotm);
-              CloseHandle(hSnapShot);
-              CloseHandle(hProc);
-              FreeLibrary(hInstLib);
-              return 0;
-            }
-            else
-            {
-              // Unable to terminate process
-              CloseHandle(hSnapShotm);
-              CloseHandle(hSnapShot);
-              CloseHandle(hProc);
-              FreeLibrary(hInstLib);
-              return 602;
-            }
-          }
-          else
-          {
-            // Unable to open process for termination
-            CloseHandle(hSnapShotm);
-            CloseHandle(hSnapShot);
-            FreeLibrary(hInstLib);
-            return 604;
-          }
-        }
-        else
-        {  // Look for next modules for this process
-          modentry.dwSize=sizeof(MODULEENTRY32);
-          bResultm=lpfModule32Next(hSnapShotm,&amp;modentry);
-        }
-      }
-
-      //Keep looking
-      CloseHandle(hSnapShotm);
-      procentry.dwSize = sizeof(PROCESSENTRY32);
-      bResult = lpfProcess32Next(hSnapShot,&amp;procentry);
-    }
-    CloseHandle(hSnapShot);
-  }
-  if(iFound==0)
-  {
-    FreeLibrary(hInstLib);
-    return 603;
-  }
-  FreeLibrary(hInstLib);
-  return 0;
-}
+#include &lt;windows.h&gt;
+#include &lt;tlhelp32.h&gt;
+#include &lt;iostream&gt;
+
+int killbyname(const char *szToTerminate)
+// Created: 6/23/2000  (Ravi Kochhar)
+// Last modified: 3/10/2002  (RK)
+// Please report any problems or bugs to <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">kochhar at physiology.wisc.edu</A>
+// The latest version of this routine can be found at:
+//     <A HREF="http://www.neurophys.wisc.edu/ravi/software/killproc/">http://www.neurophys.wisc.edu/ravi/software/killproc/</A>
+// Terminate the process &quot;szToTerminate&quot; if it is currently running
+// This works for Win/95/98/ME and also Win/NT/2000/XP
+// The process name is case-insensitive, i.e. &quot;notepad.exe&quot; and &quot;NOTEPAD.EXE&quot;
+// will both work (for szToTerminate)
+// Return codes are as follows:
+//   0   = Process was successfully terminated
+//   602 = Unable to terminate process for some other reason
+//   603 = Process was not currently running
+//   604 = No permission to terminate process
+//   605 = Unable to load PSAPI.DLL
+//   606 = Unable to identify system type
+//   607 = Unsupported OS
+//   632 = Invalid process name
+//   700 = Unable to get procedure address from PSAPI.DLL
+//   701 = Unable to get process list, EnumProcesses failed
+//   702 = Unable to load KERNEL32.DLL
+//   703 = Unable to get procedure address from KERNEL32.DLL
+//   704 = CreateToolhelp32Snapshot failed
+
+{
+  BOOL bResult,bResultm;
+  DWORD aiPID[1000],iCb=1000,iNumProc;  //,iV2000=0;
+  DWORD iCbneeded,i,iFound=0;
+  char szName[MAX_PATH],szToTermUpper[MAX_PATH];
+  HANDLE hProc,hSnapShot,hSnapShotm;
+  OSVERSIONINFO osvi;
+  HINSTANCE hInstLib;
+  int iLen,iLenP,indx;
+  HMODULE hMod;
+  PROCESSENTRY32 procentry;
+  MODULEENTRY32 modentry;
+
+  // Transfer Process name into &quot;szToTermUpper&quot; and convert to upper case
+  iLenP=strlen(szToTerminate);
+  if(iLenP&lt;1 || iLenP&gt;MAX_PATH) return 632;
+  for(indx=0;indx&lt;iLenP;indx++)
+    szToTermUpper[indx]=toupper(szToTerminate[indx]);
+  szToTermUpper[iLenP]=0;
+
+  // PSAPI Function Pointers.
+  BOOL (WINAPI *lpfEnumProcesses)( DWORD *, DWORD cb, DWORD * );
+  BOOL (WINAPI *lpfEnumProcessModules)( HANDLE, HMODULE *,
+                                        DWORD, LPDWORD );
+  DWORD (WINAPI *lpfGetModuleBaseName)( HANDLE, HMODULE,
+                                        LPTSTR, DWORD );
+
+  // ToolHelp Function Pointers.
+  HANDLE (WINAPI *lpfCreateToolhelp32Snapshot)(DWORD,DWORD) ;
+  BOOL (WINAPI *lpfProcess32First)(HANDLE,LPPROCESSENTRY32) ;
+  BOOL (WINAPI *lpfProcess32Next)(HANDLE,LPPROCESSENTRY32) ;
+  BOOL (WINAPI *lpfModule32First)(HANDLE,LPMODULEENTRY32) ;
+  BOOL (WINAPI *lpfModule32Next)(HANDLE,LPMODULEENTRY32) ;
+
+  // First check what version of Windows we're in
+  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+  bResult=GetVersionEx(&amp;osvi);
+  if(!bResult) return 606;    // Unable to identify system version
+
+  // At Present we only support Win/NT/2000/XP or Win/9x/ME
+  // Seems to work OK in Win7
+  if((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) &amp;&amp;
+     (osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)) return 607;
+
+  if(osvi.dwPlatformId==VER_PLATFORM_WIN32_NT)
+  {
+    // Win/NT or 2000 or XP
+
+    // Load library and get the procedures explicitly. We do
+    // this so that we don't have to worry about modules using
+    // this code failing to load under Windows 9x, because
+    // it can't resolve references to the PSAPI.DLL.
+    hInstLib = LoadLibraryA(&quot;PSAPI.DLL&quot;);
+    if(hInstLib == NULL) return 605;
+
+    // Get procedure addresses.
+    lpfEnumProcesses = (BOOL(WINAPI *)(DWORD *,DWORD,DWORD*))
+        GetProcAddress( hInstLib, &quot;EnumProcesses&quot; ) ;
+    lpfEnumProcessModules = (BOOL(WINAPI *)(HANDLE, HMODULE *,
+        DWORD, LPDWORD)) GetProcAddress( hInstLib,                                                                     &quot;EnumProcessModules&quot; ) ;
+        lpfGetModuleBaseName =(DWORD (WINAPI *)(HANDLE, HMODULE, LPTSTR,
+        DWORD )) GetProcAddress( hInstLib, &quot;GetModuleBaseNameA&quot; ) ;
+
+    if(lpfEnumProcesses == NULL || lpfEnumProcessModules == NULL ||
+         lpfGetModuleBaseName == NULL) {
+      FreeLibrary(hInstLib);
+      return 700;
+    }
+
+    bResult=lpfEnumProcesses(aiPID,iCb,&amp;iCbneeded);
+    if(!bResult) {
+      // Unable to get process list, EnumProcesses failed
+      FreeLibrary(hInstLib);
+      return 701;
+    }
+
+    // How many processes are there?
+    iNumProc=iCbneeded/sizeof(DWORD);
+
+    // Get and match the name of each process
+    for(i=0;i&lt;iNumProc;i++) {
+      // Get the (module) name for this process
+      strcpy(szName,&quot;Unknown&quot;);
+      // First, get a handle to the process
+      hProc=OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,
+                        aiPID[i]);
+      // Now, get the process name
+      if(hProc) {
+        if(lpfEnumProcessModules(hProc,&amp;hMod,sizeof(hMod),&amp;iCbneeded) ) {
+          iLen=lpfGetModuleBaseName(hProc,hMod,szName,MAX_PATH);
+        }
+      }
+      CloseHandle(hProc);
+      // We will match regardless of lower or upper case
+      if(strcmp(_strupr(szName),szToTermUpper)==0) {
+        // Process found, now terminate it
+        iFound=1;
+        // First open for termination
+        hProc=OpenProcess(PROCESS_TERMINATE,FALSE,aiPID[i]);
+        if(hProc) {
+          if(TerminateProcess(hProc,0)) {
+            // process terminated
+            CloseHandle(hProc);
+            FreeLibrary(hInstLib);
+            return 0;
+          } else {
+            // Unable to terminate process
+            CloseHandle(hProc);
+            FreeLibrary(hInstLib);
+            return 602;
+          }
+        } else {
+          // Unable to open process for termination
+          FreeLibrary(hInstLib);
+          return 604;
+        }
+      }
+    }
+  }
+
+  if(osvi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)
+  {
+    // Win/95 or 98 or ME
+
+    hInstLib = LoadLibraryA(&quot;Kernel32.DLL&quot;);
+    if( hInstLib == NULL )
+      return 702;
+
+    // Get procedure addresses.
+    // We are linking to these functions of Kernel32
+    // explicitly, because otherwise a module using
+    // this code would fail to load under Windows NT,
+    // which does not have the Toolhelp32
+    // functions in the Kernel 32.
+    lpfCreateToolhelp32Snapshot=
+        (HANDLE(WINAPI *)(DWORD,DWORD))
+        GetProcAddress( hInstLib,
+                        &quot;CreateToolhelp32Snapshot&quot; ) ;
+    lpfProcess32First=
+        (BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32))
+        GetProcAddress( hInstLib, &quot;Process32First&quot; ) ;
+    lpfProcess32Next=
+        (BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32))
+        GetProcAddress( hInstLib, &quot;Process32Next&quot; ) ;
+    lpfModule32First=
+        (BOOL(WINAPI *)(HANDLE,LPMODULEENTRY32))
+        GetProcAddress( hInstLib, &quot;Module32First&quot; ) ;
+    lpfModule32Next=
+        (BOOL(WINAPI *)(HANDLE,LPMODULEENTRY32))
+        GetProcAddress( hInstLib, &quot;Module32Next&quot; ) ;
+    if( lpfProcess32Next == NULL ||
+        lpfProcess32First == NULL ||
+        lpfModule32Next == NULL ||
+        lpfModule32First == NULL ||
+        lpfCreateToolhelp32Snapshot == NULL )
+    {
+      FreeLibrary(hInstLib);
+      return 703;
+    }
+
+    // The Process32.. and Module32.. routines return names in all uppercase
+
+    // Get a handle to a Toolhelp snapshot of all the systems processes.
+
+    hSnapShot = lpfCreateToolhelp32Snapshot(
+          TH32CS_SNAPPROCESS, 0 ) ;
+    if( hSnapShot == INVALID_HANDLE_VALUE )
+    {
+      FreeLibrary(hInstLib);
+      return 704;
+    }
+
+    // Get the first process' information.
+    procentry.dwSize = sizeof(PROCESSENTRY32);
+    bResult=lpfProcess32First(hSnapShot,&amp;procentry);
+
+    // While there are processes, keep looping and checking.
+    while(bResult)
+    {
+      // Get a handle to a Toolhelp snapshot of this process.
+      hSnapShotm = lpfCreateToolhelp32Snapshot(
+            TH32CS_SNAPMODULE, procentry.th32ProcessID) ;
+      if( hSnapShotm == INVALID_HANDLE_VALUE )
+      {
+        CloseHandle(hSnapShot);
+        FreeLibrary(hInstLib);
+        return 704;
+      }
+      // Get the module list for this process
+      modentry.dwSize=sizeof(MODULEENTRY32);
+      bResultm=lpfModule32First(hSnapShotm,&amp;modentry);
+
+      // While there are modules, keep looping and checking
+      while(bResultm)
+      {
+        if(strcmp(modentry.szModule,szToTermUpper)==0)
+        {
+          // Process found, now terminate it
+          iFound=1;
+          // First open for termination
+          hProc=OpenProcess(PROCESS_TERMINATE,FALSE,procentry.th32ProcessID);
+          if(hProc)
+          {
+            if(TerminateProcess(hProc,0))
+            {
+              // process terminated
+              CloseHandle(hSnapShotm);
+              CloseHandle(hSnapShot);
+              CloseHandle(hProc);
+              FreeLibrary(hInstLib);
+              return 0;
+            }
+            else
+            {
+              // Unable to terminate process
+              CloseHandle(hSnapShotm);
+              CloseHandle(hSnapShot);
+              CloseHandle(hProc);
+              FreeLibrary(hInstLib);
+              return 602;
+            }
+          }
+          else
+          {
+            // Unable to open process for termination
+            CloseHandle(hSnapShotm);
+            CloseHandle(hSnapShot);
+            FreeLibrary(hInstLib);
+            return 604;
+          }
+        }
+        else
+        {  // Look for next modules for this process
+          modentry.dwSize=sizeof(MODULEENTRY32);
+          bResultm=lpfModule32Next(hSnapShotm,&amp;modentry);
+        }
+      }
+
+      //Keep looking
+      CloseHandle(hSnapShotm);
+      procentry.dwSize = sizeof(PROCESSENTRY32);
+      bResult = lpfProcess32Next(hSnapShot,&amp;procentry);
+    }
+    CloseHandle(hSnapShot);
+  }
+  if(iFound==0)
+  {
+    FreeLibrary(hInstLib);
+    return 603;
+  }
+  FreeLibrary(hInstLib);
+  return 0;
+}


Property changes on: branches/map65/killbyname.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/JT65code.f90
===================================================================
--- branches/map65/libm65/JT65code.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/JT65code.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,47 +1,47 @@
-program JT65code
-
-! Provides examples of message packing, bit and symbol ordering,
-! Reed Solomon encoding, and other necessary details of the JT65
-! protocol.
-
-  character*22 msg0,msg,decoded,cok*3
-  integer dgen(12),sent(63),recd(12),era(51)
-
-  nargs=iargc()
-  if(nargs.ne.1) then
-     print*,'Usage: JT65code &quot;message&quot;'
-     go to 999
-  endif
-
-  call getarg(1,msg0)                     !Get message from command line
-  msg=msg0
-
-  call chkmsg(msg,cok,nspecial,flip)      !See if it includes &quot;OOO&quot; report
-  if(nspecial.gt.0) then                  !or is a shorthand message
-     write(*,1010) 
-1010 format('Shorthand message.')
-     go to 999
-  endif
-
-  call packmsg(msg,dgen)                  !Pack message into 72 bits
-  write(*,1020) msg0
-1020 format('Message:   ',a22)            !Echo input message
-  if(iand(dgen(10),8).ne.0) write(*,1030) !Is plain text bit set?
-1030 format('Plain text.')         
-  write(*,1040) dgen
-1040 format('Packed message, 6-bit symbols: ',12i3) !Display packed symbols
-
-  call rs_encode(dgen,sent)               !RS encode
-  call interleave63(sent,1)               !Interleave channel symbols
-  call graycode(sent,63,1)                !Apply Gray code
-  write(*,1050) sent
-1050 format('Channel symbols, including FEC:'/(i5,20i3))
-
-  call graycode(sent,63,-1)
-  call interleave63(sent,-1)
-  call rs_decode(sent,era,0,recd,nerr)
-  call unpackmsg(recd,decoded)            !Unpack the user message
-  write(*,1060) decoded,cok
-1060 format('Decoded message: ',a22,2x,a3)
-
-999 end program JT65code
+program JT65code
+
+! Provides examples of message packing, bit and symbol ordering,
+! Reed Solomon encoding, and other necessary details of the JT65
+! protocol.
+
+  character*22 msg0,msg,decoded,cok*3
+  integer dgen(12),sent(63),recd(12),era(51)
+
+  nargs=iargc()
+  if(nargs.ne.1) then
+     print*,'Usage: JT65code &quot;message&quot;'
+     go to 999
+  endif
+
+  call getarg(1,msg0)                     !Get message from command line
+  msg=msg0
+
+  call chkmsg(msg,cok,nspecial,flip)      !See if it includes &quot;OOO&quot; report
+  if(nspecial.gt.0) then                  !or is a shorthand message
+     write(*,1010) 
+1010 format('Shorthand message.')
+     go to 999
+  endif
+
+  call packmsg(msg,dgen)                  !Pack message into 72 bits
+  write(*,1020) msg0
+1020 format('Message:   ',a22)            !Echo input message
+  if(iand(dgen(10),8).ne.0) write(*,1030) !Is plain text bit set?
+1030 format('Plain text.')         
+  write(*,1040) dgen
+1040 format('Packed message, 6-bit symbols: ',12i3) !Display packed symbols
+
+  call rs_encode(dgen,sent)               !RS encode
+  call interleave63(sent,1)               !Interleave channel symbols
+  call graycode(sent,63,1)                !Apply Gray code
+  write(*,1050) sent
+1050 format('Channel symbols, including FEC:'/(i5,20i3))
+
+  call graycode(sent,63,-1)
+  call interleave63(sent,-1)
+  call rs_decode(sent,era,0,recd,nerr)
+  call unpackmsg(recd,decoded)            !Unpack the user message
+  write(*,1060) decoded,cok
+1060 format('Decoded message: ',a22,2x,a3)
+
+999 end program JT65code


Property changes on: branches/map65/libm65/JT65code.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/Makefile.MinGW
===================================================================
--- branches/map65/libm65/Makefile.MinGW	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/Makefile.MinGW	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,92 +1,92 @@
-# Makefile for MinGW on Windows
-CC = gcc
-FC = g95
-
-FFLAGS = -O2 -fbounds-check -Wall -Wno-precision-loss -fno-second-underscore
-CFLAGS = -I. -fbounds-check
-
-# Default rules
-%.o: %.c
-	${CC} ${CFLAGS} -c $&lt;
-%.o: %.f
-	${FC} ${FFLAGS} -c $&lt;
-%.o: %.F
-	${FC} ${FFLAGS} -c $&lt;
-%.o: %.f90
-	${FC} ${FFLAGS} -c $&lt;
-%.o: %.F90
-	${FC} ${FFLAGS} -c $&lt;
-
-all:    libm65.a m65.exe JT65code.exe
-
-OBJS1 = trimlist.o display.o getdphi.o pctile.o ccf65.o \
-	decode1a.o sort.o filbig.o fil6521.o afc65b.o \
-	twkfreq.o decode65b.o indexx.o ssort.o fchisq.o setup65.o \
-	extract.o deep65.o ccf2.o demod64a.o chkhist.o graycode.o \
-	interleave63.o unpackmsg.o encode65.o igray.o set.o unpackcall.o \
-	unpackgrid.o grid2k.o unpacktext.o getpfx2.o packmsg.o \
-	deg2grid.o packtext.o getpfx1.o packcall.o k2grid.o packgrid.o \
-	wrapkarn.o nchar.o init_rs.o encode_rs.o decode_rs.o \
-	four2a.o rfile3a.o grid2deg.o pfxdump.o dpol.o \
-	astro.o tm2.o sun.o moondop.o coord.o tmoonsub.o \
-	geocentric.o moon2.o toxyz.o dot.o dcoord.o f77_wisdom.o \
-	gen65.o chkmsg.o ptt.o astrosub.o astro0.o recvpkt.o symspec.o \
-	iqcal.o iqfix.o timf2.o s3avg.o
-
-libm65.a: $(OBJS1)
-	ar cr libm65.a $(OBJS1) 
-	ranlib libm65.a
-
-OBJS3 = m65.o m65a.o map65a.o symspec.o decode0.o ftninit.o ftnquit.o \
-	timer.o ipcomm.o sec_midn.o cutil.o 
-LIBS3    = -L'c:/QtSDK/Desktop/Qt/4.7.4/mingw/lib' -lQtCore4
-
-m65.exe: $(OBJS3) libm65.a
-	g++ -o m65.exe $(OBJS3) $(LIBS3) libm65.a ../libfftw3f_win.a \
-	c:/MinGW/lib/libf95.a
-	cp m65.exe ../../map65_install
-
-OBJS2 = JT65code.o
-JT65code.exe: $(OBJS2) libm65.a
-	$(FC) -o JT65code.exe $(OBJS2) libm65.a
-
-INCPATH = -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/include/QtCore' \
-	 -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/include' \
-	 -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/include/ActiveQt' \
-	 -I'release' -I'.' -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/mkspecs/win32-g++'
-ipcomm.o: ipcomm.cpp
-	g++ -c $(INCPATH) ipcomm.cpp
-
-#m65a.o:	m65a.f90
-#	$(FC) -c -fno-second-underscore -cpp m65a.f90
-
-sec_midn.o: sec_midn.f90
-	$(FC) -c -fno-second-underscore sec_midn.f90
-
-#symspec.o: ../symspec.f90
-#	$(FC) -c $(FFLAGS) -o symspec.o ../symspec.f90
-
-OBJS4 = tastro.o astro0.o libm65.a
-tastro.exe: $(OBJS4)
-	$(FC) $(FFLAGS) -o tastro.exe $(OBJS4) libm65.a 
-
-OBJS5 = t1.o timer.o libm65.a
-t1.exe: $(OBJS5)
-	$(FC) $(FFLAGS) -o t1.exe $(OBJS5) libm65.a 
-
-#astro0.o: ../astro0.f90
-#	$(FC) -c $(FFLAGS) -o astro0.o ../astro0.f90
-
-init_rs.o: init_rs.c
-	$(CC) -c -DBIGSYM=1 -o init_rs.o init_rs.c
-
-encode_rs.o: encode_rs.c
-	$(CC) -c -DBIGSYM=1 -o encode_rs.o encode_rs.c
-
-decode_rs.o: decode_rs.c
-	$(CC) -c -DBIGSYM=1 -o decode_rs.o decode_rs.c
-
-.PHONY : clean
-
-clean:
-	rm -f *.o libm65.a m65.exe jt65code.exe
+# Makefile for MinGW on Windows
+CC = gcc
+FC = g95
+
+FFLAGS = -O2 -fbounds-check -Wall -Wno-precision-loss -fno-second-underscore
+CFLAGS = -I. -fbounds-check
+
+# Default rules
+%.o: %.c
+	${CC} ${CFLAGS} -c $&lt;
+%.o: %.f
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.f90
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F90
+	${FC} ${FFLAGS} -c $&lt;
+
+all:    libm65.a m65.exe JT65code.exe
+
+OBJS1 = trimlist.o display.o getdphi.o pctile.o ccf65.o \
+	decode1a.o sort.o filbig.o fil6521.o afc65b.o \
+	twkfreq.o decode65b.o indexx.o ssort.o fchisq.o setup65.o \
+	extract.o deep65.o ccf2.o demod64a.o chkhist.o graycode.o \
+	interleave63.o unpackmsg.o encode65.o igray.o set.o unpackcall.o \
+	unpackgrid.o grid2k.o unpacktext.o getpfx2.o packmsg.o \
+	deg2grid.o packtext.o getpfx1.o packcall.o k2grid.o packgrid.o \
+	wrapkarn.o nchar.o init_rs.o encode_rs.o decode_rs.o \
+	four2a.o rfile3a.o grid2deg.o pfxdump.o dpol.o \
+	astro.o tm2.o sun.o moondop.o coord.o tmoonsub.o \
+	geocentric.o moon2.o toxyz.o dot.o dcoord.o f77_wisdom.o \
+	gen65.o chkmsg.o ptt.o astrosub.o astro0.o recvpkt.o symspec.o \
+	iqcal.o iqfix.o timf2.o s3avg.o
+
+libm65.a: $(OBJS1)
+	ar cr libm65.a $(OBJS1) 
+	ranlib libm65.a
+
+OBJS3 = m65.o m65a.o map65a.o symspec.o decode0.o ftninit.o ftnquit.o \
+	timer.o ipcomm.o sec_midn.o cutil.o 
+LIBS3    = -L'c:/QtSDK/Desktop/Qt/4.7.4/mingw/lib' -lQtCore4
+
+m65.exe: $(OBJS3) libm65.a
+	g++ -o m65.exe $(OBJS3) $(LIBS3) libm65.a ../libfftw3f_win.a \
+	c:/MinGW/lib/libf95.a
+	cp m65.exe ../../map65_install
+
+OBJS2 = JT65code.o
+JT65code.exe: $(OBJS2) libm65.a
+	$(FC) -o JT65code.exe $(OBJS2) libm65.a
+
+INCPATH = -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/include/QtCore' \
+	 -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/include' \
+	 -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/include/ActiveQt' \
+	 -I'release' -I'.' -I'c:/QtSDK/Desktop/Qt/4.7.4/mingw/mkspecs/win32-g++'
+ipcomm.o: ipcomm.cpp
+	g++ -c $(INCPATH) ipcomm.cpp
+
+#m65a.o:	m65a.f90
+#	$(FC) -c -fno-second-underscore -cpp m65a.f90
+
+sec_midn.o: sec_midn.f90
+	$(FC) -c -fno-second-underscore sec_midn.f90
+
+#symspec.o: ../symspec.f90
+#	$(FC) -c $(FFLAGS) -o symspec.o ../symspec.f90
+
+OBJS4 = tastro.o astro0.o libm65.a
+tastro.exe: $(OBJS4)
+	$(FC) $(FFLAGS) -o tastro.exe $(OBJS4) libm65.a 
+
+OBJS5 = t1.o timer.o libm65.a
+t1.exe: $(OBJS5)
+	$(FC) $(FFLAGS) -o t1.exe $(OBJS5) libm65.a 
+
+#astro0.o: ../astro0.f90
+#	$(FC) -c $(FFLAGS) -o astro0.o ../astro0.f90
+
+init_rs.o: init_rs.c
+	$(CC) -c -DBIGSYM=1 -o init_rs.o init_rs.c
+
+encode_rs.o: encode_rs.c
+	$(CC) -c -DBIGSYM=1 -o encode_rs.o encode_rs.c
+
+decode_rs.o: decode_rs.c
+	$(CC) -c -DBIGSYM=1 -o decode_rs.o decode_rs.c
+
+.PHONY : clean
+
+clean:
+	rm -f *.o libm65.a m65.exe jt65code.exe


Property changes on: branches/map65/libm65/Makefile.MinGW
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/Makefile.linux
===================================================================
--- branches/map65/libm65/Makefile.linux	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/Makefile.linux	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,96 +1,96 @@
-CC = gcc
-FC = gfortran
-
-FFLAGS = -O2 -fbounds-check -Wall 
-# For ptt_unix:
-CFLAGS = -I. -fbounds-check -DHAVE_STDLIB_H=1 -DHAVE_STDIO_H=1 \
-	-DHAVE_FCNTL_H=1 -DHAVE_SYS_IOCTL_H=1
-
-# Default rules
-%.o: %.c
-	${CC} ${CFLAGS} -c $&lt;
-%.o: %.f
-	${FC} ${FFLAGS} -c $&lt;
-%.o: %.F
-	${FC} ${FFLAGS} -c $&lt;
-%.o: %.f90
-	${FC} ${FFLAGS} -c $&lt;
-%.o: %.F90
-	${FC} ${FFLAGS} -c $&lt;
-
-all:    libm65.a m65
-
-OBJS1 = trimlist.o display.o getdphi.o pctile.o ccf65.o \
-	decode1a.o sort.o filbig.o fil6521.o afc65b.o \
-	twkfreq.o decode65b.o indexx.o ssort.o fchisq.o setup65.o \
-	extract.o deep65.o ccf2.o demod64a.o chkhist.o graycode.o \
-	interleave63.o unpackmsg.o encode65.o igray.o set.o unpackcall.o \
-	unpackgrid.o grid2k.o unpacktext.o getpfx2.o packmsg.o \
-	deg2grid.o packtext.o getpfx1.o packcall.o k2grid.o packgrid.o \
-	wrapkarn.o nchar.o init_rs.o encode_rs.o decode_rs.o \
-	four2a.o rfile3a.o grid2deg.o pfxdump.o dpol.o \
-	astro.o tm2.o sun.o moondop.o coord.o tmoonsub.o \
-	geocentric.o moon2.o toxyz.o dot.o dcoord.o f77_wisdom.o \
-	gen65.o chkmsg.o ptt_unix.o astrosub.o astro0.o recvpkt.o \
-	symspec.o iqcal.o iqfix.o timf2.o s3avg.o
-
-libm65.a: $(OBJS1)
-	ar cr libm65.a $(OBJS1) 
-	ranlib libm65.a
-
-OBJS3 = m65.o m65a.o map65a.o symspec.o decode0.o ftninit.o ftnquit.o \
-	timer.o ipcomm.o sec_midn.o cutil.o 
-
-m65:	$(OBJS3) libm65.a
-	g++ -o m65 $(OBJS3) libm65.a -lfftw3f -lQtCore -lfftw3f -lgfortran
-
-OBJS2 = m65a.o ipcomm.o sec_midn.o cutil.o decode0.o map65a.o \
-	timer.o ftninit.o ftnquit.o
-LIBS2    = -lQtCore -lfftw3f -lgfortran
-
-m65a: 	 $(OBJS2) libm65.a
-	 g++ -o m65a $(OBJS2) libm65.a -lQtCore -lfftw3f -lgfortran
-
-OBJS6 = t3.o ipcomm.o 
-LIBS2    = -lQtCore -lgfortran
-
-t3: 	 $(OBJS6) 
-	 g++ -o t3 $(OBJS6) $(LIBS2)
-
-t3:	
-
-INCPATH = -I. -I'/usr/include/qt4' -I'/usr/include/qt4/QtCore'
-
-ipcomm.o: ipcomm.cpp
-	g++ -c $(INCPATH) ipcomm.cpp
-
-m65a.o:	m65a.F90
-	$(FC) -c -fno-second-underscore -DUNIX m65a.F90
-
-extract.o: extract.F
-	$(FC) -c -fno-second-underscore -DUNIX extract.F
-
-sec_midn.o: sec_midn.f90
-	$(FC) -c -fno-second-underscore sec_midn.f90
-
-OBJS4 = tastro.o astro0.o libm65.a
-tastro: $(OBJS4)
-	$(FC) $(FFLAGS) -o tastro $(OBJS4) libm65.a 
-
-OBJS5 = t1.o timer.o libm65.a
-t1: $(OBJS5)
-	$(FC) $(FFLAGS) -o t1 $(OBJS5) libm65.a 
-
-init_rs.o: init_rs.c
-	$(CC) -c -DBIGSYM=1 -o init_rs.o init_rs.c
-
-encode_rs.o: encode_rs.c
-	$(CC) -c -DBIGSYM=1 -o encode_rs.o encode_rs.c
-
-decode_rs.o: decode_rs.c
-	$(CC) -c -DBIGSYM=1 -o decode_rs.o decode_rs.c
-
-.PHONY : clean
-
-clean:
-	rm -f *.o libm65.a m65 m65a
+CC = gcc
+FC = gfortran
+
+FFLAGS = -O2 -fbounds-check -Wall 
+# For ptt_unix:
+CFLAGS = -I. -fbounds-check -DHAVE_STDLIB_H=1 -DHAVE_STDIO_H=1 \
+	-DHAVE_FCNTL_H=1 -DHAVE_SYS_IOCTL_H=1
+
+# Default rules
+%.o: %.c
+	${CC} ${CFLAGS} -c $&lt;
+%.o: %.f
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.f90
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F90
+	${FC} ${FFLAGS} -c $&lt;
+
+all:    libm65.a m65
+
+OBJS1 = trimlist.o display.o getdphi.o pctile.o ccf65.o \
+	decode1a.o sort.o filbig.o fil6521.o afc65b.o \
+	twkfreq.o decode65b.o indexx.o ssort.o fchisq.o setup65.o \
+	extract.o deep65.o ccf2.o demod64a.o chkhist.o graycode.o \
+	interleave63.o unpackmsg.o encode65.o igray.o set.o unpackcall.o \
+	unpackgrid.o grid2k.o unpacktext.o getpfx2.o packmsg.o \
+	deg2grid.o packtext.o getpfx1.o packcall.o k2grid.o packgrid.o \
+	wrapkarn.o nchar.o init_rs.o encode_rs.o decode_rs.o \
+	four2a.o rfile3a.o grid2deg.o pfxdump.o dpol.o \
+	astro.o tm2.o sun.o moondop.o coord.o tmoonsub.o \
+	geocentric.o moon2.o toxyz.o dot.o dcoord.o f77_wisdom.o \
+	gen65.o chkmsg.o ptt_unix.o astrosub.o astro0.o recvpkt.o \
+	symspec.o iqcal.o iqfix.o timf2.o s3avg.o
+
+libm65.a: $(OBJS1)
+	ar cr libm65.a $(OBJS1) 
+	ranlib libm65.a
+
+OBJS3 = m65.o m65a.o map65a.o symspec.o decode0.o ftninit.o ftnquit.o \
+	timer.o ipcomm.o sec_midn.o cutil.o 
+
+m65:	$(OBJS3) libm65.a
+	g++ -o m65 $(OBJS3) libm65.a -lfftw3f -lQtCore -lfftw3f -lgfortran
+
+OBJS2 = m65a.o ipcomm.o sec_midn.o cutil.o decode0.o map65a.o \
+	timer.o ftninit.o ftnquit.o
+LIBS2    = -lQtCore -lfftw3f -lgfortran
+
+m65a: 	 $(OBJS2) libm65.a
+	 g++ -o m65a $(OBJS2) libm65.a -lQtCore -lfftw3f -lgfortran
+
+OBJS6 = t3.o ipcomm.o 
+LIBS2    = -lQtCore -lgfortran
+
+t3: 	 $(OBJS6) 
+	 g++ -o t3 $(OBJS6) $(LIBS2)
+
+t3:	
+
+INCPATH = -I. -I'/usr/include/qt4' -I'/usr/include/qt4/QtCore'
+
+ipcomm.o: ipcomm.cpp
+	g++ -c $(INCPATH) ipcomm.cpp
+
+m65a.o:	m65a.F90
+	$(FC) -c -fno-second-underscore -DUNIX m65a.F90
+
+extract.o: extract.F
+	$(FC) -c -fno-second-underscore -DUNIX extract.F
+
+sec_midn.o: sec_midn.f90
+	$(FC) -c -fno-second-underscore sec_midn.f90
+
+OBJS4 = tastro.o astro0.o libm65.a
+tastro: $(OBJS4)
+	$(FC) $(FFLAGS) -o tastro $(OBJS4) libm65.a 
+
+OBJS5 = t1.o timer.o libm65.a
+t1: $(OBJS5)
+	$(FC) $(FFLAGS) -o t1 $(OBJS5) libm65.a 
+
+init_rs.o: init_rs.c
+	$(CC) -c -DBIGSYM=1 -o init_rs.o init_rs.c
+
+encode_rs.o: encode_rs.c
+	$(CC) -c -DBIGSYM=1 -o encode_rs.o encode_rs.c
+
+decode_rs.o: decode_rs.c
+	$(CC) -c -DBIGSYM=1 -o decode_rs.o decode_rs.c
+
+.PHONY : clean
+
+clean:
+	rm -f *.o libm65.a m65 m65a


Property changes on: branches/map65/libm65/Makefile.linux
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/afc65b.f
===================================================================
--- branches/map65/libm65/afc65b.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/afc65b.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,68 +1,68 @@
-      subroutine afc65b(cx,cy,npts,fsample,nflip,ipol,xpol,a,
-     +  ccfbest,dtbest)
-
-      logical xpol
-      complex cx(npts)
-      complex cy(npts)
-      real a(5),deltaa(5)
-
-      a(1)=0.
-      a(2)=0.
-      a(3)=0.
-      a(4)=45.0*(ipol-1.0)
-      deltaa(1)=2.0
-      deltaa(2)=2.0
-      deltaa(3)=2.0
-      deltaa(4)=22.5
-      deltaa(5)=0.05
-      nterms=3
-      if(xpol) nterms=4
-      chisqr=0.
-
-C  Start the iteration
-      chisqr0=1.e6
-      do iter=1,3                               !One iteration is enough?
-         do j=1,nterms
-            chisq1=fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
-            fn=0.
-            delta=deltaa(j)
- 10         a(j)=a(j)+delta
-            chisq2=fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
-            if(chisq2.eq.chisq1) go to 10
-            if(chisq2.gt.chisq1) then
-               delta=-delta                      !Reverse direction
-               a(j)=a(j)+delta
-               tmp=chisq1
-               chisq1=chisq2
-               chisq2=tmp
-            endif
- 20         fn=fn+1.0
-            a(j)=a(j)+delta
-            chisq3=fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
-            if(chisq3.lt.chisq2) then
-               chisq1=chisq2
-               chisq2=chisq3
-               go to 20
-            endif
-
-C  Find minimum of parabola defined by last three points
-            delta=delta*(1./(1.+(chisq1-chisq2)/(chisq3-chisq2))+0.5)
-            a(j)=a(j)-delta
-            deltaa(j)=deltaa(j)*fn/3.
-         enddo
-         chisqr=fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
-         if(chisqr/chisqr0.gt.0.9999) go to 30
-         chisqr0=chisqr
-      enddo
-
- 30   ccfbest=ccfmax * (1378.125/fsample)**2
-      dtbest=dtmax
-
-      if(a(4).lt.0.0) a(4)=a(4)+180.0
-      if(a(4).ge.180.0) a(4)=a(4)-180.0
-      if(nint(a(4)).eq.180) a(4)=0.
-      ipol=nint(a(4)/45.0) + 1
-      if(ipol.gt.4) ipol=ipol-4
-
-      return
-      end
+      subroutine afc65b(cx,cy,npts,fsample,nflip,ipol,xpol,a,
+     +  ccfbest,dtbest)
+
+      logical xpol
+      complex cx(npts)
+      complex cy(npts)
+      real a(5),deltaa(5)
+
+      a(1)=0.
+      a(2)=0.
+      a(3)=0.
+      a(4)=45.0*(ipol-1.0)
+      deltaa(1)=2.0
+      deltaa(2)=2.0
+      deltaa(3)=2.0
+      deltaa(4)=22.5
+      deltaa(5)=0.05
+      nterms=3
+      if(xpol) nterms=4
+      chisqr=0.
+
+C  Start the iteration
+      chisqr0=1.e6
+      do iter=1,3                               !One iteration is enough?
+         do j=1,nterms
+            chisq1=fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
+            fn=0.
+            delta=deltaa(j)
+ 10         a(j)=a(j)+delta
+            chisq2=fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
+            if(chisq2.eq.chisq1) go to 10
+            if(chisq2.gt.chisq1) then
+               delta=-delta                      !Reverse direction
+               a(j)=a(j)+delta
+               tmp=chisq1
+               chisq1=chisq2
+               chisq2=tmp
+            endif
+ 20         fn=fn+1.0
+            a(j)=a(j)+delta
+            chisq3=fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
+            if(chisq3.lt.chisq2) then
+               chisq1=chisq2
+               chisq2=chisq3
+               go to 20
+            endif
+
+C  Find minimum of parabola defined by last three points
+            delta=delta*(1./(1.+(chisq1-chisq2)/(chisq3-chisq2))+0.5)
+            a(j)=a(j)-delta
+            deltaa(j)=deltaa(j)*fn/3.
+         enddo
+         chisqr=fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
+         if(chisqr/chisqr0.gt.0.9999) go to 30
+         chisqr0=chisqr
+      enddo
+
+ 30   ccfbest=ccfmax * (1378.125/fsample)**2
+      dtbest=dtmax
+
+      if(a(4).lt.0.0) a(4)=a(4)+180.0
+      if(a(4).ge.180.0) a(4)=a(4)-180.0
+      if(nint(a(4)).eq.180) a(4)=0.
+      ipol=nint(a(4)/45.0) + 1
+      if(ipol.gt.4) ipol=ipol-4
+
+      return
+      end


Property changes on: branches/map65/libm65/afc65b.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/astro.f
===================================================================
--- branches/map65/libm65/astro.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/astro.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,109 +1,109 @@
-      subroutine astro(nyear,month,nday,uth,nfreq,Mygrid,
-     +     NStation,MoonDX,AzSun,ElSun,AzMoon0,ElMoon0,
-     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
-     +     poloffset,xnr,day,lon,lat,LST)
-
-C  Computes astronomical quantities for display and tracking.
-C  NB: may want to smooth the Tsky map to 10 degrees or so.
-
-      character*6 MyGrid,HisGrid
-      real LST
-      real lat,lon
-      integer*2 nt144(180)
-
-!      common/echo/xdop(2),techo,AzMoon,ElMoon,mjd
-      real xdop(2)
-
-      data rad/57.2957795/
-      data nt144/
-     +  234, 246, 257, 267, 275, 280, 283, 286, 291, 298,
-     +  305, 313, 322, 331, 341, 351, 361, 369, 376, 381, 
-     +  383, 382, 379, 374, 370, 366, 363, 361, 363, 368, 
-     +  376, 388, 401, 415, 428, 440, 453, 467, 487, 512, 
-     +  544, 579, 607, 618, 609, 588, 563, 539, 512, 482, 
-     +  450, 422, 398, 379, 363, 349, 334, 319, 302, 282, 
-     +  262, 242, 226, 213, 205, 200, 198, 197, 196, 197, 
-     +  200, 202, 204, 205, 204, 203, 202, 201, 203, 206, 
-     +  212, 218, 223, 227, 231, 236, 240, 243, 247, 257, 
-     +  276, 301, 324, 339, 346, 344, 339, 331, 323, 316, 
-     +  312, 310, 312, 317, 327, 341, 358, 375, 392, 407, 
-     +  422, 437, 451, 466, 480, 494, 511, 530, 552, 579, 
-     +  612, 653, 702, 768, 863,1008,1232,1557,1966,2385, 
-     + 2719,2924,3018,3038,2986,2836,2570,2213,1823,1461, 
-     + 1163, 939, 783, 677, 602, 543, 494, 452, 419, 392, 
-     +  373, 360, 353, 350, 350, 350, 350, 350, 350, 348, 
-     +  344, 337, 329, 319, 307, 295, 284, 276, 272, 272, 
-     +  273, 274, 274, 271, 266, 260, 252, 245, 238, 231/
-      save
-
-      call grid2deg(MyGrid,elon,lat)
-      lon=-elon
-      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
-     +    AzSun,ElSun,mjd,day)
-
-      freq=nfreq*1.e6
-      if(nfreq.eq.2) freq=1.8e6
-      if(nfreq.eq.4) freq=3.5e6
-
-      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
-     +  LST,HA,AzMoon,ElMoon,vr,dist)
-
-C  Compute spatial polarization offset
-      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
-     +     cos(AzMoon/rad)*sin(ElMoon/rad)
-      yy=cos(lat/rad)*sin(AzMoon/rad)
-      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
-      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
-
-      techo=2.0 * dist/2.99792458e5                 !Echo delay time
-      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
-
-      call coord(0.,0.,-1.570796,1.161639,RAMoon/rad,DecMoon/rad,el,eb)
-      longecl_half=nint(rad*el/2.0)
-      if(longecl_half.lt.1 .or. longecl_half.gt.180) longecl_half=180
-      t144=nt144(longecl_half)
-      tsky=(t144-2.7)*(144.0/nfreq)**2.6 + 2.7      !Tsky for obs freq
-
-      xdop(NStation)=doppler
-      if(NStation.eq.2) then
-         HisGrid=MyGrid
-         go to 900
-      endif
-
-      doppler00=2.0*xdop(1)
-      doppler=xdop(1)+xdop(2)
-!      if(mode.eq.3) doppler=2.0*xdop(1)
-      dBMoon=-40.0*log10(dist/356903.)
-      sd=16.23*370152.0/dist
-
-!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
-!     +    (mode.eq.2 .or. mode.eq.5)) then
-      if(NStation.eq.1 .and. MoonDX.ne.0) then
-         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
-         if(poloffset.gt.90.0) poloffset=poloffset-180.0
-         x1=abs(cos(2*poloffset/rad))
-         if(x1.lt.0.056234) x1=0.056234
-         xnr=-20.0*log10(x1)
-         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'R') xnr=0
-      endif
-
-      tr=80.0                              !Good preamp
-      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
-      tsysmin=tskymin+tr
-      tsys=tsky+tr
-      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
- 900  AzMoon0=Azmoon
-      ElMoon0=Elmoon
-      ntsky=nint(tsky)
-
-!      auxHA = 15.0*(LST-auxra)                       !HA in degrees
-!      pi=3.14159265
-!      pio2=0.5*pi
-!      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
-!     +  auxdec/rad,azaux,elaux)
-!      AzAux=azaux*rad
-!      ElAux=ElAux*rad
-
-      return
-
-      end
+      subroutine astro(nyear,month,nday,uth,nfreq,Mygrid,
+     +     NStation,MoonDX,AzSun,ElSun,AzMoon0,ElMoon0,
+     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
+     +     poloffset,xnr,day,lon,lat,LST)
+
+C  Computes astronomical quantities for display and tracking.
+C  NB: may want to smooth the Tsky map to 10 degrees or so.
+
+      character*6 MyGrid,HisGrid
+      real LST
+      real lat,lon
+      integer*2 nt144(180)
+
+!      common/echo/xdop(2),techo,AzMoon,ElMoon,mjd
+      real xdop(2)
+
+      data rad/57.2957795/
+      data nt144/
+     +  234, 246, 257, 267, 275, 280, 283, 286, 291, 298,
+     +  305, 313, 322, 331, 341, 351, 361, 369, 376, 381, 
+     +  383, 382, 379, 374, 370, 366, 363, 361, 363, 368, 
+     +  376, 388, 401, 415, 428, 440, 453, 467, 487, 512, 
+     +  544, 579, 607, 618, 609, 588, 563, 539, 512, 482, 
+     +  450, 422, 398, 379, 363, 349, 334, 319, 302, 282, 
+     +  262, 242, 226, 213, 205, 200, 198, 197, 196, 197, 
+     +  200, 202, 204, 205, 204, 203, 202, 201, 203, 206, 
+     +  212, 218, 223, 227, 231, 236, 240, 243, 247, 257, 
+     +  276, 301, 324, 339, 346, 344, 339, 331, 323, 316, 
+     +  312, 310, 312, 317, 327, 341, 358, 375, 392, 407, 
+     +  422, 437, 451, 466, 480, 494, 511, 530, 552, 579, 
+     +  612, 653, 702, 768, 863,1008,1232,1557,1966,2385, 
+     + 2719,2924,3018,3038,2986,2836,2570,2213,1823,1461, 
+     + 1163, 939, 783, 677, 602, 543, 494, 452, 419, 392, 
+     +  373, 360, 353, 350, 350, 350, 350, 350, 350, 348, 
+     +  344, 337, 329, 319, 307, 295, 284, 276, 272, 272, 
+     +  273, 274, 274, 271, 266, 260, 252, 245, 238, 231/
+      save
+
+      call grid2deg(MyGrid,elon,lat)
+      lon=-elon
+      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
+     +    AzSun,ElSun,mjd,day)
+
+      freq=nfreq*1.e6
+      if(nfreq.eq.2) freq=1.8e6
+      if(nfreq.eq.4) freq=3.5e6
+
+      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
+     +  LST,HA,AzMoon,ElMoon,vr,dist)
+
+C  Compute spatial polarization offset
+      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
+     +     cos(AzMoon/rad)*sin(ElMoon/rad)
+      yy=cos(lat/rad)*sin(AzMoon/rad)
+      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
+      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
+
+      techo=2.0 * dist/2.99792458e5                 !Echo delay time
+      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
+
+      call coord(0.,0.,-1.570796,1.161639,RAMoon/rad,DecMoon/rad,el,eb)
+      longecl_half=nint(rad*el/2.0)
+      if(longecl_half.lt.1 .or. longecl_half.gt.180) longecl_half=180
+      t144=nt144(longecl_half)
+      tsky=(t144-2.7)*(144.0/nfreq)**2.6 + 2.7      !Tsky for obs freq
+
+      xdop(NStation)=doppler
+      if(NStation.eq.2) then
+         HisGrid=MyGrid
+         go to 900
+      endif
+
+      doppler00=2.0*xdop(1)
+      doppler=xdop(1)+xdop(2)
+!      if(mode.eq.3) doppler=2.0*xdop(1)
+      dBMoon=-40.0*log10(dist/356903.)
+      sd=16.23*370152.0/dist
+
+!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
+!     +    (mode.eq.2 .or. mode.eq.5)) then
+      if(NStation.eq.1 .and. MoonDX.ne.0) then
+         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
+         if(poloffset.gt.90.0) poloffset=poloffset-180.0
+         x1=abs(cos(2*poloffset/rad))
+         if(x1.lt.0.056234) x1=0.056234
+         xnr=-20.0*log10(x1)
+         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'R') xnr=0
+      endif
+
+      tr=80.0                              !Good preamp
+      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
+      tsysmin=tskymin+tr
+      tsys=tsky+tr
+      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
+ 900  AzMoon0=Azmoon
+      ElMoon0=Elmoon
+      ntsky=nint(tsky)
+
+!      auxHA = 15.0*(LST-auxra)                       !HA in degrees
+!      pi=3.14159265
+!      pio2=0.5*pi
+!      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
+!     +  auxdec/rad,azaux,elaux)
+!      AzAux=azaux*rad
+!      ElAux=ElAux*rad
+
+      return
+
+      end


Property changes on: branches/map65/libm65/astro.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/astro0.f90
===================================================================
--- branches/map65/libm65/astro0.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/astro0.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,81 +1,81 @@
-subroutine astro0(nyear,month,nday,uth8,nfreq,mygrid,hisgrid,              &amp;
-     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,    &amp;
-     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,    &amp;
-     width1,width2,w501,w502,xlst8)
-
-  parameter (DEGS=57.2957795130823d0)
-  character*6 mygrid,hisgrid
-  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8
-  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0,dt
-  real*8 sd8,poloffset8,day8,width1,width2,w501,w502,xlst8
-  real*8 uth8
-  data uth8z/0.d0/
-  save
-
-  uth=uth8
-  call astro(nyear,month,nday,uth,nfreq,hisgrid,2,1,                 &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,               &amp;
-       day,xlon2,xlat2,xlst)
-  AzMoonB8=AzMoon
-  ElMoonB8=ElMoon
-  call astro(nyear,month,nday,uth,nfreq,mygrid,1,1,                  &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,               &amp;
-       day,xlon1,xlat1,xlst)
-
-  day8=day
-  xlst8=xlst
-  call tm2(day8,xlat1,xlon1,xl1,b1)
-  call tm2(day8,xlat2,xlon2,xl2,b2)
-  call tm2(day8+1.d0/1440.0,xlat1,xlon1,xl1a,b1a)
-  call tm2(day8+1.d0/1440.0,xlat2,xlon2,xl2a,b2a)
-  fghz=0.001*nfreq
-  dldt1=DEGS*(xl1a-xl1)
-  dbdt1=DEGS*(b1a-b1)
-  dldt2=DEGS*(xl2a-xl2)
-  dbdt2=DEGS*(b2a-b2)
-  rate1=2.0*sqrt(dldt1**2 + dbdt1**2)
-  width1=0.5*6741*fghz*rate1
-  rate2=sqrt((dldt1+dldt2)**2 + (dbdt1+dbdt2)**2)
-  width2=0.5*6741*fghz*rate2
-
-  fbend=0.7
-  a2=0.0045*log(fghz/fbend)/log(1.05)
-  if(fghz.lt.fbend) a2=0.0
-  f50=0.19 * (fghz/fbend)**a2
-  if(f50.gt.1.0) f50=1.0
-  w501=f50*width1
-  w502=f50*width2
-
-  AzSun8=AzSun
-  ElSun8=ElSun
-  AzMoon8=AzMoon
-  ElMoon8=ElMoon
-  dbMoon8=dbMoon
-  RAMoon8=RAMoon/15.0
-  DecMoon8=DecMoon
-  HA8=HA
-  Dgrd8=Dgrd
-  sd8=sd
-  poloffset8=poloffset
-  xnr8=xnr
-  ndop=nint(doppler)
-  ndop00=nint(doppler00)
-
-  if(uth8z.eq.0.d0) then
-     uth8z=uth8-1.d0/3600.d0
-     dopplerz=doppler
-     doppler00z=doppler00
-  endif
-     
-  dt=60.0*(uth8-uth8z)
-  if(dt.le.0) dt=1.d0/60.d0
-  dfdt=(doppler-dopplerz)/dt
-  dfdt0=(doppler00-doppler00z)/dt
-  uth8z=uth8
-  dopplerz=doppler
-  doppler00z=doppler00
-
-  return
-end subroutine astro0
+subroutine astro0(nyear,month,nday,uth8,nfreq,mygrid,hisgrid,              &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,    &amp;
+     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,    &amp;
+     width1,width2,w501,w502,xlst8)
+
+  parameter (DEGS=57.2957795130823d0)
+  character*6 mygrid,hisgrid
+  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8
+  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0,dt
+  real*8 sd8,poloffset8,day8,width1,width2,w501,w502,xlst8
+  real*8 uth8
+  data uth8z/0.d0/
+  save
+
+  uth=uth8
+  call astro(nyear,month,nday,uth,nfreq,hisgrid,2,1,                 &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,               &amp;
+       day,xlon2,xlat2,xlst)
+  AzMoonB8=AzMoon
+  ElMoonB8=ElMoon
+  call astro(nyear,month,nday,uth,nfreq,mygrid,1,1,                  &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,               &amp;
+       day,xlon1,xlat1,xlst)
+
+  day8=day
+  xlst8=xlst
+  call tm2(day8,xlat1,xlon1,xl1,b1)
+  call tm2(day8,xlat2,xlon2,xl2,b2)
+  call tm2(day8+1.d0/1440.0,xlat1,xlon1,xl1a,b1a)
+  call tm2(day8+1.d0/1440.0,xlat2,xlon2,xl2a,b2a)
+  fghz=0.001*nfreq
+  dldt1=DEGS*(xl1a-xl1)
+  dbdt1=DEGS*(b1a-b1)
+  dldt2=DEGS*(xl2a-xl2)
+  dbdt2=DEGS*(b2a-b2)
+  rate1=2.0*sqrt(dldt1**2 + dbdt1**2)
+  width1=0.5*6741*fghz*rate1
+  rate2=sqrt((dldt1+dldt2)**2 + (dbdt1+dbdt2)**2)
+  width2=0.5*6741*fghz*rate2
+
+  fbend=0.7
+  a2=0.0045*log(fghz/fbend)/log(1.05)
+  if(fghz.lt.fbend) a2=0.0
+  f50=0.19 * (fghz/fbend)**a2
+  if(f50.gt.1.0) f50=1.0
+  w501=f50*width1
+  w502=f50*width2
+
+  AzSun8=AzSun
+  ElSun8=ElSun
+  AzMoon8=AzMoon
+  ElMoon8=ElMoon
+  dbMoon8=dbMoon
+  RAMoon8=RAMoon/15.0
+  DecMoon8=DecMoon
+  HA8=HA
+  Dgrd8=Dgrd
+  sd8=sd
+  poloffset8=poloffset
+  xnr8=xnr
+  ndop=nint(doppler)
+  ndop00=nint(doppler00)
+
+  if(uth8z.eq.0.d0) then
+     uth8z=uth8-1.d0/3600.d0
+     dopplerz=doppler
+     doppler00z=doppler00
+  endif
+     
+  dt=60.0*(uth8-uth8z)
+  if(dt.le.0) dt=1.d0/60.d0
+  dfdt=(doppler-dopplerz)/dt
+  dfdt0=(doppler00-doppler00z)/dt
+  uth8z=uth8
+  dopplerz=doppler
+  doppler00z=doppler00
+
+  return
+end subroutine astro0


Property changes on: branches/map65/libm65/astro0.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/astrosub.f90
===================================================================
--- branches/map65/libm65/astrosub.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/astrosub.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,14 +1,14 @@
-subroutine astrosub(nyear,month,nday,uth8,nfreq,mygrid,hisgrid,          &amp;
-     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
-     RAMoon8,DecMoon8,Dgrd8,poloffset8,xnr8)
-
-  implicit real*8 (a-h,o-z)
-  character*6 mygrid,hisgrid
-
-  call astro0(nyear,month,nday,uth8,nfreq,mygrid,hisgrid,                &amp;
-     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
-     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
-     width1,width2,w501,w502,xlst8)
-
-  return  
-end subroutine astrosub
+subroutine astrosub(nyear,month,nday,uth8,nfreq,mygrid,hisgrid,          &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
+     RAMoon8,DecMoon8,Dgrd8,poloffset8,xnr8)
+
+  implicit real*8 (a-h,o-z)
+  character*6 mygrid,hisgrid
+
+  call astro0(nyear,month,nday,uth8,nfreq,mygrid,hisgrid,                &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
+     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
+     width1,width2,w501,w502,xlst8)
+
+  return  
+end subroutine astrosub


Property changes on: branches/map65/libm65/astrosub.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/ccf2.f
===================================================================
--- branches/map65/libm65/ccf2.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/ccf2.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,45 +1,45 @@
-      subroutine ccf2(ss,nz,nflip,ccfbest,lagpk)
-
-      parameter (LAGMAX=60)
-!      parameter (LAGMAX=200)
-      real ss(nz)
-      real ccf(-LAGMAX:LAGMAX)
-      integer npr(126)
-
-C  The JT65 pseudo-random sync pattern:
-      data npr/
-     + 1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,
-     + 0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,
-     + 0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,
-     + 0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,
-     + 1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,
-     + 0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,
-     + 1,1,1,1,1,1/
-      save
-
-      ccfbest=0.
-      lag1=-LAGMAX
-      lag2=LAGMAX
-      do lag=lag1,lag2
-         s0=0.
-         s1=0.
-         do i=1,126
-            j=2*(8*i + 43) + lag
-            if(j.ge.1 .and. j.le.nz-8) then
-               x=ss(j)+ss(j+8)             !Add two half-symbol contributions
-               if(npr(i).eq.0) then
-                  s0=s0 + x
-               else
-                  s1=s1 + x
-               endif
-            endif
-         enddo
-         ccf(lag)=nflip*(s1-s0)
-         if(ccf(lag).gt.ccfbest) then
-            ccfbest=ccf(lag)
-            lagpk=lag
-         endif
-      enddo
-
-      return
-      end
+      subroutine ccf2(ss,nz,nflip,ccfbest,lagpk)
+
+      parameter (LAGMAX=60)
+!      parameter (LAGMAX=200)
+      real ss(nz)
+      real ccf(-LAGMAX:LAGMAX)
+      integer npr(126)
+
+C  The JT65 pseudo-random sync pattern:
+      data npr/
+     + 1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,
+     + 0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,
+     + 0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,
+     + 0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,
+     + 1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,
+     + 0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,
+     + 1,1,1,1,1,1/
+      save
+
+      ccfbest=0.
+      lag1=-LAGMAX
+      lag2=LAGMAX
+      do lag=lag1,lag2
+         s0=0.
+         s1=0.
+         do i=1,126
+            j=2*(8*i + 43) + lag
+            if(j.ge.1 .and. j.le.nz-8) then
+               x=ss(j)+ss(j+8)             !Add two half-symbol contributions
+               if(npr(i).eq.0) then
+                  s0=s0 + x
+               else
+                  s1=s1 + x
+               endif
+            endif
+         enddo
+         ccf(lag)=nflip*(s1-s0)
+         if(ccf(lag).gt.ccfbest) then
+            ccfbest=ccf(lag)
+            lagpk=lag
+         endif
+      enddo
+
+      return
+      end


Property changes on: branches/map65/libm65/ccf2.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/ccf65.f90
===================================================================
--- branches/map65/libm65/ccf65.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/ccf65.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,118 +1,118 @@
-subroutine ccf65(ss,nhsym,ssmax,sync1,ipol1,jpz,dt1,flipk,syncshort,      &amp;
-     snr2,ipol2,dt2)
-
-  parameter (NFFT=512,NH=NFFT/2)
-  real ss(4,322)                   !Input: half-symbol powers, 4 pol'ns
-  real s(NFFT)                     !CCF = ss*pr
-  complex cs(0:NH)                 !Complex FT of s
-  real s2(NFFT)                    !CCF = ss*pr2
-  complex cs2(0:NH)                !Complex FT of s2
-  real pr(NFFT)                    !JT65 pseudo-random sync pattern
-  complex cpr(0:NH)                !Complex FT of pr
-  real pr2(NFFT)                   !JT65 shorthand pattern
-  complex cpr2(0:NH)               !Complex FT of pr2
-  real tmp1(322)
-  real tmp2(322)
-  real ccf(-27:27,4)
-  logical first
-  integer npr(126)
-  data first/.true./
-  equivalence (s,cs),(pr,cpr),(s2,cs2),(pr2,cpr2)
-  save
-
-! The JT65 pseudo-random sync pattern:
-  data npr/                                        &amp;
-      1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,     &amp;
-      0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,     &amp;
-      0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,     &amp;
-      0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,     &amp;
-      1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,     &amp;
-      0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,     &amp;
-      1,1,1,1,1,1/
-
-  if(first) then
-! Initialize pr, pr2; compute cpr, cpr2.
-     fac=1.0/NFFT
-     do i=1,NFFT
-        pr(i)=0.
-        pr2(i)=0.
-        k=2*mod((i-1)/8,2)-1
-        if(i.le.NH) pr2(i)=fac*k
-     enddo
-     do i=1,126
-        j=2*i
-        pr(j)=fac*(2*npr(i)-1)
-! Not sure why, but it works significantly better without the following line:
-!        pr(j-1)=pr(j)
-     enddo
-     call four2a(pr,NFFT,1,-1,0)
-     call four2a(pr2,NFFT,1,-1,0)
-     first=.false.
-  endif
-
-! Look for JT65 sync pattern and shorthand square-wave pattern.
-  ccfbest=0.
-  ccfbest2=0.
-  ipol1=1
-  ipol2=1
-  do ip=1,jpz                                  !Do jpz polarizations
-     do i=1,nhsym-1
-!        s(i)=ss(ip,i)+ss(ip,i+1)
-        s(i)=min(ssmax,ss(ip,i)+ss(ip,i+1))
-     enddo
-     s(nhsym:NFFT)=0.
-     call four2a(s,NFFT,1,-1,0)                !Real-to-complex FFT
-     do i=0,NH
-        cs2(i)=cs(i)*conjg(cpr2(i))            !Mult by complex FFT of pr2
-        cs(i)=cs(i)*conjg(cpr(i))              !Mult by complex FFT of pr
-     enddo
-     call four2a(cs,NFFT,1,1,-1)               !Complex-to-real inv-FFT
-     call four2a(cs2,NFFT,1,1,-1)              !Complex-to-real inv-FFT
-     
-     do lag=-27,27                             !Check for best JT65 sync
-        ccf(lag,ip)=s(lag+28)                  
-        if(abs(ccf(lag,ip)).gt.ccfbest) then
-           ccfbest=abs(ccf(lag,ip))
-           lagpk=lag
-           ipol1=ip
-           flipk=1.0
-           if(ccf(lag,ip).lt.0.0) flipk=-1.0
-        endif
-     enddo
-
-     do lag=-8,7                               !Check for best shorthand
-        ccf2=s2(lag+28)
-        if(ccf2.gt.ccfbest2) then
-           ccfbest2=ccf2
-           lagpk2=lag
-           ipol2=ip
-        endif
-     enddo
-     
-  enddo
-
-! Find rms level on baseline of &quot;ccfblue&quot;, for normalization.
-  sum=0.
-  do lag=-26,26
-     if(abs(lag-lagpk).gt.1) sum=sum + ccf(lag,ipol1)
-  enddo
-  base=sum/50.0
-  sq=0.
-  do lag=-26,26
-     if(abs(lag-lagpk).gt.1) sq=sq + (ccf(lag,ipol1)-base)**2
-  enddo
-  rms=sqrt(sq/49.0)
-  sync1=ccfbest/rms - 4.0
-  dt1=2.5 + lagpk*(2048.0/11025.0)
-
-! Find base level for normalizing snr2.
-  do i=1,nhsym
-     tmp1(i)=ss(ipol2,i)
-  enddo
-  call pctile(tmp1,tmp2,nhsym,40,base)
-  snr2=0.398107*ccfbest2/base                !### empirical
-  syncshort=0.5*ccfbest2/rms - 4.0           !### better normalizer than rms?
-  dt2=2.5 + lagpk2*(2048.0/11025.0)
-
-  return
-end subroutine ccf65
+subroutine ccf65(ss,nhsym,ssmax,sync1,ipol1,jpz,dt1,flipk,syncshort,      &amp;
+     snr2,ipol2,dt2)
+
+  parameter (NFFT=512,NH=NFFT/2)
+  real ss(4,322)                   !Input: half-symbol powers, 4 pol'ns
+  real s(NFFT)                     !CCF = ss*pr
+  complex cs(0:NH)                 !Complex FT of s
+  real s2(NFFT)                    !CCF = ss*pr2
+  complex cs2(0:NH)                !Complex FT of s2
+  real pr(NFFT)                    !JT65 pseudo-random sync pattern
+  complex cpr(0:NH)                !Complex FT of pr
+  real pr2(NFFT)                   !JT65 shorthand pattern
+  complex cpr2(0:NH)               !Complex FT of pr2
+  real tmp1(322)
+  real tmp2(322)
+  real ccf(-27:27,4)
+  logical first
+  integer npr(126)
+  data first/.true./
+  equivalence (s,cs),(pr,cpr),(s2,cs2),(pr2,cpr2)
+  save
+
+! The JT65 pseudo-random sync pattern:
+  data npr/                                        &amp;
+      1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,     &amp;
+      0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,     &amp;
+      0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,     &amp;
+      0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,     &amp;
+      1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,     &amp;
+      0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,     &amp;
+      1,1,1,1,1,1/
+
+  if(first) then
+! Initialize pr, pr2; compute cpr, cpr2.
+     fac=1.0/NFFT
+     do i=1,NFFT
+        pr(i)=0.
+        pr2(i)=0.
+        k=2*mod((i-1)/8,2)-1
+        if(i.le.NH) pr2(i)=fac*k
+     enddo
+     do i=1,126
+        j=2*i
+        pr(j)=fac*(2*npr(i)-1)
+! Not sure why, but it works significantly better without the following line:
+!        pr(j-1)=pr(j)
+     enddo
+     call four2a(pr,NFFT,1,-1,0)
+     call four2a(pr2,NFFT,1,-1,0)
+     first=.false.
+  endif
+
+! Look for JT65 sync pattern and shorthand square-wave pattern.
+  ccfbest=0.
+  ccfbest2=0.
+  ipol1=1
+  ipol2=1
+  do ip=1,jpz                                  !Do jpz polarizations
+     do i=1,nhsym-1
+!        s(i)=ss(ip,i)+ss(ip,i+1)
+        s(i)=min(ssmax,ss(ip,i)+ss(ip,i+1))
+     enddo
+     s(nhsym:NFFT)=0.
+     call four2a(s,NFFT,1,-1,0)                !Real-to-complex FFT
+     do i=0,NH
+        cs2(i)=cs(i)*conjg(cpr2(i))            !Mult by complex FFT of pr2
+        cs(i)=cs(i)*conjg(cpr(i))              !Mult by complex FFT of pr
+     enddo
+     call four2a(cs,NFFT,1,1,-1)               !Complex-to-real inv-FFT
+     call four2a(cs2,NFFT,1,1,-1)              !Complex-to-real inv-FFT
+     
+     do lag=-27,27                             !Check for best JT65 sync
+        ccf(lag,ip)=s(lag+28)                  
+        if(abs(ccf(lag,ip)).gt.ccfbest) then
+           ccfbest=abs(ccf(lag,ip))
+           lagpk=lag
+           ipol1=ip
+           flipk=1.0
+           if(ccf(lag,ip).lt.0.0) flipk=-1.0
+        endif
+     enddo
+
+     do lag=-8,7                               !Check for best shorthand
+        ccf2=s2(lag+28)
+        if(ccf2.gt.ccfbest2) then
+           ccfbest2=ccf2
+           lagpk2=lag
+           ipol2=ip
+        endif
+     enddo
+     
+  enddo
+
+! Find rms level on baseline of &quot;ccfblue&quot;, for normalization.
+  sum=0.
+  do lag=-26,26
+     if(abs(lag-lagpk).gt.1) sum=sum + ccf(lag,ipol1)
+  enddo
+  base=sum/50.0
+  sq=0.
+  do lag=-26,26
+     if(abs(lag-lagpk).gt.1) sq=sq + (ccf(lag,ipol1)-base)**2
+  enddo
+  rms=sqrt(sq/49.0)
+  sync1=ccfbest/rms - 4.0
+  dt1=2.5 + lagpk*(2048.0/11025.0)
+
+! Find base level for normalizing snr2.
+  do i=1,nhsym
+     tmp1(i)=ss(ipol2,i)
+  enddo
+  call pctile(tmp1,tmp2,nhsym,40,base)
+  snr2=0.398107*ccfbest2/base                !### empirical
+  syncshort=0.5*ccfbest2/rms - 4.0           !### better normalizer than rms?
+  dt2=2.5 + lagpk2*(2048.0/11025.0)
+
+  return
+end subroutine ccf65


Property changes on: branches/map65/libm65/ccf65.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/chkhist.f
===================================================================
--- branches/map65/libm65/chkhist.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/chkhist.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,23 +1,23 @@
-      subroutine chkhist(mrsym,nmax,ipk)
-
-      integer mrsym(63)
-      integer hist(0:63)
-
-      do i=0,63
-         hist(i)=0
-      enddo
-      do j=1,63
-         i=mrsym(j)
-         hist(i)=hist(i)+1
-      enddo
-
-      nmax=0
-      do i=0,63
-         if(hist(i).gt.nmax) then
-            nmax=hist(i)
-            ipk=i+1
-         endif
-      enddo
-
-      return
-      end
+      subroutine chkhist(mrsym,nmax,ipk)
+
+      integer mrsym(63)
+      integer hist(0:63)
+
+      do i=0,63
+         hist(i)=0
+      enddo
+      do j=1,63
+         i=mrsym(j)
+         hist(i)=hist(i)+1
+      enddo
+
+      nmax=0
+      do i=0,63
+         if(hist(i).gt.nmax) then
+            nmax=hist(i)
+            ipk=i+1
+         endif
+      enddo
+
+      return
+      end


Property changes on: branches/map65/libm65/chkhist.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/chkmsg.f
===================================================================
--- branches/map65/libm65/chkmsg.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/chkmsg.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,32 +1,32 @@
-      subroutine chkmsg(message,cok,nspecial,flip)
-
-      character message*22,cok*3
-
-      nspecial=0
-      flip=1.0
-      cok=&quot;   &quot;
-
-      do i=22,1,-1
-         if(message(i:i).ne.' ') go to 10
-      enddo
-      i=22
-
- 10   if(i.ge.11) then
-         if ((message(i-3:i).eq.' OOO') .or. 
-     +        (message(20:22).eq.' OO')) then
-            cok='OOO'
-            flip=-1.0
-            if(message(20:22).eq.' OO') then
-               message=message(1:19)
-            else
-               message=message(1:i-4)
-            endif
-         endif
-      endif
-
-      if(message(1:3).eq.'RO ')  nspecial=2
-      if(message(1:4).eq.'RRR ') nspecial=3
-      if(message(1:3).eq.'73 ')  nspecial=4
-
-      return
-      end
+      subroutine chkmsg(message,cok,nspecial,flip)
+
+      character message*22,cok*3
+
+      nspecial=0
+      flip=1.0
+      cok=&quot;   &quot;
+
+      do i=22,1,-1
+         if(message(i:i).ne.' ') go to 10
+      enddo
+      i=22
+
+ 10   if(i.ge.11) then
+         if ((message(i-3:i).eq.' OOO') .or. 
+     +        (message(20:22).eq.' OO')) then
+            cok='OOO'
+            flip=-1.0
+            if(message(20:22).eq.' OO') then
+               message=message(1:19)
+            else
+               message=message(1:i-4)
+            endif
+         endif
+      endif
+
+      if(message(1:3).eq.'RO ')  nspecial=2
+      if(message(1:4).eq.'RRR ') nspecial=3
+      if(message(1:3).eq.'73 ')  nspecial=4
+
+      return
+      end


Property changes on: branches/map65/libm65/chkmsg.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/coord.f
===================================================================
--- branches/map65/libm65/coord.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/coord.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,41 +1,41 @@
-        SUBROUTINE COORD(A0,B0,AP,BP,A1,B1,A2,B2)
-
-C  Examples:
-C  1. From ha,dec to az,el:
-C       call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
-C  2. From az,el to ha,dec:
-C       call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
-C  3. From ra,dec to l,b
-C       call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
-C         ra,dec,l,b)
-C  4. From l,b to ra,dec
-C       call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
-C         0.478220215d0,l,b,ra,dec)
-C  5. From ra,dec to ecliptic latitude (eb) and longitude (el):
-C       call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
-C  6. From ecliptic latitude (eb) and longitude (el) to ra,dec:
-C       call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,el,eb,ra,dec)
-
-
-      SB0=sin(B0)
-      CB0=cos(B0)
-      SBP=sin(BP)
-      CBP=cos(BP)
-      SB1=sin(B1)
-      CB1=cos(B1)
-      SB2=SBP*SB1 + CBP*CB1*cos(AP-A1)
-      CB2=SQRT(1.e0-SB2**2)
-      B2=atan(SB2/CB2)
-      SAA=sin(AP-A1)*CB1/CB2
-      CAA=(SB1-SB2*SBP)/(CB2*CBP)
-      CBB=SB0/CBP
-      SBB=sin(AP-A0)*CB0
-      SA2=SAA*CBB-CAA*SBB
-      CA2=CAA*CBB+SAA*SBB
-      TA2O2=0.0 !Shut up compiler warnings. -db
-      IF(CA2.LE.0.e0) TA2O2=(1.e0-CA2)/SA2 
-      IF(CA2.GT.0.e0) TA2O2=SA2/(1.e0+CA2)
-      A2=2.e0*atan(TA2O2)
-      IF(A2.LT.0.e0) A2=A2+6.2831853
-      RETURN
-      END
+        SUBROUTINE COORD(A0,B0,AP,BP,A1,B1,A2,B2)
+
+C  Examples:
+C  1. From ha,dec to az,el:
+C       call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
+C  2. From az,el to ha,dec:
+C       call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
+C  3. From ra,dec to l,b
+C       call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
+C         ra,dec,l,b)
+C  4. From l,b to ra,dec
+C       call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
+C         0.478220215d0,l,b,ra,dec)
+C  5. From ra,dec to ecliptic latitude (eb) and longitude (el):
+C       call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
+C  6. From ecliptic latitude (eb) and longitude (el) to ra,dec:
+C       call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,el,eb,ra,dec)
+
+
+      SB0=sin(B0)
+      CB0=cos(B0)
+      SBP=sin(BP)
+      CBP=cos(BP)
+      SB1=sin(B1)
+      CB1=cos(B1)
+      SB2=SBP*SB1 + CBP*CB1*cos(AP-A1)
+      CB2=SQRT(1.e0-SB2**2)
+      B2=atan(SB2/CB2)
+      SAA=sin(AP-A1)*CB1/CB2
+      CAA=(SB1-SB2*SBP)/(CB2*CBP)
+      CBB=SB0/CBP
+      SBB=sin(AP-A0)*CB0
+      SA2=SAA*CBB-CAA*SBB
+      CA2=CAA*CBB+SAA*SBB
+      TA2O2=0.0 !Shut up compiler warnings. -db
+      IF(CA2.LE.0.e0) TA2O2=(1.e0-CA2)/SA2 
+      IF(CA2.GT.0.e0) TA2O2=SA2/(1.e0+CA2)
+      A2=2.e0*atan(TA2O2)
+      IF(A2.LT.0.e0) A2=A2+6.2831853
+      RETURN
+      END


Property changes on: branches/map65/libm65/coord.f
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: branches/map65/libm65/cutil.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/dcoord.f
===================================================================
--- branches/map65/libm65/dcoord.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/dcoord.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,40 +1,40 @@
-        SUBROUTINE DCOORD(A0,B0,AP,BP,A1,B1,A2,B2)
-
-        implicit real*8 (a-h,o-z)
-C  Examples:
-C  1. From ha,dec to az,el:
-C       call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
-C  2. From az,el to ha,dec:
-C       call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
-C  3. From ra,dec to l,b
-C       call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
-C         ra,dec,l,b)
-C  4. From l,b to ra,dec
-C       call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
-C         0.478220215d0,l,b,ra,dec)
-C  5. From ecliptic latitude (eb) and longitude (el) to ra, dec:
-C       call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
-
-      SB0=sin(B0)
-      CB0=cos(B0)
-      SBP=sin(BP)
-      CBP=cos(BP)
-      SB1=sin(B1)
-      CB1=cos(B1)
-      SB2=SBP*SB1 + CBP*CB1*cos(AP-A1)
-      CB2=SQRT(1.D0-SB2**2)
-      B2=atan(SB2/CB2)
-      SAA=sin(AP-A1)*CB1/CB2
-      CAA=(SB1-SB2*SBP)/(CB2*CBP)
-      CBB=SB0/CBP
-      SBB=sin(AP-A0)*CB0
-      SA2=SAA*CBB-CAA*SBB
-      CA2=CAA*CBB+SAA*SBB
-      TA2O2=0.0 !Shut up compiler warnings. -db
-      IF(CA2.LE.0.D0) TA2O2=(1.D0-CA2)/SA2 
-      IF(CA2.GT.0.D0) TA2O2=SA2/(1.D0+CA2)
-      A2=2.D0*atan(TA2O2)
-      IF(A2.LT.0.D0) A2=A2+6.2831853071795864D0
-
-      RETURN
-      END
+        SUBROUTINE DCOORD(A0,B0,AP,BP,A1,B1,A2,B2)
+
+        implicit real*8 (a-h,o-z)
+C  Examples:
+C  1. From ha,dec to az,el:
+C       call coord(pi,pio2-lat,0.,lat,ha,dec,az,el)
+C  2. From az,el to ha,dec:
+C       call coord(pi,pio2-lat,0.,lat,az,el,ha,dec)
+C  3. From ra,dec to l,b
+C       call coord(4.635594495,-0.504691042,3.355395488,0.478220215,
+C         ra,dec,l,b)
+C  4. From l,b to ra,dec
+C       call coord(1.705981071d0,-1.050357016d0,2.146800277d0,
+C         0.478220215d0,l,b,ra,dec)
+C  5. From ecliptic latitude (eb) and longitude (el) to ra, dec:
+C       call coord(0.d0,0.d0,-pio2,pio2-23.443*pi/180,ra,dec,el,eb)
+
+      SB0=sin(B0)
+      CB0=cos(B0)
+      SBP=sin(BP)
+      CBP=cos(BP)
+      SB1=sin(B1)
+      CB1=cos(B1)
+      SB2=SBP*SB1 + CBP*CB1*cos(AP-A1)
+      CB2=SQRT(1.D0-SB2**2)
+      B2=atan(SB2/CB2)
+      SAA=sin(AP-A1)*CB1/CB2
+      CAA=(SB1-SB2*SBP)/(CB2*CBP)
+      CBB=SB0/CBP
+      SBB=sin(AP-A0)*CB0
+      SA2=SAA*CBB-CAA*SBB
+      CA2=CAA*CBB+SAA*SBB
+      TA2O2=0.0 !Shut up compiler warnings. -db
+      IF(CA2.LE.0.D0) TA2O2=(1.D0-CA2)/SA2 
+      IF(CA2.GT.0.D0) TA2O2=SA2/(1.D0+CA2)
+      A2=2.D0*atan(TA2O2)
+      IF(A2.LT.0.D0) A2=A2+6.2831853071795864D0
+
+      RETURN
+      END


Property changes on: branches/map65/libm65/dcoord.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/decode0.f90
===================================================================
--- branches/map65/libm65/decode0.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/decode0.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,64 +1,64 @@
-subroutine decode0(dd,ss,savg,nstandalone)
-
-  parameter (NSMAX=60*96000)
-  parameter (NFFT=32768)
-
-  real*4 dd(4,NSMAX),ss(4,322,NFFT),savg(4,NFFT)
-  real*8 fcenter
-  integer hist(0:32768)
-  character mycall*12,hiscall*12,mygrid*6,hisgrid*6,datetime*20
-  character mycall0*12,hiscall0*12,hisgrid0*6
-  common/npar/fcenter,nutc,idphi,mousedf,mousefqso,nagain,                &amp;
-       ndepth,ndiskdat,neme,newdat,nfa,nfb,nfcal,nfshift,                 &amp;
-       mcall3,nkeep,ntol,nxant,nrxlog,nfsample,nxpol,mode65,              &amp;
-       mycall,mygrid,hiscall,hisgrid,datetime
-  common/tracer/ limtrace,lu
-  data neme0/-99/,mcall3b/1/
-  save
-
-  call timer('decode0 ',0)
-
-  if(newdat.ne.0) then
-     nz=52*96000
-     hist=0
-     do i=1,nz
-        j1=min(abs(dd(1,i)),32768.0)
-        hist(j1)=hist(j1)+1
-        j2=min(abs(dd(2,i)),32768.0)
-        hist(j2)=hist(j2)+1
-        j3=min(abs(dd(3,i)),32768.0)
-        hist(j3)=hist(j3)+1
-        j4=min(abs(dd(4,i)),32768.0)
-        hist(j4)=hist(j4)+1
-     enddo
-     m=0
-     do i=0,32768
-        m=m+hist(i)
-        if(m.ge.2*nz) go to 10
-     enddo
-10   rmsdd=1.5*i
-  endif
-  nhsym=279
-  ndphi=0
-  if(iand(nrxlog,8).ne.0) ndphi=1
-
-  if(mycall.ne.mycall0 .or. hiscall.ne.hiscall0 .or.         &amp;
-       hisgrid.ne.hisgrid0 .or. mcall3.ne.0 .or. neme.ne.neme0) mcall3b=1
-      
-  mycall0=mycall
-  hiscall0=hiscall
-  hisgrid0=hisgrid
-  neme0=neme
-
-  call timer('map65a  ',0)
-  call map65a(dd,ss,savg,newdat,nutc,fcenter,ntol,idphi,nfa,nfb,           &amp;
-       mousedf,mousefqso,nagain,ndecdone,ndiskdat,nfshift,ndphi,           &amp;
-       nfcal,nkeep,mcall3b,nsave,nxant,rmsdd,mycall,mygrid,                &amp;
-       neme,ndepth,hiscall,hisgrid,nhsym,nfsample,nxpol,mode65)
-
-  call timer('map65a  ',1)
-  call timer('decode0 ',1)
-  if(nstandalone.eq.0) call timer('decode0 ',101)
-
-  return
-end subroutine decode0
+subroutine decode0(dd,ss,savg,nstandalone)
+
+  parameter (NSMAX=60*96000)
+  parameter (NFFT=32768)
+
+  real*4 dd(4,NSMAX),ss(4,322,NFFT),savg(4,NFFT)
+  real*8 fcenter
+  integer hist(0:32768)
+  character mycall*12,hiscall*12,mygrid*6,hisgrid*6,datetime*20
+  character mycall0*12,hiscall0*12,hisgrid0*6
+  common/npar/fcenter,nutc,idphi,mousedf,mousefqso,nagain,                &amp;
+       ndepth,ndiskdat,neme,newdat,nfa,nfb,nfcal,nfshift,                 &amp;
+       mcall3,nkeep,ntol,nxant,nrxlog,nfsample,nxpol,mode65,              &amp;
+       mycall,mygrid,hiscall,hisgrid,datetime
+  common/tracer/ limtrace,lu
+  data neme0/-99/,mcall3b/1/
+  save
+
+  call timer('decode0 ',0)
+
+  if(newdat.ne.0) then
+     nz=52*96000
+     hist=0
+     do i=1,nz
+        j1=min(abs(dd(1,i)),32768.0)
+        hist(j1)=hist(j1)+1
+        j2=min(abs(dd(2,i)),32768.0)
+        hist(j2)=hist(j2)+1
+        j3=min(abs(dd(3,i)),32768.0)
+        hist(j3)=hist(j3)+1
+        j4=min(abs(dd(4,i)),32768.0)
+        hist(j4)=hist(j4)+1
+     enddo
+     m=0
+     do i=0,32768
+        m=m+hist(i)
+        if(m.ge.2*nz) go to 10
+     enddo
+10   rmsdd=1.5*i
+  endif
+  nhsym=279
+  ndphi=0
+  if(iand(nrxlog,8).ne.0) ndphi=1
+
+  if(mycall.ne.mycall0 .or. hiscall.ne.hiscall0 .or.         &amp;
+       hisgrid.ne.hisgrid0 .or. mcall3.ne.0 .or. neme.ne.neme0) mcall3b=1
+      
+  mycall0=mycall
+  hiscall0=hiscall
+  hisgrid0=hisgrid
+  neme0=neme
+
+  call timer('map65a  ',0)
+  call map65a(dd,ss,savg,newdat,nutc,fcenter,ntol,idphi,nfa,nfb,           &amp;
+       mousedf,mousefqso,nagain,ndecdone,ndiskdat,nfshift,ndphi,           &amp;
+       nfcal,nkeep,mcall3b,nsave,nxant,rmsdd,mycall,mygrid,                &amp;
+       neme,ndepth,hiscall,hisgrid,nhsym,nfsample,nxpol,mode65)
+
+  call timer('map65a  ',1)
+  call timer('decode0 ',1)
+  if(nstandalone.eq.0) call timer('decode0 ',101)
+
+  return
+end subroutine decode0


Property changes on: branches/map65/libm65/decode0.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/decode1a.f
===================================================================
--- branches/map65/libm65/decode1a.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/decode1a.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,149 +1,149 @@
-      subroutine decode1a(dd,newdat,f0,nflip,mode65,nfsample,xpol,
-     +     mycall,hiscall,hisgrid,neme,ndepth,nqd,dphi,
-     +     nutc,nkhz,ndf,ipol,sync2,a,dt,pol,nkv,nhist,qual,decoded)
-
-!  Apply AFC corrections to a candidate JT65 signal, then decode it.
-
-      parameter (NMAX=60*96000)          !Samples per 60 s
-      real*4  dd(4,NMAX)                 !92 MB: raw data from Linrad timf2
-      complex cx(NMAX/64), cy(NMAX/64)   !Data at 1378.125 samples/s
-      complex c5x(NMAX/256),c5y(NMAX/256),c5tmp(NMAX/256)  !Data at 344.53125 Hz
-      complex c5a(512)
-      complex z
-      real s2(66,126)
-      real s3(64,63),sy(63)
-      real a(5)
-      logical first,xpol
-      character decoded*22
-      character mycall*12,hiscall*12,hisgrid*6
-      data first/.true./,jjjmin/1000/,jjjmax/-1000/
-      data nutc0/-999/,nkhz0/-999/
-      save
-
-!  Mix sync tone to baseband, low-pass filter, downsample to 1378.125 Hz
-      dt00=dt
-      call timer('filbig  ',0)
-      call filbig(dd,NMAX,f0,newdat,nfsample,xpol,cx,cy,n5)
-!  NB: cx, cy have sample rate 96000*77125/5376000 = 1378.125 Hz
-      call timer('filbig  ',1)
-      joff=0
-      sqa=0.
-      sqb=0.
-      do i=1,n5
-         sqa=sqa + real(cx(i))**2 + aimag(cx(i))**2
-         sqb=sqb + real(cy(i))**2 + aimag(cy(i))**2
-      enddo
-      sqa=sqa/n5
-      sqb=sqb/n5
-
-!  Find best DF, f1, f2, DT, and pol.  Start by downsampling to 344.53125 Hz
-      z=cmplx(cos(dphi),sin(dphi))
-      cy(:n5)=z*cy(:n5)                   !Adjust for cable length difference
-      call timer('fil6521 ',0)
-      call fil6521(cx,n5,c5x,n6)
-      call fil6521(cy,n5,c5y,n6)
-      call timer('fil6521 ',1)
-
-! Add some zeros at start of c5 arrays -- empirical fix for negative DT's
-! NB: might be better to add zeros to cx and cy, rather than here.
-! Q: is the DT search range big enough?
-
-      nadd=200
-      c5tmp(1:nadd)=0.
-      c5tmp(1+nadd:n6+nadd)=c5x(1:n6)
-      c5x(1:n6+nadd)=c5tmp(1:n6+nadd)
-      c5tmp(1+nadd:n6+nadd)=c5y(1:n6)
-      c5y(1:n6+nadd)=c5tmp(1:n6+nadd)
-      n6=n6+nadd
-
-      fsample=1378.125/4.
-      a(5)=dt00
-      i0=nint((a(5)+0.5)*fsample) - 2 + 200
-      if(i0.lt.1) then
-         write(13,*) 'i0 too small in decode1a:',i0,f0
-         flush(13)
-         i0=1
-      endif
-      nz=n6+1-i0
-
-! We're looking only at sync tone here... so why not downsample by another
-! factor of 1/8, say?  Should be a significant execution speed-up.
-      call timer('afc65b  ',0)
-! Best fit for DF, f1, f2, pol
-      call afc65b(c5x(i0),c5y(i0),nz,fsample,nflip,ipol,xpol,a,
-     +     ccfbest,dtbest)
-      call timer('afc65b  ',1)
-
-      pol=a(4)/57.2957795
-      aa=cos(pol)
-      bb=sin(pol)
-      sq0=aa*aa*sqa + bb*bb*sqb
-      sync2=3.7*ccfbest/sq0
-
-!  Apply AFC corrections to the time-domain signal
-!  Now we are back to using the 1378.125 Hz sample rate, enough to 
-!  accommodate the full JT65C bandwidth.
-
-      call timer('twkfreq ',0)
-      call twkfreq(cx,cy,n5,a)
-      call timer('twkfreq ',1)
-
-!  Compute spectrum at best polarization for each half symbol.
-!  Adding or subtracting a small number (e.g., 5) to j may make it decode.\
-!  NB: might want to try computing full-symbol spectra (nfft=512, even for
-!  submodes B and C).
-
-      nsym=126
-      nfft=512/mode65
-      j=(dt00+dtbest+2.685)*1378.125 + joff
-      if(j.lt.0) j=0
-
-      call timer('sh_ffts ',0)
-
-! Perhaps should try full-symbol-length FFTs even in B, C sub-modes?
-! (Tried this, found no significant difference in decodes.)
-
-      do k=1,nsym
-         do n=1,mode65
-            do i=1,nfft
-               j=j+1
-               c5a(i)=aa*cx(j) + bb*cy(j)
-            enddo
-            call four2a(c5a,nfft,1,1,1)
-            if(n.eq.1) then
-               do i=1,66
-                  s2(i,k)=real(c5a(i))**2 + aimag(c5a(i))**2
-               enddo
-            else
-               do i=1,66
-                  s2(i,k)=s2(i,k) + real(c5a(i))**2 + aimag(c5a(i))**2
-               enddo
-            endif
-         enddo
-      enddo
-
-      call timer('sh_ffts ',1)
-
-      flip=nflip
-      call timer('dec65b  ',0)
-      call decode65b(s2,flip,mycall,hiscall,hisgrid,mode65,neme,ndepth,
-     +    nqd,nkv,nhist,qual,decoded,s3,sy)
-      dt=dt00 + dtbest
-      call timer('dec65b  ',1)
-
-      if(nqd.eq.1 .and. nkv.eq.0) then
-         if(nutc.ne.nutc0) syncbest=0.
-         if(sync2.gt.syncbest) then
-            if(nutc.eq.nutc0) nsave=nsave-1
-            if(nkhz.ne.nkhz0) nsave=0
-            nkhz0=nkhz
-            nsave=min(32,nsave+1)
-            npol=nint(57.296*pol)
-            call s3avg(nsave,mode65,nutc,ndf,dt+0.8,npol,s3,nkv,decoded)
-            syncbest=sync2
-         endif
-         nutc0=nutc
-      endif
-
-      return
-      end
+      subroutine decode1a(dd,newdat,f0,nflip,mode65,nfsample,xpol,
+     +     mycall,hiscall,hisgrid,neme,ndepth,nqd,dphi,
+     +     nutc,nkhz,ndf,ipol,sync2,a,dt,pol,nkv,nhist,qual,decoded)
+
+!  Apply AFC corrections to a candidate JT65 signal, then decode it.
+
+      parameter (NMAX=60*96000)          !Samples per 60 s
+      real*4  dd(4,NMAX)                 !92 MB: raw data from Linrad timf2
+      complex cx(NMAX/64), cy(NMAX/64)   !Data at 1378.125 samples/s
+      complex c5x(NMAX/256),c5y(NMAX/256),c5tmp(NMAX/256)  !Data at 344.53125 Hz
+      complex c5a(512)
+      complex z
+      real s2(66,126)
+      real s3(64,63),sy(63)
+      real a(5)
+      logical first,xpol
+      character decoded*22
+      character mycall*12,hiscall*12,hisgrid*6
+      data first/.true./,jjjmin/1000/,jjjmax/-1000/
+      data nutc0/-999/,nkhz0/-999/
+      save
+
+!  Mix sync tone to baseband, low-pass filter, downsample to 1378.125 Hz
+      dt00=dt
+      call timer('filbig  ',0)
+      call filbig(dd,NMAX,f0,newdat,nfsample,xpol,cx,cy,n5)
+!  NB: cx, cy have sample rate 96000*77125/5376000 = 1378.125 Hz
+      call timer('filbig  ',1)
+      joff=0
+      sqa=0.
+      sqb=0.
+      do i=1,n5
+         sqa=sqa + real(cx(i))**2 + aimag(cx(i))**2
+         sqb=sqb + real(cy(i))**2 + aimag(cy(i))**2
+      enddo
+      sqa=sqa/n5
+      sqb=sqb/n5
+
+!  Find best DF, f1, f2, DT, and pol.  Start by downsampling to 344.53125 Hz
+      z=cmplx(cos(dphi),sin(dphi))
+      cy(:n5)=z*cy(:n5)                   !Adjust for cable length difference
+      call timer('fil6521 ',0)
+      call fil6521(cx,n5,c5x,n6)
+      call fil6521(cy,n5,c5y,n6)
+      call timer('fil6521 ',1)
+
+! Add some zeros at start of c5 arrays -- empirical fix for negative DT's
+! NB: might be better to add zeros to cx and cy, rather than here.
+! Q: is the DT search range big enough?
+
+      nadd=200
+      c5tmp(1:nadd)=0.
+      c5tmp(1+nadd:n6+nadd)=c5x(1:n6)
+      c5x(1:n6+nadd)=c5tmp(1:n6+nadd)
+      c5tmp(1+nadd:n6+nadd)=c5y(1:n6)
+      c5y(1:n6+nadd)=c5tmp(1:n6+nadd)
+      n6=n6+nadd
+
+      fsample=1378.125/4.
+      a(5)=dt00
+      i0=nint((a(5)+0.5)*fsample) - 2 + 200
+      if(i0.lt.1) then
+         write(13,*) 'i0 too small in decode1a:',i0,f0
+         flush(13)
+         i0=1
+      endif
+      nz=n6+1-i0
+
+! We're looking only at sync tone here... so why not downsample by another
+! factor of 1/8, say?  Should be a significant execution speed-up.
+      call timer('afc65b  ',0)
+! Best fit for DF, f1, f2, pol
+      call afc65b(c5x(i0),c5y(i0),nz,fsample,nflip,ipol,xpol,a,
+     +     ccfbest,dtbest)
+      call timer('afc65b  ',1)
+
+      pol=a(4)/57.2957795
+      aa=cos(pol)
+      bb=sin(pol)
+      sq0=aa*aa*sqa + bb*bb*sqb
+      sync2=3.7*ccfbest/sq0
+
+!  Apply AFC corrections to the time-domain signal
+!  Now we are back to using the 1378.125 Hz sample rate, enough to 
+!  accommodate the full JT65C bandwidth.
+
+      call timer('twkfreq ',0)
+      call twkfreq(cx,cy,n5,a)
+      call timer('twkfreq ',1)
+
+!  Compute spectrum at best polarization for each half symbol.
+!  Adding or subtracting a small number (e.g., 5) to j may make it decode.\
+!  NB: might want to try computing full-symbol spectra (nfft=512, even for
+!  submodes B and C).
+
+      nsym=126
+      nfft=512/mode65
+      j=(dt00+dtbest+2.685)*1378.125 + joff
+      if(j.lt.0) j=0
+
+      call timer('sh_ffts ',0)
+
+! Perhaps should try full-symbol-length FFTs even in B, C sub-modes?
+! (Tried this, found no significant difference in decodes.)
+
+      do k=1,nsym
+         do n=1,mode65
+            do i=1,nfft
+               j=j+1
+               c5a(i)=aa*cx(j) + bb*cy(j)
+            enddo
+            call four2a(c5a,nfft,1,1,1)
+            if(n.eq.1) then
+               do i=1,66
+                  s2(i,k)=real(c5a(i))**2 + aimag(c5a(i))**2
+               enddo
+            else
+               do i=1,66
+                  s2(i,k)=s2(i,k) + real(c5a(i))**2 + aimag(c5a(i))**2
+               enddo
+            endif
+         enddo
+      enddo
+
+      call timer('sh_ffts ',1)
+
+      flip=nflip
+      call timer('dec65b  ',0)
+      call decode65b(s2,flip,mycall,hiscall,hisgrid,mode65,neme,ndepth,
+     +    nqd,nkv,nhist,qual,decoded,s3,sy)
+      dt=dt00 + dtbest
+      call timer('dec65b  ',1)
+
+      if(nqd.eq.1 .and. nkv.eq.0) then
+         if(nutc.ne.nutc0) syncbest=0.
+         if(sync2.gt.syncbest) then
+            if(nutc.eq.nutc0) nsave=nsave-1
+            if(nkhz.ne.nkhz0) nsave=0
+            nkhz0=nkhz
+            nsave=min(32,nsave+1)
+            npol=nint(57.296*pol)
+            call s3avg(nsave,mode65,nutc,ndf,dt+0.8,npol,s3,nkv,decoded)
+            syncbest=sync2
+         endif
+         nutc0=nutc
+      endif
+
+      return
+      end


Property changes on: branches/map65/libm65/decode1a.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/decode65b.f
===================================================================
--- branches/map65/libm65/decode65b.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/decode65b.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,49 +1,49 @@
-      subroutine decode65b(s2,flip,mycall,hiscall,hisgrid,mode65,
-     +  neme,ndepth,nqd,nkv,nhist,qual,decoded,s3,sy)
-
-      real s2(66,126)
-      real s3(64,63),sy(63)
-      logical first,ltext
-      character decoded*22,deepmsg*22
-      character mycall*12,hiscall*12,hisgrid*6
-      common/prcom/pr(126),mdat(126),mref(126,2),mdat2(126),mref2(126,2)
-      data first/.true./
-      save
-
-      if(first) call setup65
-      first=.false.
-
-      do j=1,63
-         k=mdat(j)                       !Points to data symbol
-         if(flip.lt.0.0) k=mdat2(j)
-         do i=1,64
-            s3(i,j)=s2(i+2,k)
-         enddo
-         k=mdat2(j)                       !Points to data symbol
-         if(flip.lt.0.0) k=mdat(j)
-         sy(j)=s2(1,k)
-      enddo
-
-      nadd=mode65
-      call extract(s3,nadd,ncount,nhist,decoded,ltext)     !Extract the message
-C  Suppress &quot;birdie messages&quot; and other garbage decodes:
-      if(decoded(1:7).eq.'000AAA ') ncount=-1
-      if(decoded(1:7).eq.'0L6MWK ') ncount=-1
-      if(flip.lt.0.0 .and. ltext) ncount=-1
-      nkv=1
-      if(ncount.lt.0) then 
-         nkv=0
-         decoded='                      '
-      endif
-
-      qual=0.
-      if(ndepth.ge.1 .and. (nqd.eq.1 .or. flip.eq.1.0)) then
-         call deep65(s3,mode65,neme,flip,mycall,hiscall,
-     +       hisgrid,deepmsg,qual)
-         if(nqd.ne.1 .and. qual.lt.10.0) qual=0.0
-         if(ndepth.lt.2 .and. qual.lt.6.0) qual=0.0
-      endif
-      if(nkv.eq.0 .and. qual.ge.1.0) decoded=deepmsg
-
-      return
-      end
+      subroutine decode65b(s2,flip,mycall,hiscall,hisgrid,mode65,
+     +  neme,ndepth,nqd,nkv,nhist,qual,decoded,s3,sy)
+
+      real s2(66,126)
+      real s3(64,63),sy(63)
+      logical first,ltext
+      character decoded*22,deepmsg*22
+      character mycall*12,hiscall*12,hisgrid*6
+      common/prcom/pr(126),mdat(126),mref(126,2),mdat2(126),mref2(126,2)
+      data first/.true./
+      save
+
+      if(first) call setup65
+      first=.false.
+
+      do j=1,63
+         k=mdat(j)                       !Points to data symbol
+         if(flip.lt.0.0) k=mdat2(j)
+         do i=1,64
+            s3(i,j)=s2(i+2,k)
+         enddo
+         k=mdat2(j)                       !Points to data symbol
+         if(flip.lt.0.0) k=mdat(j)
+         sy(j)=s2(1,k)
+      enddo
+
+      nadd=mode65
+      call extract(s3,nadd,ncount,nhist,decoded,ltext)     !Extract the message
+C  Suppress &quot;birdie messages&quot; and other garbage decodes:
+      if(decoded(1:7).eq.'000AAA ') ncount=-1
+      if(decoded(1:7).eq.'0L6MWK ') ncount=-1
+      if(flip.lt.0.0 .and. ltext) ncount=-1
+      nkv=1
+      if(ncount.lt.0) then 
+         nkv=0
+         decoded='                      '
+      endif
+
+      qual=0.
+      if(ndepth.ge.1 .and. (nqd.eq.1 .or. flip.eq.1.0)) then
+         call deep65(s3,mode65,neme,flip,mycall,hiscall,
+     +       hisgrid,deepmsg,qual)
+         if(nqd.ne.1 .and. qual.lt.10.0) qual=0.0
+         if(ndepth.lt.2 .and. qual.lt.6.0) qual=0.0
+      endif
+      if(nkv.eq.0 .and. qual.ge.1.0) decoded=deepmsg
+
+      return
+      end


Property changes on: branches/map65/libm65/decode65b.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/decode_rs.c
===================================================================
--- branches/map65/libm65/decode_rs.c	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/decode_rs.c	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,263 +1,263 @@
-/* Reed-Solomon decoder
- * Copyright 2002 Phil Karn, KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-
-#ifdef DEBUG
-#include &lt;stdio.h&gt;
-#endif
-
-#include &lt;string.h&gt;
-
-#define NULL ((void *)0)
-#define	min(a,b)	((a) &lt; (b) ? (a) : (b))
-
-#ifdef FIXED
-#include &quot;fixed.h&quot;
-#elif defined(BIGSYM)
-#include &quot;int.h&quot;
-#else
-#include &quot;char.h&quot;
-#endif
-
-int DECODE_RS(
-#ifdef FIXED
-DTYPE *data, int *eras_pos, int no_eras,int pad){
-#else
-void *p,DTYPE *data, int *eras_pos, int no_eras){
-  struct rs *rs = (struct rs *)p;
-#endif
-  int deg_lambda, el, deg_omega;
-  int i, j, r,k;
-  DTYPE u,q,tmp,num1,num2,den,discr_r;
-  DTYPE lambda[NROOTS+1], s[NROOTS];	/* Err+Eras Locator poly
-					 * and syndrome poly */
-  DTYPE b[NROOTS+1], t[NROOTS+1], omega[NROOTS+1];
-  DTYPE root[NROOTS], reg[NROOTS+1], loc[NROOTS];
-  int syn_error, count;
-
-#ifdef FIXED
-  /* Check pad parameter for validity */
-  if(pad &lt; 0 || pad &gt;= NN)
-    return -1;
-#endif
-
-  /* form the syndromes; i.e., evaluate data(x) at roots of g(x) */
-  for(i=0;i&lt;NROOTS;i++)
-    s[i] = data[0];
-
-  for(j=1;j&lt;NN-PAD;j++){
-    for(i=0;i&lt;NROOTS;i++){
-      if(s[i] == 0){
-	s[i] = data[j];
-      } else {
-	s[i] = data[j] ^ ALPHA_TO[MODNN(INDEX_OF[s[i]] + (FCR+i)*PRIM)];
-      }
-    }
-  }
-
-  /* Convert syndromes to index form, checking for nonzero condition */
-  syn_error = 0;
-  for(i=0;i&lt;NROOTS;i++){
-    syn_error |= s[i];
-    s[i] = INDEX_OF[s[i]];
-  }
-
-  if (!syn_error) {
-    /* if syndrome is zero, data[] is a codeword and there are no
-     * errors to correct. So return data[] unmodified
-     */
-    count = 0;
-    goto finish;
-  }
-  memset(&amp;lambda[1],0,NROOTS*sizeof(lambda[0]));
-  lambda[0] = 1;
-
-  if (no_eras &gt; 0) {
-    /* Init lambda to be the erasure locator polynomial */
-    lambda[1] = ALPHA_TO[MODNN(PRIM*(NN-1-eras_pos[0]))];
-    for (i = 1; i &lt; no_eras; i++) {
-      u = MODNN(PRIM*(NN-1-eras_pos[i]));
-      for (j = i+1; j &gt; 0; j--) {
-	tmp = INDEX_OF[lambda[j - 1]];
-	if(tmp != A0)
-	  lambda[j] ^= ALPHA_TO[MODNN(u + tmp)];
-      }
-    }
-
-#if DEBUG &gt;= 1
-    /* Test code that verifies the erasure locator polynomial just constructed
-       Needed only for decoder debugging. */
-    
-    /* find roots of the erasure location polynomial */
-    for(i=1;i&lt;=no_eras;i++)
-      reg[i] = INDEX_OF[lambda[i]];
-
-    count = 0;
-    for (i = 1,k=IPRIM-1; i &lt;= NN; i++,k = MODNN(k+IPRIM)) {
-      q = 1;
-      for (j = 1; j &lt;= no_eras; j++)
-	if (reg[j] != A0) {
-	  reg[j] = MODNN(reg[j] + j);
-	  q ^= ALPHA_TO[reg[j]];
-	}
-      if (q != 0)
-	continue;
-      /* store root and error location number indices */
-      root[count] = i;
-      loc[count] = k;
-      count++;
-    }
-    if (count != no_eras) {
-      printf(&quot;count = %d no_eras = %d\n lambda(x) is WRONG\n&quot;,count,no_eras);
-      count = -1;
-      goto finish;
-    }
-#if DEBUG &gt;= 2
-    printf(&quot;\n Erasure positions as determined by roots of Eras Loc Poly:\n&quot;);
-    for (i = 0; i &lt; count; i++)
-      printf(&quot;%d &quot;, loc[i]);
-    printf(&quot;\n&quot;);
-#endif
-#endif
-  }
-  for(i=0;i&lt;NROOTS+1;i++)
-    //    printf(&quot;%d  %d  %d\n&quot;,i,lambda[i],INDEX_OF[lambda[i]]);
-    b[i] = INDEX_OF[lambda[i]];
-  
-  /*
-   * Begin Berlekamp-Massey algorithm to determine error+erasure
-   * locator polynomial
-   */
-  r = no_eras;
-  el = no_eras;
-  while (++r &lt;= NROOTS) {	/* r is the step number */
-    /* Compute discrepancy at the r-th step in poly-form */
-    discr_r = 0;
-    for (i = 0; i &lt; r; i++){
-      if ((lambda[i] != 0) &amp;&amp; (s[r-i-1] != A0)) {
-	discr_r ^= ALPHA_TO[MODNN(INDEX_OF[lambda[i]] + s[r-i-1])];
-      }
-    }
-    discr_r = INDEX_OF[discr_r];	/* Index form */
-    if (discr_r == A0) {
-      /* 2 lines below: B(x) &lt;-- x*B(x) */
-      memmove(&amp;b[1],b,NROOTS*sizeof(b[0]));
-      b[0] = A0;
-    } else {
-      /* 7 lines below: T(x) &lt;-- lambda(x) - discr_r*x*b(x) */
-      t[0] = lambda[0];
-      for (i = 0 ; i &lt; NROOTS; i++) {
-	if(b[i] != A0)
-	  t[i+1] = lambda[i+1] ^ ALPHA_TO[MODNN(discr_r + b[i])];
-	else
-	  t[i+1] = lambda[i+1];
-      }
-      if (2 * el &lt;= r + no_eras - 1) {
-	el = r + no_eras - el;
-	/*
-	 * 2 lines below: B(x) &lt;-- inv(discr_r) *
-	 * lambda(x)
-	 */
-	for (i = 0; i &lt;= NROOTS; i++)
-	  b[i] = (lambda[i] == 0) ? A0 : MODNN(INDEX_OF[lambda[i]] - discr_r + NN);
-      } else {
-	/* 2 lines below: B(x) &lt;-- x*B(x) */
-	memmove(&amp;b[1],b,NROOTS*sizeof(b[0]));
-	b[0] = A0;
-      }
-      memcpy(lambda,t,(NROOTS+1)*sizeof(t[0]));
-    }
-  }
-
-  /* Convert lambda to index form and compute deg(lambda(x)) */
-  deg_lambda = 0;
-  for(i=0;i&lt;NROOTS+1;i++){
-    lambda[i] = INDEX_OF[lambda[i]];
-    if(lambda[i] != A0)
-      deg_lambda = i;
-  }
-  /* Find roots of the error+erasure locator polynomial by Chien search */
-  memcpy(&amp;reg[1],&amp;lambda[1],NROOTS*sizeof(reg[0]));
-  count = 0;		/* Number of roots of lambda(x) */
-  for (i = 1,k=IPRIM-1; i &lt;= NN; i++,k = MODNN(k+IPRIM)) {
-    q = 1; /* lambda[0] is always 0 */
-    for (j = deg_lambda; j &gt; 0; j--){
-      if (reg[j] != A0) {
-	reg[j] = MODNN(reg[j] + j);
-	q ^= ALPHA_TO[reg[j]];
-      }
-    }
-    if (q != 0)
-      continue; /* Not a root */
-    /* store root (index-form) and error location number */
-#if DEBUG&gt;=2
-    printf(&quot;count %d root %d loc %d\n&quot;,count,i,k);
-#endif
-    root[count] = i;
-    loc[count] = k;
-    /* If we've already found max possible roots,
-     * abort the search to save time
-     */
-    if(++count == deg_lambda)
-      break;
-  }
-  if (deg_lambda != count) {
-    /*
-     * deg(lambda) unequal to number of roots =&gt; uncorrectable
-     * error detected
-     */
-    count = -1;
-    goto finish;
-  }
-  /*
-   * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo
-   * x**NROOTS). in index form. Also find deg(omega).
-   */
-  deg_omega = deg_lambda-1;
-  for (i = 0; i &lt;= deg_omega;i++){
-    tmp = 0;
-    for(j=i;j &gt;= 0; j--){
-      if ((s[i - j] != A0) &amp;&amp; (lambda[j] != A0))
-	tmp ^= ALPHA_TO[MODNN(s[i - j] + lambda[j])];
-    }
-    omega[i] = INDEX_OF[tmp];
-  }
-
-  /*
-   * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =
-   * inv(X(l))**(FCR-1) and den = lambda_pr(inv(X(l))) all in poly-form
-   */
-  for (j = count-1; j &gt;=0; j--) {
-    num1 = 0;
-    for (i = deg_omega; i &gt;= 0; i--) {
-      if (omega[i] != A0)
-	num1  ^= ALPHA_TO[MODNN(omega[i] + i * root[j])];
-    }
-    num2 = ALPHA_TO[MODNN(root[j] * (FCR - 1) + NN)];
-    den = 0;
-    
-    /* lambda[i+1] for i even is the formal derivative lambda_pr of lambda[i] */
-    for (i = min(deg_lambda,NROOTS-1) &amp; ~1; i &gt;= 0; i -=2) {
-      if(lambda[i+1] != A0)
-	den ^= ALPHA_TO[MODNN(lambda[i+1] + i * root[j])];
-    }
-#if DEBUG &gt;= 1
-    if (den == 0) {
-      printf(&quot;\n ERROR: denominator = 0\n&quot;);
-      count = -1;
-      goto finish;
-    }
-#endif
-    /* Apply error to data */
-    if (num1 != 0 &amp;&amp; loc[j] &gt;= PAD) {
-      data[loc[j]-PAD] ^= ALPHA_TO[MODNN(INDEX_OF[num1] + INDEX_OF[num2] + NN - INDEX_OF[den])];
-    }
-  }
- finish:
-  if(eras_pos != NULL){
-    for(i=0;i&lt;count;i++)
-      eras_pos[i] = loc[i];
-  }
-  return count;
-}
+/* Reed-Solomon decoder
+ * Copyright 2002 Phil Karn, KA9Q
+ * May be used under the terms of the GNU General Public License (GPL)
+ */
+
+#ifdef DEBUG
+#include &lt;stdio.h&gt;
+#endif
+
+#include &lt;string.h&gt;
+
+#define NULL ((void *)0)
+#define	min(a,b)	((a) &lt; (b) ? (a) : (b))
+
+#ifdef FIXED
+#include &quot;fixed.h&quot;
+#elif defined(BIGSYM)
+#include &quot;int.h&quot;
+#else
+#include &quot;char.h&quot;
+#endif
+
+int DECODE_RS(
+#ifdef FIXED
+DTYPE *data, int *eras_pos, int no_eras,int pad){
+#else
+void *p,DTYPE *data, int *eras_pos, int no_eras){
+  struct rs *rs = (struct rs *)p;
+#endif
+  int deg_lambda, el, deg_omega;
+  int i, j, r,k;
+  DTYPE u,q,tmp,num1,num2,den,discr_r;
+  DTYPE lambda[NROOTS+1], s[NROOTS];	/* Err+Eras Locator poly
+					 * and syndrome poly */
+  DTYPE b[NROOTS+1], t[NROOTS+1], omega[NROOTS+1];
+  DTYPE root[NROOTS], reg[NROOTS+1], loc[NROOTS];
+  int syn_error, count;
+
+#ifdef FIXED
+  /* Check pad parameter for validity */
+  if(pad &lt; 0 || pad &gt;= NN)
+    return -1;
+#endif
+
+  /* form the syndromes; i.e., evaluate data(x) at roots of g(x) */
+  for(i=0;i&lt;NROOTS;i++)
+    s[i] = data[0];
+
+  for(j=1;j&lt;NN-PAD;j++){
+    for(i=0;i&lt;NROOTS;i++){
+      if(s[i] == 0){
+	s[i] = data[j];
+      } else {
+	s[i] = data[j] ^ ALPHA_TO[MODNN(INDEX_OF[s[i]] + (FCR+i)*PRIM)];
+      }
+    }
+  }
+
+  /* Convert syndromes to index form, checking for nonzero condition */
+  syn_error = 0;
+  for(i=0;i&lt;NROOTS;i++){
+    syn_error |= s[i];
+    s[i] = INDEX_OF[s[i]];
+  }
+
+  if (!syn_error) {
+    /* if syndrome is zero, data[] is a codeword and there are no
+     * errors to correct. So return data[] unmodified
+     */
+    count = 0;
+    goto finish;
+  }
+  memset(&amp;lambda[1],0,NROOTS*sizeof(lambda[0]));
+  lambda[0] = 1;
+
+  if (no_eras &gt; 0) {
+    /* Init lambda to be the erasure locator polynomial */
+    lambda[1] = ALPHA_TO[MODNN(PRIM*(NN-1-eras_pos[0]))];
+    for (i = 1; i &lt; no_eras; i++) {
+      u = MODNN(PRIM*(NN-1-eras_pos[i]));
+      for (j = i+1; j &gt; 0; j--) {
+	tmp = INDEX_OF[lambda[j - 1]];
+	if(tmp != A0)
+	  lambda[j] ^= ALPHA_TO[MODNN(u + tmp)];
+      }
+    }
+
+#if DEBUG &gt;= 1
+    /* Test code that verifies the erasure locator polynomial just constructed
+       Needed only for decoder debugging. */
+    
+    /* find roots of the erasure location polynomial */
+    for(i=1;i&lt;=no_eras;i++)
+      reg[i] = INDEX_OF[lambda[i]];
+
+    count = 0;
+    for (i = 1,k=IPRIM-1; i &lt;= NN; i++,k = MODNN(k+IPRIM)) {
+      q = 1;
+      for (j = 1; j &lt;= no_eras; j++)
+	if (reg[j] != A0) {
+	  reg[j] = MODNN(reg[j] + j);
+	  q ^= ALPHA_TO[reg[j]];
+	}
+      if (q != 0)
+	continue;
+      /* store root and error location number indices */
+      root[count] = i;
+      loc[count] = k;
+      count++;
+    }
+    if (count != no_eras) {
+      printf(&quot;count = %d no_eras = %d\n lambda(x) is WRONG\n&quot;,count,no_eras);
+      count = -1;
+      goto finish;
+    }
+#if DEBUG &gt;= 2
+    printf(&quot;\n Erasure positions as determined by roots of Eras Loc Poly:\n&quot;);
+    for (i = 0; i &lt; count; i++)
+      printf(&quot;%d &quot;, loc[i]);
+    printf(&quot;\n&quot;);
+#endif
+#endif
+  }
+  for(i=0;i&lt;NROOTS+1;i++)
+    //    printf(&quot;%d  %d  %d\n&quot;,i,lambda[i],INDEX_OF[lambda[i]]);
+    b[i] = INDEX_OF[lambda[i]];
+  
+  /*
+   * Begin Berlekamp-Massey algorithm to determine error+erasure
+   * locator polynomial
+   */
+  r = no_eras;
+  el = no_eras;
+  while (++r &lt;= NROOTS) {	/* r is the step number */
+    /* Compute discrepancy at the r-th step in poly-form */
+    discr_r = 0;
+    for (i = 0; i &lt; r; i++){
+      if ((lambda[i] != 0) &amp;&amp; (s[r-i-1] != A0)) {
+	discr_r ^= ALPHA_TO[MODNN(INDEX_OF[lambda[i]] + s[r-i-1])];
+      }
+    }
+    discr_r = INDEX_OF[discr_r];	/* Index form */
+    if (discr_r == A0) {
+      /* 2 lines below: B(x) &lt;-- x*B(x) */
+      memmove(&amp;b[1],b,NROOTS*sizeof(b[0]));
+      b[0] = A0;
+    } else {
+      /* 7 lines below: T(x) &lt;-- lambda(x) - discr_r*x*b(x) */
+      t[0] = lambda[0];
+      for (i = 0 ; i &lt; NROOTS; i++) {
+	if(b[i] != A0)
+	  t[i+1] = lambda[i+1] ^ ALPHA_TO[MODNN(discr_r + b[i])];
+	else
+	  t[i+1] = lambda[i+1];
+      }
+      if (2 * el &lt;= r + no_eras - 1) {
+	el = r + no_eras - el;
+	/*
+	 * 2 lines below: B(x) &lt;-- inv(discr_r) *
+	 * lambda(x)
+	 */
+	for (i = 0; i &lt;= NROOTS; i++)
+	  b[i] = (lambda[i] == 0) ? A0 : MODNN(INDEX_OF[lambda[i]] - discr_r + NN);
+      } else {
+	/* 2 lines below: B(x) &lt;-- x*B(x) */
+	memmove(&amp;b[1],b,NROOTS*sizeof(b[0]));
+	b[0] = A0;
+      }
+      memcpy(lambda,t,(NROOTS+1)*sizeof(t[0]));
+    }
+  }
+
+  /* Convert lambda to index form and compute deg(lambda(x)) */
+  deg_lambda = 0;
+  for(i=0;i&lt;NROOTS+1;i++){
+    lambda[i] = INDEX_OF[lambda[i]];
+    if(lambda[i] != A0)
+      deg_lambda = i;
+  }
+  /* Find roots of the error+erasure locator polynomial by Chien search */
+  memcpy(&amp;reg[1],&amp;lambda[1],NROOTS*sizeof(reg[0]));
+  count = 0;		/* Number of roots of lambda(x) */
+  for (i = 1,k=IPRIM-1; i &lt;= NN; i++,k = MODNN(k+IPRIM)) {
+    q = 1; /* lambda[0] is always 0 */
+    for (j = deg_lambda; j &gt; 0; j--){
+      if (reg[j] != A0) {
+	reg[j] = MODNN(reg[j] + j);
+	q ^= ALPHA_TO[reg[j]];
+      }
+    }
+    if (q != 0)
+      continue; /* Not a root */
+    /* store root (index-form) and error location number */
+#if DEBUG&gt;=2
+    printf(&quot;count %d root %d loc %d\n&quot;,count,i,k);
+#endif
+    root[count] = i;
+    loc[count] = k;
+    /* If we've already found max possible roots,
+     * abort the search to save time
+     */
+    if(++count == deg_lambda)
+      break;
+  }
+  if (deg_lambda != count) {
+    /*
+     * deg(lambda) unequal to number of roots =&gt; uncorrectable
+     * error detected
+     */
+    count = -1;
+    goto finish;
+  }
+  /*
+   * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo
+   * x**NROOTS). in index form. Also find deg(omega).
+   */
+  deg_omega = deg_lambda-1;
+  for (i = 0; i &lt;= deg_omega;i++){
+    tmp = 0;
+    for(j=i;j &gt;= 0; j--){
+      if ((s[i - j] != A0) &amp;&amp; (lambda[j] != A0))
+	tmp ^= ALPHA_TO[MODNN(s[i - j] + lambda[j])];
+    }
+    omega[i] = INDEX_OF[tmp];
+  }
+
+  /*
+   * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =
+   * inv(X(l))**(FCR-1) and den = lambda_pr(inv(X(l))) all in poly-form
+   */
+  for (j = count-1; j &gt;=0; j--) {
+    num1 = 0;
+    for (i = deg_omega; i &gt;= 0; i--) {
+      if (omega[i] != A0)
+	num1  ^= ALPHA_TO[MODNN(omega[i] + i * root[j])];
+    }
+    num2 = ALPHA_TO[MODNN(root[j] * (FCR - 1) + NN)];
+    den = 0;
+    
+    /* lambda[i+1] for i even is the formal derivative lambda_pr of lambda[i] */
+    for (i = min(deg_lambda,NROOTS-1) &amp; ~1; i &gt;= 0; i -=2) {
+      if(lambda[i+1] != A0)
+	den ^= ALPHA_TO[MODNN(lambda[i+1] + i * root[j])];
+    }
+#if DEBUG &gt;= 1
+    if (den == 0) {
+      printf(&quot;\n ERROR: denominator = 0\n&quot;);
+      count = -1;
+      goto finish;
+    }
+#endif
+    /* Apply error to data */
+    if (num1 != 0 &amp;&amp; loc[j] &gt;= PAD) {
+      data[loc[j]-PAD] ^= ALPHA_TO[MODNN(INDEX_OF[num1] + INDEX_OF[num2] + NN - INDEX_OF[den])];
+    }
+  }
+ finish:
+  if(eras_pos != NULL){
+    for(i=0;i&lt;count;i++)
+      eras_pos[i] = loc[i];
+  }
+  return count;
+}


Property changes on: branches/map65/libm65/decode_rs.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/deep65.f90
===================================================================
--- branches/map65/libm65/deep65.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/deep65.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,169 +1,169 @@
-subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,hisgrid,decoded,qual)
-
-  parameter (MAXCALLS=7000,MAXRPT=63)
-  real s3(64,63)
-  character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
-  character*12 mycall,hiscall
-  character*22 decoded
-  character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
-  character*15 callgrid(MAXCALLS)
-  character*180 line
-  character*4 rpt(MAXRPT)
-  integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
-  real pp(2*MAXCALLS + 2 + MAXRPT)
-  common/mrscom/ mrs(63),mrs2(63)
-  common/c3com/ mcall3a
-  data rpt/'-01','-02','-03','-04','-05',          &amp;
-           '-06','-07','-08','-09','-10',          &amp;
-           '-11','-12','-13','-14','-15',          &amp;
-           '-16','-17','-18','-19','-20',          &amp;
-           '-21','-22','-23','-24','-25',          &amp;
-           '-26','-27','-28','-29','-30',          &amp;
-           'R-01','R-02','R-03','R-04','R-05',     &amp;
-           'R-06','R-07','R-08','R-09','R-10',     &amp;
-           'R-11','R-12','R-13','R-14','R-15',     &amp;
-           'R-16','R-17','R-18','R-19','R-20',     &amp;
-           'R-21','R-22','R-23','R-24','R-25',     &amp;
-           'R-26','R-27','R-28','R-29','R-30',     &amp;
-           'RO','RRR','73'/
-  save
-
-  if(mcall3a.eq.0) go to 30
-
-  call timer('deep65a ',0)
-  mcall3a=0
-  rewind 23
-  k=0
-  icall=0
-  do n=1,MAXCALLS
-     if(n.eq.1) then
-        callsign=hiscall
-        do i=4,12
-           if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
-        enddo
-        grid=hisgrid(1:4)
-        if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
-        if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
-     else
-        read(23,1002,end=20) line
-1002    format (A80)
-        if(line(1:4).eq.'ZZZZ') go to 20
-        if(line(1:2).eq.'//') go to 10
-        i1=index(line,',')
-        if(i1.lt.4) go to 10
-        i2=index(line(i1+1:),',')
-        if(i2.lt.5) go to 10
-        i2=i2+i1
-        i3=index(line(i2+1:),',')
-        if(i3.lt.1) i3=index(line(i2+1:),' ')
-        i3=i2+i3
-        callsign=line(1:i1-1)
-        grid=line(i1+1:i2-1)
-        ceme=line(i2+1:i3-1)
-        if(neme.eq.1 .and. ceme.ne.'EME') go to 10
-     endif
-
-     icall=icall+1
-     j1=index(mycall,' ') - 1
-     if(j1.le.-1) j1=12
-     if(j1.lt.3) j1=6
-     j2=index(callsign,' ') - 1
-     if(j2.le.-1) j2=12
-     if(j2.lt.3) j2=6
-     j3=index(mycall,'/')                 ! j3&gt;0 means compound mycall
-     j4=index(callsign,'/')               ! j4&gt;0 means compound hiscall
-     callgrid(icall)=callsign(1:j2)
-
-     mz=1
-! Allow MyCall + HisCall + rpt (?)
-     if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.                       &amp;
-          flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
-     do m=1,mz
-        if(m.gt.1) grid=rpt(m-1)
-        if(j3.lt.1 .and.j4.lt.1) callgrid(icall)=callsign(1:j2)//' '//grid
-        message=mycall(1:j1)//' '//callgrid(icall)
-        k=k+1
-        testmsg(k)=message
-        call encode65(message,ncode(1,k))
-        
-! Insert CQ message
-        if(j4.lt.1) callgrid(icall)=callsign(1:j2)//' '//grid
-        message='CQ '//callgrid(icall)
-        k=k+1
-        testmsg(k)=message
-        call encode65(message,ncode(1,k))
-     enddo
-10   continue
-  enddo
-
-20 continue
-  ntot=k
-  call timer('deep65a ',1)
-
-30 continue
-  call timer('deep65b ',0)
-  ref0=0.
-  do j=1,63
-     ref0=ref0 + s3(mrs(j),j)
-  enddo
-
-  p1=-1.e30
-  p2=-1.e30
-  do k=1,ntot
-     pp(k)=0.
-! Test all messages if flip=+1; skip the CQ messages if flip=-1.
-     if(flip.gt.0.0 .or. testmsg(k)(1:3).ne.'CQ ') then
-        sum=0.
-        ref=ref0
-        do j=1,63
-           i=ncode(j,k)+1
-           sum=sum + s3(i,j)
-           if(i.eq.mrs(j)) ref=ref - s3(i,j) + s3(mrs2(j),j)
-        enddo
-        p=sum/ref
-        pp(k)=p
-        if(p.gt.p1) then
-           p1=p
-           ip1=k
-        endif
-     endif
-  enddo
-
-  do i=1,ntot
-     if(pp(i).gt.p2 .and. pp(i).ne.p1) p2=pp(i)
-  enddo
-
-! ### DO NOT REMOVE ### 
-  rewind 77
-  write(77,*) p1,p2
-! ### Works OK without it (in both Windows and Linux) if compiled 
-! ### without optimization.  However, in Windows this is a colossal 
-! ### pain because of the way F2PY wants to run the compile step.
-
-  if(mode65.eq.1) bias=max(1.12*p2,0.335)
-  if(mode65.eq.2) bias=max(1.08*p2,0.405)
-  if(mode65.ge.4) bias=max(1.04*p2,0.505)
-
-  if(p2.eq.p1 .and. p1.ne.-1.e30) stop 'Error in deep65'
-  qual=100.0*(p1-bias)
-
-  decoded='                      '
-  c=' '
-
-  if(qual.gt.1.0) then
-     if(qual.lt.6.0) c='?'
-     decoded=testmsg(ip1)
-  else
-     qual=0.
-  endif
-  decoded(22:22)=c
-
-! Make sure everything is upper case.
-  do i=1,22
-     if(decoded(i:i).ge.'a' .and. decoded(i:i).le.'z')                &amp;
-          decoded(i:i)=char(ichar(decoded(i:i))-32)
-  enddo
-  call timer('deep65b ',1)
-
-  return
-end subroutine deep65
+subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,hisgrid,decoded,qual)
+
+  parameter (MAXCALLS=7000,MAXRPT=63)
+  real s3(64,63)
+  character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
+  character*12 mycall,hiscall
+  character*22 decoded
+  character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
+  character*15 callgrid(MAXCALLS)
+  character*180 line
+  character*4 rpt(MAXRPT)
+  integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
+  real pp(2*MAXCALLS + 2 + MAXRPT)
+  common/mrscom/ mrs(63),mrs2(63)
+  common/c3com/ mcall3a
+  data rpt/'-01','-02','-03','-04','-05',          &amp;
+           '-06','-07','-08','-09','-10',          &amp;
+           '-11','-12','-13','-14','-15',          &amp;
+           '-16','-17','-18','-19','-20',          &amp;
+           '-21','-22','-23','-24','-25',          &amp;
+           '-26','-27','-28','-29','-30',          &amp;
+           'R-01','R-02','R-03','R-04','R-05',     &amp;
+           'R-06','R-07','R-08','R-09','R-10',     &amp;
+           'R-11','R-12','R-13','R-14','R-15',     &amp;
+           'R-16','R-17','R-18','R-19','R-20',     &amp;
+           'R-21','R-22','R-23','R-24','R-25',     &amp;
+           'R-26','R-27','R-28','R-29','R-30',     &amp;
+           'RO','RRR','73'/
+  save
+
+  if(mcall3a.eq.0) go to 30
+
+  call timer('deep65a ',0)
+  mcall3a=0
+  rewind 23
+  k=0
+  icall=0
+  do n=1,MAXCALLS
+     if(n.eq.1) then
+        callsign=hiscall
+        do i=4,12
+           if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
+        enddo
+        grid=hisgrid(1:4)
+        if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
+        if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
+     else
+        read(23,1002,end=20) line
+1002    format (A80)
+        if(line(1:4).eq.'ZZZZ') go to 20
+        if(line(1:2).eq.'//') go to 10
+        i1=index(line,',')
+        if(i1.lt.4) go to 10
+        i2=index(line(i1+1:),',')
+        if(i2.lt.5) go to 10
+        i2=i2+i1
+        i3=index(line(i2+1:),',')
+        if(i3.lt.1) i3=index(line(i2+1:),' ')
+        i3=i2+i3
+        callsign=line(1:i1-1)
+        grid=line(i1+1:i2-1)
+        ceme=line(i2+1:i3-1)
+        if(neme.eq.1 .and. ceme.ne.'EME') go to 10
+     endif
+
+     icall=icall+1
+     j1=index(mycall,' ') - 1
+     if(j1.le.-1) j1=12
+     if(j1.lt.3) j1=6
+     j2=index(callsign,' ') - 1
+     if(j2.le.-1) j2=12
+     if(j2.lt.3) j2=6
+     j3=index(mycall,'/')                 ! j3&gt;0 means compound mycall
+     j4=index(callsign,'/')               ! j4&gt;0 means compound hiscall
+     callgrid(icall)=callsign(1:j2)
+
+     mz=1
+! Allow MyCall + HisCall + rpt (?)
+     if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.                       &amp;
+          flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
+     do m=1,mz
+        if(m.gt.1) grid=rpt(m-1)
+        if(j3.lt.1 .and.j4.lt.1) callgrid(icall)=callsign(1:j2)//' '//grid
+        message=mycall(1:j1)//' '//callgrid(icall)
+        k=k+1
+        testmsg(k)=message
+        call encode65(message,ncode(1,k))
+        
+! Insert CQ message
+        if(j4.lt.1) callgrid(icall)=callsign(1:j2)//' '//grid
+        message='CQ '//callgrid(icall)
+        k=k+1
+        testmsg(k)=message
+        call encode65(message,ncode(1,k))
+     enddo
+10   continue
+  enddo
+
+20 continue
+  ntot=k
+  call timer('deep65a ',1)
+
+30 continue
+  call timer('deep65b ',0)
+  ref0=0.
+  do j=1,63
+     ref0=ref0 + s3(mrs(j),j)
+  enddo
+
+  p1=-1.e30
+  p2=-1.e30
+  do k=1,ntot
+     pp(k)=0.
+! Test all messages if flip=+1; skip the CQ messages if flip=-1.
+     if(flip.gt.0.0 .or. testmsg(k)(1:3).ne.'CQ ') then
+        sum=0.
+        ref=ref0
+        do j=1,63
+           i=ncode(j,k)+1
+           sum=sum + s3(i,j)
+           if(i.eq.mrs(j)) ref=ref - s3(i,j) + s3(mrs2(j),j)
+        enddo
+        p=sum/ref
+        pp(k)=p
+        if(p.gt.p1) then
+           p1=p
+           ip1=k
+        endif
+     endif
+  enddo
+
+  do i=1,ntot
+     if(pp(i).gt.p2 .and. pp(i).ne.p1) p2=pp(i)
+  enddo
+
+! ### DO NOT REMOVE ### 
+  rewind 77
+  write(77,*) p1,p2
+! ### Works OK without it (in both Windows and Linux) if compiled 
+! ### without optimization.  However, in Windows this is a colossal 
+! ### pain because of the way F2PY wants to run the compile step.
+
+  if(mode65.eq.1) bias=max(1.12*p2,0.335)
+  if(mode65.eq.2) bias=max(1.08*p2,0.405)
+  if(mode65.ge.4) bias=max(1.04*p2,0.505)
+
+  if(p2.eq.p1 .and. p1.ne.-1.e30) stop 'Error in deep65'
+  qual=100.0*(p1-bias)
+
+  decoded='                      '
+  c=' '
+
+  if(qual.gt.1.0) then
+     if(qual.lt.6.0) c='?'
+     decoded=testmsg(ip1)
+  else
+     qual=0.
+  endif
+  decoded(22:22)=c
+
+! Make sure everything is upper case.
+  do i=1,22
+     if(decoded(i:i).ge.'a' .and. decoded(i:i).le.'z')                &amp;
+          decoded(i:i)=char(ichar(decoded(i:i))-32)
+  enddo
+  call timer('deep65b ',1)
+
+  return
+end subroutine deep65


Property changes on: branches/map65/libm65/deep65.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/deg2grid.f
===================================================================
--- branches/map65/libm65/deg2grid.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/deg2grid.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,30 +1,30 @@
-      subroutine deg2grid(dlong0,dlat,grid)
-
-      real dlong                        !West longitude (deg)
-      real dlat                         !Latitude (deg)
-      character grid*6
-
-      dlong=dlong0
-      if(dlong.lt.-180.0) dlong=dlong+360.0
-      if(dlong.gt.180.0) dlong=dlong-360.0
-
-C  Convert to units of 5 min of longitude, working east from 180 deg.
-      nlong=60.0*(180.0-dlong)/5.0
-      n1=nlong/240                      !20-degree field
-      n2=(nlong-240*n1)/24              !2 degree square
-      n3=nlong-240*n1-24*n2             !5 minute subsquare
-      grid(1:1)=char(ichar('A')+n1)
-      grid(3:3)=char(ichar('0')+n2)
-      grid(5:5)=char(ichar('a')+n3)
-
-C  Convert to units of 2.5 min of latitude, working north from -90 deg.
-      nlat=60.0*(dlat+90)/2.5
-      n1=nlat/240                       !10-degree field
-      n2=(nlat-240*n1)/24               !1 degree square
-      n3=nlat-240*n1-24*n2              !2.5 minuts subsquare
-      grid(2:2)=char(ichar('A')+n1)
-      grid(4:4)=char(ichar('0')+n2)
-      grid(6:6)=char(ichar('a')+n3)
-
-      return
-      end
+      subroutine deg2grid(dlong0,dlat,grid)
+
+      real dlong                        !West longitude (deg)
+      real dlat                         !Latitude (deg)
+      character grid*6
+
+      dlong=dlong0
+      if(dlong.lt.-180.0) dlong=dlong+360.0
+      if(dlong.gt.180.0) dlong=dlong-360.0
+
+C  Convert to units of 5 min of longitude, working east from 180 deg.
+      nlong=60.0*(180.0-dlong)/5.0
+      n1=nlong/240                      !20-degree field
+      n2=(nlong-240*n1)/24              !2 degree square
+      n3=nlong-240*n1-24*n2             !5 minute subsquare
+      grid(1:1)=char(ichar('A')+n1)
+      grid(3:3)=char(ichar('0')+n2)
+      grid(5:5)=char(ichar('a')+n3)
+
+C  Convert to units of 2.5 min of latitude, working north from -90 deg.
+      nlat=60.0*(dlat+90)/2.5
+      n1=nlat/240                       !10-degree field
+      n2=(nlat-240*n1)/24               !1 degree square
+      n3=nlat-240*n1-24*n2              !2.5 minuts subsquare
+      grid(2:2)=char(ichar('A')+n1)
+      grid(4:4)=char(ichar('0')+n2)
+      grid(6:6)=char(ichar('a')+n3)
+
+      return
+      end


Property changes on: branches/map65/libm65/deg2grid.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/demod64a.f
===================================================================
--- branches/map65/libm65/demod64a.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/demod64a.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,73 +1,73 @@
-      subroutine demod64a(s3,nadd,mrsym,mrprob,
-     +  mr2sym,mr2prob,ntest,nlow)
-
-C  Demodulate the 64-bin spectra for each of 63 symbols in a frame.
-
-C  Parameters
-C     nadd     number of spectra already summed
-C     mrsym    most reliable symbol value
-C     mr2sym   second most likely symbol value
-C     mrprob   probability that mrsym was the transmitted value
-C     mr2prob  probability that mr2sym was the transmitted value
-
-      implicit real*8 (a-h,o-z)
-      real*4 s3(64,63)
-      real*8 fs(64)
-      integer mrsym(63),mrprob(63),mr2sym(63),mr2prob(63)
-      common/mrscom/ mrs(63),mrs2(63)
-
-      afac=1.1 * float(nadd)**0.64
-      scale=255.999
-
-C  Compute average spectral value
-      sum=0.
-      do j=1,63
-         do i=1,64
-            sum=sum+s3(i,j)
-         enddo
-      enddo
-      ave=sum/(64.*63.)
-      i1=1                                      !Silence warning
-      i2=1
-
-C  Compute probabilities for most reliable symbol values
-      do j=1,63
-         s1=-1.e30
-         fsum=0.
-         do i=1,64
-            x=min(afac*s3(i,j)/ave,50.d0)
-            fs(i)=exp(x)
-            fsum=fsum+fs(i)
-            if(s3(i,j).gt.s1) then
-               s1=s3(i,j)
-               i1=i                              !Most reliable
-            endif
-         enddo
-
-         s2=-1.e30
-         do i=1,64
-            if(i.ne.i1 .and. s3(i,j).gt.s2) then
-               s2=s3(i,j)
-               i2=i                              !Second most reliable
-            endif
-         enddo
-         p1=fs(i1)/fsum                          !Normalized probabilities
-         p2=fs(i2)/fsum
-         mrsym(j)=i1-1
-         mr2sym(j)=i2-1
-         mrprob(j)=scale*p1
-         mr2prob(j)=scale*p2
-         mrs(j)=i1
-         mrs2(j)=i2
-      enddo
-
-      sum=0.
-      nlow=0
-      do j=1,63
-         sum=sum+mrprob(j)
-         if(mrprob(j).le.5) nlow=nlow+1
-      enddo
-      ntest=sum/63
-
-      return
-      end
+      subroutine demod64a(s3,nadd,mrsym,mrprob,
+     +  mr2sym,mr2prob,ntest,nlow)
+
+C  Demodulate the 64-bin spectra for each of 63 symbols in a frame.
+
+C  Parameters
+C     nadd     number of spectra already summed
+C     mrsym    most reliable symbol value
+C     mr2sym   second most likely symbol value
+C     mrprob   probability that mrsym was the transmitted value
+C     mr2prob  probability that mr2sym was the transmitted value
+
+      implicit real*8 (a-h,o-z)
+      real*4 s3(64,63)
+      real*8 fs(64)
+      integer mrsym(63),mrprob(63),mr2sym(63),mr2prob(63)
+      common/mrscom/ mrs(63),mrs2(63)
+
+      afac=1.1 * float(nadd)**0.64
+      scale=255.999
+
+C  Compute average spectral value
+      sum=0.
+      do j=1,63
+         do i=1,64
+            sum=sum+s3(i,j)
+         enddo
+      enddo
+      ave=sum/(64.*63.)
+      i1=1                                      !Silence warning
+      i2=1
+
+C  Compute probabilities for most reliable symbol values
+      do j=1,63
+         s1=-1.e30
+         fsum=0.
+         do i=1,64
+            x=min(afac*s3(i,j)/ave,50.d0)
+            fs(i)=exp(x)
+            fsum=fsum+fs(i)
+            if(s3(i,j).gt.s1) then
+               s1=s3(i,j)
+               i1=i                              !Most reliable
+            endif
+         enddo
+
+         s2=-1.e30
+         do i=1,64
+            if(i.ne.i1 .and. s3(i,j).gt.s2) then
+               s2=s3(i,j)
+               i2=i                              !Second most reliable
+            endif
+         enddo
+         p1=fs(i1)/fsum                          !Normalized probabilities
+         p2=fs(i2)/fsum
+         mrsym(j)=i1-1
+         mr2sym(j)=i2-1
+         mrprob(j)=scale*p1
+         mr2prob(j)=scale*p2
+         mrs(j)=i1
+         mrs2(j)=i2
+      enddo
+
+      sum=0.
+      nlow=0
+      do j=1,63
+         sum=sum+mrprob(j)
+         if(mrprob(j).le.5) nlow=nlow+1
+      enddo
+      ntest=sum/63
+
+      return
+      end


Property changes on: branches/map65/libm65/demod64a.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/display.f90
===================================================================
--- branches/map65/libm65/display.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/display.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,169 +1,169 @@
-subroutine display(nkeep,ftol)
-
-  parameter (MAXLINES=400,MX=400)
-  integer indx(MAXLINES),indx2(MX)
-  character*81 line(MAXLINES),line2(MX),line3(MAXLINES)
-  character out*50,cfreq0*3,cqlive*52
-  character*6 callsign,callsign0
-  character*12 freqcall(100)
-  real freqkHz(MAXLINES)
-  integer utc(MAXLINES),utc2(MX),utcz
-  real*8 f0
-
-  rewind 26
-
-  do i=1,MAXLINES
-     read(26,1010,end=10) line(i)
-1010 format(a80)
-     read(line(i),1020) f0,ndf,nh,nm
-1020 format(f8.3,i5,25x,i3,i2)
-     utc(i)=60*nh + nm
-     freqkHz(i)=1000.d0*(f0-144.d0) + 0.001d0*ndf
-  enddo
-
-10 nz=i-1
-  utcz=utc(nz)
-  nz=nz-1
-  if(nz.lt.1) go to 999
-  nquad=max(nkeep/4,3)
-  do i=1,nz
-     nage=utcz-utc(i)
-     if(nage.lt.0) nage=nage+1440
-     iage=nage/nquad
-     write(line(i)(80:81),1021) iage
-1021 format(i2)
-  enddo
-
-  nage=utcz-utc(1)
-  if(nage.lt.0) nage=nage+1440
-  if(nage.gt.nkeep) then
-     do i=1,nz
-        nage=utcz-utc(i)
-        if(nage.lt.0) nage=nage+1440
-        if(nage.le.nkeep) go to 20
-     enddo
-20   i0=i
-     nz=nz-i0+1
-     rewind 26
-     if(nz.lt.1) go to 999
-     do i=1,nz
-        j=i+i0-1
-        line(i)=line(j)
-        utc(i)=utc(j)
-        freqkHz(i)=freqkHz(j)
-        write(26,1010) line(i)
-     enddo
-  endif
-
-  call flush(26)
-  call indexx(nz,freqkHz,indx)
-
-  nstart=1
-  k3=0
-  k=1
-  m=indx(1)
-  if(m.lt.1 .or. m.gt.MAXLINES) then
-     print*,'Error in display.f90: ',nz,m
-     m=1
-  endif
-  line2(1)=line(m)
-  utc2(1)=utc(m)
-  do i=2,nz
-     j0=indx(i-1)
-     j=indx(i)
-     if(freqkHz(j)-freqkHz(j0).gt.2.0*ftol) then
-        if(nstart.eq.0) then
-           k=k+1
-           line2(k)=&quot;&quot;
-           utc2(k)=-1
-        endif
-        kz=k
-        if(nstart.eq.1) then
-           call indexx(kz,utc2,indx2)
-           k3=0
-           do k=1,kz
-              k3=min(k3+1,400)
-              line3(k3)=line2(indx2(k))
-           enddo
-           nstart=0
-        else
-           call indexx(kz,utc2,indx2)
-           do k=1,kz
-              k3=min(k3+1,400)
-              line3(k3)=line2(indx2(k))
-           enddo
-        endif
-        k=0
-     endif
-     if(i.eq.nz) then
-        k=k+1
-        line2(k)=&quot;&quot;
-        utc2(k)=-1
-     endif
-     k=k+1
-     line2(k)=line(j)
-     utc2(k)=utc(j)
-     j0=j
-  enddo
-  kz=k
-  call indexx(kz,utc2,indx2)
-  do k=1,kz
-     k3=min(k3+1,400)
-     line3(k3)=line2(indx2(k))
-  enddo
-
-  rewind 19
-  rewind 20
-  cfreq0='   '
-  nc=0
-  callsign0='      '
-  do k=1,k3
-     out=line3(k)(6:13)//line3(k)(28:31)//line3(k)(39:43)//       &amp;
-          line3(k)(35:38)//line3(k)(44:67)//line3(k)(77:81)
-     if(out(1:3).ne.'   ') then
-        cfreq0=out(1:3)
-        if(iw.lt.MAXLINES-1) iw=iw+1
-        cqlive=line3(k)(6:13)//line3(k)(28:31)//line3(k)(39:43)//       &amp;
-             line3(k)(23:27)//line3(k)(35:38)//line3(k)(44:67)//        &amp;
-             line3(k)(80:81)
-        if(index(cqlive,' CQ ').gt.0 .or. index(cqlive,' QRZ ').gt.0 .or.   &amp;
-           index(cqlive,' QRT ').gt.0 .or. index(cqlive,' CQV ').gt.0 .or.  &amp;
-           index(cqlive,' CQH ').gt.0) write(19,1029) cqlive
-1029    format(a52)
-        write(*,1030) out
-1030    format('@',a50)
-        i1=index(out(24:),' ')
-        callsign=out(i1+24:)
-        i2=index(callsign,' ')
-        if(i2.gt.1) callsign(i2:)='      '
-        if(callsign.ne.'      ' .and. callsign.ne.callsign0) then
-           len=i2-1
-           if(len.lt.0) len=6
-           if(len.ge.4) then                        !Omit short &quot;callsigns&quot;
-              nc=nc+1
-              freqcall(nc)=cfreq0//' '//callsign//line3(k)(80:81)
-              callsign0=callsign
-           endif
-        endif
-        if(callsign.ne.'      ' .and. callsign.eq.callsign0) then
-           freqcall(nc)=cfreq0//' '//callsign//line3(k)(80:81)
-        endif
-     endif
-  enddo
-  flush(19)
-  nc=nc+1
-  freqcall(nc)='            '
-  nc=nc+1
-  freqcall(nc)='            '
-  freqcall(nc+1)='            '
-  freqcall(nc+2)='            '
-  iz=(nc+2)/3
-
-  do i=1,nc
-  write(*,1042) freqcall(i)
-1042 format('&amp;',a12)
-  enddo
-
-999  continue
-  return
-end subroutine display
+subroutine display(nkeep,ftol)
+
+  parameter (MAXLINES=400,MX=400)
+  integer indx(MAXLINES),indx2(MX)
+  character*81 line(MAXLINES),line2(MX),line3(MAXLINES)
+  character out*50,cfreq0*3,cqlive*52
+  character*6 callsign,callsign0
+  character*12 freqcall(100)
+  real freqkHz(MAXLINES)
+  integer utc(MAXLINES),utc2(MX),utcz
+  real*8 f0
+
+  rewind 26
+
+  do i=1,MAXLINES
+     read(26,1010,end=10) line(i)
+1010 format(a80)
+     read(line(i),1020) f0,ndf,nh,nm
+1020 format(f8.3,i5,25x,i3,i2)
+     utc(i)=60*nh + nm
+     freqkHz(i)=1000.d0*(f0-144.d0) + 0.001d0*ndf
+  enddo
+
+10 nz=i-1
+  utcz=utc(nz)
+  nz=nz-1
+  if(nz.lt.1) go to 999
+  nquad=max(nkeep/4,3)
+  do i=1,nz
+     nage=utcz-utc(i)
+     if(nage.lt.0) nage=nage+1440
+     iage=nage/nquad
+     write(line(i)(80:81),1021) iage
+1021 format(i2)
+  enddo
+
+  nage=utcz-utc(1)
+  if(nage.lt.0) nage=nage+1440
+  if(nage.gt.nkeep) then
+     do i=1,nz
+        nage=utcz-utc(i)
+        if(nage.lt.0) nage=nage+1440
+        if(nage.le.nkeep) go to 20
+     enddo
+20   i0=i
+     nz=nz-i0+1
+     rewind 26
+     if(nz.lt.1) go to 999
+     do i=1,nz
+        j=i+i0-1
+        line(i)=line(j)
+        utc(i)=utc(j)
+        freqkHz(i)=freqkHz(j)
+        write(26,1010) line(i)
+     enddo
+  endif
+
+  call flush(26)
+  call indexx(nz,freqkHz,indx)
+
+  nstart=1
+  k3=0
+  k=1
+  m=indx(1)
+  if(m.lt.1 .or. m.gt.MAXLINES) then
+     print*,'Error in display.f90: ',nz,m
+     m=1
+  endif
+  line2(1)=line(m)
+  utc2(1)=utc(m)
+  do i=2,nz
+     j0=indx(i-1)
+     j=indx(i)
+     if(freqkHz(j)-freqkHz(j0).gt.2.0*ftol) then
+        if(nstart.eq.0) then
+           k=k+1
+           line2(k)=&quot;&quot;
+           utc2(k)=-1
+        endif
+        kz=k
+        if(nstart.eq.1) then
+           call indexx(kz,utc2,indx2)
+           k3=0
+           do k=1,kz
+              k3=min(k3+1,400)
+              line3(k3)=line2(indx2(k))
+           enddo
+           nstart=0
+        else
+           call indexx(kz,utc2,indx2)
+           do k=1,kz
+              k3=min(k3+1,400)
+              line3(k3)=line2(indx2(k))
+           enddo
+        endif
+        k=0
+     endif
+     if(i.eq.nz) then
+        k=k+1
+        line2(k)=&quot;&quot;
+        utc2(k)=-1
+     endif
+     k=k+1
+     line2(k)=line(j)
+     utc2(k)=utc(j)
+     j0=j
+  enddo
+  kz=k
+  call indexx(kz,utc2,indx2)
+  do k=1,kz
+     k3=min(k3+1,400)
+     line3(k3)=line2(indx2(k))
+  enddo
+
+  rewind 19
+  rewind 20
+  cfreq0='   '
+  nc=0
+  callsign0='      '
+  do k=1,k3
+     out=line3(k)(6:13)//line3(k)(28:31)//line3(k)(39:43)//       &amp;
+          line3(k)(35:38)//line3(k)(44:67)//line3(k)(77:81)
+     if(out(1:3).ne.'   ') then
+        cfreq0=out(1:3)
+        if(iw.lt.MAXLINES-1) iw=iw+1
+        cqlive=line3(k)(6:13)//line3(k)(28:31)//line3(k)(39:43)//       &amp;
+             line3(k)(23:27)//line3(k)(35:38)//line3(k)(44:67)//        &amp;
+             line3(k)(80:81)
+        if(index(cqlive,' CQ ').gt.0 .or. index(cqlive,' QRZ ').gt.0 .or.   &amp;
+           index(cqlive,' QRT ').gt.0 .or. index(cqlive,' CQV ').gt.0 .or.  &amp;
+           index(cqlive,' CQH ').gt.0) write(19,1029) cqlive
+1029    format(a52)
+        write(*,1030) out
+1030    format('@',a50)
+        i1=index(out(24:),' ')
+        callsign=out(i1+24:)
+        i2=index(callsign,' ')
+        if(i2.gt.1) callsign(i2:)='      '
+        if(callsign.ne.'      ' .and. callsign.ne.callsign0) then
+           len=i2-1
+           if(len.lt.0) len=6
+           if(len.ge.4) then                        !Omit short &quot;callsigns&quot;
+              nc=nc+1
+              freqcall(nc)=cfreq0//' '//callsign//line3(k)(80:81)
+              callsign0=callsign
+           endif
+        endif
+        if(callsign.ne.'      ' .and. callsign.eq.callsign0) then
+           freqcall(nc)=cfreq0//' '//callsign//line3(k)(80:81)
+        endif
+     endif
+  enddo
+  flush(19)
+  nc=nc+1
+  freqcall(nc)='            '
+  nc=nc+1
+  freqcall(nc)='            '
+  freqcall(nc+1)='            '
+  freqcall(nc+2)='            '
+  iz=(nc+2)/3
+
+  do i=1,nc
+  write(*,1042) freqcall(i)
+1042 format('&amp;',a12)
+  enddo
+
+999  continue
+  return
+end subroutine display


Property changes on: branches/map65/libm65/display.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/dot.f
===================================================================
--- branches/map65/libm65/dot.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/dot.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,11 +1,11 @@
-      real*8 function dot(x,y)
-
-      real*8 x(3),y(3)
-
-      dot=0.d0
-      do i=1,3
-         dot=dot+x(i)*y(i)
-      enddo
-
-      return
-      end
+      real*8 function dot(x,y)
+
+      real*8 x(3),y(3)
+
+      dot=0.d0
+      do i=1,3
+         dot=dot+x(i)*y(i)
+      enddo
+
+      return
+      end


Property changes on: branches/map65/libm65/dot.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/dpol.f90
===================================================================
--- branches/map65/libm65/dpol.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/dpol.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,41 +1,41 @@
-real function dpol(mygrid,hisgrid)
-
-! Compute spatial polartzation offset in degrees for the present 
-! time, between two specified grid locators.
-
-  character*6 MyGrid,HisGrid
-  real lat,lon,LST
-  character cdate*8,ctime2*10,czone*5,fnamedate*6
-  integer  it(8)
-  data rad/57.2957795/
-
-  call date_and_time(cdate,ctime2,czone,it)
-  nyear=it(1)
-  month=it(2)
-  nday=it(3)
-  nh=it(5)-it(4)/60
-  nm=it(6)
-  ns=it(7)
-  uth=nh + nm/60.0 + ns/3600.0
-
-  call grid2deg(MyGrid,lon,lat)
-  call MoonDop(nyear,month,nday,uth,-lon,lat,RAMoon,DecMoon,         &amp;
-       LST,HA,AzMoon,ElMoon,vr,dist)
-  xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*                    &amp;
-       cos(AzMoon/rad)*sin(ElMoon/rad)
-  yy=cos(lat/rad)*sin(AzMoon/rad)
-  poloffset1=rad*atan2(yy,xx)
-
-  call grid2deg(hisGrid,lon,lat)
-  call MoonDop(nyear,month,nday,uth,-lon,lat,RAMoon,DecMoon,         &amp;
-       LST,HA,AzMoon,ElMoon,vr,dist)
-  xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*                    &amp;
-       cos(AzMoon/rad)*sin(ElMoon/rad)
-  yy=cos(lat/rad)*sin(AzMoon/rad)
-  poloffset2=rad*atan2(yy,xx)
-
-  dpol=mod(poloffset2-poloffset1+720.0,180.0)
-  if(dpol.gt.90.0) dpol=dpol-180.0
-
-  return
-end function dpol
+real function dpol(mygrid,hisgrid)
+
+! Compute spatial polartzation offset in degrees for the present 
+! time, between two specified grid locators.
+
+  character*6 MyGrid,HisGrid
+  real lat,lon,LST
+  character cdate*8,ctime2*10,czone*5,fnamedate*6
+  integer  it(8)
+  data rad/57.2957795/
+
+  call date_and_time(cdate,ctime2,czone,it)
+  nyear=it(1)
+  month=it(2)
+  nday=it(3)
+  nh=it(5)-it(4)/60
+  nm=it(6)
+  ns=it(7)
+  uth=nh + nm/60.0 + ns/3600.0
+
+  call grid2deg(MyGrid,lon,lat)
+  call MoonDop(nyear,month,nday,uth,-lon,lat,RAMoon,DecMoon,         &amp;
+       LST,HA,AzMoon,ElMoon,vr,dist)
+  xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*                    &amp;
+       cos(AzMoon/rad)*sin(ElMoon/rad)
+  yy=cos(lat/rad)*sin(AzMoon/rad)
+  poloffset1=rad*atan2(yy,xx)
+
+  call grid2deg(hisGrid,lon,lat)
+  call MoonDop(nyear,month,nday,uth,-lon,lat,RAMoon,DecMoon,         &amp;
+       LST,HA,AzMoon,ElMoon,vr,dist)
+  xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*                    &amp;
+       cos(AzMoon/rad)*sin(ElMoon/rad)
+  yy=cos(lat/rad)*sin(AzMoon/rad)
+  poloffset2=rad*atan2(yy,xx)
+
+  dpol=mod(poloffset2-poloffset1+720.0,180.0)
+  if(dpol.gt.90.0) dpol=dpol-180.0
+
+  return
+end function dpol


Property changes on: branches/map65/libm65/dpol.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/encode65.f
===================================================================
--- branches/map65/libm65/encode65.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/encode65.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,13 +1,13 @@
-      subroutine encode65(message,sent)
-
-      character message*22
-      integer dgen(12)
-      integer sent(63)
-
-      call packmsg(message,dgen)
-      call rs_encode(dgen,sent)
-      call interleave63(sent,1)
-      call graycode(sent,63,1)
-
-      return
-      end
+      subroutine encode65(message,sent)
+
+      character message*22
+      integer dgen(12)
+      integer sent(63)
+
+      call packmsg(message,dgen)
+      call rs_encode(dgen,sent)
+      call interleave63(sent,1)
+      call graycode(sent,63,1)
+
+      return
+      end


Property changes on: branches/map65/libm65/encode65.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/encode_rs.c
===================================================================
--- branches/map65/libm65/encode_rs.c	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/encode_rs.c	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,52 +1,52 @@
-/* Reed-Solomon encoder
- * Copyright 2002, Phil Karn, KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-#include &lt;string.h&gt;
-
-#ifdef FIXED
-#include &quot;fixed.h&quot;
-#elif defined(BIGSYM)
-#include &quot;int.h&quot;
-#else
-#include &quot;char.h&quot;
-#endif
-
-void ENCODE_RS(
-#ifdef FIXED
-DTYPE *data, DTYPE *bb,int pad){
-#else
-void *p,DTYPE *data, DTYPE *bb){
-  struct rs *rs = (struct rs *)p;
-#endif
-  int i, j;
-  DTYPE feedback;
-
-#ifdef FIXED
-  /* Check pad parameter for validity */
-  if(pad &lt; 0 || pad &gt;= NN)
-    return;
-#endif
-
-  memset(bb,0,NROOTS*sizeof(DTYPE));
-
-  for(i=0;i&lt;NN-NROOTS-PAD;i++){
-    feedback = INDEX_OF[data[i] ^ bb[0]];
-    if(feedback != A0){      /* feedback term is non-zero */
-#ifdef UNNORMALIZED
-      /* This line is unnecessary when GENPOLY[NROOTS] is unity, as it must
-       * always be for the polynomials constructed by init_rs()
-       */
-      feedback = MODNN(NN - GENPOLY[NROOTS] + feedback);
-#endif
-      for(j=1;j&lt;NROOTS;j++)
-	bb[j] ^= ALPHA_TO[MODNN(feedback + GENPOLY[NROOTS-j])];
-    }
-    /* Shift */
-    memmove(&amp;bb[0],&amp;bb[1],sizeof(DTYPE)*(NROOTS-1));
-    if(feedback != A0)
-      bb[NROOTS-1] = ALPHA_TO[MODNN(feedback + GENPOLY[0])];
-    else
-      bb[NROOTS-1] = 0;
-  }
-}
+/* Reed-Solomon encoder
+ * Copyright 2002, Phil Karn, KA9Q
+ * May be used under the terms of the GNU General Public License (GPL)
+ */
+#include &lt;string.h&gt;
+
+#ifdef FIXED
+#include &quot;fixed.h&quot;
+#elif defined(BIGSYM)
+#include &quot;int.h&quot;
+#else
+#include &quot;char.h&quot;
+#endif
+
+void ENCODE_RS(
+#ifdef FIXED
+DTYPE *data, DTYPE *bb,int pad){
+#else
+void *p,DTYPE *data, DTYPE *bb){
+  struct rs *rs = (struct rs *)p;
+#endif
+  int i, j;
+  DTYPE feedback;
+
+#ifdef FIXED
+  /* Check pad parameter for validity */
+  if(pad &lt; 0 || pad &gt;= NN)
+    return;
+#endif
+
+  memset(bb,0,NROOTS*sizeof(DTYPE));
+
+  for(i=0;i&lt;NN-NROOTS-PAD;i++){
+    feedback = INDEX_OF[data[i] ^ bb[0]];
+    if(feedback != A0){      /* feedback term is non-zero */
+#ifdef UNNORMALIZED
+      /* This line is unnecessary when GENPOLY[NROOTS] is unity, as it must
+       * always be for the polynomials constructed by init_rs()
+       */
+      feedback = MODNN(NN - GENPOLY[NROOTS] + feedback);
+#endif
+      for(j=1;j&lt;NROOTS;j++)
+	bb[j] ^= ALPHA_TO[MODNN(feedback + GENPOLY[NROOTS-j])];
+    }
+    /* Shift */
+    memmove(&amp;bb[0],&amp;bb[1],sizeof(DTYPE)*(NROOTS-1));
+    if(feedback != A0)
+      bb[NROOTS-1] = ALPHA_TO[MODNN(feedback + GENPOLY[0])];
+    else
+      bb[NROOTS-1] = 0;
+  }
+}


Property changes on: branches/map65/libm65/encode_rs.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/extract.F
===================================================================
--- branches/map65/libm65/extract.F	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/extract.F	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,109 +1,109 @@
-      subroutine extract(s3,nadd,ncount,nhist,decoded,ltext)
-
-      real s3(64,63)
-      real tmp(4032)
-      character decoded*22
-      integer era(51),dat4(12),indx(64)
-      integer mrsym(63),mr2sym(63),mrprob(63),mr2prob(63)
-      logical first,ltext
-      data first/.true./,nsec1/0/
-      save
-
-      nfail=0
- 1    continue
-!      call timer('demod64a',0)
-      call demod64a(s3,nadd,mrsym,mrprob,mr2sym,mr2prob,ntest,nlow)
-!      call timer('demod64a',1)
-      if(ntest.lt.50 .or. nlow.gt.20) then
-         ncount=-999                         !Flag bad data
-         go to 900
-      endif
-      call chkhist(mrsym,nhist,ipk)
-
-      if(nhist.ge.20) then
-         nfail=nfail+1
-         call pctile(s3,tmp,4032,50,base)     ! ### or, use ave from demod64a
-         do j=1,63
-            s3(ipk,j)=base
-         enddo
-         if(nfail.gt.30) then
-            decoded='                      '
-            ncount=-1
-            go to 900
-         endif
-         go to 1
-      endif
-
-      call graycode(mrsym,63,-1)
-      call interleave63(mrsym,-1)
-      call interleave63(mrprob,-1)
-
-      ndec=1
-      nemax=30                              !Was 200 (30)
-      maxe=8
-      xlambda=13.0                          !Was 12
-
-      if(ndec.eq.1) then
-         call graycode(mr2sym,63,-1)
-         call interleave63(mr2sym,-1)
-         call interleave63(mr2prob,-1)
-
-         nsec1=nsec1+1
-         write(22,rec=1) nsec1,xlambda,maxe,200,
-     +        mrsym,mrprob,mr2sym,mr2prob
-         call flush(22)
-!         call timer('kvasd   ',0)
-#ifdef UNIX
-         iret=system('./kvasd -q &gt; dev_null')
-#else
-         iret=system('kvasd -q &gt; dev_null')
-#endif
-!         call timer('kvasd   ',1)
-         if(iret.ne.0) then
-            if(first) write(*,1000) iret
- 1000       format('Error in KV decoder, or no KV decoder present.'/
-     +         'Return code:',i8,'.  Will use BM algorithm.')
-            ndec=0
-            first=.false.
-            go to 20
-         endif
-
-         read(22,rec=2) nsec2,ncount,dat4
-         j=nsec2                !Silence compiler warning
-         decoded='                      '
-         ltext=.false.
-         if(ncount.ge.0) then
-            call unpackmsg(dat4,decoded)     !Unpack the user message
-            if(iand(dat4(10),8).ne.0) ltext=.true.
-            do i=2,12
-               if(dat4(i).ne.dat4(1)) go to 20
-            enddo
-            write(13,*) 'Bad decode?',nhist,nfail,ipk,
-     +      ' ',dat4,decoded
-            ncount=-1           !Suppress supposedly bogus decodes
-            decoded='                      '
-         endif
-      endif
- 20   if(ndec.eq.0) then
-         call indexx(63,mrprob,indx)
-         do i=1,nemax
-            j=indx(i)
-            if(mrprob(j).gt.120) then
-               ne2=i-1
-               go to 2
-            endif
-            era(i)=j-1
-         enddo
-         ne2=nemax
- 2       decoded='                      '
-         do nerase=0,ne2,2
-            call rs_decode(mrsym,era,nerase,dat4,ncount)
-            if(ncount.ge.0) then
-               call unpackmsg(dat4,decoded)
-               go to 900
-            endif
-         enddo
-      endif
-
- 900  return
-      end
+      subroutine extract(s3,nadd,ncount,nhist,decoded,ltext)
+
+      real s3(64,63)
+      real tmp(4032)
+      character decoded*22
+      integer era(51),dat4(12),indx(64)
+      integer mrsym(63),mr2sym(63),mrprob(63),mr2prob(63)
+      logical first,ltext
+      data first/.true./,nsec1/0/
+      save
+
+      nfail=0
+ 1    continue
+!      call timer('demod64a',0)
+      call demod64a(s3,nadd,mrsym,mrprob,mr2sym,mr2prob,ntest,nlow)
+!      call timer('demod64a',1)
+      if(ntest.lt.50 .or. nlow.gt.20) then
+         ncount=-999                         !Flag bad data
+         go to 900
+      endif
+      call chkhist(mrsym,nhist,ipk)
+
+      if(nhist.ge.20) then
+         nfail=nfail+1
+         call pctile(s3,tmp,4032,50,base)     ! ### or, use ave from demod64a
+         do j=1,63
+            s3(ipk,j)=base
+         enddo
+         if(nfail.gt.30) then
+            decoded='                      '
+            ncount=-1
+            go to 900
+         endif
+         go to 1
+      endif
+
+      call graycode(mrsym,63,-1)
+      call interleave63(mrsym,-1)
+      call interleave63(mrprob,-1)
+
+      ndec=1
+      nemax=30                              !Was 200 (30)
+      maxe=8
+      xlambda=13.0                          !Was 12
+
+      if(ndec.eq.1) then
+         call graycode(mr2sym,63,-1)
+         call interleave63(mr2sym,-1)
+         call interleave63(mr2prob,-1)
+
+         nsec1=nsec1+1
+         write(22,rec=1) nsec1,xlambda,maxe,200,
+     +        mrsym,mrprob,mr2sym,mr2prob
+         call flush(22)
+!         call timer('kvasd   ',0)
+#ifdef UNIX
+         iret=system('./kvasd -q &gt; dev_null')
+#else
+         iret=system('kvasd -q &gt; dev_null')
+#endif
+!         call timer('kvasd   ',1)
+         if(iret.ne.0) then
+            if(first) write(*,1000) iret
+ 1000       format('Error in KV decoder, or no KV decoder present.'/
+     +         'Return code:',i8,'.  Will use BM algorithm.')
+            ndec=0
+            first=.false.
+            go to 20
+         endif
+
+         read(22,rec=2) nsec2,ncount,dat4
+         j=nsec2                !Silence compiler warning
+         decoded='                      '
+         ltext=.false.
+         if(ncount.ge.0) then
+            call unpackmsg(dat4,decoded)     !Unpack the user message
+            if(iand(dat4(10),8).ne.0) ltext=.true.
+            do i=2,12
+               if(dat4(i).ne.dat4(1)) go to 20
+            enddo
+            write(13,*) 'Bad decode?',nhist,nfail,ipk,
+     +      ' ',dat4,decoded
+            ncount=-1           !Suppress supposedly bogus decodes
+            decoded='                      '
+         endif
+      endif
+ 20   if(ndec.eq.0) then
+         call indexx(63,mrprob,indx)
+         do i=1,nemax
+            j=indx(i)
+            if(mrprob(j).gt.120) then
+               ne2=i-1
+               go to 2
+            endif
+            era(i)=j-1
+         enddo
+         ne2=nemax
+ 2       decoded='                      '
+         do nerase=0,ne2,2
+            call rs_decode(mrsym,era,nerase,dat4,ncount)
+            if(ncount.ge.0) then
+               call unpackmsg(dat4,decoded)
+               go to 900
+            endif
+         enddo
+      endif
+
+ 900  return
+      end


Property changes on: branches/map65/libm65/extract.F
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: branches/map65/libm65/f77_wisdom.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/fchisq.f
===================================================================
--- branches/map65/libm65/fchisq.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/fchisq.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,76 +1,76 @@
-      real function fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
-
-      parameter (NMAX=60*96000)          !Samples per 60 s
-      complex cx(npts),cy(npts)
-      real a(5)
-      complex w,wstep,za,zb,z
-      real ss(2600)
-      complex csx(0:NMAX/64),csy(0:NMAX/64)
-      data twopi/6.283185307/a1,a2,a3/99.,99.,99./
-      save
-
-      call timer('fchisq  ',0)
-      baud=11025.0/4096.0
-      if(a(1).ne.a1 .or. a(2).ne.a2 .or. a(3).ne.a3) then
-         a1=a(1)
-         a2=a(2)
-         a3=a(3)
-
-C  Mix and integrate the complex X and Y signals
-         csx(0)=0.
-         csy(0)=0.
-         w=1.0
-         x0=0.5*(npts+1)
-         s=2.0/npts
-         do i=1,npts
-            x=s*(i-x0)
-            if(mod(i,100).eq.1) then
-               p2=1.5*x*x - 0.5
-!               p3=2.5*(x**3) - 1.5*x
-!               p4=4.375*(x**4) - 3.75*(x**2) + 0.375
-               dphi=(a(1) + x*a(2) + p2*a(3)) * (twopi/fsample)
-               wstep=cmplx(cos(dphi),sin(dphi))
-            endif
-            w=w*wstep
-            csx(i)=csx(i-1) + w*cx(i)
-            csy(i)=csy(i-1) + w*cy(i)
-         enddo
-      endif
-
-C  Compute 1/2-symbol powers at 1/16-symbol steps.
-      fac=1.e-4
-      pol=a(4)/57.2957795
-      aa=cos(pol)
-      bb=sin(pol)
-      nsps=nint(fsample/baud)                  !Samples per symbol
-      nsph=nsps/2                              !Samples per half-symbol
-
-      ndiv=16                                  !Output ss() steps per symbol
-      nout=ndiv*npts/nsps
-      dtstep=1.0/(ndiv*baud)                   !Time per output step
-
-      do i=1,nout
-         j=i*nsps/ndiv
-         k=j-nsph
-         ss(i)=0.
-         if(k.ge.1) then
-            za=csx(j)-csx(k)
-            zb=csy(j)-csy(k)
-            z=aa*za + bb*zb
-            ss(i)=fac*(real(z)**2 + aimag(z)**2)
-         endif
-      enddo
-
-      ccfmax=0.
-      call timer('ccf2    ',0)
-      call ccf2(ss,nout,nflip,ccf,lagpk)
-      call timer('ccf2    ',1)
-      if(ccf.gt.ccfmax) then
-         ccfmax=ccf
-         dtmax=lagpk*dtstep
-      endif
-      fchisq=-ccfmax
-
-      call timer('fchisq  ',1)
-      return
-      end
+      real function fchisq(cx,cy,npts,fsample,nflip,a,ccfmax,dtmax)
+
+      parameter (NMAX=60*96000)          !Samples per 60 s
+      complex cx(npts),cy(npts)
+      real a(5)
+      complex w,wstep,za,zb,z
+      real ss(2600)
+      complex csx(0:NMAX/64),csy(0:NMAX/64)
+      data twopi/6.283185307/a1,a2,a3/99.,99.,99./
+      save
+
+      call timer('fchisq  ',0)
+      baud=11025.0/4096.0
+      if(a(1).ne.a1 .or. a(2).ne.a2 .or. a(3).ne.a3) then
+         a1=a(1)
+         a2=a(2)
+         a3=a(3)
+
+C  Mix and integrate the complex X and Y signals
+         csx(0)=0.
+         csy(0)=0.
+         w=1.0
+         x0=0.5*(npts+1)
+         s=2.0/npts
+         do i=1,npts
+            x=s*(i-x0)
+            if(mod(i,100).eq.1) then
+               p2=1.5*x*x - 0.5
+!               p3=2.5*(x**3) - 1.5*x
+!               p4=4.375*(x**4) - 3.75*(x**2) + 0.375
+               dphi=(a(1) + x*a(2) + p2*a(3)) * (twopi/fsample)
+               wstep=cmplx(cos(dphi),sin(dphi))
+            endif
+            w=w*wstep
+            csx(i)=csx(i-1) + w*cx(i)
+            csy(i)=csy(i-1) + w*cy(i)
+         enddo
+      endif
+
+C  Compute 1/2-symbol powers at 1/16-symbol steps.
+      fac=1.e-4
+      pol=a(4)/57.2957795
+      aa=cos(pol)
+      bb=sin(pol)
+      nsps=nint(fsample/baud)                  !Samples per symbol
+      nsph=nsps/2                              !Samples per half-symbol
+
+      ndiv=16                                  !Output ss() steps per symbol
+      nout=ndiv*npts/nsps
+      dtstep=1.0/(ndiv*baud)                   !Time per output step
+
+      do i=1,nout
+         j=i*nsps/ndiv
+         k=j-nsph
+         ss(i)=0.
+         if(k.ge.1) then
+            za=csx(j)-csx(k)
+            zb=csy(j)-csy(k)
+            z=aa*za + bb*zb
+            ss(i)=fac*(real(z)**2 + aimag(z)**2)
+         endif
+      enddo
+
+      ccfmax=0.
+      call timer('ccf2    ',0)
+      call ccf2(ss,nout,nflip,ccf,lagpk)
+      call timer('ccf2    ',1)
+      if(ccf.gt.ccfmax) then
+         ccfmax=ccf
+         dtmax=lagpk*dtstep
+      endif
+      fchisq=-ccfmax
+
+      call timer('fchisq  ',1)
+      return
+      end


Property changes on: branches/map65/libm65/fchisq.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/fftw3.f
===================================================================
--- branches/map65/libm65/fftw3.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/fftw3.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,64 +1,64 @@
-      INTEGER FFTW_R2HC
-      PARAMETER (FFTW_R2HC=0)
-      INTEGER FFTW_HC2R
-      PARAMETER (FFTW_HC2R=1)
-      INTEGER FFTW_DHT
-      PARAMETER (FFTW_DHT=2)
-      INTEGER FFTW_REDFT00
-      PARAMETER (FFTW_REDFT00=3)
-      INTEGER FFTW_REDFT01
-      PARAMETER (FFTW_REDFT01=4)
-      INTEGER FFTW_REDFT10
-      PARAMETER (FFTW_REDFT10=5)
-      INTEGER FFTW_REDFT11
-      PARAMETER (FFTW_REDFT11=6)
-      INTEGER FFTW_RODFT00
-      PARAMETER (FFTW_RODFT00=7)
-      INTEGER FFTW_RODFT01
-      PARAMETER (FFTW_RODFT01=8)
-      INTEGER FFTW_RODFT10
-      PARAMETER (FFTW_RODFT10=9)
-      INTEGER FFTW_RODFT11
-      PARAMETER (FFTW_RODFT11=10)
-      INTEGER FFTW_FORWARD
-      PARAMETER (FFTW_FORWARD=-1)
-      INTEGER FFTW_BACKWARD
-      PARAMETER (FFTW_BACKWARD=+1)
-      INTEGER FFTW_MEASURE
-      PARAMETER (FFTW_MEASURE=0)
-      INTEGER FFTW_DESTROY_INPUT
-      PARAMETER (FFTW_DESTROY_INPUT=1)
-      INTEGER FFTW_UNALIGNED
-      PARAMETER (FFTW_UNALIGNED=2)
-      INTEGER FFTW_CONSERVE_MEMORY
-      PARAMETER (FFTW_CONSERVE_MEMORY=4)
-      INTEGER FFTW_EXHAUSTIVE
-      PARAMETER (FFTW_EXHAUSTIVE=8)
-      INTEGER FFTW_PRESERVE_INPUT
-      PARAMETER (FFTW_PRESERVE_INPUT=16)
-      INTEGER FFTW_PATIENT
-      PARAMETER (FFTW_PATIENT=32)
-      INTEGER FFTW_ESTIMATE
-      PARAMETER (FFTW_ESTIMATE=64)
-      INTEGER FFTW_ESTIMATE_PATIENT
-      PARAMETER (FFTW_ESTIMATE_PATIENT=128)
-      INTEGER FFTW_BELIEVE_PCOST
-      PARAMETER (FFTW_BELIEVE_PCOST=256)
-      INTEGER FFTW_DFT_R2HC_ICKY
-      PARAMETER (FFTW_DFT_R2HC_ICKY=512)
-      INTEGER FFTW_NONTHREADED_ICKY
-      PARAMETER (FFTW_NONTHREADED_ICKY=1024)
-      INTEGER FFTW_NO_BUFFERING
-      PARAMETER (FFTW_NO_BUFFERING=2048)
-      INTEGER FFTW_NO_INDIRECT_OP
-      PARAMETER (FFTW_NO_INDIRECT_OP=4096)
-      INTEGER FFTW_ALLOW_LARGE_GENERIC
-      PARAMETER (FFTW_ALLOW_LARGE_GENERIC=8192)
-      INTEGER FFTW_NO_RANK_SPLITS
-      PARAMETER (FFTW_NO_RANK_SPLITS=16384)
-      INTEGER FFTW_NO_VRANK_SPLITS
-      PARAMETER (FFTW_NO_VRANK_SPLITS=32768)
-      INTEGER FFTW_NO_VRECURSE
-      PARAMETER (FFTW_NO_VRECURSE=65536)
-      INTEGER FFTW_NO_SIMD
-      PARAMETER (FFTW_NO_SIMD=131072)
+      INTEGER FFTW_R2HC
+      PARAMETER (FFTW_R2HC=0)
+      INTEGER FFTW_HC2R
+      PARAMETER (FFTW_HC2R=1)
+      INTEGER FFTW_DHT
+      PARAMETER (FFTW_DHT=2)
+      INTEGER FFTW_REDFT00
+      PARAMETER (FFTW_REDFT00=3)
+      INTEGER FFTW_REDFT01
+      PARAMETER (FFTW_REDFT01=4)
+      INTEGER FFTW_REDFT10
+      PARAMETER (FFTW_REDFT10=5)
+      INTEGER FFTW_REDFT11
+      PARAMETER (FFTW_REDFT11=6)
+      INTEGER FFTW_RODFT00
+      PARAMETER (FFTW_RODFT00=7)
+      INTEGER FFTW_RODFT01
+      PARAMETER (FFTW_RODFT01=8)
+      INTEGER FFTW_RODFT10
+      PARAMETER (FFTW_RODFT10=9)
+      INTEGER FFTW_RODFT11
+      PARAMETER (FFTW_RODFT11=10)
+      INTEGER FFTW_FORWARD
+      PARAMETER (FFTW_FORWARD=-1)
+      INTEGER FFTW_BACKWARD
+      PARAMETER (FFTW_BACKWARD=+1)
+      INTEGER FFTW_MEASURE
+      PARAMETER (FFTW_MEASURE=0)
+      INTEGER FFTW_DESTROY_INPUT
+      PARAMETER (FFTW_DESTROY_INPUT=1)
+      INTEGER FFTW_UNALIGNED
+      PARAMETER (FFTW_UNALIGNED=2)
+      INTEGER FFTW_CONSERVE_MEMORY
+      PARAMETER (FFTW_CONSERVE_MEMORY=4)
+      INTEGER FFTW_EXHAUSTIVE
+      PARAMETER (FFTW_EXHAUSTIVE=8)
+      INTEGER FFTW_PRESERVE_INPUT
+      PARAMETER (FFTW_PRESERVE_INPUT=16)
+      INTEGER FFTW_PATIENT
+      PARAMETER (FFTW_PATIENT=32)
+      INTEGER FFTW_ESTIMATE
+      PARAMETER (FFTW_ESTIMATE=64)
+      INTEGER FFTW_ESTIMATE_PATIENT
+      PARAMETER (FFTW_ESTIMATE_PATIENT=128)
+      INTEGER FFTW_BELIEVE_PCOST
+      PARAMETER (FFTW_BELIEVE_PCOST=256)
+      INTEGER FFTW_DFT_R2HC_ICKY
+      PARAMETER (FFTW_DFT_R2HC_ICKY=512)
+      INTEGER FFTW_NONTHREADED_ICKY
+      PARAMETER (FFTW_NONTHREADED_ICKY=1024)
+      INTEGER FFTW_NO_BUFFERING
+      PARAMETER (FFTW_NO_BUFFERING=2048)
+      INTEGER FFTW_NO_INDIRECT_OP
+      PARAMETER (FFTW_NO_INDIRECT_OP=4096)
+      INTEGER FFTW_ALLOW_LARGE_GENERIC
+      PARAMETER (FFTW_ALLOW_LARGE_GENERIC=8192)
+      INTEGER FFTW_NO_RANK_SPLITS
+      PARAMETER (FFTW_NO_RANK_SPLITS=16384)
+      INTEGER FFTW_NO_VRANK_SPLITS
+      PARAMETER (FFTW_NO_VRANK_SPLITS=32768)
+      INTEGER FFTW_NO_VRECURSE
+      PARAMETER (FFTW_NO_VRECURSE=65536)
+      INTEGER FFTW_NO_SIMD
+      PARAMETER (FFTW_NO_SIMD=131072)


Property changes on: branches/map65/libm65/fftw3.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/fil6521.f
===================================================================
--- branches/map65/libm65/fil6521.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/fil6521.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,44 +1,44 @@
-      subroutine fil6521(c1,n1,c2,n2)
-
-C  FIR lowpass filter designed using ScopeFIR
-
-C                   Pass #1   Pass #2  
-C-----------------------------------------------
-C  fsample    (Hz)  1378.125   Input sample rate
-C  Ntaps            21         Number of filter taps
-C  fc         (Hz)  40         Cutoff frequency
-C  fstop      (Hz)  172.266    Lower limit of stopband
-C  Ripple     (dB)  0.1        Ripple in passband
-C  Stop Atten (dB)  38         Stopband attenuation
-C  fout       (Hz)  344.531    Output sample rate
-
-      parameter (NTAPS=21)
-      parameter (NH=NTAPS/2)
-      parameter (NDOWN=4)                !Downsample ratio = 1/4
-      complex c1(n1)
-      complex c2(n1/NDOWN)
-
-C  Filter coefficients:
-      real a(-NH:NH)
-      data a/
-     +  -0.011958606980,-0.013888627387,-0.015601306443,-0.010602249570,
-     +   0.003804023436, 0.028320058273, 0.060903935217, 0.096841904411,
-     +   0.129639871228, 0.152644580853, 0.160917511283, 0.152644580853,
-     +   0.129639871228, 0.096841904411, 0.060903935217, 0.028320058273,
-     +   0.003804023436,-0.010602249570,-0.015601306443,-0.013888627387,
-     +  -0.011958606980/
-
-      n2=(n1-NTAPS+NDOWN)/NDOWN
-      k0=NH-NDOWN+1
-
-C  Loop over all output samples
-      do i=1,n2
-         c2(i)=0.
-         k=k0 + NDOWN*i
-         do j=-NH,NH
-            c2(i)=c2(i) + c1(j+k)*a(j)
-         enddo
-      enddo
-
-      return
-      end
+      subroutine fil6521(c1,n1,c2,n2)
+
+C  FIR lowpass filter designed using ScopeFIR
+
+C                   Pass #1   Pass #2  
+C-----------------------------------------------
+C  fsample    (Hz)  1378.125   Input sample rate
+C  Ntaps            21         Number of filter taps
+C  fc         (Hz)  40         Cutoff frequency
+C  fstop      (Hz)  172.266    Lower limit of stopband
+C  Ripple     (dB)  0.1        Ripple in passband
+C  Stop Atten (dB)  38         Stopband attenuation
+C  fout       (Hz)  344.531    Output sample rate
+
+      parameter (NTAPS=21)
+      parameter (NH=NTAPS/2)
+      parameter (NDOWN=4)                !Downsample ratio = 1/4
+      complex c1(n1)
+      complex c2(n1/NDOWN)
+
+C  Filter coefficients:
+      real a(-NH:NH)
+      data a/
+     +  -0.011958606980,-0.013888627387,-0.015601306443,-0.010602249570,
+     +   0.003804023436, 0.028320058273, 0.060903935217, 0.096841904411,
+     +   0.129639871228, 0.152644580853, 0.160917511283, 0.152644580853,
+     +   0.129639871228, 0.096841904411, 0.060903935217, 0.028320058273,
+     +   0.003804023436,-0.010602249570,-0.015601306443,-0.013888627387,
+     +  -0.011958606980/
+
+      n2=(n1-NTAPS+NDOWN)/NDOWN
+      k0=NH-NDOWN+1
+
+C  Loop over all output samples
+      do i=1,n2
+         c2(i)=0.
+         k=k0 + NDOWN*i
+         do j=-NH,NH
+            c2(i)=c2(i) + c1(j+k)*a(j)
+         enddo
+      enddo
+
+      return
+      end


Property changes on: branches/map65/libm65/fil6521.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/filbig.f
===================================================================
--- branches/map65/libm65/filbig.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/filbig.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,134 +1,134 @@
-      subroutine filbig(dd,nmax,f0,newdat,nfsample,xpol,c4a,c4b,n4)
-
-C  Filter and downsample complex data stored in array dd(4,nmax).  
-C  Output is downsampled from 96000 Hz to 1375.125 Hz.
-
-      parameter (MAXFFT1=5376000,MAXFFT2=77175)
-      real*4  dd(4,nmax)                         !Input data
-      complex ca(MAXFFT1),cb(MAXFFT1)            !FFTs of input
-      complex c4a(MAXFFT2),c4b(MAXFFT2)          !Output data
-      real*8 df
-      real halfpulse(8)                 !Impulse response of filter (one sided)
-      complex cfilt(MAXFFT2)                     !Filter (complex; imag = 0)
-      real rfilt(MAXFFT2)                        !Filter (real)
-      integer*8 plan1,plan2,plan3,plan4,plan5
-      logical first,xpol
-      include 'fftw3.f'
-      equivalence (rfilt,cfilt)
-      data first/.true./,npatience/1/
-      data halfpulse/114.97547150,36.57879257,-20.93789101,
-     +  5.89886379,1.59355187,-2.49138308,0.60910773,-0.04248129/
-      save
-
-      nfft1=MAXFFT1
-      nfft2=MAXFFT2
-      if(nfsample.eq.95238) then
-         nfft1=5120000
-         nfft2=74088
-      endif
-      if(nmax.lt.0) go to 900
-      if(first) then
-         nflags=FFTW_ESTIMATE
-         if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
-         if(npatience.eq.2) nflags=FFTW_MEASURE
-         if(npatience.eq.3) nflags=FFTW_PATIENT
-         if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
-C  Plan the FFTs just once
-         call timer('FFTplans ',0)
-         call sfftw_plan_dft_1d(plan1,nfft1,ca,ca,
-     +        FFTW_BACKWARD,nflags)
-         call sfftw_plan_dft_1d(plan2,nfft1,cb,cb,
-     +        FFTW_BACKWARD,nflags)
-         call sfftw_plan_dft_1d(plan3,nfft2,c4a,c4a,
-     +        FFTW_FORWARD,nflags)
-         call sfftw_plan_dft_1d(plan4,nfft2,c4b,c4b,
-     +        FFTW_FORWARD,nflags)
-         call sfftw_plan_dft_1d(plan5,nfft2,cfilt,cfilt,
-     +        FFTW_BACKWARD,nflags)
-         call timer('FFTplans ',1)
-
-C  Convert impulse response to filter function
-         do i=1,nfft2
-            cfilt(i)=0.
-         enddo
-         fac=0.00625/nfft1
-         cfilt(1)=fac*halfpulse(1)
-         do i=2,8
-            cfilt(i)=fac*halfpulse(i)
-            cfilt(nfft2+2-i)=fac*halfpulse(i)
-         enddo
-         call timer('FFTfilt ',0)
-         call sfftw_execute(plan5)
-         call timer('FFTfilt ',1)
-
-         base=cfilt(nfft2/2+1)
-         do i=1,nfft2
-            rfilt(i)=real(cfilt(i))-base
-         enddo
-
-         df=96000.d0/nfft1
-         if(nfsample.eq.95238) df=95238.1d0/nfft1
-         first=.false.
-      endif
-
-C  When new data comes along, we need to compute a new &quot;big FFT&quot;
-C  If we just have a new f0, continue with the existing ca and cb.
-
-      if(newdat.ne.0) then
-         nz=min(nmax,nfft1)
-         do i=1,nz
-            ca(i)=cmplx(dd(1,i),dd(2,i))
-            if(xpol) cb(i)=cmplx(dd(3,i),dd(4,i))
-         enddo
-
-         if(nmax.lt.nfft1) then
-            do i=nmax+1,nfft1
-               ca(i)=0.
-               if(xpol) cb(i)=0.
-            enddo
-         endif
-         call timer('FFTbig  ',0)
-         call sfftw_execute(plan1)
-         if(xpol) call sfftw_execute(plan2)
-         call timer('FFTbig  ',1)
-         newdat=0
-      endif
-
-C  NB: f0 is the frequency at which we want our filter centered.
-C      i0 is the bin number in ca and cb closest to f0.
-
-      i0=nint(f0/df) + 1
-      nh=nfft2/2
-      do i=1,nh                                !Copy data into c4a and c4b,
-         j=i0+i-1                              !and apply the filter function
-         if(j.ge.1 .and. j.le.nfft1) then
-            c4a(i)=rfilt(i)*ca(j)
-            if(xpol) c4b(i)=rfilt(i)*cb(j)
-         else
-            c4a(i)=0.
-            if(xpol) c4b(i)=0.
-         endif
-      enddo
-      do i=nh+1,nfft2
-         j=i0+i-1-nfft2
-         if(j.lt.1) j=j+nfft1                  !nfft1 was nfft2
-         c4a(i)=rfilt(i)*ca(j)
-         if(xpol) c4b(i)=rfilt(i)*cb(j)
-      enddo
-
-C  Do the short reverse transform, to go back to time domain.
-      call timer('FFTsmall',0)
-      call sfftw_execute(plan3)
-      if(xpol) call sfftw_execute(plan4)
-      call timer('FFTsmall',1)
-      n4=min(nmax/64,nfft2)
-      go to 999
-
- 900  call sfftw_destroy_plan(plan1)
-      call sfftw_destroy_plan(plan2)
-      call sfftw_destroy_plan(plan3)
-      call sfftw_destroy_plan(plan4)
-      call sfftw_destroy_plan(plan5)
-
- 999  return
-      end
+      subroutine filbig(dd,nmax,f0,newdat,nfsample,xpol,c4a,c4b,n4)
+
+C  Filter and downsample complex data stored in array dd(4,nmax).  
+C  Output is downsampled from 96000 Hz to 1375.125 Hz.
+
+      parameter (MAXFFT1=5376000,MAXFFT2=77175)
+      real*4  dd(4,nmax)                         !Input data
+      complex ca(MAXFFT1),cb(MAXFFT1)            !FFTs of input
+      complex c4a(MAXFFT2),c4b(MAXFFT2)          !Output data
+      real*8 df
+      real halfpulse(8)                 !Impulse response of filter (one sided)
+      complex cfilt(MAXFFT2)                     !Filter (complex; imag = 0)
+      real rfilt(MAXFFT2)                        !Filter (real)
+      integer*8 plan1,plan2,plan3,plan4,plan5
+      logical first,xpol
+      include 'fftw3.f'
+      equivalence (rfilt,cfilt)
+      data first/.true./,npatience/1/
+      data halfpulse/114.97547150,36.57879257,-20.93789101,
+     +  5.89886379,1.59355187,-2.49138308,0.60910773,-0.04248129/
+      save
+
+      nfft1=MAXFFT1
+      nfft2=MAXFFT2
+      if(nfsample.eq.95238) then
+         nfft1=5120000
+         nfft2=74088
+      endif
+      if(nmax.lt.0) go to 900
+      if(first) then
+         nflags=FFTW_ESTIMATE
+         if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
+         if(npatience.eq.2) nflags=FFTW_MEASURE
+         if(npatience.eq.3) nflags=FFTW_PATIENT
+         if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
+C  Plan the FFTs just once
+         call timer('FFTplans ',0)
+         call sfftw_plan_dft_1d(plan1,nfft1,ca,ca,
+     +        FFTW_BACKWARD,nflags)
+         call sfftw_plan_dft_1d(plan2,nfft1,cb,cb,
+     +        FFTW_BACKWARD,nflags)
+         call sfftw_plan_dft_1d(plan3,nfft2,c4a,c4a,
+     +        FFTW_FORWARD,nflags)
+         call sfftw_plan_dft_1d(plan4,nfft2,c4b,c4b,
+     +        FFTW_FORWARD,nflags)
+         call sfftw_plan_dft_1d(plan5,nfft2,cfilt,cfilt,
+     +        FFTW_BACKWARD,nflags)
+         call timer('FFTplans ',1)
+
+C  Convert impulse response to filter function
+         do i=1,nfft2
+            cfilt(i)=0.
+         enddo
+         fac=0.00625/nfft1
+         cfilt(1)=fac*halfpulse(1)
+         do i=2,8
+            cfilt(i)=fac*halfpulse(i)
+            cfilt(nfft2+2-i)=fac*halfpulse(i)
+         enddo
+         call timer('FFTfilt ',0)
+         call sfftw_execute(plan5)
+         call timer('FFTfilt ',1)
+
+         base=cfilt(nfft2/2+1)
+         do i=1,nfft2
+            rfilt(i)=real(cfilt(i))-base
+         enddo
+
+         df=96000.d0/nfft1
+         if(nfsample.eq.95238) df=95238.1d0/nfft1
+         first=.false.
+      endif
+
+C  When new data comes along, we need to compute a new &quot;big FFT&quot;
+C  If we just have a new f0, continue with the existing ca and cb.
+
+      if(newdat.ne.0) then
+         nz=min(nmax,nfft1)
+         do i=1,nz
+            ca(i)=cmplx(dd(1,i),dd(2,i))
+            if(xpol) cb(i)=cmplx(dd(3,i),dd(4,i))
+         enddo
+
+         if(nmax.lt.nfft1) then
+            do i=nmax+1,nfft1
+               ca(i)=0.
+               if(xpol) cb(i)=0.
+            enddo
+         endif
+         call timer('FFTbig  ',0)
+         call sfftw_execute(plan1)
+         if(xpol) call sfftw_execute(plan2)
+         call timer('FFTbig  ',1)
+         newdat=0
+      endif
+
+C  NB: f0 is the frequency at which we want our filter centered.
+C      i0 is the bin number in ca and cb closest to f0.
+
+      i0=nint(f0/df) + 1
+      nh=nfft2/2
+      do i=1,nh                                !Copy data into c4a and c4b,
+         j=i0+i-1                              !and apply the filter function
+         if(j.ge.1 .and. j.le.nfft1) then
+            c4a(i)=rfilt(i)*ca(j)
+            if(xpol) c4b(i)=rfilt(i)*cb(j)
+         else
+            c4a(i)=0.
+            if(xpol) c4b(i)=0.
+         endif
+      enddo
+      do i=nh+1,nfft2
+         j=i0+i-1-nfft2
+         if(j.lt.1) j=j+nfft1                  !nfft1 was nfft2
+         c4a(i)=rfilt(i)*ca(j)
+         if(xpol) c4b(i)=rfilt(i)*cb(j)
+      enddo
+
+C  Do the short reverse transform, to go back to time domain.
+      call timer('FFTsmall',0)
+      call sfftw_execute(plan3)
+      if(xpol) call sfftw_execute(plan4)
+      call timer('FFTsmall',1)
+      n4=min(nmax/64,nfft2)
+      go to 999
+
+ 900  call sfftw_destroy_plan(plan1)
+      call sfftw_destroy_plan(plan2)
+      call sfftw_destroy_plan(plan3)
+      call sfftw_destroy_plan(plan4)
+      call sfftw_destroy_plan(plan5)
+
+ 999  return
+      end


Property changes on: branches/map65/libm65/filbig.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/four2a.f90
===================================================================
--- branches/map65/libm65/four2a.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/four2a.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,89 +1,89 @@
-subroutine four2a(a,nfft,ndim,isign,iform)
-
-!     IFORM = 1, 0 or -1, as data is
-!     complex, real, or the first half of a complex array.  Transform
-!     values are returned in array DATA.  They are complex, real, or
-!     the first half of a complex array, as IFORM = 1, -1 or 0.
-
-!     The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
-!     by ... will be returned in the same array, now considered to
-!     be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
-!     IFORM = 0 or -1, N(1) must be even, and enough room must be
-!     reserved.  The missing values may be obtained by complex conjugation.  
-
-!     The reverse transformation of a half complex array dimensioned
-!     N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
-!     to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
-!     The transform will be real and returned to the input array.
-
-  parameter (NPMAX=100)
-  parameter (NSMALL=16384)
-  complex a(nfft)
-  complex aa(NSMALL)
-  integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
-  integer*8 plan(NPMAX)             !Actually should be i*8, but no matter
-  data nplan/0/,npatience/1/
-  include 'fftw3.f'
-  save plan,nplan,nn,ns,nf,nl
-
-  if(nfft.lt.0) go to 999
-
-  nloc=loc(a)
-  do i=1,nplan
-     if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.                     &amp;
-          iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
-  enddo
-  if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
-  nplan=nplan+1
-  i=nplan
-  nn(i)=nfft
-  ns(i)=isign
-  nf(i)=iform
-  nl(i)=nloc
-
-! Planning: FFTW_ESTIMATE, FFTW_ESTIMATE_PATIENT, FFTW_MEASURE, 
-!            FFTW_PATIENT,  FFTW_EXHAUSTIVE
-  nflags=FFTW_ESTIMATE
-  if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
-  if(npatience.eq.2) nflags=FFTW_MEASURE
-  if(npatience.eq.3) nflags=FFTW_PATIENT
-  if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
-
-  if(nfft.le.NSMALL) then
-     jz=nfft
-     if(iform.eq.0) jz=nfft/2
-     do j=1,jz
-        aa(j)=a(j)
-     enddo
-  endif
-  if(isign.eq.-1 .and. iform.eq.1) then
-     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_FORWARD,nflags)
-  else if(isign.eq.1 .and. iform.eq.1) then
-     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_BACKWARD,nflags)
-  else if(isign.eq.-1 .and. iform.eq.0) then
-     call sfftw_plan_dft_r2c_1d(plan(i),nfft,a,a,nflags)
-  else if(isign.eq.1 .and. iform.eq.-1) then
-     call sfftw_plan_dft_c2r_1d(plan(i),nfft,a,a,nflags)
-  else
-     stop 'Unsupported request in four2a'
-  endif
-  i=nplan
-  if(nfft.le.NSMALL) then
-     jz=nfft
-     if(iform.eq.0) jz=nfft/2
-     do j=1,jz
-        a(j)=aa(j)
-     enddo
-  endif
-
-10 continue
-  call sfftw_execute(plan(i))
-  return
-
-999 do i=1,nplan
-! The test is only to silence a compiler warning:
-     if(ndim.ne.-999) call sfftw_destroy_plan(plan(i))
-  enddo
-
-  return
-end subroutine four2a
+subroutine four2a(a,nfft,ndim,isign,iform)
+
+!     IFORM = 1, 0 or -1, as data is
+!     complex, real, or the first half of a complex array.  Transform
+!     values are returned in array DATA.  They are complex, real, or
+!     the first half of a complex array, as IFORM = 1, -1 or 0.
+
+!     The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
+!     by ... will be returned in the same array, now considered to
+!     be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
+!     IFORM = 0 or -1, N(1) must be even, and enough room must be
+!     reserved.  The missing values may be obtained by complex conjugation.  
+
+!     The reverse transformation of a half complex array dimensioned
+!     N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
+!     to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
+!     The transform will be real and returned to the input array.
+
+  parameter (NPMAX=100)
+  parameter (NSMALL=16384)
+  complex a(nfft)
+  complex aa(NSMALL)
+  integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
+  integer*8 plan(NPMAX)             !Actually should be i*8, but no matter
+  data nplan/0/,npatience/1/
+  include 'fftw3.f'
+  save plan,nplan,nn,ns,nf,nl
+
+  if(nfft.lt.0) go to 999
+
+  nloc=loc(a)
+  do i=1,nplan
+     if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.                     &amp;
+          iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
+  enddo
+  if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
+  nplan=nplan+1
+  i=nplan
+  nn(i)=nfft
+  ns(i)=isign
+  nf(i)=iform
+  nl(i)=nloc
+
+! Planning: FFTW_ESTIMATE, FFTW_ESTIMATE_PATIENT, FFTW_MEASURE, 
+!            FFTW_PATIENT,  FFTW_EXHAUSTIVE
+  nflags=FFTW_ESTIMATE
+  if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
+  if(npatience.eq.2) nflags=FFTW_MEASURE
+  if(npatience.eq.3) nflags=FFTW_PATIENT
+  if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
+
+  if(nfft.le.NSMALL) then
+     jz=nfft
+     if(iform.eq.0) jz=nfft/2
+     do j=1,jz
+        aa(j)=a(j)
+     enddo
+  endif
+  if(isign.eq.-1 .and. iform.eq.1) then
+     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_FORWARD,nflags)
+  else if(isign.eq.1 .and. iform.eq.1) then
+     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_BACKWARD,nflags)
+  else if(isign.eq.-1 .and. iform.eq.0) then
+     call sfftw_plan_dft_r2c_1d(plan(i),nfft,a,a,nflags)
+  else if(isign.eq.1 .and. iform.eq.-1) then
+     call sfftw_plan_dft_c2r_1d(plan(i),nfft,a,a,nflags)
+  else
+     stop 'Unsupported request in four2a'
+  endif
+  i=nplan
+  if(nfft.le.NSMALL) then
+     jz=nfft
+     if(iform.eq.0) jz=nfft/2
+     do j=1,jz
+        a(j)=aa(j)
+     enddo
+  endif
+
+10 continue
+  call sfftw_execute(plan(i))
+  return
+
+999 do i=1,nplan
+! The test is only to silence a compiler warning:
+     if(ndim.ne.-999) call sfftw_destroy_plan(plan(i))
+  enddo
+
+  return
+end subroutine four2a


Property changes on: branches/map65/libm65/four2a.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/ftninit.f90
===================================================================
--- branches/map65/libm65/ftninit.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/ftninit.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,63 +1,63 @@
-! Fortran logical units used in WSJT6
-!
-!   10  binary input data, *.tf2 files
-!   11  prefixes.txt
-!   12  timer.out
-!   13  map65.log
-!   14  
-!   15  
-!   16
-!   17  saved *.tf2 files
-!   18  test file to be transmitted (wsjtgen.f90)
-!   19  livecq.txt
-!   20  
-!   21  map65_rx.log
-!   22  kvasd.dat
-!   23  CALL3.TXT
-!   24  
-!   25  
-!   26  tmp26.txt
-!   27  
-!   28  fftw_wisdom.dat
-!------------------------------------------------ ftn_init
-subroutine ftninit(appd)
-
-  character*(*) appd
-  character cjunk*1,firstline*30
-  character addpfx*8
-  integer junk(256)
-  common/pfxcom/addpfx
-
-  addpfx='    '
-  call pfxdump(appd//'/prefixes.txt')
-  open(12,file=appd//'/timer.out',status='unknown',err=920)
-  open(13,file=appd//'/map65.log',status='unknown')
-  open(19,file=appd//'/livecq.txt',status='unknown')
-  open(21,file=appd//'/map65_rx.log',status='unknown',access='append',err=950)
-  open(22,file=appd//'/kvasd.dat',access='direct',recl=1024,status='unknown')
-  read(22,rec=2,err=12) junk
-  go to 18
-12 junk=0
-  write(22,rec=1) junk
-  write(22,rec=2) junk
-
-18  open(26,file=appd//'/tmp26.txt',status='unknown')
-
-! Import FFTW wisdom, if available:
-  open(28,file=appd//'/fftwf_wisdom.dat',status='old',err=30)
-  read(28,1000,err=30,end=30) firstline
-1000 format(a30)
-  rewind 28
-  call import_wisdom_from_file(isuccess,28)
-  close(28)
-  if(isuccess.ne.0) write(13,1010) firstline
-1010 format('Imported FFTW wisdom: ',a30)
-
-30  return
-
-920 write(0,*) '!Error opening timer.out'
-  stop
-950 write(0,*) '!Error opening ALL65.TXT'
-  stop
-
-end subroutine ftninit
+! Fortran logical units used in WSJT6
+!
+!   10  binary input data, *.tf2 files
+!   11  prefixes.txt
+!   12  timer.out
+!   13  map65.log
+!   14  
+!   15  
+!   16
+!   17  saved *.tf2 files
+!   18  test file to be transmitted (wsjtgen.f90)
+!   19  livecq.txt
+!   20  
+!   21  map65_rx.log
+!   22  kvasd.dat
+!   23  CALL3.TXT
+!   24  
+!   25  
+!   26  tmp26.txt
+!   27  
+!   28  fftw_wisdom.dat
+!------------------------------------------------ ftn_init
+subroutine ftninit(appd)
+
+  character*(*) appd
+  character cjunk*1,firstline*30
+  character addpfx*8
+  integer junk(256)
+  common/pfxcom/addpfx
+
+  addpfx='    '
+  call pfxdump(appd//'/prefixes.txt')
+  open(12,file=appd//'/timer.out',status='unknown',err=920)
+  open(13,file=appd//'/map65.log',status='unknown')
+  open(19,file=appd//'/livecq.txt',status='unknown')
+  open(21,file=appd//'/map65_rx.log',status='unknown',access='append',err=950)
+  open(22,file=appd//'/kvasd.dat',access='direct',recl=1024,status='unknown')
+  read(22,rec=2,err=12) junk
+  go to 18
+12 junk=0
+  write(22,rec=1) junk
+  write(22,rec=2) junk
+
+18  open(26,file=appd//'/tmp26.txt',status='unknown')
+
+! Import FFTW wisdom, if available:
+  open(28,file=appd//'/fftwf_wisdom.dat',status='old',err=30)
+  read(28,1000,err=30,end=30) firstline
+1000 format(a30)
+  rewind 28
+  call import_wisdom_from_file(isuccess,28)
+  close(28)
+  if(isuccess.ne.0) write(13,1010) firstline
+1010 format('Imported FFTW wisdom: ',a30)
+
+30  return
+
+920 write(0,*) '!Error opening timer.out'
+  stop
+950 write(0,*) '!Error opening ALL65.TXT'
+  stop
+
+end subroutine ftninit


Property changes on: branches/map65/libm65/ftninit.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/ftnquit.f90
===================================================================
--- branches/map65/libm65/ftnquit.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/ftnquit.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,9 +1,9 @@
-subroutine ftnquit
-
-! Destroy the FFTW plans
-  call four2a(a,-1,1,1,1)
-  call filbig(id,-1,f0,newdat,nfsample,c4a,c4b,n4)
-  stop
-
-  return
-end subroutine ftnquit
+subroutine ftnquit
+
+! Destroy the FFTW plans
+  call four2a(a,-1,1,1,1)
+  call filbig(id,-1,f0,newdat,nfsample,c4a,c4b,n4)
+  stop
+
+  return
+end subroutine ftnquit


Property changes on: branches/map65/libm65/ftnquit.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/gen65.f90
===================================================================
--- branches/map65/libm65/gen65.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/gen65.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,93 +1,93 @@
-subroutine gen65(message,mode65,samfac,nsendingsh,msgsent,iwave,nwave)
-
-! Encodes a JT65 message into a wavefile.  
-! Executes in 17 ms on opti-745.
-
-  parameter (NMAX=60*11025)     !Max length of wave file
-  character*22 message          !Message to be generated
-  character*22 msgsent          !Message as it will be received
-  character*3 cok               !'   ' or 'OOO'
-  real*8 dt,phi,f,f0,dfgen,dphi,twopi,samfac
-  integer*2 iwave(NMAX)         !Generated wave file
-  integer dgen(12)
-  integer sent(63)
-  logical first
-  integer nprc(126)
-  real pr(126)
-  data nprc/1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,  &amp;
-            0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,  &amp;
-            0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,  &amp;
-            0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,  &amp;
-            1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,  &amp;
-            0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,  &amp;
-            1,1,1,1,1,1/
-  data twopi/6.283185307179586476d0/,first/.true./
-  save
-
-  if(first) then
-     do i=1,126
-        pr(i)=2*nprc(i)-1
-     enddo
-     first=.false.
-  endif
-
-  call chkmsg(message,cok,nspecial,flip)
-  if(nspecial.eq.0) then
-     call packmsg(message,dgen)          !Pack message into 72 bits
-     nsendingsh=0
-     if(iand(dgen(10),8).ne.0) nsendingsh=-1    !Plain text flag
-
-     call rs_encode(dgen,sent)
-     call interleave63(sent,1)           !Apply interleaving
-     call graycode(sent,63,1)            !Apply Gray code
-     nsym=126                            !Symbols per transmission
-     nsps=4096
-  else
-     nsym=32
-     nsps=16384
-     nsendingsh=1                         !Flag for shorthand message
-  endif
-  if(mode65.eq.0) go to 900
-
-! Set up necessary constants
-  dt=1.d0/(samfac*11025.d0)
-  f0=118*11025.d0/1024
-  dfgen=mode65*11025.d0/4096.d0
-  phi=0.d0
-  i=0
-  k=0
-  do j=1,nsym
-     f=f0
-     if(nspecial.ne.0 .and. mod(j,2).eq.0) f=f0+10*nspecial*dfgen
-     if(nspecial.eq.0 .and. flip*pr(j).lt.0.0) then
-        k=k+1
-        f=f0+(sent(k)+2)*dfgen
-     endif
-     dphi=twopi*dt*f
-     do ii=1,nsps
-        phi=phi+dphi
-        if(phi.gt.twopi) phi=phi-twopi
-        xphi=phi
-        i=i+1
-        iwave(i)=32767.0*sin(xphi)
-     enddo
-  enddo
-
-  iwave(nsym*nsps+1:)=0
-  nwave=nsym*nsps + 5512
-  call unpackmsg(dgen,msgsent)
-  if(flip.lt.0.0) then
-     do i=22,1,-1
-        if(msgsent(i:i).ne.' ') goto 10
-     enddo
-10   msgsent=msgsent(1:i)//' OOO'
-  endif
-
-  if(nsendingsh.eq.1) then
-     if(nspecial.eq.2) msgsent='RO'
-     if(nspecial.eq.3) msgsent='RRR'
-     if(nspecial.eq.4) msgsent='73'
-  endif
-
-900 return
-end subroutine gen65
+subroutine gen65(message,mode65,samfac,nsendingsh,msgsent,iwave,nwave)
+
+! Encodes a JT65 message into a wavefile.  
+! Executes in 17 ms on opti-745.
+
+  parameter (NMAX=60*11025)     !Max length of wave file
+  character*22 message          !Message to be generated
+  character*22 msgsent          !Message as it will be received
+  character*3 cok               !'   ' or 'OOO'
+  real*8 dt,phi,f,f0,dfgen,dphi,twopi,samfac
+  integer*2 iwave(NMAX)         !Generated wave file
+  integer dgen(12)
+  integer sent(63)
+  logical first
+  integer nprc(126)
+  real pr(126)
+  data nprc/1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,  &amp;
+            0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,  &amp;
+            0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,  &amp;
+            0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,  &amp;
+            1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,  &amp;
+            0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,  &amp;
+            1,1,1,1,1,1/
+  data twopi/6.283185307179586476d0/,first/.true./
+  save
+
+  if(first) then
+     do i=1,126
+        pr(i)=2*nprc(i)-1
+     enddo
+     first=.false.
+  endif
+
+  call chkmsg(message,cok,nspecial,flip)
+  if(nspecial.eq.0) then
+     call packmsg(message,dgen)          !Pack message into 72 bits
+     nsendingsh=0
+     if(iand(dgen(10),8).ne.0) nsendingsh=-1    !Plain text flag
+
+     call rs_encode(dgen,sent)
+     call interleave63(sent,1)           !Apply interleaving
+     call graycode(sent,63,1)            !Apply Gray code
+     nsym=126                            !Symbols per transmission
+     nsps=4096
+  else
+     nsym=32
+     nsps=16384
+     nsendingsh=1                         !Flag for shorthand message
+  endif
+  if(mode65.eq.0) go to 900
+
+! Set up necessary constants
+  dt=1.d0/(samfac*11025.d0)
+  f0=118*11025.d0/1024
+  dfgen=mode65*11025.d0/4096.d0
+  phi=0.d0
+  i=0
+  k=0
+  do j=1,nsym
+     f=f0
+     if(nspecial.ne.0 .and. mod(j,2).eq.0) f=f0+10*nspecial*dfgen
+     if(nspecial.eq.0 .and. flip*pr(j).lt.0.0) then
+        k=k+1
+        f=f0+(sent(k)+2)*dfgen
+     endif
+     dphi=twopi*dt*f
+     do ii=1,nsps
+        phi=phi+dphi
+        if(phi.gt.twopi) phi=phi-twopi
+        xphi=phi
+        i=i+1
+        iwave(i)=32767.0*sin(xphi)
+     enddo
+  enddo
+
+  iwave(nsym*nsps+1:)=0
+  nwave=nsym*nsps + 5512
+  call unpackmsg(dgen,msgsent)
+  if(flip.lt.0.0) then
+     do i=22,1,-1
+        if(msgsent(i:i).ne.' ') goto 10
+     enddo
+10   msgsent=msgsent(1:i)//' OOO'
+  endif
+
+  if(nsendingsh.eq.1) then
+     if(nspecial.eq.2) msgsent='RO'
+     if(nspecial.eq.3) msgsent='RRR'
+     if(nspecial.eq.4) msgsent='73'
+  endif
+
+900 return
+end subroutine gen65


Property changes on: branches/map65/libm65/gen65.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/geocentric.f
===================================================================
--- branches/map65/libm65/geocentric.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/geocentric.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,17 +1,17 @@
-      subroutine geocentric(alat,elev,hlt,erad)
-
-      implicit real*8 (a-h,o-z)
-
-C  IAU 1976 flattening f, equatorial radius a
-      f = 1.d0/298.257d0
-      a = 6378140.d0
-      c = 1.d0/sqrt(1.d0 + (-2.d0 + f)*f*sin(alat)*sin(alat))
-      arcf = (a*c + elev)*cos(alat)
-      arsf = (a*(1.d0 - f)*(1.d0 - f)*c + elev)*sin(alat)
-      hlt = datan2(arsf,arcf)
-      erad = sqrt(arcf*arcf + arsf*arsf)
-      erad = 0.001d0*erad
-
-      return
-      end
-
+      subroutine geocentric(alat,elev,hlt,erad)
+
+      implicit real*8 (a-h,o-z)
+
+C  IAU 1976 flattening f, equatorial radius a
+      f = 1.d0/298.257d0
+      a = 6378140.d0
+      c = 1.d0/sqrt(1.d0 + (-2.d0 + f)*f*sin(alat)*sin(alat))
+      arcf = (a*c + elev)*cos(alat)
+      arsf = (a*(1.d0 - f)*(1.d0 - f)*c + elev)*sin(alat)
+      hlt = datan2(arsf,arcf)
+      erad = sqrt(arcf*arcf + arsf*arsf)
+      erad = 0.001d0*erad
+
+      return
+      end
+


Property changes on: branches/map65/libm65/geocentric.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/getdphi.f90
===================================================================
--- branches/map65/libm65/getdphi.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/getdphi.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,18 +1,18 @@
-subroutine getdphi(qphi)
-
-  real qphi(12)
-
-  s=0.
-  c=0.
-  do i=1,12
-     th=i*30/57.2957795
-     s=s+qphi(i)*sin(th)
-     c=c+qphi(i)*cos(th)
-  enddo
-
-  dphi=57.2957795*atan2(s,c)
-  write(*,1010) nint(dphi)
-1010 format('!Best-fit Dphi =',i4,' deg')
-
-  return
-  end
+subroutine getdphi(qphi)
+
+  real qphi(12)
+
+  s=0.
+  c=0.
+  do i=1,12
+     th=i*30/57.2957795
+     s=s+qphi(i)*sin(th)
+     c=c+qphi(i)*cos(th)
+  enddo
+
+  dphi=57.2957795*atan2(s,c)
+  write(*,1010) nint(dphi)
+1010 format('!Best-fit Dphi =',i4,' deg')
+
+  return
+  end


Property changes on: branches/map65/libm65/getdphi.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/getpfx1.f
===================================================================
--- branches/map65/libm65/getpfx1.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/getpfx1.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,96 +1,96 @@
-      subroutine getpfx1(callsign,k,nv2)
-
-      character*12 callsign0,callsign,lof,rof
-      character*8 c
-      character addpfx*8,tpfx*4,tsfx*3
-      logical ispfx,issfx,invalid
-      common/pfxcom/addpfx
-      include 'pfx.f'
-
-      callsign0=callsign
-      nv2=0
-      iz=index(callsign,' ') - 1
-      if(iz.lt.0) iz=12
-      islash=index(callsign(1:iz),'/')
-      k=0
-      c='   '
-      if(islash.gt.0 .and. islash.le.(iz-4)) then
-!  Add-on prefix
-         c=callsign(1:islash-1)
-         callsign=callsign(islash+1:iz)
-         do i=1,NZ
-            if(pfx(i)(1:4).eq.c) then
-               k=i
-               go to 10
-            endif
-         enddo
-         if(addpfx.eq.c) then
-            k=449
-            go to 10
-         endif
-
-      else if(islash.eq.(iz-1)) then
-!  Add-on suffix
-         c=callsign(islash+1:iz)
-         callsign=callsign(1:islash-1)
-         do i=1,NZ2
-            if(sfx(i).eq.c(1:1)) then
-               k=400+i
-               go to 10
-            endif
-         enddo
-      endif
-
- 10   if(islash.ne.0 .and.k.eq.0) then
-!  Original JT65 would force this compound callsign to be treated as
-!  plain text.  In JT65v2, we will encode the prefix or suffix into nc1.
-!  The task here is to compute the proper value of k.
-         lof=callsign0(:islash-1)
-         rof=callsign0(islash+1:)
-         llof=len_trim(lof)
-         lrof=len_trim(rof)
-         ispfx=(llof.gt.0 .and. llof.le.4)
-         issfx=(lrof.gt.0 .and. lrof.le.3)
-         invalid=.not.(ispfx.or.issfx)
-         if(ispfx.and.issfx) then
-            if(llof.lt.3) issfx=.false.
-            if(lrof.lt.3) ispfx=.false.
-            if(ispfx.and.issfx) then
-               i=ichar(callsign0(islash-1:islash-1))
-               if(i.ge.ichar('0') .and. i.le.ichar('9')) then
-                  issfx=.false.
-               else
-                  ispfx=.false.
-               endif
-            endif
-         endif
-
-         if(invalid) then
-            k=-1
-         else
-            if(ispfx) then
-               tpfx=lof
-               k=nchar(tpfx(1:1))
-               k=37*k + nchar(tpfx(2:2))
-               k=37*k + nchar(tpfx(3:3))
-               k=37*k + nchar(tpfx(4:4))
-               nv2=1
-               i=index(callsign0,'/')
-               callsign=callsign0(:i-1)
-               callsign=callsign0(i+1:)
-            endif
-            if(issfx) then
-               tsfx=rof
-               k=nchar(tsfx(1:1))
-               k=37*k + nchar(tsfx(2:2))
-               k=37*k + nchar(tsfx(3:3))
-               nv2=2
-               i=index(callsign0,'/')
-               callsign=callsign0(:i-1)
-            endif
-         endif
-      endif
-
-      return
-      end
-
+      subroutine getpfx1(callsign,k,nv2)
+
+      character*12 callsign0,callsign,lof,rof
+      character*8 c
+      character addpfx*8,tpfx*4,tsfx*3
+      logical ispfx,issfx,invalid
+      common/pfxcom/addpfx
+      include 'pfx.f'
+
+      callsign0=callsign
+      nv2=0
+      iz=index(callsign,' ') - 1
+      if(iz.lt.0) iz=12
+      islash=index(callsign(1:iz),'/')
+      k=0
+      c='   '
+      if(islash.gt.0 .and. islash.le.(iz-4)) then
+!  Add-on prefix
+         c=callsign(1:islash-1)
+         callsign=callsign(islash+1:iz)
+         do i=1,NZ
+            if(pfx(i)(1:4).eq.c) then
+               k=i
+               go to 10
+            endif
+         enddo
+         if(addpfx.eq.c) then
+            k=449
+            go to 10
+         endif
+
+      else if(islash.eq.(iz-1)) then
+!  Add-on suffix
+         c=callsign(islash+1:iz)
+         callsign=callsign(1:islash-1)
+         do i=1,NZ2
+            if(sfx(i).eq.c(1:1)) then
+               k=400+i
+               go to 10
+            endif
+         enddo
+      endif
+
+ 10   if(islash.ne.0 .and.k.eq.0) then
+!  Original JT65 would force this compound callsign to be treated as
+!  plain text.  In JT65v2, we will encode the prefix or suffix into nc1.
+!  The task here is to compute the proper value of k.
+         lof=callsign0(:islash-1)
+         rof=callsign0(islash+1:)
+         llof=len_trim(lof)
+         lrof=len_trim(rof)
+         ispfx=(llof.gt.0 .and. llof.le.4)
+         issfx=(lrof.gt.0 .and. lrof.le.3)
+         invalid=.not.(ispfx.or.issfx)
+         if(ispfx.and.issfx) then
+            if(llof.lt.3) issfx=.false.
+            if(lrof.lt.3) ispfx=.false.
+            if(ispfx.and.issfx) then
+               i=ichar(callsign0(islash-1:islash-1))
+               if(i.ge.ichar('0') .and. i.le.ichar('9')) then
+                  issfx=.false.
+               else
+                  ispfx=.false.
+               endif
+            endif
+         endif
+
+         if(invalid) then
+            k=-1
+         else
+            if(ispfx) then
+               tpfx=lof
+               k=nchar(tpfx(1:1))
+               k=37*k + nchar(tpfx(2:2))
+               k=37*k + nchar(tpfx(3:3))
+               k=37*k + nchar(tpfx(4:4))
+               nv2=1
+               i=index(callsign0,'/')
+               callsign=callsign0(:i-1)
+               callsign=callsign0(i+1:)
+            endif
+            if(issfx) then
+               tsfx=rof
+               k=nchar(tsfx(1:1))
+               k=37*k + nchar(tsfx(2:2))
+               k=37*k + nchar(tsfx(3:3))
+               nv2=2
+               i=index(callsign0,'/')
+               callsign=callsign0(:i-1)
+            endif
+         endif
+      endif
+
+      return
+      end
+


Property changes on: branches/map65/libm65/getpfx1.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/getpfx2.f
===================================================================
--- branches/map65/libm65/getpfx2.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/getpfx2.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,24 +1,24 @@
-      subroutine getpfx2(k0,callsign)
-
-      character callsign*12
-      include 'pfx.f'
-      character addpfx*8
-      common/pfxcom/addpfx
-
-      k=k0
-      if(k.gt.450) k=k-450
-      if(k.ge.1 .and. k.le.NZ) then
-         iz=index(pfx(k),' ') - 1
-         callsign=pfx(k)(1:iz)//'/'//callsign
-      else if(k.ge.401 .and. k.le.400+NZ2) then
-         iz=index(callsign,' ') - 1
-         callsign=callsign(1:iz)//'/'//sfx(k-400)
-      else if(k.eq.449) then
-         iz=index(addpfx,' ') - 1
-         if(iz.lt.1) iz=8
-         callsign=addpfx(1:iz)//'/'//callsign
-      endif
-
-      return
-      end
-
+      subroutine getpfx2(k0,callsign)
+
+      character callsign*12
+      include 'pfx.f'
+      character addpfx*8
+      common/pfxcom/addpfx
+
+      k=k0
+      if(k.gt.450) k=k-450
+      if(k.ge.1 .and. k.le.NZ) then
+         iz=index(pfx(k),' ') - 1
+         callsign=pfx(k)(1:iz)//'/'//callsign
+      else if(k.ge.401 .and. k.le.400+NZ2) then
+         iz=index(callsign,' ') - 1
+         callsign=callsign(1:iz)//'/'//sfx(k-400)
+      else if(k.eq.449) then
+         iz=index(addpfx,' ') - 1
+         if(iz.lt.1) iz=8
+         callsign=addpfx(1:iz)//'/'//callsign
+      endif
+
+      return
+      end
+


Property changes on: branches/map65/libm65/getpfx2.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/graycode.f
===================================================================
--- branches/map65/libm65/graycode.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/graycode.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,10 +1,10 @@
-      subroutine graycode(dat,n,idir)
-
-      integer dat(n)
-      do i=1,n
-         dat(i)=igray(dat(i),idir)
-      enddo
-
-      return
-      end
-
+      subroutine graycode(dat,n,idir)
+
+      integer dat(n)
+      do i=1,n
+         dat(i)=igray(dat(i),idir)
+      enddo
+
+      return
+      end
+


Property changes on: branches/map65/libm65/graycode.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/grid2deg.f
===================================================================
--- branches/map65/libm65/grid2deg.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/grid2deg.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,38 +1,38 @@
-      subroutine grid2deg(grid0,dlong,dlat)
-
-C  Converts Maidenhead grid locator to degrees of West longitude
-C  and North latitude.
-
-      character*6 grid0,grid
-      character*1 g1,g2,g3,g4,g5,g6
-
-      grid=grid0
-      i=ichar(grid(5:5))
-      if(grid(5:5).eq.' ' .or. i.le.64 .or. i.ge.128) grid(5:6)='mm'
-
-      if(grid(1:1).ge.'a' .and. grid(1:1).le.'z') grid(1:1)= 
-     +   char(ichar(grid(1:1))+ichar('A')-ichar('a'))
-      if(grid(2:2).ge.'a' .and. grid(2:2).le.'z') grid(2:2)=
-     +   char(ichar(grid(2:2))+ichar('A')-ichar('a'))
-      if(grid(5:5).ge.'A' .and. grid(5:5).le.'Z') grid(5:5)=
-     +   char(ichar(grid(5:5))-ichar('A')+ichar('a'))
-      if(grid(6:6).ge.'A' .and. grid(6:6).le.'Z') grid(6:6)=
-     +   char(ichar(grid(6:6))-ichar('A')+ichar('a'))
-
-      g1=grid(1:1)
-      g2=grid(2:2)
-      g3=grid(3:3)
-      g4=grid(4:4)
-      g5=grid(5:5)
-      g6=grid(6:6)
-
-      nlong = 180 - 20*(ichar(g1)-ichar('A'))
-      n20d = 2*(ichar(g3)-ichar('0'))
-      xminlong = 5*(ichar(g5)-ichar('a')+0.5)
-      dlong = nlong - n20d - xminlong/60.0
-      nlat = -90+10*(ichar(g2)-ichar('A')) + ichar(g4)-ichar('0')
-      xminlat = 2.5*(ichar(g6)-ichar('a')+0.5)
-      dlat = nlat + xminlat/60.0
-
-      return
-      end
+      subroutine grid2deg(grid0,dlong,dlat)
+
+C  Converts Maidenhead grid locator to degrees of West longitude
+C  and North latitude.
+
+      character*6 grid0,grid
+      character*1 g1,g2,g3,g4,g5,g6
+
+      grid=grid0
+      i=ichar(grid(5:5))
+      if(grid(5:5).eq.' ' .or. i.le.64 .or. i.ge.128) grid(5:6)='mm'
+
+      if(grid(1:1).ge.'a' .and. grid(1:1).le.'z') grid(1:1)= 
+     +   char(ichar(grid(1:1))+ichar('A')-ichar('a'))
+      if(grid(2:2).ge.'a' .and. grid(2:2).le.'z') grid(2:2)=
+     +   char(ichar(grid(2:2))+ichar('A')-ichar('a'))
+      if(grid(5:5).ge.'A' .and. grid(5:5).le.'Z') grid(5:5)=
+     +   char(ichar(grid(5:5))-ichar('A')+ichar('a'))
+      if(grid(6:6).ge.'A' .and. grid(6:6).le.'Z') grid(6:6)=
+     +   char(ichar(grid(6:6))-ichar('A')+ichar('a'))
+
+      g1=grid(1:1)
+      g2=grid(2:2)
+      g3=grid(3:3)
+      g4=grid(4:4)
+      g5=grid(5:5)
+      g6=grid(6:6)
+
+      nlong = 180 - 20*(ichar(g1)-ichar('A'))
+      n20d = 2*(ichar(g3)-ichar('0'))
+      xminlong = 5*(ichar(g5)-ichar('a')+0.5)
+      dlong = nlong - n20d - xminlong/60.0
+      nlat = -90+10*(ichar(g2)-ichar('A')) + ichar(g4)-ichar('0')
+      xminlat = 2.5*(ichar(g6)-ichar('a')+0.5)
+      dlat = nlat + xminlat/60.0
+
+      return
+      end


Property changes on: branches/map65/libm65/grid2deg.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/grid2k.f
===================================================================
--- branches/map65/libm65/grid2k.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/grid2k.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,12 +1,12 @@
-      subroutine grid2k(grid,k)
-
-      character*6 grid
-
-      call grid2deg(grid,xlong,xlat)
-      nlong=nint(xlong)
-      nlat=nint(xlat)
-      k=0
-      if(nlat.ge.85) k=5*(nlong+179)/2 + nlat-84
-
-      return
-      end
+      subroutine grid2k(grid,k)
+
+      character*6 grid
+
+      call grid2deg(grid,xlong,xlat)
+      nlong=nint(xlong)
+      nlat=nint(xlat)
+      k=0
+      if(nlat.ge.85) k=5*(nlong+179)/2 + nlat-84
+
+      return
+      end


Property changes on: branches/map65/libm65/grid2k.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/igray.c
===================================================================
--- branches/map65/libm65/igray.c	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/igray.c	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,22 +1,22 @@
-#ifdef CVF
-extern int __stdcall IGRAY(int *n0, int *idir)
-#else
-int igray_(int *n0, int *idir)
-#endif
-{
-  int n;
-  unsigned long sh;
-  unsigned long nn;
-  n=*n0;
-
-  if(*idir&gt;0) return (n ^ (n &gt;&gt; 1));
-
-  sh = 1;
-  nn = (n &gt;&gt; sh);
-  while (nn &gt; 0) {
-    n ^= nn;
-    sh &lt;&lt;= 1;
-    nn = (n &gt;&gt; sh);
-  }
-  return (n);
-}
+#ifdef CVF
+extern int __stdcall IGRAY(int *n0, int *idir)
+#else
+int igray_(int *n0, int *idir)
+#endif
+{
+  int n;
+  unsigned long sh;
+  unsigned long nn;
+  n=*n0;
+
+  if(*idir&gt;0) return (n ^ (n &gt;&gt; 1));
+
+  sh = 1;
+  nn = (n &gt;&gt; sh);
+  while (nn &gt; 0) {
+    n ^= nn;
+    sh &lt;&lt;= 1;
+    nn = (n &gt;&gt; sh);
+  }
+  return (n);
+}


Property changes on: branches/map65/libm65/igray.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/indexx.f
===================================================================
--- branches/map65/libm65/indexx.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/indexx.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,19 +1,19 @@
-      subroutine indexx(n,arr,indx)
-
-      parameter (NMAX=3000)
-      integer indx(n)
-      real arr(n)
-      real brr(NMAX)
-      if(n.gt.NMAX) then
-         print*,'n=',n,' too big in indexx.'
-         stop
-      endif
-      do i=1,n
-         brr(i)=arr(i)
-         indx(i)=i
-      enddo
-      call ssort(brr,indx,n,2)
-
-      return
-      end
-
+      subroutine indexx(n,arr,indx)
+
+      parameter (NMAX=3000)
+      integer indx(n)
+      real arr(n)
+      real brr(NMAX)
+      if(n.gt.NMAX) then
+         print*,'n=',n,' too big in indexx.'
+         stop
+      endif
+      do i=1,n
+         brr(i)=arr(i)
+         indx(i)=i
+      enddo
+      call ssort(brr,indx,n,2)
+
+      return
+      end
+


Property changes on: branches/map65/libm65/indexx.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/init_rs.c
===================================================================
--- branches/map65/libm65/init_rs.c	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/init_rs.c	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,126 +1,126 @@
-/* Initialize a RS codec
- *
- * Copyright 2002 Phil Karn, KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-#include &lt;stdlib.h&gt;
-
-#ifdef CCSDS
-#include &quot;ccsds.h&quot;
-#elif defined(BIGSYM)
-#include &quot;int.h&quot;
-#else
-#include &quot;char.h&quot;
-#endif
-
-#define NULL ((void *)0)
-
-void FREE_RS(void *p){
-  struct rs *rs = (struct rs *)p;
-
-  free(rs-&gt;alpha_to);
-  free(rs-&gt;index_of);
-  free(rs-&gt;genpoly);
-  free(rs);
-}
-
-/* Initialize a Reed-Solomon codec
- * symsize = symbol size, bits (1-8)
- * gfpoly = Field generator polynomial coefficients
- * fcr = first root of RS code generator polynomial, index form
- * prim = primitive element to generate polynomial roots
- * nroots = RS code generator polynomial degree (number of roots)
- * pad = padding bytes at front of shortened block
- */
-void *INIT_RS(int symsize,int gfpoly,int fcr,int prim,
-	int nroots,int pad){
-  struct rs *rs;
-  int i, j, sr,root,iprim;
-
-  /* Check parameter ranges */
-  if(symsize &lt; 0 || symsize &gt; 8*sizeof(DTYPE))
-    return NULL; /* Need version with ints rather than chars */
-
-  if(fcr &lt; 0 || fcr &gt;= (1&lt;&lt;symsize))
-    return NULL;
-  if(prim &lt;= 0 || prim &gt;= (1&lt;&lt;symsize))
-    return NULL;
-  if(nroots &lt; 0 || nroots &gt;= (1&lt;&lt;symsize))
-    return NULL; /* Can't have more roots than symbol values! */
-  if(pad &lt; 0 || pad &gt;= ((1&lt;&lt;symsize) -1 - nroots))
-    return NULL; /* Too much padding */
-
-  rs = (struct rs *)calloc(1,sizeof(struct rs));
-  rs-&gt;mm = symsize;
-  rs-&gt;nn = (1&lt;&lt;symsize)-1;
-  rs-&gt;pad = pad;
-
-  rs-&gt;alpha_to = (DTYPE *)malloc(sizeof(DTYPE)*(rs-&gt;nn+1));
-  if(rs-&gt;alpha_to == NULL){
-    free(rs);
-    return NULL;
-  }
-  rs-&gt;index_of = (DTYPE *)malloc(sizeof(DTYPE)*(rs-&gt;nn+1));
-  if(rs-&gt;index_of == NULL){
-    free(rs-&gt;alpha_to);
-    free(rs);
-    return NULL;
-  }
-
-  /* Generate Galois field lookup tables */
-  rs-&gt;index_of[0] = A0; /* log(zero) = -inf */
-  rs-&gt;alpha_to[A0] = 0; /* alpha**-inf = 0 */
-  sr = 1;
-  for(i=0;i&lt;rs-&gt;nn;i++){
-    rs-&gt;index_of[sr] = i;
-    rs-&gt;alpha_to[i] = sr;
-    sr &lt;&lt;= 1;
-    if(sr &amp; (1&lt;&lt;symsize))
-      sr ^= gfpoly;
-    sr &amp;= rs-&gt;nn;
-  }
-  if(sr != 1){
-    /* field generator polynomial is not primitive! */
-    free(rs-&gt;alpha_to);
-    free(rs-&gt;index_of);
-    free(rs);
-    return NULL;
-  }
-
-  /* Form RS code generator polynomial from its roots */
-  rs-&gt;genpoly = (DTYPE *)malloc(sizeof(DTYPE)*(nroots+1));
-  if(rs-&gt;genpoly == NULL){
-    free(rs-&gt;alpha_to);
-    free(rs-&gt;index_of);
-    free(rs);
-    return NULL;
-  }
-  rs-&gt;fcr = fcr;
-  rs-&gt;prim = prim;
-  rs-&gt;nroots = nroots;
-
-  /* Find prim-th root of 1, used in decoding */
-  for(iprim=1;(iprim % prim) != 0;iprim += rs-&gt;nn)
-    ;
-  rs-&gt;iprim = iprim / prim;
-
-  rs-&gt;genpoly[0] = 1;
-  for (i = 0,root=fcr*prim; i &lt; nroots; i++,root += prim) {
-    rs-&gt;genpoly[i+1] = 1;
-
-    /* Multiply rs-&gt;genpoly[] by  @**(root + x) */
-    for (j = i; j &gt; 0; j--){
-      if (rs-&gt;genpoly[j] != 0)
-	rs-&gt;genpoly[j] = rs-&gt;genpoly[j-1] ^ rs-&gt;alpha_to[modnn(rs,rs-&gt;index_of[rs-&gt;genpoly[j]] + root)];
-      else
-	rs-&gt;genpoly[j] = rs-&gt;genpoly[j-1];
-    }
-    /* rs-&gt;genpoly[0] can never be zero */
-    rs-&gt;genpoly[0] = rs-&gt;alpha_to[modnn(rs,rs-&gt;index_of[rs-&gt;genpoly[0]] + root)];
-  }
-  /* convert rs-&gt;genpoly[] to index form for quicker encoding */
-  for (i = 0; i &lt;= nroots; i++)
-    rs-&gt;genpoly[i] = rs-&gt;index_of[rs-&gt;genpoly[i]];
-
-  return rs;
-}
+/* Initialize a RS codec
+ *
+ * Copyright 2002 Phil Karn, KA9Q
+ * May be used under the terms of the GNU General Public License (GPL)
+ */
+#include &lt;stdlib.h&gt;
+
+#ifdef CCSDS
+#include &quot;ccsds.h&quot;
+#elif defined(BIGSYM)
+#include &quot;int.h&quot;
+#else
+#include &quot;char.h&quot;
+#endif
+
+#define NULL ((void *)0)
+
+void FREE_RS(void *p){
+  struct rs *rs = (struct rs *)p;
+
+  free(rs-&gt;alpha_to);
+  free(rs-&gt;index_of);
+  free(rs-&gt;genpoly);
+  free(rs);
+}
+
+/* Initialize a Reed-Solomon codec
+ * symsize = symbol size, bits (1-8)
+ * gfpoly = Field generator polynomial coefficients
+ * fcr = first root of RS code generator polynomial, index form
+ * prim = primitive element to generate polynomial roots
+ * nroots = RS code generator polynomial degree (number of roots)
+ * pad = padding bytes at front of shortened block
+ */
+void *INIT_RS(int symsize,int gfpoly,int fcr,int prim,
+	int nroots,int pad){
+  struct rs *rs;
+  int i, j, sr,root,iprim;
+
+  /* Check parameter ranges */
+  if(symsize &lt; 0 || symsize &gt; 8*sizeof(DTYPE))
+    return NULL; /* Need version with ints rather than chars */
+
+  if(fcr &lt; 0 || fcr &gt;= (1&lt;&lt;symsize))
+    return NULL;
+  if(prim &lt;= 0 || prim &gt;= (1&lt;&lt;symsize))
+    return NULL;
+  if(nroots &lt; 0 || nroots &gt;= (1&lt;&lt;symsize))
+    return NULL; /* Can't have more roots than symbol values! */
+  if(pad &lt; 0 || pad &gt;= ((1&lt;&lt;symsize) -1 - nroots))
+    return NULL; /* Too much padding */
+
+  rs = (struct rs *)calloc(1,sizeof(struct rs));
+  rs-&gt;mm = symsize;
+  rs-&gt;nn = (1&lt;&lt;symsize)-1;
+  rs-&gt;pad = pad;
+
+  rs-&gt;alpha_to = (DTYPE *)malloc(sizeof(DTYPE)*(rs-&gt;nn+1));
+  if(rs-&gt;alpha_to == NULL){
+    free(rs);
+    return NULL;
+  }
+  rs-&gt;index_of = (DTYPE *)malloc(sizeof(DTYPE)*(rs-&gt;nn+1));
+  if(rs-&gt;index_of == NULL){
+    free(rs-&gt;alpha_to);
+    free(rs);
+    return NULL;
+  }
+
+  /* Generate Galois field lookup tables */
+  rs-&gt;index_of[0] = A0; /* log(zero) = -inf */
+  rs-&gt;alpha_to[A0] = 0; /* alpha**-inf = 0 */
+  sr = 1;
+  for(i=0;i&lt;rs-&gt;nn;i++){
+    rs-&gt;index_of[sr] = i;
+    rs-&gt;alpha_to[i] = sr;
+    sr &lt;&lt;= 1;
+    if(sr &amp; (1&lt;&lt;symsize))
+      sr ^= gfpoly;
+    sr &amp;= rs-&gt;nn;
+  }
+  if(sr != 1){
+    /* field generator polynomial is not primitive! */
+    free(rs-&gt;alpha_to);
+    free(rs-&gt;index_of);
+    free(rs);
+    return NULL;
+  }
+
+  /* Form RS code generator polynomial from its roots */
+  rs-&gt;genpoly = (DTYPE *)malloc(sizeof(DTYPE)*(nroots+1));
+  if(rs-&gt;genpoly == NULL){
+    free(rs-&gt;alpha_to);
+    free(rs-&gt;index_of);
+    free(rs);
+    return NULL;
+  }
+  rs-&gt;fcr = fcr;
+  rs-&gt;prim = prim;
+  rs-&gt;nroots = nroots;
+
+  /* Find prim-th root of 1, used in decoding */
+  for(iprim=1;(iprim % prim) != 0;iprim += rs-&gt;nn)
+    ;
+  rs-&gt;iprim = iprim / prim;
+
+  rs-&gt;genpoly[0] = 1;
+  for (i = 0,root=fcr*prim; i &lt; nroots; i++,root += prim) {
+    rs-&gt;genpoly[i+1] = 1;
+
+    /* Multiply rs-&gt;genpoly[] by  @**(root + x) */
+    for (j = i; j &gt; 0; j--){
+      if (rs-&gt;genpoly[j] != 0)
+	rs-&gt;genpoly[j] = rs-&gt;genpoly[j-1] ^ rs-&gt;alpha_to[modnn(rs,rs-&gt;index_of[rs-&gt;genpoly[j]] + root)];
+      else
+	rs-&gt;genpoly[j] = rs-&gt;genpoly[j-1];
+    }
+    /* rs-&gt;genpoly[0] can never be zero */
+    rs-&gt;genpoly[0] = rs-&gt;alpha_to[modnn(rs,rs-&gt;index_of[rs-&gt;genpoly[0]] + root)];
+  }
+  /* convert rs-&gt;genpoly[] to index form for quicker encoding */
+  for (i = 0; i &lt;= nroots; i++)
+    rs-&gt;genpoly[i] = rs-&gt;index_of[rs-&gt;genpoly[i]];
+
+  return rs;
+}


Property changes on: branches/map65/libm65/init_rs.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/int.h
===================================================================
--- branches/map65/libm65/int.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/int.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,57 +1,57 @@
-/* Include file to configure the RS codec for integer symbols
- *
- * Copyright 2002, Phil Karn, KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-#define DTYPE int
-
-/* Reed-Solomon codec control block */
-struct rs {
-  int mm;              /* Bits per symbol */
-  int nn;              /* Symbols per block (= (1&lt;&lt;mm)-1) */
-  DTYPE *alpha_to;     /* log lookup table */
-  DTYPE *index_of;     /* Antilog lookup table */
-  DTYPE *genpoly;      /* Generator polynomial */
-  int nroots;     /* Number of generator roots = number of parity symbols */
-  int fcr;        /* First consecutive root, index form */
-  int prim;       /* Primitive element, index form */
-  int iprim;      /* prim-th root of 1, index form */
-  int pad;        /* Padding bytes in shortened block */
-};
-
-static int modnn(struct rs *rs,int x){
-  while (x &gt;= rs-&gt;nn) {
-    x -= rs-&gt;nn;
-    x = (x &gt;&gt; rs-&gt;mm) + (x &amp; rs-&gt;nn);
-  }
-  return x;
-}
-#define MODNN(x) modnn(rs,x)
-
-#define MM (rs-&gt;mm)
-#define NN (rs-&gt;nn)
-#define ALPHA_TO (rs-&gt;alpha_to) 
-#define INDEX_OF (rs-&gt;index_of)
-#define GENPOLY (rs-&gt;genpoly)
-//#define NROOTS (rs-&gt;nroots)
-#define NROOTS (51)
-#define FCR (rs-&gt;fcr)
-#define PRIM (rs-&gt;prim)
-#define IPRIM (rs-&gt;iprim)
-#define PAD (rs-&gt;pad)
-#define A0 (NN)
-
-#define ENCODE_RS encode_rs_int
-#define DECODE_RS decode_rs_int
-#define INIT_RS init_rs_int
-#define FREE_RS free_rs_int
-
-void ENCODE_RS(void *p,DTYPE *data,DTYPE *parity);
-int DECODE_RS(void *p,DTYPE *data,int *eras_pos,int no_eras);
-void *INIT_RS(int symsize,int gfpoly,int fcr,
-		   int prim,int nroots,int pad);
-void FREE_RS(void *p);
-
-
-
-
+/* Include file to configure the RS codec for integer symbols
+ *
+ * Copyright 2002, Phil Karn, KA9Q
+ * May be used under the terms of the GNU General Public License (GPL)
+ */
+#define DTYPE int
+
+/* Reed-Solomon codec control block */
+struct rs {
+  int mm;              /* Bits per symbol */
+  int nn;              /* Symbols per block (= (1&lt;&lt;mm)-1) */
+  DTYPE *alpha_to;     /* log lookup table */
+  DTYPE *index_of;     /* Antilog lookup table */
+  DTYPE *genpoly;      /* Generator polynomial */
+  int nroots;     /* Number of generator roots = number of parity symbols */
+  int fcr;        /* First consecutive root, index form */
+  int prim;       /* Primitive element, index form */
+  int iprim;      /* prim-th root of 1, index form */
+  int pad;        /* Padding bytes in shortened block */
+};
+
+static int modnn(struct rs *rs,int x){
+  while (x &gt;= rs-&gt;nn) {
+    x -= rs-&gt;nn;
+    x = (x &gt;&gt; rs-&gt;mm) + (x &amp; rs-&gt;nn);
+  }
+  return x;
+}
+#define MODNN(x) modnn(rs,x)
+
+#define MM (rs-&gt;mm)
+#define NN (rs-&gt;nn)
+#define ALPHA_TO (rs-&gt;alpha_to) 
+#define INDEX_OF (rs-&gt;index_of)
+#define GENPOLY (rs-&gt;genpoly)
+//#define NROOTS (rs-&gt;nroots)
+#define NROOTS (51)
+#define FCR (rs-&gt;fcr)
+#define PRIM (rs-&gt;prim)
+#define IPRIM (rs-&gt;iprim)
+#define PAD (rs-&gt;pad)
+#define A0 (NN)
+
+#define ENCODE_RS encode_rs_int
+#define DECODE_RS decode_rs_int
+#define INIT_RS init_rs_int
+#define FREE_RS free_rs_int
+
+void ENCODE_RS(void *p,DTYPE *data,DTYPE *parity);
+int DECODE_RS(void *p,DTYPE *data,int *eras_pos,int no_eras);
+void *INIT_RS(int symsize,int gfpoly,int fcr,
+		   int prim,int nroots,int pad);
+void FREE_RS(void *p);
+
+
+
+


Property changes on: branches/map65/libm65/int.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/interleave63.f
===================================================================
--- branches/map65/libm65/interleave63.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/interleave63.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,25 +1,25 @@
-      subroutine interleave63(d1,idir)
-
-C  Interleave (idir=1) or de-interleave (idir=-1) the array d1.
-
-      integer d1(0:6,0:8)
-      integer d2(0:8,0:6)
-
-      if(idir.ge.0) then
-         do i=0,6
-            do j=0,8
-               d2(j,i)=d1(i,j)
-            enddo
-         enddo
-         call move(d2,d1,63)
-      else
-         call move(d1,d2,63)
-         do i=0,6
-            do j=0,8
-               d1(i,j)=d2(j,i)
-            enddo
-         enddo
-      endif
-         
-      return
-      end
+      subroutine interleave63(d1,idir)
+
+C  Interleave (idir=1) or de-interleave (idir=-1) the array d1.
+
+      integer d1(0:6,0:8)
+      integer d2(0:8,0:6)
+
+      if(idir.ge.0) then
+         do i=0,6
+            do j=0,8
+               d2(j,i)=d1(i,j)
+            enddo
+         enddo
+         call move(d2,d1,63)
+      else
+         call move(d1,d2,63)
+         do i=0,6
+            do j=0,8
+               d1(i,j)=d2(j,i)
+            enddo
+         enddo
+      endif
+         
+      return
+      end


Property changes on: branches/map65/libm65/interleave63.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/ipcomm.cpp
===================================================================
--- branches/map65/libm65/ipcomm.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/ipcomm.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,34 +1,34 @@
-#include &lt;QDebug&gt;
-#include &lt;qsharedmemory.h&gt;
-#include &lt;QSystemSemaphore&gt;
-
-QSharedMemory mem_m65(&quot;mem_m65&quot;);
-QSystemSemaphore sem_m65(&quot;sem_m65&quot;, 1, QSystemSemaphore::Open);
-
-extern &quot;C&quot; {
-  bool attach_m65_();
-  bool create_m65_(int nsize);
-  bool detach_m65_();
-  bool lock_m65_();
-  bool unlock_m65_();
-  char* address_m65_();
-  int size_m65_();
-
-  bool acquire_m65_();
-  bool release_m65_();
-
-  extern struct {
-    char c[10];
-  } m65com_;
-}
-
-bool attach_m65_() {return mem_m65.attach();}
-bool create_m65_(int nsize) {return mem_m65.create(nsize);}
-bool detach_m65_() {return mem_m65.detach();}
-bool lock_m65_() {return mem_m65.lock();}
-bool unlock_m65_() {return mem_m65.unlock();}
-char* address_m65_() {return (char*)mem_m65.constData();}
-int size_m65_() {return (int)mem_m65.size();}
-
-bool acquire_m65_() {return sem_m65.acquire();}
-bool release_m65_() {return sem_m65.release();}
+#include &lt;QDebug&gt;
+#include &lt;qsharedmemory.h&gt;
+#include &lt;QSystemSemaphore&gt;
+
+QSharedMemory mem_m65(&quot;mem_m65&quot;);
+QSystemSemaphore sem_m65(&quot;sem_m65&quot;, 1, QSystemSemaphore::Open);
+
+extern &quot;C&quot; {
+  bool attach_m65_();
+  bool create_m65_(int nsize);
+  bool detach_m65_();
+  bool lock_m65_();
+  bool unlock_m65_();
+  char* address_m65_();
+  int size_m65_();
+
+  bool acquire_m65_();
+  bool release_m65_();
+
+  extern struct {
+    char c[10];
+  } m65com_;
+}
+
+bool attach_m65_() {return mem_m65.attach();}
+bool create_m65_(int nsize) {return mem_m65.create(nsize);}
+bool detach_m65_() {return mem_m65.detach();}
+bool lock_m65_() {return mem_m65.lock();}
+bool unlock_m65_() {return mem_m65.unlock();}
+char* address_m65_() {return (char*)mem_m65.constData();}
+int size_m65_() {return (int)mem_m65.size();}
+
+bool acquire_m65_() {return sem_m65.acquire();}
+bool release_m65_() {return sem_m65.release();}


Property changes on: branches/map65/libm65/ipcomm.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/iqcal.f90
===================================================================
--- branches/map65/libm65/iqcal.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/iqcal.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,30 +1,30 @@
-subroutine iqcal(nn,c,nfft,gain,phase,zsum,ipk,reject)
-
-  complex c(0:nfft-1)
-  complex z,zsum,zave
-
-  if(nn.eq.0) then
-     zsum=0.
-  endif
-  nn=nn+1
-  smax=0.
-  ipk=1
-  do i=1,nfft-1                       !Find strongest signal
-     s=real(c(i))**2 + aimag(c(i))**2
-     if(s.gt.smax) then
-        smax=s
-        ipk=i
-     endif
-  enddo
-  pimage=real(c(nfft-ipk))**2 + aimag(c(nfft-ipk))**2
-  p=smax + pimage
-  z=c(ipk)*c(nfft-ipk)/p              !Synchronous detection of image
-  zsum=zsum+z
-  zave=zsum/nn
-  tmp=sqrt(1.0 - (2.0*real(zave))**2)
-  phase=asin(2.0*aimag(zave)/tmp)    !Estimate phase
-  gain=tmp/(1.0-2.0*real(zave))      !Estimate gain
-  reject=10.0*log10(pimage/smax)
-
-  return
-end subroutine iqcal
+subroutine iqcal(nn,c,nfft,gain,phase,zsum,ipk,reject)
+
+  complex c(0:nfft-1)
+  complex z,zsum,zave
+
+  if(nn.eq.0) then
+     zsum=0.
+  endif
+  nn=nn+1
+  smax=0.
+  ipk=1
+  do i=1,nfft-1                       !Find strongest signal
+     s=real(c(i))**2 + aimag(c(i))**2
+     if(s.gt.smax) then
+        smax=s
+        ipk=i
+     endif
+  enddo
+  pimage=real(c(nfft-ipk))**2 + aimag(c(nfft-ipk))**2
+  p=smax + pimage
+  z=c(ipk)*c(nfft-ipk)/p              !Synchronous detection of image
+  zsum=zsum+z
+  zave=zsum/nn
+  tmp=sqrt(1.0 - (2.0*real(zave))**2)
+  phase=asin(2.0*aimag(zave)/tmp)    !Estimate phase
+  gain=tmp/(1.0-2.0*real(zave))      !Estimate gain
+  reject=10.0*log10(pimage/smax)
+
+  return
+end subroutine iqcal


Property changes on: branches/map65/libm65/iqcal.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/iqfix.f90
===================================================================
--- branches/map65/libm65/iqfix.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/iqfix.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,29 +1,29 @@
-subroutine iqfix(c,nfft,gain,phase)
-
-  complex c(0:nfft-1)
-  complex z,h,u,v
-  real*8 sq1,sq2
-
-  nh=nfft/2
-  h=gain*cmplx(cos(phase),sin(phase))
-
-  do i=1,nh-1
-     u=c(i)
-     v=c(nfft-i)
-     x=real(u)  + real(v)  - (aimag(u) + aimag(v))*aimag(h) +         &amp;
-          (real(u) - real(v))*real(h)
-     y=aimag(u) - aimag(v) + (aimag(u) + aimag(v))*real(h)  +         &amp;
-          (real(u) - real(v))*aimag(h)
-     c(i)=0.5*cmplx(x,y)
-     z=u
-     u=v
-     v=z
-     x=real(u)  + real(v)  - (aimag(u) + aimag(v))*aimag(h) +         &amp;
-          (real(u) - real(v))*real(h)
-     y=aimag(u) - aimag(v) + (aimag(u) + aimag(v))*real(h)  +         &amp;
-          (real(u) - real(v))*aimag(h)
-     c(nfft-i)=0.5*cmplx(x,y)
-  enddo
-
-  return
-end subroutine iqfix
+subroutine iqfix(c,nfft,gain,phase)
+
+  complex c(0:nfft-1)
+  complex z,h,u,v
+  real*8 sq1,sq2
+
+  nh=nfft/2
+  h=gain*cmplx(cos(phase),sin(phase))
+
+  do i=1,nh-1
+     u=c(i)
+     v=c(nfft-i)
+     x=real(u)  + real(v)  - (aimag(u) + aimag(v))*aimag(h) +         &amp;
+          (real(u) - real(v))*real(h)
+     y=aimag(u) - aimag(v) + (aimag(u) + aimag(v))*real(h)  +         &amp;
+          (real(u) - real(v))*aimag(h)
+     c(i)=0.5*cmplx(x,y)
+     z=u
+     u=v
+     v=z
+     x=real(u)  + real(v)  - (aimag(u) + aimag(v))*aimag(h) +         &amp;
+          (real(u) - real(v))*real(h)
+     y=aimag(u) - aimag(v) + (aimag(u) + aimag(v))*real(h)  +         &amp;
+          (real(u) - real(v))*aimag(h)
+     c(nfft-i)=0.5*cmplx(x,y)
+  enddo
+
+  return
+end subroutine iqfix


Property changes on: branches/map65/libm65/iqfix.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/k2grid.f
===================================================================
--- branches/map65/libm65/k2grid.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/k2grid.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,12 +1,12 @@
-      subroutine k2grid(k,grid)
-      character grid*6
-
-      nlong=2*mod((k-1)/5,90)-179
-      if(k.gt.450) nlong=nlong+180
-      nlat=mod(k-1,5)+ 85
-      dlat=nlat
-      dlong=nlong
-      call deg2grid(dlong,dlat,grid)
-
-      return
-      end
+      subroutine k2grid(k,grid)
+      character grid*6
+
+      nlong=2*mod((k-1)/5,90)-179
+      if(k.gt.450) nlong=nlong+180
+      nlat=mod(k-1,5)+ 85
+      dlat=nlat
+      dlong=nlong
+      call deg2grid(dlong,dlat,grid)
+
+      return
+      end


Property changes on: branches/map65/libm65/k2grid.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/m65.f90
===================================================================
--- branches/map65/libm65/m65.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/m65.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,130 +1,130 @@
-program m65
-
-! Decoder for map65.  Can run stand-alone, reading data from *.tf2 files;
-! or as the back end of map65, with data placed in a shared memory region.
-
-  parameter (NSMAX=60*96000)
-  parameter (NFFT=32768)
-  integer*2 i2(4,87)
-  real*8 hsym
-  real*4 ssz5a(NFFT)
-  logical*1 lstrong(0:1023)
-  common/tracer/limtrace,lu
-  real*8 fc0,fcenter
-  character*80 arg,infile
-  character mycall*12,hiscall*12,mygrid*6,hisgrid*6,datetime*20
-  common/datcom/dd(4,5760000),ss(4,322,NFFT),savg(4,NFFT),fc0,nutc0,junk(34)
-  common/npar/fcenter,nutc,idphi,mousedf,mousefqso,nagain,                &amp;
-       ndepth,ndiskdat,neme,newdat,nfa,nfb,nfcal,nfshift,                 &amp;
-       mcall3,nkeep,ntol,nxant,nrxlog,nfsample,nxpol,mode65,              &amp;
-       mycall,mygrid,hiscall,hisgrid,datetime
-
-  nargs=iargc()
-  if(nargs.lt.1) then
-     print*,'Usage: m65 [95238] file1 [file2 ...]'
-     print*,'       Reads data from *.tf2 files.'
-     print*,''
-     print*,'       m65 -s'
-     print*,'       Gets data from shared memory region.'
-     go to 999
-  endif
-  call getarg(1,arg)
-  if(arg(1:2).eq.'-s') then
-     call m65a
-     call ftnquit
-     go to 999
-  endif
-  nfsample=96000
-  nxpol=1
-  mode65=2
-  ifile1=1
-  if(arg.eq.'95238') then
-     nfsample=95238
-     call getarg(2,arg)
-     ifile1=2
-  endif
-
-  limtrace=0
-  lu=12
-  nfa=100
-  nfb=162
-  nfshift=6
-  ndepth=2
-  nfcal=344
-  idphi=-50
-  ntol=500
-  nkeep=10
-
-  call ftninit('.')
-
-  do ifile=ifile1,nargs
-     call getarg(ifile,infile)
-     open(10,file=infile,access='stream',status='old',err=998)
-     i1=index(infile,'.tf2')
-     read(infile(i1-4:i1-1),*,err=1) nutc0
-     go to 2
-1    nutc0=0
-2    hsym=2048.d0*96000.d0/11025.d0          !Samples per half symbol
-     nhsym0=-999
-     k=0
-     fcenter=144.125d0
-     mousedf=0
-     mousefqso=125
-     newdat=1
-     mycall='K1JT'
-
-     if(ifile.eq.ifile1) call timer('m65     ',0)
-     do irec=1,9999999
-        call timer('read_tf2',0)
-        read(10) i2
-        call timer('read_tf2',1)
-        
-        call timer('float   ',0)
-        do i=1,87
-           k=k+1
-           dd(1,k)=i2(1,i)
-           dd(2,k)=i2(2,i)
-           dd(3,k)=i2(3,i)
-           dd(4,k)=i2(4,i)
-        enddo
-        call timer('float   ',1)
-        nhsym=(k-2048)/hsym
-        if(nhsym.ge.1 .and. nhsym.ne.nhsym0) then
-           ndiskdat=1
-           nb=0
-! Emit signal readyForFFT
-           call timer('symspec ',0)
-           fgreen=-13.0
-           iqadjust=1
-           iqapply=1
-           nbslider=100
-           gainx=0.9962
-           gainy=1.0265
-           phasex=0.01426
-           phasey=-0.01195
-           call symspec(k,nxpol,ndiskdat,nb,nbslider,idphi,nfsample,fgreen,  &amp;
-                iqadjust,iqapply,gainx,gainy,phasex,phasey,rejectx,rejecty,  &amp;
-                pxdb,pydb,ssz5a,nkhz,ihsym,nzap,slimit,lstrong)
-           call timer('symspec ',1)
-           nhsym0=nhsym
-           if(ihsym.ge.278) go to 10
-        endif
-     enddo
-
-10   continue
-     if(iqadjust.ne.0) write(*,3002) rejectx,rejecty
-3002 format('Image rejection:',2f7.1,' dB')
-     nutc=nutc0
-     nstandalone=1
-     call decode0(dd,ss,savg,nstandalone,nfsample)
-  enddo
-
-  call timer('m65     ',1)
-  call timer('m65     ',101)
-  call ftnquit
-  go to 999
-
-998 print*,'Cannot open file:'
-  print*,infile
-
-999 end program m65
+program m65
+
+! Decoder for map65.  Can run stand-alone, reading data from *.tf2 files;
+! or as the back end of map65, with data placed in a shared memory region.
+
+  parameter (NSMAX=60*96000)
+  parameter (NFFT=32768)
+  integer*2 i2(4,87)
+  real*8 hsym
+  real*4 ssz5a(NFFT)
+  logical*1 lstrong(0:1023)
+  common/tracer/limtrace,lu
+  real*8 fc0,fcenter
+  character*80 arg,infile
+  character mycall*12,hiscall*12,mygrid*6,hisgrid*6,datetime*20
+  common/datcom/dd(4,5760000),ss(4,322,NFFT),savg(4,NFFT),fc0,nutc0,junk(34)
+  common/npar/fcenter,nutc,idphi,mousedf,mousefqso,nagain,                &amp;
+       ndepth,ndiskdat,neme,newdat,nfa,nfb,nfcal,nfshift,                 &amp;
+       mcall3,nkeep,ntol,nxant,nrxlog,nfsample,nxpol,mode65,              &amp;
+       mycall,mygrid,hiscall,hisgrid,datetime
+
+  nargs=iargc()
+  if(nargs.lt.1) then
+     print*,'Usage: m65 [95238] file1 [file2 ...]'
+     print*,'       Reads data from *.tf2 files.'
+     print*,''
+     print*,'       m65 -s'
+     print*,'       Gets data from shared memory region.'
+     go to 999
+  endif
+  call getarg(1,arg)
+  if(arg(1:2).eq.'-s') then
+     call m65a
+     call ftnquit
+     go to 999
+  endif
+  nfsample=96000
+  nxpol=1
+  mode65=2
+  ifile1=1
+  if(arg.eq.'95238') then
+     nfsample=95238
+     call getarg(2,arg)
+     ifile1=2
+  endif
+
+  limtrace=0
+  lu=12
+  nfa=100
+  nfb=162
+  nfshift=6
+  ndepth=2
+  nfcal=344
+  idphi=-50
+  ntol=500
+  nkeep=10
+
+  call ftninit('.')
+
+  do ifile=ifile1,nargs
+     call getarg(ifile,infile)
+     open(10,file=infile,access='stream',status='old',err=998)
+     i1=index(infile,'.tf2')
+     read(infile(i1-4:i1-1),*,err=1) nutc0
+     go to 2
+1    nutc0=0
+2    hsym=2048.d0*96000.d0/11025.d0          !Samples per half symbol
+     nhsym0=-999
+     k=0
+     fcenter=144.125d0
+     mousedf=0
+     mousefqso=125
+     newdat=1
+     mycall='K1JT'
+
+     if(ifile.eq.ifile1) call timer('m65     ',0)
+     do irec=1,9999999
+        call timer('read_tf2',0)
+        read(10) i2
+        call timer('read_tf2',1)
+        
+        call timer('float   ',0)
+        do i=1,87
+           k=k+1
+           dd(1,k)=i2(1,i)
+           dd(2,k)=i2(2,i)
+           dd(3,k)=i2(3,i)
+           dd(4,k)=i2(4,i)
+        enddo
+        call timer('float   ',1)
+        nhsym=(k-2048)/hsym
+        if(nhsym.ge.1 .and. nhsym.ne.nhsym0) then
+           ndiskdat=1
+           nb=0
+! Emit signal readyForFFT
+           call timer('symspec ',0)
+           fgreen=-13.0
+           iqadjust=1
+           iqapply=1
+           nbslider=100
+           gainx=0.9962
+           gainy=1.0265
+           phasex=0.01426
+           phasey=-0.01195
+           call symspec(k,nxpol,ndiskdat,nb,nbslider,idphi,nfsample,fgreen,  &amp;
+                iqadjust,iqapply,gainx,gainy,phasex,phasey,rejectx,rejecty,  &amp;
+                pxdb,pydb,ssz5a,nkhz,ihsym,nzap,slimit,lstrong)
+           call timer('symspec ',1)
+           nhsym0=nhsym
+           if(ihsym.ge.278) go to 10
+        endif
+     enddo
+
+10   continue
+     if(iqadjust.ne.0) write(*,3002) rejectx,rejecty
+3002 format('Image rejection:',2f7.1,' dB')
+     nutc=nutc0
+     nstandalone=1
+     call decode0(dd,ss,savg,nstandalone,nfsample)
+  enddo
+
+  call timer('m65     ',1)
+  call timer('m65     ',101)
+  call ftnquit
+  go to 999
+
+998 print*,'Cannot open file:'
+  print*,infile
+
+999 end program m65


Property changes on: branches/map65/libm65/m65.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/m65a.F90
===================================================================
--- branches/map65/libm65/m65a.F90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/m65a.F90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,97 +1,97 @@
-subroutine m65a
-
-! NB: this interface block is required by g95, but must be omitted
-!     for gfortran.  (????)
-
-#ifndef UNIX
-  interface
-     function address_m65()
-     end function address_m65
-  end interface
-#endif
-  
-  integer*1 attach_m65,lock_m65,unlock_m65
-  integer size_m65
-  integer*1, pointer :: address_m65,p_m65
-  character*80 cwd
-  logical fileExists
-  common/tracer/limtrace,lu
-
-  call getcwd(cwd)
-  call ftninit(trim(cwd))
-  limtrace=0
-  lu=12
-  i1=attach_m65()
-
-10 inquire(file=trim(cwd)//'/.lock',exist=fileExists)
-  if(fileExists) then
-     call sleep_msec(100)
-     go to 10
-  endif
-
-  inquire(file=trim(cwd)//'/.quit',exist=fileExists)
-  if(fileExists) then
-     call ftnquit
-     i=detach_m65()
-     go to 999
-  endif
-  
-  nbytes=size_m65()
-  if(nbytes.le.0) then
-     print*,'m65a: Shared memory mem_m65 does not exist.' 
-     print*,'Program m65a should be started automatically from within map65.'
-     go to 999
-  endif
-  p_m65=&gt;address_m65()
-  call m65b(p_m65,nbytes)
-
-  write(*,1010) 
-1010 format('&lt;m65aFinished&gt;')
-  flush(6)
-
-100 inquire(file=trim(cwd)//'/.lock',exist=fileExists)
-  if(fileExists) go to 10
-  call sleep_msec(100)
-  go to 100
-
-999 return
-end subroutine m65a
-
-subroutine m65b(m65com,nbytes)
-  integer*1 m65com(0:nbytes-1)
-  kss=4*4*60*96000
-  ksavg=kss+4*4*322*32768
-  kfcenter=ksavg+4*4*32768
- call m65c(m65com(0),m65com(kss),m65com(ksavg),m65com(kfcenter))
-  return
-end subroutine m65b
-
-subroutine m65c(dd,ss,savg,nparams0)
-  integer*1 detach_m65
-  real*4 dd(4,5760000),ss(4,322,32768),savg(4,32768)
-  real*8 fcenter
-  integer nparams0(37),nparams(37)
-  character*12 mycall,hiscall
-  character*6 mygrid,hisgrid
-  character*20 datetime
-  common/npar/fcenter,nutc,idphi,mousedf,mousefqso,nagain,              &amp;
-       ndepth,ndiskdat,neme,newdat,nfa,nfb,nfcal,nfshift,               &amp;
-       mcall3,nkeep,ntol,nxant,nrxlog,nfsample,nxpol,mode65,            &amp;
-       mycall,mygrid,hiscall,hisgrid,datetime
-  equivalence (nparams,fcenter)
-  
-  nparams=nparams0                     !Copy parameters into common/npar/
-  npatience=1
-  if(iand(nrxlog,1).ne.0) then
-     write(21,1000) datetime(:17)
-1000 format(/'UTC Date: 'a17/78('-'))
-     flush(21)
-  endif
-  if(iand(nrxlog,2).ne.0) rewind 21
-  if(iand(nrxlog,4).ne.0) rewind 26
-
-  nstandalone=0
-  if(sum(nparams).ne.0) call decode0(dd,ss,savg,nstandalone)
-
-  return
-end subroutine m65c
+subroutine m65a
+
+! NB: this interface block is required by g95, but must be omitted
+!     for gfortran.  (????)
+
+#ifndef UNIX
+  interface
+     function address_m65()
+     end function address_m65
+  end interface
+#endif
+  
+  integer*1 attach_m65,lock_m65,unlock_m65
+  integer size_m65
+  integer*1, pointer :: address_m65,p_m65
+  character*80 cwd
+  logical fileExists
+  common/tracer/limtrace,lu
+
+  call getcwd(cwd)
+  call ftninit(trim(cwd))
+  limtrace=0
+  lu=12
+  i1=attach_m65()
+
+10 inquire(file=trim(cwd)//'/.lock',exist=fileExists)
+  if(fileExists) then
+     call sleep_msec(100)
+     go to 10
+  endif
+
+  inquire(file=trim(cwd)//'/.quit',exist=fileExists)
+  if(fileExists) then
+     call ftnquit
+     i=detach_m65()
+     go to 999
+  endif
+  
+  nbytes=size_m65()
+  if(nbytes.le.0) then
+     print*,'m65a: Shared memory mem_m65 does not exist.' 
+     print*,'Program m65a should be started automatically from within map65.'
+     go to 999
+  endif
+  p_m65=&gt;address_m65()
+  call m65b(p_m65,nbytes)
+
+  write(*,1010) 
+1010 format('&lt;m65aFinished&gt;')
+  flush(6)
+
+100 inquire(file=trim(cwd)//'/.lock',exist=fileExists)
+  if(fileExists) go to 10
+  call sleep_msec(100)
+  go to 100
+
+999 return
+end subroutine m65a
+
+subroutine m65b(m65com,nbytes)
+  integer*1 m65com(0:nbytes-1)
+  kss=4*4*60*96000
+  ksavg=kss+4*4*322*32768
+  kfcenter=ksavg+4*4*32768
+ call m65c(m65com(0),m65com(kss),m65com(ksavg),m65com(kfcenter))
+  return
+end subroutine m65b
+
+subroutine m65c(dd,ss,savg,nparams0)
+  integer*1 detach_m65
+  real*4 dd(4,5760000),ss(4,322,32768),savg(4,32768)
+  real*8 fcenter
+  integer nparams0(37),nparams(37)
+  character*12 mycall,hiscall
+  character*6 mygrid,hisgrid
+  character*20 datetime
+  common/npar/fcenter,nutc,idphi,mousedf,mousefqso,nagain,              &amp;
+       ndepth,ndiskdat,neme,newdat,nfa,nfb,nfcal,nfshift,               &amp;
+       mcall3,nkeep,ntol,nxant,nrxlog,nfsample,nxpol,mode65,            &amp;
+       mycall,mygrid,hiscall,hisgrid,datetime
+  equivalence (nparams,fcenter)
+  
+  nparams=nparams0                     !Copy parameters into common/npar/
+  npatience=1
+  if(iand(nrxlog,1).ne.0) then
+     write(21,1000) datetime(:17)
+1000 format(/'UTC Date: 'a17/78('-'))
+     flush(21)
+  endif
+  if(iand(nrxlog,2).ne.0) rewind 21
+  if(iand(nrxlog,4).ne.0) rewind 26
+
+  nstandalone=0
+  if(sum(nparams).ne.0) call decode0(dd,ss,savg,nstandalone)
+
+  return
+end subroutine m65c


Property changes on: branches/map65/libm65/m65a.F90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/map65a.f90
===================================================================
--- branches/map65/libm65/map65a.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/map65a.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,438 +1,438 @@
-subroutine map65a(dd,ss,savg,newdat,nutc,fcenter,ntol,idphi,nfa,nfb,        &amp;
-     mousedf,mousefqso,nagain,ndecdone,ndiskdat,nfshift,ndphi,              &amp;
-     nfcal,nkeep,mcall3b,nsave,nxant,rmsdd,mycall,mygrid,                    &amp;
-     neme,ndepth,hiscall,hisgrid,nhsym,nfsample,nxpol,mode65)
-
-!  Processes timf2 data from Linrad to find and decode JT65 signals.
-
-  parameter (MAXMSG=1000)            !Size of decoded message list
-  parameter (NSMAX=60*96000)
-  parameter (NFFT=32768)
-  real dd(4,NSMAX)
-  real*4 ss(4,322,NFFT),savg(4,NFFT)
-  real tavg(-50:50)                  !Temp for finding local base level
-  real base(4)                       !Local basel level at 4 pol'ns
-  real tmp (200)                     !Temp storage for pctile sorting
-  real sig(MAXMSG,30)                !Parameters of detected signals
-  real a(5)
-  real*8 fcenter
-  character*22 msg(MAXMSG)
-  character*3 shmsg0(4)
-  character mycall*12,hiscall*12,mygrid*6,hisgrid*6,grid*6,cp*1
-  integer indx(MAXMSG),nsiz(MAXMSG)
-  logical done(MAXMSG)
-  logical xpol
-  character decoded*22,blank*22
-  real short(3,NFFT)                 !SNR dt ipol for potential shorthands
-  real qphi(12)
-  common/c3com/ mcall3a
-  common/testcom/ifreq
-  
-  data blank/'                      '/
-  data shmsg0/'ATT','RO ','RRR','73 '/
-  data nfile/0/,nutc0/-999/,nid/0/,ip000/1/,ip001/1/,mousefqso0/-999/
-  save
-
-  mcall3a=mcall3b
-  mousefqso0=mousefqso
-  xpol=(nxpol.ne.0)
-  if(.not.xpol) ndphi=0
-
-!### Should use AppDir! ###
-!  open(23,file='release/CALL3.TXT',status='unknown')
-  open(23,file='CALL3.TXT',status='unknown')
-
-  if(nutc.ne.nutc0) nfile=nfile+1
-  nutc0=nutc
-  df=96000.0/NFFT                     !df = 96000/NFFT = 2.930 Hz
-  if(nfsample.eq.95238) df=95238.1/NFFT
-  ftol=0.010                          !Frequency tolerance (kHz)
-  dphi=idphi/57.2957795
-  foffset=0.001*(1270 + nfcal)              !Offset from sync tone, plus CAL
-  fqso=mousefqso + foffset - 0.5*(nfa+nfb) + nfshift !fqso at baseband (khz)
-  iloop=0
-
-2  if(ndphi.eq.1) dphi=30*iloop/57.2957795
-
-  do nqd=1,0,-1
-     if(nqd.eq.1) then                     !Quick decode, at fQSO
-        fa=1000.0*(fqso+0.001*mousedf) - ntol
-        fb=1000.0*(fqso+0.001*mousedf) + ntol + 4*53.8330078
-     else                                  !Wideband decode at all freqs
-        fa=-1000*0.5*(nfb-nfa) + 1000*nfshift
-        fb= 1000*0.5*(nfb-nfa) + 1000*nfshift
-     endif
-     ia=nint(fa/df) + 16385
-     ib=nint(fb/df) + 16385
-     ia=max(51,ia)
-     ib=min(32768-51,ib)
-
-     km=0
-     nkm=1
-     nz=n/8
-     freq0=-999.
-     sync10=-999.
-     fshort0=-999.
-     syncshort0=-999.
-     ntry=0
-     short=0.                                 !Zero the whole short array
-     jpz=1
-     if(xpol) jpz=4
-
-     do i=ia,ib                               !Search over freq range
-        freq=0.001*(i-16385)*df
-!  Find the local base level for each polarization; update every 10 bins.
-        if(mod(i-ia,10).eq.0) then
-           do jp=1,jpz
-              do ii=-50,50
-                 iii=i+ii
-                 if(iii.ge.1 .and. iii.le.32768) then
-                    tavg(ii)=savg(jp,iii)
-                 else
-                    write(13,*) ,'Error in iii:',iii,ia,ib,fa,fb
-                    flush(13)
-                    go to 999
-                 endif
-              enddo
-              call pctile(tavg,tmp,101,50,base(jp))
-           enddo
-        endif
-
-!  Find max signal at this frequency
-        smax=0.
-        do jp=1,jpz
-           if(savg(jp,i)/base(jp).gt.smax) then
-              smax=savg(jp,i)/base(jp)
-              jpmax=jp
-           endif
-        enddo
-
-        if(smax.gt.1.1) then
-
-!  Look for JT65 sync patterns and shorthand square-wave patterns.
-           call timer('ccf65   ',0)
-!           ssmax=4.0*(rmsdd/22.5)**2
-           ssmax=savg(jpmax,i)
-           call ccf65(ss(1,1,i),nhsym,ssmax,sync1,ipol,jpz,dt,flipk,     &amp;
-                syncshort,snr2,ipol2,dt2)
-           call timer('ccf65   ',1)
-
-! ########################### Search for Shorthand Messages #################
-!  Is there a shorthand tone above threshold?
-           thresh0=1.0
-!  Use lower thresh0 at fQSO
-           if(nqd.eq.1 .and. ntol.le.100) thresh0=0.
-           if(syncshort.gt.thresh0) then
-! ### Do shorthand AFC here (or maybe after finding a pair?) ###
-              short(1,i)=syncshort
-              short(2,i)=dt2
-              short(3,i)=ipol2
-           
-!  Check to see if lower tone of shorthand pair was found.
-              do j=2,4
-                 i0=i-nint(j*mode65*10.0*(11025.0/4096.0)/df)
-!  Should this be i0 +/- 1, or just i0?
-!  Should we also insist that difference in DT be either 1.5 or -1.5 s?
-                 if(short(1,i0).gt.thresh0) then
-                    fshort=0.001*(i0-16385)*df
-                    noffset=0
-                    if(nqd.eq.1) noffset=nint(1000.0*(fshort-fqso)-mousedf)
-                    if(abs(noffset).le.ntol) then
-!  Keep only the best candidate within ftol.
-!### NB: sync2 was not defined here!
-!                       sync2=syncshort                   !### try this ???
-                       if(fshort-fshort0.le.ftol .and. syncshort.gt.syncshort0 &amp;
-                            .and. nkm.eq.2) km=km-1
-                       if(fshort-fshort0.gt.ftol .or.                     &amp;
-                            syncshort.gt.syncshort0) then
-                          if(km.lt.MAXMSG) km=km+1
-                          sig(km,1)=nfile
-                          sig(km,2)=nutc
-                          sig(km,3)=fshort + 0.5*(nfa+nfb)
-                          sig(km,4)=syncshort
-                          sig(km,5)=dt2
-                          sig(km,6)=45*(ipol2-1)/57.2957795
-                          sig(km,7)=0
-                          sig(km,8)=snr2
-                          sig(km,9)=0
-                          sig(km,10)=0
-!                           sig(km,11)=rms0
-                          sig(km,12)=savg(ipol2,i)
-                          sig(km,13)=0
-                          sig(km,14)=0
-                          sig(km,15)=0
-                          sig(km,16)=0
-!                           sig(km,17)=0
-                          sig(km,18)=0
-                          msg(km)=shmsg0(j)
-                          fshort0=fshort
-                          syncshort0=syncshort
-                          nkm=2
-                       endif
-                    endif
-                 endif
-              enddo
-           endif
-
-! ########################### Search for Normal Messages ###########
-!  Is sync1 above threshold?
-           thresh1=1.0
-!  Use lower thresh1 at fQSO
-           if(nqd.eq.1 .and. ntol.le.100) thresh1=0.
-           noffset=0
-           if(nqd.eq.1) noffset=nint(1000.0*(freq-fqso)-mousedf)
-
-           if(sync1.gt.thresh1 .and. abs(noffset).le.ntol) then
-!  Keep only the best candidate within ftol.
-!  (Am I deleting any good decodes by doing this?)
-              if(freq-freq0.le.ftol .and. sync1.gt.sync10 .and.       &amp;
-                   nkm.eq.1) km=km-1
-              if(freq-freq0.gt.ftol .or. sync1.gt.sync10) then
-                 nflip=nint(flipk)
-                 f00=(i-1)*df          !Freq of detected sync tone (0-96000 Hz)
-                 ntry=ntry+1
-                 if((nqd.eq.1 .and. ntry.ge.40) .or.                  &amp;
-                          (nqd.eq.0 .and. ntry.ge.400)) then
-! Too many calls to decode1a!
-                    write(*,*) '! Signal too strong?  Decoding aborted.'
-                    write(13,*) 'Signal too strong?  Decoding aborted.'
-                    call flush(13)
-                    go to 999
-                 endif
-                 call timer('decode1a',0)
-                 ifreq=i
-                 ikHz=nint(freq+0.5*(nfa+nfb)-foffset)-nfshift
-                 idf=nint(1000.0*(freq+0.5*(nfa+nfb)-foffset-(ikHz+nfshift)))
-                 call decode1a(dd,newdat,f00,nflip,mode65,nfsample,xpol,  &amp;
-                      mycall,hiscall,hisgrid,neme,ndepth,nqd,dphi,        &amp;
-                      nutc,ikHz,idf,ipol,sync2,a,dt,pol,nkv,nhist,qual,decoded)
-                 dt=dt+0.8                           !### empirical tweak
-                 call timer('decode1a',1)
-
-                 if(km.lt.MAXMSG) km=km+1
-                 sig(km,1)=nfile
-                 sig(km,2)=nutc
-                 sig(km,3)=freq + 0.5*(nfa+nfb)
-                 sig(km,4)=sync1
-                 sig(km,5)=dt
-                 sig(km,6)=pol
-                 sig(km,7)=flipk
-                 sig(km,8)=sync2
-                 sig(km,9)=nkv
-                 sig(km,10)=qual
-!                 sig(km,11)=idphi
-                 sig(km,12)=savg(ipol,i)
-                 sig(km,13)=a(1)
-                 sig(km,14)=a(2)
-                 sig(km,15)=a(3)
-                 sig(km,16)=a(4)
-!                     sig(km,17)=a(5)
-                 sig(km,18)=nhist
-                 msg(km)=decoded
-                 freq0=freq
-                 sync10=sync1
-                 nkm=1
-              endif
-           endif
-        endif
-!70      continue
-     enddo
-
-     if(nqd.eq.1) then
-        nwrite=0
-        do k=1,km
-           decoded=msg(k)
-           if(decoded.ne.'                      ') then
-              nutc=sig(k,2)
-              freq=sig(k,3)
-              sync1=sig(k,4)
-              dt=sig(k,5)
-              npol=nint(57.2957795*sig(k,6))
-              flip=sig(k,7)
-              sync2=sig(k,8)
-              nkv=sig(k,9)
-              nqual=sig(k,10)
-!              idphi=nint(sig(k,11))
-              if(flip.lt.0.0) then
-                 do i=22,1,-1
-                    if(decoded(i:i).ne.' ') go to 8
-                 enddo
-                 stop 'Error in message format'
-8                if(i.le.18) decoded(i+2:i+4)='OOO'
-              endif
-              nkHz=nint(freq-foffset)-nfshift
-              mhz=fcenter                         ! ... +fadd ???
-              f0=mhz+0.001*nkHz
-              ndf=nint(1000.0*(freq-foffset-(nkHz+nfshift)))
-              nsync1=sync1
-              nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
-              if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
-                   decoded(1:4).eq.'73  ') nsync2=nsync2-6
-              nwrite=nwrite+1
-              if(nxant.ne.0) then
-                 npol=npol-45
-                 if(npol.lt.0) npol=npol+180
-              endif
-
-!  If Tx station's grid is in decoded message, compute optimum TxPol
-              i1=index(decoded,' ')
-              i2=index(decoded(i1+1:),' ') + i1
-              grid='      '
-              if(i2.ge.8 .and. i2.le.18) grid=decoded(i2+1:i2+4)//'mm'
-              ntxpol=0
-              cp=' '
-              if(xpol) then
-                 if(grid(1:1).ge.'A' .and. grid(1:1).le.'R' .and.           &amp;
-                      grid(2:2).ge.'A' .and. grid(2:2).le.'R' .and.         &amp;
-                      grid(3:3).ge.'0' .and. grid(3:3).le.'9' .and.         &amp;
-                      grid(4:4).ge.'0' .and. grid(4:4).le.'9') then                 
-                    ntxpol=mod(npol-nint(2.0*dpol(mygrid,grid))+720,180)
-                    if(nxant.eq.0) then
-                       cp='H'
-                       if(ntxpol.gt.45 .and. ntxpol.le.135) cp='V'
-                    else
-                       cp='/'
-                       if(ntxpol.ge.90 .and. ntxpol.lt.180) cp='\\'
-                    endif
-                 endif
-              endif
-              
-              if(ndphi.eq.0) then
-                 write(*,1010) nkHz,ndf,npol,nutc,dt,nsync2,    &amp;
-                      decoded,nkv,nqual,ntxpol,cp
-1010             format('!',i3,i5,i4,i5.4,f5.1,i4,2x,a22,i5,i4,i5,1x,a1)
-              else
-                 if(iloop.ge.1) qphi(iloop)=sig(k,10)
-                 write(*,1010) nkHz,ndf,npol,nutc,dt,nsync2,    &amp;
-                      decoded,nkv,nqual,30*iloop
-                 write(27,1011) 30*iloop,nkHz,ndf,npol,nutc,  &amp;
-                      dt,sync2,nkv,nqual,decoded
-1011             format(i3,i4,i5,i4,i5.4,f5.1,f7.1,i3,i5,2x,a22)
-              endif
-           endif
-        enddo
-
-        if(nwrite.eq.0) then
-           write(*,1012) mousefqso,nutc
-1012       format('!',i3,9x,i5.4,' ')
-        endif
-   
-     endif
-     if(ndphi.eq.1 .and.iloop.lt.12) then
-        iloop=iloop+1
-        go to 2
-     endif
-     
-     if(ndphi.eq.1 .and.iloop.eq.12) call getdphi(qphi)
-     if(nagain.eq.1) go to 999
-  enddo
-
-!  Trim the list and produce a sorted index and sizes of groups.
-!  (Should trimlist remove all but best SNR for given UTC and message content?)
-  call trimlist(sig,km,ftol,indx,nsiz,nz)
-
-  do i=1,km
-     done(i)=.false.
-  enddo
-  j=0
-  ilatest=-1
-  do n=1,nz
-     ifile0=0
-     do m=1,nsiz(n)
-        i=indx(j+m)
-        ifile=sig(i,1)
-        if(ifile.gt.ifile0 .and.msg(i).ne.blank) then
-           ilatest=i
-           ifile0=ifile
-        endif
-     enddo
-     i=ilatest
-
-     if(i.ge.1) then
-        if(.not.done(i)) then
-           done(i)=.true.
-           nutc=sig(i,2)
-           freq=sig(i,3)
-           sync1=sig(i,4)
-           dt=sig(i,5)
-           npol=nint(57.2957795*sig(i,6))
-           flip=sig(i,7)
-           sync2=sig(i,8)
-           nkv=sig(i,9)
-           nqual=min(sig(i,10),10.0)
-!                  rms0=sig(i,11)
-           do k=1,5
-              a(k)=sig(i,12+k)
-           enddo
-           nhist=sig(i,18)
-           decoded=msg(i)
-           
-           if(flip.lt.0.0) then
-              do i=22,1,-1
-                 if(decoded(i:i).ne.' ') go to 10
-              enddo
-              stop 'Error in message format'
-10            if(i.le.18) decoded(i+2:i+4)='OOO'
-           endif
-           mhz=fcenter                             !... +fadd ???
-           nkHz=nint(freq-foffset)-nfshift
-           f0=mhz+0.001*nkHz
-           ndf=nint(1000.0*(freq-foffset-(nkHz+nfshift)))
-           ndf0=nint(a(1))
-           ndf1=nint(a(2))
-           ndf2=nint(a(3))
-           nsync1=sync1
-           nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
-           if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
-                decoded(1:4).eq.'73  ') nsync2=nsync2-6
-           if(nxant.ne.0) then
-              npol=npol-45
-              if(npol.lt.0) npol=npol+180
-           endif
-
-!  If Tx station's grid is in decoded message, compute optimum TxPol
-           i1=index(decoded,' ')
-           i2=index(decoded(i1+1:),' ') + i1
-           grid='      '
-           if(i2.ge.8 .and. i2.le.18) grid=decoded(i2+1:i2+4)//'mm'
-           ntxpol=0
-           cp=' '
-           if(xpol) then
-              if(grid(1:1).ge.'A' .and. grid(1:1).le.'R' .and.           &amp;
-                   grid(2:2).ge.'A' .and. grid(2:2).le.'R' .and.         &amp;
-                   grid(3:3).ge.'0' .and. grid(3:3).le.'9' .and.         &amp;
-                   grid(4:4).ge.'0' .and. grid(4:4).le.'9') then                 
-                 ntxpol=mod(npol-nint(2.0*dpol(mygrid,grid))+720,180)
-                 if(nxant.eq.0) then
-                    cp='H'
-                    if(ntxpol.gt.45 .and. ntxpol.le.135) cp='V'
-                 else
-                    cp='/'
-                    if(ntxpol.ge.90 .and. ntxpol.lt.180) cp='\\'
-                 endif
-              endif
-           endif
-           write(26,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
-                nsync2,nutc,decoded,nkv,nqual,nhist,cp
-           write(21,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
-                nsync2,nutc,decoded,nkv,nqual,nhist
-1014       format(f8.3,i5,3i3,f5.1,i4,i3,i4,i5.4,2x,a22,3i3,1x,a1)
-
-        endif
-     endif
-     j=j+nsiz(n)
-  enddo
-  write(26,1015) nutc
-1015 format(39x,i4.4)
-  call flush(21)
-  call flush(26)
-  call display(nkeep,ftol)
-  ndecdone=2
-
-999 close(23)
-  ndphi=0
-  nagain=0
-  mcall3b=mcall3a
-
-  return
-end subroutine map65a
+subroutine map65a(dd,ss,savg,newdat,nutc,fcenter,ntol,idphi,nfa,nfb,        &amp;
+     mousedf,mousefqso,nagain,ndecdone,ndiskdat,nfshift,ndphi,              &amp;
+     nfcal,nkeep,mcall3b,nsave,nxant,rmsdd,mycall,mygrid,                    &amp;
+     neme,ndepth,hiscall,hisgrid,nhsym,nfsample,nxpol,mode65)
+
+!  Processes timf2 data from Linrad to find and decode JT65 signals.
+
+  parameter (MAXMSG=1000)            !Size of decoded message list
+  parameter (NSMAX=60*96000)
+  parameter (NFFT=32768)
+  real dd(4,NSMAX)
+  real*4 ss(4,322,NFFT),savg(4,NFFT)
+  real tavg(-50:50)                  !Temp for finding local base level
+  real base(4)                       !Local basel level at 4 pol'ns
+  real tmp (200)                     !Temp storage for pctile sorting
+  real sig(MAXMSG,30)                !Parameters of detected signals
+  real a(5)
+  real*8 fcenter
+  character*22 msg(MAXMSG)
+  character*3 shmsg0(4)
+  character mycall*12,hiscall*12,mygrid*6,hisgrid*6,grid*6,cp*1
+  integer indx(MAXMSG),nsiz(MAXMSG)
+  logical done(MAXMSG)
+  logical xpol
+  character decoded*22,blank*22
+  real short(3,NFFT)                 !SNR dt ipol for potential shorthands
+  real qphi(12)
+  common/c3com/ mcall3a
+  common/testcom/ifreq
+  
+  data blank/'                      '/
+  data shmsg0/'ATT','RO ','RRR','73 '/
+  data nfile/0/,nutc0/-999/,nid/0/,ip000/1/,ip001/1/,mousefqso0/-999/
+  save
+
+  mcall3a=mcall3b
+  mousefqso0=mousefqso
+  xpol=(nxpol.ne.0)
+  if(.not.xpol) ndphi=0
+
+!### Should use AppDir! ###
+!  open(23,file='release/CALL3.TXT',status='unknown')
+  open(23,file='CALL3.TXT',status='unknown')
+
+  if(nutc.ne.nutc0) nfile=nfile+1
+  nutc0=nutc
+  df=96000.0/NFFT                     !df = 96000/NFFT = 2.930 Hz
+  if(nfsample.eq.95238) df=95238.1/NFFT
+  ftol=0.010                          !Frequency tolerance (kHz)
+  dphi=idphi/57.2957795
+  foffset=0.001*(1270 + nfcal)              !Offset from sync tone, plus CAL
+  fqso=mousefqso + foffset - 0.5*(nfa+nfb) + nfshift !fqso at baseband (khz)
+  iloop=0
+
+2  if(ndphi.eq.1) dphi=30*iloop/57.2957795
+
+  do nqd=1,0,-1
+     if(nqd.eq.1) then                     !Quick decode, at fQSO
+        fa=1000.0*(fqso+0.001*mousedf) - ntol
+        fb=1000.0*(fqso+0.001*mousedf) + ntol + 4*53.8330078
+     else                                  !Wideband decode at all freqs
+        fa=-1000*0.5*(nfb-nfa) + 1000*nfshift
+        fb= 1000*0.5*(nfb-nfa) + 1000*nfshift
+     endif
+     ia=nint(fa/df) + 16385
+     ib=nint(fb/df) + 16385
+     ia=max(51,ia)
+     ib=min(32768-51,ib)
+
+     km=0
+     nkm=1
+     nz=n/8
+     freq0=-999.
+     sync10=-999.
+     fshort0=-999.
+     syncshort0=-999.
+     ntry=0
+     short=0.                                 !Zero the whole short array
+     jpz=1
+     if(xpol) jpz=4
+
+     do i=ia,ib                               !Search over freq range
+        freq=0.001*(i-16385)*df
+!  Find the local base level for each polarization; update every 10 bins.
+        if(mod(i-ia,10).eq.0) then
+           do jp=1,jpz
+              do ii=-50,50
+                 iii=i+ii
+                 if(iii.ge.1 .and. iii.le.32768) then
+                    tavg(ii)=savg(jp,iii)
+                 else
+                    write(13,*) ,'Error in iii:',iii,ia,ib,fa,fb
+                    flush(13)
+                    go to 999
+                 endif
+              enddo
+              call pctile(tavg,tmp,101,50,base(jp))
+           enddo
+        endif
+
+!  Find max signal at this frequency
+        smax=0.
+        do jp=1,jpz
+           if(savg(jp,i)/base(jp).gt.smax) then
+              smax=savg(jp,i)/base(jp)
+              jpmax=jp
+           endif
+        enddo
+
+        if(smax.gt.1.1) then
+
+!  Look for JT65 sync patterns and shorthand square-wave patterns.
+           call timer('ccf65   ',0)
+!           ssmax=4.0*(rmsdd/22.5)**2
+           ssmax=savg(jpmax,i)
+           call ccf65(ss(1,1,i),nhsym,ssmax,sync1,ipol,jpz,dt,flipk,     &amp;
+                syncshort,snr2,ipol2,dt2)
+           call timer('ccf65   ',1)
+
+! ########################### Search for Shorthand Messages #################
+!  Is there a shorthand tone above threshold?
+           thresh0=1.0
+!  Use lower thresh0 at fQSO
+           if(nqd.eq.1 .and. ntol.le.100) thresh0=0.
+           if(syncshort.gt.thresh0) then
+! ### Do shorthand AFC here (or maybe after finding a pair?) ###
+              short(1,i)=syncshort
+              short(2,i)=dt2
+              short(3,i)=ipol2
+           
+!  Check to see if lower tone of shorthand pair was found.
+              do j=2,4
+                 i0=i-nint(j*mode65*10.0*(11025.0/4096.0)/df)
+!  Should this be i0 +/- 1, or just i0?
+!  Should we also insist that difference in DT be either 1.5 or -1.5 s?
+                 if(short(1,i0).gt.thresh0) then
+                    fshort=0.001*(i0-16385)*df
+                    noffset=0
+                    if(nqd.eq.1) noffset=nint(1000.0*(fshort-fqso)-mousedf)
+                    if(abs(noffset).le.ntol) then
+!  Keep only the best candidate within ftol.
+!### NB: sync2 was not defined here!
+!                       sync2=syncshort                   !### try this ???
+                       if(fshort-fshort0.le.ftol .and. syncshort.gt.syncshort0 &amp;
+                            .and. nkm.eq.2) km=km-1
+                       if(fshort-fshort0.gt.ftol .or.                     &amp;
+                            syncshort.gt.syncshort0) then
+                          if(km.lt.MAXMSG) km=km+1
+                          sig(km,1)=nfile
+                          sig(km,2)=nutc
+                          sig(km,3)=fshort + 0.5*(nfa+nfb)
+                          sig(km,4)=syncshort
+                          sig(km,5)=dt2
+                          sig(km,6)=45*(ipol2-1)/57.2957795
+                          sig(km,7)=0
+                          sig(km,8)=snr2
+                          sig(km,9)=0
+                          sig(km,10)=0
+!                           sig(km,11)=rms0
+                          sig(km,12)=savg(ipol2,i)
+                          sig(km,13)=0
+                          sig(km,14)=0
+                          sig(km,15)=0
+                          sig(km,16)=0
+!                           sig(km,17)=0
+                          sig(km,18)=0
+                          msg(km)=shmsg0(j)
+                          fshort0=fshort
+                          syncshort0=syncshort
+                          nkm=2
+                       endif
+                    endif
+                 endif
+              enddo
+           endif
+
+! ########################### Search for Normal Messages ###########
+!  Is sync1 above threshold?
+           thresh1=1.0
+!  Use lower thresh1 at fQSO
+           if(nqd.eq.1 .and. ntol.le.100) thresh1=0.
+           noffset=0
+           if(nqd.eq.1) noffset=nint(1000.0*(freq-fqso)-mousedf)
+
+           if(sync1.gt.thresh1 .and. abs(noffset).le.ntol) then
+!  Keep only the best candidate within ftol.
+!  (Am I deleting any good decodes by doing this?)
+              if(freq-freq0.le.ftol .and. sync1.gt.sync10 .and.       &amp;
+                   nkm.eq.1) km=km-1
+              if(freq-freq0.gt.ftol .or. sync1.gt.sync10) then
+                 nflip=nint(flipk)
+                 f00=(i-1)*df          !Freq of detected sync tone (0-96000 Hz)
+                 ntry=ntry+1
+                 if((nqd.eq.1 .and. ntry.ge.40) .or.                  &amp;
+                          (nqd.eq.0 .and. ntry.ge.400)) then
+! Too many calls to decode1a!
+                    write(*,*) '! Signal too strong?  Decoding aborted.'
+                    write(13,*) 'Signal too strong?  Decoding aborted.'
+                    call flush(13)
+                    go to 999
+                 endif
+                 call timer('decode1a',0)
+                 ifreq=i
+                 ikHz=nint(freq+0.5*(nfa+nfb)-foffset)-nfshift
+                 idf=nint(1000.0*(freq+0.5*(nfa+nfb)-foffset-(ikHz+nfshift)))
+                 call decode1a(dd,newdat,f00,nflip,mode65,nfsample,xpol,  &amp;
+                      mycall,hiscall,hisgrid,neme,ndepth,nqd,dphi,        &amp;
+                      nutc,ikHz,idf,ipol,sync2,a,dt,pol,nkv,nhist,qual,decoded)
+                 dt=dt+0.8                           !### empirical tweak
+                 call timer('decode1a',1)
+
+                 if(km.lt.MAXMSG) km=km+1
+                 sig(km,1)=nfile
+                 sig(km,2)=nutc
+                 sig(km,3)=freq + 0.5*(nfa+nfb)
+                 sig(km,4)=sync1
+                 sig(km,5)=dt
+                 sig(km,6)=pol
+                 sig(km,7)=flipk
+                 sig(km,8)=sync2
+                 sig(km,9)=nkv
+                 sig(km,10)=qual
+!                 sig(km,11)=idphi
+                 sig(km,12)=savg(ipol,i)
+                 sig(km,13)=a(1)
+                 sig(km,14)=a(2)
+                 sig(km,15)=a(3)
+                 sig(km,16)=a(4)
+!                     sig(km,17)=a(5)
+                 sig(km,18)=nhist
+                 msg(km)=decoded
+                 freq0=freq
+                 sync10=sync1
+                 nkm=1
+              endif
+           endif
+        endif
+!70      continue
+     enddo
+
+     if(nqd.eq.1) then
+        nwrite=0
+        do k=1,km
+           decoded=msg(k)
+           if(decoded.ne.'                      ') then
+              nutc=sig(k,2)
+              freq=sig(k,3)
+              sync1=sig(k,4)
+              dt=sig(k,5)
+              npol=nint(57.2957795*sig(k,6))
+              flip=sig(k,7)
+              sync2=sig(k,8)
+              nkv=sig(k,9)
+              nqual=sig(k,10)
+!              idphi=nint(sig(k,11))
+              if(flip.lt.0.0) then
+                 do i=22,1,-1
+                    if(decoded(i:i).ne.' ') go to 8
+                 enddo
+                 stop 'Error in message format'
+8                if(i.le.18) decoded(i+2:i+4)='OOO'
+              endif
+              nkHz=nint(freq-foffset)-nfshift
+              mhz=fcenter                         ! ... +fadd ???
+              f0=mhz+0.001*nkHz
+              ndf=nint(1000.0*(freq-foffset-(nkHz+nfshift)))
+              nsync1=sync1
+              nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
+              if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
+                   decoded(1:4).eq.'73  ') nsync2=nsync2-6
+              nwrite=nwrite+1
+              if(nxant.ne.0) then
+                 npol=npol-45
+                 if(npol.lt.0) npol=npol+180
+              endif
+
+!  If Tx station's grid is in decoded message, compute optimum TxPol
+              i1=index(decoded,' ')
+              i2=index(decoded(i1+1:),' ') + i1
+              grid='      '
+              if(i2.ge.8 .and. i2.le.18) grid=decoded(i2+1:i2+4)//'mm'
+              ntxpol=0
+              cp=' '
+              if(xpol) then
+                 if(grid(1:1).ge.'A' .and. grid(1:1).le.'R' .and.           &amp;
+                      grid(2:2).ge.'A' .and. grid(2:2).le.'R' .and.         &amp;
+                      grid(3:3).ge.'0' .and. grid(3:3).le.'9' .and.         &amp;
+                      grid(4:4).ge.'0' .and. grid(4:4).le.'9') then                 
+                    ntxpol=mod(npol-nint(2.0*dpol(mygrid,grid))+720,180)
+                    if(nxant.eq.0) then
+                       cp='H'
+                       if(ntxpol.gt.45 .and. ntxpol.le.135) cp='V'
+                    else
+                       cp='/'
+                       if(ntxpol.ge.90 .and. ntxpol.lt.180) cp='\\'
+                    endif
+                 endif
+              endif
+              
+              if(ndphi.eq.0) then
+                 write(*,1010) nkHz,ndf,npol,nutc,dt,nsync2,    &amp;
+                      decoded,nkv,nqual,ntxpol,cp
+1010             format('!',i3,i5,i4,i5.4,f5.1,i4,2x,a22,i5,i4,i5,1x,a1)
+              else
+                 if(iloop.ge.1) qphi(iloop)=sig(k,10)
+                 write(*,1010) nkHz,ndf,npol,nutc,dt,nsync2,    &amp;
+                      decoded,nkv,nqual,30*iloop
+                 write(27,1011) 30*iloop,nkHz,ndf,npol,nutc,  &amp;
+                      dt,sync2,nkv,nqual,decoded
+1011             format(i3,i4,i5,i4,i5.4,f5.1,f7.1,i3,i5,2x,a22)
+              endif
+           endif
+        enddo
+
+        if(nwrite.eq.0) then
+           write(*,1012) mousefqso,nutc
+1012       format('!',i3,9x,i5.4,' ')
+        endif
+   
+     endif
+     if(ndphi.eq.1 .and.iloop.lt.12) then
+        iloop=iloop+1
+        go to 2
+     endif
+     
+     if(ndphi.eq.1 .and.iloop.eq.12) call getdphi(qphi)
+     if(nagain.eq.1) go to 999
+  enddo
+
+!  Trim the list and produce a sorted index and sizes of groups.
+!  (Should trimlist remove all but best SNR for given UTC and message content?)
+  call trimlist(sig,km,ftol,indx,nsiz,nz)
+
+  do i=1,km
+     done(i)=.false.
+  enddo
+  j=0
+  ilatest=-1
+  do n=1,nz
+     ifile0=0
+     do m=1,nsiz(n)
+        i=indx(j+m)
+        ifile=sig(i,1)
+        if(ifile.gt.ifile0 .and.msg(i).ne.blank) then
+           ilatest=i
+           ifile0=ifile
+        endif
+     enddo
+     i=ilatest
+
+     if(i.ge.1) then
+        if(.not.done(i)) then
+           done(i)=.true.
+           nutc=sig(i,2)
+           freq=sig(i,3)
+           sync1=sig(i,4)
+           dt=sig(i,5)
+           npol=nint(57.2957795*sig(i,6))
+           flip=sig(i,7)
+           sync2=sig(i,8)
+           nkv=sig(i,9)
+           nqual=min(sig(i,10),10.0)
+!                  rms0=sig(i,11)
+           do k=1,5
+              a(k)=sig(i,12+k)
+           enddo
+           nhist=sig(i,18)
+           decoded=msg(i)
+           
+           if(flip.lt.0.0) then
+              do i=22,1,-1
+                 if(decoded(i:i).ne.' ') go to 10
+              enddo
+              stop 'Error in message format'
+10            if(i.le.18) decoded(i+2:i+4)='OOO'
+           endif
+           mhz=fcenter                             !... +fadd ???
+           nkHz=nint(freq-foffset)-nfshift
+           f0=mhz+0.001*nkHz
+           ndf=nint(1000.0*(freq-foffset-(nkHz+nfshift)))
+           ndf0=nint(a(1))
+           ndf1=nint(a(2))
+           ndf2=nint(a(3))
+           nsync1=sync1
+           nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
+           if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
+                decoded(1:4).eq.'73  ') nsync2=nsync2-6
+           if(nxant.ne.0) then
+              npol=npol-45
+              if(npol.lt.0) npol=npol+180
+           endif
+
+!  If Tx station's grid is in decoded message, compute optimum TxPol
+           i1=index(decoded,' ')
+           i2=index(decoded(i1+1:),' ') + i1
+           grid='      '
+           if(i2.ge.8 .and. i2.le.18) grid=decoded(i2+1:i2+4)//'mm'
+           ntxpol=0
+           cp=' '
+           if(xpol) then
+              if(grid(1:1).ge.'A' .and. grid(1:1).le.'R' .and.           &amp;
+                   grid(2:2).ge.'A' .and. grid(2:2).le.'R' .and.         &amp;
+                   grid(3:3).ge.'0' .and. grid(3:3).le.'9' .and.         &amp;
+                   grid(4:4).ge.'0' .and. grid(4:4).le.'9') then                 
+                 ntxpol=mod(npol-nint(2.0*dpol(mygrid,grid))+720,180)
+                 if(nxant.eq.0) then
+                    cp='H'
+                    if(ntxpol.gt.45 .and. ntxpol.le.135) cp='V'
+                 else
+                    cp='/'
+                    if(ntxpol.ge.90 .and. ntxpol.lt.180) cp='\\'
+                 endif
+              endif
+           endif
+           write(26,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
+                nsync2,nutc,decoded,nkv,nqual,nhist,cp
+           write(21,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
+                nsync2,nutc,decoded,nkv,nqual,nhist
+1014       format(f8.3,i5,3i3,f5.1,i4,i3,i4,i5.4,2x,a22,3i3,1x,a1)
+
+        endif
+     endif
+     j=j+nsiz(n)
+  enddo
+  write(26,1015) nutc
+1015 format(39x,i4.4)
+  call flush(21)
+  call flush(26)
+  call display(nkeep,ftol)
+  ndecdone=2
+
+999 close(23)
+  ndphi=0
+  nagain=0
+  mcall3b=mcall3a
+
+  return
+end subroutine map65a


Property changes on: branches/map65/libm65/map65a.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/moon2.f
===================================================================
--- branches/map65/libm65/moon2.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/moon2.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,167 +1,167 @@
-      subroutine moon2(y,m,Day,UT,lon,lat,RA,Dec,topRA,topDec,
-     +  LST,HA,Az,El,dist)
-
-      implicit none
-
-      integer y                           !Year
-      integer m                           !Month
-      integer Day                         !Day
-      real*8 UT                           !UTC in hours
-      real*8 RA,Dec                       !RA and Dec of moon
-
-C  NB: Double caps are single caps in the writeup.
-
-      real*8 NN                           !Longitude of ascending node
-      real*8 i                            !Inclination to the ecliptic
-      real*8 w                            !Argument of perigee
-      real*8 a                            !Semi-major axis
-      real*8 e                            !Eccentricity
-      real*8 MM                           !Mean anomaly
-
-      real*8 v                            !True anomaly
-      real*8 EE                           !Eccentric anomaly
-      real*8 ecl                          !Obliquity of the ecliptic
-
-      real*8 d                            !Ephemeris time argument in days
-      real*8 r                            !Distance to sun, AU
-      real*8 xv,yv                        !x and y coords in ecliptic
-      real*8 lonecl,latecl                !Ecliptic long and lat of moon
-      real*8 xg,yg,zg                     !Ecliptic rectangular coords
-      real*8 Ms                           !Mean anomaly of sun
-      real*8 ws                           !Argument of perihelion of sun
-      real*8 Ls                           !Mean longitude of sun (Ns=0)
-      real*8 Lm                           !Mean longitude of moon
-      real*8 DD                           !Mean elongation of moon
-      real*8 FF                           !Argument of latitude for moon
-      real*8 xe,ye,ze                     !Equatorial geocentric coords of moon
-      real*8 mpar                         !Parallax of moon (r_E / d)
-      real*8 lat,lon                      !Station coordinates on earth
-      real*8 gclat                        !Geocentric latitude
-      real*8 rho                          !Earth radius factor
-      real*8 GMST0,LST,HA
-      real*8 g
-      real*8 topRA,topDec                 !Topocentric coordinates of Moon
-      real*8 Az,El
-      real*8 dist
-
-      real*8 rad,twopi,pi,pio2
-      data rad/57.2957795131d0/,twopi/6.283185307d0/
-
-      d=367*y - 7*(y+(m+9)/12)/4 + 275*m/9 + Day - 730530 + UT/24.d0
-      ecl = 23.4393d0 - 3.563d-7 * d
-
-C  Orbital elements for Moon:  
-      NN = 125.1228d0 - 0.0529538083d0 * d
-      i = 5.1454d0
-      w = mod(318.0634d0 + 0.1643573223d0 * d + 360000.d0,360.d0)
-      a = 60.2666d0
-      e = 0.054900d0
-      MM = mod(115.3654d0 + 13.0649929509d0 * d + 360000.d0,360.d0)
-
-      EE = MM + e*rad*sin(MM/rad) * (1.d0 + e*cos(MM/rad))
-      EE = EE - (EE - e*rad*sin(EE/rad)-MM) / (1.d0 - e*cos(EE/rad))
-      EE = EE - (EE - e*rad*sin(EE/rad)-MM) / (1.d0 - e*cos(EE/rad))
-
-      xv = a * (cos(EE/rad) - e)
-      yv = a * (sqrt(1.d0-e*e) * sin(EE/rad))
-
-      v = mod(rad*atan2(yv,xv)+720.d0,360.d0)
-      r = sqrt(xv*xv + yv*yv)
-
-C  Get geocentric position in ecliptic rectangular coordinates:
-
-      xg = r * (cos(NN/rad)*cos((v+w)/rad) -
-     +          sin(NN/rad)*sin((v+w)/rad)*cos(i/rad))
-      yg = r * (sin(NN/rad)*cos((v+w)/rad) + 
-     +          cos(NN/rad)*sin((v+w)/rad)*cos(i/rad))
-      zg = r * (sin((v+w)/rad)*sin(i/rad))
-
-C  Ecliptic longitude and latitude of moon:
-      lonecl = mod(rad*atan2(yg/rad,xg/rad)+720.d0,360.d0)
-      latecl = rad*atan2(zg/rad,sqrt(xg*xg + yg*yg)/rad)
-
-C  Now include orbital perturbations:
-      Ms = mod(356.0470d0 + 0.9856002585d0 * d + 3600000.d0,360.d0)
-      ws = 282.9404d0 + 4.70935d-5*d
-      Ls = mod(Ms + ws + 720.d0,360.d0)
-      Lm = mod(MM + w + NN+720.d0,360.d0)
-      DD = mod(Lm - Ls + 360.d0,360.d0)
-      FF = mod(Lm - NN + 360.d0,360.d0)
-
-      lonecl = lonecl 
-     +  -1.274d0 * sin((MM-2.d0*DD)/rad)
-     +  +0.658d0 * sin(2.d0*DD/rad)
-     +  -0.186d0 * sin(Ms/rad)
-     +  -0.059d0 * sin((2.d0*MM-2.d0*DD)/rad)
-     +  -0.057d0 * sin((MM-2.d0*DD+Ms)/rad)
-     +  +0.053d0 * sin((MM+2.d0*DD)/rad)
-     +  +0.046d0 * sin((2.d0*DD-Ms)/rad)
-     +  +0.041d0 * sin((MM-Ms)/rad)
-     +  -0.035d0 * sin(DD/rad)
-     +  -0.031d0 * sin((MM+Ms)/rad)
-     +  -0.015d0 * sin((2.d0*FF-2.d0*DD)/rad)
-     +  +0.011d0 * sin((MM-4.d0*DD)/rad)
-
-      latecl = latecl
-     +  -0.173d0 * sin((FF-2.d0*DD)/rad)
-     +  -0.055d0 * sin((MM-FF-2.d0*DD)/rad)
-     +  -0.046d0 * sin((MM+FF-2.d0*DD)/rad)
-     +  +0.033d0 * sin((FF+2.d0*DD)/rad)
-     +  +0.017d0 * sin((2.d0*MM+FF)/rad)
-
-      r = 60.36298d0
-     +  - 3.27746d0*cos(MM/rad)
-     +  - 0.57994d0*cos((MM-2.d0*DD)/rad)
-     +  - 0.46357d0*cos(2.d0*DD/rad)
-     +  - 0.08904d0*cos(2.d0*MM/rad)
-     +  + 0.03865d0*cos((2.d0*MM-2.d0*DD)/rad)
-     +  - 0.03237d0*cos((2.d0*DD-Ms)/rad)
-     +  - 0.02688d0*cos((MM+2.d0*DD)/rad)
-     +  - 0.02358d0*cos((MM-2.d0*DD+Ms)/rad)
-     +  - 0.02030d0*cos((MM-Ms)/rad)
-     +  + 0.01719d0*cos(DD/rad)
-     +  + 0.01671d0*cos((MM+Ms)/rad)
-
-      dist=r*6378.140d0
-
-C  Geocentric coordinates:
-C  Rectangular ecliptic coordinates of the moon:
-
-      xg = r * cos(lonecl/rad)*cos(latecl/rad)
-      yg = r * sin(lonecl/rad)*cos(latecl/rad)
-      zg = r *                 sin(latecl/rad)
-
-C  Rectangular equatorial coordinates of the moon:
-      xe = xg
-      ye = yg*cos(ecl/rad) - zg*sin(ecl/rad)
-      ze = yg*sin(ecl/rad) + zg*cos(ecl/rad)
-   
-C  Right Ascension, Declination:
-      RA = mod(rad*atan2(ye,xe)+360.d0,360.d0)
-      Dec = rad*atan2(ze,sqrt(xe*xe + ye*ye))
-
-C  Now convert to topocentric system:
-      mpar=rad*asin(1.d0/r)
-C      alt_topoc = alt_geoc - mpar*cos(alt_geoc)
-      gclat = lat - 0.1924d0*sin(2.d0*lat/rad)
-      rho = 0.99883d0 + 0.00167d0*cos(2.d0*lat/rad)
-      GMST0 = (Ls + 180.d0)/15.d0
-      LST = mod(GMST0+UT+lon/15.d0+48.d0,24.d0)    !LST in hours
-      HA = 15.d0*LST - RA                          !HA in degrees
-      g = rad*atan(tan(gclat/rad)/cos(HA/rad))
-      topRA = RA - mpar*rho*cos(gclat/rad)*sin(HA/rad)/cos(Dec/rad)
-      topDec = Dec - mpar*rho*sin(gclat/rad)*sin((g-Dec)/rad)/sin(g/rad)
-
-      HA = 15.d0*LST - topRA                       !HA in degrees
-      if(HA.gt.180.d0) HA=HA-360.d0
-      if(HA.lt.-180.d0) HA=HA+360.d0
-
-      pi=0.5d0*twopi
-      pio2=0.5d0*pi
-      call dcoord(pi,pio2-lat/rad,0.d0,lat/rad,ha*twopi/360,
-     +  topDec/rad,az,el)
-      Az=az*rad
-      El=El*rad
-
-      return
-      end
+      subroutine moon2(y,m,Day,UT,lon,lat,RA,Dec,topRA,topDec,
+     +  LST,HA,Az,El,dist)
+
+      implicit none
+
+      integer y                           !Year
+      integer m                           !Month
+      integer Day                         !Day
+      real*8 UT                           !UTC in hours
+      real*8 RA,Dec                       !RA and Dec of moon
+
+C  NB: Double caps are single caps in the writeup.
+
+      real*8 NN                           !Longitude of ascending node
+      real*8 i                            !Inclination to the ecliptic
+      real*8 w                            !Argument of perigee
+      real*8 a                            !Semi-major axis
+      real*8 e                            !Eccentricity
+      real*8 MM                           !Mean anomaly
+
+      real*8 v                            !True anomaly
+      real*8 EE                           !Eccentric anomaly
+      real*8 ecl                          !Obliquity of the ecliptic
+
+      real*8 d                            !Ephemeris time argument in days
+      real*8 r                            !Distance to sun, AU
+      real*8 xv,yv                        !x and y coords in ecliptic
+      real*8 lonecl,latecl                !Ecliptic long and lat of moon
+      real*8 xg,yg,zg                     !Ecliptic rectangular coords
+      real*8 Ms                           !Mean anomaly of sun
+      real*8 ws                           !Argument of perihelion of sun
+      real*8 Ls                           !Mean longitude of sun (Ns=0)
+      real*8 Lm                           !Mean longitude of moon
+      real*8 DD                           !Mean elongation of moon
+      real*8 FF                           !Argument of latitude for moon
+      real*8 xe,ye,ze                     !Equatorial geocentric coords of moon
+      real*8 mpar                         !Parallax of moon (r_E / d)
+      real*8 lat,lon                      !Station coordinates on earth
+      real*8 gclat                        !Geocentric latitude
+      real*8 rho                          !Earth radius factor
+      real*8 GMST0,LST,HA
+      real*8 g
+      real*8 topRA,topDec                 !Topocentric coordinates of Moon
+      real*8 Az,El
+      real*8 dist
+
+      real*8 rad,twopi,pi,pio2
+      data rad/57.2957795131d0/,twopi/6.283185307d0/
+
+      d=367*y - 7*(y+(m+9)/12)/4 + 275*m/9 + Day - 730530 + UT/24.d0
+      ecl = 23.4393d0 - 3.563d-7 * d
+
+C  Orbital elements for Moon:  
+      NN = 125.1228d0 - 0.0529538083d0 * d
+      i = 5.1454d0
+      w = mod(318.0634d0 + 0.1643573223d0 * d + 360000.d0,360.d0)
+      a = 60.2666d0
+      e = 0.054900d0
+      MM = mod(115.3654d0 + 13.0649929509d0 * d + 360000.d0,360.d0)
+
+      EE = MM + e*rad*sin(MM/rad) * (1.d0 + e*cos(MM/rad))
+      EE = EE - (EE - e*rad*sin(EE/rad)-MM) / (1.d0 - e*cos(EE/rad))
+      EE = EE - (EE - e*rad*sin(EE/rad)-MM) / (1.d0 - e*cos(EE/rad))
+
+      xv = a * (cos(EE/rad) - e)
+      yv = a * (sqrt(1.d0-e*e) * sin(EE/rad))
+
+      v = mod(rad*atan2(yv,xv)+720.d0,360.d0)
+      r = sqrt(xv*xv + yv*yv)
+
+C  Get geocentric position in ecliptic rectangular coordinates:
+
+      xg = r * (cos(NN/rad)*cos((v+w)/rad) -
+     +          sin(NN/rad)*sin((v+w)/rad)*cos(i/rad))
+      yg = r * (sin(NN/rad)*cos((v+w)/rad) + 
+     +          cos(NN/rad)*sin((v+w)/rad)*cos(i/rad))
+      zg = r * (sin((v+w)/rad)*sin(i/rad))
+
+C  Ecliptic longitude and latitude of moon:
+      lonecl = mod(rad*atan2(yg/rad,xg/rad)+720.d0,360.d0)
+      latecl = rad*atan2(zg/rad,sqrt(xg*xg + yg*yg)/rad)
+
+C  Now include orbital perturbations:
+      Ms = mod(356.0470d0 + 0.9856002585d0 * d + 3600000.d0,360.d0)
+      ws = 282.9404d0 + 4.70935d-5*d
+      Ls = mod(Ms + ws + 720.d0,360.d0)
+      Lm = mod(MM + w + NN+720.d0,360.d0)
+      DD = mod(Lm - Ls + 360.d0,360.d0)
+      FF = mod(Lm - NN + 360.d0,360.d0)
+
+      lonecl = lonecl 
+     +  -1.274d0 * sin((MM-2.d0*DD)/rad)
+     +  +0.658d0 * sin(2.d0*DD/rad)
+     +  -0.186d0 * sin(Ms/rad)
+     +  -0.059d0 * sin((2.d0*MM-2.d0*DD)/rad)
+     +  -0.057d0 * sin((MM-2.d0*DD+Ms)/rad)
+     +  +0.053d0 * sin((MM+2.d0*DD)/rad)
+     +  +0.046d0 * sin((2.d0*DD-Ms)/rad)
+     +  +0.041d0 * sin((MM-Ms)/rad)
+     +  -0.035d0 * sin(DD/rad)
+     +  -0.031d0 * sin((MM+Ms)/rad)
+     +  -0.015d0 * sin((2.d0*FF-2.d0*DD)/rad)
+     +  +0.011d0 * sin((MM-4.d0*DD)/rad)
+
+      latecl = latecl
+     +  -0.173d0 * sin((FF-2.d0*DD)/rad)
+     +  -0.055d0 * sin((MM-FF-2.d0*DD)/rad)
+     +  -0.046d0 * sin((MM+FF-2.d0*DD)/rad)
+     +  +0.033d0 * sin((FF+2.d0*DD)/rad)
+     +  +0.017d0 * sin((2.d0*MM+FF)/rad)
+
+      r = 60.36298d0
+     +  - 3.27746d0*cos(MM/rad)
+     +  - 0.57994d0*cos((MM-2.d0*DD)/rad)
+     +  - 0.46357d0*cos(2.d0*DD/rad)
+     +  - 0.08904d0*cos(2.d0*MM/rad)
+     +  + 0.03865d0*cos((2.d0*MM-2.d0*DD)/rad)
+     +  - 0.03237d0*cos((2.d0*DD-Ms)/rad)
+     +  - 0.02688d0*cos((MM+2.d0*DD)/rad)
+     +  - 0.02358d0*cos((MM-2.d0*DD+Ms)/rad)
+     +  - 0.02030d0*cos((MM-Ms)/rad)
+     +  + 0.01719d0*cos(DD/rad)
+     +  + 0.01671d0*cos((MM+Ms)/rad)
+
+      dist=r*6378.140d0
+
+C  Geocentric coordinates:
+C  Rectangular ecliptic coordinates of the moon:
+
+      xg = r * cos(lonecl/rad)*cos(latecl/rad)
+      yg = r * sin(lonecl/rad)*cos(latecl/rad)
+      zg = r *                 sin(latecl/rad)
+
+C  Rectangular equatorial coordinates of the moon:
+      xe = xg
+      ye = yg*cos(ecl/rad) - zg*sin(ecl/rad)
+      ze = yg*sin(ecl/rad) + zg*cos(ecl/rad)
+   
+C  Right Ascension, Declination:
+      RA = mod(rad*atan2(ye,xe)+360.d0,360.d0)
+      Dec = rad*atan2(ze,sqrt(xe*xe + ye*ye))
+
+C  Now convert to topocentric system:
+      mpar=rad*asin(1.d0/r)
+C      alt_topoc = alt_geoc - mpar*cos(alt_geoc)
+      gclat = lat - 0.1924d0*sin(2.d0*lat/rad)
+      rho = 0.99883d0 + 0.00167d0*cos(2.d0*lat/rad)
+      GMST0 = (Ls + 180.d0)/15.d0
+      LST = mod(GMST0+UT+lon/15.d0+48.d0,24.d0)    !LST in hours
+      HA = 15.d0*LST - RA                          !HA in degrees
+      g = rad*atan(tan(gclat/rad)/cos(HA/rad))
+      topRA = RA - mpar*rho*cos(gclat/rad)*sin(HA/rad)/cos(Dec/rad)
+      topDec = Dec - mpar*rho*sin(gclat/rad)*sin((g-Dec)/rad)/sin(g/rad)
+
+      HA = 15.d0*LST - topRA                       !HA in degrees
+      if(HA.gt.180.d0) HA=HA-360.d0
+      if(HA.lt.-180.d0) HA=HA+360.d0
+
+      pi=0.5d0*twopi
+      pio2=0.5d0*pi
+      call dcoord(pi,pio2-lat/rad,0.d0,lat/rad,ha*twopi/360,
+     +  topDec/rad,az,el)
+      Az=az*rad
+      El=El*rad
+
+      return
+      end


Property changes on: branches/map65/libm65/moon2.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/moondop.f
===================================================================
--- branches/map65/libm65/moondop.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/moondop.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,73 +1,73 @@
-      subroutine MoonDop(nyear,month,nday,uth4,lon4,lat4,RAMoon4,
-     +  DecMoon4,LST4,HA4,AzMoon4,ElMoon4,vr4,dist4)
-
-      implicit real*8 (a-h,o-z)
-      real*4 uth4                    !UT in hours
-      real*4 lon4                    !West longitude, degrees
-      real*4 lat4                    !Latitude, degrees
-      real*4 RAMoon4                 !Topocentric RA of moon, hours
-      real*4 DecMoon4                !Topocentric Dec of Moon, degrees
-      real*4 LST4                    !Locat sidereal time, hours
-      real*4 HA4                     !Local Hour angle, degrees
-      real*4 AzMoon4                 !Topocentric Azimuth of moon, degrees
-      real*4 ElMoon4                 !Topocentric Elevation of moon, degrees
-      real*4 vr4                     !Radial velocity of moon wrt obs, km/s
-      real*4 dist4                   !Echo time, seconds
-
-      real*8 LST
-      real*8 RME(6)                  !Vector from Earth center to Moon
-      real*8 RAE(6)                  !Vector from Earth center to Obs
-      real*8 RMA(6)                  !Vector from Obs to Moon
-      real*8 pvsun(6)
-      real*8 rme0(6)
-      logical km,bary
-
-      data rad/57.2957795130823d0/,twopi/6.28310530717959d0/
-
-      km=.true.
-      dlat=lat4/rad
-      dlong1=lon4/rad
-      elev1=200.d0
-      call geocentric(dlat,elev1,dlat1,erad1)
-
-      dt=100.d0                       !For numerical derivative, in seconds
-      UT=uth4
-
-C  NB: geodetic latitude used here, but geocentric latitude used when 
-C  determining Earth-rotation contribution to Doppler.
-
-      call moon2(nyear,month,nDay,UT-dt/3600.d0,dlong1*rad,dlat*rad,
-     +  RA,Dec,topRA,topDec,LST,HA,Az0,El0,dist)
-      call toxyz(RA/rad,Dec/rad,dist,rme0)      !Convert to rectangular coords
-
-      call moon2(nyear,month,nDay,UT,dlong1*rad,dlat*rad,
-     +  RA,Dec,topRA,topDec,LST,HA,Az,El,dist)
-      call toxyz(RA/rad,Dec/rad,dist,rme)       !Convert to rectangular coords
-
-      phi=LST*twopi/24.d0
-      call toxyz(phi,dlat1,erad1,rae)           !Gencentric numbers used here!
-      radps=twopi/(86400.d0/1.002737909d0)
-      rae(4)=-rae(2)*radps                      !Vel of Obs wrt Earth center
-      rae(5)=rae(1)*radps
-      rae(6)=0.d0
-
-      do i=1,3
-         rme(i+3)=(rme(i)-rme0(i))/dt
-         rma(i)=rme(i)-rae(i)
-         rma(i+3)=rme(i+3)-rae(i+3)
-      enddo
-
-      call fromxyz(rma,alpha1,delta1,dtopo0)     !Get topocentric coords
-      vr=dot(rma(4),rma)/dtopo0
-
-      RAMoon4=topRA
-      DecMoon4=topDec
-      LST4=LST
-      HA4=HA
-      AzMoon4=Az
-      ElMoon4=El
-      vr4=vr
-      dist4=dist
-
-      return
-      end
+      subroutine MoonDop(nyear,month,nday,uth4,lon4,lat4,RAMoon4,
+     +  DecMoon4,LST4,HA4,AzMoon4,ElMoon4,vr4,dist4)
+
+      implicit real*8 (a-h,o-z)
+      real*4 uth4                    !UT in hours
+      real*4 lon4                    !West longitude, degrees
+      real*4 lat4                    !Latitude, degrees
+      real*4 RAMoon4                 !Topocentric RA of moon, hours
+      real*4 DecMoon4                !Topocentric Dec of Moon, degrees
+      real*4 LST4                    !Locat sidereal time, hours
+      real*4 HA4                     !Local Hour angle, degrees
+      real*4 AzMoon4                 !Topocentric Azimuth of moon, degrees
+      real*4 ElMoon4                 !Topocentric Elevation of moon, degrees
+      real*4 vr4                     !Radial velocity of moon wrt obs, km/s
+      real*4 dist4                   !Echo time, seconds
+
+      real*8 LST
+      real*8 RME(6)                  !Vector from Earth center to Moon
+      real*8 RAE(6)                  !Vector from Earth center to Obs
+      real*8 RMA(6)                  !Vector from Obs to Moon
+      real*8 pvsun(6)
+      real*8 rme0(6)
+      logical km,bary
+
+      data rad/57.2957795130823d0/,twopi/6.28310530717959d0/
+
+      km=.true.
+      dlat=lat4/rad
+      dlong1=lon4/rad
+      elev1=200.d0
+      call geocentric(dlat,elev1,dlat1,erad1)
+
+      dt=100.d0                       !For numerical derivative, in seconds
+      UT=uth4
+
+C  NB: geodetic latitude used here, but geocentric latitude used when 
+C  determining Earth-rotation contribution to Doppler.
+
+      call moon2(nyear,month,nDay,UT-dt/3600.d0,dlong1*rad,dlat*rad,
+     +  RA,Dec,topRA,topDec,LST,HA,Az0,El0,dist)
+      call toxyz(RA/rad,Dec/rad,dist,rme0)      !Convert to rectangular coords
+
+      call moon2(nyear,month,nDay,UT,dlong1*rad,dlat*rad,
+     +  RA,Dec,topRA,topDec,LST,HA,Az,El,dist)
+      call toxyz(RA/rad,Dec/rad,dist,rme)       !Convert to rectangular coords
+
+      phi=LST*twopi/24.d0
+      call toxyz(phi,dlat1,erad1,rae)           !Gencentric numbers used here!
+      radps=twopi/(86400.d0/1.002737909d0)
+      rae(4)=-rae(2)*radps                      !Vel of Obs wrt Earth center
+      rae(5)=rae(1)*radps
+      rae(6)=0.d0
+
+      do i=1,3
+         rme(i+3)=(rme(i)-rme0(i))/dt
+         rma(i)=rme(i)-rae(i)
+         rma(i+3)=rme(i+3)-rae(i+3)
+      enddo
+
+      call fromxyz(rma,alpha1,delta1,dtopo0)     !Get topocentric coords
+      vr=dot(rma(4),rma)/dtopo0
+
+      RAMoon4=topRA
+      DecMoon4=topDec
+      LST4=LST
+      HA4=HA
+      AzMoon4=Az
+      ElMoon4=El
+      vr4=vr
+      dist4=dist
+
+      return
+      end


Property changes on: branches/map65/libm65/moondop.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/nchar.f
===================================================================
--- branches/map65/libm65/nchar.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/nchar.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,23 +1,23 @@
-      function nchar(c)
-
-C  Convert ascii number, letter, or space to 0-36 for callsign packing.
-
-      character c*1
-
-      n=0                                    !Silence compiler warning
-      if(c.ge.'0' .and. c.le.'9') then
-         n=ichar(c)-ichar('0')
-      else if(c.ge.'A' .and. c.le.'Z') then
-         n=ichar(c)-ichar('A') + 10
-      else if(c.ge.'a' .and. c.le.'z') then
-         n=ichar(c)-ichar('a') + 10
-      else if(c.ge.' ') then
-         n=36
-      else
-         Print*,'Invalid character in callsign ',c,' ',ichar(c)
-         stop
-      endif
-      nchar=n
-
-      return
-      end
+      function nchar(c)
+
+C  Convert ascii number, letter, or space to 0-36 for callsign packing.
+
+      character c*1
+
+      n=0                                    !Silence compiler warning
+      if(c.ge.'0' .and. c.le.'9') then
+         n=ichar(c)-ichar('0')
+      else if(c.ge.'A' .and. c.le.'Z') then
+         n=ichar(c)-ichar('A') + 10
+      else if(c.ge.'a' .and. c.le.'z') then
+         n=ichar(c)-ichar('a') + 10
+      else if(c.ge.' ') then
+         n=36
+      else
+         Print*,'Invalid character in callsign ',c,' ',ichar(c)
+         stop
+      endif
+      nchar=n
+
+      return
+      end


Property changes on: branches/map65/libm65/nchar.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/packcall.f
===================================================================
--- branches/map65/libm65/packcall.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/packcall.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,79 +1,79 @@
-      subroutine packcall(callsign,ncall,text)
-
-C  Pack a valid callsign into a 28-bit integer.
-
-      parameter (NBASE=37*36*10*27*27*27)
-      character callsign*6,c*1,tmp*6
-      logical text
-
-      text=.false.
-
-C  Work-around for Swaziland prefix:
-      if(callsign(1:4).eq.'3DA0') callsign='3D0'//callsign(5:6)
-
-      if(callsign(1:3).eq.'CQ ') then
-         ncall=NBASE + 1
-         if(callsign(4:4).ge.'0' .and. callsign(4:4).le.'9' .and. 
-     +      callsign(5:5).ge.'0' .and. callsign(5:5).le.'9' .and. 
-     +      callsign(6:6).ge.'0' .and. callsign(6:6).le.'9') then
-            read(callsign(4:6),*) nfreq
-            ncall=NBASE + 3 + nfreq
-         endif
-         return
-      else if(callsign(1:4).eq.'QRZ ') then
-         ncall=NBASE + 2
-         return
-      else if(callsign(1:3).eq.'DE ') then
-         ncall=267796945
-         return
-      endif
-
-      tmp='      '
-      if(callsign(3:3).ge.'0' .and. callsign(3:3).le.'9') then
-         tmp=callsign
-      else if(callsign(2:2).ge.'0' .and. callsign(2:2).le.'9') then
-         if(callsign(6:6).ne.' ') then
-            text=.true.
-            return
-         endif
-         tmp=' '//callsign(:5)
-      else
-         text=.true.
-         return
-      endif
-
-      do i=1,6
-         c=tmp(i:i)
-         if(c.ge.'a' .and. c.le.'z') 
-     +     tmp(i:i)=char(ichar(c)-ichar('a')+ichar('A'))
-      enddo
-
-      n1=0
-      if((tmp(1:1).ge.'A'.and.tmp(1:1).le.'Z').or.tmp(1:1).eq.' ') n1=1
-      if(tmp(1:1).ge.'0' .and. tmp(1:1).le.'9') n1=1
-      n2=0
-      if(tmp(2:2).ge.'A' .and. tmp(2:2).le.'Z') n2=1
-      if(tmp(2:2).ge.'0' .and. tmp(2:2).le.'9') n2=1
-      n3=0
-      if(tmp(3:3).ge.'0' .and. tmp(3:3).le.'9') n3=1
-      n4=0
-      if((tmp(4:4).ge.'A'.and.tmp(4:4).le.'Z').or.tmp(4:4).eq.' ') n4=1
-      n5=0
-      if((tmp(5:5).ge.'A'.and.tmp(5:5).le.'Z').or.tmp(5:5).eq.' ') n5=1
-      n6=0
-      if((tmp(6:6).ge.'A'.and.tmp(6:6).le.'Z').or.tmp(6:6).eq.' ') n6=1
-
-      if(n1+n2+n3+n4+n5+n6 .ne. 6) then
-         text=.true.
-         return 
-      endif
-
-      ncall=nchar(tmp(1:1))
-      ncall=36*ncall+nchar(tmp(2:2))
-      ncall=10*ncall+nchar(tmp(3:3))
-      ncall=27*ncall+nchar(tmp(4:4))-10
-      ncall=27*ncall+nchar(tmp(5:5))-10
-      ncall=27*ncall+nchar(tmp(6:6))-10
-
-      return
-      end
+      subroutine packcall(callsign,ncall,text)
+
+C  Pack a valid callsign into a 28-bit integer.
+
+      parameter (NBASE=37*36*10*27*27*27)
+      character callsign*6,c*1,tmp*6
+      logical text
+
+      text=.false.
+
+C  Work-around for Swaziland prefix:
+      if(callsign(1:4).eq.'3DA0') callsign='3D0'//callsign(5:6)
+
+      if(callsign(1:3).eq.'CQ ') then
+         ncall=NBASE + 1
+         if(callsign(4:4).ge.'0' .and. callsign(4:4).le.'9' .and. 
+     +      callsign(5:5).ge.'0' .and. callsign(5:5).le.'9' .and. 
+     +      callsign(6:6).ge.'0' .and. callsign(6:6).le.'9') then
+            read(callsign(4:6),*) nfreq
+            ncall=NBASE + 3 + nfreq
+         endif
+         return
+      else if(callsign(1:4).eq.'QRZ ') then
+         ncall=NBASE + 2
+         return
+      else if(callsign(1:3).eq.'DE ') then
+         ncall=267796945
+         return
+      endif
+
+      tmp='      '
+      if(callsign(3:3).ge.'0' .and. callsign(3:3).le.'9') then
+         tmp=callsign
+      else if(callsign(2:2).ge.'0' .and. callsign(2:2).le.'9') then
+         if(callsign(6:6).ne.' ') then
+            text=.true.
+            return
+         endif
+         tmp=' '//callsign(:5)
+      else
+         text=.true.
+         return
+      endif
+
+      do i=1,6
+         c=tmp(i:i)
+         if(c.ge.'a' .and. c.le.'z') 
+     +     tmp(i:i)=char(ichar(c)-ichar('a')+ichar('A'))
+      enddo
+
+      n1=0
+      if((tmp(1:1).ge.'A'.and.tmp(1:1).le.'Z').or.tmp(1:1).eq.' ') n1=1
+      if(tmp(1:1).ge.'0' .and. tmp(1:1).le.'9') n1=1
+      n2=0
+      if(tmp(2:2).ge.'A' .and. tmp(2:2).le.'Z') n2=1
+      if(tmp(2:2).ge.'0' .and. tmp(2:2).le.'9') n2=1
+      n3=0
+      if(tmp(3:3).ge.'0' .and. tmp(3:3).le.'9') n3=1
+      n4=0
+      if((tmp(4:4).ge.'A'.and.tmp(4:4).le.'Z').or.tmp(4:4).eq.' ') n4=1
+      n5=0
+      if((tmp(5:5).ge.'A'.and.tmp(5:5).le.'Z').or.tmp(5:5).eq.' ') n5=1
+      n6=0
+      if((tmp(6:6).ge.'A'.and.tmp(6:6).le.'Z').or.tmp(6:6).eq.' ') n6=1
+
+      if(n1+n2+n3+n4+n5+n6 .ne. 6) then
+         text=.true.
+         return 
+      endif
+
+      ncall=nchar(tmp(1:1))
+      ncall=36*ncall+nchar(tmp(2:2))
+      ncall=10*ncall+nchar(tmp(3:3))
+      ncall=27*ncall+nchar(tmp(4:4))-10
+      ncall=27*ncall+nchar(tmp(5:5))-10
+      ncall=27*ncall+nchar(tmp(6:6))-10
+
+      return
+      end


Property changes on: branches/map65/libm65/packcall.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/packdxcc.f
===================================================================
--- branches/map65/libm65/packdxcc.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/packdxcc.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,64 +1,64 @@
-      subroutine packdxcc(c,ng,ldxcc)
-
-      character*3 c
-      logical ldxcc
-
-      parameter (NZ=303)
-      character*5 pfx(NZ)
-      data pfx/
-     +  '1A   ','1S   ','3A   ','3B6  ','3B8  ','3B9  ','3C   ','3C0  ',
-     +  '3D2  ',                '3DA  ','3V   ','3W   ','3X   ','3Y   ',
-     +          '4J   ','4L   ','4S   ','4U1  ',                '4W   ',
-     +  '4X   ','5A   ','5B   ','5H   ','5N   ','5R   ','5T   ','5U   ',
-     +  '5V   ','5W   ','5X   ','5Z   ','6W   ','6Y   ','7O   ','7P   ',
-     +  '7Q   ','7X   ','8P   ','8Q   ','8R   ','9A   ','9G   ','9H   ',
-     +  '9J   ','9K   ','9L   ','9M2  ','9M6  ','9N   ','9Q   ','9U   ',
-     +  '9V   ','9X   ','9Y   ','A2   ','A3   ','A4   ','A5   ','A6   ',
-     +  'A7   ','A9   ','AP   ','BS7  ','BV   ','BV9  ','BY   ','C2   ',
-     +  'C3   ','C5   ','C6   ','C9   ','CE   ','CE0  ',                
-     +  'CE9  ','CM   ','CN   ','CP   ','CT   ','CT3  ','CU   ','CX   ',
-     +  'CY0  ','CY9  ','D2   ','D4   ','D6   ','DL   ','DU   ','E3   ',
-     +  'E4   ','EA   ','EA6  ','EA8  ','EA9  ','EI   ','EK   ','EL   ',
-     +  'EP   ','ER   ','ES   ','ET   ','EU   ','EX   ','EY   ','EZ   ',
-     +  'F    ','FG   ','FH   ','FJ   ','FK   ',        'FM   ','FO   ',
-     +                          'FP   ','FR   ',                        
-     +  'FT5  ',                'FW   ','FY   ','M    ','MD   ','MI   ',
-     +  'MJ   ','MM   ',        'MU   ','MW   ','H4   ','H40  ','HA   ',
-     +  'HB   ','HB0  ','HC   ','HC8  ','HH   ','HI   ','HK   ','HK0  ',
-     +          'HL   ','HM   ','HP   ','HR   ','HS   ','HV   ','HZ   ',
-     +  'I    ','IG9  ','IS   ','IT9  ','J2   ','J3   ','J5   ','J6   ',
-     +  'J7   ','J8   ','JA   ','JD   ',        'JT   ','JW   ',        
-     +  'JX   ','JY   ','K    ','KG4  ','KH0  ','KH1  ','KH2  ','KH3  ',
-     +  'KH4  ','KH5  ',        'KH6  ','KH7  ','KH8  ','KH9  ','KL   ',
-     +  'KP1  ','KP2  ','KP4  ','KP5  ','LA   ','LU   ','LX   ','LY   ',
-     +  'LZ   ','OA   ','OD   ','OE   ','OH   ','OH0  ','OJ0  ','OK   ',
-     +  'OM   ','ON   ','OX   ','OY   ','OZ   ','P2   ','P4   ','PA   ',
-     +  'PJ2  ','PJ7  ','PY   ','PY0  ',                'PZ   ','R1F  ',
-     +  'R1M  ','S0   ','S2   ','S5   ','S7   ','S9   ','SM   ','SP   ',
-     +  'ST   ','SU   ','SV   ',        'SV5  ','SV9  ','T2   ','T30  ',
-     +  'T31  ','T32  ','T33  ','T5   ','T7   ','T8   ','T9   ','TA   ',
-     +  'TA1  ','TF   ','TG   ','TI   ','TI9  ','TJ   ','TK   ','TL   ',
-     +  'TN   ','TR   ','TT   ','TU   ','TY   ','TZ   ','UA   ','UA2  ',
-     +  'UA9  ','UK   ','UN   ','UR   ','V2   ','V3   ','V4   ','V5   ',
-     +  'V6   ','V7   ','V8   ','VE   ','VK   ','VK0  ',        'VK9  ',
-     +                                          'VP2  ',                
-     +  'VP5  ','VP6  ',        'VP8  ',                                
-     +  'VP9  ','VQ9  ','VR   ','VU   ','VU4  ','VU7  ','XE   ','XF4  ',
-     +  'XT   ','XU   ','XW   ','XX9  ','XZ   ','YA   ','YB   ','YI   ',
-     +  'YJ   ','YK   ','YL   ','YN   ','YO   ','YS   ','YU   ','YV   ',
-     +  'YV0  ','Z2   ','Z3   ','ZA   ','ZB   ','ZC4  ','ZD7  ','ZD8  ',
-     +  'ZD9  ','ZF   ','ZK1  ',        'ZK2  ','ZK3  ','ZL   ','ZL7  ',
-     +  'ZL8  ','ZL9  ','ZP   ','ZS   ','ZS8  '/
-
-      ldxcc=.false.
-      ng=0
-      do i=1,NZ
-         if(pfx(i)(1:3).eq.c) go to 10
-      enddo
-      go to 20
-
- 10   ng=180*180+61+i
-      ldxcc=.true.
-
- 20   return
-      end
+      subroutine packdxcc(c,ng,ldxcc)
+
+      character*3 c
+      logical ldxcc
+
+      parameter (NZ=303)
+      character*5 pfx(NZ)
+      data pfx/
+     +  '1A   ','1S   ','3A   ','3B6  ','3B8  ','3B9  ','3C   ','3C0  ',
+     +  '3D2  ',                '3DA  ','3V   ','3W   ','3X   ','3Y   ',
+     +          '4J   ','4L   ','4S   ','4U1  ',                '4W   ',
+     +  '4X   ','5A   ','5B   ','5H   ','5N   ','5R   ','5T   ','5U   ',
+     +  '5V   ','5W   ','5X   ','5Z   ','6W   ','6Y   ','7O   ','7P   ',
+     +  '7Q   ','7X   ','8P   ','8Q   ','8R   ','9A   ','9G   ','9H   ',
+     +  '9J   ','9K   ','9L   ','9M2  ','9M6  ','9N   ','9Q   ','9U   ',
+     +  '9V   ','9X   ','9Y   ','A2   ','A3   ','A4   ','A5   ','A6   ',
+     +  'A7   ','A9   ','AP   ','BS7  ','BV   ','BV9  ','BY   ','C2   ',
+     +  'C3   ','C5   ','C6   ','C9   ','CE   ','CE0  ',                
+     +  'CE9  ','CM   ','CN   ','CP   ','CT   ','CT3  ','CU   ','CX   ',
+     +  'CY0  ','CY9  ','D2   ','D4   ','D6   ','DL   ','DU   ','E3   ',
+     +  'E4   ','EA   ','EA6  ','EA8  ','EA9  ','EI   ','EK   ','EL   ',
+     +  'EP   ','ER   ','ES   ','ET   ','EU   ','EX   ','EY   ','EZ   ',
+     +  'F    ','FG   ','FH   ','FJ   ','FK   ',        'FM   ','FO   ',
+     +                          'FP   ','FR   ',                        
+     +  'FT5  ',                'FW   ','FY   ','M    ','MD   ','MI   ',
+     +  'MJ   ','MM   ',        'MU   ','MW   ','H4   ','H40  ','HA   ',
+     +  'HB   ','HB0  ','HC   ','HC8  ','HH   ','HI   ','HK   ','HK0  ',
+     +          'HL   ','HM   ','HP   ','HR   ','HS   ','HV   ','HZ   ',
+     +  'I    ','IG9  ','IS   ','IT9  ','J2   ','J3   ','J5   ','J6   ',
+     +  'J7   ','J8   ','JA   ','JD   ',        'JT   ','JW   ',        
+     +  'JX   ','JY   ','K    ','KG4  ','KH0  ','KH1  ','KH2  ','KH3  ',
+     +  'KH4  ','KH5  ',        'KH6  ','KH7  ','KH8  ','KH9  ','KL   ',
+     +  'KP1  ','KP2  ','KP4  ','KP5  ','LA   ','LU   ','LX   ','LY   ',
+     +  'LZ   ','OA   ','OD   ','OE   ','OH   ','OH0  ','OJ0  ','OK   ',
+     +  'OM   ','ON   ','OX   ','OY   ','OZ   ','P2   ','P4   ','PA   ',
+     +  'PJ2  ','PJ7  ','PY   ','PY0  ',                'PZ   ','R1F  ',
+     +  'R1M  ','S0   ','S2   ','S5   ','S7   ','S9   ','SM   ','SP   ',
+     +  'ST   ','SU   ','SV   ',        'SV5  ','SV9  ','T2   ','T30  ',
+     +  'T31  ','T32  ','T33  ','T5   ','T7   ','T8   ','T9   ','TA   ',
+     +  'TA1  ','TF   ','TG   ','TI   ','TI9  ','TJ   ','TK   ','TL   ',
+     +  'TN   ','TR   ','TT   ','TU   ','TY   ','TZ   ','UA   ','UA2  ',
+     +  'UA9  ','UK   ','UN   ','UR   ','V2   ','V3   ','V4   ','V5   ',
+     +  'V6   ','V7   ','V8   ','VE   ','VK   ','VK0  ',        'VK9  ',
+     +                                          'VP2  ',                
+     +  'VP5  ','VP6  ',        'VP8  ',                                
+     +  'VP9  ','VQ9  ','VR   ','VU   ','VU4  ','VU7  ','XE   ','XF4  ',
+     +  'XT   ','XU   ','XW   ','XX9  ','XZ   ','YA   ','YB   ','YI   ',
+     +  'YJ   ','YK   ','YL   ','YN   ','YO   ','YS   ','YU   ','YV   ',
+     +  'YV0  ','Z2   ','Z3   ','ZA   ','ZB   ','ZC4  ','ZD7  ','ZD8  ',
+     +  'ZD9  ','ZF   ','ZK1  ',        'ZK2  ','ZK3  ','ZL   ','ZL7  ',
+     +  'ZL8  ','ZL9  ','ZP   ','ZS   ','ZS8  '/
+
+      ldxcc=.false.
+      ng=0
+      do i=1,NZ
+         if(pfx(i)(1:3).eq.c) go to 10
+      enddo
+      go to 20
+
+ 10   ng=180*180+61+i
+      ldxcc=.true.
+
+ 20   return
+      end


Property changes on: branches/map65/libm65/packdxcc.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/packgrid.f
===================================================================
--- branches/map65/libm65/packgrid.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/packgrid.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,47 +1,47 @@
-      subroutine packgrid(grid,ng,text)
-
-      parameter (NGBASE=180*180)
-      character*4 grid
-      logical text
-
-      text=.false.
-      if(grid.eq.'    ') go to 90                 !Blank grid is OK
-
-C  Test for numerical signal report, etc.
-      if(grid(1:1).eq.'-') then
-         read(grid(2:3),*,err=1,end=1) n
- 1       ng=NGBASE+1+n
-         go to 100
-      else if(grid(1:2).eq.'R-') then
-         read(grid(3:4),*,err=2,end=2) n
- 2       if(n.eq.0) go to 90
-         ng=NGBASE+31+n
-         go to 100
-      else if(grid(1:2).eq.'RO') then
-         ng=NGBASE+62
-         go to 100
-      else if(grid(1:3).eq.'RRR') then
-         ng=NGBASE+63
-         go to 100
-      else if(grid(1:2).eq.'73') then
-         ng=NGBASE+64
-         go to 100
-      endif
-
-      if(grid(1:1).lt.'A' .or. grid(1:1).gt.'R') text=.true.
-      if(grid(2:2).lt.'A' .or. grid(2:2).gt.'R') text=.true.
-      if(grid(3:3).lt.'0' .or. grid(3:3).gt.'9') text=.true.
-      if(grid(4:4).lt.'0' .or. grid(4:4).gt.'9') text=.true.
-      if(text) go to 100
-
-      call grid2deg(grid//'mm',dlong,dlat)
-      long=dlong
-      lat=dlat+ 90.0
-      ng=((long+180)/2)*180 + lat
-      go to 100
-
- 90   ng=NGBASE + 1
-
- 100  return
-      end
-
+      subroutine packgrid(grid,ng,text)
+
+      parameter (NGBASE=180*180)
+      character*4 grid
+      logical text
+
+      text=.false.
+      if(grid.eq.'    ') go to 90                 !Blank grid is OK
+
+C  Test for numerical signal report, etc.
+      if(grid(1:1).eq.'-') then
+         read(grid(2:3),*,err=1,end=1) n
+ 1       ng=NGBASE+1+n
+         go to 100
+      else if(grid(1:2).eq.'R-') then
+         read(grid(3:4),*,err=2,end=2) n
+ 2       if(n.eq.0) go to 90
+         ng=NGBASE+31+n
+         go to 100
+      else if(grid(1:2).eq.'RO') then
+         ng=NGBASE+62
+         go to 100
+      else if(grid(1:3).eq.'RRR') then
+         ng=NGBASE+63
+         go to 100
+      else if(grid(1:2).eq.'73') then
+         ng=NGBASE+64
+         go to 100
+      endif
+
+      if(grid(1:1).lt.'A' .or. grid(1:1).gt.'R') text=.true.
+      if(grid(2:2).lt.'A' .or. grid(2:2).gt.'R') text=.true.
+      if(grid(3:3).lt.'0' .or. grid(3:3).gt.'9') text=.true.
+      if(grid(4:4).lt.'0' .or. grid(4:4).gt.'9') text=.true.
+      if(text) go to 100
+
+      call grid2deg(grid//'mm',dlong,dlat)
+      long=dlong
+      lat=dlat+ 90.0
+      ng=((long+180)/2)*180 + lat
+      go to 100
+
+ 90   ng=NGBASE + 1
+
+ 100  return
+      end
+


Property changes on: branches/map65/libm65/packgrid.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/packmsg.f
===================================================================
--- branches/map65/libm65/packmsg.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/packmsg.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,103 +1,103 @@
-      subroutine packmsg(msg,dat)
-
-      parameter (NBASE=37*36*10*27*27*27)
-      parameter (NBASE2=262178562)
-      character*22 msg
-      integer dat(12)
-      character*12 c1,c2,c2z
-      character*4 c3
-      character*6 grid6
-c      character*3 dxcc                  !Where is DXCC implemented?
-      logical text1,text2,text3
-
-C  Convert all letters to upper case
-      do i=1,22
-         if(msg(i:i).ge.'a' .and. msg(i:i).le.'z') 
-     +     msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
-      enddo
-
-C  See if it's a CQ message
-      if(msg(1:3).eq.'CQ ') then
-         i=3
-C  ... and if so, does it have a reply frequency?
-         if(msg(4:4).ge.'0' .and. msg(4:4).le.'9' .and. 
-     +      msg(5:5).ge.'0' .and. msg(5:5).le.'9' .and. 
-     +      msg(6:6).ge.'0' .and. msg(6:6).le.'9') i=7
-         go to 1
-      endif
-
-      do i=1,22
-         if(msg(i:i).eq.' ') go to 1       !Get 1st blank
-      enddo 
-      go to 10                             !Consider msg as plain text
-      
- 1    ia=i
-      c1=msg(1:ia-1)
-      do i=ia+1,22
-         if(msg(i:i).eq.' ') go to 2       !Get 2nd blank
-      enddo
-      go to 10                             !Consider msg as plain text
-
- 2    ib=i
-      c2=msg(ia+1:ib-1)
-
-      do i=ib+1,22
-         if(msg(i:i).eq.' ') go to 3       !Get 3rd blank
-      enddo
-      go to 10                             !Consider msg as plain text
-
- 3    ic=i
-      c3='    '
-      if(ic.ge.ib+1) c3=msg(ib+1:ic)
-      if(c3.eq.'OOO ') c3='    '           !Strip out the OOO flag
-      call getpfx1(c1,k1,junk)
-      call packcall(c1,nc1,text1)
-      c2z=c2
-      call getpfx1(c2,k2,nv2)
-      call packcall(c2,nc2,text2)
-      if(nv2.eq.0) then
-         if(k1.lt.0 .or. k2.lt.0 .or. k1*k2.ne.0) go to 10
-         if(k2.gt.0) k2=k2+450
-         k=max(k1,k2)
-         if(k.gt.0) then
-            call k2grid(k,grid6)
-            c3=grid6(:4)
-         endif
-      endif
-      call packgrid(c3,ng,text3)
-      if(nv2.eq.0 .and. (.not.text1) .and. (.not.text2) .and. 
-     +        (.not.text3)) go to 20
-      if(nv2.gt.0) then
-         if(nv2.eq.1) then
-            if(c1(1:3).eq.'CQ ')  nc1=262178563 + k2
-            if(c1(1:4).eq.'QRZ ') nc1=264002072 + k2 
-            if(c1(1:3).eq.'DE ')  nc1=265825581 + k2
-         endif
-         if(nv2.eq.2) then
-            if(c1(1:3).eq.'CQ ')  nc1=267649090 + k2
-            if(c1(1:4).eq.'QRZ ') nc1=267698375 + k2
-            if(c1(1:3).eq.'DE ')  nc1=267747660 + k2
-         endif
-         go to 20
-      endif
-
-C  The message will be treated as plain text.
- 10   call packtext(msg,nc1,nc2,ng)
-      ng=ng+32768
-
-C  Encode data into 6-bit words
- 20   dat(1)=iand(ishft(nc1,-22),63)                !6 bits
-      dat(2)=iand(ishft(nc1,-16),63)                !6 bits
-      dat(3)=iand(ishft(nc1,-10),63)                !6 bits
-      dat(4)=iand(ishft(nc1, -4),63)                !6 bits
-      dat(5)=4*iand(nc1,15)+iand(ishft(nc2,-26),3)  !4+2 bits
-      dat(6)=iand(ishft(nc2,-20),63)                !6 bits
-      dat(7)=iand(ishft(nc2,-14),63)                !6 bits
-      dat(8)=iand(ishft(nc2, -8),63)                !6 bits
-      dat(9)=iand(ishft(nc2, -2),63)                !6 bits
-      dat(10)=16*iand(nc2,3)+iand(ishft(ng,-12),15) !2+4 bits
-      dat(11)=iand(ishft(ng,-6),63)
-      dat(12)=iand(ng,63)
-
-      return
-      end
+      subroutine packmsg(msg,dat)
+
+      parameter (NBASE=37*36*10*27*27*27)
+      parameter (NBASE2=262178562)
+      character*22 msg
+      integer dat(12)
+      character*12 c1,c2,c2z
+      character*4 c3
+      character*6 grid6
+c      character*3 dxcc                  !Where is DXCC implemented?
+      logical text1,text2,text3
+
+C  Convert all letters to upper case
+      do i=1,22
+         if(msg(i:i).ge.'a' .and. msg(i:i).le.'z') 
+     +     msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
+      enddo
+
+C  See if it's a CQ message
+      if(msg(1:3).eq.'CQ ') then
+         i=3
+C  ... and if so, does it have a reply frequency?
+         if(msg(4:4).ge.'0' .and. msg(4:4).le.'9' .and. 
+     +      msg(5:5).ge.'0' .and. msg(5:5).le.'9' .and. 
+     +      msg(6:6).ge.'0' .and. msg(6:6).le.'9') i=7
+         go to 1
+      endif
+
+      do i=1,22
+         if(msg(i:i).eq.' ') go to 1       !Get 1st blank
+      enddo 
+      go to 10                             !Consider msg as plain text
+      
+ 1    ia=i
+      c1=msg(1:ia-1)
+      do i=ia+1,22
+         if(msg(i:i).eq.' ') go to 2       !Get 2nd blank
+      enddo
+      go to 10                             !Consider msg as plain text
+
+ 2    ib=i
+      c2=msg(ia+1:ib-1)
+
+      do i=ib+1,22
+         if(msg(i:i).eq.' ') go to 3       !Get 3rd blank
+      enddo
+      go to 10                             !Consider msg as plain text
+
+ 3    ic=i
+      c3='    '
+      if(ic.ge.ib+1) c3=msg(ib+1:ic)
+      if(c3.eq.'OOO ') c3='    '           !Strip out the OOO flag
+      call getpfx1(c1,k1,junk)
+      call packcall(c1,nc1,text1)
+      c2z=c2
+      call getpfx1(c2,k2,nv2)
+      call packcall(c2,nc2,text2)
+      if(nv2.eq.0) then
+         if(k1.lt.0 .or. k2.lt.0 .or. k1*k2.ne.0) go to 10
+         if(k2.gt.0) k2=k2+450
+         k=max(k1,k2)
+         if(k.gt.0) then
+            call k2grid(k,grid6)
+            c3=grid6(:4)
+         endif
+      endif
+      call packgrid(c3,ng,text3)
+      if(nv2.eq.0 .and. (.not.text1) .and. (.not.text2) .and. 
+     +        (.not.text3)) go to 20
+      if(nv2.gt.0) then
+         if(nv2.eq.1) then
+            if(c1(1:3).eq.'CQ ')  nc1=262178563 + k2
+            if(c1(1:4).eq.'QRZ ') nc1=264002072 + k2 
+            if(c1(1:3).eq.'DE ')  nc1=265825581 + k2
+         endif
+         if(nv2.eq.2) then
+            if(c1(1:3).eq.'CQ ')  nc1=267649090 + k2
+            if(c1(1:4).eq.'QRZ ') nc1=267698375 + k2
+            if(c1(1:3).eq.'DE ')  nc1=267747660 + k2
+         endif
+         go to 20
+      endif
+
+C  The message will be treated as plain text.
+ 10   call packtext(msg,nc1,nc2,ng)
+      ng=ng+32768
+
+C  Encode data into 6-bit words
+ 20   dat(1)=iand(ishft(nc1,-22),63)                !6 bits
+      dat(2)=iand(ishft(nc1,-16),63)                !6 bits
+      dat(3)=iand(ishft(nc1,-10),63)                !6 bits
+      dat(4)=iand(ishft(nc1, -4),63)                !6 bits
+      dat(5)=4*iand(nc1,15)+iand(ishft(nc2,-26),3)  !4+2 bits
+      dat(6)=iand(ishft(nc2,-20),63)                !6 bits
+      dat(7)=iand(ishft(nc2,-14),63)                !6 bits
+      dat(8)=iand(ishft(nc2, -8),63)                !6 bits
+      dat(9)=iand(ishft(nc2, -2),63)                !6 bits
+      dat(10)=16*iand(nc2,3)+iand(ishft(ng,-12),15) !2+4 bits
+      dat(11)=iand(ishft(ng,-6),63)
+      dat(12)=iand(ng,63)
+
+      return
+      end


Property changes on: branches/map65/libm65/packmsg.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/packtext.f
===================================================================
--- branches/map65/libm65/packtext.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/packtext.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,47 +1,47 @@
-      subroutine packtext(msg,nc1,nc2,nc3)
-
-      parameter (MASK28=2**28 - 1)
-      character*13 msg
-      character*44 c
-      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?'/
-
-      nc1=0
-      nc2=0
-      nc3=0
-
-      do i=1,5                                !First 5 characters in nc1
-         do j=1,44                            !Get character code
-            if(msg(i:i).eq.c(j:j)) go to 10
-         enddo
-         j=37
- 10      j=j-1                                !Codes should start at zero
-         nc1=42*nc1 + j
-      enddo
-
-      do i=6,10                               !Characters 6-10 in nc2
-         do j=1,44                            !Get character code
-            if(msg(i:i).eq.c(j:j)) go to 20
-         enddo
-         j=37
- 20      j=j-1                                !Codes should start at zero
-         nc2=42*nc2 + j
-      enddo
-
-      do i=11,13                              !Characters 11-13 in nc3
-         do j=1,44                            !Get character code
-            if(msg(i:i).eq.c(j:j)) go to 30
-         enddo
-         j=37
- 30      j=j-1                                !Codes should start at zero
-         nc3=42*nc3 + j
-      enddo
-
-C  We now have used 17 bits in nc3.  Must move one each to nc1 and nc2.
-      nc1=nc1+nc1
-      if(iand(nc3,32768).ne.0) nc1=nc1+1
-      nc2=nc2+nc2
-      if(iand(nc3,65536).ne.0) nc2=nc2+1
-      nc3=iand(nc3,32767)
-
-      return
-      end
+      subroutine packtext(msg,nc1,nc2,nc3)
+
+      parameter (MASK28=2**28 - 1)
+      character*13 msg
+      character*44 c
+      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?'/
+
+      nc1=0
+      nc2=0
+      nc3=0
+
+      do i=1,5                                !First 5 characters in nc1
+         do j=1,44                            !Get character code
+            if(msg(i:i).eq.c(j:j)) go to 10
+         enddo
+         j=37
+ 10      j=j-1                                !Codes should start at zero
+         nc1=42*nc1 + j
+      enddo
+
+      do i=6,10                               !Characters 6-10 in nc2
+         do j=1,44                            !Get character code
+            if(msg(i:i).eq.c(j:j)) go to 20
+         enddo
+         j=37
+ 20      j=j-1                                !Codes should start at zero
+         nc2=42*nc2 + j
+      enddo
+
+      do i=11,13                              !Characters 11-13 in nc3
+         do j=1,44                            !Get character code
+            if(msg(i:i).eq.c(j:j)) go to 30
+         enddo
+         j=37
+ 30      j=j-1                                !Codes should start at zero
+         nc3=42*nc3 + j
+      enddo
+
+C  We now have used 17 bits in nc3.  Must move one each to nc1 and nc2.
+      nc1=nc1+nc1
+      if(iand(nc3,32768).ne.0) nc1=nc1+1
+      nc2=nc2+nc2
+      if(iand(nc3,65536).ne.0) nc2=nc2+1
+      nc3=iand(nc3,32767)
+
+      return
+      end


Property changes on: branches/map65/libm65/packtext.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/pctile.f
===================================================================
--- branches/map65/libm65/pctile.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/pctile.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,13 +1,13 @@
-      subroutine pctile(x,tmp,nmax,npct,xpct)
-      real x(nmax),tmp(nmax)
-
-      do i=1,nmax
-         tmp(i)=x(i)
-      enddo
-      call sort(nmax,tmp)
-      j=nint(nmax*0.01*npct)
-      if(j.lt.1) j=1
-      xpct=tmp(j)
-
-      return
-      end
+      subroutine pctile(x,tmp,nmax,npct,xpct)
+      real x(nmax),tmp(nmax)
+
+      do i=1,nmax
+         tmp(i)=x(i)
+      enddo
+      call sort(nmax,tmp)
+      j=nint(nmax*0.01*npct)
+      if(j.lt.1) j=1
+      xpct=tmp(j)
+
+      return
+      end


Property changes on: branches/map65/libm65/pctile.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/pfx.f
===================================================================
--- branches/map65/libm65/pfx.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/pfx.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,50 +1,50 @@
-      parameter (NZ=339)                     !Total number of prefixes
-      parameter (NZ2=12)                     !Total number of suffixes
-      character*1 sfx(NZ2)
-      character*5 pfx(NZ)
-
-      data sfx/'P','0','1','2','3','4','5','6','7','8','9','A'/
-      data pfx/
-     +  '1A   ','1S   ','3A   ','3B6  ','3B8  ','3B9  ','3C   ','3C0  ',
-     +  '3D2  ','3D2C ','3D2R ','3DA  ','3V   ','3W   ','3X   ','3Y   ',
-     +  '3YB  ','3YP  ','4J   ','4L   ','4S   ','4U1I ','4U1U ','4W   ',
-     +  '4X   ','5A   ','5B   ','5H   ','5N   ','5R   ','5T   ','5U   ',
-     +  '5V   ','5W   ','5X   ','5Z   ','6W   ','6Y   ','7O   ','7P   ',
-     +  '7Q   ','7X   ','8P   ','8Q   ','8R   ','9A   ','9G   ','9H   ',
-     +  '9J   ','9K   ','9L   ','9M2  ','9M6  ','9N   ','9Q   ','9U   ',
-     +  '9V   ','9X   ','9Y   ','A2   ','A3   ','A4   ','A5   ','A6   ',
-     +  'A7   ','A9   ','AP   ','BS7  ','BV   ','BV9  ','BY   ','C2   ',
-     +  'C3   ','C5   ','C6   ','C9   ','CE   ','CE0X ','CE0Y ','CE0Z ',
-     +  'CE9  ','CM   ','CN   ','CP   ','CT   ','CT3  ','CU   ','CX   ',
-     +  'CY0  ','CY9  ','D2   ','D4   ','D6   ','DL   ','DU   ','E3   ',
-     +  'E4   ','EA   ','EA6  ','EA8  ','EA9  ','EI   ','EK   ','EL   ',
-     +  'EP   ','ER   ','ES   ','ET   ','EU   ','EX   ','EY   ','EZ   ',
-     +  'F    ','FG   ','FH   ','FJ   ','FK   ','FKC  ','FM   ','FO   ',
-     +  'FOA  ','FOC  ','FOM  ','FP   ','FR   ','FRG  ','FRJ  ','FRT  ',
-     +  'FT5W ','FT5X ','FT5Z ','FW   ','FY   ','M    ','MD   ','MI   ',
-     +  'MJ   ','MM   ',        'MU   ','MW   ','H4   ','H40  ','HA   ',
-     +  'HB   ','HB0  ','HC   ','HC8  ','HH   ','HI   ','HK   ','HK0A ',
-     +  'HK0M ','HL   ','HM   ','HP   ','HR   ','HS   ','HV   ','HZ   ',
-     +  'I    ','IS   ','IS0  ',        'J2   ','J3   ','J5   ','J6   ',
-     +  'J7   ','J8   ','JA   ','JDM  ','JDO  ','JT   ','JW   ',        
-     +  'JX   ','JY   ','K    ','KG4  ','KH0  ','KH1  ','KH2  ','KH3  ',
-     +  'KH4  ','KH5  ','KH5K ','KH6  ','KH7  ','KH8  ','KH9  ','KL   ',
-     +  'KP1  ','KP2  ','KP4  ','KP5  ','LA   ','LU   ','LX   ','LY   ',
-     +  'LZ   ','OA   ','OD   ','OE   ','OH   ','OH0  ','OJ0  ','OK   ',
-     +  'OM   ','ON   ','OX   ','OY   ','OZ   ','P2   ','P4   ','PA   ',
-     +  'PJ2  ','PJ7  ','PY   ','PY0F ','PT0S ','PY0T ','PZ   ','R1F  ',
-     +  'R1M  ','S0   ','S2   ','S5   ','S7   ','S9   ','SM   ','SP   ',
-     +  'ST   ','SU   ','SV   ','SVA  ','SV5  ','SV9  ','T2   ','T30  ',
-     +  'T31  ','T32  ','T33  ','T5   ','T7   ','T8   ','T9   ','TA   ',
-     +          'TF   ','TG   ','TI   ','TI9  ','TJ   ','TK   ','TL   ',
-     +  'TN   ','TR   ','TT   ','TU   ','TY   ','TZ   ','UA   ','UA2  ',
-     +  'UA9  ','UK   ','UN   ','UR   ','V2   ','V3   ','V4   ','V5   ',
-     +  'V6   ','V7   ','V8   ','VE   ','VK   ','VK0H ','VK0M ','VK9C ',
-     +  'VK9L ','VK9M ','VK9N ','VK9W ','VK9X ','VP2E ','VP2M ','VP2V ',
-     +  'VP5  ','VP6  ','VP6D ','VP8  ','VP8G ','VP8H ','VP8O ','VP8S ',
-     +  'VP9  ','VQ9  ','VR   ','VU   ','VU4  ','VU7  ','XE   ','XF4  ',
-     +  'XT   ','XU   ','XW   ','XX9  ','XZ   ','YA   ','YB   ','YI   ',
-     +  'YJ   ','YK   ','YL   ','YN   ','YO   ','YS   ','YU   ','YV   ',
-     +  'YV0  ','Z2   ','Z3   ','ZA   ','ZB   ','ZC4  ','ZD7  ','ZD8  ',
-     +  'ZD9  ','ZF   ','ZK1N ','ZK1S ','ZK2  ','ZK3  ','ZL   ','ZL7  ',
-     +  'ZL8  ','ZL9  ','ZP   ','ZS   ','ZS8  ','KC4  ','E5   '/
+      parameter (NZ=339)                     !Total number of prefixes
+      parameter (NZ2=12)                     !Total number of suffixes
+      character*1 sfx(NZ2)
+      character*5 pfx(NZ)
+
+      data sfx/'P','0','1','2','3','4','5','6','7','8','9','A'/
+      data pfx/
+     +  '1A   ','1S   ','3A   ','3B6  ','3B8  ','3B9  ','3C   ','3C0  ',
+     +  '3D2  ','3D2C ','3D2R ','3DA  ','3V   ','3W   ','3X   ','3Y   ',
+     +  '3YB  ','3YP  ','4J   ','4L   ','4S   ','4U1I ','4U1U ','4W   ',
+     +  '4X   ','5A   ','5B   ','5H   ','5N   ','5R   ','5T   ','5U   ',
+     +  '5V   ','5W   ','5X   ','5Z   ','6W   ','6Y   ','7O   ','7P   ',
+     +  '7Q   ','7X   ','8P   ','8Q   ','8R   ','9A   ','9G   ','9H   ',
+     +  '9J   ','9K   ','9L   ','9M2  ','9M6  ','9N   ','9Q   ','9U   ',
+     +  '9V   ','9X   ','9Y   ','A2   ','A3   ','A4   ','A5   ','A6   ',
+     +  'A7   ','A9   ','AP   ','BS7  ','BV   ','BV9  ','BY   ','C2   ',
+     +  'C3   ','C5   ','C6   ','C9   ','CE   ','CE0X ','CE0Y ','CE0Z ',
+     +  'CE9  ','CM   ','CN   ','CP   ','CT   ','CT3  ','CU   ','CX   ',
+     +  'CY0  ','CY9  ','D2   ','D4   ','D6   ','DL   ','DU   ','E3   ',
+     +  'E4   ','EA   ','EA6  ','EA8  ','EA9  ','EI   ','EK   ','EL   ',
+     +  'EP   ','ER   ','ES   ','ET   ','EU   ','EX   ','EY   ','EZ   ',
+     +  'F    ','FG   ','FH   ','FJ   ','FK   ','FKC  ','FM   ','FO   ',
+     +  'FOA  ','FOC  ','FOM  ','FP   ','FR   ','FRG  ','FRJ  ','FRT  ',
+     +  'FT5W ','FT5X ','FT5Z ','FW   ','FY   ','M    ','MD   ','MI   ',
+     +  'MJ   ','MM   ',        'MU   ','MW   ','H4   ','H40  ','HA   ',
+     +  'HB   ','HB0  ','HC   ','HC8  ','HH   ','HI   ','HK   ','HK0A ',
+     +  'HK0M ','HL   ','HM   ','HP   ','HR   ','HS   ','HV   ','HZ   ',
+     +  'I    ','IS   ','IS0  ',        'J2   ','J3   ','J5   ','J6   ',
+     +  'J7   ','J8   ','JA   ','JDM  ','JDO  ','JT   ','JW   ',        
+     +  'JX   ','JY   ','K    ','KG4  ','KH0  ','KH1  ','KH2  ','KH3  ',
+     +  'KH4  ','KH5  ','KH5K ','KH6  ','KH7  ','KH8  ','KH9  ','KL   ',
+     +  'KP1  ','KP2  ','KP4  ','KP5  ','LA   ','LU   ','LX   ','LY   ',
+     +  'LZ   ','OA   ','OD   ','OE   ','OH   ','OH0  ','OJ0  ','OK   ',
+     +  'OM   ','ON   ','OX   ','OY   ','OZ   ','P2   ','P4   ','PA   ',
+     +  'PJ2  ','PJ7  ','PY   ','PY0F ','PT0S ','PY0T ','PZ   ','R1F  ',
+     +  'R1M  ','S0   ','S2   ','S5   ','S7   ','S9   ','SM   ','SP   ',
+     +  'ST   ','SU   ','SV   ','SVA  ','SV5  ','SV9  ','T2   ','T30  ',
+     +  'T31  ','T32  ','T33  ','T5   ','T7   ','T8   ','T9   ','TA   ',
+     +          'TF   ','TG   ','TI   ','TI9  ','TJ   ','TK   ','TL   ',
+     +  'TN   ','TR   ','TT   ','TU   ','TY   ','TZ   ','UA   ','UA2  ',
+     +  'UA9  ','UK   ','UN   ','UR   ','V2   ','V3   ','V4   ','V5   ',
+     +  'V6   ','V7   ','V8   ','VE   ','VK   ','VK0H ','VK0M ','VK9C ',
+     +  'VK9L ','VK9M ','VK9N ','VK9W ','VK9X ','VP2E ','VP2M ','VP2V ',
+     +  'VP5  ','VP6  ','VP6D ','VP8  ','VP8G ','VP8H ','VP8O ','VP8S ',
+     +  'VP9  ','VQ9  ','VR   ','VU   ','VU4  ','VU7  ','XE   ','XF4  ',
+     +  'XT   ','XU   ','XW   ','XX9  ','XZ   ','YA   ','YB   ','YI   ',
+     +  'YJ   ','YK   ','YL   ','YN   ','YO   ','YS   ','YU   ','YV   ',
+     +  'YV0  ','Z2   ','Z3   ','ZA   ','ZB   ','ZC4  ','ZD7  ','ZD8  ',
+     +  'ZD9  ','ZF   ','ZK1N ','ZK1S ','ZK2  ','ZK3  ','ZL   ','ZL7  ',
+     +  'ZL8  ','ZL9  ','ZP   ','ZS   ','ZS8  ','KC4  ','E5   '/


Property changes on: branches/map65/libm65/pfx.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/pfxdump.f
===================================================================
--- branches/map65/libm65/pfxdump.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/pfxdump.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,13 +1,13 @@
-      subroutine pfxdump(fname)
-      character*(*) fname
-      include 'pfx.f'
-
-      open(11,file=fname,status='unknown')
-      write(11,1001) sfx
- 1001 format('Supported Suffixes:'/(11('/',a1,2x)))
-      write(11,1002) pfx
- 1002 format(/'Supported Add-On DXCC Prefixes:'/(15(a5,1x)))
-      close(11)
-
-      return
-      end
+      subroutine pfxdump(fname)
+      character*(*) fname
+      include 'pfx.f'
+
+      open(11,file=fname,status='unknown')
+      write(11,1001) sfx
+ 1001 format('Supported Suffixes:'/(11('/',a1,2x)))
+      write(11,1002) pfx
+ 1002 format(/'Supported Add-On DXCC Prefixes:'/(15(a5,1x)))
+      close(11)
+
+      return
+      end


Property changes on: branches/map65/libm65/pfxdump.f
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: branches/map65/libm65/ptt.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/ptt_unix.c
===================================================================
--- branches/map65/libm65/ptt_unix.c	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/ptt_unix.c	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,391 +1,391 @@
-/*
- * WSJT is Copyright (c) 2001-2006 by Joseph H. Taylor, Jr., K1JT, 
- * and is licensed under the GNU General Public License (GPL).
- *
- * Code used from cwdaemon for parallel port ptt only.
- *
- * cwdaemon - morse sounding daemon for the parallel or serial port
- * Copyright (C) 2002 -2005 Joop Stakenborg &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">pg4i at amsat.org</A>&gt;
- *                       and many authors, see the AUTHORS file.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-# if HAVE_STDIO_H
-# include &lt;stdio.h&gt;
-#endif
-#if STDC_HEADERS
-# include &lt;stdlib.h&gt;
-# include &lt;stddef.h&gt;
-#else
-# if HAVE_STDLIB_H
-#  include &lt;stdlib.h&gt;
-# endif
-#endif
-#if HAVE_UNISTD_H
-# include &lt;unistd.h&gt;
-#endif
-#if HAVE_SYS_IOCTL_H
-# include &lt;sys/ioctl.h&gt;
-#endif
-#if HAVE_FCNTL_H
-# include &lt;fcntl.h&gt;
-#endif
-
-#ifdef HAVE_LINUX_PPDEV_H
-# include &lt;linux/ppdev.h&gt;
-# include &lt;linux/parport.h&gt;
-#endif
-#ifdef HAVE_DEV_PPBUS_PPI_H
-# include &lt;dev/ppbus/ppi.h&gt;
-# include &lt;dev/ppbus/ppbconf.h&gt;
-#endif
-
-int lp_reset (int fd);
-int lp_ptt (int fd, int onoff);
-
-#ifdef HAVE_SYS_STAT_H
-# include &lt;sys/stat.h&gt;
-#endif
-#if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG)
-# include &lt;sys/param.h&gt;
-#endif
-
-#include &lt;string.h&gt;
-/* parport functions */
-
-int dev_is_parport(int fd);
-int ptt_parallel(int fd, int *ntx, int *iptt);
-int ptt_serial(int fd, int *ntx, int *iptt);
-
-int fd=-1;		/* Used for both serial and parallel */
-
-/*
- * ptt_
- *
- * generic unix PTT routine called from Fortran
- *
- * Inputs	
- * unused	Unused, to satisfy old windows calling convention
- * ptt_port	device name serial or parallel
- * ntx		pointer to fortran command on or off
- * iptt		pointer to fortran command status on or off
- * Returns	- non 0 if error
-*/
-
-/* Tiny state machine */
-#define STATE_PORT_CLOSED		0
-#define STATE_PORT_OPEN_PARALLEL	1
-#define STATE_PORT_OPEN_SERIAL		2
-
-//int ptt_(int *unused, char *ptt_port, int *ntx, int *iptt)
-int ptt_(int *unused, int *ntx, int *iptt)
-{
-  static int state=0;
-  char *p;
-
-// ### Temporary:
-  char* ptt_port;
-  if(*unused != -99) {
-    *iptt=*ntx;
-    return 0;
-  }
-// ###
-
-  /* In the very unlikely event of a NULL pointer, just return.
-   * Yes, I realise this should not be possible in WSJT.
-   */
-  if (ptt_port == NULL) {
-    *iptt = *ntx;
-    return (0);
-  }
-    
-  switch (state) {
-  case STATE_PORT_CLOSED:
-
-     /* Remove trailing ' ' */
-    if ((p = strchr(ptt_port, ' ')) != NULL)
-      *p = '\0';
-
-    /* If all that is left is a '\0' then also just return */
-    if (*ptt_port == '\0') {
-      *iptt = *ntx;
-      return(0);
-    }
-
-    if ((fd = open(ptt_port, O_RDWR|O_NONBLOCK)) &lt; 0) {
-	fprintf(stderr, &quot;Can't open %s.\n&quot;, ptt_port);
-	return (1);
-    }
-
-    if (dev_is_parport(fd)) {
-      state = STATE_PORT_OPEN_PARALLEL;
-      lp_reset(fd);
-      ptt_parallel(fd, ntx, iptt);
-    } else {
-      state = STATE_PORT_OPEN_SERIAL;
-      ptt_serial(fd, ntx, iptt);
-    }
-    break;
-
-  case STATE_PORT_OPEN_PARALLEL:
-    ptt_parallel(fd, ntx, iptt);
-    break;
-
-  case STATE_PORT_OPEN_SERIAL:
-    ptt_serial(fd, ntx, iptt);
-    break;
-
-  default:
-    close(fd);
-    fd = -1;
-    state = STATE_PORT_CLOSED;
-    break;
-  }
-  return(0);
-}
-
-/*
- * ptt_serial
- *
- * generic serial unix PTT routine called indirectly from Fortran
- *
- * fd		- already opened file descriptor
- * ntx		- pointer to fortran command on or off
- * iptt		- pointer to fortran command status on or off
- */
-
-int
-ptt_serial(int fd, int *ntx, int *iptt)
-{
-  int control = TIOCM_RTS | TIOCM_DTR;
-
-  if(*ntx) {
-    ioctl(fd, TIOCMBIS, &amp;control);               /* Set DTR and RTS */
-    *iptt = 1;
-  } else {
-    ioctl(fd, TIOCMBIC, &amp;control);
-    *iptt = 0;
-  }
-  return(0);
-}
-
-
-/* parport functions */
-
-/*
- * dev_is_parport(fd):
- *
- * inputs	- Already open fd
- * output	- 1 if parallel port, 0 if not
- * side effects	- Unfortunately, this is platform specific.
- */
-
-#if defined(HAVE_LINUX_PPDEV_H)                /* Linux (ppdev) */
-
-int
-dev_is_parport(int fd)
-{
-       struct stat st;
-       int m;
-
-       if ((fstat(fd, &amp;st) == -1) ||
-	   ((st.st_mode &amp; S_IFMT) != S_IFCHR) ||
-	   (ioctl(fd, PPGETMODE, &amp;m) == -1))
-	 return(0);
-
-       return(1);
-}
-
-#elif defined(HAVE_DEV_PPBUS_PPI_H)    /* FreeBSD (ppbus/ppi) */
-
-int
-dev_is_parport(int fd)
-{
-       struct stat st;
-       unsigned char c;
-
-       if ((fstat(fd, &amp;st) == -1) ||
-	   ((st.st_mode &amp; S_IFMT) != S_IFCHR) ||
-	   (ioctl(fd, PPISSTATUS, &amp;c) == -1))
-	 return(0);
-
-       return(1);
-}
-
-#else                                  /* Fallback (nothing) */
-
-int
-dev_is_parport(int fd)
-{
-       return(0);
-}
-
-#endif
-/* Linux wrapper around PPFCONTROL */
-#ifdef HAVE_LINUX_PPDEV_H
-static void
-parport_control (int fd, unsigned char controlbits, int values)
-{
-	struct ppdev_frob_struct frob;
-	frob.mask = controlbits;
-	frob.val = values;
-
-	if (ioctl (fd, PPFCONTROL, &amp;frob) == -1)
-	{
-		fprintf(stderr, &quot;Parallel port PPFCONTROL&quot;);
-		exit (1);
-	}
-}
-#endif
-
-/* FreeBSD wrapper around PPISCTRL */
-#ifdef HAVE_DEV_PPBUS_PPI_H
-static void
-parport_control (int fd, unsigned char controlbits, int values)
-{
-	unsigned char val;
-
-	if (ioctl (fd, PPIGCTRL, &amp;val) == -1)
-	{
-		fprintf(stderr, &quot;Parallel port PPIGCTRL&quot;);
-		exit (1);
-	}
-
-	val &amp;= ~controlbits;
-	val |= values;
-
-	if (ioctl (fd, PPISCTRL, &amp;val) == -1)
-	{
-		fprintf(stderr, &quot;Parallel port PPISCTRL&quot;);
-		exit (1);
-	}
-}
-#endif
-
-/* Initialise a parallel port, given open fd */
-int
-lp_init (int fd)
-{
-#ifdef HAVE_LINUX_PPDEV_H
-	int mode;
-#endif
-
-#ifdef HAVE_LINUX_PPDEV_H
-	mode = PARPORT_MODE_PCSPP;
-
-	if (ioctl (fd, PPSETMODE, &amp;mode) == -1)
-	{
-		fprintf(stderr, &quot;Setting parallel port mode&quot;);
-		close (fd);
-		return(-1);
-	}
-
-	if (ioctl (fd, PPEXCL, NULL) == -1)
-	{
-		fprintf(stderr, &quot;Parallel port is already in use.\n&quot;);
-		close (fd);
-		return(-1);
-	}
-	if (ioctl (fd, PPCLAIM, NULL) == -1)
-	{
-		fprintf(stderr, &quot;Claiming parallel port.\n&quot;);
-		fprintf(stderr, &quot;HINT: did you unload the lp kernel module?&quot;);
-		close (fd);
-		return(-1);
-	}
-
-	/* Enable CW &amp; PTT - /STROBE bit (pin 1) */
-	parport_control (fd, PARPORT_CONTROL_STROBE, PARPORT_CONTROL_STROBE);
-#endif
-#ifdef HAVE_DEV_PPBUS_PPI_H
-	parport_control (fd, STROBE, STROBE);
-#endif
-	lp_reset (fd);
-	return(0);
-}
-
-/* release ppdev and close port */
-int
-lp_free (int fd)
-{
-#ifdef HAVE_LINUX_PPDEV_H
-	lp_reset (fd);
-
-	/* Disable CW &amp; PTT - /STROBE bit (pin 1) */
-	parport_control (fd, PARPORT_CONTROL_STROBE, 0);
-
-	ioctl (fd, PPRELEASE);
-#endif
-#ifdef HAVE_DEV_PPBUS_PPI_H
-	/* Disable CW &amp; PTT - /STROBE bit (pin 1) */
-	parport_control (fd, STROBE, 0);
-#endif
-	close (fd);
-	return(0);
-}
-
-/* set to a known state */
-int
-lp_reset (int fd)
-{
-#if defined (HAVE_LINUX_PPDEV_H) || defined (HAVE_DEV_PPBUS_PPI_H)
-	lp_ptt (fd, 0);
-#endif
-	return(0);
-}
-
-/* SSB PTT keying - /INIT bit (pin 16) (inverted) */
-int
-lp_ptt (int fd, int onoff)
-{
-#ifdef HAVE_LINUX_PPDEV_H
-	if (onoff == 1)
-		parport_control (fd, PARPORT_CONTROL_INIT,
-				PARPORT_CONTROL_INIT);
-	else
-		parport_control (fd, PARPORT_CONTROL_INIT, 0);
-#endif
-#ifdef HAVE_DEV_PPBUS_PPI_H
-	if (onoff == 1)
-		parport_control (fd, nINIT,
-				nINIT);
-	else
-		parport_control (fd, nINIT, 0);
-#endif
-	return(0);
-}
-
-/*
- * ptt_parallel
- *
- * generic parallel unix PTT routine called indirectly from Fortran
- *
- * fd		- already opened file descriptor
- * ntx		- pointer to fortran command on or off
- * iptt		- pointer to fortran command status on or off
- */
-
-int
-ptt_parallel(int fd, int *ntx, int *iptt)
-{
-  if(*ntx) {
-    lp_ptt(fd, 1);
-    *iptt=1;
-  }  else {
-    lp_ptt(fd, 0);
-    *iptt=0;
-  }
-  return(0);
-}
+/*
+ * WSJT is Copyright (c) 2001-2006 by Joseph H. Taylor, Jr., K1JT, 
+ * and is licensed under the GNU General Public License (GPL).
+ *
+ * Code used from cwdaemon for parallel port ptt only.
+ *
+ * cwdaemon - morse sounding daemon for the parallel or serial port
+ * Copyright (C) 2002 -2005 Joop Stakenborg &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">pg4i at amsat.org</A>&gt;
+ *                       and many authors, see the AUTHORS file.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+# if HAVE_STDIO_H
+# include &lt;stdio.h&gt;
+#endif
+#if STDC_HEADERS
+# include &lt;stdlib.h&gt;
+# include &lt;stddef.h&gt;
+#else
+# if HAVE_STDLIB_H
+#  include &lt;stdlib.h&gt;
+# endif
+#endif
+#if HAVE_UNISTD_H
+# include &lt;unistd.h&gt;
+#endif
+#if HAVE_SYS_IOCTL_H
+# include &lt;sys/ioctl.h&gt;
+#endif
+#if HAVE_FCNTL_H
+# include &lt;fcntl.h&gt;
+#endif
+
+#ifdef HAVE_LINUX_PPDEV_H
+# include &lt;linux/ppdev.h&gt;
+# include &lt;linux/parport.h&gt;
+#endif
+#ifdef HAVE_DEV_PPBUS_PPI_H
+# include &lt;dev/ppbus/ppi.h&gt;
+# include &lt;dev/ppbus/ppbconf.h&gt;
+#endif
+
+int lp_reset (int fd);
+int lp_ptt (int fd, int onoff);
+
+#ifdef HAVE_SYS_STAT_H
+# include &lt;sys/stat.h&gt;
+#endif
+#if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG)
+# include &lt;sys/param.h&gt;
+#endif
+
+#include &lt;string.h&gt;
+/* parport functions */
+
+int dev_is_parport(int fd);
+int ptt_parallel(int fd, int *ntx, int *iptt);
+int ptt_serial(int fd, int *ntx, int *iptt);
+
+int fd=-1;		/* Used for both serial and parallel */
+
+/*
+ * ptt_
+ *
+ * generic unix PTT routine called from Fortran
+ *
+ * Inputs	
+ * unused	Unused, to satisfy old windows calling convention
+ * ptt_port	device name serial or parallel
+ * ntx		pointer to fortran command on or off
+ * iptt		pointer to fortran command status on or off
+ * Returns	- non 0 if error
+*/
+
+/* Tiny state machine */
+#define STATE_PORT_CLOSED		0
+#define STATE_PORT_OPEN_PARALLEL	1
+#define STATE_PORT_OPEN_SERIAL		2
+
+//int ptt_(int *unused, char *ptt_port, int *ntx, int *iptt)
+int ptt_(int *unused, int *ntx, int *iptt)
+{
+  static int state=0;
+  char *p;
+
+// ### Temporary:
+  char* ptt_port;
+  if(*unused != -99) {
+    *iptt=*ntx;
+    return 0;
+  }
+// ###
+
+  /* In the very unlikely event of a NULL pointer, just return.
+   * Yes, I realise this should not be possible in WSJT.
+   */
+  if (ptt_port == NULL) {
+    *iptt = *ntx;
+    return (0);
+  }
+    
+  switch (state) {
+  case STATE_PORT_CLOSED:
+
+     /* Remove trailing ' ' */
+    if ((p = strchr(ptt_port, ' ')) != NULL)
+      *p = '\0';
+
+    /* If all that is left is a '\0' then also just return */
+    if (*ptt_port == '\0') {
+      *iptt = *ntx;
+      return(0);
+    }
+
+    if ((fd = open(ptt_port, O_RDWR|O_NONBLOCK)) &lt; 0) {
+	fprintf(stderr, &quot;Can't open %s.\n&quot;, ptt_port);
+	return (1);
+    }
+
+    if (dev_is_parport(fd)) {
+      state = STATE_PORT_OPEN_PARALLEL;
+      lp_reset(fd);
+      ptt_parallel(fd, ntx, iptt);
+    } else {
+      state = STATE_PORT_OPEN_SERIAL;
+      ptt_serial(fd, ntx, iptt);
+    }
+    break;
+
+  case STATE_PORT_OPEN_PARALLEL:
+    ptt_parallel(fd, ntx, iptt);
+    break;
+
+  case STATE_PORT_OPEN_SERIAL:
+    ptt_serial(fd, ntx, iptt);
+    break;
+
+  default:
+    close(fd);
+    fd = -1;
+    state = STATE_PORT_CLOSED;
+    break;
+  }
+  return(0);
+}
+
+/*
+ * ptt_serial
+ *
+ * generic serial unix PTT routine called indirectly from Fortran
+ *
+ * fd		- already opened file descriptor
+ * ntx		- pointer to fortran command on or off
+ * iptt		- pointer to fortran command status on or off
+ */
+
+int
+ptt_serial(int fd, int *ntx, int *iptt)
+{
+  int control = TIOCM_RTS | TIOCM_DTR;
+
+  if(*ntx) {
+    ioctl(fd, TIOCMBIS, &amp;control);               /* Set DTR and RTS */
+    *iptt = 1;
+  } else {
+    ioctl(fd, TIOCMBIC, &amp;control);
+    *iptt = 0;
+  }
+  return(0);
+}
+
+
+/* parport functions */
+
+/*
+ * dev_is_parport(fd):
+ *
+ * inputs	- Already open fd
+ * output	- 1 if parallel port, 0 if not
+ * side effects	- Unfortunately, this is platform specific.
+ */
+
+#if defined(HAVE_LINUX_PPDEV_H)                /* Linux (ppdev) */
+
+int
+dev_is_parport(int fd)
+{
+       struct stat st;
+       int m;
+
+       if ((fstat(fd, &amp;st) == -1) ||
+	   ((st.st_mode &amp; S_IFMT) != S_IFCHR) ||
+	   (ioctl(fd, PPGETMODE, &amp;m) == -1))
+	 return(0);
+
+       return(1);
+}
+
+#elif defined(HAVE_DEV_PPBUS_PPI_H)    /* FreeBSD (ppbus/ppi) */
+
+int
+dev_is_parport(int fd)
+{
+       struct stat st;
+       unsigned char c;
+
+       if ((fstat(fd, &amp;st) == -1) ||
+	   ((st.st_mode &amp; S_IFMT) != S_IFCHR) ||
+	   (ioctl(fd, PPISSTATUS, &amp;c) == -1))
+	 return(0);
+
+       return(1);
+}
+
+#else                                  /* Fallback (nothing) */
+
+int
+dev_is_parport(int fd)
+{
+       return(0);
+}
+
+#endif
+/* Linux wrapper around PPFCONTROL */
+#ifdef HAVE_LINUX_PPDEV_H
+static void
+parport_control (int fd, unsigned char controlbits, int values)
+{
+	struct ppdev_frob_struct frob;
+	frob.mask = controlbits;
+	frob.val = values;
+
+	if (ioctl (fd, PPFCONTROL, &amp;frob) == -1)
+	{
+		fprintf(stderr, &quot;Parallel port PPFCONTROL&quot;);
+		exit (1);
+	}
+}
+#endif
+
+/* FreeBSD wrapper around PPISCTRL */
+#ifdef HAVE_DEV_PPBUS_PPI_H
+static void
+parport_control (int fd, unsigned char controlbits, int values)
+{
+	unsigned char val;
+
+	if (ioctl (fd, PPIGCTRL, &amp;val) == -1)
+	{
+		fprintf(stderr, &quot;Parallel port PPIGCTRL&quot;);
+		exit (1);
+	}
+
+	val &amp;= ~controlbits;
+	val |= values;
+
+	if (ioctl (fd, PPISCTRL, &amp;val) == -1)
+	{
+		fprintf(stderr, &quot;Parallel port PPISCTRL&quot;);
+		exit (1);
+	}
+}
+#endif
+
+/* Initialise a parallel port, given open fd */
+int
+lp_init (int fd)
+{
+#ifdef HAVE_LINUX_PPDEV_H
+	int mode;
+#endif
+
+#ifdef HAVE_LINUX_PPDEV_H
+	mode = PARPORT_MODE_PCSPP;
+
+	if (ioctl (fd, PPSETMODE, &amp;mode) == -1)
+	{
+		fprintf(stderr, &quot;Setting parallel port mode&quot;);
+		close (fd);
+		return(-1);
+	}
+
+	if (ioctl (fd, PPEXCL, NULL) == -1)
+	{
+		fprintf(stderr, &quot;Parallel port is already in use.\n&quot;);
+		close (fd);
+		return(-1);
+	}
+	if (ioctl (fd, PPCLAIM, NULL) == -1)
+	{
+		fprintf(stderr, &quot;Claiming parallel port.\n&quot;);
+		fprintf(stderr, &quot;HINT: did you unload the lp kernel module?&quot;);
+		close (fd);
+		return(-1);
+	}
+
+	/* Enable CW &amp; PTT - /STROBE bit (pin 1) */
+	parport_control (fd, PARPORT_CONTROL_STROBE, PARPORT_CONTROL_STROBE);
+#endif
+#ifdef HAVE_DEV_PPBUS_PPI_H
+	parport_control (fd, STROBE, STROBE);
+#endif
+	lp_reset (fd);
+	return(0);
+}
+
+/* release ppdev and close port */
+int
+lp_free (int fd)
+{
+#ifdef HAVE_LINUX_PPDEV_H
+	lp_reset (fd);
+
+	/* Disable CW &amp; PTT - /STROBE bit (pin 1) */
+	parport_control (fd, PARPORT_CONTROL_STROBE, 0);
+
+	ioctl (fd, PPRELEASE);
+#endif
+#ifdef HAVE_DEV_PPBUS_PPI_H
+	/* Disable CW &amp; PTT - /STROBE bit (pin 1) */
+	parport_control (fd, STROBE, 0);
+#endif
+	close (fd);
+	return(0);
+}
+
+/* set to a known state */
+int
+lp_reset (int fd)
+{
+#if defined (HAVE_LINUX_PPDEV_H) || defined (HAVE_DEV_PPBUS_PPI_H)
+	lp_ptt (fd, 0);
+#endif
+	return(0);
+}
+
+/* SSB PTT keying - /INIT bit (pin 16) (inverted) */
+int
+lp_ptt (int fd, int onoff)
+{
+#ifdef HAVE_LINUX_PPDEV_H
+	if (onoff == 1)
+		parport_control (fd, PARPORT_CONTROL_INIT,
+				PARPORT_CONTROL_INIT);
+	else
+		parport_control (fd, PARPORT_CONTROL_INIT, 0);
+#endif
+#ifdef HAVE_DEV_PPBUS_PPI_H
+	if (onoff == 1)
+		parport_control (fd, nINIT,
+				nINIT);
+	else
+		parport_control (fd, nINIT, 0);
+#endif
+	return(0);
+}
+
+/*
+ * ptt_parallel
+ *
+ * generic parallel unix PTT routine called indirectly from Fortran
+ *
+ * fd		- already opened file descriptor
+ * ntx		- pointer to fortran command on or off
+ * iptt		- pointer to fortran command status on or off
+ */
+
+int
+ptt_parallel(int fd, int *ntx, int *iptt)
+{
+  if(*ntx) {
+    lp_ptt(fd, 1);
+    *iptt=1;
+  }  else {
+    lp_ptt(fd, 0);
+    *iptt=0;
+  }
+  return(0);
+}


Property changes on: branches/map65/libm65/ptt_unix.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/recvpkt.f90
===================================================================
--- branches/map65/libm65/recvpkt.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/recvpkt.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,70 +1,70 @@
-subroutine recvpkt(nsam,nblock2,userx_no,k,buf4,buf8,buf16)
-
-! Reformat timf2 data from Linrad and stuff data into r*4 array dd().
-
-  parameter (NSMAX=60*96000)          !Total sample intervals per minute
-  parameter (NFFT=32768)
-  integer*1 userx_no
-  real*4 d4,buf4(*)                   !(348)
-  real*8 d8,buf8(*)                   !(174)
-  complex*16 c16,buf16(*)             !(87)
-  integer*2 jd(4),kd(2),nblock2
-  real*4 xd(4),yd(2)
-  real*8 fcenter
-  common/datcom/dd(4,5760000),ss(4,322,NFFT),savg(4,NFFT),fcenter,nutc,junk(34)
-  equivalence (kd,d4)
-  equivalence (jd,d8,yd)
-  equivalence (xd,c16)
-
-  if(nsam.eq.-1) then
-! Move data from the UDP packet buffer into array dd().
-     if(userx_no.eq.-1) then
-        do i=1,174                    !One RF channel, r*4 data
-           k=k+1
-           d8=buf8(i)
-           dd(1,k)=yd(1)
-           dd(2,k)=yd(2)
-        enddo
-     else if(userx_no.eq.1) then
-        do i=1,348                    !One RF channel, i*2 data
-           k=k+1
-           d4=buf4(i)
-           dd(1,k)=kd(1)
-           dd(2,k)=kd(2)
-        enddo
-     else if(userx_no.eq.-2) then
-        do i=1,87                    !Two RF channels, r*4 data
-           k=k+1
-           c16=buf16(i)
-           dd(1,k)=xd(1)
-           dd(2,k)=xd(2)
-           dd(3,k)=xd(3)
-           dd(4,k)=xd(4)
-        enddo
-     else if(userx_no.eq.2) then
-        do i=1,174                    !Two RF channels, i*2 data
-           k=k+1
-           d8=buf8(i)
-           dd(1,k)=jd(1)
-           dd(2,k)=jd(2)
-           dd(3,k)=jd(3)
-           dd(4,k)=jd(4)
-        enddo
-     endif
-  else
-     if(userx_no.eq.1) then
-        do i=1,nsam                    !One RF channel, r*4 data
-           k=k+1
-           d4=buf4(i)
-           dd(1,k)=kd(1)
-           dd(2,k)=kd(2)
-
-           k=k+1
-           dd(1,k)=kd(1)
-           dd(2,k)=kd(2)
-        enddo
-     endif
-  endif
-
-  return
-end subroutine recvpkt
+subroutine recvpkt(nsam,nblock2,userx_no,k,buf4,buf8,buf16)
+
+! Reformat timf2 data from Linrad and stuff data into r*4 array dd().
+
+  parameter (NSMAX=60*96000)          !Total sample intervals per minute
+  parameter (NFFT=32768)
+  integer*1 userx_no
+  real*4 d4,buf4(*)                   !(348)
+  real*8 d8,buf8(*)                   !(174)
+  complex*16 c16,buf16(*)             !(87)
+  integer*2 jd(4),kd(2),nblock2
+  real*4 xd(4),yd(2)
+  real*8 fcenter
+  common/datcom/dd(4,5760000),ss(4,322,NFFT),savg(4,NFFT),fcenter,nutc,junk(34)
+  equivalence (kd,d4)
+  equivalence (jd,d8,yd)
+  equivalence (xd,c16)
+
+  if(nsam.eq.-1) then
+! Move data from the UDP packet buffer into array dd().
+     if(userx_no.eq.-1) then
+        do i=1,174                    !One RF channel, r*4 data
+           k=k+1
+           d8=buf8(i)
+           dd(1,k)=yd(1)
+           dd(2,k)=yd(2)
+        enddo
+     else if(userx_no.eq.1) then
+        do i=1,348                    !One RF channel, i*2 data
+           k=k+1
+           d4=buf4(i)
+           dd(1,k)=kd(1)
+           dd(2,k)=kd(2)
+        enddo
+     else if(userx_no.eq.-2) then
+        do i=1,87                    !Two RF channels, r*4 data
+           k=k+1
+           c16=buf16(i)
+           dd(1,k)=xd(1)
+           dd(2,k)=xd(2)
+           dd(3,k)=xd(3)
+           dd(4,k)=xd(4)
+        enddo
+     else if(userx_no.eq.2) then
+        do i=1,174                    !Two RF channels, i*2 data
+           k=k+1
+           d8=buf8(i)
+           dd(1,k)=jd(1)
+           dd(2,k)=jd(2)
+           dd(3,k)=jd(3)
+           dd(4,k)=jd(4)
+        enddo
+     endif
+  else
+     if(userx_no.eq.1) then
+        do i=1,nsam                    !One RF channel, r*4 data
+           k=k+1
+           d4=buf4(i)
+           dd(1,k)=kd(1)
+           dd(2,k)=kd(2)
+
+           k=k+1
+           dd(1,k)=kd(1)
+           dd(2,k)=kd(2)
+        enddo
+     endif
+  endif
+
+  return
+end subroutine recvpkt


Property changes on: branches/map65/libm65/recvpkt.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/rfile3a.f90
===================================================================
--- branches/map65/libm65/rfile3a.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/rfile3a.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,14 +1,14 @@
-subroutine rfile3a(infile,ibuf,n,fcenter,ierr)
-
-  character*(*) infile
-  integer*8 ibuf(n)
-  real*8 fcenter
-
-  open(10,file=infile,access='stream',status='old',err=998)
-  read(10,end=998) (ibuf(i),i=1,n/8),fcenter
-  ierr=0
-  go to 999
-998 ierr=1002
-999 close(10)
-  return
-end subroutine rfile3a
+subroutine rfile3a(infile,ibuf,n,fcenter,ierr)
+
+  character*(*) infile
+  integer*8 ibuf(n)
+  real*8 fcenter
+
+  open(10,file=infile,access='stream',status='old',err=998)
+  read(10,end=998) (ibuf(i),i=1,n/8),fcenter
+  ierr=0
+  go to 999
+998 ierr=1002
+999 close(10)
+  return
+end subroutine rfile3a


Property changes on: branches/map65/libm65/rfile3a.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/rs.h
===================================================================
--- branches/map65/libm65/rs.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/rs.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,35 +1,35 @@
-/* User include file for the Reed-Solomon codec
- * Copyright 2002, Phil Karn KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-
-/* General purpose RS codec, 8-bit symbols */
-void encode_rs_char(void *rs,unsigned char *data,unsigned char *parity);
-int decode_rs_char(void *rs,unsigned char *data,int *eras_pos,
-		   int no_eras);
-void *init_rs_char(int symsize,int gfpoly,
-		   int fcr,int prim,int nroots,
-		   int pad);
-void free_rs_char(void *rs);
-
-/* General purpose RS codec, integer symbols */
-void encode_rs_int(void *rs,int *data,int *parity);
-int decode_rs_int(void *rs,int *data,int *eras_pos,int no_eras);
-void *init_rs_int(int symsize,int gfpoly,int fcr,
-		  int prim,int nroots,int pad);
-void free_rs_int(void *rs);
-
-/* CCSDS standard (255,223) RS codec with conventional (*not* dual-basis)
- * symbol representation
- */
-void encode_rs_8(unsigned char *data,unsigned char *parity,int pad);
-int decode_rs_8(unsigned char *data,int *eras_pos,int no_eras,int pad);
-
-/* CCSDS standard (255,223) RS codec with dual-basis symbol representation */
-void encode_rs_ccsds(unsigned char *data,unsigned char *parity,int pad);
-int decode_rs_ccsds(unsigned char *data,int *eras_pos,int no_eras,int pad);
-
-/* Tables to map from conventional-&gt;dual (Taltab) and
- * dual-&gt;conventional (Tal1tab) bases
- */
-extern unsigned char Taltab[],Tal1tab[];
+/* User include file for the Reed-Solomon codec
+ * Copyright 2002, Phil Karn KA9Q
+ * May be used under the terms of the GNU General Public License (GPL)
+ */
+
+/* General purpose RS codec, 8-bit symbols */
+void encode_rs_char(void *rs,unsigned char *data,unsigned char *parity);
+int decode_rs_char(void *rs,unsigned char *data,int *eras_pos,
+		   int no_eras);
+void *init_rs_char(int symsize,int gfpoly,
+		   int fcr,int prim,int nroots,
+		   int pad);
+void free_rs_char(void *rs);
+
+/* General purpose RS codec, integer symbols */
+void encode_rs_int(void *rs,int *data,int *parity);
+int decode_rs_int(void *rs,int *data,int *eras_pos,int no_eras);
+void *init_rs_int(int symsize,int gfpoly,int fcr,
+		  int prim,int nroots,int pad);
+void free_rs_int(void *rs);
+
+/* CCSDS standard (255,223) RS codec with conventional (*not* dual-basis)
+ * symbol representation
+ */
+void encode_rs_8(unsigned char *data,unsigned char *parity,int pad);
+int decode_rs_8(unsigned char *data,int *eras_pos,int no_eras,int pad);
+
+/* CCSDS standard (255,223) RS codec with dual-basis symbol representation */
+void encode_rs_ccsds(unsigned char *data,unsigned char *parity,int pad);
+int decode_rs_ccsds(unsigned char *data,int *eras_pos,int no_eras,int pad);
+
+/* Tables to map from conventional-&gt;dual (Taltab) and
+ * dual-&gt;conventional (Tal1tab) bases
+ */
+extern unsigned char Taltab[],Tal1tab[];


Property changes on: branches/map65/libm65/rs.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/s3avg.f90
===================================================================
--- branches/map65/libm65/s3avg.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/s3avg.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,42 +1,42 @@
-subroutine s3avg(nsave,mode65,nutc,ndf,xdt,npol,s3,nkv,decoded)
-
-  real s3(64,63),s3b(64,63)
-  real s3a(64,63,32)
-  integer iutc(32),idf(32),ipol(32)
-  real dt(32)
-  character*22 decoded
-  logical ltext
-  save
-  
-  n=nsave
-  iutc(n)=nutc
-  idf(n)=ndf
-  ipol(n)=npol
-  dt(n)=xdt
-  s3a(1:64,1:63,n)=s3
-
-  s3b=0.
-  nsum=0
-  idfdiff=100
-  dtdiff=0.2
-  do i=1,n
-     if(mod(iutc(i),2).ne.mod(nutc,2)) cycle
-     if(abs(ndf-idf(i)).gt.idfdiff) cycle
-     if(abs(xdt-dt(i)).gt.dtdiff) cycle
-     s3b=s3b + s3a(1:64,1:63,i)
-     nsum=nsum+1
-  enddo
-
-  decoded='                      '
-  if(nsum.ge.2) then
-     nadd=mode65*nsum
-     call extract(s3b,nadd,ncount,nhist,decoded,ltext)     !Extract the message
-     nkv=nsum
-     if(ncount.lt.0) then 
-        nkv=0
-        decoded='                      '
-     endif
-  endif
-
-  return
-end subroutine s3avg
+subroutine s3avg(nsave,mode65,nutc,ndf,xdt,npol,s3,nkv,decoded)
+
+  real s3(64,63),s3b(64,63)
+  real s3a(64,63,32)
+  integer iutc(32),idf(32),ipol(32)
+  real dt(32)
+  character*22 decoded
+  logical ltext
+  save
+  
+  n=nsave
+  iutc(n)=nutc
+  idf(n)=ndf
+  ipol(n)=npol
+  dt(n)=xdt
+  s3a(1:64,1:63,n)=s3
+
+  s3b=0.
+  nsum=0
+  idfdiff=100
+  dtdiff=0.2
+  do i=1,n
+     if(mod(iutc(i),2).ne.mod(nutc,2)) cycle
+     if(abs(ndf-idf(i)).gt.idfdiff) cycle
+     if(abs(xdt-dt(i)).gt.dtdiff) cycle
+     s3b=s3b + s3a(1:64,1:63,i)
+     nsum=nsum+1
+  enddo
+
+  decoded='                      '
+  if(nsum.ge.2) then
+     nadd=mode65*nsum
+     call extract(s3b,nadd,ncount,nhist,decoded,ltext)     !Extract the message
+     nkv=nsum
+     if(ncount.lt.0) then 
+        nkv=0
+        decoded='                      '
+     endif
+  endif
+
+  return
+end subroutine s3avg


Property changes on: branches/map65/libm65/s3avg.f90
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: branches/map65/libm65/sec_midn.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/set.f
===================================================================
--- branches/map65/libm65/set.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/set.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,31 +1,31 @@
-      subroutine set(a,y,n)
-      real y(n)
-      do i=1,n
-         y(i)=a
-      enddo
-      return
-      end
-
-      subroutine move(x,y,n)
-      real x(n),y(n)
-      do i=1,n
-         y(i)=x(i)
-      enddo
-      return
-      end
-
-      subroutine zero(x,n)
-      real x(n)
-      do i=1,n
-         x(i)=0.0
-      enddo
-      return
-      end
-
-      subroutine add(a,b,c,n)
-      real a(n),b(n),c(n)
-      do i=1,n
-         c(i)=a(i)+b(i)
-      enddo
-      return
-      end
+      subroutine set(a,y,n)
+      real y(n)
+      do i=1,n
+         y(i)=a
+      enddo
+      return
+      end
+
+      subroutine move(x,y,n)
+      real x(n),y(n)
+      do i=1,n
+         y(i)=x(i)
+      enddo
+      return
+      end
+
+      subroutine zero(x,n)
+      real x(n)
+      do i=1,n
+         x(i)=0.0
+      enddo
+      return
+      end
+
+      subroutine add(a,b,c,n)
+      real a(n),b(n),c(n)
+      do i=1,n
+         c(i)=a(i)+b(i)
+      enddo
+      return
+      end


Property changes on: branches/map65/libm65/set.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/setup65.f
===================================================================
--- branches/map65/libm65/setup65.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/setup65.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,96 +1,96 @@
-      subroutine setup65
-
-C  Defines arrays related to the JT65 pseudo-random synchronizing pattern.
-C  Executed at program start.
-
-      integer nprc(126)
-      common/prcom/pr(126),mdat(126),mref(126,2),mdat2(126),mref2(126,2)
-
-C  JT65
-      data nprc/
-     + 1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,
-     + 0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,
-     + 0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,
-     + 0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,
-     + 1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,
-     + 0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,
-     + 1,1,1,1,1,1/
-      data mr2/0/                !Silence compiler warning
-
-C  Put the appropriate pseudo-random sequence into pr
-      nsym=126
-      do i=1,nsym
-         pr(i)=2*nprc(i)-1
-      enddo
-
-C  Determine locations of data and reference symbols
-      k=0
-      mr1=0
-      do i=1,nsym
-         if(pr(i).lt.0.0) then
-            k=k+1
-            mdat(k)=i
-         else
-            mr2=i
-            if(mr1.eq.0) mr1=i
-         endif
-      enddo
-      nsig=k
-
-C  Determine the reference symbols for each data symbol.
-      do k=1,nsig
-         m=mdat(k)
-         mref(k,1)=mr1
-         do n=1,10                     !Get ref symbol before data
-            if((m-n).gt.0) then
-               if (pr(m-n).gt.0.0) go to 10
-            endif
-         enddo
-         go to 12
- 10      mref(k,1)=m-n
- 12      mref(k,2)=mr2
-         do n=1,10                     !Get ref symbol after data
-            if((m+n).le.nsym) then
-               if (pr(m+n).gt.0.0) go to 20
-            endif
-         enddo
-         go to 22
- 20      mref(k,2)=m+n
- 22   enddo
-
-C  Now do it all again, using opposite logic on pr(i)
-      k=0
-      mr1=0
-      do i=1,nsym
-         if(pr(i).gt.0.0) then
-            k=k+1
-            mdat2(k)=i
-         else
-            mr2=i
-            if(mr1.eq.0) mr1=i
-         endif
-      enddo
-      nsig=k
-
-      do k=1,nsig
-         m=mdat2(k)
-         mref2(k,1)=mr1
-         do n=1,10
-            if((m-n).gt.0) then
-               if (pr(m-n).lt.0.0) go to 110
-            endif
-         enddo
-         go to 112
- 110      mref2(k,1)=m-n
- 112      mref2(k,2)=mr2
-         do n=1,10
-            if((m+n).le.nsym) then
-               if (pr(m+n).lt.0.0) go to 120
-            endif
-         enddo
-         go to 122
- 120     mref2(k,2)=m+n
- 122  enddo
-
-      return
-      end
+      subroutine setup65
+
+C  Defines arrays related to the JT65 pseudo-random synchronizing pattern.
+C  Executed at program start.
+
+      integer nprc(126)
+      common/prcom/pr(126),mdat(126),mref(126,2),mdat2(126),mref2(126,2)
+
+C  JT65
+      data nprc/
+     + 1,0,0,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,
+     + 0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,
+     + 0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,
+     + 0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,
+     + 1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,1,1,0,1,
+     + 0,1,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,1,
+     + 1,1,1,1,1,1/
+      data mr2/0/                !Silence compiler warning
+
+C  Put the appropriate pseudo-random sequence into pr
+      nsym=126
+      do i=1,nsym
+         pr(i)=2*nprc(i)-1
+      enddo
+
+C  Determine locations of data and reference symbols
+      k=0
+      mr1=0
+      do i=1,nsym
+         if(pr(i).lt.0.0) then
+            k=k+1
+            mdat(k)=i
+         else
+            mr2=i
+            if(mr1.eq.0) mr1=i
+         endif
+      enddo
+      nsig=k
+
+C  Determine the reference symbols for each data symbol.
+      do k=1,nsig
+         m=mdat(k)
+         mref(k,1)=mr1
+         do n=1,10                     !Get ref symbol before data
+            if((m-n).gt.0) then
+               if (pr(m-n).gt.0.0) go to 10
+            endif
+         enddo
+         go to 12
+ 10      mref(k,1)=m-n
+ 12      mref(k,2)=mr2
+         do n=1,10                     !Get ref symbol after data
+            if((m+n).le.nsym) then
+               if (pr(m+n).gt.0.0) go to 20
+            endif
+         enddo
+         go to 22
+ 20      mref(k,2)=m+n
+ 22   enddo
+
+C  Now do it all again, using opposite logic on pr(i)
+      k=0
+      mr1=0
+      do i=1,nsym
+         if(pr(i).gt.0.0) then
+            k=k+1
+            mdat2(k)=i
+         else
+            mr2=i
+            if(mr1.eq.0) mr1=i
+         endif
+      enddo
+      nsig=k
+
+      do k=1,nsig
+         m=mdat2(k)
+         mref2(k,1)=mr1
+         do n=1,10
+            if((m-n).gt.0) then
+               if (pr(m-n).lt.0.0) go to 110
+            endif
+         enddo
+         go to 112
+ 110      mref2(k,1)=m-n
+ 112      mref2(k,2)=mr2
+         do n=1,10
+            if((m+n).le.nsym) then
+               if (pr(m+n).lt.0.0) go to 120
+            endif
+         enddo
+         go to 122
+ 120     mref2(k,2)=m+n
+ 122  enddo
+
+      return
+      end


Property changes on: branches/map65/libm65/setup65.f
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: branches/map65/libm65/sleep.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/sleep_msec.f90
===================================================================
--- branches/map65/libm65/sleep_msec.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/sleep_msec.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,3 +1,3 @@
-subroutine sleep_msec(n)
-  return
-end subroutine sleep_msec
+subroutine sleep_msec(n)
+  return
+end subroutine sleep_msec


Property changes on: branches/map65/libm65/sleep_msec.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/sort.f
===================================================================
--- branches/map65/libm65/sort.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/sort.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,4 +1,4 @@
-      subroutine sort(n,arr)
-      call ssort(arr,tmp,n,1)
-      return
-      end
+      subroutine sort(n,arr)
+      call ssort(arr,tmp,n,1)
+      return
+      end


Property changes on: branches/map65/libm65/sort.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/ssort.f
===================================================================
--- branches/map65/libm65/ssort.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/ssort.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,287 +1,287 @@
-      subroutine ssort (x,y,n,kflag)
-c***purpose  sort an array and optionally make the same interchanges in
-c            an auxiliary array.  the array may be sorted in increasing
-c            or decreasing order.  a slightly modified quicksort
-c            algorithm is used.
-c
-c   ssort sorts array x and optionally makes the same interchanges in
-c   array y.  the array x may be sorted in increasing order or
-c   decreasing order.  a slightly modified quicksort algorithm is used.
-c
-c   description of parameters
-c      x - array of values to be sorted
-c      y - array to be (optionally) carried along
-c      n - number of values in array x to be sorted
-c      kflag - control parameter
-c            =  2  means sort x in increasing order and carry y along.
-c            =  1  means sort x in increasing order (ignoring y)
-c            = -1  means sort x in decreasing order (ignoring y)
-c            = -2  means sort x in decreasing order and carry y along.
-
-      integer kflag, n
-!      real x(n), y(n)
-!      real r, t, tt, tty, ty
-      integer x(n), y(n)
-      integer r, t, tt, tty, ty
-      integer i, ij, j, k, kk, l, m, nn
-      integer il(21), iu(21)
-
-      nn = n
-      if (nn .lt. 1) then
-!         print*,'ssort: The number of sort elements is not positive.'
-!         print*,'ssort: n = ',nn,'   kflag = ',kflag
-         return
-      endif
-c
-      kk = abs(kflag)
-      if (kk.ne.1 .and. kk.ne.2) then
-         print *,
-     +      'the sort control parameter, k, is not 2, 1, -1, or -2.'
-         return
-      endif
-c
-c     alter array x to get decreasing order if needed
-c
-      if (kflag .le. -1) then
-         do 10 i=1,nn
-            x(i) = -x(i)
-   10    continue
-      endif
-c
-      if (kk .eq. 2) go to 100
-c
-c     sort x only
-c
-      m = 1
-      i = 1
-      j = nn
-      r = 0.375e0
-c
-   20 if (i .eq. j) go to 60
-      if (r .le. 0.5898437e0) then
-         r = r+3.90625e-2
-      else
-         r = r-0.21875e0
-      endif
-c
-   30 k = i
-c
-c     select a central element of the array and save it in location t
-c
-      ij = i + int((j-i)*r)
-      t = x(ij)
-c
-c     if first element of array is greater than t, interchange with t
-c
-      if (x(i) .gt. t) then
-         x(ij) = x(i)
-         x(i) = t
-         t = x(ij)
-      endif
-      l = j
-c
-c     if last element of array is less than than t, interchange with t
-c
-      if (x(j) .lt. t) then
-         x(ij) = x(j)
-         x(j) = t
-         t = x(ij)
-c
-c        if first element of array is greater than t, interchange with t
-c
-         if (x(i) .gt. t) then
-            x(ij) = x(i)
-            x(i) = t
-            t = x(ij)
-         endif
-      endif
-c
-c     find an element in the second half of the array which is smaller
-c     than t
-c
-   40 l = l-1
-      if (x(l) .gt. t) go to 40
-c
-c     find an element in the first half of the array which is greater
-c     than t
-c
-   50 k = k+1
-      if (x(k) .lt. t) go to 50
-c
-c     interchange these elements
-c
-      if (k .le. l) then
-         tt = x(l)
-         x(l) = x(k)
-         x(k) = tt
-         go to 40
-      endif
-c
-c     save upper and lower subscripts of the array yet to be sorted
-c
-      if (l-i .gt. j-k) then
-         il(m) = i
-         iu(m) = l
-         i = k
-         m = m+1
-      else
-         il(m) = k
-         iu(m) = j
-         j = l
-         m = m+1
-      endif
-      go to 70
-c
-c     begin again on another portion of the unsorted array
-c
-   60 m = m-1
-      if (m .eq. 0) go to 190
-      i = il(m)
-      j = iu(m)
-c
-   70 if (j-i .ge. 1) go to 30
-      if (i .eq. 1) go to 20
-      i = i-1
-c
-   80 i = i+1
-      if (i .eq. j) go to 60
-      t = x(i+1)
-      if (x(i) .le. t) go to 80
-      k = i
-c
-   90 x(k+1) = x(k)
-      k = k-1
-      if (t .lt. x(k)) go to 90
-      x(k+1) = t
-      go to 80
-c
-c     sort x and carry y along
-c
-  100 m = 1
-      i = 1
-      j = nn
-      r = 0.375e0
-c
-  110 if (i .eq. j) go to 150
-      if (r .le. 0.5898437e0) then
-         r = r+3.90625e-2
-      else
-         r = r-0.21875e0
-      endif
-c
-  120 k = i
-c
-c     select a central element of the array and save it in location t
-c
-      ij = i + int((j-i)*r)
-      t = x(ij)
-      ty = y(ij)
-c
-c     if first element of array is greater than t, interchange with t
-c
-      if (x(i) .gt. t) then
-         x(ij) = x(i)
-         x(i) = t
-         t = x(ij)
-         y(ij) = y(i)
-         y(i) = ty
-         ty = y(ij)
-      endif
-      l = j
-c
-c     if last element of array is less than t, interchange with t
-c
-      if (x(j) .lt. t) then
-         x(ij) = x(j)
-         x(j) = t
-         t = x(ij)
-         y(ij) = y(j)
-         y(j) = ty
-         ty = y(ij)
-c
-c        if first element of array is greater than t, interchange with t
-c
-         if (x(i) .gt. t) then
-            x(ij) = x(i)
-            x(i) = t
-            t = x(ij)
-            y(ij) = y(i)
-            y(i) = ty
-            ty = y(ij)
-         endif
-      endif
-c
-c     find an element in the second half of the array which is smaller
-c     than t
-c
-  130 l = l-1
-      if (x(l) .gt. t) go to 130
-c
-c     find an element in the first half of the array which is greater
-c     than t
-c
-  140 k = k+1
-      if (x(k) .lt. t) go to 140
-c
-c     interchange these elements
-c
-      if (k .le. l) then
-         tt = x(l)
-         x(l) = x(k)
-         x(k) = tt
-         tty = y(l)
-         y(l) = y(k)
-         y(k) = tty
-         go to 130
-      endif
-c
-c     save upper and lower subscripts of the array yet to be sorted
-c
-      if (l-i .gt. j-k) then
-         il(m) = i
-         iu(m) = l
-         i = k
-         m = m+1
-      else
-         il(m) = k
-         iu(m) = j
-         j = l
-         m = m+1
-      endif
-      go to 160
-c
-c     begin again on another portion of the unsorted array
-c
-  150 m = m-1
-      if (m .eq. 0) go to 190
-      i = il(m)
-      j = iu(m)
-c
-  160 if (j-i .ge. 1) go to 120
-      if (i .eq. 1) go to 110
-      i = i-1
-c
-  170 i = i+1
-      if (i .eq. j) go to 150
-      t = x(i+1)
-      ty = y(i+1)
-      if (x(i) .le. t) go to 170
-      k = i
-c
-  180 x(k+1) = x(k)
-      y(k+1) = y(k)
-      k = k-1
-      if (t .lt. x(k)) go to 180
-      x(k+1) = t
-      y(k+1) = ty
-      go to 170
-c
-c     clean up
-c
-  190 if (kflag .le. -1) then
-         do 200 i=1,nn
-            x(i) = -x(i)
-  200    continue
-      endif
-      return
-      end
+      subroutine ssort (x,y,n,kflag)
+c***purpose  sort an array and optionally make the same interchanges in
+c            an auxiliary array.  the array may be sorted in increasing
+c            or decreasing order.  a slightly modified quicksort
+c            algorithm is used.
+c
+c   ssort sorts array x and optionally makes the same interchanges in
+c   array y.  the array x may be sorted in increasing order or
+c   decreasing order.  a slightly modified quicksort algorithm is used.
+c
+c   description of parameters
+c      x - array of values to be sorted
+c      y - array to be (optionally) carried along
+c      n - number of values in array x to be sorted
+c      kflag - control parameter
+c            =  2  means sort x in increasing order and carry y along.
+c            =  1  means sort x in increasing order (ignoring y)
+c            = -1  means sort x in decreasing order (ignoring y)
+c            = -2  means sort x in decreasing order and carry y along.
+
+      integer kflag, n
+!      real x(n), y(n)
+!      real r, t, tt, tty, ty
+      integer x(n), y(n)
+      integer r, t, tt, tty, ty
+      integer i, ij, j, k, kk, l, m, nn
+      integer il(21), iu(21)
+
+      nn = n
+      if (nn .lt. 1) then
+!         print*,'ssort: The number of sort elements is not positive.'
+!         print*,'ssort: n = ',nn,'   kflag = ',kflag
+         return
+      endif
+c
+      kk = abs(kflag)
+      if (kk.ne.1 .and. kk.ne.2) then
+         print *,
+     +      'the sort control parameter, k, is not 2, 1, -1, or -2.'
+         return
+      endif
+c
+c     alter array x to get decreasing order if needed
+c
+      if (kflag .le. -1) then
+         do 10 i=1,nn
+            x(i) = -x(i)
+   10    continue
+      endif
+c
+      if (kk .eq. 2) go to 100
+c
+c     sort x only
+c
+      m = 1
+      i = 1
+      j = nn
+      r = 0.375e0
+c
+   20 if (i .eq. j) go to 60
+      if (r .le. 0.5898437e0) then
+         r = r+3.90625e-2
+      else
+         r = r-0.21875e0
+      endif
+c
+   30 k = i
+c
+c     select a central element of the array and save it in location t
+c
+      ij = i + int((j-i)*r)
+      t = x(ij)
+c
+c     if first element of array is greater than t, interchange with t
+c
+      if (x(i) .gt. t) then
+         x(ij) = x(i)
+         x(i) = t
+         t = x(ij)
+      endif
+      l = j
+c
+c     if last element of array is less than than t, interchange with t
+c
+      if (x(j) .lt. t) then
+         x(ij) = x(j)
+         x(j) = t
+         t = x(ij)
+c
+c        if first element of array is greater than t, interchange with t
+c
+         if (x(i) .gt. t) then
+            x(ij) = x(i)
+            x(i) = t
+            t = x(ij)
+         endif
+      endif
+c
+c     find an element in the second half of the array which is smaller
+c     than t
+c
+   40 l = l-1
+      if (x(l) .gt. t) go to 40
+c
+c     find an element in the first half of the array which is greater
+c     than t
+c
+   50 k = k+1
+      if (x(k) .lt. t) go to 50
+c
+c     interchange these elements
+c
+      if (k .le. l) then
+         tt = x(l)
+         x(l) = x(k)
+         x(k) = tt
+         go to 40
+      endif
+c
+c     save upper and lower subscripts of the array yet to be sorted
+c
+      if (l-i .gt. j-k) then
+         il(m) = i
+         iu(m) = l
+         i = k
+         m = m+1
+      else
+         il(m) = k
+         iu(m) = j
+         j = l
+         m = m+1
+      endif
+      go to 70
+c
+c     begin again on another portion of the unsorted array
+c
+   60 m = m-1
+      if (m .eq. 0) go to 190
+      i = il(m)
+      j = iu(m)
+c
+   70 if (j-i .ge. 1) go to 30
+      if (i .eq. 1) go to 20
+      i = i-1
+c
+   80 i = i+1
+      if (i .eq. j) go to 60
+      t = x(i+1)
+      if (x(i) .le. t) go to 80
+      k = i
+c
+   90 x(k+1) = x(k)
+      k = k-1
+      if (t .lt. x(k)) go to 90
+      x(k+1) = t
+      go to 80
+c
+c     sort x and carry y along
+c
+  100 m = 1
+      i = 1
+      j = nn
+      r = 0.375e0
+c
+  110 if (i .eq. j) go to 150
+      if (r .le. 0.5898437e0) then
+         r = r+3.90625e-2
+      else
+         r = r-0.21875e0
+      endif
+c
+  120 k = i
+c
+c     select a central element of the array and save it in location t
+c
+      ij = i + int((j-i)*r)
+      t = x(ij)
+      ty = y(ij)
+c
+c     if first element of array is greater than t, interchange with t
+c
+      if (x(i) .gt. t) then
+         x(ij) = x(i)
+         x(i) = t
+         t = x(ij)
+         y(ij) = y(i)
+         y(i) = ty
+         ty = y(ij)
+      endif
+      l = j
+c
+c     if last element of array is less than t, interchange with t
+c
+      if (x(j) .lt. t) then
+         x(ij) = x(j)
+         x(j) = t
+         t = x(ij)
+         y(ij) = y(j)
+         y(j) = ty
+         ty = y(ij)
+c
+c        if first element of array is greater than t, interchange with t
+c
+         if (x(i) .gt. t) then
+            x(ij) = x(i)
+            x(i) = t
+            t = x(ij)
+            y(ij) = y(i)
+            y(i) = ty
+            ty = y(ij)
+         endif
+      endif
+c
+c     find an element in the second half of the array which is smaller
+c     than t
+c
+  130 l = l-1
+      if (x(l) .gt. t) go to 130
+c
+c     find an element in the first half of the array which is greater
+c     than t
+c
+  140 k = k+1
+      if (x(k) .lt. t) go to 140
+c
+c     interchange these elements
+c
+      if (k .le. l) then
+         tt = x(l)
+         x(l) = x(k)
+         x(k) = tt
+         tty = y(l)
+         y(l) = y(k)
+         y(k) = tty
+         go to 130
+      endif
+c
+c     save upper and lower subscripts of the array yet to be sorted
+c
+      if (l-i .gt. j-k) then
+         il(m) = i
+         iu(m) = l
+         i = k
+         m = m+1
+      else
+         il(m) = k
+         iu(m) = j
+         j = l
+         m = m+1
+      endif
+      go to 160
+c
+c     begin again on another portion of the unsorted array
+c
+  150 m = m-1
+      if (m .eq. 0) go to 190
+      i = il(m)
+      j = iu(m)
+c
+  160 if (j-i .ge. 1) go to 120
+      if (i .eq. 1) go to 110
+      i = i-1
+c
+  170 i = i+1
+      if (i .eq. j) go to 150
+      t = x(i+1)
+      ty = y(i+1)
+      if (x(i) .le. t) go to 170
+      k = i
+c
+  180 x(k+1) = x(k)
+      y(k+1) = y(k)
+      k = k-1
+      if (t .lt. x(k)) go to 180
+      x(k+1) = t
+      y(k+1) = ty
+      go to 170
+c
+c     clean up
+c
+  190 if (kflag .le. -1) then
+         do 200 i=1,nn
+            x(i) = -x(i)
+  200    continue
+      endif
+      return
+      end


Property changes on: branches/map65/libm65/ssort.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/sun.f
===================================================================
--- branches/map65/libm65/sun.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/sun.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,88 +1,88 @@
-      subroutine sun(y,m,DD,UT,lon,lat,RA,Dec,LST,Az,El,mjd,day)
-
-      implicit none
-
-      integer y                         !Year
-      integer m                         !Month
-      integer DD                        !Day
-      integer mjd                       !Modified Julian Date
-      real UT                           !UTC in hours
-      real RA,Dec                       !RA and Dec of sun
-
-C  NB: Double caps here are single caps in the writeup.
-
-C  Orbital elements of the Sun (also N=0, i=0, a=1):
-      real w                            !Argument of perihelion
-      real e                            !Eccentricity
-      real MM                           !Mean anomaly
-      real Ls                           !Mean longitude
-
-C  Other standard variables:
-      real v                            !True anomaly
-      real EE                           !Eccentric anomaly
-      real ecl                          !Obliquity of the ecliptic
-      real d                            !Ephemeris time argument in days
-      real r                            !Distance to sun, AU
-      real xv,yv                        !x and y coords in ecliptic
-      real lonsun                       !Ecliptic long and lat of sun
-C Ecliptic coords of sun (geocentric)
-      real xs,ys
-C Equatorial coords of sun (geocentric)
-      real xe,ye,ze
-      real lon,lat
-      real GMST0,LST,HA
-      real xx,yy,zz
-      real xhor,yhor,zhor
-      real Az,El
-
-      real day
-      real rad
-      data rad/57.2957795/
-
-C  Time in days, with Jan 0, 2000 equal to 0.0:
-      d=367*y - 7*(y+(m+9)/12)/4 + 275*m/9 + DD - 730530 + UT/24.0
-      mjd=d + 51543
-      ecl = 23.4393 - 3.563e-7 * d
-
-C  Compute updated orbital elements for Sun:
-      w = 282.9404 + 4.70935e-5 * d
-      e = 0.016709 - 1.151e-9 * d
-      MM = mod(356.0470d0 + 0.9856002585d0 * d + 360000.d0,360.d0)
-      Ls = mod(w+MM+720.0,360.0)
-
-      EE = MM + e*rad*sin(MM/rad) * (1.0 + e*cos(M/rad))
-      EE = EE - (EE - e*rad*sin(EE/rad)-MM) / (1.0 - e*cos(EE/rad))
-
-      xv = cos(EE/rad) - e
-      yv = sqrt(1.0-e*e) * sin(EE/rad)
-      v = rad*atan2(yv,xv)
-      r = sqrt(xv*xv + yv*yv)
-      lonsun = mod(v + w + 720.0,360.0)
-C  Ecliptic coordinates of sun (rectangular):
-      xs = r * cos(lonsun/rad)
-      ys = r * sin(lonsun/rad)
-
-C  Equatorial coordinates of sun (rectangular):
-      xe = xs
-      ye = ys * cos(ecl/rad)
-      ze = ys * sin(ecl/rad)
-
-C  RA and Dec in degrees:
-      RA = rad*atan2(ye,xe)
-      Dec = rad*atan2(ze,sqrt(xe*xe + ye*ye))
-
-      GMST0 = (Ls + 180.0)/15.0
-      LST = mod(GMST0+UT+lon/15.0+48.0,24.0)    !LST in hours
-      HA = 15.0*LST - RA                        !HA in degrees
-      xx = cos(HA/rad)*cos(Dec/rad)
-      yy = sin(HA/rad)*cos(Dec/rad)
-      zz =             sin(Dec/rad)
-      xhor = xx*sin(lat/rad) - zz*cos(lat/rad)
-      yhor = yy
-      zhor = xx*cos(lat/rad) + zz*sin(lat/rad)
-      Az = mod(rad*atan2(yhor,xhor) + 180.0 + 360.0,360.0)
-      El = rad*asin(zhor)
-      day=d-1.5
-
-      return
-      end
+      subroutine sun(y,m,DD,UT,lon,lat,RA,Dec,LST,Az,El,mjd,day)
+
+      implicit none
+
+      integer y                         !Year
+      integer m                         !Month
+      integer DD                        !Day
+      integer mjd                       !Modified Julian Date
+      real UT                           !UTC in hours
+      real RA,Dec                       !RA and Dec of sun
+
+C  NB: Double caps here are single caps in the writeup.
+
+C  Orbital elements of the Sun (also N=0, i=0, a=1):
+      real w                            !Argument of perihelion
+      real e                            !Eccentricity
+      real MM                           !Mean anomaly
+      real Ls                           !Mean longitude
+
+C  Other standard variables:
+      real v                            !True anomaly
+      real EE                           !Eccentric anomaly
+      real ecl                          !Obliquity of the ecliptic
+      real d                            !Ephemeris time argument in days
+      real r                            !Distance to sun, AU
+      real xv,yv                        !x and y coords in ecliptic
+      real lonsun                       !Ecliptic long and lat of sun
+C Ecliptic coords of sun (geocentric)
+      real xs,ys
+C Equatorial coords of sun (geocentric)
+      real xe,ye,ze
+      real lon,lat
+      real GMST0,LST,HA
+      real xx,yy,zz
+      real xhor,yhor,zhor
+      real Az,El
+
+      real day
+      real rad
+      data rad/57.2957795/
+
+C  Time in days, with Jan 0, 2000 equal to 0.0:
+      d=367*y - 7*(y+(m+9)/12)/4 + 275*m/9 + DD - 730530 + UT/24.0
+      mjd=d + 51543
+      ecl = 23.4393 - 3.563e-7 * d
+
+C  Compute updated orbital elements for Sun:
+      w = 282.9404 + 4.70935e-5 * d
+      e = 0.016709 - 1.151e-9 * d
+      MM = mod(356.0470d0 + 0.9856002585d0 * d + 360000.d0,360.d0)
+      Ls = mod(w+MM+720.0,360.0)
+
+      EE = MM + e*rad*sin(MM/rad) * (1.0 + e*cos(M/rad))
+      EE = EE - (EE - e*rad*sin(EE/rad)-MM) / (1.0 - e*cos(EE/rad))
+
+      xv = cos(EE/rad) - e
+      yv = sqrt(1.0-e*e) * sin(EE/rad)
+      v = rad*atan2(yv,xv)
+      r = sqrt(xv*xv + yv*yv)
+      lonsun = mod(v + w + 720.0,360.0)
+C  Ecliptic coordinates of sun (rectangular):
+      xs = r * cos(lonsun/rad)
+      ys = r * sin(lonsun/rad)
+
+C  Equatorial coordinates of sun (rectangular):
+      xe = xs
+      ye = ys * cos(ecl/rad)
+      ze = ys * sin(ecl/rad)
+
+C  RA and Dec in degrees:
+      RA = rad*atan2(ye,xe)
+      Dec = rad*atan2(ze,sqrt(xe*xe + ye*ye))
+
+      GMST0 = (Ls + 180.0)/15.0
+      LST = mod(GMST0+UT+lon/15.0+48.0,24.0)    !LST in hours
+      HA = 15.0*LST - RA                        !HA in degrees
+      xx = cos(HA/rad)*cos(Dec/rad)
+      yy = sin(HA/rad)*cos(Dec/rad)
+      zz =             sin(Dec/rad)
+      xhor = xx*sin(lat/rad) - zz*cos(lat/rad)
+      yhor = yy
+      zhor = xx*cos(lat/rad) + zz*sin(lat/rad)
+      Az = mod(rad*atan2(yhor,xhor) + 180.0 + 360.0,360.0)
+      El = rad*asin(zhor)
+      day=d-1.5
+
+      return
+      end


Property changes on: branches/map65/libm65/sun.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/symspec.f90
===================================================================
--- branches/map65/libm65/symspec.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/symspec.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,193 +1,193 @@
-subroutine symspec(k,nxpol,ndiskdat,nb,nbslider,idphi,nfsample,fgreen,   &amp;
-     iqadjust,iqapply,gainx,gainy,phasex,phasey,rejectx,rejecty,         &amp;
-     pxdb,pydb,ssz5a,nkhz,ihsym,nzap,slimit,lstrong)
-
-!  k        pointer to the most recent new data
-!  nxpol    0/1 to indicate single- or dual-polarization
-!  ndiskdat 0/1 to indicate if data from disk
-!  nb       0/1 status of noise blanker
-!  idphi    Phase correction for Y channel, degrees
-!  nfsample sample rate (Hz)
-!  fgreen   Frequency of green marker in I/Q calibrate mode (-48.0 to +48.0 kHz)
-!  iqadjust 0/1 to indicate whether IQ adjustment is active
-!  iqapply  0/1 to indicate whether to apply I/Q calibration
-!  pxdb     power in x channel (0-60 dB)
-!  pydb     power in y channel (0-60 dB)
-!  ssz5a    polarized spectrum, for waterfall display
-!  nkhz     integer kHz portion of center frequency, e.g., 125 for 144.125
-!  ihsym    index number of this half-symbol (1-322)
-!  nzap     number of samples zero'ed by noise blanker
-
-  parameter (NSMAX=60*96000)          !Total sample intervals per minute
-  parameter (NFFT=32768)              !Length of FFTs
-  real*8 ts,hsym
-  real*8 fcenter
-  common/datcom/dd(4,5760000),ss(4,322,NFFT),savg(4,NFFT),fcenter,nutc,junk(34)
-  real*4 ssz5a(NFFT),w(NFFT)
-  complex z,zfac
-  complex zsumx,zsumy
-  complex cx(NFFT),cy(NFFT)
-  complex cx0(0:1023),cx1(0:1023)
-  complex cy0(0:1023),cy1(0:1023)
-  logical*1 lstrong(0:1023)
-  data rms/999.0/,k0/99999999/,nadjx/0/,nadjy/0/
-  save
-
-  if(k.gt.5751000) go to 999
-  if(k.lt.NFFT) then
-     ihsym=0
-     go to 999             !Wait for enough samples to start
-  endif
-  if(k.lt.k0) k1=0
-  if(k0.eq.99999999) then
-     pi=4.0*atan(1.0)
-     do i=1,NFFT
-        w(i)=(sin(i*pi/NFFT))**2
-     enddo
-  endif
-
-  nzap=0
-  sigmas=1.5*(10.0**(0.01*nbslider)) + 0.7
-  peaklimit=sigmas*max(10.0,rms)
-  faclim=3.0
-  px=0.
-  py=0.
-
-  iqapply0=0
-  iqadjust0=0
-  if(iqadjust.ne.0) iqapply0=0
-  nwindow=2
-  nfft2=1024
-  kstep=nfft2
-  if(nwindow.ne.0) kstep=nfft2/2
-  nblks=(k-k1)/kstep
-  do nblk=1,nblks
-     j=k1+1
-     do i=0,nfft2-1
-        cx0(i)=cmplx(dd(1,j+i),dd(2,j+i))
-        if(nxpol.ne.0) cy0(i)=cmplx(dd(3,j+i),dd(4,j+i))
-     enddo
-     call timf2(nxpol,nfft2,nwindow,nb,peaklimit,iqadjust0,iqapply0,faclim,  &amp;
-          cx0,cy0,gainx,gainy,phasex,phasey,cx1,cy1,slimit,lstrong,          &amp;
-          px,py,nzap)
-
-     do i=0,kstep-1
-        dd(1,j+i)=real(cx1(i))
-        dd(2,j+i)=aimag(cx1(i))
-        if(nxpol.ne.0) then
-           dd(3,j+i)=real(cy1(i))
-           dd(4,j+i)=aimag(cy1(i))
-        endif
-     enddo
-     k1=k1+kstep
-  enddo
-
-  hsym=2048.d0*96000.d0/11025.d0      !Samples per JT65 half-symbol
-  if(nfsample.eq.95238)   hsym=2048.d0*95238.1d0/11025.d0
-  npts=NFFT                           !Samples used in each half-symbol FFT
-
-  if(k.lt.k0) then
-     ts=1.d0 - hsym
-     savg=0.
-     ihsym=0
-  endif
-  k0=k
-  ihsym=ihsym+1
-  ja=ts+hsym                          !Index of first sample
-  jb=ja+npts-1                        !Last sample
-
-  ts=ts+hsym
-  i=0
-  fac=0.0002
-  dphi=idphi/57.2957795
-  zfac=fac*cmplx(cos(dphi),sin(dphi))
-  do j=ja,jb                          !Copy data into cx, cy
-     x1=dd(1,j)
-     x2=dd(2,j)
-     if(nxpol.ne.0) then
-        x3=dd(3,j)
-        x4=dd(4,j)
-     else
-        x3=0.
-        x4=0.
-     endif
-     i=i+1
-     cx(i)=fac*cmplx(x1,x2)
-     cy(i)=zfac*cmplx(x3,x4)          !NB: cy includes dphi correction
-  enddo
-
-  if(nzap/178.lt.50 .and. (ndiskdat.eq.0 .or. ihsym.lt.280)) then
-     nsum=nblks*kstep - nzap
-     if(nsum.le.0) nsum=1
-     rmsx=sqrt(0.5*px/nsum)
-     rmsy=sqrt(0.5*py/nsum)
-     rms=rmsx
-     if(nxpol.ne.0) rms=sqrt((px+py)/(4.0*nsum))
-  endif
-  pxdb=0.
-  pydb=0.
-  if(rmsx.gt.1.0) pxdb=20.0*log10(rmsx)
-  if(rmsy.gt.1.0) pydb=20.0*log10(rmsy)
-  if(pxdb.gt.60.0) pxdb=60.0
-  if(pydb.gt.60.0) pydb=60.0
-
-  cx=w*cx                             !Apply window for 2nd forward FFT
-  if(nxpol.ne.0) cy=w*cy
-
-  call four2a(cx,NFFT,1,1,1)          !Second forward FFT
-  if(iqadjust.eq.0) nadjx=0
-  if(iqadjust.ne.0 .and. nadjx.lt.50) call iqcal(nadjx,cx,NFFT,gainx,phasex, &amp;
-                                                 zsumx,ipkx,rejectx0)
-  if(iqapply.ne.0) call iqfix(cx,NFFT,gainx,phasex)
-
-  if(nxpol.ne.0) then
-     call four2a(cy,NFFT,1,1,1)
-     if(iqadjust.eq.0) nadjy=0
-     if(iqadjust.ne.0 .and. nadjy.lt.50) call iqcal(nadjy,cy,NFFT,gainy,phasey,&amp;
-                                                 zsumy,ipky,rejecty)
-     if(iqapply.ne.0) call iqfix(cy,NFFT,gainy,phasey)
-  endif
-
-  n=ihsym
-  do i=1,NFFT
-     sx=real(cx(i))**2 + aimag(cx(i))**2  
-     ss(1,n,i)=sx                    ! Pol = 0
-     savg(1,i)=savg(1,i) + sx
-     
-     if(nxpol.ne.0) then
-        z=cx(i) + cy(i)
-        s45=0.5*(real(z)**2 + aimag(z)**2)
-        ss(2,n,i)=s45                   ! Pol = 45
-        savg(2,i)=savg(2,i) + s45
-
-        sy=real(cy(i))**2 + aimag(cy(i))**2
-        ss(3,n,i)=sy                    ! Pol = 90
-        savg(3,i)=savg(3,i) + sy
-        
-        z=cx(i) - cy(i)
-        s135=0.5*(real(z)**2 + aimag(z)**2)
-        ss(4,n,i)=s135                  ! Pol = 135
-        savg(4,i)=savg(4,i) + s135
-
-        z=cx(i)*conjg(cy(i))
-        q=sx - sy
-        u=2.0*real(z)
-        ssz5a(i)=0.707*sqrt(q*q + u*u)    !Spectrum of linear polarization
-! Leif's formula:
-!     ssz5a(i)=0.5*(sx+sy) + (real(z)**2 + aimag(z)**2 - sx*sy)/(sx+sy)
-     else
-        ssz5a(i)=sx
-     endif
-  enddo
-  if(ihsym.eq.278) then
-     if(iqadjust.ne.0 .and. ipkx.ne.0 .and. ipky.ne.0) then
-        rejectx=10.0*log10(savg(1,1+nfft-ipkx)/savg(1,1+ipkx))
-        rejecty=10.0*log10(savg(3,1+nfft-ipky)/savg(3,1+ipky))
-     endif
-  endif
-
-  nkhz=nint(1000.d0*(fcenter-int(fcenter)))
-  if(fcenter.eq.0.d0) nkhz=125
-
-999 return
-end subroutine symspec
+subroutine symspec(k,nxpol,ndiskdat,nb,nbslider,idphi,nfsample,fgreen,   &amp;
+     iqadjust,iqapply,gainx,gainy,phasex,phasey,rejectx,rejecty,         &amp;
+     pxdb,pydb,ssz5a,nkhz,ihsym,nzap,slimit,lstrong)
+
+!  k        pointer to the most recent new data
+!  nxpol    0/1 to indicate single- or dual-polarization
+!  ndiskdat 0/1 to indicate if data from disk
+!  nb       0/1 status of noise blanker
+!  idphi    Phase correction for Y channel, degrees
+!  nfsample sample rate (Hz)
+!  fgreen   Frequency of green marker in I/Q calibrate mode (-48.0 to +48.0 kHz)
+!  iqadjust 0/1 to indicate whether IQ adjustment is active
+!  iqapply  0/1 to indicate whether to apply I/Q calibration
+!  pxdb     power in x channel (0-60 dB)
+!  pydb     power in y channel (0-60 dB)
+!  ssz5a    polarized spectrum, for waterfall display
+!  nkhz     integer kHz portion of center frequency, e.g., 125 for 144.125
+!  ihsym    index number of this half-symbol (1-322)
+!  nzap     number of samples zero'ed by noise blanker
+
+  parameter (NSMAX=60*96000)          !Total sample intervals per minute
+  parameter (NFFT=32768)              !Length of FFTs
+  real*8 ts,hsym
+  real*8 fcenter
+  common/datcom/dd(4,5760000),ss(4,322,NFFT),savg(4,NFFT),fcenter,nutc,junk(34)
+  real*4 ssz5a(NFFT),w(NFFT)
+  complex z,zfac
+  complex zsumx,zsumy
+  complex cx(NFFT),cy(NFFT)
+  complex cx0(0:1023),cx1(0:1023)
+  complex cy0(0:1023),cy1(0:1023)
+  logical*1 lstrong(0:1023)
+  data rms/999.0/,k0/99999999/,nadjx/0/,nadjy/0/
+  save
+
+  if(k.gt.5751000) go to 999
+  if(k.lt.NFFT) then
+     ihsym=0
+     go to 999             !Wait for enough samples to start
+  endif
+  if(k.lt.k0) k1=0
+  if(k0.eq.99999999) then
+     pi=4.0*atan(1.0)
+     do i=1,NFFT
+        w(i)=(sin(i*pi/NFFT))**2
+     enddo
+  endif
+
+  nzap=0
+  sigmas=1.5*(10.0**(0.01*nbslider)) + 0.7
+  peaklimit=sigmas*max(10.0,rms)
+  faclim=3.0
+  px=0.
+  py=0.
+
+  iqapply0=0
+  iqadjust0=0
+  if(iqadjust.ne.0) iqapply0=0
+  nwindow=2
+  nfft2=1024
+  kstep=nfft2
+  if(nwindow.ne.0) kstep=nfft2/2
+  nblks=(k-k1)/kstep
+  do nblk=1,nblks
+     j=k1+1
+     do i=0,nfft2-1
+        cx0(i)=cmplx(dd(1,j+i),dd(2,j+i))
+        if(nxpol.ne.0) cy0(i)=cmplx(dd(3,j+i),dd(4,j+i))
+     enddo
+     call timf2(nxpol,nfft2,nwindow,nb,peaklimit,iqadjust0,iqapply0,faclim,  &amp;
+          cx0,cy0,gainx,gainy,phasex,phasey,cx1,cy1,slimit,lstrong,          &amp;
+          px,py,nzap)
+
+     do i=0,kstep-1
+        dd(1,j+i)=real(cx1(i))
+        dd(2,j+i)=aimag(cx1(i))
+        if(nxpol.ne.0) then
+           dd(3,j+i)=real(cy1(i))
+           dd(4,j+i)=aimag(cy1(i))
+        endif
+     enddo
+     k1=k1+kstep
+  enddo
+
+  hsym=2048.d0*96000.d0/11025.d0      !Samples per JT65 half-symbol
+  if(nfsample.eq.95238)   hsym=2048.d0*95238.1d0/11025.d0
+  npts=NFFT                           !Samples used in each half-symbol FFT
+
+  if(k.lt.k0) then
+     ts=1.d0 - hsym
+     savg=0.
+     ihsym=0
+  endif
+  k0=k
+  ihsym=ihsym+1
+  ja=ts+hsym                          !Index of first sample
+  jb=ja+npts-1                        !Last sample
+
+  ts=ts+hsym
+  i=0
+  fac=0.0002
+  dphi=idphi/57.2957795
+  zfac=fac*cmplx(cos(dphi),sin(dphi))
+  do j=ja,jb                          !Copy data into cx, cy
+     x1=dd(1,j)
+     x2=dd(2,j)
+     if(nxpol.ne.0) then
+        x3=dd(3,j)
+        x4=dd(4,j)
+     else
+        x3=0.
+        x4=0.
+     endif
+     i=i+1
+     cx(i)=fac*cmplx(x1,x2)
+     cy(i)=zfac*cmplx(x3,x4)          !NB: cy includes dphi correction
+  enddo
+
+  if(nzap/178.lt.50 .and. (ndiskdat.eq.0 .or. ihsym.lt.280)) then
+     nsum=nblks*kstep - nzap
+     if(nsum.le.0) nsum=1
+     rmsx=sqrt(0.5*px/nsum)
+     rmsy=sqrt(0.5*py/nsum)
+     rms=rmsx
+     if(nxpol.ne.0) rms=sqrt((px+py)/(4.0*nsum))
+  endif
+  pxdb=0.
+  pydb=0.
+  if(rmsx.gt.1.0) pxdb=20.0*log10(rmsx)
+  if(rmsy.gt.1.0) pydb=20.0*log10(rmsy)
+  if(pxdb.gt.60.0) pxdb=60.0
+  if(pydb.gt.60.0) pydb=60.0
+
+  cx=w*cx                             !Apply window for 2nd forward FFT
+  if(nxpol.ne.0) cy=w*cy
+
+  call four2a(cx,NFFT,1,1,1)          !Second forward FFT
+  if(iqadjust.eq.0) nadjx=0
+  if(iqadjust.ne.0 .and. nadjx.lt.50) call iqcal(nadjx,cx,NFFT,gainx,phasex, &amp;
+                                                 zsumx,ipkx,rejectx0)
+  if(iqapply.ne.0) call iqfix(cx,NFFT,gainx,phasex)
+
+  if(nxpol.ne.0) then
+     call four2a(cy,NFFT,1,1,1)
+     if(iqadjust.eq.0) nadjy=0
+     if(iqadjust.ne.0 .and. nadjy.lt.50) call iqcal(nadjy,cy,NFFT,gainy,phasey,&amp;
+                                                 zsumy,ipky,rejecty)
+     if(iqapply.ne.0) call iqfix(cy,NFFT,gainy,phasey)
+  endif
+
+  n=ihsym
+  do i=1,NFFT
+     sx=real(cx(i))**2 + aimag(cx(i))**2  
+     ss(1,n,i)=sx                    ! Pol = 0
+     savg(1,i)=savg(1,i) + sx
+     
+     if(nxpol.ne.0) then
+        z=cx(i) + cy(i)
+        s45=0.5*(real(z)**2 + aimag(z)**2)
+        ss(2,n,i)=s45                   ! Pol = 45
+        savg(2,i)=savg(2,i) + s45
+
+        sy=real(cy(i))**2 + aimag(cy(i))**2
+        ss(3,n,i)=sy                    ! Pol = 90
+        savg(3,i)=savg(3,i) + sy
+        
+        z=cx(i) - cy(i)
+        s135=0.5*(real(z)**2 + aimag(z)**2)
+        ss(4,n,i)=s135                  ! Pol = 135
+        savg(4,i)=savg(4,i) + s135
+
+        z=cx(i)*conjg(cy(i))
+        q=sx - sy
+        u=2.0*real(z)
+        ssz5a(i)=0.707*sqrt(q*q + u*u)    !Spectrum of linear polarization
+! Leif's formula:
+!     ssz5a(i)=0.5*(sx+sy) + (real(z)**2 + aimag(z)**2 - sx*sy)/(sx+sy)
+     else
+        ssz5a(i)=sx
+     endif
+  enddo
+  if(ihsym.eq.278) then
+     if(iqadjust.ne.0 .and. ipkx.ne.0 .and. ipky.ne.0) then
+        rejectx=10.0*log10(savg(1,1+nfft-ipkx)/savg(1,1+ipkx))
+        rejecty=10.0*log10(savg(3,1+nfft-ipky)/savg(3,1+ipky))
+     endif
+  endif
+
+  nkhz=nint(1000.d0*(fcenter-int(fcenter)))
+  if(fcenter.eq.0.d0) nkhz=125
+
+999 return
+end subroutine symspec


Property changes on: branches/map65/libm65/symspec.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/tastro.f90
===================================================================
--- branches/map65/libm65/tastro.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/tastro.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,35 +1,35 @@
-program tastro
-
-  implicit real*8 (a-h,o-z)
-
-  character grid*6
-  character*9 cauxra,cauxdec
-
-  character*12 clock(3)
-  integer nt(8)
-  equivalence (nt(1),nyear)
-
-  grid='FN20qi'
-  nfreq=144
-  cauxra='00:00:00'
-  
-10 call date_and_time(clock(1),clock(2),clock(3),nt)
-  ih=ihour-ntz/60
-  if(ih.le.0) then
-     ih=ih+24
-     nday=nday+1
-  endif
-  uth8=ih + imin/60.d0 + isec/3600.d0 + ims/3600000.d0 
-  call astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
-     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
-     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
-     RaAux8,DecAux8,AzAux8,ElAux8,width1,width2,w501,w502,xlst8)
-  
-  write(*,1010) nyear,month,nday,ih,imin,isec,AzMoon8,ElMoon8,          &amp;
-       AzSun8,ElSun8,ndop,dgrd8,ntsky
-1010 format(i4,i3,i3,i4.2,':',i2.2,':',i2.2,4f8.1,i6,f6.1,i6)
-
-  call system('sleep 1')
-  go to 10
-
-end program tastro
+program tastro
+
+  implicit real*8 (a-h,o-z)
+
+  character grid*6
+  character*9 cauxra,cauxdec
+
+  character*12 clock(3)
+  integer nt(8)
+  equivalence (nt(1),nyear)
+
+  grid='FN20qi'
+  nfreq=144
+  cauxra='00:00:00'
+  
+10 call date_and_time(clock(1),clock(2),clock(3),nt)
+  ih=ihour-ntz/60
+  if(ih.le.0) then
+     ih=ih+24
+     nday=nday+1
+  endif
+  uth8=ih + imin/60.d0 + isec/3600.d0 + ims/3600000.d0 
+  call astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
+     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
+     RaAux8,DecAux8,AzAux8,ElAux8,width1,width2,w501,w502,xlst8)
+  
+  write(*,1010) nyear,month,nday,ih,imin,isec,AzMoon8,ElMoon8,          &amp;
+       AzSun8,ElSun8,ndop,dgrd8,ntsky
+1010 format(i4,i3,i3,i4.2,':',i2.2,':',i2.2,4f8.1,i6,f6.1,i6)
+
+  call system('sleep 1')
+  go to 10
+
+end program tastro


Property changes on: branches/map65/libm65/tastro.f90
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: branches/map65/libm65/timer.f90
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: branches/map65/libm65/timeval.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/timf2.f90
===================================================================
--- branches/map65/libm65/timf2.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/timf2.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,220 +1,220 @@
-subroutine timf2(nxpol,nfft,nwindow,nb,peaklimit,iqadjust,iqapply,faclim,   &amp;
-  cx0,cy0,gainx,gainy,phasex,phasey,cx1,cy1,slimit,lstrong,px,py,nzap)
-
-! Sequential processing of time-domain I/Q data, using Linrad-like
-! &quot;first FFT&quot; and &quot;first backward FFT&quot;.  
-
-!  cx0,cy0      - complex input data
-!  nfft      - length of FFTs
-!  nwindow   - 0 for no window, 2 for sin^2 window
-!  iqapply   - 0/1 determines if I/Q phase and amplitude corrections applied
-!  gainx,y   - gain error in Q channel, relative to I
-!  phasex,y  - phase error
-!  cx1,cy1   - output data
-
-! Non-windowed processing means no overlap, so kstep=nfft.  
-! Sin^2 window has 50% overlap, kstep=nfft/2.
-
-! Frequencies with strong signals are identified and separated.  The back
-! transforms are done separately for weak and strong signals, so that
-! noise blanking can be applied to the weak-signal portion.  Strong and
-! weak are finally re-combined in the time domain.
-
-  parameter (MAXFFT=1024,MAXNH=MAXFFT/2)
-  parameter (MAXSIGS=100)
-  complex cx0(0:nfft-1),cx1(0:nfft-1)
-  complex cy0(0:nfft-1),cy1(0:nfft-1)
-  complex cx(0:MAXFFT-1),cxt(0:MAXFFT-1)
-  complex cy(0:MAXFFT-1),cyt(0:MAXFFT-1)
-  complex cxs(0:MAXFFT-1),covxs(0:MAXNH-1)     !Strong X signals
-  complex cys(0:MAXFFT-1),covys(0:MAXNH-1)     !Strong Y signals
-  complex cxw(0:MAXFFT-1),covxw(0:MAXNH-1)     !Weak X signals
-  complex cyw(0:MAXFFT-1),covyw(0:MAXNH-1)     !Weak Y signals
-  real*4 w(0:MAXFFT-1)
-  real*4 s(0:MAXFFT-1),stmp(0:MAXFFT-1)
-  logical*1 lstrong(0:MAXFFT-1),lprev
-  integer ia(MAXSIGS),ib(MAXSIGS)
-  complex h,u,v
-  logical first
-  data first/.true./
-  save w,covxs,covxw,covys,covyw,s,ntc,ntot,nh,kstep,fac,first
-
-  if(first) then
-     pi=4.0*atan(1.0)
-     do i=0,nfft-1
-        w(i)=(sin(i*pi/nfft))**2
-     enddo
-     covxs=0.
-     covxw=0.
-     covys=0.
-     covyw=0.
-     s=0.
-     ntc=0
-     ntot=0
-     nh=nfft/2
-     kstep=nfft
-     if(nwindow.eq.2) kstep=nh
-     fac=1.0/nfft
-     slimit=1.e30
-     first=.false.
-  endif
-
-  cx(0:nfft-1)=cx0
-  if(nwindow.eq.2) cx(0:nfft-1)=w(0:nfft-1)*cx(0:nfft-1)
-  call four2a(cx,nfft,1,1,1)                       !First forward FFT
-
-  if(nxpol.ne.0) then
-     cy(0:nfft-1)=cy0
-     if(nwindow.eq.2) cy(0:nfft-1)=w(0:nfft-1)*cy(0:nfft-1)
-     call four2a(cy,nfft,1,1,1)                    !First forward FFT
-  endif
-
-  if(iqapply.ne.0) then                            !Apply I/Q corrections
-     h=gainx*cmplx(cos(phasex),sin(phasex))
-     v=0.
-     do i=0,nfft-1
-        u=cx(i)
-        if(i.gt.0) v=cx(nfft-i)
-        x=real(u)  + real(v)  - (aimag(u) + aimag(v))*aimag(h) +         &amp;
-             (real(u) - real(v))*real(h)
-        y=aimag(u) - aimag(v) + (aimag(u) + aimag(v))*real(h)  +         &amp;
-             (real(u) - real(v))*aimag(h)
-        cxt(i)=0.5*cmplx(x,y)
-     enddo
-  else
-     cxt(0:nfft-1)=cx(0:nfft-1)
-  endif
-
-  if(nxpol.ne.0) then
-     if(iqapply.ne.0) then                         !Apply I/Q corrections
-        h=gainy*cmplx(cos(phasey),sin(phasey))
-        v=0.
-        do i=0,nfft-1
-           u=cy(i)
-           if(i.gt.0) v=cy(nfft-i)
-           x=real(u)  + real(v)  - (aimag(u) + aimag(v))*aimag(h) +         &amp;
-                (real(u) - real(v))*real(h)
-           y=aimag(u) - aimag(v) + (aimag(u) + aimag(v))*real(h)  +         &amp;
-                (real(u) - real(v))*aimag(h)
-           cyt(i)=0.5*cmplx(x,y)
-        enddo
-     else
-        cyt(0:nfft-1)=cy(0:nfft-1)
-     endif
-  endif
-
-! Identify frequencies with strong signals, copy frequency-domain
-! data into array cs (strong) or cw (weak).
-
-  ntot=ntot+1
-  if(mod(ntot,128).eq.5) then
-     call pctile(s,stmp,1024,50,xmedian)
-     slimit=faclim*xmedian
-  endif
-
-  if(ntc.lt.96000/nfft) ntc=ntc+1
-  uu=1.0/ntc
-  smax=0.
-  do i=0,nfft-1
-     p=real(cxt(i))**2 + aimag(cxt(i))**2
-     if(nxpol.ne.0) p=p + real(cyt(i))**2 + aimag(cyt(i))**2
-     s(i)=(1.0-uu)*s(i) + uu*p
-     lstrong(i)=(s(i).gt.slimit)
-     if(s(i).gt.smax) smax=s(i)
-  enddo
-
-  nsigs=0
-  lprev=.false.
-  iwid=1
-  ib=-99
-  do i=0,nfft-1
-     if(lstrong(i) .and. (.not.lprev)) then
-        if(nsigs.lt.MAXSIGS) nsigs=nsigs+1
-        ia(nsigs)=i-iwid
-        if(ia(nsigs).lt.0) ia(nsigs)=0
-     endif
-     if(.not.lstrong(i) .and. lprev) then
-        ib(nsigs)=i-1+iwid
-        if(ib(nsigs).gt.nfft-1) ib(nsigs)=nfft-1
-     endif
-     lprev=lstrong(i)
-  enddo
-
-  if(nsigs.gt.0) then
-     do i=1,nsigs
-        ja=ia(i)
-        jb=ib(i)
-        if(ja.lt.0 .or. ja.gt.nfft-1 .or. jb.lt.0 .or. jb.gt.nfft-1) then
-           cycle
-        endif
-        if(jb.eq.-99) jb=ja + min(2*iwid,nfft-1)
-        lstrong(ja:jb)=.true.
-     enddo
-  endif
-
-  do i=0,nfft-1
-     if(lstrong(i)) then
-        cxs(i)=fac*cxt(i)
-        cxw(i)=0.
-        if(nxpol.ne.0) then
-           cys(i)=fac*cyt(i)
-           cyw(i)=0.
-        endif
-     else
-        cxw(i)=fac*cxt(i)
-        cxs(i)=0.
-        if(nxpol.ne.0) then
-           cyw(i)=fac*cyt(i)
-           cys(i)=0.
-        endif
-     endif
-  enddo
-
-  call four2a(cxw,nfft,1,-1,1)                 !Transform weak and strong X
-  call four2a(cxs,nfft,1,-1,1)                 !back to time domain, separately
-
-  if(nxpol.ne.0) then
-     call four2a(cyw,nfft,1,-1,1)              !Transform weak and strong Y
-     call four2a(cys,nfft,1,-1,1)              !back to time domain, separately
-  endif
-
-  if(nwindow.eq.2) then
-     cxw(0:nh-1)=cxw(0:nh-1)+covxw(0:nh-1)     !Add previous segment's 2nd half
-     covxw(0:nh-1)=cxw(nh:nfft-1)              !Save 2nd half
-     cxs(0:nh-1)=cxs(0:nh-1)+covxs(0:nh-1)     !Ditto for strong signals
-     covxs(0:nh-1)=cxs(nh:nfft-1)
-
-     if(nxpol.ne.0) then
-        cyw(0:nh-1)=cyw(0:nh-1)+covyw(0:nh-1)  !Add previous segment's 2nd half
-        covyw(0:nh-1)=cyw(nh:nfft-1)           !Save 2nd half
-        cys(0:nh-1)=cys(0:nh-1)+covys(0:nh-1)  !Ditto for strong signals
-        covys(0:nh-1)=cys(nh:nfft-1)
-     endif
-  endif
-
-! Apply noise blanking to weak data
-  if(nb.ne.0) then
-     do i=0,kstep-1
-        peak=abs(cxw(i))
-        if(nxpol.ne.0) peak=max(peak,abs(cyw(i)))
-        if(peak.gt.peaklimit) then
-           cxw(i)=0.
-           if(nxpol.ne.0) cyw(i)=0.
-           nzap=nzap+1
-        endif
-     enddo
-  endif
-
-! Compute power levels from weak data only
-  do i=0,kstep-1
-     px=px + real(cxw(i))**2 + aimag(cxw(i))**2
-     if(nxpol.ne.0) py=py + real(cyw(i))**2 + aimag(cyw(i))**2
-  enddo
-
-  cx1(0:kstep-1)=cxw(0:kstep-1) + cxs(0:kstep-1)     !Recombine weak + strong
-  if(nxpol.ne.0) then
-     cy1(0:kstep-1)=cyw(0:kstep-1) + cys(0:kstep-1)    !Weak + strong
-  endif
-
-  return
-end subroutine timf2
+subroutine timf2(nxpol,nfft,nwindow,nb,peaklimit,iqadjust,iqapply,faclim,   &amp;
+  cx0,cy0,gainx,gainy,phasex,phasey,cx1,cy1,slimit,lstrong,px,py,nzap)
+
+! Sequential processing of time-domain I/Q data, using Linrad-like
+! &quot;first FFT&quot; and &quot;first backward FFT&quot;.  
+
+!  cx0,cy0      - complex input data
+!  nfft      - length of FFTs
+!  nwindow   - 0 for no window, 2 for sin^2 window
+!  iqapply   - 0/1 determines if I/Q phase and amplitude corrections applied
+!  gainx,y   - gain error in Q channel, relative to I
+!  phasex,y  - phase error
+!  cx1,cy1   - output data
+
+! Non-windowed processing means no overlap, so kstep=nfft.  
+! Sin^2 window has 50% overlap, kstep=nfft/2.
+
+! Frequencies with strong signals are identified and separated.  The back
+! transforms are done separately for weak and strong signals, so that
+! noise blanking can be applied to the weak-signal portion.  Strong and
+! weak are finally re-combined in the time domain.
+
+  parameter (MAXFFT=1024,MAXNH=MAXFFT/2)
+  parameter (MAXSIGS=100)
+  complex cx0(0:nfft-1),cx1(0:nfft-1)
+  complex cy0(0:nfft-1),cy1(0:nfft-1)
+  complex cx(0:MAXFFT-1),cxt(0:MAXFFT-1)
+  complex cy(0:MAXFFT-1),cyt(0:MAXFFT-1)
+  complex cxs(0:MAXFFT-1),covxs(0:MAXNH-1)     !Strong X signals
+  complex cys(0:MAXFFT-1),covys(0:MAXNH-1)     !Strong Y signals
+  complex cxw(0:MAXFFT-1),covxw(0:MAXNH-1)     !Weak X signals
+  complex cyw(0:MAXFFT-1),covyw(0:MAXNH-1)     !Weak Y signals
+  real*4 w(0:MAXFFT-1)
+  real*4 s(0:MAXFFT-1),stmp(0:MAXFFT-1)
+  logical*1 lstrong(0:MAXFFT-1),lprev
+  integer ia(MAXSIGS),ib(MAXSIGS)
+  complex h,u,v
+  logical first
+  data first/.true./
+  save w,covxs,covxw,covys,covyw,s,ntc,ntot,nh,kstep,fac,first
+
+  if(first) then
+     pi=4.0*atan(1.0)
+     do i=0,nfft-1
+        w(i)=(sin(i*pi/nfft))**2
+     enddo
+     covxs=0.
+     covxw=0.
+     covys=0.
+     covyw=0.
+     s=0.
+     ntc=0
+     ntot=0
+     nh=nfft/2
+     kstep=nfft
+     if(nwindow.eq.2) kstep=nh
+     fac=1.0/nfft
+     slimit=1.e30
+     first=.false.
+  endif
+
+  cx(0:nfft-1)=cx0
+  if(nwindow.eq.2) cx(0:nfft-1)=w(0:nfft-1)*cx(0:nfft-1)
+  call four2a(cx,nfft,1,1,1)                       !First forward FFT
+
+  if(nxpol.ne.0) then
+     cy(0:nfft-1)=cy0
+     if(nwindow.eq.2) cy(0:nfft-1)=w(0:nfft-1)*cy(0:nfft-1)
+     call four2a(cy,nfft,1,1,1)                    !First forward FFT
+  endif
+
+  if(iqapply.ne.0) then                            !Apply I/Q corrections
+     h=gainx*cmplx(cos(phasex),sin(phasex))
+     v=0.
+     do i=0,nfft-1
+        u=cx(i)
+        if(i.gt.0) v=cx(nfft-i)
+        x=real(u)  + real(v)  - (aimag(u) + aimag(v))*aimag(h) +         &amp;
+             (real(u) - real(v))*real(h)
+        y=aimag(u) - aimag(v) + (aimag(u) + aimag(v))*real(h)  +         &amp;
+             (real(u) - real(v))*aimag(h)
+        cxt(i)=0.5*cmplx(x,y)
+     enddo
+  else
+     cxt(0:nfft-1)=cx(0:nfft-1)
+  endif
+
+  if(nxpol.ne.0) then
+     if(iqapply.ne.0) then                         !Apply I/Q corrections
+        h=gainy*cmplx(cos(phasey),sin(phasey))
+        v=0.
+        do i=0,nfft-1
+           u=cy(i)
+           if(i.gt.0) v=cy(nfft-i)
+           x=real(u)  + real(v)  - (aimag(u) + aimag(v))*aimag(h) +         &amp;
+                (real(u) - real(v))*real(h)
+           y=aimag(u) - aimag(v) + (aimag(u) + aimag(v))*real(h)  +         &amp;
+                (real(u) - real(v))*aimag(h)
+           cyt(i)=0.5*cmplx(x,y)
+        enddo
+     else
+        cyt(0:nfft-1)=cy(0:nfft-1)
+     endif
+  endif
+
+! Identify frequencies with strong signals, copy frequency-domain
+! data into array cs (strong) or cw (weak).
+
+  ntot=ntot+1
+  if(mod(ntot,128).eq.5) then
+     call pctile(s,stmp,1024,50,xmedian)
+     slimit=faclim*xmedian
+  endif
+
+  if(ntc.lt.96000/nfft) ntc=ntc+1
+  uu=1.0/ntc
+  smax=0.
+  do i=0,nfft-1
+     p=real(cxt(i))**2 + aimag(cxt(i))**2
+     if(nxpol.ne.0) p=p + real(cyt(i))**2 + aimag(cyt(i))**2
+     s(i)=(1.0-uu)*s(i) + uu*p
+     lstrong(i)=(s(i).gt.slimit)
+     if(s(i).gt.smax) smax=s(i)
+  enddo
+
+  nsigs=0
+  lprev=.false.
+  iwid=1
+  ib=-99
+  do i=0,nfft-1
+     if(lstrong(i) .and. (.not.lprev)) then
+        if(nsigs.lt.MAXSIGS) nsigs=nsigs+1
+        ia(nsigs)=i-iwid
+        if(ia(nsigs).lt.0) ia(nsigs)=0
+     endif
+     if(.not.lstrong(i) .and. lprev) then
+        ib(nsigs)=i-1+iwid
+        if(ib(nsigs).gt.nfft-1) ib(nsigs)=nfft-1
+     endif
+     lprev=lstrong(i)
+  enddo
+
+  if(nsigs.gt.0) then
+     do i=1,nsigs
+        ja=ia(i)
+        jb=ib(i)
+        if(ja.lt.0 .or. ja.gt.nfft-1 .or. jb.lt.0 .or. jb.gt.nfft-1) then
+           cycle
+        endif
+        if(jb.eq.-99) jb=ja + min(2*iwid,nfft-1)
+        lstrong(ja:jb)=.true.
+     enddo
+  endif
+
+  do i=0,nfft-1
+     if(lstrong(i)) then
+        cxs(i)=fac*cxt(i)
+        cxw(i)=0.
+        if(nxpol.ne.0) then
+           cys(i)=fac*cyt(i)
+           cyw(i)=0.
+        endif
+     else
+        cxw(i)=fac*cxt(i)
+        cxs(i)=0.
+        if(nxpol.ne.0) then
+           cyw(i)=fac*cyt(i)
+           cys(i)=0.
+        endif
+     endif
+  enddo
+
+  call four2a(cxw,nfft,1,-1,1)                 !Transform weak and strong X
+  call four2a(cxs,nfft,1,-1,1)                 !back to time domain, separately
+
+  if(nxpol.ne.0) then
+     call four2a(cyw,nfft,1,-1,1)              !Transform weak and strong Y
+     call four2a(cys,nfft,1,-1,1)              !back to time domain, separately
+  endif
+
+  if(nwindow.eq.2) then
+     cxw(0:nh-1)=cxw(0:nh-1)+covxw(0:nh-1)     !Add previous segment's 2nd half
+     covxw(0:nh-1)=cxw(nh:nfft-1)              !Save 2nd half
+     cxs(0:nh-1)=cxs(0:nh-1)+covxs(0:nh-1)     !Ditto for strong signals
+     covxs(0:nh-1)=cxs(nh:nfft-1)
+
+     if(nxpol.ne.0) then
+        cyw(0:nh-1)=cyw(0:nh-1)+covyw(0:nh-1)  !Add previous segment's 2nd half
+        covyw(0:nh-1)=cyw(nh:nfft-1)           !Save 2nd half
+        cys(0:nh-1)=cys(0:nh-1)+covys(0:nh-1)  !Ditto for strong signals
+        covys(0:nh-1)=cys(nh:nfft-1)
+     endif
+  endif
+
+! Apply noise blanking to weak data
+  if(nb.ne.0) then
+     do i=0,kstep-1
+        peak=abs(cxw(i))
+        if(nxpol.ne.0) peak=max(peak,abs(cyw(i)))
+        if(peak.gt.peaklimit) then
+           cxw(i)=0.
+           if(nxpol.ne.0) cyw(i)=0.
+           nzap=nzap+1
+        endif
+     enddo
+  endif
+
+! Compute power levels from weak data only
+  do i=0,kstep-1
+     px=px + real(cxw(i))**2 + aimag(cxw(i))**2
+     if(nxpol.ne.0) py=py + real(cyw(i))**2 + aimag(cyw(i))**2
+  enddo
+
+  cx1(0:kstep-1)=cxw(0:kstep-1) + cxs(0:kstep-1)     !Recombine weak + strong
+  if(nxpol.ne.0) then
+     cy1(0:kstep-1)=cyw(0:kstep-1) + cys(0:kstep-1)    !Weak + strong
+  endif
+
+  return
+end subroutine timf2


Property changes on: branches/map65/libm65/timf2.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/tm2.f90
===================================================================
--- branches/map65/libm65/tm2.f90	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/tm2.f90	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,14 +1,14 @@
-subroutine tm2(day,xlat4,xlon4,xl4,b4)
-
-  implicit real*8 (a-h,o-z)
-  parameter (RADS=0.0174532925199433d0)
-
-  real*4 day4,xlat4,xlon4,xl4,b4
-
-  glat=xlat4*RADS
-  glong=xlon4*RADS
-  call tmoonsub(day,glat,glong,el,rv,xl,b,pax)
-  xl4=xl
-  b4=b
-
-end subroutine tm2
+subroutine tm2(day,xlat4,xlon4,xl4,b4)
+
+  implicit real*8 (a-h,o-z)
+  parameter (RADS=0.0174532925199433d0)
+
+  real*4 day4,xlat4,xlon4,xl4,b4
+
+  glat=xlat4*RADS
+  glong=xlon4*RADS
+  call tmoonsub(day,glat,glong,el,rv,xl,b,pax)
+  xl4=xl
+  b4=b
+
+end subroutine tm2


Property changes on: branches/map65/libm65/tm2.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/tmoonsub.c
===================================================================
--- branches/map65/libm65/tmoonsub.c	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/tmoonsub.c	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,514 +1,514 @@
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;math.h&gt;
-
-#define RADS 0.0174532925199433
-#define DEGS 57.2957795130823
-#define TPI 6.28318530717959
-#define PI 3.1415927
-
-/* ratio of     earth radius to astronomical unit */
-#define ER_OVER_AU 0.0000426352325194252
-
-/* all prototypes here */
-
-double getcoord(int coord);
-void getargs(int argc, char *argv[], int *y, int *m, double *tz, double *glong, double *glat);
-double range(double y);
-double rangerad(double y);
-double days(int y, int m, int dn, double hour);
-double days_(int *y, int *m, int *dn, double *hour);
-void moonpos(double, double *, double *, double *);
-void sunpos(double , double *, double *, double *);
-double moontransit(int y, int m, int d, double timezone, double glat, double glong, int *nt);
-double atan22(double y, double x);
-double epsilon(double d);
-void equatorial(double d, double *lon, double *lat, double *r);
-void ecliptic(double d, double *lon, double *lat, double *r);
-double gst(double d);
-void topo(double lst, double glat, double *alp, double *dec, double *r);
-double alt(double glat, double ha, double dec);
-void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p);
-void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill);
-int daysinmonth(int y, int m);
-int isleap(int y);
-void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
-   double *mrv, double *l, double *b, double *paxis);
-
-static const char
-*usage = &quot;  Usage: tmoon date[yyyymm] timz[+/-h.hh] long[+/-dddmm] lat[+/-ddmm]\n&quot;
-            &quot;example: tmoon 200009 0 -00155 5230\n&quot;;
-
-/*
-  getargs() gets the arguments from the command line, does some basic error
-  checking, and converts arguments into numerical form. Arguments are passed
-  back in pointers. Error messages print to stderr so re-direction of output
-  to file won't leave users blind. Error checking prints list of all errors
-  in a command line before quitting.
-*/
-void getargs(int argc, char *argv[], int *y, int *m, double *tz,
-             double *glong, double *glat) {
-
-  int date, latitude, longitude;
-  int mflag = 0, yflag = 0, longflag = 0, latflag = 0, tzflag = 0;
-  int longminflag = 0, latminflag = 0, dflag = 0;
-
-  /* if not right number of arguments, then print example command line */
-
-  if (argc !=5) {
-    fprintf(stderr, usage);
-    exit(EXIT_FAILURE);
-  }
-
-  date = atoi(argv[1]);
-  *y = date / 100;
-  *m = date - *y * 100;
-  *tz = (double) atof(argv[2]);
-  longitude = atoi(argv[3]);
-  latitude = atoi(argv[4]);
-  *glong = RADS * getcoord(longitude);
-  *glat = RADS * getcoord(latitude);
-
-  /* set a flag for each error found */
-
-  if (*m &gt; 12 || *m &lt; 1) mflag = 1;
-  if (*y &gt; 2500) yflag = 1;
-  if (date &lt; 150001) dflag = 1;
-  if (fabs((float) *glong) &gt; 180 * RADS) longflag = 1;
-  if (abs(longitude) % 100 &gt; 59) longminflag = 1;
-  if (fabs((float) *glat) &gt; 90 * RADS) latflag = 1;
-  if (abs(latitude) % 100 &gt; 59) latminflag = 1;
-  if (fabs((float) *tz) &gt; 12) tzflag = 1;
-
-  /* print all the errors found */
-  
-  if (dflag == 1) {
-    fprintf(stderr, &quot;date: dates must be in form yyyymm, gregorian, and later than 1500 AD\n&quot;);
-  }
-  if (yflag == 1) {
-    fprintf(stderr, &quot;date: too far in future - accurate from 1500 to 2500\n&quot;);
-  }
-  if (mflag == 1) {
-    fprintf(stderr, &quot;date: month must be in range 0 to 12, eg - August 2000 is entered as 200008\n&quot;);
-  }
-  if (tzflag == 1) {
-    fprintf(stderr, &quot;timz: must be in range +/- 12 hours, eg -6 for Chicago\n&quot;);
-  }
-  if (longflag == 1) {
-    fprintf(stderr, &quot;long: must be in range +/- 180 degrees\n&quot;);
-  }
-  if (longminflag == 1) {
-    fprintf(stderr, &quot;long: last two digits are arcmin - max 59\n&quot;);
-  }
-  if (latflag == 1) {
-    fprintf(stderr, &quot; lat: must be in range +/- 90 degrees\n&quot;);
-  }
-  if (latminflag == 1) {
-    fprintf(stderr, &quot; lat: last two digits are arcmin - max 59\n&quot;);
-  }
-
-  /* quits if one or more flags set */
-
-  if (dflag + mflag + yflag + longflag + latflag + tzflag + longminflag + latminflag &gt; 0) {
-    exit(EXIT_FAILURE);
-  }
-  
-}
-
-/*
-   returns coordinates in decimal degrees given the
-   coord as a ddmm value stored in an integer.
-*/
-double getcoord(int coord) {
-  int west = 1;
-  double glg, deg;
-  if (coord &lt; 0) west = -1;
-  glg = fabs((double) coord/100);
-  deg = floor(glg);
-  glg = west* (deg + (glg - deg)*100 / 60);
-  return(glg);
-}
-
-/*
-  days() takes the year, month, day in the month and decimal hours
-  in the day and returns the number of days since J2000.0.
-  Assumes Gregorian calendar.
-*/
-double days(int y, int m, int d, double h) {
-  int a, b;
-  double day;
-  
-  /*
-    The lines below work from 1900 march to feb 2100
-    a = 367 * y - 7 * (y + (m + 9) / 12) / 4 + 275 * m / 9 + d;
-    day = (double)a - 730531.5 + hour / 24;
-  */
-
-  /*  These lines work for any Gregorian date since 0 AD */
-  if (m ==1 || m==2) {
-    m +=12;
-    y -= 1;
-  }
-  a = y / 100;
-  b = 2 - a + a/4;
-  day = floor(365.25*(y + 4716)) + floor(30.6001*(m + 1))
-    + d + b - 1524.5 - 2451545 + h/24;
-  return(day);
-}
-double days_(int *y0, int *m0, int *d0, double *h0) 
-{
-  return days(*y0,*m0,*d0,*h0);
-}
-
-/*
-Returns 1 if y a leap year, and 0 otherwise, according
-to the Gregorian calendar
-*/
-int isleap(int y) {
-  int a = 0;
-  if(y % 4 == 0) a = 1;
-  if(y % 100 == 0) a = 0;
-  if(y % 400 == 0) a = 1;
-  return(a);
-}
-
-/*
-Given the year and the month, function returns the
-number of days in the month. Valid for Gregorian
-calendar.
-*/
-int daysinmonth(int y, int m) {
-  int b = 31;
-  if(m == 2) {
-    if(isleap(y) == 1) b= 29;
-    else b = 28;
-  }
-  if(m == 4 || m == 6 || m == 9 || m == 11) b = 30;
-  return(b);
-}
-
-/*
-moonpos() takes days from J2000.0 and returns ecliptic coordinates
-of moon in the pointers. Note call by reference.
-This function is within a couple of arcminutes most of the time,
-and is truncated from the Meeus Ch45 series, themselves truncations of
-ELP-2000. Returns moon distance in earth radii.
-Terms have been written out explicitly rather than using the
-table based method as only a small number of terms is
-retained.
-*/
-void moonpos(double d, double *lambda, double *beta, double *rvec) {
-  double dl, dB, dR, L, D, M, M1, F, e, lm, bm, rm, t;
-
-  t = d / 36525;
-
-  L = range(218.3164591  + 481267.88134236  * t) * RADS;
-  D = range(297.8502042  + 445267.1115168  * t) * RADS;
-  M = range(357.5291092  + 35999.0502909  * t) * RADS;
-  M1 = range(134.9634114  + 477198.8676313  * t - .008997 * t * t) * RADS;
-  F = range(93.27209929999999  + 483202.0175273  * t - .0034029*t*t)*RADS;
-  e = 1 - .002516 * t;
-
-  dl =      6288774 * sin(M1);
-  dl +=     1274027 * sin(2 * D - M1);
-  dl +=      658314 * sin(2 * D);
-  dl +=      213618 * sin(2 * M1);
-  dl -=  e * 185116 * sin(M);
-  dl -=      114332 * sin(2 * F) ;
-  dl +=       58793 * sin(2 * D - 2 * M1);
-  dl +=   e * 57066 * sin(2 * D - M - M1) ;
-  dl +=       53322 * sin(2 * D + M1);
-  dl +=   e * 45758 * sin(2 * D - M);
-  dl -=   e * 40923 * sin(M - M1);
-  dl -=       34720 * sin(D) ;
-  dl -=   e * 30383 * sin(M + M1) ;
-  dl +=       15327 * sin(2 * D - 2 * F) ;
-  dl -=       12528 * sin(M1 + 2 * F);
-  dl +=       10980 * sin(M1 - 2 * F);
-  lm = rangerad(L + dl / 1000000 * RADS);
-
-  dB =   5128122 * sin(F);
-  dB +=   280602 * sin(M1 + F);
-  dB +=   277693 * sin(M1 - F);
-  dB +=   173237 * sin(2 * D - F);
-  dB +=    55413 * sin(2 * D - M1 + F);
-  dB +=    46271 * sin(2 * D - M1 - F);
-  dB +=    32573 * sin(2 * D + F);
-  dB +=    17198 * sin(2 * M1 + F);
-  dB +=     9266 * sin(2 * D + M1 - F);
-  dB +=     8822 * sin(2 * M1 - F);
-  dB += e * 8216 * sin(2 * D - M - F);
-  dB +=     4324 * sin(2 * D - 2 * M1 - F);
-  bm = dB / 1000000 * RADS;
-
-  dR =    -20905355 * cos(M1);
-  dR -=     3699111 * cos(2 * D - M1);
-  dR -=     2955968 * cos(2 * D);
-  dR -=      569925 * cos(2 * M1);
-  dR +=   e * 48888 * cos(M);
-  dR -=        3149 * cos(2 * F);
-  dR +=      246158 * cos(2 * D - 2 * M1);
-  dR -=  e * 152138 * cos(2 * D - M - M1) ;
-  dR -=      170733 * cos(2 * D + M1);
-  dR -=  e * 204586 * cos(2 * D - M);
-  dR -=  e * 129620 * cos(M - M1);
-  dR +=      108743 * cos(D);
-  dR +=  e * 104755 * cos(M + M1);
-  dR +=       79661 * cos(M1 - 2 * F);
-  rm = 385000.56  + dR / 1000;
-
-  *lambda = lm;
-  *beta = bm;
-  /* distance to Moon must be in Earth radii */
-  *rvec = rm / 6378.14;
-}
-
-/*
-topomoon() takes the local siderial time, the geographical
-latitude of the observer, and pointers to the geocentric
-equatorial coordinates. The function overwrites the geocentric
-coordinates with topocentric coordinates on a simple spherical
-earth model (no polar flattening). Expects Moon-Earth distance in
-Earth radii.    Formulas scavenged from Astronomical Almanac 'low
-precision formulae for Moon position' page D46.
-*/
-
-void topo(double lst, double glat, double *alp, double *dec, double *r) {
-  double x, y, z, r1;
-  x = *r * cos(*dec) * cos(*alp) - cos(glat) * cos(lst);
-  y = *r * cos(*dec) * sin(*alp) - cos(glat) * sin(lst);
-  z = *r * sin(*dec)  - sin(glat);
-  r1 = sqrt(x*x + y*y + z*z);
-  *alp = atan22(y, x);
-  *dec = asin(z / r1);
-  *r = r1;
-}
-
-/*
-moontransit() takes date, the time zone and geographic longitude
-of observer and returns the time (decimal hours) of lunar transit
-on that day if there is one, and sets the notransit flag if there
-isn't. See Explanatory Supplement to Astronomical Almanac
-section 9.32 and 9.31 for the method.
-*/
-
-double moontransit(int y, int m, int d, double tz, double glat, double glong, int *notransit) {
-  double hm, ht, ht1, lon, lat, rv, dnew, lst;
-  int itcount;
-
-  ht1 = 180 * RADS;
-  ht = 0;
-  itcount = 0;
-  *notransit = 0;
-  do {
-    ht = ht1;
-    itcount++;
-    dnew = days(y, m, d, ht * DEGS/15) - tz/24;
-    lst = gst(dnew) + glong;
-    /* find the topocentric Moon ra (hence hour angle) and dec */
-    moonpos(dnew, &amp;lon, &amp;lat, &amp;rv);
-    equatorial(dnew, &amp;lon, &amp;lat, &amp;rv);
-    topo(lst, glat, &amp;lon, &amp;lat, &amp;rv);
-    hm = rangerad(lst -  lon);
-    ht1 = rangerad(ht - hm);
-    /* if no convergence, then no transit on that day */
-    if (itcount &gt; 30) {
-      *notransit = 1;
-      break;
-    }
-  }
-  while (fabs(ht - ht1) &gt; 0.04 * RADS);
-  return(ht1);
-}
-
-/*
-  Calculates the selenographic coordinates of either the sub Earth point
-  (optical libration) or the sub-solar point (selen. coords of centre of
-  bright hemisphere).  Based on Meeus chapter 51 but neglects physical
-  libration and nutation, with some simplification of the formulas.
-*/
-void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p) {
-  double i, f, omega, w, y, x, a, t, eps;
-  t = day / 36525;
-  i = 1.54242 * RADS;
-  eps = epsilon(day);
-  f = range(93.2720993 + 483202.0175273 * t - .0034029 * t * t) * RADS;
-  omega = range(125.044555 - 1934.1361849 * t + .0020762 * t * t) * RADS;
-  w = lambda - omega;
-  y = sin(w) * cos(beta) * cos(i) - sin(beta) * sin(i);
-  x = cos(w) * cos(beta);
-  a = atan22(y, x);
-  *l = a - f;
-
-  /*  kludge to catch cases of 'round the back' angles  */
-  if (*l &lt; -90 * RADS) *l += TPI;
-  if (*l &gt; 90 * RADS)  *l -= TPI;
-  *b = asin(-sin(w) * cos(beta) * sin(i) - sin(beta) * cos(i));
-
-  /*  pa pole axis - not used for Sun stuff */
-  x = sin(i) * sin(omega);
-  y = sin(i) * cos(omega) * cos(eps) - cos(i) * sin(eps);
-  w = atan22(x, y);
-  *p = rangerad(asin(sqrt(x*x + y*y) * cos(alpha - w) / cos(*b)));
-}
-
-/*
-  Takes: days since J2000.0, eq coords Moon, ratio of moon to sun distance,
-  eq coords Sun
-  Returns: position angle of bright limb wrt NCP, percentage illumination
-  of Sun
-*/
-void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill) {
-  double x, y, phi, i;
-  y = cos(sdec) * sin(sra - lra);
-  x = sin(sdec) * cos(ldec) - cos(sdec) * sin(ldec) * cos (sra - lra);
-  *pabl = atan22(y, x);
-  phi = acos(sin(sdec) * sin(ldec) + cos(sdec) * cos(ldec) * cos(sra-lra));
-  i = atan22(sin(phi) , (dr - cos(phi)));
-  *ill = 0.5*(1 + cos(i));
-}
-
-/*
-sunpos() takes days from J2000.0 and returns ecliptic longitude
-of Sun in the pointers. Latitude is zero at this level of precision,
-but pointer left in for consistency in number of arguments.
-This function is within 0.01 degree (1 arcmin) almost all the time
-for a century either side of J2000.0. This is from the 'low precision
-fomulas for the Sun' from C24 of Astronomical Alamanac
-*/
-void sunpos(double d, double *lambda, double *beta, double *rvec) {
-  double L, g, ls, bs, rs;
-
-  L = range(280.461 + .9856474 * d) * RADS;
-  g = range(357.528 + .9856003 * d) * RADS;
-  ls = L + (1.915 * sin(g) + .02 * sin(2 * g)) * RADS;
-  bs = 0;
-  rs = 1.00014 - .01671 * cos(g) - .00014 * cos(2 * g);
-  *lambda = ls;
-  *beta = bs;
-  *rvec = rs;
-}
-
-/*
-this routine returns the altitude given the days since J2000.0
-the hour angle and declination of the object and the latitude
-of the observer. Used to find the Sun's altitude to put a letter
-code on the transit time, and to find the Moon's altitude at
-transit just to make sure that the Moon is visible.
-*/
-double alt(double glat, double ha, double dec) {
-  return(asin(sin(dec) * sin(glat) + cos(dec) * cos(glat) * cos(ha)));
-}
-
-/* returns an angle in degrees in the range 0 to 360 */
-double range(double x) {
-  double a, b;
-  b = x / 360;
-  a = 360 * (b - floor(b));
-  if (a &lt; 0)
-    a = 360 + a;
-  return(a);
-}
-
-/* returns an angle in rads in the range 0 to two pi */
-double rangerad(double x) {
-  double a, b;
-  b = x / TPI;
-  a = TPI * (b - floor(b));
-  if (a &lt; 0)
-    a = TPI + a;
-  return(a);
-}
-
-/*
-gets the atan2 function returning angles in the right
-order and  range
-*/
-double atan22(double y, double x) {
-  double a;
-
-  a = atan2(y, x);
-  if (a &lt; 0) a += TPI;
-  return(a);
-}
-
-/*
-returns mean obliquity of ecliptic in radians given days since
-J2000.0.
-*/
-double epsilon(double d) {
-  double t = d/ 36525;
-  return((23.4392911111111 - (t* (46.8150 + 0.00059*t)/3600)) *RADS);
-}
-
-/*
-replaces ecliptic coordinates with equatorial coordinates
-note: call by reference destroys original values
-R is unchanged.
-*/
-void equatorial(double d, double *lon, double *lat, double *r) {
-  double  eps, ceps, seps, l, b;
-
-  l = *lon;
-  b = * lat;
-  eps = epsilon(d);
-  ceps = cos(eps);
-  seps = sin(eps);
-  *lon = atan22(sin(l)*ceps - tan(b)*seps, cos(l));
-  *lat = asin(sin(b)*ceps + cos(b)*seps*sin(l));
-}
-
-/*
-replaces equatorial coordinates with ecliptic ones. Inverse
-of above, but used to find topocentric ecliptic coords.
-*/
-void ecliptic(double d, double *lon, double *lat, double *r) {
-  double  eps, ceps, seps, alp, dec;
-  alp = *lon;
-  dec = *lat;
-  eps = epsilon(d);
-  ceps = cos(eps);
-  seps = sin(eps);
-  *lon = atan22(sin(alp)*ceps + tan(dec)*seps, cos(alp));
-  *lat = asin(sin(dec)*ceps - cos(dec)*seps*sin(alp));
-}
-
-/*
-returns the siderial time at greenwich meridian as
-an angle in radians given the days since J2000.0
-*/
-double gst( double d) {
-  double t = d / 36525;
-  double theta;
-  theta = range(280.46061837 + 360.98564736629 * d + 0.000387933 * t * t);
-  return(theta * RADS);
-}
-
-void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
-   double *mrv, double *l, double *b, double *paxis)
-{
-  double mlambda, mbeta;
-  double malpha, mdelta;
-  double lst, mhr;
-  double tlambda, tbeta, trv;
-
-  lst = gst(*day) + *glong;
-      
-  /* find Moon topocentric coordinates for libration calculations */
-
-  moonpos(*day, &amp;mlambda, &amp;mbeta, mrv);
-  malpha = mlambda;
-  mdelta = mbeta;
-  equatorial(*day, &amp;malpha, &amp;mdelta, mrv);
-  topo(lst, *glat, &amp;malpha, &amp;mdelta, mrv);
-  mhr = rangerad(lst - malpha);
-  *moonalt = alt(*glat, mhr, mdelta);
-      
-  /* Optical libration and Position angle of the Pole */
-
-  tlambda = malpha;
-  tbeta = mdelta;
-  trv = *mrv;
-  ecliptic(*day, &amp;tlambda, &amp;tbeta, &amp;trv);
-  libration(*day, tlambda, tbeta, malpha,  l, b, paxis);
-}
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+#define RADS 0.0174532925199433
+#define DEGS 57.2957795130823
+#define TPI 6.28318530717959
+#define PI 3.1415927
+
+/* ratio of     earth radius to astronomical unit */
+#define ER_OVER_AU 0.0000426352325194252
+
+/* all prototypes here */
+
+double getcoord(int coord);
+void getargs(int argc, char *argv[], int *y, int *m, double *tz, double *glong, double *glat);
+double range(double y);
+double rangerad(double y);
+double days(int y, int m, int dn, double hour);
+double days_(int *y, int *m, int *dn, double *hour);
+void moonpos(double, double *, double *, double *);
+void sunpos(double , double *, double *, double *);
+double moontransit(int y, int m, int d, double timezone, double glat, double glong, int *nt);
+double atan22(double y, double x);
+double epsilon(double d);
+void equatorial(double d, double *lon, double *lat, double *r);
+void ecliptic(double d, double *lon, double *lat, double *r);
+double gst(double d);
+void topo(double lst, double glat, double *alp, double *dec, double *r);
+double alt(double glat, double ha, double dec);
+void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p);
+void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill);
+int daysinmonth(int y, int m);
+int isleap(int y);
+void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
+   double *mrv, double *l, double *b, double *paxis);
+
+static const char
+*usage = &quot;  Usage: tmoon date[yyyymm] timz[+/-h.hh] long[+/-dddmm] lat[+/-ddmm]\n&quot;
+            &quot;example: tmoon 200009 0 -00155 5230\n&quot;;
+
+/*
+  getargs() gets the arguments from the command line, does some basic error
+  checking, and converts arguments into numerical form. Arguments are passed
+  back in pointers. Error messages print to stderr so re-direction of output
+  to file won't leave users blind. Error checking prints list of all errors
+  in a command line before quitting.
+*/
+void getargs(int argc, char *argv[], int *y, int *m, double *tz,
+             double *glong, double *glat) {
+
+  int date, latitude, longitude;
+  int mflag = 0, yflag = 0, longflag = 0, latflag = 0, tzflag = 0;
+  int longminflag = 0, latminflag = 0, dflag = 0;
+
+  /* if not right number of arguments, then print example command line */
+
+  if (argc !=5) {
+    fprintf(stderr, usage);
+    exit(EXIT_FAILURE);
+  }
+
+  date = atoi(argv[1]);
+  *y = date / 100;
+  *m = date - *y * 100;
+  *tz = (double) atof(argv[2]);
+  longitude = atoi(argv[3]);
+  latitude = atoi(argv[4]);
+  *glong = RADS * getcoord(longitude);
+  *glat = RADS * getcoord(latitude);
+
+  /* set a flag for each error found */
+
+  if (*m &gt; 12 || *m &lt; 1) mflag = 1;
+  if (*y &gt; 2500) yflag = 1;
+  if (date &lt; 150001) dflag = 1;
+  if (fabs((float) *glong) &gt; 180 * RADS) longflag = 1;
+  if (abs(longitude) % 100 &gt; 59) longminflag = 1;
+  if (fabs((float) *glat) &gt; 90 * RADS) latflag = 1;
+  if (abs(latitude) % 100 &gt; 59) latminflag = 1;
+  if (fabs((float) *tz) &gt; 12) tzflag = 1;
+
+  /* print all the errors found */
+  
+  if (dflag == 1) {
+    fprintf(stderr, &quot;date: dates must be in form yyyymm, gregorian, and later than 1500 AD\n&quot;);
+  }
+  if (yflag == 1) {
+    fprintf(stderr, &quot;date: too far in future - accurate from 1500 to 2500\n&quot;);
+  }
+  if (mflag == 1) {
+    fprintf(stderr, &quot;date: month must be in range 0 to 12, eg - August 2000 is entered as 200008\n&quot;);
+  }
+  if (tzflag == 1) {
+    fprintf(stderr, &quot;timz: must be in range +/- 12 hours, eg -6 for Chicago\n&quot;);
+  }
+  if (longflag == 1) {
+    fprintf(stderr, &quot;long: must be in range +/- 180 degrees\n&quot;);
+  }
+  if (longminflag == 1) {
+    fprintf(stderr, &quot;long: last two digits are arcmin - max 59\n&quot;);
+  }
+  if (latflag == 1) {
+    fprintf(stderr, &quot; lat: must be in range +/- 90 degrees\n&quot;);
+  }
+  if (latminflag == 1) {
+    fprintf(stderr, &quot; lat: last two digits are arcmin - max 59\n&quot;);
+  }
+
+  /* quits if one or more flags set */
+
+  if (dflag + mflag + yflag + longflag + latflag + tzflag + longminflag + latminflag &gt; 0) {
+    exit(EXIT_FAILURE);
+  }
+  
+}
+
+/*
+   returns coordinates in decimal degrees given the
+   coord as a ddmm value stored in an integer.
+*/
+double getcoord(int coord) {
+  int west = 1;
+  double glg, deg;
+  if (coord &lt; 0) west = -1;
+  glg = fabs((double) coord/100);
+  deg = floor(glg);
+  glg = west* (deg + (glg - deg)*100 / 60);
+  return(glg);
+}
+
+/*
+  days() takes the year, month, day in the month and decimal hours
+  in the day and returns the number of days since J2000.0.
+  Assumes Gregorian calendar.
+*/
+double days(int y, int m, int d, double h) {
+  int a, b;
+  double day;
+  
+  /*
+    The lines below work from 1900 march to feb 2100
+    a = 367 * y - 7 * (y + (m + 9) / 12) / 4 + 275 * m / 9 + d;
+    day = (double)a - 730531.5 + hour / 24;
+  */
+
+  /*  These lines work for any Gregorian date since 0 AD */
+  if (m ==1 || m==2) {
+    m +=12;
+    y -= 1;
+  }
+  a = y / 100;
+  b = 2 - a + a/4;
+  day = floor(365.25*(y + 4716)) + floor(30.6001*(m + 1))
+    + d + b - 1524.5 - 2451545 + h/24;
+  return(day);
+}
+double days_(int *y0, int *m0, int *d0, double *h0) 
+{
+  return days(*y0,*m0,*d0,*h0);
+}
+
+/*
+Returns 1 if y a leap year, and 0 otherwise, according
+to the Gregorian calendar
+*/
+int isleap(int y) {
+  int a = 0;
+  if(y % 4 == 0) a = 1;
+  if(y % 100 == 0) a = 0;
+  if(y % 400 == 0) a = 1;
+  return(a);
+}
+
+/*
+Given the year and the month, function returns the
+number of days in the month. Valid for Gregorian
+calendar.
+*/
+int daysinmonth(int y, int m) {
+  int b = 31;
+  if(m == 2) {
+    if(isleap(y) == 1) b= 29;
+    else b = 28;
+  }
+  if(m == 4 || m == 6 || m == 9 || m == 11) b = 30;
+  return(b);
+}
+
+/*
+moonpos() takes days from J2000.0 and returns ecliptic coordinates
+of moon in the pointers. Note call by reference.
+This function is within a couple of arcminutes most of the time,
+and is truncated from the Meeus Ch45 series, themselves truncations of
+ELP-2000. Returns moon distance in earth radii.
+Terms have been written out explicitly rather than using the
+table based method as only a small number of terms is
+retained.
+*/
+void moonpos(double d, double *lambda, double *beta, double *rvec) {
+  double dl, dB, dR, L, D, M, M1, F, e, lm, bm, rm, t;
+
+  t = d / 36525;
+
+  L = range(218.3164591  + 481267.88134236  * t) * RADS;
+  D = range(297.8502042  + 445267.1115168  * t) * RADS;
+  M = range(357.5291092  + 35999.0502909  * t) * RADS;
+  M1 = range(134.9634114  + 477198.8676313  * t - .008997 * t * t) * RADS;
+  F = range(93.27209929999999  + 483202.0175273  * t - .0034029*t*t)*RADS;
+  e = 1 - .002516 * t;
+
+  dl =      6288774 * sin(M1);
+  dl +=     1274027 * sin(2 * D - M1);
+  dl +=      658314 * sin(2 * D);
+  dl +=      213618 * sin(2 * M1);
+  dl -=  e * 185116 * sin(M);
+  dl -=      114332 * sin(2 * F) ;
+  dl +=       58793 * sin(2 * D - 2 * M1);
+  dl +=   e * 57066 * sin(2 * D - M - M1) ;
+  dl +=       53322 * sin(2 * D + M1);
+  dl +=   e * 45758 * sin(2 * D - M);
+  dl -=   e * 40923 * sin(M - M1);
+  dl -=       34720 * sin(D) ;
+  dl -=   e * 30383 * sin(M + M1) ;
+  dl +=       15327 * sin(2 * D - 2 * F) ;
+  dl -=       12528 * sin(M1 + 2 * F);
+  dl +=       10980 * sin(M1 - 2 * F);
+  lm = rangerad(L + dl / 1000000 * RADS);
+
+  dB =   5128122 * sin(F);
+  dB +=   280602 * sin(M1 + F);
+  dB +=   277693 * sin(M1 - F);
+  dB +=   173237 * sin(2 * D - F);
+  dB +=    55413 * sin(2 * D - M1 + F);
+  dB +=    46271 * sin(2 * D - M1 - F);
+  dB +=    32573 * sin(2 * D + F);
+  dB +=    17198 * sin(2 * M1 + F);
+  dB +=     9266 * sin(2 * D + M1 - F);
+  dB +=     8822 * sin(2 * M1 - F);
+  dB += e * 8216 * sin(2 * D - M - F);
+  dB +=     4324 * sin(2 * D - 2 * M1 - F);
+  bm = dB / 1000000 * RADS;
+
+  dR =    -20905355 * cos(M1);
+  dR -=     3699111 * cos(2 * D - M1);
+  dR -=     2955968 * cos(2 * D);
+  dR -=      569925 * cos(2 * M1);
+  dR +=   e * 48888 * cos(M);
+  dR -=        3149 * cos(2 * F);
+  dR +=      246158 * cos(2 * D - 2 * M1);
+  dR -=  e * 152138 * cos(2 * D - M - M1) ;
+  dR -=      170733 * cos(2 * D + M1);
+  dR -=  e * 204586 * cos(2 * D - M);
+  dR -=  e * 129620 * cos(M - M1);
+  dR +=      108743 * cos(D);
+  dR +=  e * 104755 * cos(M + M1);
+  dR +=       79661 * cos(M1 - 2 * F);
+  rm = 385000.56  + dR / 1000;
+
+  *lambda = lm;
+  *beta = bm;
+  /* distance to Moon must be in Earth radii */
+  *rvec = rm / 6378.14;
+}
+
+/*
+topomoon() takes the local siderial time, the geographical
+latitude of the observer, and pointers to the geocentric
+equatorial coordinates. The function overwrites the geocentric
+coordinates with topocentric coordinates on a simple spherical
+earth model (no polar flattening). Expects Moon-Earth distance in
+Earth radii.    Formulas scavenged from Astronomical Almanac 'low
+precision formulae for Moon position' page D46.
+*/
+
+void topo(double lst, double glat, double *alp, double *dec, double *r) {
+  double x, y, z, r1;
+  x = *r * cos(*dec) * cos(*alp) - cos(glat) * cos(lst);
+  y = *r * cos(*dec) * sin(*alp) - cos(glat) * sin(lst);
+  z = *r * sin(*dec)  - sin(glat);
+  r1 = sqrt(x*x + y*y + z*z);
+  *alp = atan22(y, x);
+  *dec = asin(z / r1);
+  *r = r1;
+}
+
+/*
+moontransit() takes date, the time zone and geographic longitude
+of observer and returns the time (decimal hours) of lunar transit
+on that day if there is one, and sets the notransit flag if there
+isn't. See Explanatory Supplement to Astronomical Almanac
+section 9.32 and 9.31 for the method.
+*/
+
+double moontransit(int y, int m, int d, double tz, double glat, double glong, int *notransit) {
+  double hm, ht, ht1, lon, lat, rv, dnew, lst;
+  int itcount;
+
+  ht1 = 180 * RADS;
+  ht = 0;
+  itcount = 0;
+  *notransit = 0;
+  do {
+    ht = ht1;
+    itcount++;
+    dnew = days(y, m, d, ht * DEGS/15) - tz/24;
+    lst = gst(dnew) + glong;
+    /* find the topocentric Moon ra (hence hour angle) and dec */
+    moonpos(dnew, &amp;lon, &amp;lat, &amp;rv);
+    equatorial(dnew, &amp;lon, &amp;lat, &amp;rv);
+    topo(lst, glat, &amp;lon, &amp;lat, &amp;rv);
+    hm = rangerad(lst -  lon);
+    ht1 = rangerad(ht - hm);
+    /* if no convergence, then no transit on that day */
+    if (itcount &gt; 30) {
+      *notransit = 1;
+      break;
+    }
+  }
+  while (fabs(ht - ht1) &gt; 0.04 * RADS);
+  return(ht1);
+}
+
+/*
+  Calculates the selenographic coordinates of either the sub Earth point
+  (optical libration) or the sub-solar point (selen. coords of centre of
+  bright hemisphere).  Based on Meeus chapter 51 but neglects physical
+  libration and nutation, with some simplification of the formulas.
+*/
+void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p) {
+  double i, f, omega, w, y, x, a, t, eps;
+  t = day / 36525;
+  i = 1.54242 * RADS;
+  eps = epsilon(day);
+  f = range(93.2720993 + 483202.0175273 * t - .0034029 * t * t) * RADS;
+  omega = range(125.044555 - 1934.1361849 * t + .0020762 * t * t) * RADS;
+  w = lambda - omega;
+  y = sin(w) * cos(beta) * cos(i) - sin(beta) * sin(i);
+  x = cos(w) * cos(beta);
+  a = atan22(y, x);
+  *l = a - f;
+
+  /*  kludge to catch cases of 'round the back' angles  */
+  if (*l &lt; -90 * RADS) *l += TPI;
+  if (*l &gt; 90 * RADS)  *l -= TPI;
+  *b = asin(-sin(w) * cos(beta) * sin(i) - sin(beta) * cos(i));
+
+  /*  pa pole axis - not used for Sun stuff */
+  x = sin(i) * sin(omega);
+  y = sin(i) * cos(omega) * cos(eps) - cos(i) * sin(eps);
+  w = atan22(x, y);
+  *p = rangerad(asin(sqrt(x*x + y*y) * cos(alpha - w) / cos(*b)));
+}
+
+/*
+  Takes: days since J2000.0, eq coords Moon, ratio of moon to sun distance,
+  eq coords Sun
+  Returns: position angle of bright limb wrt NCP, percentage illumination
+  of Sun
+*/
+void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill) {
+  double x, y, phi, i;
+  y = cos(sdec) * sin(sra - lra);
+  x = sin(sdec) * cos(ldec) - cos(sdec) * sin(ldec) * cos (sra - lra);
+  *pabl = atan22(y, x);
+  phi = acos(sin(sdec) * sin(ldec) + cos(sdec) * cos(ldec) * cos(sra-lra));
+  i = atan22(sin(phi) , (dr - cos(phi)));
+  *ill = 0.5*(1 + cos(i));
+}
+
+/*
+sunpos() takes days from J2000.0 and returns ecliptic longitude
+of Sun in the pointers. Latitude is zero at this level of precision,
+but pointer left in for consistency in number of arguments.
+This function is within 0.01 degree (1 arcmin) almost all the time
+for a century either side of J2000.0. This is from the 'low precision
+fomulas for the Sun' from C24 of Astronomical Alamanac
+*/
+void sunpos(double d, double *lambda, double *beta, double *rvec) {
+  double L, g, ls, bs, rs;
+
+  L = range(280.461 + .9856474 * d) * RADS;
+  g = range(357.528 + .9856003 * d) * RADS;
+  ls = L + (1.915 * sin(g) + .02 * sin(2 * g)) * RADS;
+  bs = 0;
+  rs = 1.00014 - .01671 * cos(g) - .00014 * cos(2 * g);
+  *lambda = ls;
+  *beta = bs;
+  *rvec = rs;
+}
+
+/*
+this routine returns the altitude given the days since J2000.0
+the hour angle and declination of the object and the latitude
+of the observer. Used to find the Sun's altitude to put a letter
+code on the transit time, and to find the Moon's altitude at
+transit just to make sure that the Moon is visible.
+*/
+double alt(double glat, double ha, double dec) {
+  return(asin(sin(dec) * sin(glat) + cos(dec) * cos(glat) * cos(ha)));
+}
+
+/* returns an angle in degrees in the range 0 to 360 */
+double range(double x) {
+  double a, b;
+  b = x / 360;
+  a = 360 * (b - floor(b));
+  if (a &lt; 0)
+    a = 360 + a;
+  return(a);
+}
+
+/* returns an angle in rads in the range 0 to two pi */
+double rangerad(double x) {
+  double a, b;
+  b = x / TPI;
+  a = TPI * (b - floor(b));
+  if (a &lt; 0)
+    a = TPI + a;
+  return(a);
+}
+
+/*
+gets the atan2 function returning angles in the right
+order and  range
+*/
+double atan22(double y, double x) {
+  double a;
+
+  a = atan2(y, x);
+  if (a &lt; 0) a += TPI;
+  return(a);
+}
+
+/*
+returns mean obliquity of ecliptic in radians given days since
+J2000.0.
+*/
+double epsilon(double d) {
+  double t = d/ 36525;
+  return((23.4392911111111 - (t* (46.8150 + 0.00059*t)/3600)) *RADS);
+}
+
+/*
+replaces ecliptic coordinates with equatorial coordinates
+note: call by reference destroys original values
+R is unchanged.
+*/
+void equatorial(double d, double *lon, double *lat, double *r) {
+  double  eps, ceps, seps, l, b;
+
+  l = *lon;
+  b = * lat;
+  eps = epsilon(d);
+  ceps = cos(eps);
+  seps = sin(eps);
+  *lon = atan22(sin(l)*ceps - tan(b)*seps, cos(l));
+  *lat = asin(sin(b)*ceps + cos(b)*seps*sin(l));
+}
+
+/*
+replaces equatorial coordinates with ecliptic ones. Inverse
+of above, but used to find topocentric ecliptic coords.
+*/
+void ecliptic(double d, double *lon, double *lat, double *r) {
+  double  eps, ceps, seps, alp, dec;
+  alp = *lon;
+  dec = *lat;
+  eps = epsilon(d);
+  ceps = cos(eps);
+  seps = sin(eps);
+  *lon = atan22(sin(alp)*ceps + tan(dec)*seps, cos(alp));
+  *lat = asin(sin(dec)*ceps - cos(dec)*seps*sin(alp));
+}
+
+/*
+returns the siderial time at greenwich meridian as
+an angle in radians given the days since J2000.0
+*/
+double gst( double d) {
+  double t = d / 36525;
+  double theta;
+  theta = range(280.46061837 + 360.98564736629 * d + 0.000387933 * t * t);
+  return(theta * RADS);
+}
+
+void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
+   double *mrv, double *l, double *b, double *paxis)
+{
+  double mlambda, mbeta;
+  double malpha, mdelta;
+  double lst, mhr;
+  double tlambda, tbeta, trv;
+
+  lst = gst(*day) + *glong;
+      
+  /* find Moon topocentric coordinates for libration calculations */
+
+  moonpos(*day, &amp;mlambda, &amp;mbeta, mrv);
+  malpha = mlambda;
+  mdelta = mbeta;
+  equatorial(*day, &amp;malpha, &amp;mdelta, mrv);
+  topo(lst, *glat, &amp;malpha, &amp;mdelta, mrv);
+  mhr = rangerad(lst - malpha);
+  *moonalt = alt(*glat, mhr, mdelta);
+      
+  /* Optical libration and Position angle of the Pole */
+
+  tlambda = malpha;
+  tbeta = mdelta;
+  trv = *mrv;
+  ecliptic(*day, &amp;tlambda, &amp;tbeta, &amp;trv);
+  libration(*day, tlambda, tbeta, malpha,  l, b, paxis);
+}


Property changes on: branches/map65/libm65/tmoonsub.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/toxyz.f
===================================================================
--- branches/map65/libm65/toxyz.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/toxyz.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,25 +1,25 @@
-      subroutine toxyz(alpha,delta,r,vec)
-
-      implicit real*8 (a-h,o-z)
-      real*8 vec(3)
-
-      vec(1)=r*cos(delta)*cos(alpha)
-      vec(2)=r*cos(delta)*sin(alpha)
-      vec(3)=r*sin(delta)
-
-      return
-      end
-
-      subroutine fromxyz(vec,alpha,delta,r)
-
-      implicit real*8 (a-h,o-z)
-      real*8 vec(3)
-      data twopi/6.283185307d0/
-
-      r=sqrt(vec(1)**2 + vec(2)**2 + vec(3)**2)
-      alpha=atan2(vec(2),vec(1))
-      if(alpha.lt.0.d0) alpha=alpha+twopi
-      delta=asin(vec(3)/r)
-
-      return
-      end
+      subroutine toxyz(alpha,delta,r,vec)
+
+      implicit real*8 (a-h,o-z)
+      real*8 vec(3)
+
+      vec(1)=r*cos(delta)*cos(alpha)
+      vec(2)=r*cos(delta)*sin(alpha)
+      vec(3)=r*sin(delta)
+
+      return
+      end
+
+      subroutine fromxyz(vec,alpha,delta,r)
+
+      implicit real*8 (a-h,o-z)
+      real*8 vec(3)
+      data twopi/6.283185307d0/
+
+      r=sqrt(vec(1)**2 + vec(2)**2 + vec(3)**2)
+      alpha=atan2(vec(2),vec(1))
+      if(alpha.lt.0.d0) alpha=alpha+twopi
+      delta=asin(vec(3)/r)
+
+      return
+      end


Property changes on: branches/map65/libm65/toxyz.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/trimlist.f
===================================================================
--- branches/map65/libm65/trimlist.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/trimlist.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,28 +1,28 @@
-      subroutine trimlist(sig,km,ftol,indx,nsiz,nz)
-
-      parameter (MAXMSG=1000)             !Size of decoded message list
-      real sig(MAXMSG,30)
-      integer indx(MAXMSG),nsiz(MAXMSG)
-
-C     1      2     3    4    5    6     7     8
-C   nfile  nutc  freq  snr  dt  ipol  flip  sync
-
-      call indexx(km,sig(1,3),indx)            !Sort list by frequency
-
-      n=1
-      i0=1
-      do i=2,km         
-         j0=indx(i-1)
-         j=indx(i)
-         if(sig(j,3)-sig(j0,3).gt.ftol) then
-            nsiz(n)=i-i0
-            i0=i
-            n=n+1
-         endif
-      enddo
-      nz=n
-      nsiz(nz)=km+1-i0
-      nsiz(nz+1)=-1
-
-      return
-      end
+      subroutine trimlist(sig,km,ftol,indx,nsiz,nz)
+
+      parameter (MAXMSG=1000)             !Size of decoded message list
+      real sig(MAXMSG,30)
+      integer indx(MAXMSG),nsiz(MAXMSG)
+
+C     1      2     3    4    5    6     7     8
+C   nfile  nutc  freq  snr  dt  ipol  flip  sync
+
+      call indexx(km,sig(1,3),indx)            !Sort list by frequency
+
+      n=1
+      i0=1
+      do i=2,km         
+         j0=indx(i-1)
+         j=indx(i)
+         if(sig(j,3)-sig(j0,3).gt.ftol) then
+            nsiz(n)=i-i0
+            i0=i
+            n=n+1
+         endif
+      enddo
+      nz=n
+      nsiz(nz)=km+1-i0
+      nsiz(nz+1)=-1
+
+      return
+      end


Property changes on: branches/map65/libm65/trimlist.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/twkfreq.f
===================================================================
--- branches/map65/libm65/twkfreq.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/twkfreq.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,29 +1,29 @@
-      subroutine twkfreq(c4aa,c4bb,n5,a)
-
-      complex c4aa(n5)
-      complex c4bb(n5)
-      real a(5)
-      complex w,wstep
-      data twopi/6.283185307/
-
-C  Apply AFC corrections to the c4aa and c4bb data
-      w=1.0
-      wstep=1.0
-      x0=0.5*(n5+1)
-      s=2.0/n5
-      do i=1,n5
-         x=s*(i-x0)
-         if(mod(i,1000).eq.1) then
-            p2=1.5*x*x - 0.5
-!            p3=2.5*(x**3) - 1.5*x
-!            p4=4.375*(x**4) - 3.75*(x**2) + 0.375
-            dphi=(a(1) + x*a(2) + p2*a(3)) * (twopi/1378.125)
-            wstep=cmplx(cos(dphi),sin(dphi))
-         endif
-         w=w*wstep
-         c4aa(i)=w*c4aa(i)
-         c4bb(i)=w*c4bb(i)
-      enddo
-
-      return
-      end
+      subroutine twkfreq(c4aa,c4bb,n5,a)
+
+      complex c4aa(n5)
+      complex c4bb(n5)
+      real a(5)
+      complex w,wstep
+      data twopi/6.283185307/
+
+C  Apply AFC corrections to the c4aa and c4bb data
+      w=1.0
+      wstep=1.0
+      x0=0.5*(n5+1)
+      s=2.0/n5
+      do i=1,n5
+         x=s*(i-x0)
+         if(mod(i,1000).eq.1) then
+            p2=1.5*x*x - 0.5
+!            p3=2.5*(x**3) - 1.5*x
+!            p4=4.375*(x**4) - 3.75*(x**2) + 0.375
+            dphi=(a(1) + x*a(2) + p2*a(3)) * (twopi/1378.125)
+            wstep=cmplx(cos(dphi),sin(dphi))
+         endif
+         w=w*wstep
+         c4aa(i)=w*c4aa(i)
+         c4bb(i)=w*c4bb(i)
+      enddo
+
+      return
+      end


Property changes on: branches/map65/libm65/twkfreq.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/unpackcall.f
===================================================================
--- branches/map65/libm65/unpackcall.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/unpackcall.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,142 +1,142 @@
-      subroutine unpackcall(ncall,word,iv2,psfx)
-
-      parameter (NBASE=37*36*10*27*27*27)
-      character word*12,c*37,psfx*4
-
-      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ '/
-
-      n=ncall
-      iv2=0
-      if(n.ge.262177560) go to 20
-      word='......'
-      if(n.ge.262177560) go to 999            !Plain text message ...
-      i=mod(n,27)+11
-      word(6:6)=c(i:i)
-      n=n/27
-      i=mod(n,27)+11
-      word(5:5)=c(i:i)
-      n=n/27
-      i=mod(n,27)+11
-      word(4:4)=c(i:i)
-      n=n/27
-      i=mod(n,10)+1
-      word(3:3)=c(i:i)
-      n=n/10
-      i=mod(n,36)+1
-      word(2:2)=c(i:i)
-      n=n/36
-      i=n+1
-      word(1:1)=c(i:i)
-      do i=1,4
-         if(word(i:i).ne.' ') go to 10
-      enddo
-      go to 999
- 10   word=word(i:)
-      go to 999
-
- 20   if(n.ge.267796946) go to 999
-
-! We have a JT65v2 message
-      if((n.ge.262178563) .and. (n.le.264002071)) Then
-! CQ with prefix
-         iv2=1
-         n=n-262178563
-         i=mod(n,37)+1
-         psfx(4:4)=c(i:i)
-         n=n/37
-         i=mod(n,37)+1
-         psfx(3:3)=c(i:i)
-         n=n/37
-         i=mod(n,37)+1
-         psfx(2:2)=c(i:i)
-         n=n/37
-         i=n+1
-         psfx(1:1)=c(i:i)
-      endif
-
-      if((n.ge.264002072) .and. (n.le.265825580)) Then
-! QRZ with prefix
-         iv2=2
-         n=n-264002072
-         i=mod(n,37)+1
-         psfx(4:4)=c(i:i)
-         n=n/37
-         i=mod(n,37)+1
-         psfx(3:3)=c(i:i)
-         n=n/37
-         i=mod(n,37)+1
-         psfx(2:2)=c(i:i)
-         n=n/37
-         i=n+1
-         psfx(1:1)=c(i:i)
-      endif
-
-      if((n.ge.265825581) .and. (n.le.267649089)) Then
-! DE with prefix
-         iv2=3
-         n=n-265825581
-         i=mod(n,37)+1
-         psfx(4:4)=c(i:i)
-         n=n/37
-         i=mod(n,37)+1
-         psfx(3:3)=c(i:i)
-         n=n/37
-         i=mod(n,37)+1
-         psfx(2:2)=c(i:i)
-         n=n/37
-         i=n+1
-         psfx(1:1)=c(i:i)
-      endif
-
-      if((n.ge.267649090) .and. (n.le.267698374)) Then
-! CQ with suffix
-         iv2=4
-         n=n-267649090
-         i=mod(n,37)+1
-         psfx(3:3)=c(i:i)
-         n=n/37
-         i=mod(n,37)+1
-         psfx(2:2)=c(i:i)
-         n=n/37
-         i=n+1
-         psfx(1:1)=c(i:i)
-      endif
-
-      if((n.ge.267698375) .and. (n.le.267747659)) Then
-! QRZ with suffix
-         iv2=5
-         n=n-267698375
-         i=mod(n,37)+1
-         psfx(3:3)=c(i:i)
-         n=n/37
-         i=mod(n,37)+1
-         psfx(2:2)=c(i:i)
-         n=n/37
-         i=n+1
-         psfx(1:1)=c(i:i)
-      endif
-
-      if((n.ge.267747660) .and. (n.le.267796944)) Then
-! DE with suffix
-         iv2=6
-         n=n-267747660
-         i=mod(n,37)+1
-         psfx(3:3)=c(i:i)
-         n=n/37
-         i=mod(n,37)+1
-         psfx(2:2)=c(i:i)
-         n=n/37
-         i=n+1
-         psfx(1:1)=c(i:i)
-      endif
-
-      if(n.eq.267796945) Then
-! DE with no prefix or suffix
-         iv2=7
-         psfx = '    '
-      endif
-
- 999  if(word(1:3).eq.'3D0') word='3DA0'//word(4:)
-
-      return
-      end
+      subroutine unpackcall(ncall,word,iv2,psfx)
+
+      parameter (NBASE=37*36*10*27*27*27)
+      character word*12,c*37,psfx*4
+
+      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ '/
+
+      n=ncall
+      iv2=0
+      if(n.ge.262177560) go to 20
+      word='......'
+      if(n.ge.262177560) go to 999            !Plain text message ...
+      i=mod(n,27)+11
+      word(6:6)=c(i:i)
+      n=n/27
+      i=mod(n,27)+11
+      word(5:5)=c(i:i)
+      n=n/27
+      i=mod(n,27)+11
+      word(4:4)=c(i:i)
+      n=n/27
+      i=mod(n,10)+1
+      word(3:3)=c(i:i)
+      n=n/10
+      i=mod(n,36)+1
+      word(2:2)=c(i:i)
+      n=n/36
+      i=n+1
+      word(1:1)=c(i:i)
+      do i=1,4
+         if(word(i:i).ne.' ') go to 10
+      enddo
+      go to 999
+ 10   word=word(i:)
+      go to 999
+
+ 20   if(n.ge.267796946) go to 999
+
+! We have a JT65v2 message
+      if((n.ge.262178563) .and. (n.le.264002071)) Then
+! CQ with prefix
+         iv2=1
+         n=n-262178563
+         i=mod(n,37)+1
+         psfx(4:4)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.264002072) .and. (n.le.265825580)) Then
+! QRZ with prefix
+         iv2=2
+         n=n-264002072
+         i=mod(n,37)+1
+         psfx(4:4)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.265825581) .and. (n.le.267649089)) Then
+! DE with prefix
+         iv2=3
+         n=n-265825581
+         i=mod(n,37)+1
+         psfx(4:4)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.267649090) .and. (n.le.267698374)) Then
+! CQ with suffix
+         iv2=4
+         n=n-267649090
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.267698375) .and. (n.le.267747659)) Then
+! QRZ with suffix
+         iv2=5
+         n=n-267698375
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if((n.ge.267747660) .and. (n.le.267796944)) Then
+! DE with suffix
+         iv2=6
+         n=n-267747660
+         i=mod(n,37)+1
+         psfx(3:3)=c(i:i)
+         n=n/37
+         i=mod(n,37)+1
+         psfx(2:2)=c(i:i)
+         n=n/37
+         i=n+1
+         psfx(1:1)=c(i:i)
+      endif
+
+      if(n.eq.267796945) Then
+! DE with no prefix or suffix
+         iv2=7
+         psfx = '    '
+      endif
+
+ 999  if(word(1:3).eq.'3D0') word='3DA0'//word(4:)
+
+      return
+      end


Property changes on: branches/map65/libm65/unpackcall.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/unpackgrid.f
===================================================================
--- branches/map65/libm65/unpackgrid.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/unpackgrid.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,32 +1,32 @@
-      subroutine unpackgrid(ng,grid)
-
-      parameter (NGBASE=180*180)
-      character grid*4,grid6*6
-
-      grid='    '
-      if(ng.ge.32400) go to 10
-      dlat=mod(ng,180)-90
-      dlong=(ng/180)*2 - 180 + 2
-      call deg2grid(dlong,dlat,grid6)
-      grid=grid6(:4)
-      go to 100
-
- 10   n=ng-NGBASE-1
-      if(n.ge.1 .and.n.le.30) then
-         write(grid,1012) -n
- 1012    format(i3.2)
-      else if(n.ge.31 .and.n.le.60) then
-         n=n-30
-         write(grid,1022) -n
- 1022    format('R',i3.2)
-      else if(n.eq.61) then
-         grid='RO'
-      else if(n.eq.62) then
-         grid='RRR'
-      else if(n.eq.63) then
-         grid='73'
-      endif
-
- 100  return
-      end
-
+      subroutine unpackgrid(ng,grid)
+
+      parameter (NGBASE=180*180)
+      character grid*4,grid6*6
+
+      grid='    '
+      if(ng.ge.32400) go to 10
+      dlat=mod(ng,180)-90
+      dlong=(ng/180)*2 - 180 + 2
+      call deg2grid(dlong,dlat,grid6)
+      grid=grid6(:4)
+      go to 100
+
+ 10   n=ng-NGBASE-1
+      if(n.ge.1 .and.n.le.30) then
+         write(grid,1012) -n
+ 1012    format(i3.2)
+      else if(n.ge.31 .and.n.le.60) then
+         n=n-30
+         write(grid,1022) -n
+ 1022    format('R',i3.2)
+      else if(n.eq.61) then
+         grid='RO'
+      else if(n.eq.62) then
+         grid='RRR'
+      else if(n.eq.63) then
+         grid='73'
+      endif
+
+ 100  return
+      end
+


Property changes on: branches/map65/libm65/unpackgrid.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/unpackmsg.f
===================================================================
--- branches/map65/libm65/unpackmsg.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/unpackmsg.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,100 +1,100 @@
-      subroutine unpackmsg(dat,msg)
-
-      parameter (NBASE=37*36*10*27*27*27)
-      parameter (NGBASE=180*180)
-      integer dat(12)
-      character c1*12,c2*12,grid*4,msg*22,grid6*6,psfx*4,junk2*4
-      logical cqnnn
-
-      cqnnn=.false.
-      nc1=ishft(dat(1),22) + ishft(dat(2),16) + ishft(dat(3),10)+
-     +  ishft(dat(4),4) + iand(ishft(dat(5),-2),15)
-
-      nc2=ishft(iand(dat(5),3),26) + ishft(dat(6),20) + 
-     +  ishft(dat(7),14) + ishft(dat(8),8) + ishft(dat(9),2) + 
-     +  iand(ishft(dat(10),-4),3)
-
-      ng=ishft(iand(dat(10),15),12) + ishft(dat(11),6) + dat(12)
-
-      if(ng.gt.32768) then
-         call unpacktext(nc1,nc2,ng,msg)
-         go to 100
-      endif
-
-      call unpackcall(nc1,c1,iv2,psfx)
-      if(iv2.eq.0) then
-! This is an &quot;original JT65&quot; message
-         if(nc1.eq.NBASE+1) c1='CQ    '
-         if(nc1.eq.NBASE+2) c1='QRZ   '
-         nfreq=nc1-NBASE-3
-         if(nfreq.ge.0 .and. nfreq.le.999) then
-            write(c1,1002) nfreq
- 1002       format('CQ ',i3.3)
-            cqnnn=.true.
-         endif
-      endif
-
-      call unpackcall(nc2,c2,junk1,junk2)
-      call unpackgrid(ng,grid)
-
-      if(iv2.gt.0) then
-! This is a JT65v2 message
-         n1=len_trim(psfx)
-         n2=len_trim(c2)
-         if(iv2.eq.1) msg='CQ '//psfx(:n1)//'/'//c2(:n2)//' '//grid
-         if(iv2.eq.2) msg='QRZ '//psfx(:n1)//'/'//c2(:n2)//' '//grid
-         if(iv2.eq.3) msg='DE '//psfx(:n1)//'/'//c2(:n2)//' '//grid
-         if(iv2.eq.4) msg='CQ '//c2(:n2)//'/'//psfx(:n1)//' '//grid
-         if(iv2.eq.5) msg='QRZ '//c2(:n2)//'/'//psfx(:n1)//' '//grid
-         if(iv2.eq.6) msg='DE '//c2(:n2)//'/'//psfx(:n1)//' '//grid
-         if(iv2.eq.7) msg='DE '//c2(:n2)//' '//grid
-         go to 100
-      else
-         
-      endif
-
-      grid6=grid//'ma'
-      call grid2k(grid6,k)
-      if(k.ge.1 .and. k.le.450)   call getpfx2(k,c1)
-      if(k.ge.451 .and. k.le.900) call getpfx2(k,c2)
-
-      i=index(c1,char(0))
-      if(i.ge.3) c1=c1(1:i-1)//'            '
-      i=index(c2,char(0))
-      if(i.ge.3) c2=c2(1:i-1)//'            '
-
-      msg='                      '
-      j=0
-      if(cqnnn) then
-         msg=c1//'          '
-         j=7                                  !### ??? ###
-         go to 10
-      endif
-
-      do i=1,12
-         j=j+1
-         msg(j:j)=c1(i:i)
-         if(c1(i:i).eq.' ') go to 10
-      enddo
-      j=j+1
-      msg(j:j)=' '
-
- 10   do i=1,12
-         if(j.le.21) j=j+1
-         msg(j:j)=c2(i:i)
-         if(c2(i:i).eq.' ') go to 20
-      enddo
-      if(j.le.21) j=j+1
-      msg(j:j)=' '
-
- 20   if(k.eq.0) then
-         do i=1,4
-            if(j.le.21) j=j+1
-            msg(j:j)=grid(i:i)
-         enddo
-         if(j.le.21) j=j+1
-         msg(j:j)=' '
-      endif
-
- 100  return
-      end
+      subroutine unpackmsg(dat,msg)
+
+      parameter (NBASE=37*36*10*27*27*27)
+      parameter (NGBASE=180*180)
+      integer dat(12)
+      character c1*12,c2*12,grid*4,msg*22,grid6*6,psfx*4,junk2*4
+      logical cqnnn
+
+      cqnnn=.false.
+      nc1=ishft(dat(1),22) + ishft(dat(2),16) + ishft(dat(3),10)+
+     +  ishft(dat(4),4) + iand(ishft(dat(5),-2),15)
+
+      nc2=ishft(iand(dat(5),3),26) + ishft(dat(6),20) + 
+     +  ishft(dat(7),14) + ishft(dat(8),8) + ishft(dat(9),2) + 
+     +  iand(ishft(dat(10),-4),3)
+
+      ng=ishft(iand(dat(10),15),12) + ishft(dat(11),6) + dat(12)
+
+      if(ng.gt.32768) then
+         call unpacktext(nc1,nc2,ng,msg)
+         go to 100
+      endif
+
+      call unpackcall(nc1,c1,iv2,psfx)
+      if(iv2.eq.0) then
+! This is an &quot;original JT65&quot; message
+         if(nc1.eq.NBASE+1) c1='CQ    '
+         if(nc1.eq.NBASE+2) c1='QRZ   '
+         nfreq=nc1-NBASE-3
+         if(nfreq.ge.0 .and. nfreq.le.999) then
+            write(c1,1002) nfreq
+ 1002       format('CQ ',i3.3)
+            cqnnn=.true.
+         endif
+      endif
+
+      call unpackcall(nc2,c2,junk1,junk2)
+      call unpackgrid(ng,grid)
+
+      if(iv2.gt.0) then
+! This is a JT65v2 message
+         n1=len_trim(psfx)
+         n2=len_trim(c2)
+         if(iv2.eq.1) msg='CQ '//psfx(:n1)//'/'//c2(:n2)//' '//grid
+         if(iv2.eq.2) msg='QRZ '//psfx(:n1)//'/'//c2(:n2)//' '//grid
+         if(iv2.eq.3) msg='DE '//psfx(:n1)//'/'//c2(:n2)//' '//grid
+         if(iv2.eq.4) msg='CQ '//c2(:n2)//'/'//psfx(:n1)//' '//grid
+         if(iv2.eq.5) msg='QRZ '//c2(:n2)//'/'//psfx(:n1)//' '//grid
+         if(iv2.eq.6) msg='DE '//c2(:n2)//'/'//psfx(:n1)//' '//grid
+         if(iv2.eq.7) msg='DE '//c2(:n2)//' '//grid
+         go to 100
+      else
+         
+      endif
+
+      grid6=grid//'ma'
+      call grid2k(grid6,k)
+      if(k.ge.1 .and. k.le.450)   call getpfx2(k,c1)
+      if(k.ge.451 .and. k.le.900) call getpfx2(k,c2)
+
+      i=index(c1,char(0))
+      if(i.ge.3) c1=c1(1:i-1)//'            '
+      i=index(c2,char(0))
+      if(i.ge.3) c2=c2(1:i-1)//'            '
+
+      msg='                      '
+      j=0
+      if(cqnnn) then
+         msg=c1//'          '
+         j=7                                  !### ??? ###
+         go to 10
+      endif
+
+      do i=1,12
+         j=j+1
+         msg(j:j)=c1(i:i)
+         if(c1(i:i).eq.' ') go to 10
+      enddo
+      j=j+1
+      msg(j:j)=' '
+
+ 10   do i=1,12
+         if(j.le.21) j=j+1
+         msg(j:j)=c2(i:i)
+         if(c2(i:i).eq.' ') go to 20
+      enddo
+      if(j.le.21) j=j+1
+      msg(j:j)=' '
+
+ 20   if(k.eq.0) then
+         do i=1,4
+            if(j.le.21) j=j+1
+            msg(j:j)=grid(i:i)
+         enddo
+         if(j.le.21) j=j+1
+         msg(j:j)=' '
+      endif
+
+ 100  return
+      end


Property changes on: branches/map65/libm65/unpackmsg.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/unpacktext.f
===================================================================
--- branches/map65/libm65/unpacktext.f	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/unpacktext.f	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,35 +1,35 @@
-      subroutine unpacktext(nc1,nc2,nc3,msg)
-
-      character*22 msg
-      character*44 c
-      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?'/
-
-      nc3=iand(nc3,32767)                      !Remove the &quot;plain text&quot; bit
-      if(iand(nc1,1).ne.0) nc3=nc3+32768
-      nc1=nc1/2
-      if(iand(nc2,1).ne.0) nc3=nc3+65536
-      nc2=nc2/2
-
-      do i=5,1,-1
-         j=mod(nc1,42)+1
-         msg(i:i)=c(j:j)
-         nc1=nc1/42
-      enddo
-
-      do i=10,6,-1
-         j=mod(nc2,42)+1
-         msg(i:i)=c(j:j)
-         nc2=nc2/42
-      enddo
-
-      do i=13,11,-1
-         j=mod(nc3,42)+1
-         msg(i:i)=c(j:j)
-         nc3=nc3/42
-      enddo
-      msg(14:22) = '         '
-
-      return
-      end
-
-
+      subroutine unpacktext(nc1,nc2,nc3,msg)
+
+      character*22 msg
+      character*44 c
+      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?'/
+
+      nc3=iand(nc3,32767)                      !Remove the &quot;plain text&quot; bit
+      if(iand(nc1,1).ne.0) nc3=nc3+32768
+      nc1=nc1/2
+      if(iand(nc2,1).ne.0) nc3=nc3+65536
+      nc2=nc2/2
+
+      do i=5,1,-1
+         j=mod(nc1,42)+1
+         msg(i:i)=c(j:j)
+         nc1=nc1/42
+      enddo
+
+      do i=10,6,-1
+         j=mod(nc2,42)+1
+         msg(i:i)=c(j:j)
+         nc2=nc2/42
+      enddo
+
+      do i=13,11,-1
+         j=mod(nc3,42)+1
+         msg(i:i)=c(j:j)
+         nc3=nc3/42
+      enddo
+      msg(14:22) = '         '
+
+      return
+      end
+
+


Property changes on: branches/map65/libm65/unpacktext.f
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/libm65/wrapkarn.c
===================================================================
--- branches/map65/libm65/wrapkarn.c	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/libm65/wrapkarn.c	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,70 +1,70 @@
-#include &lt;math.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;float.h&gt;
-#include &lt;limits.h&gt;
-#include &lt;stdlib.h&gt;
-#include &quot;rs.h&quot;
-
-static void *rs;
-static int first=1;
-
-void rs_encode_(int *dgen, int *sent)
-// Encode JT65 data dgen[12], producing sent[63].
-{
-  int dat1[12];
-  int b[51];
-  int i;
-
-  if(first) {
-    // Initialize the JT65 codec
-    rs=init_rs_int(6,0x43,3,1,51,0);
-    first=0;
-  }
-
-  // Reverse data order for the Karn codec.
-  for(i=0; i&lt;12; i++) {
-    dat1[i]=dgen[11-i];
-  }
-  // Compute the parity symbols
-  encode_rs_int(rs,dat1,b);
-
-  // Move parity symbols and data into sent[] array, in reverse order.
-  for (i = 0; i &lt; 51; i++) sent[50-i] = b[i];
-  for (i = 0; i &lt; 12; i++) sent[i+51] = dat1[11-i];
-}
-
-void rs_decode_(int *recd0, int *era0, int *numera0, int *decoded, int *nerr)
-// Decode JT65 received data recd0[63], producing decoded[12].
-// Erasures are indicated in era0[numera].  The number of corrected
-// errors is *nerr.  If the data are uncorrectable, *nerr=-1 is returned.
-{
-  int numera;
-  int i;
-  int era_pos[50];
-  int recd[63];
-
-  if(first) {
-    rs=init_rs_int(6,0x43,3,1,51,0);
-    first=0;
-  }
-
-  numera=*numera0;
-  for(i=0; i&lt;12; i++) recd[i]=recd0[62-i];
-  for(i=0; i&lt;51; i++) recd[12+i]=recd0[50-i];
-  if(numera) 
-    for(i=0; i&lt;numera; i++) era_pos[i]=era0[i];
-  *nerr=decode_rs_int(rs,recd,era_pos,numera);
-  for(i=0; i&lt;12; i++) decoded[i]=recd[11-i];
-}
-
-
-void rs_encode__(int *dgen, int *sent)
-{
-  rs_encode_(dgen, sent);
-}
-
-void rs_decode__(int *recd0, int *era0, int *numera0, int *decoded, int *nerr)
-{
-  rs_decode_(recd0, era0, numera0, decoded, nerr);
-}
-
+#include &lt;math.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;float.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;rs.h&quot;
+
+static void *rs;
+static int first=1;
+
+void rs_encode_(int *dgen, int *sent)
+// Encode JT65 data dgen[12], producing sent[63].
+{
+  int dat1[12];
+  int b[51];
+  int i;
+
+  if(first) {
+    // Initialize the JT65 codec
+    rs=init_rs_int(6,0x43,3,1,51,0);
+    first=0;
+  }
+
+  // Reverse data order for the Karn codec.
+  for(i=0; i&lt;12; i++) {
+    dat1[i]=dgen[11-i];
+  }
+  // Compute the parity symbols
+  encode_rs_int(rs,dat1,b);
+
+  // Move parity symbols and data into sent[] array, in reverse order.
+  for (i = 0; i &lt; 51; i++) sent[50-i] = b[i];
+  for (i = 0; i &lt; 12; i++) sent[i+51] = dat1[11-i];
+}
+
+void rs_decode_(int *recd0, int *era0, int *numera0, int *decoded, int *nerr)
+// Decode JT65 received data recd0[63], producing decoded[12].
+// Erasures are indicated in era0[numera].  The number of corrected
+// errors is *nerr.  If the data are uncorrectable, *nerr=-1 is returned.
+{
+  int numera;
+  int i;
+  int era_pos[50];
+  int recd[63];
+
+  if(first) {
+    rs=init_rs_int(6,0x43,3,1,51,0);
+    first=0;
+  }
+
+  numera=*numera0;
+  for(i=0; i&lt;12; i++) recd[i]=recd0[62-i];
+  for(i=0; i&lt;51; i++) recd[12+i]=recd0[50-i];
+  if(numera) 
+    for(i=0; i&lt;numera; i++) era_pos[i]=era0[i];
+  *nerr=decode_rs_int(rs,recd,era_pos,numera);
+  for(i=0; i&lt;12; i++) decoded[i]=recd[11-i];
+}
+
+
+void rs_encode__(int *dgen, int *sent)
+{
+  rs_encode_(dgen, sent);
+}
+
+void rs_decode__(int *recd0, int *era0, int *numera0, int *decoded, int *nerr)
+{
+  rs_decode_(recd0, era0, numera0, decoded, nerr);
+}
+


Property changes on: branches/map65/libm65/wrapkarn.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/main.cpp
===================================================================
--- branches/map65/main.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/main.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,11 +1,11 @@
-#include &lt;QtGui&gt;
-#include &lt;QtGui/QApplication&gt;
-#include &quot;mainwindow.h&quot;
-
-int main(int argc, char *argv[])
-{
-    QApplication a(argc, argv);
-    MainWindow w;
-    w.show();
-    return a.exec();
-}
+#include &lt;QtGui&gt;
+#include &lt;QtGui/QApplication&gt;
+#include &quot;mainwindow.h&quot;
+
+int main(int argc, char *argv[])
+{
+    QApplication a(argc, argv);
+    MainWindow w;
+    w.show();
+    return a.exec();
+}


Property changes on: branches/map65/main.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/mainwindow.cpp
===================================================================
--- branches/map65/mainwindow.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/mainwindow.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,1970 +1,1970 @@
-//-------------------------------------------------------------- MainWindow
-#include &quot;mainwindow.h&quot;
-#include &quot;ui_mainwindow.h&quot;
-#include &quot;devsetup.h&quot;
-#include &quot;plotter.h&quot;
-#include &quot;about.h&quot;
-#include &quot;astro.h&quot;
-#include &quot;widegraph.h&quot;
-#include &quot;messages.h&quot;
-#include &quot;bandmap.h&quot;
-#include &quot;sleep.h&quot;
-#include &lt;portaudio.h&gt;
-
-#define NFFT 32768
-
-short int iwave[60*11025];            //Wave file for Tx audio
-int nwave;                            //Length of Tx waveform
-bool btxok;                           //True if OK to transmit
-double outputLatency;                 //Latency in seconds
-qint16 id[4*60*96000];
-
-
-Astro*     g_pAstro = NULL;
-WideGraph* g_pWideGraph = NULL;
-Messages*  g_pMessages = NULL;
-
-BandMap*   g_pBandMap = NULL;
-QSharedMemory mem_m65(&quot;mem_m65&quot;);
-
-QString rev=&quot;$Rev: 631 $&quot;;
-QString Program_Title_Version=&quot;  MAP65   v2.3.0, r&quot; + rev.mid(6,3) +
-                              &quot;    by K1JT&quot;;
-
-extern const int RxDataFrequency = 96000;
-extern const int TxDataFrequency = 11025;
-
-//-------------------------------------------------- MainWindow constructor
-MainWindow::MainWindow(QWidget *parent) :
-  QMainWindow(parent),
-  ui(new Ui::MainWindow)
-{
-  ui-&gt;setupUi(this);
-
-  on_EraseButton_clicked();
-  ui-&gt;labUTC-&gt;setStyleSheet( \
-        &quot;QLabel { background-color : black; color : yellow; }&quot;);
-  ui-&gt;labTol1-&gt;setStyleSheet( \
-        &quot;QLabel { background-color : white; color : black; }&quot;);
-  ui-&gt;labTol1-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
-  ui-&gt;dxStationGroupBox-&gt;setStyleSheet(&quot;QFrame{border: 5px groove red}&quot;);
-
-  QActionGroup* paletteGroup = new QActionGroup(this);
-  ui-&gt;actionCuteSDR-&gt;setActionGroup(paletteGroup);
-  ui-&gt;actionLinrad-&gt;setActionGroup(paletteGroup);
-  ui-&gt;actionAFMHot-&gt;setActionGroup(paletteGroup);
-  ui-&gt;actionBlue-&gt;setActionGroup(paletteGroup);
-
-  QActionGroup* modeGroup = new QActionGroup(this);
-  ui-&gt;actionJT65A-&gt;setActionGroup(modeGroup);
-  ui-&gt;actionJT65B-&gt;setActionGroup(modeGroup);
-  ui-&gt;actionJT65C-&gt;setActionGroup(modeGroup);
-
-  QActionGroup* saveGroup = new QActionGroup(this);
-  ui-&gt;actionSave_all-&gt;setActionGroup(saveGroup);
-  ui-&gt;actionNone-&gt;setActionGroup(saveGroup);
-
-  QActionGroup* DepthGroup = new QActionGroup(this);
-  ui-&gt;actionNo_Deep_Search-&gt;setActionGroup(DepthGroup);
-  ui-&gt;actionNormal_Deep_Search-&gt;setActionGroup(DepthGroup);
-  ui-&gt;actionAggressive_Deep_Search-&gt;setActionGroup(DepthGroup);
-
-  QButtonGroup* txMsgButtonGroup = new QButtonGroup;
-  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb1,1);
-  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb2,2);
-  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb3,3);
-  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb4,4);
-  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb5,5);
-  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb6,6);
-  connect(txMsgButtonGroup,SIGNAL(buttonClicked(int)),SLOT(set_ntx(int)));
-  connect(ui-&gt;decodedTextBrowser,SIGNAL(selectCallsign(bool)),this,
-          SLOT(selectCall2(bool)));
-
-  setWindowTitle(Program_Title_Version);
-
-  connect(&amp;soundInThread, SIGNAL(readyForFFT(int)),
-             this, SLOT(dataSink(int)));
-  connect(&amp;soundInThread, SIGNAL(error(QString)), this,
-          SLOT(showSoundInError(QString)));
-  connect(&amp;soundInThread, SIGNAL(status(QString)), this,
-          SLOT(showStatusMessage(QString)));
-  createStatusBar();
-
-  connect(&amp;proc_m65, SIGNAL(readyReadStandardOutput()),
-                    this, SLOT(readFromStdout()));
-
-  connect(&amp;proc_m65, SIGNAL(error(QProcess::ProcessError)),
-          this, SLOT(m65_error()));
-
-  connect(&amp;proc_m65, SIGNAL(readyReadStandardError()),
-          this, SLOT(readFromStderr()));
-
-  QTimer *guiTimer = new QTimer(this);
-  connect(guiTimer, SIGNAL(timeout()), this, SLOT(guiUpdate()));
-  guiTimer-&gt;start(100);                            //Don't change the 100 ms!
-
-  m_auto=false;
-  m_waterfallAvg = 1;
-  m_network = true;
-  m_txFirst=false;
-  m_txMute=false;
-  btxok=false;
-  m_restart=false;
-  m_transmitting=false;
-  m_killAll=false;
-  m_widebandDecode=false;
-  m_ntx=1;
-  m_myCall=&quot;K1JT&quot;;
-  m_myGrid=&quot;FN20qi&quot;;
-  m_appDir = QApplication::applicationDirPath();
-  m_saveDir=&quot;/users/joe/map65/install/save&quot;;
-  m_azelDir=&quot;/users/joe/map65/install/&quot;;
-  m_txFreq=125;
-  m_setftx=0;
-  m_loopall=false;
-  m_startAnother=false;
-  m_saveAll=false;
-  m_onlyEME=false;
-  m_sec0=-1;
-  m_hsym0=-1;
-  m_palette=&quot;CuteSDR&quot;;
-  m_map65RxLog=1;                     //Write Date and Time to all65.txt
-  m_nutc0=9999;
-  m_kb8rq=false;
-  m_NB=false;
-  m_mode=&quot;JT65B&quot;;
-  m_mode65=2;
-  m_fs96000=true;
-  m_udpPort=50004;
-  m_adjustIQ=0;
-  m_applyIQcal=0;
-  m_colors=&quot;000066ff0000ffff00969696646464&quot;;
-
-  ui-&gt;xThermo-&gt;setFillBrush(Qt::green);
-  ui-&gt;yThermo-&gt;setFillBrush(Qt::magenta);
-
-#ifdef WIN32
-  while(true) {
-      int iret=killbyname(&quot;m65.exe&quot;);
-      if(iret == 603) break;
-      if(iret != 0) msgBox(&quot;KillByName return code: &quot; +
-                           QString::number(iret));
-  }
-#endif
-
-  if(!mem_m65.attach()) {
-    if (!mem_m65.create(sizeof(datcom_))) {
-      msgBox(&quot;Unable to create shared memory segment.&quot;);
-    }
-  }
-  char *to = (char*)mem_m65.data();
-  int size=sizeof(datcom_);
-  if(datcom_.newdat==0) {
-    int noffset = 4*4*5760000 + 4*4*322*32768 + 4*4*32768;
-    to += noffset;
-    size -= noffset;
-  }
-  memset(to,0,size);         //Zero all decoding params in shared memory
-
-  PaError paerr=Pa_Initialize();                    //Initialize Portaudio
-  if(paerr!=paNoError) {
-    msgBox(&quot;Unable to initialize PortAudio.&quot;);
-  }
-  readSettings();		             //Restore user's setup params
-  QFile lockFile(m_appDir + &quot;/.lock&quot;); //Create .lock so m65 will wait
-  lockFile.open(QIODevice::ReadWrite);
-  QFile quitFile(m_appDir + &quot;/.lock&quot;);
-  quitFile.remove();
-  proc_m65.start(QDir::toNativeSeparators(m_appDir + &quot;/m65 -s&quot;));
-
-  m_pbdecoding_style1=&quot;QPushButton{background-color: cyan; \
-      border-style: outset; border-width: 1px; border-radius: 5px; \
-      border-color: black; min-width: 5em; padding: 3px;}&quot;;
-  m_pbmonitor_style=&quot;QPushButton{background-color: #00ff00; \
-      border-style: outset; border-width: 1px; border-radius: 5px; \
-      border-color: black; min-width: 5em; padding: 3px;}&quot;;
-  m_pbAutoOn_style=&quot;QPushButton{background-color: red; \
-      border-style: outset; border-width: 1px; border-radius: 5px; \
-      border-color: black; min-width: 5em; padding: 3px;}&quot;;
-
-  genStdMsgs(&quot;&quot;);
-
-  on_actionAstro_Data_triggered();           //Create the other windows
-  on_actionWide_Waterfall_triggered();
-  on_actionMessages_triggered();
-  on_actionBand_Map_triggered();
-  g_pMessages-&gt;setColors(m_colors);
-  g_pBandMap-&gt;setColors(m_colors);
-  g_pAstro-&gt;setFontSize(m_astroFont);
-  if(m_mode==&quot;JT65A&quot;) on_actionJT65A_triggered();
-  if(m_mode==&quot;JT65B&quot;) on_actionJT65B_triggered();
-  if(m_mode==&quot;JT65C&quot;) on_actionJT65C_triggered();
-
-  future1 = new QFuture&lt;void&gt;;
-  watcher1 = new QFutureWatcher&lt;void&gt;;
-  connect(watcher1, SIGNAL(finished()),this,SLOT(diskDat()));
-
-  future2 = new QFuture&lt;void&gt;;
-  watcher2 = new QFutureWatcher&lt;void&gt;;
-  connect(watcher2, SIGNAL(finished()),this,SLOT(diskWriteFinished()));
-
-// Assign input device and start input thread
-  soundInThread.setInputDevice(m_paInDevice);
-  if(m_fs96000) soundInThread.setRate(96000.0);
-  if(!m_fs96000) soundInThread.setRate(95238.1);
-  soundInThread.setBufSize(10*7056);
-  soundInThread.setNetwork(m_network);
-  soundInThread.setPort(m_udpPort);
-  if(!m_xpol) soundInThread.setNrx(1);
-  if(m_xpol) soundInThread.setNrx(2);
-  soundInThread.start(QThread::HighestPriority);
-
-  // Assign output device and start output thread
-  soundOutThread.setOutputDevice(m_paOutDevice);
-//  soundOutThread.start(QThread::HighPriority);
-
-  m_monitoring=true;                           // Start with Monitoring ON
-  soundInThread.setMonitoring(m_monitoring);
-  m_diskData=false;
-  m_tol=500;
-  g_pWideGraph-&gt;setTol(m_tol);
-  g_pWideGraph-&gt;setFcal(m_fCal);
-  if(m_fs96000) g_pWideGraph-&gt;setFsample(96000);
-  if(!m_fs96000) g_pWideGraph-&gt;setFsample(95238);
-  g_pWideGraph-&gt;m_mult570=m_mult570;
-  g_pWideGraph-&gt;m_cal570=m_cal570;
-  if(m_initIQplus) g_pWideGraph-&gt;initIQplus();
-
-// Create &quot;m_worked&quot;, a dictionary of all calls in wsjt.log
-  QFile f(&quot;wsjt.log&quot;);
-  f.open(QIODevice::ReadOnly);
-  QTextStream in(&amp;f);
-  QString line,t,callsign;
-  for(int i=0; i&lt;99999; i++) {
-    line=in.readLine();
-    if(line.length()&lt;=0) break;
-    t=line.mid(18,12);
-    callsign=t.mid(0,t.indexOf(&quot;,&quot;));
-    m_worked[callsign]=true;
-  }
-  f.close();
-
-  if(ui-&gt;actionLinrad-&gt;isChecked()) on_actionLinrad_triggered();
-  if(ui-&gt;actionCuteSDR-&gt;isChecked()) on_actionCuteSDR_triggered();
-  if(ui-&gt;actionAFMHot-&gt;isChecked()) on_actionAFMHot_triggered();
-  if(ui-&gt;actionBlue-&gt;isChecked()) on_actionBlue_triggered();
-                                             // End of MainWindow constructor
-}
-
-  //--------------------------------------------------- MainWindow destructor
-MainWindow::~MainWindow()
-{
-  writeSettings();
-  if (soundInThread.isRunning()) {
-    soundInThread.quit();
-    soundInThread.wait(3000);
-  }
-  if (soundOutThread.isRunning()) {
-    soundOutThread.quitExecution=true;
-    soundOutThread.wait(3000);
-  }
-  if(!m_decoderBusy) {
-    QFile lockFile(m_appDir + &quot;/.lock&quot;);
-    lockFile.remove();
-  }
-  delete ui;
-}
-
-//-------------------------------------------------------- writeSettings()
-void MainWindow::writeSettings()
-{
-  QString inifile = m_appDir + &quot;/map65.ini&quot;;
-  QSettings settings(inifile, QSettings::IniFormat);
-
-  settings.beginGroup(&quot;MainWindow&quot;);
-  settings.setValue(&quot;geometry&quot;, saveGeometry());
-  settings.setValue(&quot;MRUdir&quot;, m_path);
-  settings.setValue(&quot;TxFirst&quot;,m_txFirst);
-  settings.setValue(&quot;DXcall&quot;,ui-&gt;dxCallEntry-&gt;text());
-  settings.setValue(&quot;DXgrid&quot;,ui-&gt;dxGridEntry-&gt;text());
-
-  if(g_pAstro-&gt;isVisible()) {
-    m_astroGeom = g_pAstro-&gt;geometry();
-    settings.setValue(&quot;AstroGeom&quot;,m_astroGeom);
-  }
-
-  if(g_pWideGraph-&gt;isVisible()) {
-    m_wideGraphGeom = g_pWideGraph-&gt;geometry();
-    settings.setValue(&quot;WideGraphGeom&quot;,m_wideGraphGeom);
-  }
-  if(g_pMessages-&gt;isVisible()) {
-    m_messagesGeom = g_pMessages-&gt;geometry();
-    settings.setValue(&quot;MessagesGeom&quot;,m_messagesGeom);
-  }
-  if(g_pBandMap-&gt;isVisible()) {
-    m_bandMapGeom = g_pBandMap-&gt;geometry();
-    settings.setValue(&quot;BandMapGeom&quot;,m_bandMapGeom);
-  }
-  settings.endGroup();
-
-  settings.beginGroup(&quot;Common&quot;);
-  settings.setValue(&quot;MyCall&quot;,m_myCall);
-  settings.setValue(&quot;MyGrid&quot;,m_myGrid);
-  settings.setValue(&quot;IDint&quot;,m_idInt);
-  settings.setValue(&quot;PTTport&quot;,m_pttPort);
-  settings.setValue(&quot;AstroFont&quot;,m_astroFont);
-  settings.setValue(&quot;Xpol&quot;,m_xpol);
-  settings.setValue(&quot;XpolX&quot;,m_xpolx);
-  settings.setValue(&quot;SaveDir&quot;,m_saveDir);
-  settings.setValue(&quot;AzElDir&quot;,m_azelDir);
-  settings.setValue(&quot;DXCCpfx&quot;,m_dxccPfx);
-  settings.setValue(&quot;Timeout&quot;,m_timeout);
-  settings.setValue(&quot;IQamp&quot;,m_IQamp);
-  settings.setValue(&quot;IQphase&quot;,m_IQphase);
-  settings.setValue(&quot;ApplyIQcal&quot;,m_applyIQcal);
-  settings.setValue(&quot;dPhi&quot;,m_dPhi);
-  settings.setValue(&quot;Fcal&quot;,m_fCal);
-  settings.setValue(&quot;Fadd&quot;,m_fAdd);
-  settings.setValue(&quot;NetworkInput&quot;, m_network);
-  settings.setValue(&quot;FSam96000&quot;, m_fs96000);
-  settings.setValue(&quot;SoundInIndex&quot;,m_nDevIn);
-  settings.setValue(&quot;paInDevice&quot;,m_paInDevice);
-  settings.setValue(&quot;SoundOutIndex&quot;,m_nDevOut);
-  settings.setValue(&quot;paOutDevice&quot;,m_paOutDevice);
-  settings.setValue(&quot;IQswap&quot;,m_IQswap);
-  settings.setValue(&quot;Plus10dB&quot;,m_10db);
-  settings.setValue(&quot;InitIQplus&quot;,m_initIQplus);
-  settings.setValue(&quot;UDPport&quot;,m_udpPort);
-  settings.setValue(&quot;PaletteCuteSDR&quot;,ui-&gt;actionCuteSDR-&gt;isChecked());
-  settings.setValue(&quot;PaletteLinrad&quot;,ui-&gt;actionLinrad-&gt;isChecked());
-  settings.setValue(&quot;PaletteAFMHot&quot;,ui-&gt;actionAFMHot-&gt;isChecked());
-  settings.setValue(&quot;PaletteBlue&quot;,ui-&gt;actionBlue-&gt;isChecked());
-  settings.setValue(&quot;Mode&quot;,m_mode);
-  settings.setValue(&quot;SaveNone&quot;,ui-&gt;actionNone-&gt;isChecked());
-  settings.setValue(&quot;SaveAll&quot;,ui-&gt;actionSave_all-&gt;isChecked());
-  settings.setValue(&quot;NDepth&quot;,m_ndepth);
-  settings.setValue(&quot;NEME&quot;,m_onlyEME);
-  settings.setValue(&quot;KB8RQ&quot;,m_kb8rq);
-  settings.setValue(&quot;NB&quot;,m_NB);
-  settings.setValue(&quot;NBslider&quot;,m_NBslider);
-  settings.setValue(&quot;GainX&quot;,(double)m_gainx);
-  settings.setValue(&quot;GainY&quot;,(double)m_gainy);
-  settings.setValue(&quot;PhaseX&quot;,(double)m_phasex);
-  settings.setValue(&quot;PhaseY&quot;,(double)m_phasey);
-  settings.setValue(&quot;Mult570&quot;,m_mult570);
-  settings.setValue(&quot;Cal570&quot;,m_cal570);
-  settings.setValue(&quot;Colors&quot;,m_colors);
-  settings.endGroup();
-}
-
-//---------------------------------------------------------- readSettings()
-void MainWindow::readSettings()
-{
-  QString inifile = m_appDir + &quot;/map65.ini&quot;;
-  QSettings settings(inifile, QSettings::IniFormat);
-  settings.beginGroup(&quot;MainWindow&quot;);
-  restoreGeometry(settings.value(&quot;geometry&quot;).toByteArray());
-  ui-&gt;dxCallEntry-&gt;setText(settings.value(&quot;DXcall&quot;,&quot;&quot;).toString());
-  ui-&gt;dxGridEntry-&gt;setText(settings.value(&quot;DXgrid&quot;,&quot;&quot;).toString());
-
-  m_astroGeom = settings.value(&quot;AstroGeom&quot;, QRect(71,390,227,403)).toRect();
-
-  m_wideGraphGeom = settings.value(&quot;WideGraphGeom&quot;, \
-                                   QRect(45,30,1023,340)).toRect();
-  m_messagesGeom = settings.value(&quot;MessagesGeom&quot;, \
-                                  QRect(800,400,381,400)).toRect();
-  m_bandMapGeom = settings.value(&quot;BandMapGeom&quot;, \
-                                  QRect(280,400,142,400)).toRect();
-  m_path = settings.value(&quot;MRUdir&quot;, m_appDir + &quot;/save&quot;).toString();
-  m_txFirst = settings.value(&quot;TxFirst&quot;,false).toBool();
-  ui-&gt;txFirstCheckBox-&gt;setChecked(m_txFirst);
-  settings.endGroup();
-
-  settings.beginGroup(&quot;Common&quot;);
-  m_myCall=settings.value(&quot;MyCall&quot;,&quot;&quot;).toString();
-  m_myGrid=settings.value(&quot;MyGrid&quot;,&quot;&quot;).toString();
-  m_idInt=settings.value(&quot;IDint&quot;,0).toInt();
-  m_pttPort=settings.value(&quot;PTTport&quot;,0).toInt();
-  m_astroFont=settings.value(&quot;AstroFont&quot;,20).toInt();
-  m_xpol=settings.value(&quot;Xpol&quot;,false).toBool();
-  ui-&gt;actionFind_Delta_Phi-&gt;setEnabled(m_xpol);
-  m_xpolx=settings.value(&quot;XpolX&quot;,false).toBool();
-  m_saveDir=settings.value(&quot;SaveDir&quot;,m_appDir + &quot;/save&quot;).toString();
-  m_azelDir=settings.value(&quot;AzElDir&quot;,m_appDir).toString();
-  m_dxccPfx=settings.value(&quot;DXCCpfx&quot;,&quot;&quot;).toString();
-  m_timeout=settings.value(&quot;Timeout&quot;,20).toInt();
-  m_IQamp=settings.value(&quot;IQamp&quot;,1.0000).toDouble();
-  m_IQphase=settings.value(&quot;IQphase&quot;,0.0).toDouble();
-  m_applyIQcal=settings.value(&quot;ApplyIQcal&quot;,0).toInt();
-  ui-&gt;actionApply_IQ_Calibration-&gt;setChecked(m_applyIQcal!=0);
-  m_dPhi=settings.value(&quot;dPhi&quot;,0).toInt();
-  m_fCal=settings.value(&quot;Fcal&quot;,0).toInt();
-  m_fAdd=settings.value(&quot;FAdd&quot;,0).toDouble();
-  soundInThread.setFadd(m_fAdd);
-  m_network = settings.value(&quot;NetworkInput&quot;,true).toBool();
-  m_fs96000 = settings.value(&quot;FSam96000&quot;,true).toBool();
-  m_nDevIn = settings.value(&quot;SoundInIndex&quot;, 0).toInt();
-  m_paInDevice = settings.value(&quot;paInDevice&quot;,0).toInt();
-  m_nDevOut = settings.value(&quot;SoundOutIndex&quot;, 0).toInt();
-  m_paOutDevice = settings.value(&quot;paOutDevice&quot;,0).toInt();
-  m_IQswap = settings.value(&quot;IQswap&quot;,false).toBool();
-  m_10db = settings.value(&quot;Plus10dB&quot;,false).toBool();
-  m_initIQplus = settings.value(&quot;InitIQplus&quot;,false).toBool();
-  m_udpPort = settings.value(&quot;UDPport&quot;,50004).toInt();
-  soundInThread.setSwapIQ(m_IQswap);
-  soundInThread.set10db(m_10db);
-  soundInThread.setPort(m_udpPort);
-  ui-&gt;actionCuteSDR-&gt;setChecked(settings.value(
-                                  &quot;PaletteCuteSDR&quot;,true).toBool());
-  ui-&gt;actionLinrad-&gt;setChecked(settings.value(
-                                 &quot;PaletteLinrad&quot;,false).toBool());
-  ui-&gt;actionAFMHot-&gt;setChecked(settings.value(
-                                 &quot;PaletteAFMHot&quot;,false).toBool());
-  ui-&gt;actionBlue-&gt;setChecked(settings.value(
-                                 &quot;PaletteBlue&quot;,false).toBool());
-  m_mode=settings.value(&quot;Mode&quot;,&quot;JT65B&quot;).toString();
-  ui-&gt;actionNone-&gt;setChecked(settings.value(&quot;SaveNone&quot;,true).toBool());
-  ui-&gt;actionSave_all-&gt;setChecked(settings.value(&quot;SaveAll&quot;,false).toBool());
-  m_saveAll=ui-&gt;actionSave_all-&gt;isChecked();
-  m_ndepth=settings.value(&quot;NDepth&quot;,0).toInt();
-  m_onlyEME=settings.value(&quot;NEME&quot;,false).toBool();
-  ui-&gt;actionOnly_EME_calls-&gt;setChecked(m_onlyEME);
-  m_kb8rq=settings.value(&quot;KB8RQ&quot;,false).toBool();
-  ui-&gt;actionF4_sets_Tx6-&gt;setChecked(m_kb8rq);
-  m_NB=settings.value(&quot;NB&quot;,false).toBool();
-  ui-&gt;NBcheckBox-&gt;setChecked(m_NB);
-  m_NBslider=settings.value(&quot;NBslider&quot;,40).toInt();
-  ui-&gt;NBslider-&gt;setValue(m_NBslider);
-  m_gainx=settings.value(&quot;GainX&quot;,1.0).toFloat();
-  m_gainy=settings.value(&quot;GainY&quot;,1.0).toFloat();
-  m_phasex=settings.value(&quot;PhaseX&quot;,0.0).toFloat();
-  m_phasey=settings.value(&quot;PhaseY&quot;,0.0).toFloat();
-  m_mult570=settings.value(&quot;Mult570&quot;,2).toInt();
-  m_cal570=settings.value(&quot;Cal570&quot;,0.0).toDouble();
-  m_colors=settings.value(&quot;Colors&quot;,&quot;000066ff0000ffff00969696646464&quot;).toString();
-  settings.endGroup();
-
-  if(!ui-&gt;actionLinrad-&gt;isChecked() &amp;&amp; !ui-&gt;actionCuteSDR-&gt;isChecked() &amp;&amp;
-    !ui-&gt;actionAFMHot-&gt;isChecked() &amp;&amp; !ui-&gt;actionBlue-&gt;isChecked()) {
-    on_actionLinrad_triggered();
-    ui-&gt;actionLinrad-&gt;setChecked(true);
-  }
-  if(m_ndepth==0) ui-&gt;actionNo_Deep_Search-&gt;setChecked(true);
-  if(m_ndepth==1) ui-&gt;actionNormal_Deep_Search-&gt;setChecked(true);
-  if(m_ndepth==2) ui-&gt;actionAggressive_Deep_Search-&gt;setChecked(true);
-}
-
-//-------------------------------------------------------------- dataSink()
-void MainWindow::dataSink(int k)
-{
-  static float s[NFFT],splot[NFFT];
-  static int n=0;
-  static int ihsym=0;
-  static int nzap=0;
-  static int n60z=0;
-  static int nkhz;
-  static int nfsample=96000;
-  static int nxpol=0;
-  static float fgreen;
-  static int ndiskdat;
-  static int nb;
-  static int nadj=0;
-  static float px=0.0,py=0.0;
-  static uchar lstrong[1024];
-  static float rejectx;
-  static float rejecty;
-  static float slimit;
-
-
-  if(m_diskData) {
-    ndiskdat=1;
-    datcom_.ndiskdat=1;
-  } else {
-    ndiskdat=0;
-    datcom_.ndiskdat=0;
-  }
-// Get x and y power, polarized spectrum, nkhz, and ihsym
-  nb=0;
-  if(m_NB) nb=1;
-  nfsample=96000;
-  if(!m_fs96000) nfsample=95238;
-  nxpol=0;
-  if(m_xpol) nxpol=1;
-  fgreen=(float)g_pWideGraph-&gt;fGreen();
-  nadj++;
-  if(m_adjustIQ==0) nadj=0;
-  symspec_(&amp;k, &amp;nxpol, &amp;ndiskdat, &amp;nb, &amp;m_NBslider, &amp;m_dPhi, &amp;nfsample,
-           &amp;fgreen, &amp;m_adjustIQ, &amp;m_applyIQcal, &amp;m_gainx, &amp;m_gainy, &amp;m_phasex,
-           &amp;m_phasey, &amp;rejectx, &amp;rejecty, &amp;px, &amp;py, s, &amp;nkhz,
-           &amp;ihsym, &amp;nzap, &amp;slimit, lstrong);
-  QString t;
-  m_pctZap=nzap/178.3;
-  if(m_xpol) t.sprintf(&quot; Rx noise: %5.1f  %5.1f %5.1f %% &quot;,px,py,m_pctZap);
-  if(!m_xpol) t.sprintf(&quot; Rx noise: %5.1f  %5.1f %% &quot;,px,m_pctZap);
-  lab4-&gt;setText(t);
-  ui-&gt;xThermo-&gt;setValue((double)px);   //Update the bargraphs
-  ui-&gt;yThermo-&gt;setValue((double)py);
-  if(m_monitoring || m_diskData) {
-    g_pWideGraph-&gt;dataSink2(s,nkhz,ihsym,m_diskData,lstrong);
-  }
-
-  if(nadj == 10) {
-    if(m_xpol) {
-      t.sprintf(&quot;Amp: %6.4f %6.4f   Phase: %6.4f %6.4f&quot;,
-                m_gainx,m_gainy,m_phasex,m_phasey);
-    } else {
-      t.sprintf(&quot;Amp: %6.4f   Phase: %6.4f&quot;,m_gainx,m_phasex);
-    }
-    ui-&gt;decodedTextBrowser-&gt;append(t);
-    m_adjustIQ=0;
-  }
-
-  //Average over specified number of spectra
-  if (n==0) {
-    for (int i=0; i&lt;NFFT; i++)
-      splot[i]=s[i];
-  } else {
-    for (int i=0; i&lt;NFFT; i++)
-      splot[i] += s[i];
-  }
-  n++;
-
-  if (n&gt;=m_waterfallAvg) {
-    for (int i=0; i&lt;NFFT; i++) {
-        splot[i] /= n;                           //Normalize the average
-    }
-
-// Time according to this computer
-    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
-    int n60 = (ms/1000) % 60;
-    if((m_diskData &amp;&amp; ihsym &lt;= m_waterfallAvg) || (!m_diskData &amp;&amp; n60&lt;n60z)) {
-      for (int i=0; i&lt;NFFT; i++) {
-        splot[i] = 1.e30;
-      }
-    }
-    n60z=n60;
-    n=0;
-  }
-  if(ihsym == 279) {
-    datcom_.newdat=1;
-    datcom_.nagain=0;
-    QDateTime t = QDateTime::currentDateTimeUtc();
-    m_dateTime=t.toString(&quot;yyyy-MMM-dd hh:mm&quot;);
-    decode();                                           //Start the decoder
-    if(m_saveAll) {
-      QString fname=m_saveDir + &quot;/&quot; + t.date().toString(&quot;yyMMdd&quot;) + &quot;_&quot; +
-          t.time().toString(&quot;hhmm&quot;);
-      if(m_xpol) fname += &quot;.tf2&quot;;
-      if(!m_xpol) fname += &quot;.iq&quot;;
-      *future2 = QtConcurrent::run(savetf2, fname, m_xpol);
-      watcher2-&gt;setFuture(*future2);
-    }
-  }
-  soundInThread.m_dataSinkBusy=false;
-}
-
-void MainWindow::showSoundInError(const QString&amp; errorMsg)
- {QMessageBox::critical(this, tr(&quot;Error in SoundIn&quot;), errorMsg);}
-
-void MainWindow::showStatusMessage(const QString&amp; statusMsg)
- {statusBar()-&gt;showMessage(statusMsg);}
-
-void MainWindow::on_actionDeviceSetup_triggered()               //Setup Dialog
-{
-  DevSetup dlg(this);
-  dlg.m_myCall=m_myCall;
-  dlg.m_myGrid=m_myGrid;
-  dlg.m_idInt=m_idInt;
-  dlg.m_pttPort=m_pttPort;
-  dlg.m_astroFont=m_astroFont;
-  dlg.m_xpol=m_xpol;
-  dlg.m_xpolx=m_xpolx;
-  dlg.m_saveDir=m_saveDir;
-  dlg.m_azelDir=m_azelDir;
-  dlg.m_dxccPfx=m_dxccPfx;
-  dlg.m_timeout=m_timeout;
-  dlg.m_dPhi=m_dPhi;
-  dlg.m_fCal=m_fCal;
-  dlg.m_fAdd=m_fAdd;
-  dlg.m_network=m_network;
-  dlg.m_fs96000=m_fs96000;
-  dlg.m_nDevIn=m_nDevIn;
-  dlg.m_nDevOut=m_nDevOut;
-  dlg.m_udpPort=m_udpPort;
-  dlg.m_IQswap=m_IQswap;
-  dlg.m_10db=m_10db;
-  dlg.m_initIQplus=m_initIQplus;
-  dlg.m_cal570=m_cal570;
-  dlg.m_mult570=m_mult570;
-  dlg.m_colors=m_colors;
-
-  dlg.initDlg();
-  if(dlg.exec() == QDialog::Accepted) {
-    m_myCall=dlg.m_myCall;
-    m_myGrid=dlg.m_myGrid;
-    m_idInt=dlg.m_idInt;
-    m_pttPort=dlg.m_pttPort;
-    m_astroFont=dlg.m_astroFont;
-    if(g_pAstro-&gt;isVisible()) g_pAstro-&gt;setFontSize(m_astroFont);
-    m_xpol=dlg.m_xpol;
-    ui-&gt;actionFind_Delta_Phi-&gt;setEnabled(m_xpol);
-    m_xpolx=dlg.m_xpolx;
-    m_saveDir=dlg.m_saveDir;
-    m_azelDir=dlg.m_azelDir;
-    m_dxccPfx=dlg.m_dxccPfx;
-    m_timeout=dlg.m_timeout;
-    m_dPhi=dlg.m_dPhi;
-    m_fCal=dlg.m_fCal;
-    m_fAdd=dlg.m_fAdd;
-    g_pWideGraph-&gt;setFcal(m_fCal);
-    m_fs96000=dlg.m_fs96000;
-    m_network=dlg.m_network;
-    m_nDevIn=dlg.m_nDevIn;
-    m_paInDevice=dlg.m_paInDevice;
-    m_nDevOut=dlg.m_nDevOut;
-    m_paOutDevice=dlg.m_paOutDevice;
-    m_udpPort=dlg.m_udpPort;
-    m_IQswap=dlg.m_IQswap;
-    m_10db=dlg.m_10db;
-    m_initIQplus=dlg.m_initIQplus;
-    m_colors=dlg.m_colors;
-    g_pMessages-&gt;setColors(m_colors);
-    g_pBandMap-&gt;setColors(m_colors);
-    m_cal570=dlg.m_cal570;
-    m_mult570=dlg.m_mult570;
-    g_pWideGraph-&gt;m_mult570=m_mult570;
-    g_pWideGraph-&gt;m_cal570=m_cal570;
-    soundInThread.setSwapIQ(m_IQswap);
-    soundInThread.set10db(m_10db);
-
-    if(dlg.m_restartSoundIn) {
-      soundInThread.quit();
-      soundInThread.wait(1000);
-      soundInThread.setNetwork(m_network);
-      if(m_fs96000) soundInThread.setRate(96000.0);
-      if(!m_fs96000) soundInThread.setRate(95238.1);
-      soundInThread.setFadd(m_fAdd);
-      if(!m_xpol) soundInThread.setNrx(1);
-      if(m_xpol) soundInThread.setNrx(2);
-      soundInThread.setInputDevice(m_paInDevice);
-      soundInThread.start(QThread::HighestPriority);
-    }
-
-    if(dlg.m_restartSoundOut) {
-      soundOutThread.quitExecution=true;
-      soundOutThread.wait(1000);
-      soundOutThread.setOutputDevice(m_paOutDevice);
-//      soundOutThread.start(QThread::HighPriority);
-    }
-  }
-}
-
-void MainWindow::on_monitorButton_clicked()                  //Monitor
-{
-  m_monitoring=true;
-  soundInThread.setMonitoring(true);
-  m_diskData=false;
-}
-void MainWindow::on_actionLinrad_triggered()                 //Linrad palette
-{
-  if(g_pWideGraph != NULL) g_pWideGraph-&gt;setPalette(&quot;Linrad&quot;);
-}
-
-void MainWindow::on_actionCuteSDR_triggered()                //CuteSDR palette
-{
-  if(g_pWideGraph != NULL) g_pWideGraph-&gt;setPalette(&quot;CuteSDR&quot;);
-}
-
-void MainWindow::on_actionAFMHot_triggered()
-{
-  if(g_pWideGraph != NULL) g_pWideGraph-&gt;setPalette(&quot;AFMHot&quot;);
-}
-
-void MainWindow::on_actionBlue_triggered()
-{
-  if(g_pWideGraph != NULL) g_pWideGraph-&gt;setPalette(&quot;Blue&quot;);
-}
-
-void MainWindow::on_actionAbout_triggered()                  //Display &quot;About&quot;
-{
-  CAboutDlg dlg(this,Program_Title_Version);
-  dlg.exec();
-}
-
-void MainWindow::on_autoButton_clicked()                     //Auto
-{
-  m_auto = !m_auto;
-  if(m_auto) {
-    ui-&gt;autoButton-&gt;setStyleSheet(m_pbAutoOn_style);
-    ui-&gt;autoButton-&gt;setText(&quot;Auto is ON&quot;);
-  } else {
-    btxok=false;
-    ui-&gt;autoButton-&gt;setStyleSheet(&quot;&quot;);
-    ui-&gt;autoButton-&gt;setText(&quot;Auto is OFF&quot;);
-    on_monitorButton_clicked();
-  }
-}
-
-void MainWindow::on_stopTxButton_clicked()                    //Stop Tx
-{
-  if(m_auto) on_autoButton_clicked();
-  btxok=false;
-}
-
-void MainWindow::keyPressEvent( QKeyEvent *e )                //keyPressEvent
-{
-  switch(e-&gt;key())
-  {
-  case Qt::Key_F3:
-    m_txMute=!m_txMute;
-    break;
-  case Qt::Key_F4:
-    ui-&gt;dxCallEntry-&gt;setText(&quot;&quot;);
-    ui-&gt;dxGridEntry-&gt;setText(&quot;&quot;);
-    if(m_kb8rq) {
-      m_ntx=6;
-      ui-&gt;txrb6-&gt;setChecked(true);
-    }
-  case Qt::Key_F6:
-    if(e-&gt;modifiers() &amp; Qt::ShiftModifier) {
-      on_actionDecode_remaining_files_in_directory_triggered();
-    }
-    break;
-  case Qt::Key_F11:
-    if(e-&gt;modifiers() &amp; Qt::ShiftModifier) {
-    } else {
-      int n0=g_pWideGraph-&gt;DF();
-      int n=(n0 + 10000) % 5;
-      if(n==0) n=5;
-      g_pWideGraph-&gt;setDF(n0-n);
-    }
-    break;
-  case Qt::Key_F12:
-    if(e-&gt;modifiers() &amp; Qt::ShiftModifier) {
-    } else {
-      int n0=g_pWideGraph-&gt;DF();
-      int n=(n0 + 10000) % 5;
-      if(n==0) n=5;
-      g_pWideGraph-&gt;setDF(n0+n);
-    }
-    break;
-  case Qt::Key_G:
-    if(e-&gt;modifiers() &amp; Qt::AltModifier) {
-      genStdMsgs(&quot;&quot;);
-      break;
-    }
-  case Qt::Key_L:
-    if(e-&gt;modifiers() &amp; Qt::ControlModifier) {
-      lookup();
-      genStdMsgs(&quot;&quot;);
-      break;
-    }
-  }
-}
-
-void MainWindow::bumpDF(int n)                                  //bumpDF()
-{
-  if(n==11) {
-    int n0=g_pWideGraph-&gt;DF();
-    int n=(n0 + 10000) % 5;
-    if(n==0) n=5;
-    g_pWideGraph-&gt;setDF(n0-n);
-  }
-  if(n==12) {
-    int n0=g_pWideGraph-&gt;DF();
-    int n=(n0 + 10000) % 5;
-    if(n==0) n=5;
-    g_pWideGraph-&gt;setDF(n0+n);
-  }
-}
-
-bool MainWindow::eventFilter(QObject *object, QEvent *event)  //eventFilter()
-{
-  if (event-&gt;type() == QEvent::KeyPress) {
-    //Use the event in parent using its keyPressEvent()
-    QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(event);
-    MainWindow::keyPressEvent(keyEvent);
-    return QObject::eventFilter(object, event);
-  }
-  return QObject::eventFilter(object, event);
-}
-
-void MainWindow::createStatusBar()                           //createStatusBar
-{
-  lab1 = new QLabel(&quot;Receiving&quot;);
-  lab1-&gt;setAlignment(Qt::AlignHCenter);
-  lab1-&gt;setMinimumSize(QSize(80,10));
-  lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #00ff00}&quot;);
-  lab1-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
-  statusBar()-&gt;addWidget(lab1);
-
-  lab2 = new QLabel(&quot;QSO freq:  125&quot;);
-  lab2-&gt;setAlignment(Qt::AlignHCenter);
-  lab2-&gt;setMinimumSize(QSize(90,10));
-  lab2-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
-  statusBar()-&gt;addWidget(lab2);
-
-  lab3 = new QLabel(&quot;QSO DF:   0&quot;);
-  lab3-&gt;setAlignment(Qt::AlignHCenter);
-  lab3-&gt;setMinimumSize(QSize(80,10));
-  lab3-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
-  statusBar()-&gt;addWidget(lab3);
-
-  lab4 = new QLabel(&quot;&quot;);
-  lab4-&gt;setAlignment(Qt::AlignHCenter);
-  lab4-&gt;setMinimumSize(QSize(80,10));
-  lab4-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
-  statusBar()-&gt;addWidget(lab4);
-
-  lab5 = new QLabel(&quot;&quot;);
-  lab5-&gt;setAlignment(Qt::AlignHCenter);
-  lab5-&gt;setMinimumSize(QSize(50,10));
-  lab5-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
-  statusBar()-&gt;addWidget(lab5);
-}
-
-void MainWindow::on_tolSpinBox_valueChanged(int i)             //tolSpinBox
-{
-  static int ntol[] = {10,20,50,100,200,500,1000};
-  m_tol=ntol[i];
-  g_pWideGraph-&gt;setTol(m_tol);
-  ui-&gt;labTol1-&gt;setText(QString::number(ntol[i]));
-}
-
-void MainWindow::on_actionExit_triggered()                     //Exit()
-{
-  OnExit();
-}
-
-void MainWindow::closeEvent(QCloseEvent*)
-{
-  OnExit();
-}
-
-void MainWindow::OnExit()
-{
-  g_pWideGraph-&gt;saveSettings();
-  m_killAll=true;
-  mem_m65.detach();
-  QFile quitFile(m_appDir + &quot;/.quit&quot;);
-  quitFile.open(QIODevice::ReadWrite);
-  QFile lockFile(m_appDir + &quot;/.lock&quot;);
-  lockFile.remove();                      // Allow m65 to terminate
-  bool b=proc_m65.waitForFinished(1000);
-  if(!b) proc_m65.kill();
-  quitFile.remove();
-  qApp-&gt;exit(0);                          // Exit the event loop
-}
-
-void MainWindow::on_stopButton_clicked()                       //stopButton
-{
-  m_monitoring=false;
-  soundInThread.setMonitoring(m_monitoring);
-  m_loopall=false;  
-}
-
-void MainWindow::msgBox(QString t)                             //msgBox
-{
-  msgBox0.setText(t);
-  msgBox0.exec();
-}
-
-void MainWindow::stub()                                        //stub()
-{
-  msgBox(&quot;Not yet implemented.&quot;);
-}
-
-void MainWindow::on_actionOnline_Users_Guide_triggered()      //Display manual
-{
-  QDesktopServices::openUrl(QUrl(
-  &quot;<A HREF="http://www.physics.princeton.edu/pulsar/K1JT/MAP65_Beta_Release.pdf">http://www.physics.princeton.edu/pulsar/K1JT/MAP65_Beta_Release.pdf</A>&quot;,
-                              QUrl::TolerantMode));
-}
-
-void MainWindow::on_actionAstro_Data_triggered()             //Display Astro
-{
-  if(g_pAstro==NULL) {
-    g_pAstro = new Astro(0);
-    g_pAstro-&gt;setWindowTitle(&quot;Astronomical Data&quot;);
-    Qt::WindowFlags flags = Qt::Dialog | Qt::WindowCloseButtonHint |
-        Qt::WindowMinimizeButtonHint;
-    g_pAstro-&gt;setWindowFlags(flags);
-    g_pAstro-&gt;setGeometry(m_astroGeom);
-  }
-  g_pAstro-&gt;show();
-}
-
-void MainWindow::on_actionWide_Waterfall_triggered()      //Display Waterfalls
-{
-  if(g_pWideGraph==NULL) {
-    g_pWideGraph = new WideGraph(0);
-    g_pWideGraph-&gt;setWindowTitle(&quot;Wide Graph&quot;);
-    g_pWideGraph-&gt;setGeometry(m_wideGraphGeom);
-    Qt::WindowFlags flags = Qt::WindowCloseButtonHint |
-        Qt::WindowMinimizeButtonHint;
-    g_pWideGraph-&gt;setWindowFlags(flags);
-    connect(g_pWideGraph, SIGNAL(freezeDecode2(int)),this,
-            SLOT(freezeDecode(int)));
-    connect(g_pWideGraph, SIGNAL(f11f12(int)),this,
-            SLOT(bumpDF(int)));
-  }
-  g_pWideGraph-&gt;show();
-}
-
-void MainWindow::on_actionBand_Map_triggered()              //Display BandMap
-{
-  if(g_pBandMap==NULL) {
-    g_pBandMap = new BandMap(0);
-    g_pBandMap-&gt;setWindowTitle(&quot;Band Map&quot;);
-    Qt::WindowFlags flags = Qt::Dialog | Qt::WindowCloseButtonHint |
-        Qt::WindowMinimizeButtonHint;
-    g_pBandMap-&gt;setWindowFlags(flags);
-    g_pBandMap-&gt;setGeometry(m_bandMapGeom);
-  }
-  g_pBandMap-&gt;show();
-}
-
-void MainWindow::on_actionMessages_triggered()              //Display Messages
-{
-  if(g_pMessages==NULL) {
-    g_pMessages = new Messages(0);
-    g_pMessages-&gt;setWindowTitle(&quot;Messages&quot;);
-    Qt::WindowFlags flags = Qt::Dialog | Qt::WindowCloseButtonHint |
-        Qt::WindowMinimizeButtonHint;
-    g_pMessages-&gt;setWindowFlags(flags);
-    g_pMessages-&gt;setGeometry(m_messagesGeom);
-    connect(g_pMessages, SIGNAL(click2OnCallsign(QString, QString)),this,
-            SLOT(doubleClickOnMessages(QString, QString)));
-  }
-  g_pMessages-&gt;show();
-}
-
-void MainWindow::on_actionOpen_triggered()                     //Open File
-{
-  m_monitoring=false;
-  soundInThread.setMonitoring(m_monitoring);
-  QString fname;
-  if(m_xpol) {
-    fname=QFileDialog::getOpenFileName(this, &quot;Open File&quot;, m_path,
-                                       &quot;MAP65 Files (*.tf2)&quot;);
-  } else {
-    fname=QFileDialog::getOpenFileName(this, &quot;Open File&quot;, m_path,
-                                       &quot;MAP65 Files (*.iq)&quot;);
-  }
-  if(fname != &quot;&quot;) {
-    m_path=fname;
-    int i;
-    i=fname.indexOf(&quot;.iq&quot;) - 11;
-    if(m_xpol) i=fname.indexOf(&quot;.tf2&quot;) - 11;
-    if(i&gt;=0) {
-      lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #66ff66}&quot;);
-      lab1-&gt;setText(&quot; &quot; + fname.mid(i,15) + &quot; &quot;);
-    }
-    on_stopButton_clicked();
-    m_diskData=true;
-    int dbDgrd=0;
-    if(m_myCall==&quot;K1JT&quot; and m_idInt&lt;0) dbDgrd=m_idInt;
-    *future1 = QtConcurrent::run(getfile, fname, m_xpol, dbDgrd);
-    watcher1-&gt;setFuture(*future1);
-  }
-}
-
-void MainWindow::on_actionOpen_next_in_directory_triggered()   //Open Next
-{
-  int i,len;
-  QFileInfo fi(m_path);
-  QStringList list;
-  list= fi.dir().entryList().filter(&quot;.iq&quot;);
-  len=14;
-  if(m_xpol) {
-      list= fi.dir().entryList().filter(&quot;.tf2&quot;);
-      len=15;
-  }
-  for (i = 0; i &lt; list.size()-1; ++i) {
-    if(i==list.size()-2) m_loopall=false;
-    if(list.at(i)==m_path.right(len)) {
-      int n=m_path.length();
-      QString fname=m_path.replace(n-len,len,list.at(i+1));
-      m_path=fname;
-      int i;
-      i=fname.indexOf(&quot;.iq&quot;) - 11;
-      if(m_xpol) i=fname.indexOf(&quot;.tf2&quot;) - 11;
-      if(i&gt;=0) {
-        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #66ff66}&quot;);
-        lab1-&gt;setText(&quot; &quot; + fname.mid(i,len) + &quot; &quot;);
-      }
-      m_diskData=true;
-      int dbDgrd=0;
-      if(m_myCall==&quot;K1JT&quot; and m_idInt&lt;0) dbDgrd=m_idInt;
-      *future1 = QtConcurrent::run(getfile, fname, m_xpol, dbDgrd);
-      watcher1-&gt;setFuture(*future1);
-      return;
-    }
-  }
-}
-                                                   //Open all remaining files
-void MainWindow::on_actionDecode_remaining_files_in_directory_triggered()
-{
-  m_loopall=true;
-  on_actionOpen_next_in_directory_triggered();
-}
-
-void MainWindow::diskDat()                                   //diskDat()
-{
-  double hsym;
-  //These may be redundant??
-  m_diskData=true;
-  datcom_.newdat=1;
-
-  if(m_fs96000) hsym=2048.0*96000.0/11025.0;   //Samples per JT65 half-symbol
-  if(!m_fs96000) hsym=2048.0*95238.1/11025.0;
-  for(int i=0; i&lt;281; i++) {              // Do the half-symbol FFTs
-    int k = i*hsym + 2048.5;
-    dataSink(k);
-    if(i%10 == 0) qApp-&gt;processEvents();   //Keep the GUI responsive
-  }
-}
-
-void MainWindow::diskWriteFinished()                       //diskWriteFinished
-{
-//  qDebug() &lt;&lt; &quot;diskWriteFinished&quot;;
-}
-                                                        //Delete ../save/*.tf2
-void MainWindow::on_actionDelete_all_tf2_files_in_SaveDir_triggered()
-{
-  int i;
-  QString fname;
-  int ret = QMessageBox::warning(this, &quot;Confirm Delete&quot;,
-      &quot;Are you sure you want to delete all *.tf2 and *.iq files in\n&quot; +
-       QDir::toNativeSeparators(m_saveDir) + &quot; ?&quot;,
-       QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
-  if(ret==QMessageBox::Yes) {
-    QDir dir(m_saveDir);
-    QStringList files=dir.entryList(QDir::Files);
-    QList&lt;QString&gt;::iterator f;
-    for(f=files.begin(); f!=files.end(); ++f) {
-      fname=*f;
-      i=(fname.indexOf(&quot;.tf2&quot;));
-      if(i==11) dir.remove(fname);
-      i=(fname.indexOf(&quot;.iq&quot;));
-      if(i==11) dir.remove(fname);
-    }
-  }
-}
-                                          //Clear BandMap and Messages windows
-void MainWindow::on_actionErase_Band_Map_and_Messages_triggered()
-{
-  g_pBandMap-&gt;setText(&quot;&quot;);
-  g_pMessages-&gt;setText(&quot;&quot;);
-  m_map65RxLog |= 4;
-}
-
-void MainWindow::on_actionFind_Delta_Phi_triggered()              //Find dPhi
-{
-  m_map65RxLog |= 8;
-  on_DecodeButton_clicked();
-}
-
-void MainWindow::on_actionF4_sets_Tx6_triggered()                //F4 sets Tx6
-{
-  m_kb8rq = !m_kb8rq;
-}
-
-void MainWindow::on_actionOnly_EME_calls_triggered()          //EME calls only
-{
-  m_onlyEME = ui-&gt;actionOnly_EME_calls-&gt;isChecked();
-}
-
-void MainWindow::on_actionNo_shorthands_if_Tx1_triggered()
-{
-  stub();
-}
-
-void MainWindow::on_actionNo_Deep_Search_triggered()          //No Deep Search
-{
-  m_ndepth=0;
-}
-
-void MainWindow::on_actionNormal_Deep_Search_triggered()      //Normal DS
-{
-  m_ndepth=1;
-}
-
-void MainWindow::on_actionAggressive_Deep_Search_triggered()  //Aggressive DS
-{
-  m_ndepth=2;
-}
-
-void MainWindow::on_actionNone_triggered()                    //Save None
-{
-  m_saveAll=false;
-}
-
-// ### Implement &quot;Save Last&quot; here? ###
-
-void MainWindow::on_actionSave_all_triggered()                //Save All
-{
-  m_saveAll=true;
-}
-                                          //Display list of keyboard shortcuts
-void MainWindow::on_actionKeyboard_shortcuts_triggered()
-{
-  stub();
-}
-                                              //Display list of mouse commands
-void MainWindow::on_actionSpecial_mouse_commands_triggered()
-{
-  stub();
-}
-                                              //Diaplay list of Add-On pfx/sfx
-void MainWindow::on_actionAvailable_suffixes_and_add_on_prefixes_triggered()
-{
-  stub();
-}
-
-void MainWindow::on_DecodeButton_clicked()                    //Decode request
-{
-  int n=m_sec0%60;
-  if(m_monitoring and n&gt;47 and (n&lt;52 or m_decoderBusy)) return;
-  if(!m_decoderBusy) {
-    datcom_.newdat=0;
-    datcom_.nagain=1;
-    decode();
-  }
-}
-
-void MainWindow::freezeDecode(int n)                          //freezeDecode()
-{
-  if(n==2) {
-    ui-&gt;tolSpinBox-&gt;setValue(5);
-    datcom_.ntol=m_tol;
-    datcom_.mousedf=0;
-  } else {
-    ui-&gt;tolSpinBox-&gt;setValue(3);
-    datcom_.ntol=m_tol;
-  }
-  if(!m_decoderBusy) {
-    datcom_.nagain=1;
-    datcom_.newdat=0;
-    decode();
-  }
-}
-
-void MainWindow::decode()                                       //decode()
-{
-  ui-&gt;DecodeButton-&gt;setStyleSheet(m_pbdecoding_style1);
-  if(datcom_.nagain==0 &amp;&amp; (!m_diskData)) {
-    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
-    int imin=ms/60000;
-    int ihr=imin/60;
-    imin=imin % 60;
-    datcom_.nutc=100*ihr + imin;
-  }
-
-  datcom_.idphi=m_dPhi;
-  datcom_.mousedf=g_pWideGraph-&gt;DF();
-  datcom_.mousefqso=g_pWideGraph-&gt;QSOfreq();
-  datcom_.ndepth=m_ndepth;
-  datcom_.ndiskdat=0;
-  if(m_diskData) datcom_.ndiskdat=1;
-  datcom_.neme=0;
-  if(ui-&gt;actionOnly_EME_calls-&gt;isChecked()) datcom_.neme=1;
-
-  int ispan=int(g_pWideGraph-&gt;fSpan());
-  if(ispan%2 == 1) ispan++;
-  int ifc=int(1000.0*(datcom_.fcenter - int(datcom_.fcenter))+0.5);
-  int nfa=g_pWideGraph-&gt;nStartFreq();
-  int nfb=nfa+ispan;
-  int nfshift=nfa + ispan/2 - ifc;
-
-  datcom_.nfa=nfa;
-  datcom_.nfb=nfb;
-  datcom_.nfcal=m_fCal;
-  datcom_.nfshift=nfshift;
-  datcom_.mcall3=0;
-  if(m_call3Modified) datcom_.mcall3=1;
-  datcom_.ntimeout=m_timeout;
-  datcom_.ntol=m_tol;
-  datcom_.nxant=0;
-  if(m_xpolx) datcom_.nxant=1;
-  if(datcom_.nutc &lt; m_nutc0) m_map65RxLog |= 1;  //Date and Time to all65.txt
-  m_nutc0=datcom_.nutc;
-  datcom_.map65RxLog=m_map65RxLog;
-  datcom_.nfsample=96000;
-  if(!m_fs96000) datcom_.nfsample=95238;
-  datcom_.nxpol=0;
-  if(m_xpol) datcom_.nxpol=1;
-  datcom_.mode65=m_mode65;
-
-  QString mcall=(m_myCall+&quot;            &quot;).mid(0,12);
-  QString mgrid=(m_myGrid+&quot;            &quot;).mid(0,6);
-  QString hcall=(ui-&gt;dxCallEntry-&gt;text()+&quot;            &quot;).mid(0,12);
-  QString hgrid=(ui-&gt;dxGridEntry-&gt;text()+&quot;      &quot;).mid(0,6);
-
-  strncpy(datcom_.mycall, mcall.toAscii(), 12);
-  strncpy(datcom_.mygrid, mgrid.toAscii(), 6);
-  strncpy(datcom_.hiscall, hcall.toAscii(), 12);
-  strncpy(datcom_.hisgrid, hgrid.toAscii(), 6);
-  strncpy(datcom_.datetime, m_dateTime.toAscii(), 20);
-
-  //newdat=1  ==&gt; this is new data, must do the big FFT
-  //nagain=1  ==&gt; decode only at fQSO +/- Tol
-
-  char *to = (char*)mem_m65.data();
-  char *from = (char*) datcom_.d4;
-  int size=sizeof(datcom_);
-  if(datcom_.newdat==0) {
-    int noffset = 4*4*5760000 + 4*4*322*32768 + 4*4*32768;
-    to += noffset;
-    from += noffset;
-    size -= noffset;
-  }
-  memcpy(to, from, qMin(mem_m65.size(), size));
-  datcom_.nagain=0;
-  datcom_.ndiskdat=0;
-  m_call3Modified=false;
-
-  QFile lockFile(m_appDir + &quot;/.lock&quot;);       // Allow m65 to start
-  lockFile.remove();
-
-  decodeBusy(true);
-}
-
-void MainWindow::m65_error()                                     //m65_error
-{
-  if(!m_killAll) {
-    msgBox(&quot;Error starting or running\n&quot; + m_appDir + &quot;/m65 -s&quot;);
-    exit(1);
-  }
-}
-
-void MainWindow::readFromStderr()                             //readFromStderr
-{
-  QByteArray t=proc_m65.readAllStandardError();
-  msgBox(t);
-}
-
-
-void MainWindow::readFromStdout()                             //readFromStdout
-{
-  while(proc_m65.canReadLine())
-  {
-    QByteArray t=proc_m65.readLine();
-    if(t.indexOf(&quot;&lt;m65aFinished&gt;&quot;) &gt;= 0) {
-      if(m_widebandDecode) {
-        g_pMessages-&gt;setText(m_messagesText);
-        g_pBandMap-&gt;setText(m_bandmapText);
-        m_widebandDecode=false;
-      }
-      QFile lockFile(m_appDir + &quot;/.lock&quot;);
-      lockFile.open(QIODevice::ReadWrite);
-      ui-&gt;DecodeButton-&gt;setStyleSheet(&quot;&quot;);
-      decodeBusy(false);
-      m_map65RxLog=0;
-      m_startAnother=m_loopall;
-      return;
-    }
-
-    if(t.indexOf(&quot;!&quot;) &gt;= 0) {
-      int n=t.length();
-      if(n&gt;=30) ui-&gt;decodedTextBrowser-&gt;append(t.mid(1,n-3));
-      if(n&lt;30) ui-&gt;decodedTextBrowser-&gt;append(t.mid(1,n-3));
-      n=ui-&gt;decodedTextBrowser-&gt;verticalScrollBar()-&gt;maximum();
-      ui-&gt;decodedTextBrowser-&gt;verticalScrollBar()-&gt;setValue(n);
-      m_messagesText=&quot;&quot;;
-      m_bandmapText=&quot;&quot;;
-    }
-
-    if(t.indexOf(&quot;@&quot;) &gt;= 0) {
-      m_messagesText += t.mid(1);
-      m_widebandDecode=true;
-    }
-
-    if(t.indexOf(&quot;&amp;&quot;) &gt;= 0) {
-      QString q(t);
-      QString callsign=q.mid(5);
-      callsign=callsign.mid(0,callsign.indexOf(&quot; &quot;));
-      if(callsign.length()&gt;2) {
-        if(m_worked[callsign]) {
-          q=q.mid(1,4) + &quot;  &quot; + q.mid(5);
-        } else {
-          q=q.mid(1,4) + &quot; *&quot; + q.mid(5);
-        }
-        m_bandmapText += q;
-      }
-    }
-  }
-}
-
-void MainWindow::on_EraseButton_clicked()                          //Erase
-{
-  ui-&gt;decodedTextBrowser-&gt;clear();
-}
-
-void MainWindow::decodeBusy(bool b)                             //decodeBusy()
-{
-  m_decoderBusy=b;
-  ui-&gt;DecodeButton-&gt;setEnabled(!b);
-  ui-&gt;actionOpen-&gt;setEnabled(!b);
-  ui-&gt;actionOpen_next_in_directory-&gt;setEnabled(!b);
-  ui-&gt;actionDecode_remaining_files_in_directory-&gt;setEnabled(!b);
-}
-
-//------------------------------------------------------------- //guiUpdate()
-void MainWindow::guiUpdate()
-{
-  static int iptt0=0;
-  static int iptt=0;
-  static bool btxok0=false;
-  static int nc0=1;
-  static int nc1=1;
-  static char msgsent[23];
-  static int nsendingsh=0;
-  int khsym=0;
-
-  double tx1=0.0;
-  double tx2=126.0*4096.0/11025.0 + 1.8;          //### depend on TxDelay? ###
-
-  if(!m_txFirst) {
-    tx1 += 60.0;
-    tx2 += 60.0;
-  }
-  qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
-  int nsec=ms/1000;
-  double tsec=0.001*ms;
-  double t120=fmod(tsec,120.0);
-  bool bTxTime = t120 &gt;= tx1 &amp;&amp; t120 &lt; tx2;
-
-  if(m_auto) {
-    if(bTxTime and iptt==0 and !m_txMute) {
-      int itx=1;
-      int ierr = ptt_(&amp;m_pttPort,&amp;itx,&amp;iptt);       // Raise PTT
-      if(ierr != 0) {
-        on_stopTxButton_clicked();
-        char s[18];
-        sprintf(s,&quot;Cannot open COM%d&quot;,m_pttPort);
-        msgBox(s);
-      }
-      if(!soundOutThread.isRunning()) {
-        soundOutThread.start(QThread::HighPriority);
-      }
-    }
-    if(!bTxTime || m_txMute) {
-      btxok=false;
-    }
-  }
-
-// Calculate Tx waveform when needed
-  if((iptt==1 &amp;&amp; iptt0==0) || m_restart) {
-    char message[23];
-    QByteArray ba;
-    if(m_ntx == 1) ba=ui-&gt;tx1-&gt;text().toLocal8Bit();
-    if(m_ntx == 2) ba=ui-&gt;tx2-&gt;text().toLocal8Bit();
-    if(m_ntx == 3) ba=ui-&gt;tx3-&gt;text().toLocal8Bit();
-    if(m_ntx == 4) ba=ui-&gt;tx4-&gt;text().toLocal8Bit();
-    if(m_ntx == 5) ba=ui-&gt;tx5-&gt;text().toLocal8Bit();
-    if(m_ntx == 6) ba=ui-&gt;tx6-&gt;text().toLocal8Bit();
-
-    ba2msg(ba,message);
-    int len1=22;
-    int mode65=m_mode65;
-    double samfac=1.0;
-
-    gen65_(message,&amp;mode65,&amp;samfac,&amp;nsendingsh,msgsent,iwave,&amp;nwave,len1,len1);
-    msgsent[22]=0;
-
-    if(m_restart) {
-      QFile f(&quot;map65_tx.log&quot;);
-      f.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Append);
-      QTextStream out(&amp;f);
-      out &lt;&lt; QDateTime::currentDateTimeUtc().toString(&quot;yyyy-MMM-dd hh:mm&quot;)
-          &lt;&lt; &quot;  Tx message:  &quot; &lt;&lt; QString::fromAscii(msgsent) &lt;&lt; endl;
-      f.close();
-    }
-
-    m_restart=false;
-  }
-
-// If PTT was just raised, start a countdown for raising TxOK:
-  if(iptt==1 &amp;&amp; iptt0==0) nc1=-9;    // TxDelay = 0.8 s
-  if(nc1 &lt;= 0) nc1++;
-  if(nc1 == 0) {
-    ui-&gt;xThermo-&gt;setValue(0.0);   //Set the Thermos to zero
-    ui-&gt;yThermo-&gt;setValue(0.0);
-    m_monitoring=false;
-    soundInThread.setMonitoring(false);
-    btxok=true;
-    m_transmitting=true;
-
-    QFile f(&quot;map65_tx.log&quot;);
-    f.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Append);
-    QTextStream out(&amp;f);
-    out &lt;&lt; QDateTime::currentDateTimeUtc().toString(&quot;yyyy-MMM-dd hh:mm&quot;)
-        &lt;&lt; &quot;  Tx message:  &quot; &lt;&lt; QString::fromAscii(msgsent) &lt;&lt; endl;
-    f.close();
-  }
-
-// If btxok was just lowered, start a countdown for lowering PTT
-  if(!btxok &amp;&amp; btxok0 &amp;&amp; iptt==1) nc0=-11;  //RxDelay = 1.0 s
-  if(nc0 &lt;= 0) nc0++;
-  if(nc0 == 0) {
-    int itx=0;
-    ptt_(&amp;m_pttPort,&amp;itx,&amp;iptt);       // Lower PTT
-    if(!m_txMute) soundOutThread.quitExecution=true;
-    m_transmitting=false;
-    if(m_auto) {
-      m_monitoring=true;
-      soundInThread.setMonitoring(m_monitoring);
-    }
-  }
-
-  if(iptt == 0 &amp;&amp; !btxok) {
-    // sending=&quot;&quot;
-    // nsendingsh=0
-  }
-
-  if(m_monitoring) {
-    ui-&gt;monitorButton-&gt;setStyleSheet(m_pbmonitor_style);
-  } else {
-    ui-&gt;monitorButton-&gt;setStyleSheet(&quot;&quot;);
-  }
-
-  lab2-&gt;setText(&quot;QSO Freq:  &quot; + QString::number(g_pWideGraph-&gt;QSOfreq()));
-  lab3-&gt;setText(&quot;QSO DF:  &quot; + QString::number(g_pWideGraph-&gt;DF()));
-
-  if(m_startAnother) {
-    m_startAnother=false;
-    on_actionOpen_next_in_directory_triggered();
-  }
-
-  if(nsec != m_sec0) {                                     //Once per second
-    soundInThread.setForceCenterFreqMHz(g_pWideGraph-&gt;m_dForceCenterFreq);
-    soundInThread.setForceCenterFreqBool(g_pWideGraph-&gt;m_bForceCenterFreq);
-
-    if(m_pctZap&gt;30.0 and !m_transmitting) {
-      lab4-&gt;setStyleSheet(&quot;QLabel{background-color: #ff0000}&quot;);
-    } else {
-      lab4-&gt;setStyleSheet(&quot;&quot;);
-    }
-
-    if(m_transmitting) {
-      if(nsendingsh==1) {
-        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #66ffff}&quot;);
-      } else if(nsendingsh==-1) {
-        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #ffccff}&quot;);
-      } else {
-        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #ffff33}&quot;);
-      }
-      char s[37];
-      sprintf(s,&quot;Tx: %s&quot;,msgsent);
-      lab1-&gt;setText(s);
-    } else if(m_monitoring) {
-      lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #00ff00}&quot;);
-      m_nrx=soundInThread.nrx();
-      khsym=soundInThread.mhsym();
-      QString t;
-      if(m_network) {
-        if(m_nrx==-1) t=&quot;F1&quot;;
-        if(m_nrx==1) t=&quot;I1&quot;;
-        if(m_nrx==-2) t=&quot;F2&quot;;
-        if(m_nrx==+2) t=&quot;I2&quot;;
-      } else {
-        if(m_nrx==1) t=&quot;S1&quot;;
-        if(m_nrx==2) t=&quot;S2&quot;;
-      }
-      if((abs(m_nrx)==1 and m_xpol) or (abs(m_nrx)==2 and !m_xpol))
-        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #ff1493}&quot;);
-      if(khsym==m_hsym0) {
-        t=&quot;Nil&quot;;
-        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #ffc0cb}&quot;);
-      }
-      lab1-&gt;setText(&quot;Receiving &quot; + t);
-    } else if (!m_diskData) {
-      lab1-&gt;setStyleSheet(&quot;&quot;);
-      lab1-&gt;setText(&quot;&quot;);
-    }
-
-    QDateTime t = QDateTime::currentDateTimeUtc();
-    int fQSO=g_pWideGraph-&gt;QSOfreq();
-    g_pAstro-&gt;astroUpdate(t, m_myGrid, m_hisGrid, fQSO, m_setftx,
-                          m_txFreq, m_azelDir);
-    m_setftx=0;
-    QString utc = &quot; &quot; + t.time().toString() + &quot; &quot;;
-    ui-&gt;labUTC-&gt;setText(utc);
-    if((!m_monitoring and !m_diskData) or (khsym==m_hsym0)) {
-      ui-&gt;xThermo-&gt;setValue(0.0);                      // Set Rx levels to 0
-      ui-&gt;yThermo-&gt;setValue(0.0);
-      lab4-&gt;setText(&quot; Rx noise:    0.0     0.0  0.0% &quot;);
-    }
-    m_hsym0=khsym;
-    m_sec0=nsec;
-  }
-  iptt0=iptt;
-  btxok0=btxok;
-}
-
-void MainWindow::ba2msg(QByteArray ba, char message[])             //ba2msg()
-{
-  bool eom;
-  eom=false;
-  for(int i=0;i&lt;22; i++) {
-    if((int)ba[i] == 0) eom=true;
-    if(eom) {
-      message[i]=32;
-    } else {
-      message[i]=ba[i];
-    }
-  }
-  message[22]=0;
-}
-
-void MainWindow::on_txFirstCheckBox_stateChanged(int nstate)        //TxFirst
-{
-  m_txFirst = (nstate==2);
-}
-
-void MainWindow::set_ntx(int n)                                   //set_ntx()
-{
-  m_ntx=n;
-}
-
-void MainWindow::on_txb1_clicked()                                //txb1
-{
-  m_ntx=1;
-  ui-&gt;txrb1-&gt;setChecked(true);
-  m_restart=true;
-}
-
-void MainWindow::on_txb2_clicked()                                //txb2
-{
-  m_ntx=2;
-  ui-&gt;txrb2-&gt;setChecked(true);
-  m_restart=true;
-}
-
-void MainWindow::on_txb3_clicked()                                //txb3
-{
-  m_ntx=3;
-  ui-&gt;txrb3-&gt;setChecked(true);
-  m_restart=true;
-}
-
-void MainWindow::on_txb4_clicked()                                //txb4
-{
-  m_ntx=4;
-  ui-&gt;txrb4-&gt;setChecked(true);
-  m_restart=true;
-}
-
-void MainWindow::on_txb5_clicked()                                //txb5
-{
-  m_ntx=5;
-  ui-&gt;txrb5-&gt;setChecked(true);
-  m_restart=true;
-}
-
-void MainWindow::on_txb6_clicked()                                //txb6
-{
-  m_ntx=6;
-  ui-&gt;txrb6-&gt;setChecked(true);
-  m_restart=true;
-}
-
-void MainWindow::selectCall2(bool ctrl)                                //selectCall2
-{
-  QString t = ui-&gt;decodedTextBrowser-&gt;toPlainText();   //Full contents
-  int i=ui-&gt;decodedTextBrowser-&gt;textCursor().position();
-  int i0=t.lastIndexOf(&quot; &quot;,i);
-  int i1=t.indexOf(&quot; &quot;,i);
-  QString hiscall=t.mid(i0+1,i1-i0-1);
-  if(hiscall!=&quot;&quot;) {
-    if(hiscall.length() &lt; 13) doubleClickOnCall(hiscall, ctrl);
-  }
-}
-                                                          //doubleClickOnCall
-void MainWindow::doubleClickOnCall(QString hiscall, bool ctrl)
-{
-  if(m_worked[hiscall]) {
-    msgBox(&quot;Possible dupe: &quot; + hiscall + &quot; already in log.&quot;);
-  }
-  ui-&gt;dxCallEntry-&gt;setText(hiscall);
-  QString t = ui-&gt;decodedTextBrowser-&gt;toPlainText();   //Full contents
-  int i2=ui-&gt;decodedTextBrowser-&gt;textCursor().position();
-  QString t1 = t.mid(0,i2);              //contents up to text cursor
-  int i1=t1.lastIndexOf(&quot;\n&quot;) + 1;
-  QString t2 = t1.mid(i1,i2-i1);         //selected line
-  int n = 60*t2.mid(13,2).toInt() + t2.mid(15,2).toInt();
-  m_txFirst = ((n%2) == 1);
-  ui-&gt;txFirstCheckBox-&gt;setChecked(m_txFirst);
-  QString rpt=&quot;&quot;;
-  if(ctrl) rpt=t2.mid(23,3);
-  lookup();
-  genStdMsgs(rpt);
-  if(t2.indexOf(m_myCall)&gt;0) {
-    m_ntx=2;
-    ui-&gt;txrb2-&gt;setChecked(true);
-  } else {
-    m_ntx=1;
-    ui-&gt;txrb1-&gt;setChecked(true);
-  }
-}
-                                                      //doubleClickOnMessages
-void MainWindow::doubleClickOnMessages(QString hiscall, QString t2)
-{
-  if(m_worked[hiscall]) {
-    msgBox(&quot;Possible dupe: &quot; + hiscall + &quot; already in log.&quot;);
-  }
-  ui-&gt;dxCallEntry-&gt;setText(hiscall);
-  int n = 60*t2.mid(13,2).toInt() + t2.mid(15,2).toInt();
-  m_txFirst = ((n%2) == 1);
-  ui-&gt;txFirstCheckBox-&gt;setChecked(m_txFirst);
-  lookup();
-  genStdMsgs(&quot;&quot;);
-  if(t2.indexOf(m_myCall)&gt;0) {
-    m_ntx=2;
-    ui-&gt;txrb2-&gt;setChecked(true);
-  } else {
-    m_ntx=1;
-    ui-&gt;txrb1-&gt;setChecked(true);
-  }
-}
-
-void MainWindow::genStdMsgs(QString rpt)                       //genStdMsgs()
-{
-  QString hiscall=ui-&gt;dxCallEntry-&gt;text().toUpper().trimmed();
-  ui-&gt;dxCallEntry-&gt;setText(hiscall);
-  QString t0=hiscall + &quot; &quot; + m_myCall + &quot; &quot;;
-  QString t=t0 + m_myGrid.mid(0,4);
-  msgtype(t, ui-&gt;tx1);
-  if(rpt == &quot;&quot;) {
-    t=t+&quot; OOO&quot;;
-    msgtype(t, ui-&gt;tx2);
-    msgtype(&quot;RO&quot;, ui-&gt;tx3);
-    msgtype(&quot;RRR&quot;, ui-&gt;tx4);
-    msgtype(&quot;73&quot;, ui-&gt;tx5);
-  } else {
-    t=t0 + rpt;
-    msgtype(t, ui-&gt;tx2);
-    t=t0 + &quot;R&quot; + rpt;
-    msgtype(t, ui-&gt;tx3);
-    t=t0 + &quot;RRR&quot;;
-    msgtype(t, ui-&gt;tx4);
-    t=t0 + &quot;73&quot;;
-    msgtype(t, ui-&gt;tx5);
-  }
-  t=&quot;CQ &quot; + m_myCall + &quot; &quot; + m_myGrid.mid(0,4);
-  msgtype(t, ui-&gt;tx6);
-  m_ntx=1;
-  ui-&gt;txrb1-&gt;setChecked(true);
-}
-
-void MainWindow::lookup()                                       //lookup()
-{
-  QString hiscall=ui-&gt;dxCallEntry-&gt;text().toUpper().trimmed();
-  ui-&gt;dxCallEntry-&gt;setText(hiscall);
-  QString call3File = m_appDir + &quot;/CALL3.TXT&quot;;
-  QFile f(call3File);
-  if(!f.open(QIODevice::ReadOnly | QIODevice::Text)) {
-    msgBox(&quot;Cannot open &quot; + call3File);
-    return;
-  }
-  char c[132];
-  qint64 n=0;
-  for(int i=0; i&lt;999999; i++) {
-    n=f.readLine(c,sizeof(c));
-    if(n &lt;= 0) {
-      ui-&gt;dxGridEntry-&gt;setText(&quot;&quot;);
-      break;
-     }
-    QString t=QString(c);
-    if(t.indexOf(hiscall)==0) {
-      int i1=t.indexOf(&quot;,&quot;);
-      QString hisgrid=t.mid(i1+1,6);
-      i1=hisgrid.indexOf(&quot;,&quot;);
-      if(i1&gt;0) {
-        hisgrid=hisgrid.mid(0,4);
-      } else {
-        hisgrid=hisgrid.mid(0,4) + hisgrid.mid(4,2).toLower();
-      }
-      ui-&gt;dxGridEntry-&gt;setText(hisgrid);
-      break;
-    }
-  }
-  f.close();
-}
-
-void MainWindow::on_lookupButton_clicked()                    //Lookup button
-{
-  lookup();
-}
-
-void MainWindow::on_addButton_clicked()                       //Add button
-{
-  if(ui-&gt;dxGridEntry-&gt;text()==&quot;&quot;) {
-    msgBox(&quot;Please enter a valid grid locator.&quot;);
-    return;
-  }
-  m_call3Modified=false;
-  QString hiscall=ui-&gt;dxCallEntry-&gt;text().toUpper().trimmed();
-  QString hisgrid=ui-&gt;dxGridEntry-&gt;text().trimmed();
-  QString newEntry=hiscall + &quot;,&quot; + hisgrid;
-
-  int ret = QMessageBox::warning(this, &quot;Add&quot;,
-       newEntry + &quot;\n&quot; + &quot;Is this station known to be active on EME?&quot;,
-       QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
-  if(ret==QMessageBox::Yes) {
-    newEntry += &quot;,EME,,&quot;;
-  } else {
-    newEntry += &quot;,,,&quot;;
-  }
-  QString call3File = m_appDir + &quot;/CALL3.TXT&quot;;
-  QFile f1(call3File);
-  if(!f1.open(QIODevice::ReadOnly | QIODevice::Text)) {
-    msgBox(&quot;Cannot open &quot; + call3File);
-    return;
-  }
-  QString tmpFile = m_appDir + &quot;/CALL3.TMP&quot;;
-  QFile f2(tmpFile);
-  if(!f2.open(QIODevice::WriteOnly | QIODevice::Text)) {
-    msgBox(&quot;Cannot open &quot; + tmpFile);
-    return;
-  }
-  QTextStream in(&amp;f1);
-  QTextStream out(&amp;f2);
-  QString hc=hiscall;
-  QString hc1=&quot;&quot;;
-  QString hc2=&quot;&quot;;
-  QString s;
-  do {
-    s=in.readLine();
-    hc1=hc2;
-    if(s.mid(0,2)==&quot;//&quot;) {
-      out &lt;&lt; s + &quot;\n&quot;;
-    } else {
-      int i1=s.indexOf(&quot;,&quot;);
-      hc2=s.mid(0,i1);
-      if(hc&gt;hc1 &amp;&amp; hc&lt;hc2) {
-        out &lt;&lt; newEntry + &quot;\n&quot;;
-        m_call3Modified=true;
-      } else if(hc==hc2) {
-        QString t=s + &quot;\n\n is already in CALL3.TXT\n&quot; +
-            &quot;Do you wish to replace it?&quot;;
-        int ret = QMessageBox::warning(this, &quot;Add&quot;,t,
-             QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
-        if(ret==QMessageBox::Yes) {
-          out &lt;&lt; newEntry + &quot;\n&quot;;
-          m_call3Modified=true;
-        }
-      } else {
-        out &lt;&lt; s + &quot;\n&quot;;
-      }
-    }
-  } while(!s.isNull());
-
-  f1.close();
-  if(hc&gt;hc1 &amp;&amp; !m_call3Modified)
-    out &lt;&lt; newEntry + &quot;\n&quot;;
-  if(m_call3Modified) {
-    QFile f0(m_appDir + &quot;/CALL3.OLD&quot;);
-    if(f0.exists()) f0.remove();
-    QFile f1(m_appDir + &quot;/CALL3.TXT&quot;);
-    f1.rename(m_appDir + &quot;/CALL3.OLD&quot;);
-    f2.rename(m_appDir + &quot;/CALL3.TXT&quot;);
-    f2.close();
-  }
-}
-
-void MainWindow::msgtype(QString t, QLineEdit* tx)                //msgtype()
-{
-//  if(t.length()&lt;1) return 0;
-  char message[23];
-  char msgsent[23];
-  int len1=22;
-  int mode65=0;            //mode65 ==&gt; check message but don't make wave()
-  double samfac=1.0;
-  int nsendingsh=0;
-  int mwave;
-  t=t.toUpper();
-  int i1=t.indexOf(&quot; OOO&quot;);
-  QByteArray s=t.toUpper().toLocal8Bit();
-  ba2msg(s,message);
-  gen65_(message,&amp;mode65,&amp;samfac,&amp;nsendingsh,msgsent,iwave,&amp;mwave,len1,len1);
-
-  QPalette p(tx-&gt;palette());
-  if(nsendingsh==1) {
-    p.setColor(QPalette::Base,&quot;#66ffff&quot;);
-  } else if(nsendingsh==-1) {
-    p.setColor(QPalette::Base,&quot;#ffccff&quot;);
-  } else {
-    p.setColor(QPalette::Base,Qt::white);
-  }
-  tx-&gt;setPalette(p);
-  int len=t.length();
-  if(nsendingsh==-1) {
-    len=qMin(len,13);
-    if(i1&gt;10) {
-      tx-&gt;setText(t.mid(0,len).toUpper() + &quot; OOO&quot;);
-    } else {
-      tx-&gt;setText(t.mid(0,len).toUpper());
-    }
-  } else {
-    tx-&gt;setText(t);
-  }
-}
-
-void MainWindow::on_tx1_editingFinished()                       //tx1 edited
-{
-  QString t=ui-&gt;tx1-&gt;text();
-  msgtype(t, ui-&gt;tx1);
-}
-
-void MainWindow::on_tx2_editingFinished()                       //tx2 edited
-{
-  QString t=ui-&gt;tx2-&gt;text();
-  msgtype(t, ui-&gt;tx2);
-}
-
-void MainWindow::on_tx3_editingFinished()                       //tx3 edited
-{
-  QString t=ui-&gt;tx3-&gt;text();
-  msgtype(t, ui-&gt;tx3);
-}
-
-void MainWindow::on_tx4_editingFinished()                       //tx4 edited
-{
-  QString t=ui-&gt;tx4-&gt;text();
-  msgtype(t, ui-&gt;tx4);
-}
-
-void MainWindow::on_tx5_editingFinished()                       //tx5 edited
-{
-  QString t=ui-&gt;tx5-&gt;text();
-  msgtype(t, ui-&gt;tx5);
-}
-
-void MainWindow::on_tx6_editingFinished()                       //tx6 edited
-{
-  QString t=ui-&gt;tx6-&gt;text();
-  msgtype(t, ui-&gt;tx6);
-}
-
-void MainWindow::on_setTxFreqButton_clicked()                  //Set Tx Freq
-{
-  m_setftx=1;
-  m_txFreq=g_pWideGraph-&gt;QSOfreq();
-}
-
-void MainWindow::on_dxCallEntry_textChanged(const QString &amp;t) //dxCall changed
-{
-  m_hisCall=t.toUpper().trimmed();
-  ui-&gt;dxCallEntry-&gt;setText(m_hisCall);
-}
-
-void MainWindow::on_dxGridEntry_textChanged(const QString &amp;t) //dxGrid changed
-{
-  int n=t.length();
-  if(n!=4 and n!=6) return;
-  if(!t[0].isLetter() or !t[1].isLetter()) return;
-  if(!t[2].isDigit() or !t[3].isDigit()) return;
-  if(n==4) m_hisGrid=t.mid(0,2).toUpper() + t.mid(2,2);
-  if(n==6) m_hisGrid=t.mid(0,2).toUpper() + t.mid(2,2) +
-      t.mid(4,2).toLower();
-  ui-&gt;dxGridEntry-&gt;setText(m_hisGrid);
-}
-
-void MainWindow::on_genStdMsgsPushButton_clicked()         //genStdMsgs button
-{
-  genStdMsgs(&quot;&quot;);
-}
-
-void MainWindow::on_logQSOButton_clicked()                 //Log QSO button
-{
-  int nMHz=int(datcom_.fcenter);
-  QDateTime t = QDateTime::currentDateTimeUtc();
-  QString logEntry=t.date().toString(&quot;yyyy-MMM-dd,&quot;) +
-      t.time().toString(&quot;hh:mm,&quot;) + m_hisCall + &quot;,&quot; + m_hisGrid + &quot;,&quot; +
-      QString::number(nMHz) + &quot;,JT65B\n&quot;;
-  QFile f(&quot;wsjt.log&quot;);
-  if(!f.open(QFile::Append)) {
-    msgBox(&quot;Cannot open file \&quot;wsjt.log\&quot;.&quot;);
-    return;
-  }
-  QTextStream out(&amp;f);
-  out &lt;&lt; logEntry;
-  f.close();
-  m_worked[m_hisCall]=true;
-}
-
-void MainWindow::on_actionErase_map65_rx_log_triggered()     //Erase Rx log
-{
-  int ret = QMessageBox::warning(this, &quot;Confirm Erase&quot;,
-      &quot;Are you sure you want to erase file map65_rx.log ?&quot;,
-       QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
-  if(ret==QMessageBox::Yes) {
-    m_map65RxLog |= 2;                      // Rewind map65_rx.log
-  }
-}
-
-void MainWindow::on_actionErase_map65_tx_log_triggered()     //Erase Tx log
-{
-  int ret = QMessageBox::warning(this, &quot;Confirm Erase&quot;,
-      &quot;Are you sure you want to erase file map65_tx.log ?&quot;,
-       QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
-  if(ret==QMessageBox::Yes) {
-    QFile f(&quot;map65_tx.log&quot;);
-    f.remove();
-  }
-}
-
-void MainWindow::on_actionJT65A_triggered()
-{
-  m_mode=&quot;JT65A&quot;;
-  m_mode65=1;
-  g_pWideGraph-&gt;setMode65(m_mode65);
-  lab5-&gt;setText(m_mode);
-  ui-&gt;actionJT65A-&gt;setChecked(true);
-}
-
-void MainWindow::on_actionJT65B_triggered()
-{
-  m_mode=&quot;JT65B&quot;;
-  m_mode65=2;
-  g_pWideGraph-&gt;setMode65(m_mode65);
-  lab5-&gt;setText(m_mode);
-  ui-&gt;actionJT65B-&gt;setChecked(true);
-}
-
-void MainWindow::on_actionJT65C_triggered()
-{
-  m_mode=&quot;JT65C&quot;;
-  m_mode65=4;
-  g_pWideGraph-&gt;setMode65(m_mode65);
-  lab5-&gt;setText(m_mode);
-  ui-&gt;actionJT65C-&gt;setChecked(true);
-}
-
-void MainWindow::on_NBcheckBox_toggled(bool checked)
-{
-  m_NB=checked;
-  ui-&gt;NBslider-&gt;setEnabled(m_NB);
-}
-
-void MainWindow::on_NBslider_valueChanged(int n)
-{
-  m_NBslider=n;
-}
-
-void MainWindow::on_actionAdjust_IQ_Calibration_triggered()
-{
-  m_adjustIQ=1;
-}
-
-void MainWindow::on_actionApply_IQ_Calibration_triggered()
-{
-  m_applyIQcal= 1-m_applyIQcal;
-}
-
-void MainWindow::on_actionFUNcube_Dongle_triggered()
-{
-  proc_qthid.start(QDir::toNativeSeparators(m_appDir + &quot;/qthid&quot;));
-}
+//-------------------------------------------------------------- MainWindow
+#include &quot;mainwindow.h&quot;
+#include &quot;ui_mainwindow.h&quot;
+#include &quot;devsetup.h&quot;
+#include &quot;plotter.h&quot;
+#include &quot;about.h&quot;
+#include &quot;astro.h&quot;
+#include &quot;widegraph.h&quot;
+#include &quot;messages.h&quot;
+#include &quot;bandmap.h&quot;
+#include &quot;sleep.h&quot;
+#include &lt;portaudio.h&gt;
+
+#define NFFT 32768
+
+short int iwave[60*11025];            //Wave file for Tx audio
+int nwave;                            //Length of Tx waveform
+bool btxok;                           //True if OK to transmit
+double outputLatency;                 //Latency in seconds
+qint16 id[4*60*96000];
+
+
+Astro*     g_pAstro = NULL;
+WideGraph* g_pWideGraph = NULL;
+Messages*  g_pMessages = NULL;
+
+BandMap*   g_pBandMap = NULL;
+QSharedMemory mem_m65(&quot;mem_m65&quot;);
+
+QString rev=&quot;$Rev$&quot;;
+QString Program_Title_Version=&quot;  MAP65   v2.3.0, r&quot; + rev.mid(6,3) +
+                              &quot;    by K1JT&quot;;
+
+extern const int RxDataFrequency = 96000;
+extern const int TxDataFrequency = 11025;
+
+//-------------------------------------------------- MainWindow constructor
+MainWindow::MainWindow(QWidget *parent) :
+  QMainWindow(parent),
+  ui(new Ui::MainWindow)
+{
+  ui-&gt;setupUi(this);
+
+  on_EraseButton_clicked();
+  ui-&gt;labUTC-&gt;setStyleSheet( \
+        &quot;QLabel { background-color : black; color : yellow; }&quot;);
+  ui-&gt;labTol1-&gt;setStyleSheet( \
+        &quot;QLabel { background-color : white; color : black; }&quot;);
+  ui-&gt;labTol1-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
+  ui-&gt;dxStationGroupBox-&gt;setStyleSheet(&quot;QFrame{border: 5px groove red}&quot;);
+
+  QActionGroup* paletteGroup = new QActionGroup(this);
+  ui-&gt;actionCuteSDR-&gt;setActionGroup(paletteGroup);
+  ui-&gt;actionLinrad-&gt;setActionGroup(paletteGroup);
+  ui-&gt;actionAFMHot-&gt;setActionGroup(paletteGroup);
+  ui-&gt;actionBlue-&gt;setActionGroup(paletteGroup);
+
+  QActionGroup* modeGroup = new QActionGroup(this);
+  ui-&gt;actionJT65A-&gt;setActionGroup(modeGroup);
+  ui-&gt;actionJT65B-&gt;setActionGroup(modeGroup);
+  ui-&gt;actionJT65C-&gt;setActionGroup(modeGroup);
+
+  QActionGroup* saveGroup = new QActionGroup(this);
+  ui-&gt;actionSave_all-&gt;setActionGroup(saveGroup);
+  ui-&gt;actionNone-&gt;setActionGroup(saveGroup);
+
+  QActionGroup* DepthGroup = new QActionGroup(this);
+  ui-&gt;actionNo_Deep_Search-&gt;setActionGroup(DepthGroup);
+  ui-&gt;actionNormal_Deep_Search-&gt;setActionGroup(DepthGroup);
+  ui-&gt;actionAggressive_Deep_Search-&gt;setActionGroup(DepthGroup);
+
+  QButtonGroup* txMsgButtonGroup = new QButtonGroup;
+  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb1,1);
+  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb2,2);
+  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb3,3);
+  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb4,4);
+  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb5,5);
+  txMsgButtonGroup-&gt;addButton(ui-&gt;txrb6,6);
+  connect(txMsgButtonGroup,SIGNAL(buttonClicked(int)),SLOT(set_ntx(int)));
+  connect(ui-&gt;decodedTextBrowser,SIGNAL(selectCallsign(bool)),this,
+          SLOT(selectCall2(bool)));
+
+  setWindowTitle(Program_Title_Version);
+
+  connect(&amp;soundInThread, SIGNAL(readyForFFT(int)),
+             this, SLOT(dataSink(int)));
+  connect(&amp;soundInThread, SIGNAL(error(QString)), this,
+          SLOT(showSoundInError(QString)));
+  connect(&amp;soundInThread, SIGNAL(status(QString)), this,
+          SLOT(showStatusMessage(QString)));
+  createStatusBar();
+
+  connect(&amp;proc_m65, SIGNAL(readyReadStandardOutput()),
+                    this, SLOT(readFromStdout()));
+
+  connect(&amp;proc_m65, SIGNAL(error(QProcess::ProcessError)),
+          this, SLOT(m65_error()));
+
+  connect(&amp;proc_m65, SIGNAL(readyReadStandardError()),
+          this, SLOT(readFromStderr()));
+
+  QTimer *guiTimer = new QTimer(this);
+  connect(guiTimer, SIGNAL(timeout()), this, SLOT(guiUpdate()));
+  guiTimer-&gt;start(100);                            //Don't change the 100 ms!
+
+  m_auto=false;
+  m_waterfallAvg = 1;
+  m_network = true;
+  m_txFirst=false;
+  m_txMute=false;
+  btxok=false;
+  m_restart=false;
+  m_transmitting=false;
+  m_killAll=false;
+  m_widebandDecode=false;
+  m_ntx=1;
+  m_myCall=&quot;K1JT&quot;;
+  m_myGrid=&quot;FN20qi&quot;;
+  m_appDir = QApplication::applicationDirPath();
+  m_saveDir=&quot;/users/joe/map65/install/save&quot;;
+  m_azelDir=&quot;/users/joe/map65/install/&quot;;
+  m_txFreq=125;
+  m_setftx=0;
+  m_loopall=false;
+  m_startAnother=false;
+  m_saveAll=false;
+  m_onlyEME=false;
+  m_sec0=-1;
+  m_hsym0=-1;
+  m_palette=&quot;CuteSDR&quot;;
+  m_map65RxLog=1;                     //Write Date and Time to all65.txt
+  m_nutc0=9999;
+  m_kb8rq=false;
+  m_NB=false;
+  m_mode=&quot;JT65B&quot;;
+  m_mode65=2;
+  m_fs96000=true;
+  m_udpPort=50004;
+  m_adjustIQ=0;
+  m_applyIQcal=0;
+  m_colors=&quot;000066ff0000ffff00969696646464&quot;;
+
+  ui-&gt;xThermo-&gt;setFillBrush(Qt::green);
+  ui-&gt;yThermo-&gt;setFillBrush(Qt::magenta);
+
+#ifdef WIN32
+  while(true) {
+      int iret=killbyname(&quot;m65.exe&quot;);
+      if(iret == 603) break;
+      if(iret != 0) msgBox(&quot;KillByName return code: &quot; +
+                           QString::number(iret));
+  }
+#endif
+
+  if(!mem_m65.attach()) {
+    if (!mem_m65.create(sizeof(datcom_))) {
+      msgBox(&quot;Unable to create shared memory segment.&quot;);
+    }
+  }
+  char *to = (char*)mem_m65.data();
+  int size=sizeof(datcom_);
+  if(datcom_.newdat==0) {
+    int noffset = 4*4*5760000 + 4*4*322*32768 + 4*4*32768;
+    to += noffset;
+    size -= noffset;
+  }
+  memset(to,0,size);         //Zero all decoding params in shared memory
+
+  PaError paerr=Pa_Initialize();                    //Initialize Portaudio
+  if(paerr!=paNoError) {
+    msgBox(&quot;Unable to initialize PortAudio.&quot;);
+  }
+  readSettings();		             //Restore user's setup params
+  QFile lockFile(m_appDir + &quot;/.lock&quot;); //Create .lock so m65 will wait
+  lockFile.open(QIODevice::ReadWrite);
+  QFile quitFile(m_appDir + &quot;/.lock&quot;);
+  quitFile.remove();
+  proc_m65.start(QDir::toNativeSeparators(m_appDir + &quot;/m65 -s&quot;));
+
+  m_pbdecoding_style1=&quot;QPushButton{background-color: cyan; \
+      border-style: outset; border-width: 1px; border-radius: 5px; \
+      border-color: black; min-width: 5em; padding: 3px;}&quot;;
+  m_pbmonitor_style=&quot;QPushButton{background-color: #00ff00; \
+      border-style: outset; border-width: 1px; border-radius: 5px; \
+      border-color: black; min-width: 5em; padding: 3px;}&quot;;
+  m_pbAutoOn_style=&quot;QPushButton{background-color: red; \
+      border-style: outset; border-width: 1px; border-radius: 5px; \
+      border-color: black; min-width: 5em; padding: 3px;}&quot;;
+
+  genStdMsgs(&quot;&quot;);
+
+  on_actionAstro_Data_triggered();           //Create the other windows
+  on_actionWide_Waterfall_triggered();
+  on_actionMessages_triggered();
+  on_actionBand_Map_triggered();
+  g_pMessages-&gt;setColors(m_colors);
+  g_pBandMap-&gt;setColors(m_colors);
+  g_pAstro-&gt;setFontSize(m_astroFont);
+  if(m_mode==&quot;JT65A&quot;) on_actionJT65A_triggered();
+  if(m_mode==&quot;JT65B&quot;) on_actionJT65B_triggered();
+  if(m_mode==&quot;JT65C&quot;) on_actionJT65C_triggered();
+
+  future1 = new QFuture&lt;void&gt;;
+  watcher1 = new QFutureWatcher&lt;void&gt;;
+  connect(watcher1, SIGNAL(finished()),this,SLOT(diskDat()));
+
+  future2 = new QFuture&lt;void&gt;;
+  watcher2 = new QFutureWatcher&lt;void&gt;;
+  connect(watcher2, SIGNAL(finished()),this,SLOT(diskWriteFinished()));
+
+// Assign input device and start input thread
+  soundInThread.setInputDevice(m_paInDevice);
+  if(m_fs96000) soundInThread.setRate(96000.0);
+  if(!m_fs96000) soundInThread.setRate(95238.1);
+  soundInThread.setBufSize(10*7056);
+  soundInThread.setNetwork(m_network);
+  soundInThread.setPort(m_udpPort);
+  if(!m_xpol) soundInThread.setNrx(1);
+  if(m_xpol) soundInThread.setNrx(2);
+  soundInThread.start(QThread::HighestPriority);
+
+  // Assign output device and start output thread
+  soundOutThread.setOutputDevice(m_paOutDevice);
+//  soundOutThread.start(QThread::HighPriority);
+
+  m_monitoring=true;                           // Start with Monitoring ON
+  soundInThread.setMonitoring(m_monitoring);
+  m_diskData=false;
+  m_tol=500;
+  g_pWideGraph-&gt;setTol(m_tol);
+  g_pWideGraph-&gt;setFcal(m_fCal);
+  if(m_fs96000) g_pWideGraph-&gt;setFsample(96000);
+  if(!m_fs96000) g_pWideGraph-&gt;setFsample(95238);
+  g_pWideGraph-&gt;m_mult570=m_mult570;
+  g_pWideGraph-&gt;m_cal570=m_cal570;
+  if(m_initIQplus) g_pWideGraph-&gt;initIQplus();
+
+// Create &quot;m_worked&quot;, a dictionary of all calls in wsjt.log
+  QFile f(&quot;wsjt.log&quot;);
+  f.open(QIODevice::ReadOnly);
+  QTextStream in(&amp;f);
+  QString line,t,callsign;
+  for(int i=0; i&lt;99999; i++) {
+    line=in.readLine();
+    if(line.length()&lt;=0) break;
+    t=line.mid(18,12);
+    callsign=t.mid(0,t.indexOf(&quot;,&quot;));
+    m_worked[callsign]=true;
+  }
+  f.close();
+
+  if(ui-&gt;actionLinrad-&gt;isChecked()) on_actionLinrad_triggered();
+  if(ui-&gt;actionCuteSDR-&gt;isChecked()) on_actionCuteSDR_triggered();
+  if(ui-&gt;actionAFMHot-&gt;isChecked()) on_actionAFMHot_triggered();
+  if(ui-&gt;actionBlue-&gt;isChecked()) on_actionBlue_triggered();
+                                             // End of MainWindow constructor
+}
+
+  //--------------------------------------------------- MainWindow destructor
+MainWindow::~MainWindow()
+{
+  writeSettings();
+  if (soundInThread.isRunning()) {
+    soundInThread.quit();
+    soundInThread.wait(3000);
+  }
+  if (soundOutThread.isRunning()) {
+    soundOutThread.quitExecution=true;
+    soundOutThread.wait(3000);
+  }
+  if(!m_decoderBusy) {
+    QFile lockFile(m_appDir + &quot;/.lock&quot;);
+    lockFile.remove();
+  }
+  delete ui;
+}
+
+//-------------------------------------------------------- writeSettings()
+void MainWindow::writeSettings()
+{
+  QString inifile = m_appDir + &quot;/map65.ini&quot;;
+  QSettings settings(inifile, QSettings::IniFormat);
+
+  settings.beginGroup(&quot;MainWindow&quot;);
+  settings.setValue(&quot;geometry&quot;, saveGeometry());
+  settings.setValue(&quot;MRUdir&quot;, m_path);
+  settings.setValue(&quot;TxFirst&quot;,m_txFirst);
+  settings.setValue(&quot;DXcall&quot;,ui-&gt;dxCallEntry-&gt;text());
+  settings.setValue(&quot;DXgrid&quot;,ui-&gt;dxGridEntry-&gt;text());
+
+  if(g_pAstro-&gt;isVisible()) {
+    m_astroGeom = g_pAstro-&gt;geometry();
+    settings.setValue(&quot;AstroGeom&quot;,m_astroGeom);
+  }
+
+  if(g_pWideGraph-&gt;isVisible()) {
+    m_wideGraphGeom = g_pWideGraph-&gt;geometry();
+    settings.setValue(&quot;WideGraphGeom&quot;,m_wideGraphGeom);
+  }
+  if(g_pMessages-&gt;isVisible()) {
+    m_messagesGeom = g_pMessages-&gt;geometry();
+    settings.setValue(&quot;MessagesGeom&quot;,m_messagesGeom);
+  }
+  if(g_pBandMap-&gt;isVisible()) {
+    m_bandMapGeom = g_pBandMap-&gt;geometry();
+    settings.setValue(&quot;BandMapGeom&quot;,m_bandMapGeom);
+  }
+  settings.endGroup();
+
+  settings.beginGroup(&quot;Common&quot;);
+  settings.setValue(&quot;MyCall&quot;,m_myCall);
+  settings.setValue(&quot;MyGrid&quot;,m_myGrid);
+  settings.setValue(&quot;IDint&quot;,m_idInt);
+  settings.setValue(&quot;PTTport&quot;,m_pttPort);
+  settings.setValue(&quot;AstroFont&quot;,m_astroFont);
+  settings.setValue(&quot;Xpol&quot;,m_xpol);
+  settings.setValue(&quot;XpolX&quot;,m_xpolx);
+  settings.setValue(&quot;SaveDir&quot;,m_saveDir);
+  settings.setValue(&quot;AzElDir&quot;,m_azelDir);
+  settings.setValue(&quot;DXCCpfx&quot;,m_dxccPfx);
+  settings.setValue(&quot;Timeout&quot;,m_timeout);
+  settings.setValue(&quot;IQamp&quot;,m_IQamp);
+  settings.setValue(&quot;IQphase&quot;,m_IQphase);
+  settings.setValue(&quot;ApplyIQcal&quot;,m_applyIQcal);
+  settings.setValue(&quot;dPhi&quot;,m_dPhi);
+  settings.setValue(&quot;Fcal&quot;,m_fCal);
+  settings.setValue(&quot;Fadd&quot;,m_fAdd);
+  settings.setValue(&quot;NetworkInput&quot;, m_network);
+  settings.setValue(&quot;FSam96000&quot;, m_fs96000);
+  settings.setValue(&quot;SoundInIndex&quot;,m_nDevIn);
+  settings.setValue(&quot;paInDevice&quot;,m_paInDevice);
+  settings.setValue(&quot;SoundOutIndex&quot;,m_nDevOut);
+  settings.setValue(&quot;paOutDevice&quot;,m_paOutDevice);
+  settings.setValue(&quot;IQswap&quot;,m_IQswap);
+  settings.setValue(&quot;Plus10dB&quot;,m_10db);
+  settings.setValue(&quot;InitIQplus&quot;,m_initIQplus);
+  settings.setValue(&quot;UDPport&quot;,m_udpPort);
+  settings.setValue(&quot;PaletteCuteSDR&quot;,ui-&gt;actionCuteSDR-&gt;isChecked());
+  settings.setValue(&quot;PaletteLinrad&quot;,ui-&gt;actionLinrad-&gt;isChecked());
+  settings.setValue(&quot;PaletteAFMHot&quot;,ui-&gt;actionAFMHot-&gt;isChecked());
+  settings.setValue(&quot;PaletteBlue&quot;,ui-&gt;actionBlue-&gt;isChecked());
+  settings.setValue(&quot;Mode&quot;,m_mode);
+  settings.setValue(&quot;SaveNone&quot;,ui-&gt;actionNone-&gt;isChecked());
+  settings.setValue(&quot;SaveAll&quot;,ui-&gt;actionSave_all-&gt;isChecked());
+  settings.setValue(&quot;NDepth&quot;,m_ndepth);
+  settings.setValue(&quot;NEME&quot;,m_onlyEME);
+  settings.setValue(&quot;KB8RQ&quot;,m_kb8rq);
+  settings.setValue(&quot;NB&quot;,m_NB);
+  settings.setValue(&quot;NBslider&quot;,m_NBslider);
+  settings.setValue(&quot;GainX&quot;,(double)m_gainx);
+  settings.setValue(&quot;GainY&quot;,(double)m_gainy);
+  settings.setValue(&quot;PhaseX&quot;,(double)m_phasex);
+  settings.setValue(&quot;PhaseY&quot;,(double)m_phasey);
+  settings.setValue(&quot;Mult570&quot;,m_mult570);
+  settings.setValue(&quot;Cal570&quot;,m_cal570);
+  settings.setValue(&quot;Colors&quot;,m_colors);
+  settings.endGroup();
+}
+
+//---------------------------------------------------------- readSettings()
+void MainWindow::readSettings()
+{
+  QString inifile = m_appDir + &quot;/map65.ini&quot;;
+  QSettings settings(inifile, QSettings::IniFormat);
+  settings.beginGroup(&quot;MainWindow&quot;);
+  restoreGeometry(settings.value(&quot;geometry&quot;).toByteArray());
+  ui-&gt;dxCallEntry-&gt;setText(settings.value(&quot;DXcall&quot;,&quot;&quot;).toString());
+  ui-&gt;dxGridEntry-&gt;setText(settings.value(&quot;DXgrid&quot;,&quot;&quot;).toString());
+
+  m_astroGeom = settings.value(&quot;AstroGeom&quot;, QRect(71,390,227,403)).toRect();
+
+  m_wideGraphGeom = settings.value(&quot;WideGraphGeom&quot;, \
+                                   QRect(45,30,1023,340)).toRect();
+  m_messagesGeom = settings.value(&quot;MessagesGeom&quot;, \
+                                  QRect(800,400,381,400)).toRect();
+  m_bandMapGeom = settings.value(&quot;BandMapGeom&quot;, \
+                                  QRect(280,400,142,400)).toRect();
+  m_path = settings.value(&quot;MRUdir&quot;, m_appDir + &quot;/save&quot;).toString();
+  m_txFirst = settings.value(&quot;TxFirst&quot;,false).toBool();
+  ui-&gt;txFirstCheckBox-&gt;setChecked(m_txFirst);
+  settings.endGroup();
+
+  settings.beginGroup(&quot;Common&quot;);
+  m_myCall=settings.value(&quot;MyCall&quot;,&quot;&quot;).toString();
+  m_myGrid=settings.value(&quot;MyGrid&quot;,&quot;&quot;).toString();
+  m_idInt=settings.value(&quot;IDint&quot;,0).toInt();
+  m_pttPort=settings.value(&quot;PTTport&quot;,0).toInt();
+  m_astroFont=settings.value(&quot;AstroFont&quot;,20).toInt();
+  m_xpol=settings.value(&quot;Xpol&quot;,false).toBool();
+  ui-&gt;actionFind_Delta_Phi-&gt;setEnabled(m_xpol);
+  m_xpolx=settings.value(&quot;XpolX&quot;,false).toBool();
+  m_saveDir=settings.value(&quot;SaveDir&quot;,m_appDir + &quot;/save&quot;).toString();
+  m_azelDir=settings.value(&quot;AzElDir&quot;,m_appDir).toString();
+  m_dxccPfx=settings.value(&quot;DXCCpfx&quot;,&quot;&quot;).toString();
+  m_timeout=settings.value(&quot;Timeout&quot;,20).toInt();
+  m_IQamp=settings.value(&quot;IQamp&quot;,1.0000).toDouble();
+  m_IQphase=settings.value(&quot;IQphase&quot;,0.0).toDouble();
+  m_applyIQcal=settings.value(&quot;ApplyIQcal&quot;,0).toInt();
+  ui-&gt;actionApply_IQ_Calibration-&gt;setChecked(m_applyIQcal!=0);
+  m_dPhi=settings.value(&quot;dPhi&quot;,0).toInt();
+  m_fCal=settings.value(&quot;Fcal&quot;,0).toInt();
+  m_fAdd=settings.value(&quot;FAdd&quot;,0).toDouble();
+  soundInThread.setFadd(m_fAdd);
+  m_network = settings.value(&quot;NetworkInput&quot;,true).toBool();
+  m_fs96000 = settings.value(&quot;FSam96000&quot;,true).toBool();
+  m_nDevIn = settings.value(&quot;SoundInIndex&quot;, 0).toInt();
+  m_paInDevice = settings.value(&quot;paInDevice&quot;,0).toInt();
+  m_nDevOut = settings.value(&quot;SoundOutIndex&quot;, 0).toInt();
+  m_paOutDevice = settings.value(&quot;paOutDevice&quot;,0).toInt();
+  m_IQswap = settings.value(&quot;IQswap&quot;,false).toBool();
+  m_10db = settings.value(&quot;Plus10dB&quot;,false).toBool();
+  m_initIQplus = settings.value(&quot;InitIQplus&quot;,false).toBool();
+  m_udpPort = settings.value(&quot;UDPport&quot;,50004).toInt();
+  soundInThread.setSwapIQ(m_IQswap);
+  soundInThread.set10db(m_10db);
+  soundInThread.setPort(m_udpPort);
+  ui-&gt;actionCuteSDR-&gt;setChecked(settings.value(
+                                  &quot;PaletteCuteSDR&quot;,true).toBool());
+  ui-&gt;actionLinrad-&gt;setChecked(settings.value(
+                                 &quot;PaletteLinrad&quot;,false).toBool());
+  ui-&gt;actionAFMHot-&gt;setChecked(settings.value(
+                                 &quot;PaletteAFMHot&quot;,false).toBool());
+  ui-&gt;actionBlue-&gt;setChecked(settings.value(
+                                 &quot;PaletteBlue&quot;,false).toBool());
+  m_mode=settings.value(&quot;Mode&quot;,&quot;JT65B&quot;).toString();
+  ui-&gt;actionNone-&gt;setChecked(settings.value(&quot;SaveNone&quot;,true).toBool());
+  ui-&gt;actionSave_all-&gt;setChecked(settings.value(&quot;SaveAll&quot;,false).toBool());
+  m_saveAll=ui-&gt;actionSave_all-&gt;isChecked();
+  m_ndepth=settings.value(&quot;NDepth&quot;,0).toInt();
+  m_onlyEME=settings.value(&quot;NEME&quot;,false).toBool();
+  ui-&gt;actionOnly_EME_calls-&gt;setChecked(m_onlyEME);
+  m_kb8rq=settings.value(&quot;KB8RQ&quot;,false).toBool();
+  ui-&gt;actionF4_sets_Tx6-&gt;setChecked(m_kb8rq);
+  m_NB=settings.value(&quot;NB&quot;,false).toBool();
+  ui-&gt;NBcheckBox-&gt;setChecked(m_NB);
+  m_NBslider=settings.value(&quot;NBslider&quot;,40).toInt();
+  ui-&gt;NBslider-&gt;setValue(m_NBslider);
+  m_gainx=settings.value(&quot;GainX&quot;,1.0).toFloat();
+  m_gainy=settings.value(&quot;GainY&quot;,1.0).toFloat();
+  m_phasex=settings.value(&quot;PhaseX&quot;,0.0).toFloat();
+  m_phasey=settings.value(&quot;PhaseY&quot;,0.0).toFloat();
+  m_mult570=settings.value(&quot;Mult570&quot;,2).toInt();
+  m_cal570=settings.value(&quot;Cal570&quot;,0.0).toDouble();
+  m_colors=settings.value(&quot;Colors&quot;,&quot;000066ff0000ffff00969696646464&quot;).toString();
+  settings.endGroup();
+
+  if(!ui-&gt;actionLinrad-&gt;isChecked() &amp;&amp; !ui-&gt;actionCuteSDR-&gt;isChecked() &amp;&amp;
+    !ui-&gt;actionAFMHot-&gt;isChecked() &amp;&amp; !ui-&gt;actionBlue-&gt;isChecked()) {
+    on_actionLinrad_triggered();
+    ui-&gt;actionLinrad-&gt;setChecked(true);
+  }
+  if(m_ndepth==0) ui-&gt;actionNo_Deep_Search-&gt;setChecked(true);
+  if(m_ndepth==1) ui-&gt;actionNormal_Deep_Search-&gt;setChecked(true);
+  if(m_ndepth==2) ui-&gt;actionAggressive_Deep_Search-&gt;setChecked(true);
+}
+
+//-------------------------------------------------------------- dataSink()
+void MainWindow::dataSink(int k)
+{
+  static float s[NFFT],splot[NFFT];
+  static int n=0;
+  static int ihsym=0;
+  static int nzap=0;
+  static int n60z=0;
+  static int nkhz;
+  static int nfsample=96000;
+  static int nxpol=0;
+  static float fgreen;
+  static int ndiskdat;
+  static int nb;
+  static int nadj=0;
+  static float px=0.0,py=0.0;
+  static uchar lstrong[1024];
+  static float rejectx;
+  static float rejecty;
+  static float slimit;
+
+
+  if(m_diskData) {
+    ndiskdat=1;
+    datcom_.ndiskdat=1;
+  } else {
+    ndiskdat=0;
+    datcom_.ndiskdat=0;
+  }
+// Get x and y power, polarized spectrum, nkhz, and ihsym
+  nb=0;
+  if(m_NB) nb=1;
+  nfsample=96000;
+  if(!m_fs96000) nfsample=95238;
+  nxpol=0;
+  if(m_xpol) nxpol=1;
+  fgreen=(float)g_pWideGraph-&gt;fGreen();
+  nadj++;
+  if(m_adjustIQ==0) nadj=0;
+  symspec_(&amp;k, &amp;nxpol, &amp;ndiskdat, &amp;nb, &amp;m_NBslider, &amp;m_dPhi, &amp;nfsample,
+           &amp;fgreen, &amp;m_adjustIQ, &amp;m_applyIQcal, &amp;m_gainx, &amp;m_gainy, &amp;m_phasex,
+           &amp;m_phasey, &amp;rejectx, &amp;rejecty, &amp;px, &amp;py, s, &amp;nkhz,
+           &amp;ihsym, &amp;nzap, &amp;slimit, lstrong);
+  QString t;
+  m_pctZap=nzap/178.3;
+  if(m_xpol) t.sprintf(&quot; Rx noise: %5.1f  %5.1f %5.1f %% &quot;,px,py,m_pctZap);
+  if(!m_xpol) t.sprintf(&quot; Rx noise: %5.1f  %5.1f %% &quot;,px,m_pctZap);
+  lab4-&gt;setText(t);
+  ui-&gt;xThermo-&gt;setValue((double)px);   //Update the bargraphs
+  ui-&gt;yThermo-&gt;setValue((double)py);
+  if(m_monitoring || m_diskData) {
+    g_pWideGraph-&gt;dataSink2(s,nkhz,ihsym,m_diskData,lstrong);
+  }
+
+  if(nadj == 10) {
+    if(m_xpol) {
+      t.sprintf(&quot;Amp: %6.4f %6.4f   Phase: %6.4f %6.4f&quot;,
+                m_gainx,m_gainy,m_phasex,m_phasey);
+    } else {
+      t.sprintf(&quot;Amp: %6.4f   Phase: %6.4f&quot;,m_gainx,m_phasex);
+    }
+    ui-&gt;decodedTextBrowser-&gt;append(t);
+    m_adjustIQ=0;
+  }
+
+  //Average over specified number of spectra
+  if (n==0) {
+    for (int i=0; i&lt;NFFT; i++)
+      splot[i]=s[i];
+  } else {
+    for (int i=0; i&lt;NFFT; i++)
+      splot[i] += s[i];
+  }
+  n++;
+
+  if (n&gt;=m_waterfallAvg) {
+    for (int i=0; i&lt;NFFT; i++) {
+        splot[i] /= n;                           //Normalize the average
+    }
+
+// Time according to this computer
+    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
+    int n60 = (ms/1000) % 60;
+    if((m_diskData &amp;&amp; ihsym &lt;= m_waterfallAvg) || (!m_diskData &amp;&amp; n60&lt;n60z)) {
+      for (int i=0; i&lt;NFFT; i++) {
+        splot[i] = 1.e30;
+      }
+    }
+    n60z=n60;
+    n=0;
+  }
+  if(ihsym == 279) {
+    datcom_.newdat=1;
+    datcom_.nagain=0;
+    QDateTime t = QDateTime::currentDateTimeUtc();
+    m_dateTime=t.toString(&quot;yyyy-MMM-dd hh:mm&quot;);
+    decode();                                           //Start the decoder
+    if(m_saveAll) {
+      QString fname=m_saveDir + &quot;/&quot; + t.date().toString(&quot;yyMMdd&quot;) + &quot;_&quot; +
+          t.time().toString(&quot;hhmm&quot;);
+      if(m_xpol) fname += &quot;.tf2&quot;;
+      if(!m_xpol) fname += &quot;.iq&quot;;
+      *future2 = QtConcurrent::run(savetf2, fname, m_xpol);
+      watcher2-&gt;setFuture(*future2);
+    }
+  }
+  soundInThread.m_dataSinkBusy=false;
+}
+
+void MainWindow::showSoundInError(const QString&amp; errorMsg)
+ {QMessageBox::critical(this, tr(&quot;Error in SoundIn&quot;), errorMsg);}
+
+void MainWindow::showStatusMessage(const QString&amp; statusMsg)
+ {statusBar()-&gt;showMessage(statusMsg);}
+
+void MainWindow::on_actionDeviceSetup_triggered()               //Setup Dialog
+{
+  DevSetup dlg(this);
+  dlg.m_myCall=m_myCall;
+  dlg.m_myGrid=m_myGrid;
+  dlg.m_idInt=m_idInt;
+  dlg.m_pttPort=m_pttPort;
+  dlg.m_astroFont=m_astroFont;
+  dlg.m_xpol=m_xpol;
+  dlg.m_xpolx=m_xpolx;
+  dlg.m_saveDir=m_saveDir;
+  dlg.m_azelDir=m_azelDir;
+  dlg.m_dxccPfx=m_dxccPfx;
+  dlg.m_timeout=m_timeout;
+  dlg.m_dPhi=m_dPhi;
+  dlg.m_fCal=m_fCal;
+  dlg.m_fAdd=m_fAdd;
+  dlg.m_network=m_network;
+  dlg.m_fs96000=m_fs96000;
+  dlg.m_nDevIn=m_nDevIn;
+  dlg.m_nDevOut=m_nDevOut;
+  dlg.m_udpPort=m_udpPort;
+  dlg.m_IQswap=m_IQswap;
+  dlg.m_10db=m_10db;
+  dlg.m_initIQplus=m_initIQplus;
+  dlg.m_cal570=m_cal570;
+  dlg.m_mult570=m_mult570;
+  dlg.m_colors=m_colors;
+
+  dlg.initDlg();
+  if(dlg.exec() == QDialog::Accepted) {
+    m_myCall=dlg.m_myCall;
+    m_myGrid=dlg.m_myGrid;
+    m_idInt=dlg.m_idInt;
+    m_pttPort=dlg.m_pttPort;
+    m_astroFont=dlg.m_astroFont;
+    if(g_pAstro-&gt;isVisible()) g_pAstro-&gt;setFontSize(m_astroFont);
+    m_xpol=dlg.m_xpol;
+    ui-&gt;actionFind_Delta_Phi-&gt;setEnabled(m_xpol);
+    m_xpolx=dlg.m_xpolx;
+    m_saveDir=dlg.m_saveDir;
+    m_azelDir=dlg.m_azelDir;
+    m_dxccPfx=dlg.m_dxccPfx;
+    m_timeout=dlg.m_timeout;
+    m_dPhi=dlg.m_dPhi;
+    m_fCal=dlg.m_fCal;
+    m_fAdd=dlg.m_fAdd;
+    g_pWideGraph-&gt;setFcal(m_fCal);
+    m_fs96000=dlg.m_fs96000;
+    m_network=dlg.m_network;
+    m_nDevIn=dlg.m_nDevIn;
+    m_paInDevice=dlg.m_paInDevice;
+    m_nDevOut=dlg.m_nDevOut;
+    m_paOutDevice=dlg.m_paOutDevice;
+    m_udpPort=dlg.m_udpPort;
+    m_IQswap=dlg.m_IQswap;
+    m_10db=dlg.m_10db;
+    m_initIQplus=dlg.m_initIQplus;
+    m_colors=dlg.m_colors;
+    g_pMessages-&gt;setColors(m_colors);
+    g_pBandMap-&gt;setColors(m_colors);
+    m_cal570=dlg.m_cal570;
+    m_mult570=dlg.m_mult570;
+    g_pWideGraph-&gt;m_mult570=m_mult570;
+    g_pWideGraph-&gt;m_cal570=m_cal570;
+    soundInThread.setSwapIQ(m_IQswap);
+    soundInThread.set10db(m_10db);
+
+    if(dlg.m_restartSoundIn) {
+      soundInThread.quit();
+      soundInThread.wait(1000);
+      soundInThread.setNetwork(m_network);
+      if(m_fs96000) soundInThread.setRate(96000.0);
+      if(!m_fs96000) soundInThread.setRate(95238.1);
+      soundInThread.setFadd(m_fAdd);
+      if(!m_xpol) soundInThread.setNrx(1);
+      if(m_xpol) soundInThread.setNrx(2);
+      soundInThread.setInputDevice(m_paInDevice);
+      soundInThread.start(QThread::HighestPriority);
+    }
+
+    if(dlg.m_restartSoundOut) {
+      soundOutThread.quitExecution=true;
+      soundOutThread.wait(1000);
+      soundOutThread.setOutputDevice(m_paOutDevice);
+//      soundOutThread.start(QThread::HighPriority);
+    }
+  }
+}
+
+void MainWindow::on_monitorButton_clicked()                  //Monitor
+{
+  m_monitoring=true;
+  soundInThread.setMonitoring(true);
+  m_diskData=false;
+}
+void MainWindow::on_actionLinrad_triggered()                 //Linrad palette
+{
+  if(g_pWideGraph != NULL) g_pWideGraph-&gt;setPalette(&quot;Linrad&quot;);
+}
+
+void MainWindow::on_actionCuteSDR_triggered()                //CuteSDR palette
+{
+  if(g_pWideGraph != NULL) g_pWideGraph-&gt;setPalette(&quot;CuteSDR&quot;);
+}
+
+void MainWindow::on_actionAFMHot_triggered()
+{
+  if(g_pWideGraph != NULL) g_pWideGraph-&gt;setPalette(&quot;AFMHot&quot;);
+}
+
+void MainWindow::on_actionBlue_triggered()
+{
+  if(g_pWideGraph != NULL) g_pWideGraph-&gt;setPalette(&quot;Blue&quot;);
+}
+
+void MainWindow::on_actionAbout_triggered()                  //Display &quot;About&quot;
+{
+  CAboutDlg dlg(this,Program_Title_Version);
+  dlg.exec();
+}
+
+void MainWindow::on_autoButton_clicked()                     //Auto
+{
+  m_auto = !m_auto;
+  if(m_auto) {
+    ui-&gt;autoButton-&gt;setStyleSheet(m_pbAutoOn_style);
+    ui-&gt;autoButton-&gt;setText(&quot;Auto is ON&quot;);
+  } else {
+    btxok=false;
+    ui-&gt;autoButton-&gt;setStyleSheet(&quot;&quot;);
+    ui-&gt;autoButton-&gt;setText(&quot;Auto is OFF&quot;);
+    on_monitorButton_clicked();
+  }
+}
+
+void MainWindow::on_stopTxButton_clicked()                    //Stop Tx
+{
+  if(m_auto) on_autoButton_clicked();
+  btxok=false;
+}
+
+void MainWindow::keyPressEvent( QKeyEvent *e )                //keyPressEvent
+{
+  switch(e-&gt;key())
+  {
+  case Qt::Key_F3:
+    m_txMute=!m_txMute;
+    break;
+  case Qt::Key_F4:
+    ui-&gt;dxCallEntry-&gt;setText(&quot;&quot;);
+    ui-&gt;dxGridEntry-&gt;setText(&quot;&quot;);
+    if(m_kb8rq) {
+      m_ntx=6;
+      ui-&gt;txrb6-&gt;setChecked(true);
+    }
+  case Qt::Key_F6:
+    if(e-&gt;modifiers() &amp; Qt::ShiftModifier) {
+      on_actionDecode_remaining_files_in_directory_triggered();
+    }
+    break;
+  case Qt::Key_F11:
+    if(e-&gt;modifiers() &amp; Qt::ShiftModifier) {
+    } else {
+      int n0=g_pWideGraph-&gt;DF();
+      int n=(n0 + 10000) % 5;
+      if(n==0) n=5;
+      g_pWideGraph-&gt;setDF(n0-n);
+    }
+    break;
+  case Qt::Key_F12:
+    if(e-&gt;modifiers() &amp; Qt::ShiftModifier) {
+    } else {
+      int n0=g_pWideGraph-&gt;DF();
+      int n=(n0 + 10000) % 5;
+      if(n==0) n=5;
+      g_pWideGraph-&gt;setDF(n0+n);
+    }
+    break;
+  case Qt::Key_G:
+    if(e-&gt;modifiers() &amp; Qt::AltModifier) {
+      genStdMsgs(&quot;&quot;);
+      break;
+    }
+  case Qt::Key_L:
+    if(e-&gt;modifiers() &amp; Qt::ControlModifier) {
+      lookup();
+      genStdMsgs(&quot;&quot;);
+      break;
+    }
+  }
+}
+
+void MainWindow::bumpDF(int n)                                  //bumpDF()
+{
+  if(n==11) {
+    int n0=g_pWideGraph-&gt;DF();
+    int n=(n0 + 10000) % 5;
+    if(n==0) n=5;
+    g_pWideGraph-&gt;setDF(n0-n);
+  }
+  if(n==12) {
+    int n0=g_pWideGraph-&gt;DF();
+    int n=(n0 + 10000) % 5;
+    if(n==0) n=5;
+    g_pWideGraph-&gt;setDF(n0+n);
+  }
+}
+
+bool MainWindow::eventFilter(QObject *object, QEvent *event)  //eventFilter()
+{
+  if (event-&gt;type() == QEvent::KeyPress) {
+    //Use the event in parent using its keyPressEvent()
+    QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(event);
+    MainWindow::keyPressEvent(keyEvent);
+    return QObject::eventFilter(object, event);
+  }
+  return QObject::eventFilter(object, event);
+}
+
+void MainWindow::createStatusBar()                           //createStatusBar
+{
+  lab1 = new QLabel(&quot;Receiving&quot;);
+  lab1-&gt;setAlignment(Qt::AlignHCenter);
+  lab1-&gt;setMinimumSize(QSize(80,10));
+  lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #00ff00}&quot;);
+  lab1-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
+  statusBar()-&gt;addWidget(lab1);
+
+  lab2 = new QLabel(&quot;QSO freq:  125&quot;);
+  lab2-&gt;setAlignment(Qt::AlignHCenter);
+  lab2-&gt;setMinimumSize(QSize(90,10));
+  lab2-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
+  statusBar()-&gt;addWidget(lab2);
+
+  lab3 = new QLabel(&quot;QSO DF:   0&quot;);
+  lab3-&gt;setAlignment(Qt::AlignHCenter);
+  lab3-&gt;setMinimumSize(QSize(80,10));
+  lab3-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
+  statusBar()-&gt;addWidget(lab3);
+
+  lab4 = new QLabel(&quot;&quot;);
+  lab4-&gt;setAlignment(Qt::AlignHCenter);
+  lab4-&gt;setMinimumSize(QSize(80,10));
+  lab4-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
+  statusBar()-&gt;addWidget(lab4);
+
+  lab5 = new QLabel(&quot;&quot;);
+  lab5-&gt;setAlignment(Qt::AlignHCenter);
+  lab5-&gt;setMinimumSize(QSize(50,10));
+  lab5-&gt;setFrameStyle(QFrame::Panel | QFrame::Sunken);
+  statusBar()-&gt;addWidget(lab5);
+}
+
+void MainWindow::on_tolSpinBox_valueChanged(int i)             //tolSpinBox
+{
+  static int ntol[] = {10,20,50,100,200,500,1000};
+  m_tol=ntol[i];
+  g_pWideGraph-&gt;setTol(m_tol);
+  ui-&gt;labTol1-&gt;setText(QString::number(ntol[i]));
+}
+
+void MainWindow::on_actionExit_triggered()                     //Exit()
+{
+  OnExit();
+}
+
+void MainWindow::closeEvent(QCloseEvent*)
+{
+  OnExit();
+}
+
+void MainWindow::OnExit()
+{
+  g_pWideGraph-&gt;saveSettings();
+  m_killAll=true;
+  mem_m65.detach();
+  QFile quitFile(m_appDir + &quot;/.quit&quot;);
+  quitFile.open(QIODevice::ReadWrite);
+  QFile lockFile(m_appDir + &quot;/.lock&quot;);
+  lockFile.remove();                      // Allow m65 to terminate
+  bool b=proc_m65.waitForFinished(1000);
+  if(!b) proc_m65.kill();
+  quitFile.remove();
+  qApp-&gt;exit(0);                          // Exit the event loop
+}
+
+void MainWindow::on_stopButton_clicked()                       //stopButton
+{
+  m_monitoring=false;
+  soundInThread.setMonitoring(m_monitoring);
+  m_loopall=false;  
+}
+
+void MainWindow::msgBox(QString t)                             //msgBox
+{
+  msgBox0.setText(t);
+  msgBox0.exec();
+}
+
+void MainWindow::stub()                                        //stub()
+{
+  msgBox(&quot;Not yet implemented.&quot;);
+}
+
+void MainWindow::on_actionOnline_Users_Guide_triggered()      //Display manual
+{
+  QDesktopServices::openUrl(QUrl(
+  &quot;<A HREF="http://www.physics.princeton.edu/pulsar/K1JT/MAP65_Beta_Release.pdf">http://www.physics.princeton.edu/pulsar/K1JT/MAP65_Beta_Release.pdf</A>&quot;,
+                              QUrl::TolerantMode));
+}
+
+void MainWindow::on_actionAstro_Data_triggered()             //Display Astro
+{
+  if(g_pAstro==NULL) {
+    g_pAstro = new Astro(0);
+    g_pAstro-&gt;setWindowTitle(&quot;Astronomical Data&quot;);
+    Qt::WindowFlags flags = Qt::Dialog | Qt::WindowCloseButtonHint |
+        Qt::WindowMinimizeButtonHint;
+    g_pAstro-&gt;setWindowFlags(flags);
+    g_pAstro-&gt;setGeometry(m_astroGeom);
+  }
+  g_pAstro-&gt;show();
+}
+
+void MainWindow::on_actionWide_Waterfall_triggered()      //Display Waterfalls
+{
+  if(g_pWideGraph==NULL) {
+    g_pWideGraph = new WideGraph(0);
+    g_pWideGraph-&gt;setWindowTitle(&quot;Wide Graph&quot;);
+    g_pWideGraph-&gt;setGeometry(m_wideGraphGeom);
+    Qt::WindowFlags flags = Qt::WindowCloseButtonHint |
+        Qt::WindowMinimizeButtonHint;
+    g_pWideGraph-&gt;setWindowFlags(flags);
+    connect(g_pWideGraph, SIGNAL(freezeDecode2(int)),this,
+            SLOT(freezeDecode(int)));
+    connect(g_pWideGraph, SIGNAL(f11f12(int)),this,
+            SLOT(bumpDF(int)));
+  }
+  g_pWideGraph-&gt;show();
+}
+
+void MainWindow::on_actionBand_Map_triggered()              //Display BandMap
+{
+  if(g_pBandMap==NULL) {
+    g_pBandMap = new BandMap(0);
+    g_pBandMap-&gt;setWindowTitle(&quot;Band Map&quot;);
+    Qt::WindowFlags flags = Qt::Dialog | Qt::WindowCloseButtonHint |
+        Qt::WindowMinimizeButtonHint;
+    g_pBandMap-&gt;setWindowFlags(flags);
+    g_pBandMap-&gt;setGeometry(m_bandMapGeom);
+  }
+  g_pBandMap-&gt;show();
+}
+
+void MainWindow::on_actionMessages_triggered()              //Display Messages
+{
+  if(g_pMessages==NULL) {
+    g_pMessages = new Messages(0);
+    g_pMessages-&gt;setWindowTitle(&quot;Messages&quot;);
+    Qt::WindowFlags flags = Qt::Dialog | Qt::WindowCloseButtonHint |
+        Qt::WindowMinimizeButtonHint;
+    g_pMessages-&gt;setWindowFlags(flags);
+    g_pMessages-&gt;setGeometry(m_messagesGeom);
+    connect(g_pMessages, SIGNAL(click2OnCallsign(QString, QString)),this,
+            SLOT(doubleClickOnMessages(QString, QString)));
+  }
+  g_pMessages-&gt;show();
+}
+
+void MainWindow::on_actionOpen_triggered()                     //Open File
+{
+  m_monitoring=false;
+  soundInThread.setMonitoring(m_monitoring);
+  QString fname;
+  if(m_xpol) {
+    fname=QFileDialog::getOpenFileName(this, &quot;Open File&quot;, m_path,
+                                       &quot;MAP65 Files (*.tf2)&quot;);
+  } else {
+    fname=QFileDialog::getOpenFileName(this, &quot;Open File&quot;, m_path,
+                                       &quot;MAP65 Files (*.iq)&quot;);
+  }
+  if(fname != &quot;&quot;) {
+    m_path=fname;
+    int i;
+    i=fname.indexOf(&quot;.iq&quot;) - 11;
+    if(m_xpol) i=fname.indexOf(&quot;.tf2&quot;) - 11;
+    if(i&gt;=0) {
+      lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #66ff66}&quot;);
+      lab1-&gt;setText(&quot; &quot; + fname.mid(i,15) + &quot; &quot;);
+    }
+    on_stopButton_clicked();
+    m_diskData=true;
+    int dbDgrd=0;
+    if(m_myCall==&quot;K1JT&quot; and m_idInt&lt;0) dbDgrd=m_idInt;
+    *future1 = QtConcurrent::run(getfile, fname, m_xpol, dbDgrd);
+    watcher1-&gt;setFuture(*future1);
+  }
+}
+
+void MainWindow::on_actionOpen_next_in_directory_triggered()   //Open Next
+{
+  int i,len;
+  QFileInfo fi(m_path);
+  QStringList list;
+  list= fi.dir().entryList().filter(&quot;.iq&quot;);
+  len=14;
+  if(m_xpol) {
+      list= fi.dir().entryList().filter(&quot;.tf2&quot;);
+      len=15;
+  }
+  for (i = 0; i &lt; list.size()-1; ++i) {
+    if(i==list.size()-2) m_loopall=false;
+    if(list.at(i)==m_path.right(len)) {
+      int n=m_path.length();
+      QString fname=m_path.replace(n-len,len,list.at(i+1));
+      m_path=fname;
+      int i;
+      i=fname.indexOf(&quot;.iq&quot;) - 11;
+      if(m_xpol) i=fname.indexOf(&quot;.tf2&quot;) - 11;
+      if(i&gt;=0) {
+        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #66ff66}&quot;);
+        lab1-&gt;setText(&quot; &quot; + fname.mid(i,len) + &quot; &quot;);
+      }
+      m_diskData=true;
+      int dbDgrd=0;
+      if(m_myCall==&quot;K1JT&quot; and m_idInt&lt;0) dbDgrd=m_idInt;
+      *future1 = QtConcurrent::run(getfile, fname, m_xpol, dbDgrd);
+      watcher1-&gt;setFuture(*future1);
+      return;
+    }
+  }
+}
+                                                   //Open all remaining files
+void MainWindow::on_actionDecode_remaining_files_in_directory_triggered()
+{
+  m_loopall=true;
+  on_actionOpen_next_in_directory_triggered();
+}
+
+void MainWindow::diskDat()                                   //diskDat()
+{
+  double hsym;
+  //These may be redundant??
+  m_diskData=true;
+  datcom_.newdat=1;
+
+  if(m_fs96000) hsym=2048.0*96000.0/11025.0;   //Samples per JT65 half-symbol
+  if(!m_fs96000) hsym=2048.0*95238.1/11025.0;
+  for(int i=0; i&lt;281; i++) {              // Do the half-symbol FFTs
+    int k = i*hsym + 2048.5;
+    dataSink(k);
+    if(i%10 == 0) qApp-&gt;processEvents();   //Keep the GUI responsive
+  }
+}
+
+void MainWindow::diskWriteFinished()                       //diskWriteFinished
+{
+//  qDebug() &lt;&lt; &quot;diskWriteFinished&quot;;
+}
+                                                        //Delete ../save/*.tf2
+void MainWindow::on_actionDelete_all_tf2_files_in_SaveDir_triggered()
+{
+  int i;
+  QString fname;
+  int ret = QMessageBox::warning(this, &quot;Confirm Delete&quot;,
+      &quot;Are you sure you want to delete all *.tf2 and *.iq files in\n&quot; +
+       QDir::toNativeSeparators(m_saveDir) + &quot; ?&quot;,
+       QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
+  if(ret==QMessageBox::Yes) {
+    QDir dir(m_saveDir);
+    QStringList files=dir.entryList(QDir::Files);
+    QList&lt;QString&gt;::iterator f;
+    for(f=files.begin(); f!=files.end(); ++f) {
+      fname=*f;
+      i=(fname.indexOf(&quot;.tf2&quot;));
+      if(i==11) dir.remove(fname);
+      i=(fname.indexOf(&quot;.iq&quot;));
+      if(i==11) dir.remove(fname);
+    }
+  }
+}
+                                          //Clear BandMap and Messages windows
+void MainWindow::on_actionErase_Band_Map_and_Messages_triggered()
+{
+  g_pBandMap-&gt;setText(&quot;&quot;);
+  g_pMessages-&gt;setText(&quot;&quot;);
+  m_map65RxLog |= 4;
+}
+
+void MainWindow::on_actionFind_Delta_Phi_triggered()              //Find dPhi
+{
+  m_map65RxLog |= 8;
+  on_DecodeButton_clicked();
+}
+
+void MainWindow::on_actionF4_sets_Tx6_triggered()                //F4 sets Tx6
+{
+  m_kb8rq = !m_kb8rq;
+}
+
+void MainWindow::on_actionOnly_EME_calls_triggered()          //EME calls only
+{
+  m_onlyEME = ui-&gt;actionOnly_EME_calls-&gt;isChecked();
+}
+
+void MainWindow::on_actionNo_shorthands_if_Tx1_triggered()
+{
+  stub();
+}
+
+void MainWindow::on_actionNo_Deep_Search_triggered()          //No Deep Search
+{
+  m_ndepth=0;
+}
+
+void MainWindow::on_actionNormal_Deep_Search_triggered()      //Normal DS
+{
+  m_ndepth=1;
+}
+
+void MainWindow::on_actionAggressive_Deep_Search_triggered()  //Aggressive DS
+{
+  m_ndepth=2;
+}
+
+void MainWindow::on_actionNone_triggered()                    //Save None
+{
+  m_saveAll=false;
+}
+
+// ### Implement &quot;Save Last&quot; here? ###
+
+void MainWindow::on_actionSave_all_triggered()                //Save All
+{
+  m_saveAll=true;
+}
+                                          //Display list of keyboard shortcuts
+void MainWindow::on_actionKeyboard_shortcuts_triggered()
+{
+  stub();
+}
+                                              //Display list of mouse commands
+void MainWindow::on_actionSpecial_mouse_commands_triggered()
+{
+  stub();
+}
+                                              //Diaplay list of Add-On pfx/sfx
+void MainWindow::on_actionAvailable_suffixes_and_add_on_prefixes_triggered()
+{
+  stub();
+}
+
+void MainWindow::on_DecodeButton_clicked()                    //Decode request
+{
+  int n=m_sec0%60;
+  if(m_monitoring and n&gt;47 and (n&lt;52 or m_decoderBusy)) return;
+  if(!m_decoderBusy) {
+    datcom_.newdat=0;
+    datcom_.nagain=1;
+    decode();
+  }
+}
+
+void MainWindow::freezeDecode(int n)                          //freezeDecode()
+{
+  if(n==2) {
+    ui-&gt;tolSpinBox-&gt;setValue(5);
+    datcom_.ntol=m_tol;
+    datcom_.mousedf=0;
+  } else {
+    ui-&gt;tolSpinBox-&gt;setValue(3);
+    datcom_.ntol=m_tol;
+  }
+  if(!m_decoderBusy) {
+    datcom_.nagain=1;
+    datcom_.newdat=0;
+    decode();
+  }
+}
+
+void MainWindow::decode()                                       //decode()
+{
+  ui-&gt;DecodeButton-&gt;setStyleSheet(m_pbdecoding_style1);
+  if(datcom_.nagain==0 &amp;&amp; (!m_diskData)) {
+    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
+    int imin=ms/60000;
+    int ihr=imin/60;
+    imin=imin % 60;
+    datcom_.nutc=100*ihr + imin;
+  }
+
+  datcom_.idphi=m_dPhi;
+  datcom_.mousedf=g_pWideGraph-&gt;DF();
+  datcom_.mousefqso=g_pWideGraph-&gt;QSOfreq();
+  datcom_.ndepth=m_ndepth;
+  datcom_.ndiskdat=0;
+  if(m_diskData) datcom_.ndiskdat=1;
+  datcom_.neme=0;
+  if(ui-&gt;actionOnly_EME_calls-&gt;isChecked()) datcom_.neme=1;
+
+  int ispan=int(g_pWideGraph-&gt;fSpan());
+  if(ispan%2 == 1) ispan++;
+  int ifc=int(1000.0*(datcom_.fcenter - int(datcom_.fcenter))+0.5);
+  int nfa=g_pWideGraph-&gt;nStartFreq();
+  int nfb=nfa+ispan;
+  int nfshift=nfa + ispan/2 - ifc;
+
+  datcom_.nfa=nfa;
+  datcom_.nfb=nfb;
+  datcom_.nfcal=m_fCal;
+  datcom_.nfshift=nfshift;
+  datcom_.mcall3=0;
+  if(m_call3Modified) datcom_.mcall3=1;
+  datcom_.ntimeout=m_timeout;
+  datcom_.ntol=m_tol;
+  datcom_.nxant=0;
+  if(m_xpolx) datcom_.nxant=1;
+  if(datcom_.nutc &lt; m_nutc0) m_map65RxLog |= 1;  //Date and Time to all65.txt
+  m_nutc0=datcom_.nutc;
+  datcom_.map65RxLog=m_map65RxLog;
+  datcom_.nfsample=96000;
+  if(!m_fs96000) datcom_.nfsample=95238;
+  datcom_.nxpol=0;
+  if(m_xpol) datcom_.nxpol=1;
+  datcom_.mode65=m_mode65;
+
+  QString mcall=(m_myCall+&quot;            &quot;).mid(0,12);
+  QString mgrid=(m_myGrid+&quot;            &quot;).mid(0,6);
+  QString hcall=(ui-&gt;dxCallEntry-&gt;text()+&quot;            &quot;).mid(0,12);
+  QString hgrid=(ui-&gt;dxGridEntry-&gt;text()+&quot;      &quot;).mid(0,6);
+
+  strncpy(datcom_.mycall, mcall.toAscii(), 12);
+  strncpy(datcom_.mygrid, mgrid.toAscii(), 6);
+  strncpy(datcom_.hiscall, hcall.toAscii(), 12);
+  strncpy(datcom_.hisgrid, hgrid.toAscii(), 6);
+  strncpy(datcom_.datetime, m_dateTime.toAscii(), 20);
+
+  //newdat=1  ==&gt; this is new data, must do the big FFT
+  //nagain=1  ==&gt; decode only at fQSO +/- Tol
+
+  char *to = (char*)mem_m65.data();
+  char *from = (char*) datcom_.d4;
+  int size=sizeof(datcom_);
+  if(datcom_.newdat==0) {
+    int noffset = 4*4*5760000 + 4*4*322*32768 + 4*4*32768;
+    to += noffset;
+    from += noffset;
+    size -= noffset;
+  }
+  memcpy(to, from, qMin(mem_m65.size(), size));
+  datcom_.nagain=0;
+  datcom_.ndiskdat=0;
+  m_call3Modified=false;
+
+  QFile lockFile(m_appDir + &quot;/.lock&quot;);       // Allow m65 to start
+  lockFile.remove();
+
+  decodeBusy(true);
+}
+
+void MainWindow::m65_error()                                     //m65_error
+{
+  if(!m_killAll) {
+    msgBox(&quot;Error starting or running\n&quot; + m_appDir + &quot;/m65 -s&quot;);
+    exit(1);
+  }
+}
+
+void MainWindow::readFromStderr()                             //readFromStderr
+{
+  QByteArray t=proc_m65.readAllStandardError();
+  msgBox(t);
+}
+
+
+void MainWindow::readFromStdout()                             //readFromStdout
+{
+  while(proc_m65.canReadLine())
+  {
+    QByteArray t=proc_m65.readLine();
+    if(t.indexOf(&quot;&lt;m65aFinished&gt;&quot;) &gt;= 0) {
+      if(m_widebandDecode) {
+        g_pMessages-&gt;setText(m_messagesText);
+        g_pBandMap-&gt;setText(m_bandmapText);
+        m_widebandDecode=false;
+      }
+      QFile lockFile(m_appDir + &quot;/.lock&quot;);
+      lockFile.open(QIODevice::ReadWrite);
+      ui-&gt;DecodeButton-&gt;setStyleSheet(&quot;&quot;);
+      decodeBusy(false);
+      m_map65RxLog=0;
+      m_startAnother=m_loopall;
+      return;
+    }
+
+    if(t.indexOf(&quot;!&quot;) &gt;= 0) {
+      int n=t.length();
+      if(n&gt;=30) ui-&gt;decodedTextBrowser-&gt;append(t.mid(1,n-3));
+      if(n&lt;30) ui-&gt;decodedTextBrowser-&gt;append(t.mid(1,n-3));
+      n=ui-&gt;decodedTextBrowser-&gt;verticalScrollBar()-&gt;maximum();
+      ui-&gt;decodedTextBrowser-&gt;verticalScrollBar()-&gt;setValue(n);
+      m_messagesText=&quot;&quot;;
+      m_bandmapText=&quot;&quot;;
+    }
+
+    if(t.indexOf(&quot;@&quot;) &gt;= 0) {
+      m_messagesText += t.mid(1);
+      m_widebandDecode=true;
+    }
+
+    if(t.indexOf(&quot;&amp;&quot;) &gt;= 0) {
+      QString q(t);
+      QString callsign=q.mid(5);
+      callsign=callsign.mid(0,callsign.indexOf(&quot; &quot;));
+      if(callsign.length()&gt;2) {
+        if(m_worked[callsign]) {
+          q=q.mid(1,4) + &quot;  &quot; + q.mid(5);
+        } else {
+          q=q.mid(1,4) + &quot; *&quot; + q.mid(5);
+        }
+        m_bandmapText += q;
+      }
+    }
+  }
+}
+
+void MainWindow::on_EraseButton_clicked()                          //Erase
+{
+  ui-&gt;decodedTextBrowser-&gt;clear();
+}
+
+void MainWindow::decodeBusy(bool b)                             //decodeBusy()
+{
+  m_decoderBusy=b;
+  ui-&gt;DecodeButton-&gt;setEnabled(!b);
+  ui-&gt;actionOpen-&gt;setEnabled(!b);
+  ui-&gt;actionOpen_next_in_directory-&gt;setEnabled(!b);
+  ui-&gt;actionDecode_remaining_files_in_directory-&gt;setEnabled(!b);
+}
+
+//------------------------------------------------------------- //guiUpdate()
+void MainWindow::guiUpdate()
+{
+  static int iptt0=0;
+  static int iptt=0;
+  static bool btxok0=false;
+  static int nc0=1;
+  static int nc1=1;
+  static char msgsent[23];
+  static int nsendingsh=0;
+  int khsym=0;
+
+  double tx1=0.0;
+  double tx2=126.0*4096.0/11025.0 + 1.8;          //### depend on TxDelay? ###
+
+  if(!m_txFirst) {
+    tx1 += 60.0;
+    tx2 += 60.0;
+  }
+  qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
+  int nsec=ms/1000;
+  double tsec=0.001*ms;
+  double t120=fmod(tsec,120.0);
+  bool bTxTime = t120 &gt;= tx1 &amp;&amp; t120 &lt; tx2;
+
+  if(m_auto) {
+    if(bTxTime and iptt==0 and !m_txMute) {
+      int itx=1;
+      int ierr = ptt_(&amp;m_pttPort,&amp;itx,&amp;iptt);       // Raise PTT
+      if(ierr != 0) {
+        on_stopTxButton_clicked();
+        char s[18];
+        sprintf(s,&quot;Cannot open COM%d&quot;,m_pttPort);
+        msgBox(s);
+      }
+      if(!soundOutThread.isRunning()) {
+        soundOutThread.start(QThread::HighPriority);
+      }
+    }
+    if(!bTxTime || m_txMute) {
+      btxok=false;
+    }
+  }
+
+// Calculate Tx waveform when needed
+  if((iptt==1 &amp;&amp; iptt0==0) || m_restart) {
+    char message[23];
+    QByteArray ba;
+    if(m_ntx == 1) ba=ui-&gt;tx1-&gt;text().toLocal8Bit();
+    if(m_ntx == 2) ba=ui-&gt;tx2-&gt;text().toLocal8Bit();
+    if(m_ntx == 3) ba=ui-&gt;tx3-&gt;text().toLocal8Bit();
+    if(m_ntx == 4) ba=ui-&gt;tx4-&gt;text().toLocal8Bit();
+    if(m_ntx == 5) ba=ui-&gt;tx5-&gt;text().toLocal8Bit();
+    if(m_ntx == 6) ba=ui-&gt;tx6-&gt;text().toLocal8Bit();
+
+    ba2msg(ba,message);
+    int len1=22;
+    int mode65=m_mode65;
+    double samfac=1.0;
+
+    gen65_(message,&amp;mode65,&amp;samfac,&amp;nsendingsh,msgsent,iwave,&amp;nwave,len1,len1);
+    msgsent[22]=0;
+
+    if(m_restart) {
+      QFile f(&quot;map65_tx.log&quot;);
+      f.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Append);
+      QTextStream out(&amp;f);
+      out &lt;&lt; QDateTime::currentDateTimeUtc().toString(&quot;yyyy-MMM-dd hh:mm&quot;)
+          &lt;&lt; &quot;  Tx message:  &quot; &lt;&lt; QString::fromAscii(msgsent) &lt;&lt; endl;
+      f.close();
+    }
+
+    m_restart=false;
+  }
+
+// If PTT was just raised, start a countdown for raising TxOK:
+  if(iptt==1 &amp;&amp; iptt0==0) nc1=-9;    // TxDelay = 0.8 s
+  if(nc1 &lt;= 0) nc1++;
+  if(nc1 == 0) {
+    ui-&gt;xThermo-&gt;setValue(0.0);   //Set the Thermos to zero
+    ui-&gt;yThermo-&gt;setValue(0.0);
+    m_monitoring=false;
+    soundInThread.setMonitoring(false);
+    btxok=true;
+    m_transmitting=true;
+
+    QFile f(&quot;map65_tx.log&quot;);
+    f.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Append);
+    QTextStream out(&amp;f);
+    out &lt;&lt; QDateTime::currentDateTimeUtc().toString(&quot;yyyy-MMM-dd hh:mm&quot;)
+        &lt;&lt; &quot;  Tx message:  &quot; &lt;&lt; QString::fromAscii(msgsent) &lt;&lt; endl;
+    f.close();
+  }
+
+// If btxok was just lowered, start a countdown for lowering PTT
+  if(!btxok &amp;&amp; btxok0 &amp;&amp; iptt==1) nc0=-11;  //RxDelay = 1.0 s
+  if(nc0 &lt;= 0) nc0++;
+  if(nc0 == 0) {
+    int itx=0;
+    ptt_(&amp;m_pttPort,&amp;itx,&amp;iptt);       // Lower PTT
+    if(!m_txMute) soundOutThread.quitExecution=true;
+    m_transmitting=false;
+    if(m_auto) {
+      m_monitoring=true;
+      soundInThread.setMonitoring(m_monitoring);
+    }
+  }
+
+  if(iptt == 0 &amp;&amp; !btxok) {
+    // sending=&quot;&quot;
+    // nsendingsh=0
+  }
+
+  if(m_monitoring) {
+    ui-&gt;monitorButton-&gt;setStyleSheet(m_pbmonitor_style);
+  } else {
+    ui-&gt;monitorButton-&gt;setStyleSheet(&quot;&quot;);
+  }
+
+  lab2-&gt;setText(&quot;QSO Freq:  &quot; + QString::number(g_pWideGraph-&gt;QSOfreq()));
+  lab3-&gt;setText(&quot;QSO DF:  &quot; + QString::number(g_pWideGraph-&gt;DF()));
+
+  if(m_startAnother) {
+    m_startAnother=false;
+    on_actionOpen_next_in_directory_triggered();
+  }
+
+  if(nsec != m_sec0) {                                     //Once per second
+    soundInThread.setForceCenterFreqMHz(g_pWideGraph-&gt;m_dForceCenterFreq);
+    soundInThread.setForceCenterFreqBool(g_pWideGraph-&gt;m_bForceCenterFreq);
+
+    if(m_pctZap&gt;30.0 and !m_transmitting) {
+      lab4-&gt;setStyleSheet(&quot;QLabel{background-color: #ff0000}&quot;);
+    } else {
+      lab4-&gt;setStyleSheet(&quot;&quot;);
+    }
+
+    if(m_transmitting) {
+      if(nsendingsh==1) {
+        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #66ffff}&quot;);
+      } else if(nsendingsh==-1) {
+        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #ffccff}&quot;);
+      } else {
+        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #ffff33}&quot;);
+      }
+      char s[37];
+      sprintf(s,&quot;Tx: %s&quot;,msgsent);
+      lab1-&gt;setText(s);
+    } else if(m_monitoring) {
+      lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #00ff00}&quot;);
+      m_nrx=soundInThread.nrx();
+      khsym=soundInThread.mhsym();
+      QString t;
+      if(m_network) {
+        if(m_nrx==-1) t=&quot;F1&quot;;
+        if(m_nrx==1) t=&quot;I1&quot;;
+        if(m_nrx==-2) t=&quot;F2&quot;;
+        if(m_nrx==+2) t=&quot;I2&quot;;
+      } else {
+        if(m_nrx==1) t=&quot;S1&quot;;
+        if(m_nrx==2) t=&quot;S2&quot;;
+      }
+      if((abs(m_nrx)==1 and m_xpol) or (abs(m_nrx)==2 and !m_xpol))
+        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #ff1493}&quot;);
+      if(khsym==m_hsym0) {
+        t=&quot;Nil&quot;;
+        lab1-&gt;setStyleSheet(&quot;QLabel{background-color: #ffc0cb}&quot;);
+      }
+      lab1-&gt;setText(&quot;Receiving &quot; + t);
+    } else if (!m_diskData) {
+      lab1-&gt;setStyleSheet(&quot;&quot;);
+      lab1-&gt;setText(&quot;&quot;);
+    }
+
+    QDateTime t = QDateTime::currentDateTimeUtc();
+    int fQSO=g_pWideGraph-&gt;QSOfreq();
+    g_pAstro-&gt;astroUpdate(t, m_myGrid, m_hisGrid, fQSO, m_setftx,
+                          m_txFreq, m_azelDir);
+    m_setftx=0;
+    QString utc = &quot; &quot; + t.time().toString() + &quot; &quot;;
+    ui-&gt;labUTC-&gt;setText(utc);
+    if((!m_monitoring and !m_diskData) or (khsym==m_hsym0)) {
+      ui-&gt;xThermo-&gt;setValue(0.0);                      // Set Rx levels to 0
+      ui-&gt;yThermo-&gt;setValue(0.0);
+      lab4-&gt;setText(&quot; Rx noise:    0.0     0.0  0.0% &quot;);
+    }
+    m_hsym0=khsym;
+    m_sec0=nsec;
+  }
+  iptt0=iptt;
+  btxok0=btxok;
+}
+
+void MainWindow::ba2msg(QByteArray ba, char message[])             //ba2msg()
+{
+  bool eom;
+  eom=false;
+  for(int i=0;i&lt;22; i++) {
+    if((int)ba[i] == 0) eom=true;
+    if(eom) {
+      message[i]=32;
+    } else {
+      message[i]=ba[i];
+    }
+  }
+  message[22]=0;
+}
+
+void MainWindow::on_txFirstCheckBox_stateChanged(int nstate)        //TxFirst
+{
+  m_txFirst = (nstate==2);
+}
+
+void MainWindow::set_ntx(int n)                                   //set_ntx()
+{
+  m_ntx=n;
+}
+
+void MainWindow::on_txb1_clicked()                                //txb1
+{
+  m_ntx=1;
+  ui-&gt;txrb1-&gt;setChecked(true);
+  m_restart=true;
+}
+
+void MainWindow::on_txb2_clicked()                                //txb2
+{
+  m_ntx=2;
+  ui-&gt;txrb2-&gt;setChecked(true);
+  m_restart=true;
+}
+
+void MainWindow::on_txb3_clicked()                                //txb3
+{
+  m_ntx=3;
+  ui-&gt;txrb3-&gt;setChecked(true);
+  m_restart=true;
+}
+
+void MainWindow::on_txb4_clicked()                                //txb4
+{
+  m_ntx=4;
+  ui-&gt;txrb4-&gt;setChecked(true);
+  m_restart=true;
+}
+
+void MainWindow::on_txb5_clicked()                                //txb5
+{
+  m_ntx=5;
+  ui-&gt;txrb5-&gt;setChecked(true);
+  m_restart=true;
+}
+
+void MainWindow::on_txb6_clicked()                                //txb6
+{
+  m_ntx=6;
+  ui-&gt;txrb6-&gt;setChecked(true);
+  m_restart=true;
+}
+
+void MainWindow::selectCall2(bool ctrl)                                //selectCall2
+{
+  QString t = ui-&gt;decodedTextBrowser-&gt;toPlainText();   //Full contents
+  int i=ui-&gt;decodedTextBrowser-&gt;textCursor().position();
+  int i0=t.lastIndexOf(&quot; &quot;,i);
+  int i1=t.indexOf(&quot; &quot;,i);
+  QString hiscall=t.mid(i0+1,i1-i0-1);
+  if(hiscall!=&quot;&quot;) {
+    if(hiscall.length() &lt; 13) doubleClickOnCall(hiscall, ctrl);
+  }
+}
+                                                          //doubleClickOnCall
+void MainWindow::doubleClickOnCall(QString hiscall, bool ctrl)
+{
+  if(m_worked[hiscall]) {
+    msgBox(&quot;Possible dupe: &quot; + hiscall + &quot; already in log.&quot;);
+  }
+  ui-&gt;dxCallEntry-&gt;setText(hiscall);
+  QString t = ui-&gt;decodedTextBrowser-&gt;toPlainText();   //Full contents
+  int i2=ui-&gt;decodedTextBrowser-&gt;textCursor().position();
+  QString t1 = t.mid(0,i2);              //contents up to text cursor
+  int i1=t1.lastIndexOf(&quot;\n&quot;) + 1;
+  QString t2 = t1.mid(i1,i2-i1);         //selected line
+  int n = 60*t2.mid(13,2).toInt() + t2.mid(15,2).toInt();
+  m_txFirst = ((n%2) == 1);
+  ui-&gt;txFirstCheckBox-&gt;setChecked(m_txFirst);
+  QString rpt=&quot;&quot;;
+  if(ctrl) rpt=t2.mid(23,3);
+  lookup();
+  genStdMsgs(rpt);
+  if(t2.indexOf(m_myCall)&gt;0) {
+    m_ntx=2;
+    ui-&gt;txrb2-&gt;setChecked(true);
+  } else {
+    m_ntx=1;
+    ui-&gt;txrb1-&gt;setChecked(true);
+  }
+}
+                                                      //doubleClickOnMessages
+void MainWindow::doubleClickOnMessages(QString hiscall, QString t2)
+{
+  if(m_worked[hiscall]) {
+    msgBox(&quot;Possible dupe: &quot; + hiscall + &quot; already in log.&quot;);
+  }
+  ui-&gt;dxCallEntry-&gt;setText(hiscall);
+  int n = 60*t2.mid(13,2).toInt() + t2.mid(15,2).toInt();
+  m_txFirst = ((n%2) == 1);
+  ui-&gt;txFirstCheckBox-&gt;setChecked(m_txFirst);
+  lookup();
+  genStdMsgs(&quot;&quot;);
+  if(t2.indexOf(m_myCall)&gt;0) {
+    m_ntx=2;
+    ui-&gt;txrb2-&gt;setChecked(true);
+  } else {
+    m_ntx=1;
+    ui-&gt;txrb1-&gt;setChecked(true);
+  }
+}
+
+void MainWindow::genStdMsgs(QString rpt)                       //genStdMsgs()
+{
+  QString hiscall=ui-&gt;dxCallEntry-&gt;text().toUpper().trimmed();
+  ui-&gt;dxCallEntry-&gt;setText(hiscall);
+  QString t0=hiscall + &quot; &quot; + m_myCall + &quot; &quot;;
+  QString t=t0 + m_myGrid.mid(0,4);
+  msgtype(t, ui-&gt;tx1);
+  if(rpt == &quot;&quot;) {
+    t=t+&quot; OOO&quot;;
+    msgtype(t, ui-&gt;tx2);
+    msgtype(&quot;RO&quot;, ui-&gt;tx3);
+    msgtype(&quot;RRR&quot;, ui-&gt;tx4);
+    msgtype(&quot;73&quot;, ui-&gt;tx5);
+  } else {
+    t=t0 + rpt;
+    msgtype(t, ui-&gt;tx2);
+    t=t0 + &quot;R&quot; + rpt;
+    msgtype(t, ui-&gt;tx3);
+    t=t0 + &quot;RRR&quot;;
+    msgtype(t, ui-&gt;tx4);
+    t=t0 + &quot;73&quot;;
+    msgtype(t, ui-&gt;tx5);
+  }
+  t=&quot;CQ &quot; + m_myCall + &quot; &quot; + m_myGrid.mid(0,4);
+  msgtype(t, ui-&gt;tx6);
+  m_ntx=1;
+  ui-&gt;txrb1-&gt;setChecked(true);
+}
+
+void MainWindow::lookup()                                       //lookup()
+{
+  QString hiscall=ui-&gt;dxCallEntry-&gt;text().toUpper().trimmed();
+  ui-&gt;dxCallEntry-&gt;setText(hiscall);
+  QString call3File = m_appDir + &quot;/CALL3.TXT&quot;;
+  QFile f(call3File);
+  if(!f.open(QIODevice::ReadOnly | QIODevice::Text)) {
+    msgBox(&quot;Cannot open &quot; + call3File);
+    return;
+  }
+  char c[132];
+  qint64 n=0;
+  for(int i=0; i&lt;999999; i++) {
+    n=f.readLine(c,sizeof(c));
+    if(n &lt;= 0) {
+      ui-&gt;dxGridEntry-&gt;setText(&quot;&quot;);
+      break;
+     }
+    QString t=QString(c);
+    if(t.indexOf(hiscall)==0) {
+      int i1=t.indexOf(&quot;,&quot;);
+      QString hisgrid=t.mid(i1+1,6);
+      i1=hisgrid.indexOf(&quot;,&quot;);
+      if(i1&gt;0) {
+        hisgrid=hisgrid.mid(0,4);
+      } else {
+        hisgrid=hisgrid.mid(0,4) + hisgrid.mid(4,2).toLower();
+      }
+      ui-&gt;dxGridEntry-&gt;setText(hisgrid);
+      break;
+    }
+  }
+  f.close();
+}
+
+void MainWindow::on_lookupButton_clicked()                    //Lookup button
+{
+  lookup();
+}
+
+void MainWindow::on_addButton_clicked()                       //Add button
+{
+  if(ui-&gt;dxGridEntry-&gt;text()==&quot;&quot;) {
+    msgBox(&quot;Please enter a valid grid locator.&quot;);
+    return;
+  }
+  m_call3Modified=false;
+  QString hiscall=ui-&gt;dxCallEntry-&gt;text().toUpper().trimmed();
+  QString hisgrid=ui-&gt;dxGridEntry-&gt;text().trimmed();
+  QString newEntry=hiscall + &quot;,&quot; + hisgrid;
+
+  int ret = QMessageBox::warning(this, &quot;Add&quot;,
+       newEntry + &quot;\n&quot; + &quot;Is this station known to be active on EME?&quot;,
+       QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
+  if(ret==QMessageBox::Yes) {
+    newEntry += &quot;,EME,,&quot;;
+  } else {
+    newEntry += &quot;,,,&quot;;
+  }
+  QString call3File = m_appDir + &quot;/CALL3.TXT&quot;;
+  QFile f1(call3File);
+  if(!f1.open(QIODevice::ReadOnly | QIODevice::Text)) {
+    msgBox(&quot;Cannot open &quot; + call3File);
+    return;
+  }
+  QString tmpFile = m_appDir + &quot;/CALL3.TMP&quot;;
+  QFile f2(tmpFile);
+  if(!f2.open(QIODevice::WriteOnly | QIODevice::Text)) {
+    msgBox(&quot;Cannot open &quot; + tmpFile);
+    return;
+  }
+  QTextStream in(&amp;f1);
+  QTextStream out(&amp;f2);
+  QString hc=hiscall;
+  QString hc1=&quot;&quot;;
+  QString hc2=&quot;&quot;;
+  QString s;
+  do {
+    s=in.readLine();
+    hc1=hc2;
+    if(s.mid(0,2)==&quot;//&quot;) {
+      out &lt;&lt; s + &quot;\n&quot;;
+    } else {
+      int i1=s.indexOf(&quot;,&quot;);
+      hc2=s.mid(0,i1);
+      if(hc&gt;hc1 &amp;&amp; hc&lt;hc2) {
+        out &lt;&lt; newEntry + &quot;\n&quot;;
+        m_call3Modified=true;
+      } else if(hc==hc2) {
+        QString t=s + &quot;\n\n is already in CALL3.TXT\n&quot; +
+            &quot;Do you wish to replace it?&quot;;
+        int ret = QMessageBox::warning(this, &quot;Add&quot;,t,
+             QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
+        if(ret==QMessageBox::Yes) {
+          out &lt;&lt; newEntry + &quot;\n&quot;;
+          m_call3Modified=true;
+        }
+      } else {
+        out &lt;&lt; s + &quot;\n&quot;;
+      }
+    }
+  } while(!s.isNull());
+
+  f1.close();
+  if(hc&gt;hc1 &amp;&amp; !m_call3Modified)
+    out &lt;&lt; newEntry + &quot;\n&quot;;
+  if(m_call3Modified) {
+    QFile f0(m_appDir + &quot;/CALL3.OLD&quot;);
+    if(f0.exists()) f0.remove();
+    QFile f1(m_appDir + &quot;/CALL3.TXT&quot;);
+    f1.rename(m_appDir + &quot;/CALL3.OLD&quot;);
+    f2.rename(m_appDir + &quot;/CALL3.TXT&quot;);
+    f2.close();
+  }
+}
+
+void MainWindow::msgtype(QString t, QLineEdit* tx)                //msgtype()
+{
+//  if(t.length()&lt;1) return 0;
+  char message[23];
+  char msgsent[23];
+  int len1=22;
+  int mode65=0;            //mode65 ==&gt; check message but don't make wave()
+  double samfac=1.0;
+  int nsendingsh=0;
+  int mwave;
+  t=t.toUpper();
+  int i1=t.indexOf(&quot; OOO&quot;);
+  QByteArray s=t.toUpper().toLocal8Bit();
+  ba2msg(s,message);
+  gen65_(message,&amp;mode65,&amp;samfac,&amp;nsendingsh,msgsent,iwave,&amp;mwave,len1,len1);
+
+  QPalette p(tx-&gt;palette());
+  if(nsendingsh==1) {
+    p.setColor(QPalette::Base,&quot;#66ffff&quot;);
+  } else if(nsendingsh==-1) {
+    p.setColor(QPalette::Base,&quot;#ffccff&quot;);
+  } else {
+    p.setColor(QPalette::Base,Qt::white);
+  }
+  tx-&gt;setPalette(p);
+  int len=t.length();
+  if(nsendingsh==-1) {
+    len=qMin(len,13);
+    if(i1&gt;10) {
+      tx-&gt;setText(t.mid(0,len).toUpper() + &quot; OOO&quot;);
+    } else {
+      tx-&gt;setText(t.mid(0,len).toUpper());
+    }
+  } else {
+    tx-&gt;setText(t);
+  }
+}
+
+void MainWindow::on_tx1_editingFinished()                       //tx1 edited
+{
+  QString t=ui-&gt;tx1-&gt;text();
+  msgtype(t, ui-&gt;tx1);
+}
+
+void MainWindow::on_tx2_editingFinished()                       //tx2 edited
+{
+  QString t=ui-&gt;tx2-&gt;text();
+  msgtype(t, ui-&gt;tx2);
+}
+
+void MainWindow::on_tx3_editingFinished()                       //tx3 edited
+{
+  QString t=ui-&gt;tx3-&gt;text();
+  msgtype(t, ui-&gt;tx3);
+}
+
+void MainWindow::on_tx4_editingFinished()                       //tx4 edited
+{
+  QString t=ui-&gt;tx4-&gt;text();
+  msgtype(t, ui-&gt;tx4);
+}
+
+void MainWindow::on_tx5_editingFinished()                       //tx5 edited
+{
+  QString t=ui-&gt;tx5-&gt;text();
+  msgtype(t, ui-&gt;tx5);
+}
+
+void MainWindow::on_tx6_editingFinished()                       //tx6 edited
+{
+  QString t=ui-&gt;tx6-&gt;text();
+  msgtype(t, ui-&gt;tx6);
+}
+
+void MainWindow::on_setTxFreqButton_clicked()                  //Set Tx Freq
+{
+  m_setftx=1;
+  m_txFreq=g_pWideGraph-&gt;QSOfreq();
+}
+
+void MainWindow::on_dxCallEntry_textChanged(const QString &amp;t) //dxCall changed
+{
+  m_hisCall=t.toUpper().trimmed();
+  ui-&gt;dxCallEntry-&gt;setText(m_hisCall);
+}
+
+void MainWindow::on_dxGridEntry_textChanged(const QString &amp;t) //dxGrid changed
+{
+  int n=t.length();
+  if(n!=4 and n!=6) return;
+  if(!t[0].isLetter() or !t[1].isLetter()) return;
+  if(!t[2].isDigit() or !t[3].isDigit()) return;
+  if(n==4) m_hisGrid=t.mid(0,2).toUpper() + t.mid(2,2);
+  if(n==6) m_hisGrid=t.mid(0,2).toUpper() + t.mid(2,2) +
+      t.mid(4,2).toLower();
+  ui-&gt;dxGridEntry-&gt;setText(m_hisGrid);
+}
+
+void MainWindow::on_genStdMsgsPushButton_clicked()         //genStdMsgs button
+{
+  genStdMsgs(&quot;&quot;);
+}
+
+void MainWindow::on_logQSOButton_clicked()                 //Log QSO button
+{
+  int nMHz=int(datcom_.fcenter);
+  QDateTime t = QDateTime::currentDateTimeUtc();
+  QString logEntry=t.date().toString(&quot;yyyy-MMM-dd,&quot;) +
+      t.time().toString(&quot;hh:mm,&quot;) + m_hisCall + &quot;,&quot; + m_hisGrid + &quot;,&quot; +
+      QString::number(nMHz) + &quot;,JT65B\n&quot;;
+  QFile f(&quot;wsjt.log&quot;);
+  if(!f.open(QFile::Append)) {
+    msgBox(&quot;Cannot open file \&quot;wsjt.log\&quot;.&quot;);
+    return;
+  }
+  QTextStream out(&amp;f);
+  out &lt;&lt; logEntry;
+  f.close();
+  m_worked[m_hisCall]=true;
+}
+
+void MainWindow::on_actionErase_map65_rx_log_triggered()     //Erase Rx log
+{
+  int ret = QMessageBox::warning(this, &quot;Confirm Erase&quot;,
+      &quot;Are you sure you want to erase file map65_rx.log ?&quot;,
+       QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
+  if(ret==QMessageBox::Yes) {
+    m_map65RxLog |= 2;                      // Rewind map65_rx.log
+  }
+}
+
+void MainWindow::on_actionErase_map65_tx_log_triggered()     //Erase Tx log
+{
+  int ret = QMessageBox::warning(this, &quot;Confirm Erase&quot;,
+      &quot;Are you sure you want to erase file map65_tx.log ?&quot;,
+       QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
+  if(ret==QMessageBox::Yes) {
+    QFile f(&quot;map65_tx.log&quot;);
+    f.remove();
+  }
+}
+
+void MainWindow::on_actionJT65A_triggered()
+{
+  m_mode=&quot;JT65A&quot;;
+  m_mode65=1;
+  g_pWideGraph-&gt;setMode65(m_mode65);
+  lab5-&gt;setText(m_mode);
+  ui-&gt;actionJT65A-&gt;setChecked(true);
+}
+
+void MainWindow::on_actionJT65B_triggered()
+{
+  m_mode=&quot;JT65B&quot;;
+  m_mode65=2;
+  g_pWideGraph-&gt;setMode65(m_mode65);
+  lab5-&gt;setText(m_mode);
+  ui-&gt;actionJT65B-&gt;setChecked(true);
+}
+
+void MainWindow::on_actionJT65C_triggered()
+{
+  m_mode=&quot;JT65C&quot;;
+  m_mode65=4;
+  g_pWideGraph-&gt;setMode65(m_mode65);
+  lab5-&gt;setText(m_mode);
+  ui-&gt;actionJT65C-&gt;setChecked(true);
+}
+
+void MainWindow::on_NBcheckBox_toggled(bool checked)
+{
+  m_NB=checked;
+  ui-&gt;NBslider-&gt;setEnabled(m_NB);
+}
+
+void MainWindow::on_NBslider_valueChanged(int n)
+{
+  m_NBslider=n;
+}
+
+void MainWindow::on_actionAdjust_IQ_Calibration_triggered()
+{
+  m_adjustIQ=1;
+}
+
+void MainWindow::on_actionApply_IQ_Calibration_triggered()
+{
+  m_applyIQcal= 1-m_applyIQcal;
+}
+
+void MainWindow::on_actionFUNcube_Dongle_triggered()
+{
+  proc_qthid.start(QDir::toNativeSeparators(m_appDir + &quot;/qthid&quot;));
+}


Property changes on: branches/map65/mainwindow.cpp
___________________________________________________________________
Added: svn:keywords
   + Rev
Added: svn:eol-style
   + native

Modified: branches/map65/mainwindow.h
===================================================================
--- branches/map65/mainwindow.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/mainwindow.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,274 +1,274 @@
-#ifndef MAINWINDOW_H
-#define MAINWINDOW_H
-#include &lt;QtGui&gt;
-#include &lt;QLabel&gt;
-#include &lt;QTimer&gt;
-#include &lt;QDateTime&gt;
-#include &lt;QHash&gt;
-#include &quot;soundin.h&quot;
-#include &quot;soundout.h&quot;
-#include &quot;commons.h&quot;
-#include &quot;sleep.h&quot;
-
-#define NFFT 32768
-#define NSMAX 5760000
-
-//--------------------------------------------------------------- MainWindow
-namespace Ui {
-    class MainWindow;
-}
-
-class MainWindow : public QMainWindow
-{
-  Q_OBJECT
-
-public:
-  explicit MainWindow(QWidget *parent = 0);
-  ~MainWindow();
-  bool m_network;
-
-public slots:
-  void showSoundInError(const QString&amp; errorMsg);
-  void showStatusMessage(const QString&amp; statusMsg);
-  void dataSink(int k);
-  void diskDat();
-  void diskWriteFinished();
-  void freezeDecode(int n);
-  void readFromStdout();
-  void readFromStderr();
-  void m65_error();
-  void guiUpdate();
-  void doubleClickOnCall(QString hiscall, bool ctrl);
-  void doubleClickOnMessages(QString hiscall, QString t2);
-
-protected:
-  virtual void keyPressEvent( QKeyEvent *e );
-  void  closeEvent(QCloseEvent*);
-  virtual bool eventFilter(QObject *object, QEvent *event);
-
-private slots:
-  void on_tx1_editingFinished();
-  void on_tx2_editingFinished();
-  void on_tx3_editingFinished();
-  void on_tx4_editingFinished();
-  void on_tx5_editingFinished();
-  void on_tx6_editingFinished();
-  void on_actionDeviceSetup_triggered();
-  void on_monitorButton_clicked();
-  void on_actionExit_triggered();
-  void on_actionAbout_triggered();
-  void OnExit();
-  void on_actionLinrad_triggered();
-  void on_actionCuteSDR_triggered();
-  void on_autoButton_clicked();
-  void on_stopTxButton_clicked();
-  void on_tolSpinBox_valueChanged(int arg1);
-  void on_actionAstro_Data_triggered();
-  void on_stopButton_clicked();
-  void on_actionOnline_Users_Guide_triggered();
-  void on_actionWide_Waterfall_triggered();
-  void on_actionBand_Map_triggered();
-  void on_actionMessages_triggered();
-  void on_actionOpen_triggered();
-  void on_actionOpen_next_in_directory_triggered();
-  void on_actionDecode_remaining_files_in_directory_triggered();
-  void on_actionDelete_all_tf2_files_in_SaveDir_triggered();
-  void on_actionErase_Band_Map_and_Messages_triggered();
-  void on_actionFind_Delta_Phi_triggered();
-  void on_actionF4_sets_Tx6_triggered();
-  void on_actionOnly_EME_calls_triggered();
-  void on_actionNo_shorthands_if_Tx1_triggered();
-  void on_actionNo_Deep_Search_triggered();
-  void on_actionNormal_Deep_Search_triggered();
-  void on_actionAggressive_Deep_Search_triggered();
-  void on_actionNone_triggered();
-  void on_actionSave_all_triggered();
-  void on_actionKeyboard_shortcuts_triggered();
-  void on_actionSpecial_mouse_commands_triggered();
-  void on_actionAvailable_suffixes_and_add_on_prefixes_triggered();
-  void on_DecodeButton_clicked();
-  void decode();
-  void decodeBusy(bool b);
-  void on_EraseButton_clicked();
-  void on_txb1_clicked();
-  void on_txFirstCheckBox_stateChanged(int arg1);
-  void set_ntx(int n);
-  void on_txb2_clicked();
-  void on_txb3_clicked();
-  void on_txb4_clicked();
-  void on_txb5_clicked();
-  void on_txb6_clicked();
-  void on_lookupButton_clicked();
-  void on_addButton_clicked();
-  void on_setTxFreqButton_clicked();
-  void on_dxCallEntry_textChanged(const QString &amp;arg1);
-  void on_dxGridEntry_textChanged(const QString &amp;arg1);
-  void selectCall2(bool ctrl);
-  void on_genStdMsgsPushButton_clicked();
-  void bumpDF(int n);
-  void on_logQSOButton_clicked();
-  void on_actionErase_map65_rx_log_triggered();
-  void on_actionErase_map65_tx_log_triggered();
-  void on_NBcheckBox_toggled(bool checked);
-  void on_actionJT65A_triggered();
-  void on_actionJT65B_triggered();
-  void on_actionJT65C_triggered();
-  void on_NBslider_valueChanged(int value);
-  void on_actionAdjust_IQ_Calibration_triggered();
-  void on_actionApply_IQ_Calibration_triggered();
-
-  void on_actionAFMHot_triggered();
-
-  void on_actionBlue_triggered();
-
-  void on_actionFUNcube_Dongle_triggered();
-
-private:
-    Ui::MainWindow *ui;
-    qint32  m_nDevIn;
-    qint32  m_nDevOut;
-    qint32  m_idInt;
-    qint32  m_waterfallAvg;
-    qint32  m_DF;
-    qint32  m_tol;
-    qint32  m_QSOfreq0;
-    qint32  m_ntx;
-    qint32  m_pttPort;
-    qint32  m_astroFont;
-    qint32  m_timeout;
-    qint32  m_dPhi;
-    qint32  m_fCal;
-    qint32  m_txFreq;
-    qint32  m_setftx;
-    qint32  m_ndepth;
-    qint32  m_sec0;
-    qint32  m_map65RxLog;
-    qint32  m_nutc0;
-    qint32  m_mode65;
-    qint32  m_nrx;
-    qint32  m_hsym0;
-    qint32  m_paInDevice;
-    qint32  m_paOutDevice;
-    qint32  m_udpPort;
-    qint32  m_NBslider;
-    qint32  m_adjustIQ;
-    qint32  m_applyIQcal;
-    qint32  m_mult570;
-
-    double  m_fAdd;
-    double  m_IQamp;
-    double  m_IQphase;
-    double  m_cal570;
-
-    bool    m_monitoring;
-    bool    m_transmitting;
-    bool    m_diskData;
-    bool    m_loopall;
-    bool    m_decoderBusy;
-    bool    m_txFirst;
-    bool    m_auto;
-    bool    m_txMute;
-    bool    m_restart;
-    bool    m_killAll;
-    bool    m_xpol;
-    bool    m_xpolx;
-    bool    m_call3Modified;
-    bool    m_startAnother;
-    bool    m_saveAll;
-    bool    m_onlyEME;
-    bool    m_widebandDecode;
-    bool    m_kb8rq;
-    bool    m_NB;
-    bool    m_fs96000;
-    bool    m_IQswap;
-    bool    m_10db;
-    bool    m_initIQplus;
-
-    float   m_gainx;
-    float   m_gainy;
-    float   m_phasex;
-    float   m_phasey;
-    float   m_pctZap;
-
-    QRect   m_astroGeom;
-    QRect   m_wideGraphGeom;
-    QRect   m_messagesGeom;
-    QRect   m_bandMapGeom;
-
-    QLabel* lab1;                            // labels in status bar
-    QLabel* lab2;
-    QLabel* lab3;
-    QLabel* lab4;
-    QLabel* lab5;
-    QLabel* lab6;
-
-    QMessageBox msgBox0;
-
-    QFuture&lt;void&gt;* future1;
-    QFuture&lt;void&gt;* future2;
-    QFutureWatcher&lt;void&gt;* watcher1;
-    QFutureWatcher&lt;void&gt;* watcher2;
-
-    QProcess proc_m65;
-    QProcess proc_qthid;
-
-    QString m_path;
-    QString m_pbdecoding_style1;
-    QString m_pbmonitor_style;
-    QString m_pbAutoOn_style;
-    QString m_messagesText;
-    QString m_bandmapText;
-    QString m_myCall;
-    QString m_myGrid;
-    QString m_hisCall;
-    QString m_hisGrid;
-    QString m_appDir;
-    QString m_saveDir;
-    QString m_azelDir;
-    QString m_dxccPfx;
-    QString m_palette;
-    QString m_dateTime;
-    QString m_mode;
-    QString m_colors;
-
-    QHash&lt;QString,bool&gt; m_worked;
-
-    SoundInThread soundInThread;             //Instantiate the audio threads
-    SoundOutThread soundOutThread;
-
-//---------------------------------------------------- private functions
-    void readSettings();
-    void writeSettings();
-    void createStatusBar();
-    void updateStatusBar();
-    void msgBox(QString t);
-    void genStdMsgs(QString rpt);
-    void lookup();
-    void ba2msg(QByteArray ba, char* message);
-    void msgtype(QString t, QLineEdit* tx);
-    void stub();
-};
-
-extern void getfile(QString fname, bool xpol, int idInt);
-extern void savetf2(QString fname, bool xpol);
-extern int killbyname(const char* progName);
-extern void getDev(int* numDevices,char hostAPI_DeviceName[][50],
-                   int minChan[], int maxChan[],
-                   int minSpeed[], int maxSpeed[]);
-
-extern &quot;C&quot; {
-//----------------------------------------------------- C and Fortran routines
-  void symspec_(int* k, int* nxpol, int* ndiskdat, int* nb, int* m_NBslider,
-                int* idphi, int* nfsample, float* fgreen, int* iqadjust,
-                int* iqapply, float* gainx, float* gainy, float* phasex,
-                float* phasey, float* rejectx, float* rejecty, float* px,
-                float* py, float s[], int* nkhz, int* nhsym, int* nzap,
-                float* slimit, uchar lstrong[]);
-
-  void gen65_(char* msg, int* mode65, double* samfac, int* nsendingsh,
-              char* msgsent, short iwave[], int* nwave, int len1, int len2);
-
-  int ptt_(int* nport, int* itx, int* iptt);
-  }
-
-#endif // MAINWINDOW_H
+#ifndef MAINWINDOW_H
+#define MAINWINDOW_H
+#include &lt;QtGui&gt;
+#include &lt;QLabel&gt;
+#include &lt;QTimer&gt;
+#include &lt;QDateTime&gt;
+#include &lt;QHash&gt;
+#include &quot;soundin.h&quot;
+#include &quot;soundout.h&quot;
+#include &quot;commons.h&quot;
+#include &quot;sleep.h&quot;
+
+#define NFFT 32768
+#define NSMAX 5760000
+
+//--------------------------------------------------------------- MainWindow
+namespace Ui {
+    class MainWindow;
+}
+
+class MainWindow : public QMainWindow
+{
+  Q_OBJECT
+
+public:
+  explicit MainWindow(QWidget *parent = 0);
+  ~MainWindow();
+  bool m_network;
+
+public slots:
+  void showSoundInError(const QString&amp; errorMsg);
+  void showStatusMessage(const QString&amp; statusMsg);
+  void dataSink(int k);
+  void diskDat();
+  void diskWriteFinished();
+  void freezeDecode(int n);
+  void readFromStdout();
+  void readFromStderr();
+  void m65_error();
+  void guiUpdate();
+  void doubleClickOnCall(QString hiscall, bool ctrl);
+  void doubleClickOnMessages(QString hiscall, QString t2);
+
+protected:
+  virtual void keyPressEvent( QKeyEvent *e );
+  void  closeEvent(QCloseEvent*);
+  virtual bool eventFilter(QObject *object, QEvent *event);
+
+private slots:
+  void on_tx1_editingFinished();
+  void on_tx2_editingFinished();
+  void on_tx3_editingFinished();
+  void on_tx4_editingFinished();
+  void on_tx5_editingFinished();
+  void on_tx6_editingFinished();
+  void on_actionDeviceSetup_triggered();
+  void on_monitorButton_clicked();
+  void on_actionExit_triggered();
+  void on_actionAbout_triggered();
+  void OnExit();
+  void on_actionLinrad_triggered();
+  void on_actionCuteSDR_triggered();
+  void on_autoButton_clicked();
+  void on_stopTxButton_clicked();
+  void on_tolSpinBox_valueChanged(int arg1);
+  void on_actionAstro_Data_triggered();
+  void on_stopButton_clicked();
+  void on_actionOnline_Users_Guide_triggered();
+  void on_actionWide_Waterfall_triggered();
+  void on_actionBand_Map_triggered();
+  void on_actionMessages_triggered();
+  void on_actionOpen_triggered();
+  void on_actionOpen_next_in_directory_triggered();
+  void on_actionDecode_remaining_files_in_directory_triggered();
+  void on_actionDelete_all_tf2_files_in_SaveDir_triggered();
+  void on_actionErase_Band_Map_and_Messages_triggered();
+  void on_actionFind_Delta_Phi_triggered();
+  void on_actionF4_sets_Tx6_triggered();
+  void on_actionOnly_EME_calls_triggered();
+  void on_actionNo_shorthands_if_Tx1_triggered();
+  void on_actionNo_Deep_Search_triggered();
+  void on_actionNormal_Deep_Search_triggered();
+  void on_actionAggressive_Deep_Search_triggered();
+  void on_actionNone_triggered();
+  void on_actionSave_all_triggered();
+  void on_actionKeyboard_shortcuts_triggered();
+  void on_actionSpecial_mouse_commands_triggered();
+  void on_actionAvailable_suffixes_and_add_on_prefixes_triggered();
+  void on_DecodeButton_clicked();
+  void decode();
+  void decodeBusy(bool b);
+  void on_EraseButton_clicked();
+  void on_txb1_clicked();
+  void on_txFirstCheckBox_stateChanged(int arg1);
+  void set_ntx(int n);
+  void on_txb2_clicked();
+  void on_txb3_clicked();
+  void on_txb4_clicked();
+  void on_txb5_clicked();
+  void on_txb6_clicked();
+  void on_lookupButton_clicked();
+  void on_addButton_clicked();
+  void on_setTxFreqButton_clicked();
+  void on_dxCallEntry_textChanged(const QString &amp;arg1);
+  void on_dxGridEntry_textChanged(const QString &amp;arg1);
+  void selectCall2(bool ctrl);
+  void on_genStdMsgsPushButton_clicked();
+  void bumpDF(int n);
+  void on_logQSOButton_clicked();
+  void on_actionErase_map65_rx_log_triggered();
+  void on_actionErase_map65_tx_log_triggered();
+  void on_NBcheckBox_toggled(bool checked);
+  void on_actionJT65A_triggered();
+  void on_actionJT65B_triggered();
+  void on_actionJT65C_triggered();
+  void on_NBslider_valueChanged(int value);
+  void on_actionAdjust_IQ_Calibration_triggered();
+  void on_actionApply_IQ_Calibration_triggered();
+
+  void on_actionAFMHot_triggered();
+
+  void on_actionBlue_triggered();
+
+  void on_actionFUNcube_Dongle_triggered();
+
+private:
+    Ui::MainWindow *ui;
+    qint32  m_nDevIn;
+    qint32  m_nDevOut;
+    qint32  m_idInt;
+    qint32  m_waterfallAvg;
+    qint32  m_DF;
+    qint32  m_tol;
+    qint32  m_QSOfreq0;
+    qint32  m_ntx;
+    qint32  m_pttPort;
+    qint32  m_astroFont;
+    qint32  m_timeout;
+    qint32  m_dPhi;
+    qint32  m_fCal;
+    qint32  m_txFreq;
+    qint32  m_setftx;
+    qint32  m_ndepth;
+    qint32  m_sec0;
+    qint32  m_map65RxLog;
+    qint32  m_nutc0;
+    qint32  m_mode65;
+    qint32  m_nrx;
+    qint32  m_hsym0;
+    qint32  m_paInDevice;
+    qint32  m_paOutDevice;
+    qint32  m_udpPort;
+    qint32  m_NBslider;
+    qint32  m_adjustIQ;
+    qint32  m_applyIQcal;
+    qint32  m_mult570;
+
+    double  m_fAdd;
+    double  m_IQamp;
+    double  m_IQphase;
+    double  m_cal570;
+
+    bool    m_monitoring;
+    bool    m_transmitting;
+    bool    m_diskData;
+    bool    m_loopall;
+    bool    m_decoderBusy;
+    bool    m_txFirst;
+    bool    m_auto;
+    bool    m_txMute;
+    bool    m_restart;
+    bool    m_killAll;
+    bool    m_xpol;
+    bool    m_xpolx;
+    bool    m_call3Modified;
+    bool    m_startAnother;
+    bool    m_saveAll;
+    bool    m_onlyEME;
+    bool    m_widebandDecode;
+    bool    m_kb8rq;
+    bool    m_NB;
+    bool    m_fs96000;
+    bool    m_IQswap;
+    bool    m_10db;
+    bool    m_initIQplus;
+
+    float   m_gainx;
+    float   m_gainy;
+    float   m_phasex;
+    float   m_phasey;
+    float   m_pctZap;
+
+    QRect   m_astroGeom;
+    QRect   m_wideGraphGeom;
+    QRect   m_messagesGeom;
+    QRect   m_bandMapGeom;
+
+    QLabel* lab1;                            // labels in status bar
+    QLabel* lab2;
+    QLabel* lab3;
+    QLabel* lab4;
+    QLabel* lab5;
+    QLabel* lab6;
+
+    QMessageBox msgBox0;
+
+    QFuture&lt;void&gt;* future1;
+    QFuture&lt;void&gt;* future2;
+    QFutureWatcher&lt;void&gt;* watcher1;
+    QFutureWatcher&lt;void&gt;* watcher2;
+
+    QProcess proc_m65;
+    QProcess proc_qthid;
+
+    QString m_path;
+    QString m_pbdecoding_style1;
+    QString m_pbmonitor_style;
+    QString m_pbAutoOn_style;
+    QString m_messagesText;
+    QString m_bandmapText;
+    QString m_myCall;
+    QString m_myGrid;
+    QString m_hisCall;
+    QString m_hisGrid;
+    QString m_appDir;
+    QString m_saveDir;
+    QString m_azelDir;
+    QString m_dxccPfx;
+    QString m_palette;
+    QString m_dateTime;
+    QString m_mode;
+    QString m_colors;
+
+    QHash&lt;QString,bool&gt; m_worked;
+
+    SoundInThread soundInThread;             //Instantiate the audio threads
+    SoundOutThread soundOutThread;
+
+//---------------------------------------------------- private functions
+    void readSettings();
+    void writeSettings();
+    void createStatusBar();
+    void updateStatusBar();
+    void msgBox(QString t);
+    void genStdMsgs(QString rpt);
+    void lookup();
+    void ba2msg(QByteArray ba, char* message);
+    void msgtype(QString t, QLineEdit* tx);
+    void stub();
+};
+
+extern void getfile(QString fname, bool xpol, int idInt);
+extern void savetf2(QString fname, bool xpol);
+extern int killbyname(const char* progName);
+extern void getDev(int* numDevices,char hostAPI_DeviceName[][50],
+                   int minChan[], int maxChan[],
+                   int minSpeed[], int maxSpeed[]);
+
+extern &quot;C&quot; {
+//----------------------------------------------------- C and Fortran routines
+  void symspec_(int* k, int* nxpol, int* ndiskdat, int* nb, int* m_NBslider,
+                int* idphi, int* nfsample, float* fgreen, int* iqadjust,
+                int* iqapply, float* gainx, float* gainy, float* phasex,
+                float* phasey, float* rejectx, float* rejecty, float* px,
+                float* py, float s[], int* nkhz, int* nhsym, int* nzap,
+                float* slimit, uchar lstrong[]);
+
+  void gen65_(char* msg, int* mode65, double* samfac, int* nsendingsh,
+              char* msgsent, short iwave[], int* nwave, int len1, int len2);
+
+  int ptt_(int* nport, int* itx, int* iptt);
+  }
+
+#endif // MAINWINDOW_H


Property changes on: branches/map65/mainwindow.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/map65.pro
===================================================================
--- branches/map65/map65.pro	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/map65.pro	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,77 +1,77 @@
-#-------------------------------------------------
-#
-# Project created by QtCreator 2011-07-07T08:39:24
-#
-#-------------------------------------------------
-
-QT       += core gui network
-CONFIG   += qwt thread
-#CONFIG   += console
-
-TARGET = map65
-VERSION = 2.3.0
-TEMPLATE = app
-
-win32 {
-DEFINES = WIN32
-DESTDIR = ../map65_install
-F90 = g95
-g95.output = ${QMAKE_FILE_BASE}.o
-g95.commands = $$F90 -c -O2 -o ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
-g95.input = F90_SOURCES
-QMAKE_EXTRA_COMPILERS += g95
-}
-
-unix {
-DEFINES = UNIX
-DESTDIR = ../map65_install
-F90 = gfortran
-gfortran.output = ${QMAKE_FILE_BASE}.o
-gfortran.commands = $$F90 -c -O2 -o ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
-gfortran.input = F90_SOURCES
-QMAKE_EXTRA_COMPILERS += gfortran
-}
-
-SOURCES += main.cpp mainwindow.cpp plotter.cpp about.cpp \
-    soundin.cpp soundout.cpp devsetup.cpp \
-    widegraph.cpp getfile.cpp messages.cpp bandmap.cpp \
-    astro.cpp displaytext.cpp getdev.cpp
-
-win32 {
-SOURCES += killbyname.cpp     set570.cpp
-}
-
-HEADERS  += mainwindow.h plotter.h soundin.h soundout.h \
-            about.h devsetup.h widegraph.h getfile.h messages.h \
-            bandmap.h commons.h sleep.h astro.h displaytext.h \
-
-DEFINES += __cplusplus
-
-FORMS    += mainwindow.ui about.ui devsetup.ui widegraph.ui \
-    messages.ui bandmap.ui astro.ui
-
-RC_FILE = map65.rc
-
-unix {
-INCLUDEPATH += $$quote(/usr/include/qwt-qt4)
-LIBS += -lfftw3f /usr/lib/libgfortran.so.3
-LIBS += ../map65/libm65/libm65.a
-LIBS += /usr/lib/libqwt-qt4.so
-LIBS += -lportaudio
-#LIBS +- -lusb
-}
-
-win32 {
-INCLUDEPATH += c:/qwt-6.0.1/include
-LIBS += ../map65/libm65/libm65.a
-LIBS += ../map65/libfftw3f_win.a
-LIBS += ../QtSupport/palir-02.dll
-LIBS += libwsock32
-LIBS += C:/MinGW/lib/libf95.a
-CONFIG(release) {
-   LIBS += C:/qwt-6.0.1/lib/qwt.dll
-} else {
-   LIBS += C:/qwt-6.0.1/lib/qwtd.dll
-}
-LIBS += -lusb
-}
+#-------------------------------------------------
+#
+# Project created by QtCreator 2011-07-07T08:39:24
+#
+#-------------------------------------------------
+
+QT       += core gui network
+CONFIG   += qwt thread
+#CONFIG   += console
+
+TARGET = map65
+VERSION = 2.3.0
+TEMPLATE = app
+
+win32 {
+DEFINES = WIN32
+DESTDIR = ../map65_install
+F90 = g95
+g95.output = ${QMAKE_FILE_BASE}.o
+g95.commands = $$F90 -c -O2 -o ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
+g95.input = F90_SOURCES
+QMAKE_EXTRA_COMPILERS += g95
+}
+
+unix {
+DEFINES = UNIX
+DESTDIR = ../map65_install
+F90 = gfortran
+gfortran.output = ${QMAKE_FILE_BASE}.o
+gfortran.commands = $$F90 -c -O2 -o ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
+gfortran.input = F90_SOURCES
+QMAKE_EXTRA_COMPILERS += gfortran
+}
+
+SOURCES += main.cpp mainwindow.cpp plotter.cpp about.cpp \
+    soundin.cpp soundout.cpp devsetup.cpp \
+    widegraph.cpp getfile.cpp messages.cpp bandmap.cpp \
+    astro.cpp displaytext.cpp getdev.cpp
+
+win32 {
+SOURCES += killbyname.cpp     set570.cpp
+}
+
+HEADERS  += mainwindow.h plotter.h soundin.h soundout.h \
+            about.h devsetup.h widegraph.h getfile.h messages.h \
+            bandmap.h commons.h sleep.h astro.h displaytext.h \
+
+DEFINES += __cplusplus
+
+FORMS    += mainwindow.ui about.ui devsetup.ui widegraph.ui \
+    messages.ui bandmap.ui astro.ui
+
+RC_FILE = map65.rc
+
+unix {
+INCLUDEPATH += $$quote(/usr/include/qwt-qt4)
+LIBS += -lfftw3f /usr/lib/libgfortran.so.3
+LIBS += ../map65/libm65/libm65.a
+LIBS += /usr/lib/libqwt-qt4.so
+LIBS += -lportaudio
+#LIBS +- -lusb
+}
+
+win32 {
+INCLUDEPATH += c:/qwt-6.0.1/include
+LIBS += ../map65/libm65/libm65.a
+LIBS += ../map65/libfftw3f_win.a
+LIBS += ../QtSupport/palir-02.dll
+LIBS += libwsock32
+LIBS += C:/MinGW/lib/libf95.a
+CONFIG(release) {
+   LIBS += C:/qwt-6.0.1/lib/qwt.dll
+} else {
+   LIBS += C:/qwt-6.0.1/lib/qwtd.dll
+}
+LIBS += -lusb
+}


Property changes on: branches/map65/map65.pro
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/messages.cpp
===================================================================
--- branches/map65/messages.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/messages.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,81 +1,81 @@
-#include &quot;messages.h&quot;
-#include &quot;ui_messages.h&quot;
-#include &quot;mainwindow.h&quot;
-
-Messages::Messages(QWidget *parent) :
-  QDialog(parent),
-  ui(new Ui::Messages)
-{
-  ui-&gt;setupUi(this);
-  ui-&gt;messagesTextBrowser-&gt;setStyleSheet( \
-          &quot;QTextBrowser { background-color : #000066; color : red; }&quot;);
-  ui-&gt;messagesTextBrowser-&gt;clear();
-  m_cqOnly=false;
-  connect(ui-&gt;messagesTextBrowser,SIGNAL(selectCallsign(bool)),this,
-          SLOT(selectCallsign2(bool)));
-}
-
-Messages::~Messages()
-{
-  delete ui;
-}
-
-void Messages::setText(QString t)
-{
-  QString cfreq,cfreq0;
-  m_t=t;
-
-  QString s=&quot;QTextBrowser{background-color: &quot;+m_colorBackground+&quot;}&quot;;
-  ui-&gt;messagesTextBrowser-&gt;setStyleSheet(s);
-
-  ui-&gt;messagesTextBrowser-&gt;clear();
-  QStringList lines = t.split( &quot;\n&quot;, QString::SkipEmptyParts );
-  foreach( QString line, lines ) {
-    QString t1=line.mid(0,48);
-    if(m_cqOnly and t1.indexOf(&quot; CQ &quot;) &lt; 0) continue;
-    int n=line.mid(48,2).toInt();
-    if(n==0) ui-&gt;messagesTextBrowser-&gt;setTextColor(m_color0);
-    if(n==1) ui-&gt;messagesTextBrowser-&gt;setTextColor(m_color1);
-    if(n==2) ui-&gt;messagesTextBrowser-&gt;setTextColor(m_color2);
-    if(n&gt;=3) ui-&gt;messagesTextBrowser-&gt;setTextColor(m_color3);
-    cfreq=t1.mid(0,3);
-    if(cfreq == cfreq0) {
-      t1=&quot;   &quot; + t1.mid(3,-1);
-    }
-    cfreq0=cfreq;
-    ui-&gt;messagesTextBrowser-&gt;append(t1);
-  }
-}
-
-void Messages::selectCallsign2(bool ctrl)
-{
-  QString t = ui-&gt;messagesTextBrowser-&gt;toPlainText();   //Full contents
-  int i=ui-&gt;messagesTextBrowser-&gt;textCursor().position();
-  int i0=t.lastIndexOf(&quot; &quot;,i);
-  int i1=t.indexOf(&quot; &quot;,i);
-  QString hiscall=t.mid(i0+1,i1-i0-1);
-  if(hiscall!=&quot;&quot;) {
-    if(hiscall.length() &lt; 13) {
-      QString t1 = t.mid(0,i);              //contents up to text cursor
-      int i1=t1.lastIndexOf(&quot;\n&quot;) + 1;
-      QString t2 = t1.mid(i1,i-i1);         //selected line
-      emit click2OnCallsign(hiscall,t2);
-    }
-  }
-}
-
-void Messages::on_checkBox_stateChanged(int n)
-{
-  m_cqOnly = (n!=0);
-  setText(m_t);
-}
-
-void Messages::setColors(QString t)
-{
-  m_colorBackground = &quot;#&quot;+t.mid(0,6);
-  m_color0 = &quot;#&quot;+t.mid(6,6);
-  m_color1 = &quot;#&quot;+t.mid(12,6);
-  m_color2 = &quot;#&quot;+t.mid(18,6);
-  m_color3 = &quot;#&quot;+t.mid(24,6);
-  setText(m_t);
-}
+#include &quot;messages.h&quot;
+#include &quot;ui_messages.h&quot;
+#include &quot;mainwindow.h&quot;
+
+Messages::Messages(QWidget *parent) :
+  QDialog(parent),
+  ui(new Ui::Messages)
+{
+  ui-&gt;setupUi(this);
+  ui-&gt;messagesTextBrowser-&gt;setStyleSheet( \
+          &quot;QTextBrowser { background-color : #000066; color : red; }&quot;);
+  ui-&gt;messagesTextBrowser-&gt;clear();
+  m_cqOnly=false;
+  connect(ui-&gt;messagesTextBrowser,SIGNAL(selectCallsign(bool)),this,
+          SLOT(selectCallsign2(bool)));
+}
+
+Messages::~Messages()
+{
+  delete ui;
+}
+
+void Messages::setText(QString t)
+{
+  QString cfreq,cfreq0;
+  m_t=t;
+
+  QString s=&quot;QTextBrowser{background-color: &quot;+m_colorBackground+&quot;}&quot;;
+  ui-&gt;messagesTextBrowser-&gt;setStyleSheet(s);
+
+  ui-&gt;messagesTextBrowser-&gt;clear();
+  QStringList lines = t.split( &quot;\n&quot;, QString::SkipEmptyParts );
+  foreach( QString line, lines ) {
+    QString t1=line.mid(0,48);
+    if(m_cqOnly and t1.indexOf(&quot; CQ &quot;) &lt; 0) continue;
+    int n=line.mid(48,2).toInt();
+    if(n==0) ui-&gt;messagesTextBrowser-&gt;setTextColor(m_color0);
+    if(n==1) ui-&gt;messagesTextBrowser-&gt;setTextColor(m_color1);
+    if(n==2) ui-&gt;messagesTextBrowser-&gt;setTextColor(m_color2);
+    if(n&gt;=3) ui-&gt;messagesTextBrowser-&gt;setTextColor(m_color3);
+    cfreq=t1.mid(0,3);
+    if(cfreq == cfreq0) {
+      t1=&quot;   &quot; + t1.mid(3,-1);
+    }
+    cfreq0=cfreq;
+    ui-&gt;messagesTextBrowser-&gt;append(t1);
+  }
+}
+
+void Messages::selectCallsign2(bool ctrl)
+{
+  QString t = ui-&gt;messagesTextBrowser-&gt;toPlainText();   //Full contents
+  int i=ui-&gt;messagesTextBrowser-&gt;textCursor().position();
+  int i0=t.lastIndexOf(&quot; &quot;,i);
+  int i1=t.indexOf(&quot; &quot;,i);
+  QString hiscall=t.mid(i0+1,i1-i0-1);
+  if(hiscall!=&quot;&quot;) {
+    if(hiscall.length() &lt; 13) {
+      QString t1 = t.mid(0,i);              //contents up to text cursor
+      int i1=t1.lastIndexOf(&quot;\n&quot;) + 1;
+      QString t2 = t1.mid(i1,i-i1);         //selected line
+      emit click2OnCallsign(hiscall,t2);
+    }
+  }
+}
+
+void Messages::on_checkBox_stateChanged(int n)
+{
+  m_cqOnly = (n!=0);
+  setText(m_t);
+}
+
+void Messages::setColors(QString t)
+{
+  m_colorBackground = &quot;#&quot;+t.mid(0,6);
+  m_color0 = &quot;#&quot;+t.mid(6,6);
+  m_color1 = &quot;#&quot;+t.mid(12,6);
+  m_color2 = &quot;#&quot;+t.mid(18,6);
+  m_color3 = &quot;#&quot;+t.mid(24,6);
+  setText(m_t);
+}


Property changes on: branches/map65/messages.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/messages.h
===================================================================
--- branches/map65/messages.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/messages.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,40 +1,40 @@
-#ifndef MESSAGES_H
-#define MESSAGES_H
-
-#include &lt;QDialog&gt;
-
-namespace Ui {
-  class Messages;
-}
-
-class Messages : public QDialog
-{
-  Q_OBJECT
-
-public:
-  explicit Messages(QWidget *parent = 0);
-  void setText(QString t);
-  void setColors(QString t);
-
-    ~Messages();
-
-signals:
-  void click2OnCallsign(QString hiscall, QString t2);
-
-private slots:
-  void selectCallsign2(bool ctrl);
-  void on_checkBox_stateChanged(int arg1);
-
-private:
-    Ui::Messages *ui;
-    QString m_t;
-    QString m_colorBackground;
-    QString m_color0;
-    QString m_color1;
-    QString m_color2;
-    QString m_color3;
-
-    bool m_cqOnly;
-};
-
-#endif // MESSAGES_H
+#ifndef MESSAGES_H
+#define MESSAGES_H
+
+#include &lt;QDialog&gt;
+
+namespace Ui {
+  class Messages;
+}
+
+class Messages : public QDialog
+{
+  Q_OBJECT
+
+public:
+  explicit Messages(QWidget *parent = 0);
+  void setText(QString t);
+  void setColors(QString t);
+
+    ~Messages();
+
+signals:
+  void click2OnCallsign(QString hiscall, QString t2);
+
+private slots:
+  void selectCallsign2(bool ctrl);
+  void on_checkBox_stateChanged(int arg1);
+
+private:
+    Ui::Messages *ui;
+    QString m_t;
+    QString m_colorBackground;
+    QString m_color0;
+    QString m_color1;
+    QString m_color2;
+    QString m_color3;
+
+    bool m_cqOnly;
+};
+
+#endif // MESSAGES_H


Property changes on: branches/map65/messages.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/paInputDevice.c
===================================================================
--- branches/map65/paInputDevice.c	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/paInputDevice.c	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,56 +1,56 @@
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-
-void paInputDevice(int id, char* hostAPI_DeviceName, int* minChan, 
-		   int* maxChan, int* minSpeed, int* maxSpeed)
-{
-  int i, j, k;
-  char pa_device_name[128];     
-  char pa_device_hostapi[128]; 
-  double pa_device_max_speed;
-  double pa_device_min_speed;
-  int pa_device_max_bytes;
-  int pa_device_min_bytes;
-  int pa_device_max_channels;
-  int pa_device_min_channels;
-  char p2[50];
-  char *p,*p1;
-  static int iret, numDevices, valid_dev_cnt;
-
-  iret=pa_get_device_info (id,
-                          &amp;pa_device_name,
-                          &amp;pa_device_hostapi,
-			  &amp;pa_device_max_speed,
-			  &amp;pa_device_min_speed,
-			  &amp;pa_device_max_bytes,
-			  &amp;pa_device_min_bytes,
-			  &amp;pa_device_max_channels,
-			  &amp;pa_device_min_channels);
-
-  if (iret &gt;= 0 ) {
-    valid_dev_cnt++;
-
-    p1=&quot;&quot;;
-    p=strstr(pa_device_hostapi,&quot;MME&quot;);
-    if(p!=NULL) p1=&quot;MME&quot;;
-    p=strstr(pa_device_hostapi,&quot;Direct&quot;);
-    if(p!=NULL) p1=&quot;DirectX&quot;;
-    p=strstr(pa_device_hostapi,&quot;WASAPI&quot;);
-    if(p!=NULL) p1=&quot;WASAPI&quot;;
-    p=strstr(pa_device_hostapi,&quot;ASIO&quot;);
-    if(p!=NULL) p1=&quot;ASIO&quot;;
-    p=strstr(pa_device_hostapi,&quot;WDM-KS&quot;);
-    if(p!=NULL) p1=&quot;WDM-KS&quot;;
-
-    sprintf(p2,&quot;%-8s %-39s&quot;,p1,pa_device_name);
-    for(i=0; i&lt;50; i++) {
-      hostAPI_DeviceName[i]=p2[i];
-      if(p2[i]==0) break;
-    }
-    *minChan=pa_device_min_channels;
-    *maxChan=pa_device_max_channels;
-    *minSpeed=(int)pa_device_min_speed;
-    *maxSpeed=(int)pa_device_max_speed;
-  }
-}
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+void paInputDevice(int id, char* hostAPI_DeviceName, int* minChan, 
+		   int* maxChan, int* minSpeed, int* maxSpeed)
+{
+  int i, j, k;
+  char pa_device_name[128];     
+  char pa_device_hostapi[128]; 
+  double pa_device_max_speed;
+  double pa_device_min_speed;
+  int pa_device_max_bytes;
+  int pa_device_min_bytes;
+  int pa_device_max_channels;
+  int pa_device_min_channels;
+  char p2[50];
+  char *p,*p1;
+  static int iret, numDevices, valid_dev_cnt;
+
+  iret=pa_get_device_info (id,
+                          &amp;pa_device_name,
+                          &amp;pa_device_hostapi,
+			  &amp;pa_device_max_speed,
+			  &amp;pa_device_min_speed,
+			  &amp;pa_device_max_bytes,
+			  &amp;pa_device_min_bytes,
+			  &amp;pa_device_max_channels,
+			  &amp;pa_device_min_channels);
+
+  if (iret &gt;= 0 ) {
+    valid_dev_cnt++;
+
+    p1=&quot;&quot;;
+    p=strstr(pa_device_hostapi,&quot;MME&quot;);
+    if(p!=NULL) p1=&quot;MME&quot;;
+    p=strstr(pa_device_hostapi,&quot;Direct&quot;);
+    if(p!=NULL) p1=&quot;DirectX&quot;;
+    p=strstr(pa_device_hostapi,&quot;WASAPI&quot;);
+    if(p!=NULL) p1=&quot;WASAPI&quot;;
+    p=strstr(pa_device_hostapi,&quot;ASIO&quot;);
+    if(p!=NULL) p1=&quot;ASIO&quot;;
+    p=strstr(pa_device_hostapi,&quot;WDM-KS&quot;);
+    if(p!=NULL) p1=&quot;WDM-KS&quot;;
+
+    sprintf(p2,&quot;%-8s %-39s&quot;,p1,pa_device_name);
+    for(i=0; i&lt;50; i++) {
+      hostAPI_DeviceName[i]=p2[i];
+      if(p2[i]==0) break;
+    }
+    *minChan=pa_device_min_channels;
+    *maxChan=pa_device_max_channels;
+    *minSpeed=(int)pa_device_min_speed;
+    *maxSpeed=(int)pa_device_max_speed;
+  }
+}


Property changes on: branches/map65/paInputDevice.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/pa_get_device_info.c
===================================================================
--- branches/map65/pa_get_device_info.c	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/pa_get_device_info.c	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,172 +1,172 @@
-#include &lt;portaudio.h&gt;
-#include &lt;stdio.h&gt;
-
-#define MAX_LATENCY 20
-
-PaStream *in_stream;
-//------------------------------------------------------- pa_get_device_info
-int pa_get_device_info (int  n,
-                        void *pa_device_name,
-                        void *pa_device_hostapi, 
-			double *pa_device_max_speed,
-			double *pa_device_min_speed,
-			int *pa_device_max_bytes,
-			int *pa_device_min_bytes,
-			int *pa_device_max_channels,
-			int *pa_device_min_channels )
-{
-
-  (void) n ;
-  (void) pa_device_name;
-  (void) pa_device_hostapi; 
-  (void) pa_device_max_speed;
-  (void) pa_device_min_speed;
-  (void) pa_device_max_bytes;
-  (void) pa_device_min_bytes;
-  (void) pa_device_max_channels;
-  (void) pa_device_min_channels;
-  const PaDeviceInfo *deviceInfo;
-  PaError pa_err;
-  PaStreamParameters inputParameters;
-  int i,j, speed_warning;
-  int minBytes, maxBytes;
-  double maxStandardSampleRate;
-  double minStandardSampleRate;
-  int minInputChannels;
-  int maxInputChannels;
-
-// negative terminated  list
-  static double standardSampleRates[] = {8000.0, 9600.0, 
-        11025.0, 12000.0, 16000.0, 22050.0, 24000.0, 32000.0,
-        44100.0, 48000.0, 88200.0, 96000.0, 192000.0, -1};
-// *******************************************************
-
-
-  *pa_device_max_speed=0;
-  *pa_device_min_speed=0;
-  *pa_device_max_bytes=0;
-  *pa_device_min_bytes=0;
-  *pa_device_max_channels=0;
-  *pa_device_min_channels=0;
-  minInputChannels=0;
-  if(n &gt;= Pa_GetDeviceCount() ) return -1;
-  deviceInfo = Pa_GetDeviceInfo(n);
-  if (deviceInfo-&gt;maxInputChannels==0) return -1; 
-  sprintf((char*)(pa_device_name),&quot;%s&quot;,deviceInfo-&gt;name);
-  sprintf((char*)(pa_device_hostapi),&quot;%s&quot;,
-	  Pa_GetHostApiInfo( deviceInfo-&gt;hostApi )-&gt;name);
-  speed_warning=0;
-
-// bypass bug in Juli@ ASIO driver: 
-// this driver hangs after a Pa_IsFormatSupported call 
-  i = strncmp(deviceInfo-&gt;name, &quot;ASIO 2.0 - ESI Juli@&quot;, 19);
-  if (i == 0) {
-    minStandardSampleRate=44100;
-    maxStandardSampleRate=192000;
-    minBytes=1;
-    maxBytes=4;
-    maxInputChannels= deviceInfo-&gt;maxInputChannels;
-    minInputChannels= 1;
-    goto end_pa_get_device_info;
-  }
-
-// Investigate device capabilities.
-// Check min and max samplerates  with 16 bit data.
-  maxStandardSampleRate=0;
-  minStandardSampleRate=0;
-  inputParameters.device = n;
-  inputParameters.channelCount = deviceInfo-&gt;maxInputChannels;
-  inputParameters.sampleFormat = paInt16;
-  inputParameters.suggestedLatency = 0;
-  inputParameters.hostApiSpecificStreamInfo = NULL;
-
-// ************************************************************************
-//filter for portaudio Windows hostapi's with non experts.
-//only allow ASIO or WASAPI or WDM-KS
-  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name, &quot;ASIO&quot;, 4);
-  if (i==0 ) goto end_filter_hostapi;
-  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name, 
-	      &quot;Windows WASAPI&quot;, 14);
-  if (i==0 ) goto end_filter_hostapi;
-  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name, 
-	      &quot;Windows WDM-KS&quot;, 14);
-  if (i==0 ) goto end_filter_hostapi;
-  speed_warning=1;
-end_filter_hostapi:;
-
-// ************************************************************************
-  i=0;
-  while(standardSampleRates[i] &gt; 0 &amp;&amp; minStandardSampleRate==0) {
-    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
-				standardSampleRates[i] );
-    if(pa_err == paDeviceUnavailable) return -1;
-    if(pa_err == paInvalidDevice) return -1;
-    if(pa_err == paFormatIsSupported ) { 
-      minStandardSampleRate=standardSampleRates[i];
-    }
-    i++;
-  }
-  if(minStandardSampleRate == 0) return -1;
-  j=i;
-  while(standardSampleRates[i] &gt; 0 ) i++;
-  i--;
-  while(i &gt;= j &amp;&amp; maxStandardSampleRate==0) {
-      pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
-				  standardSampleRates[i] );
-    if(pa_err == paDeviceUnavailable) return -1;
-    if(pa_err == paInvalidDevice) return -1;
-    if( pa_err == paFormatIsSupported ) { 
-      maxStandardSampleRate=standardSampleRates[i];
-    }
-    i--;
-  }
-
-// check if min SampleRate  = max SampleRate 
-  if(maxStandardSampleRate==0 &amp;&amp; (minStandardSampleRate != 0)) {
-    maxStandardSampleRate= minStandardSampleRate;
-  }
-
-// check min and max bytes
-  minBytes=2;
-  maxBytes=2;
-  inputParameters.sampleFormat = paUInt8;
-  pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
-				maxStandardSampleRate );
-  if( pa_err == paFormatIsSupported ) { 
-    minBytes=1;
-  }
-    inputParameters.sampleFormat = paInt32;
-    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
-				maxStandardSampleRate );
-  if( pa_err == paFormatIsSupported ) { 
-    maxBytes=4;
-  }
-
-// check min channel count
-  maxInputChannels= deviceInfo-&gt;maxInputChannels;
-  inputParameters.channelCount = 1;
-  inputParameters.sampleFormat = paInt16;
-  pa_err=paFormatIsSupported+32000;
-  while(pa_err != paFormatIsSupported &amp;&amp;
-	  ( inputParameters.channelCount &lt; (maxInputChannels+1)) ) {
-    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
-				maxStandardSampleRate );
-    inputParameters.channelCount++;
-  }
-  if( pa_err == paFormatIsSupported ) {
-    minInputChannels=inputParameters.channelCount-1;
-  } else {
-    return -1;
-  }
-
-end_pa_get_device_info:;
-
-  *pa_device_max_speed=maxStandardSampleRate;
-  *pa_device_min_speed=minStandardSampleRate;
-  *pa_device_max_bytes=maxBytes;
-  *pa_device_min_bytes=minBytes;
-  *pa_device_max_channels= maxInputChannels;
-  *pa_device_min_channels= minInputChannels;
-
-  return speed_warning;
-}
+#include &lt;portaudio.h&gt;
+#include &lt;stdio.h&gt;
+
+#define MAX_LATENCY 20
+
+PaStream *in_stream;
+//------------------------------------------------------- pa_get_device_info
+int pa_get_device_info (int  n,
+                        void *pa_device_name,
+                        void *pa_device_hostapi, 
+			double *pa_device_max_speed,
+			double *pa_device_min_speed,
+			int *pa_device_max_bytes,
+			int *pa_device_min_bytes,
+			int *pa_device_max_channels,
+			int *pa_device_min_channels )
+{
+
+  (void) n ;
+  (void) pa_device_name;
+  (void) pa_device_hostapi; 
+  (void) pa_device_max_speed;
+  (void) pa_device_min_speed;
+  (void) pa_device_max_bytes;
+  (void) pa_device_min_bytes;
+  (void) pa_device_max_channels;
+  (void) pa_device_min_channels;
+  const PaDeviceInfo *deviceInfo;
+  PaError pa_err;
+  PaStreamParameters inputParameters;
+  int i,j, speed_warning;
+  int minBytes, maxBytes;
+  double maxStandardSampleRate;
+  double minStandardSampleRate;
+  int minInputChannels;
+  int maxInputChannels;
+
+// negative terminated  list
+  static double standardSampleRates[] = {8000.0, 9600.0, 
+        11025.0, 12000.0, 16000.0, 22050.0, 24000.0, 32000.0,
+        44100.0, 48000.0, 88200.0, 96000.0, 192000.0, -1};
+// *******************************************************
+
+
+  *pa_device_max_speed=0;
+  *pa_device_min_speed=0;
+  *pa_device_max_bytes=0;
+  *pa_device_min_bytes=0;
+  *pa_device_max_channels=0;
+  *pa_device_min_channels=0;
+  minInputChannels=0;
+  if(n &gt;= Pa_GetDeviceCount() ) return -1;
+  deviceInfo = Pa_GetDeviceInfo(n);
+  if (deviceInfo-&gt;maxInputChannels==0) return -1; 
+  sprintf((char*)(pa_device_name),&quot;%s&quot;,deviceInfo-&gt;name);
+  sprintf((char*)(pa_device_hostapi),&quot;%s&quot;,
+	  Pa_GetHostApiInfo( deviceInfo-&gt;hostApi )-&gt;name);
+  speed_warning=0;
+
+// bypass bug in Juli@ ASIO driver: 
+// this driver hangs after a Pa_IsFormatSupported call 
+  i = strncmp(deviceInfo-&gt;name, &quot;ASIO 2.0 - ESI Juli@&quot;, 19);
+  if (i == 0) {
+    minStandardSampleRate=44100;
+    maxStandardSampleRate=192000;
+    minBytes=1;
+    maxBytes=4;
+    maxInputChannels= deviceInfo-&gt;maxInputChannels;
+    minInputChannels= 1;
+    goto end_pa_get_device_info;
+  }
+
+// Investigate device capabilities.
+// Check min and max samplerates  with 16 bit data.
+  maxStandardSampleRate=0;
+  minStandardSampleRate=0;
+  inputParameters.device = n;
+  inputParameters.channelCount = deviceInfo-&gt;maxInputChannels;
+  inputParameters.sampleFormat = paInt16;
+  inputParameters.suggestedLatency = 0;
+  inputParameters.hostApiSpecificStreamInfo = NULL;
+
+// ************************************************************************
+//filter for portaudio Windows hostapi's with non experts.
+//only allow ASIO or WASAPI or WDM-KS
+  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name, &quot;ASIO&quot;, 4);
+  if (i==0 ) goto end_filter_hostapi;
+  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name, 
+	      &quot;Windows WASAPI&quot;, 14);
+  if (i==0 ) goto end_filter_hostapi;
+  i = strncmp(Pa_GetHostApiInfo(deviceInfo-&gt;hostApi)-&gt;name, 
+	      &quot;Windows WDM-KS&quot;, 14);
+  if (i==0 ) goto end_filter_hostapi;
+  speed_warning=1;
+end_filter_hostapi:;
+
+// ************************************************************************
+  i=0;
+  while(standardSampleRates[i] &gt; 0 &amp;&amp; minStandardSampleRate==0) {
+    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
+				standardSampleRates[i] );
+    if(pa_err == paDeviceUnavailable) return -1;
+    if(pa_err == paInvalidDevice) return -1;
+    if(pa_err == paFormatIsSupported ) { 
+      minStandardSampleRate=standardSampleRates[i];
+    }
+    i++;
+  }
+  if(minStandardSampleRate == 0) return -1;
+  j=i;
+  while(standardSampleRates[i] &gt; 0 ) i++;
+  i--;
+  while(i &gt;= j &amp;&amp; maxStandardSampleRate==0) {
+      pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
+				  standardSampleRates[i] );
+    if(pa_err == paDeviceUnavailable) return -1;
+    if(pa_err == paInvalidDevice) return -1;
+    if( pa_err == paFormatIsSupported ) { 
+      maxStandardSampleRate=standardSampleRates[i];
+    }
+    i--;
+  }
+
+// check if min SampleRate  = max SampleRate 
+  if(maxStandardSampleRate==0 &amp;&amp; (minStandardSampleRate != 0)) {
+    maxStandardSampleRate= minStandardSampleRate;
+  }
+
+// check min and max bytes
+  minBytes=2;
+  maxBytes=2;
+  inputParameters.sampleFormat = paUInt8;
+  pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
+				maxStandardSampleRate );
+  if( pa_err == paFormatIsSupported ) { 
+    minBytes=1;
+  }
+    inputParameters.sampleFormat = paInt32;
+    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
+				maxStandardSampleRate );
+  if( pa_err == paFormatIsSupported ) { 
+    maxBytes=4;
+  }
+
+// check min channel count
+  maxInputChannels= deviceInfo-&gt;maxInputChannels;
+  inputParameters.channelCount = 1;
+  inputParameters.sampleFormat = paInt16;
+  pa_err=paFormatIsSupported+32000;
+  while(pa_err != paFormatIsSupported &amp;&amp;
+	  ( inputParameters.channelCount &lt; (maxInputChannels+1)) ) {
+    pa_err=Pa_IsFormatSupported(&amp;inputParameters, NULL, 
+				maxStandardSampleRate );
+    inputParameters.channelCount++;
+  }
+  if( pa_err == paFormatIsSupported ) {
+    minInputChannels=inputParameters.channelCount-1;
+  } else {
+    return -1;
+  }
+
+end_pa_get_device_info:;
+
+  *pa_device_max_speed=maxStandardSampleRate;
+  *pa_device_min_speed=minStandardSampleRate;
+  *pa_device_max_bytes=maxBytes;
+  *pa_device_min_bytes=minBytes;
+  *pa_device_max_channels= maxInputChannels;
+  *pa_device_min_channels= minInputChannels;
+
+  return speed_warning;
+}


Property changes on: branches/map65/pa_get_device_info.c
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/plotter.cpp
===================================================================
--- branches/map65/plotter.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/plotter.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,711 +1,711 @@
-#include &quot;plotter.h&quot;
-#include &lt;math.h&gt;
-#include &lt;QDebug&gt;
-
-#define MAX_SCREENSIZE 2048
-
-
-CPlotter::CPlotter(QWidget *parent) :                  //CPlotter Constructor
-  QFrame(parent)
-{
-  setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
-  setFocusPolicy(Qt::StrongFocus);
-  setAttribute(Qt::WA_PaintOnScreen,false);
-  setAutoFillBackground(false);
-  setAttribute(Qt::WA_OpaquePaintEvent, false);
-  setAttribute(Qt::WA_NoSystemBackground, true);
-
-  m_StartFreq = 100;
-  m_nSpan=65;                    //Units: kHz
-  m_fSpan=(float)m_nSpan;
-  m_hdivs = HORZ_DIVS;
-  m_FreqUnits = 1;
-  m_Running = false;
-  m_paintEventBusy=false;
-  m_WaterfallPixmap = QPixmap(0,0);
-  m_ZoomWaterfallPixmap = QPixmap(0,0);
-  m_2DPixmap = QPixmap(0,0);
-  m_ScalePixmap = QPixmap(0,0);
-  m_ZoomScalePixmap = QPixmap(0,0);
-  m_Size = QSize(0,0);
-  m_fQSO = 125;
-  m_line = 0;
-  m_fSample = 96000;
-  m_paintAllZoom = false;
-}
-
-CPlotter::~CPlotter() { }                                      // Destructor
-
-QSize CPlotter::minimumSizeHint() const
-{
-  return QSize(50, 50);
-}
-
-QSize CPlotter::sizeHint() const
-{
-  return QSize(180, 180);
-}
-
-void CPlotter::resizeEvent(QResizeEvent* )                    //resizeEvent()
-{
-  if(!size().isValid()) return;
-  if( m_Size != size() ) {
-    //if changed, resize pixmaps to new screensize
-    m_Size = size();
-    int w = m_Size.width();
-    int h = (m_Size.height()-60)/2;
-    m_WaterfallPixmap = QPixmap(w,h);
-    m_ZoomWaterfallPixmap = QPixmap(w,h);
-    m_2DPixmap = QPixmap(w,h);
-    m_WaterfallPixmap.fill(Qt::black);
-    m_ZoomWaterfallPixmap.fill(Qt::black);
-    m_2DPixmap.fill(Qt::black);
-    memset(m_zwf,0,32768*h);
-    m_ScalePixmap = QPixmap(w,30);
-    m_ZoomScalePixmap = QPixmap(w,30);    //(no change on resize...)
-    m_ScalePixmap.fill(Qt::white);
-    m_ZoomScalePixmap.fill(Qt::yellow);
-  }
-  SetCenterFreq(-1);
-  DrawOverlay();
-}
-
-void CPlotter::paintEvent(QPaintEvent *)                    // paintEvent()
-{
-  static int x00=-99;
-  int ihr,imin;
-
-  if(m_paintEventBusy) return;
-  m_paintEventBusy=true;
-  QPainter painter(this);
-  int w = m_Size.width();
-  int h = (m_Size.height()-60)/2;
-  painter.drawPixmap(0,0,m_ScalePixmap);
-  painter.drawPixmap(0,30,m_WaterfallPixmap);
-  if(m_2Dspec) {
-    painter.drawPixmap(0,h+30,m_ScalePixmap);
-    painter.drawPixmap(0,h+60,m_2DPixmap);
-    m_paintEventBusy=false;
-    return;
-  }
-
-  painter.drawPixmap(0,h+30,m_ZoomScalePixmap);
-  painter.drawPixmap(0,h+60,m_ZoomWaterfallPixmap);
-
-  QRect target(0,h+30,w,30);           // (x,y,width,height)
-  QRect source(0,0,w,30);
-  painter.drawPixmap(target,m_ZoomScalePixmap,source);
-
-  float df=m_fSample/32768.0;
-  int x0=16384 + (0.001*(m_ZoomStartFreq+m_fCal)+m_fQSO-m_nkhz+1.27046) * \
-      1000.0/df + 0.5;
-
-  QPainter painter2(&amp;m_ZoomWaterfallPixmap);
-  for(int i=0; i&lt;w; i++) {                      //Paint the top row
-    painter2.setPen(m_ColorTbl[m_zwf[x0+i]]);
-    painter2.drawPoint(i,0);
-  }
-  if(m_paintAllZoom or (x0 != x00 and x00 != -99)) {
-    // If new fQSO, paint all rows
-    int k=x0;
-    for(int j=1; j&lt;h; j++) {
-      k += 32768;
-      for(int i=0; i&lt;w; i++) {
-        painter2.setPen(m_ColorTbl[m_zwf[i+k]]);
-        painter2.drawPoint(i,j);
-      }
-      if(j == 15) {
-        painter2.setPen(m_ColorTbl[255]);
-        painter2.drawText(5,10,m_sutc);
-      }
-    }
-  } else if(m_line == 15) {
-    painter2.setPen(m_ColorTbl[255]);
-    UTCstr();
-    painter2.drawText(5,10,m_sutc);
-  }
-  m_paintAllZoom=false;
-  x00=x0;
-
-  QRect target2(0,h+60,w,h);           // (x,y,width,height)
-  QRect source2(0,0,w,h);
-  painter.drawPixmap(target2,m_ZoomWaterfallPixmap,source2);
-  m_paintEventBusy=false;
-}
-
-void CPlotter::draw(float s[], int i0, float splot[])                       //draw()
-{
-  int i,j,k,w,h;
-  int ihr,imin;
-  float y;
-
-  m_i0=i0;
-  w = m_WaterfallPixmap.width();
-  h = m_WaterfallPixmap.height();
-  double gain = pow(10.0,0.05*(m_plotGain+7));
-
-  //move current data down one line
-  //(must do this before attaching a QPainter object)
-  m_WaterfallPixmap.scroll(0,1,0,0,w,h);
-  m_ZoomWaterfallPixmap.scroll(0,1,0,0, w, h);
-  memmove(&amp;m_zwf[32768],m_zwf,32768*(h-1));
-  QPainter painter1(&amp;m_WaterfallPixmap);
-  QPainter painter2D(&amp;m_2DPixmap);
-
-  for(i=0; i&lt;256; i++) {                     //Zero the histograms
-    m_hist1[i]=0;
-    m_hist2[i]=0;
-  }
-
-  painter2D.setPen(Qt::green);
-  QRect tmp(0,0,w,h);
-  painter2D.fillRect(tmp,Qt::black);
-  QPoint LineBuf[MAX_SCREENSIZE];
-  j=0;
-  bool strong0=false;
-  bool strong=false;
-
-  for(i=0; i&lt;w; i++) {
-    strong=false;
-    if(s[i]&lt;0) {
-      strong=true;
-      s[i]=-s[i];
-    }
-    y = 10.0*log10(s[i]);
-    int y1 = 5.0*gain*(y + 29 -m_plotZero);
-    if (y1&lt;0) y1=0;
-    if (y1&gt;254) y1=254;
-    if (s[i]&gt;1.e29) y1=255;
-    m_hist1[y1]++;
-    painter1.setPen(m_ColorTbl[y1]);
-    painter1.drawPoint(i,0);
-    if(m_2Dspec) {
-      int y2 = gain*(y + 34 -m_plotZero);
-      if (y2&lt;0) y2=0;
-      if (y2&gt;254) y2=254;
-      if (s[i]&gt;1.e29) y2=255;
-      if(strong != strong0 or i==w-1) {
-        painter2D.drawPolyline(LineBuf,j);
-        j=0;
-        strong0=strong;
-        if(strong0) painter2D.setPen(Qt::red);
-        if(!strong0) painter2D.setPen(Qt::green);
-      }
-      LineBuf[j].setX(i);
-      LineBuf[j].setY(h-y2);
-      j++;
-    }
-  }
-
-  for(i=0; i&lt;32768; i++) {
-    y = 10.0*log10(splot[i]);
-    int y1 = 5.0*gain*(y + 30 - m_plotZero);
-    if (y1&lt;0) y1=0;
-    if (y1&gt;254) y1=254;
-    if (splot[i]&gt;1.e29) y1=255;
-    m_hist2[y1]++;
-    m_zwf[i]=y1;
-  }
-
-  if(s[0]&gt;1.0e29) m_line=0;
-  m_line++;
-  if(m_line == 15) {
-    UTCstr();
-    painter1.setPen(m_ColorTbl[255]);
-    painter1.drawText(5,10,m_sutc);
-  }
-  update();                              //trigger a new paintEvent
-}
-
-void CPlotter::UTCstr()
-{
-  int ihr,imin;
-  if(datcom_.ndiskdat != 0) {
-    ihr=datcom_.nutc/100;
-    imin=datcom_.nutc%100;
-  } else {
-    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
-    imin=ms/60000;
-    ihr=imin/60;
-    imin=imin % 60;
-  }
-  sprintf(m_sutc,&quot;%2.2d:%2.2d&quot;,ihr,imin);
-}
-
-void CPlotter::DrawOverlay()                                 //DrawOverlay()
-{
-  if(m_WaterfallPixmap.isNull()) return;
-  int w = m_WaterfallPixmap.width();
-  int x,y;
-  float pixperdiv;
-
-  QRect rect0;
-  QPainter painter0(&amp;m_ScalePixmap);
-  painter0.initFrom(this);
-
-  //create Font to use for scales
-  QFont Font(&quot;Arial&quot;);
-  Font.setPointSize(12);
-  QFontMetrics metrics(Font);
-  Font.setWeight(QFont::Normal);
-  painter0.setFont(Font);
-  painter0.setPen(Qt::black);
-
-  m_binsPerPixel = m_nSpan * 32768.0/(w*0.001*m_fSample) + 0.5;
-  double FreqPerDiv=5.0;
-  double df = m_binsPerPixel*0.001*m_fSample/32768.0;
-  m_hdivs = w*df/FreqPerDiv + 0.9999;
-  m_fSpan = w*df;
-  m_ScalePixmap.fill(Qt::white);
-  painter0.drawRect(0, 0, w, 30);
-
-  //draw tick marks on wideband (upper) scale
-  pixperdiv = FreqPerDiv/df;
-  for( int i=1; i&lt;m_hdivs; i++) {     //major ticks
-    x = (int)( (float)i*pixperdiv );
-    painter0.drawLine(x,18,x,30);
-  }
-  for( int i=1; i&lt;5*m_hdivs; i++) {   //minor ticks
-    x = i*pixperdiv/5.0;
-    painter0.drawLine(x,24,x,30);
-  }
-
-  //draw frequency values
-  MakeFrequencyStrs();
-  for( int i=0; i&lt;=m_hdivs; i++) {
-    if(0==i) {
-      //left justify the leftmost text
-      x = (int)( (float)i*pixperdiv);
-      rect0.setRect(x,0, (int)pixperdiv, 20);
-      painter0.drawText(rect0, Qt::AlignLeft|Qt::AlignVCenter,
-                       m_HDivText[i]);
-    }
-    else if(m_hdivs == i) {
-      //right justify the rightmost text
-      x = (int)( (float)i*pixperdiv - pixperdiv);
-      rect0.setRect(x,0, (int)pixperdiv, 20);
-      painter0.drawText(rect0, Qt::AlignRight|Qt::AlignVCenter,
-                       m_HDivText[i]);
-    } else {
-      //center justify the rest of the text
-      x = (int)( (float)i*pixperdiv - pixperdiv/2);
-      rect0.setRect(x,0, (int)pixperdiv, 20);
-      painter0.drawText(rect0, Qt::AlignHCenter|Qt::AlignVCenter,
-                       m_HDivText[i]);
-    }
-  }
-
-
-  if(m_2Dspec) {
-    QPen pen0(Qt::green, 3);                 //Mark Cal Freq with green tick
-    painter0.setPen(pen0);
-    x = m_xClick;
-    painter0.drawLine(x,15,x,30);
-    int x0=(16384-m_i0)/m_binsPerPixel;
-    m_fGreen=(x-x0)*df;
-    x0 += (x0-x);
-    QPen pen3(Qt::red, 3);
-    painter0.setPen(pen3);
-    if(x0&gt;0 and x0&lt;w) painter0.drawLine(x0,15,x0,30);
-  } else {
-    QPen pen0(Qt::green, 3);                 //Mark fQSO with green tick
-    painter0.setPen(pen0);
-    x = XfromFreq(float(fQSO()));
-    painter0.drawLine(x,15,x,30);
-  }
-
-  // Now make the zoomed scale, using m_ZoomScalePixmap and painter3
-  QRect rect1;
-  QPainter painter3(&amp;m_ZoomScalePixmap);
-  painter3.initFrom(this);
-  painter3.setFont(Font);
-  painter3.setPen(Qt::black);
-
-  FreqPerDiv=0.2;
-  df = 0.001*m_fSample/32768.0;
-  m_hdivs = 32768*df/FreqPerDiv + 0.9999;
-  int nlabs=df*w/0.2 + 1.0;
-  m_ZoomScalePixmap.fill(Qt::white);
-  painter3.drawRect(0, 0, w, 30);
-
-  pixperdiv = FreqPerDiv/df;
-  for( int i=0; i&lt;10*nlabs; i++) {
-    x = i*pixperdiv/10;
-    y=24;
-    if ((i%5) == 0) y=18;
-    painter3.drawLine(x,y,x,30);
-  }
-
-  //draw frequency values
-  MakeFrequencyStrs();
-  for( int i=0; i&lt;=nlabs; i++) {
-    x = (int)( (float)i*pixperdiv - pixperdiv/2);
-    rect1.setRect(x,0, (int)pixperdiv, 20);
-    painter3.drawText(rect1, Qt::AlignHCenter|Qt::AlignVCenter,
-                      m_HDivText[i]);
-  }
-
-  df=m_fSample/32768.0;
-  x = (m_DF + m_mode65*66*11025.0/4096.0 - m_ZoomStartFreq)/df;
-  QPen pen2(Qt::red, 3);            //Mark top JT65B tone with red tick
-  painter3.setPen(pen2);
-  painter3.drawLine(x,15,x,30);
-  x = (m_DF - m_ZoomStartFreq)/df;
-  QPen pen1(Qt::green, 3);                //Mark DF with a green tick
-  painter3.setPen(pen1);
-  painter3.drawLine(x,15,x,30);
-  for(int i=2; i&lt;5; i++) {                //Mark the shorthand freqs
-    x = (m_DF + m_mode65*10*i*11025.0/4096.0 - m_ZoomStartFreq)/df;
-    painter3.drawLine(x,20,x,30);
-  }
-  int x1=(m_DF - m_tol - m_ZoomStartFreq)/df;
-  int x2=(m_DF + m_tol - m_ZoomStartFreq)/df;
-  pen1.setWidth(6);
-  painter3.drawLine(x1,28,x2,28);
-}
-
-void CPlotter::MakeFrequencyStrs()                       //MakeFrequencyStrs
-{
-  float StartFreq = m_StartFreq;
-  float freq;
-  int i,j;
-  int FreqPerDiv=5;
-
-  if(m_hdivs &gt; 100) {
-    m_FreqUnits = 1;
-    FreqPerDiv = 200;
-    int w = m_WaterfallPixmap.width();
-    float df=m_fSample/32768.0;
-    StartFreq = -w*df/2;
-    int n=StartFreq/FreqPerDiv;
-    StartFreq=n*200;
-    m_ZoomStartFreq = (int)StartFreq;
-  }
-  int numfractdigits = (int)log10((double)m_FreqUnits);
-
-  if(1 == m_FreqUnits) {
-    //if units is Hz then just output integer freq
-    for(int i=0; i&lt;=m_hdivs; i++) {
-      freq = StartFreq/(float)m_FreqUnits;
-      m_HDivText[i].setNum((int)freq);
-      StartFreq += FreqPerDiv;
-    }
-    return;
-  }
-  //here if is fractional frequency values
-  //so create max sized text based on frequency units
-  for(int i=0; i&lt;=m_hdivs; i++) {
-    freq = StartFreq/(float)m_FreqUnits;
-    m_HDivText[i].setNum(freq,'f', numfractdigits);
-    StartFreq += FreqPerDiv;
-  }
-  //now find the division text with the longest non-zero digit
-  //to the right of the decimal point.
-  int max = 0;
-  for(i=0; i&lt;=m_hdivs; i++) {
-    int dp = m_HDivText[i].indexOf('.');
-    int l = m_HDivText[i].length()-1;
-    for(j=l; j&gt;dp; j--) {
-      if(m_HDivText[i][j] != '0')
-        break;
-    }
-    if( (j-dp) &gt; max)
-      max = j-dp;
-  }
-  //truncate all strings to maximum fractional length
-  StartFreq = m_CenterFreq - 0.5*m_fSpan;
-  for( i=0; i&lt;=m_hdivs; i++) {
-    freq = (float)StartFreq/(float)m_FreqUnits;
-    m_HDivText[i].setNum(freq,'f', max);
-    StartFreq += FreqPerDiv;
-  }
-}
-
-int CPlotter::XfromFreq(float f)                               //XfromFreq()
-{
-  float w = m_WaterfallPixmap.width();
-  int x = (int) w * (f - m_StartFreq)/m_fSpan;
-  if(x&lt;0 ) return 0;
-  if(x&gt;(int)w) return m_WaterfallPixmap.width();
-  return x;
-}
-
-float CPlotter::FreqfromX(int x)                               //FreqfromX()
-{
-  float w = m_WaterfallPixmap.width();
-  float f =m_CenterFreq - 0.5*m_fSpan + m_fSpan * x/w;
-  return f;
-}
-
-void CPlotter::SetRunningState(bool running)              //SetRunningState()
-{
-  m_Running = running;
-}
-
-void CPlotter::setPlotZero(int plotZero)                  //setPlotZero()
-{
-  m_plotZero=plotZero;
-}
-
-int CPlotter::getPlotZero()                               //getPlotZero()
-{
-  return m_plotZero;
-}
-
-void CPlotter::setPlotGain(int plotGain)                  //setPlotGain()
-{
-  m_plotGain=plotGain;
-}
-
-int CPlotter::getPlotGain()                               //getPlotGain()
-{
-  return m_plotGain;
-}
-
-void CPlotter::SetCenterFreq(int f)                   //setCenterFreq()
-{
-// f is the integer kHz portion of cfreq, from Linrad packets
-  if(f&lt;0) f=m_nkhz;
-  int ns = (f+m_FreqOffset-0.5*m_fSpan)/5.0 + 0.5;
-  double fs = 5*ns;
-  m_CenterFreq = fs + 0.5*m_fSpan;
-}
-
-qint64 CPlotter::centerFreq()                             //centerFreq()
-{
-  return m_CenterFreq;
-}
-
-void CPlotter::SetStartFreq(quint64 f)                    //SetStartFreq()
-{
-  m_StartFreq=f;
-//    resizeEvent(NULL);
-  DrawOverlay();
-}
-
-qint64 CPlotter::startFreq()                              //startFreq()
-{
-  return m_StartFreq;
-}
-
-void CPlotter::SetFreqOffset(quint64 f)                   //SetFreqOffset()
-{
-  m_FreqOffset=f;
-  DrawOverlay();
-}
-
-qint64 CPlotter::freqOffset() {return m_FreqOffset;}         //freqOffset()
-int CPlotter::plotWidth(){return m_WaterfallPixmap.width();}
-void CPlotter::UpdateOverlay() {DrawOverlay();}
-void CPlotter::setDataFromDisk(bool b) {m_dataFromDisk=b;}
-
-void CPlotter::setTol(int n)                                 //setTol()
-{
-  m_tol=n;
-  DrawOverlay();
-}
-
-void CPlotter::setBinsPerPixel(int n) {m_binsPerPixel = n;}  //set nbpp
-
-int CPlotter::binsPerPixel(){return m_binsPerPixel;}         //get nbpp
-
-void CPlotter::setFQSO(int x, bool bf)                       //setFQSO()
-{
-  if(bf) {
-    m_fQSO=x;         // x is freq in kHz
-  } else {
-    if(x&lt;0) x=0;      // x is pixel number
-    if(x&gt;m_Size.width()) x=m_Size.width();
-    m_fQSO = int(FreqfromX(x)+0.5);
-    m_xClick=x;
-  }
-  DrawOverlay();
-  update();
-}
-
-void CPlotter::setFcal(int n)                                  //setFcal()
-{
-  m_fCal=n;
-}
-
-void CPlotter::setNkhz(int n)                                  //setNkhz()
-{
-  m_nkhz=n;
-}
-
-int CPlotter::fQSO() {return m_fQSO;}                          //get fQSO
-
-int CPlotter::DF() {return m_DF;}                              // get DF
-
-void CPlotter::mousePressEvent(QMouseEvent *event)       //mousePressEvent
-{
-  int h = (m_Size.height()-60)/2;
-  int x=event-&gt;x();
-  int y=event-&gt;y();
-  if(y &lt; h+30) {
-    setFQSO(x,false);                               // Wideband waterfall
-  } else {
-    m_DF=int(m_ZoomStartFreq + x*m_fSample/32768.0);  // Zoomed waterfall
-    DrawOverlay();
-    update();
-  }
-}
-
-void CPlotter::mouseDoubleClickEvent(QMouseEvent *event)  //mouse2click
-{
-  int h = (m_Size.height()-60)/2;
-  int x=event-&gt;x();
-  int y=event-&gt;y();
-  if(y &lt; h+30) {
-    m_DF=0;
-    setFQSO(x,false);
-    emit freezeDecode1(2);                  //### ???
-  } else {
-    float f = m_ZoomStartFreq + x*m_fSample/32768.0;
-    m_DF=int(f);
-    emit freezeDecode1(1);
-    DrawOverlay();
-  }
-}
-
-int CPlotter::autoZero()                                        //autoZero()
-{
-  m_z1=0;
-  m_z2=0;
-  int sum1=0;
-  for(int i=0; i&lt;256; i++) {
-    sum1 += m_hist1[i];
-    if(sum1 &gt; m_Size.width()/2) {
-      m_z1=i;
-      break;
-    }
-  }
-  int sum2=0;
-  for(int i=0; i&lt;256; i++) {
-    sum2 += m_hist2[i];
-    if(sum2 &gt; 16384) {
-      m_z2=i;
-      break;
-    }
-  }
-  double gain = pow(10.0,0.05*(m_plotGain+7));
-//  double dz1 = (m_z1-38)/(5.0*gain);
-  double dz2 = (m_z2-28)/(5.0*gain);
-  if(m_z2 &lt; 255) m_plotZero = int(m_plotZero + dz2 + 0.5);
-  return m_plotZero;
-}
-
-void CPlotter::setNSpan(int n)                                  //setNSpan()
-{
-  m_nSpan=n;
-}
-
-void CPlotter::setPalette(QString palette)                      //setPalette()
-{
-  if(palette==&quot;Linrad&quot;) {
-    float twopi=6.2831853;
-    float r,g,b,phi,x;
-    for(int i=0; i&lt;256; i++) {
-      r=0.0;
-      if(i&gt;105 and i&lt;=198) {
-        phi=(twopi/4.0) * (i-105.0)/(198.0-105.0);
-        r=sin(phi);
-      } else if(i&gt;=198) {
-          r=1.0;
-      }
-
-      g=0.0;
-      if(i&gt;35 and i&lt;198) {
-        phi=(twopi/4.0) * (i-35.0)/(122.5-35.0);
-        g=0.625*sin(phi);
-      } else if(i&gt;=198) {
-        x=(i-186.0);
-        g=-0.014 + 0.0144*x -0.00007*x*x +0.000002*x*x*x;
-        if(g&gt;1.0) g=1.0;
-      }
-
-      b=0.0;
-      if(i&lt;=117) {
-        phi=(twopi/2.0) * i/117.0;
-        b=0.4531*sin(phi);
-      } else if(i&gt;186) {
-        x=(i-186.0);
-        b=-0.014 + 0.0144*x -0.00007*x*x +0.000002*x*x*x;
-        if(b&gt;1.0) b=1.0;
-      }
-      m_ColorTbl[i].setRgb(int(255.0*r),int(255.0*g),int(255.0*b));
-    }
-    m_ColorTbl[255].setRgb(255,255,100);
-
-  }
-
-  if(palette==&quot;CuteSDR&quot;) {
-      for( int i=0; i&lt;256; i++) {
-      if( (i&lt;43) )
-        m_ColorTbl[i].setRgb( 0,0, 255*(i)/43);
-      if( (i&gt;=43) &amp;&amp; (i&lt;87) )
-        m_ColorTbl[i].setRgb( 0, 255*(i-43)/43, 255 );
-      if( (i&gt;=87) &amp;&amp; (i&lt;120) )
-        m_ColorTbl[i].setRgb( 0,255, 255-(255*(i-87)/32));
-      if( (i&gt;=120) &amp;&amp; (i&lt;154) )
-        m_ColorTbl[i].setRgb( (255*(i-120)/33), 255, 0);
-      if( (i&gt;=154) &amp;&amp; (i&lt;217) )
-        m_ColorTbl[i].setRgb( 255, 255 - (255*(i-154)/62), 0);
-      if( (i&gt;=217)  )
-        m_ColorTbl[i].setRgb( 255, 0, 128*(i-217)/38);
-    }
-    m_ColorTbl[255].setRgb(255,255,100);
-  }
-
-  if(palette==&quot;Blue&quot;) {
-    FILE* fp=fopen(&quot;blue.dat&quot;,&quot;r&quot;);
-    int n,r,g,b;
-    float xr,xg,xb;
-    for(int i=0; i&lt;256; i++) {
-      fscanf(fp,&quot;%d%f%f%f&quot;,&amp;n,&amp;xr,&amp;xg,&amp;xb);
-      r=255.0*xr + 0.5;
-      g=255.0*xg + 0.5;
-      b=255.0*xb + 0.5;
-      m_ColorTbl[i].setRgb(r,g,b);
-    }
-  }
-
-  if(palette==&quot;AFMHot&quot;) {
-    FILE* fp=fopen(&quot;afmhot.dat&quot;,&quot;r&quot;);
-    int n,r,g,b;
-    float xr,xg,xb;
-    for(int i=0; i&lt;256; i++) {
-      fscanf(fp,&quot;%d%f%f%f&quot;,&amp;n,&amp;xr,&amp;xg,&amp;xb);
-      r=255.0*xr + 0.5;
-      g=255.0*xg + 0.5;
-      b=255.0*xb + 0.5;
-      m_ColorTbl[i].setRgb(r,g,b);
-    }
-  }
-
-}
-
-void CPlotter::setFsample(int n)
-{
-  m_fSample=n;
-}
-
-void CPlotter::setMode65(int n)
-{
-  m_mode65=n;
-  DrawOverlay();                         //Redraw scales and ticks
-  update();                              //trigger a new paintEvent
-}
-
-void CPlotter::set2Dspec(bool b)
-{
-  m_2Dspec=b;
-  m_paintAllZoom=!b;
-  DrawOverlay();                         //Redraw scales and ticks
-  update();                              //trigger a new paintEvent}
-}
-
-double CPlotter::fGreen()
-{
-  return m_fGreen;
-}
+#include &quot;plotter.h&quot;
+#include &lt;math.h&gt;
+#include &lt;QDebug&gt;
+
+#define MAX_SCREENSIZE 2048
+
+
+CPlotter::CPlotter(QWidget *parent) :                  //CPlotter Constructor
+  QFrame(parent)
+{
+  setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+  setFocusPolicy(Qt::StrongFocus);
+  setAttribute(Qt::WA_PaintOnScreen,false);
+  setAutoFillBackground(false);
+  setAttribute(Qt::WA_OpaquePaintEvent, false);
+  setAttribute(Qt::WA_NoSystemBackground, true);
+
+  m_StartFreq = 100;
+  m_nSpan=65;                    //Units: kHz
+  m_fSpan=(float)m_nSpan;
+  m_hdivs = HORZ_DIVS;
+  m_FreqUnits = 1;
+  m_Running = false;
+  m_paintEventBusy=false;
+  m_WaterfallPixmap = QPixmap(0,0);
+  m_ZoomWaterfallPixmap = QPixmap(0,0);
+  m_2DPixmap = QPixmap(0,0);
+  m_ScalePixmap = QPixmap(0,0);
+  m_ZoomScalePixmap = QPixmap(0,0);
+  m_Size = QSize(0,0);
+  m_fQSO = 125;
+  m_line = 0;
+  m_fSample = 96000;
+  m_paintAllZoom = false;
+}
+
+CPlotter::~CPlotter() { }                                      // Destructor
+
+QSize CPlotter::minimumSizeHint() const
+{
+  return QSize(50, 50);
+}
+
+QSize CPlotter::sizeHint() const
+{
+  return QSize(180, 180);
+}
+
+void CPlotter::resizeEvent(QResizeEvent* )                    //resizeEvent()
+{
+  if(!size().isValid()) return;
+  if( m_Size != size() ) {
+    //if changed, resize pixmaps to new screensize
+    m_Size = size();
+    int w = m_Size.width();
+    int h = (m_Size.height()-60)/2;
+    m_WaterfallPixmap = QPixmap(w,h);
+    m_ZoomWaterfallPixmap = QPixmap(w,h);
+    m_2DPixmap = QPixmap(w,h);
+    m_WaterfallPixmap.fill(Qt::black);
+    m_ZoomWaterfallPixmap.fill(Qt::black);
+    m_2DPixmap.fill(Qt::black);
+    memset(m_zwf,0,32768*h);
+    m_ScalePixmap = QPixmap(w,30);
+    m_ZoomScalePixmap = QPixmap(w,30);    //(no change on resize...)
+    m_ScalePixmap.fill(Qt::white);
+    m_ZoomScalePixmap.fill(Qt::yellow);
+  }
+  SetCenterFreq(-1);
+  DrawOverlay();
+}
+
+void CPlotter::paintEvent(QPaintEvent *)                    // paintEvent()
+{
+  static int x00=-99;
+  int ihr,imin;
+
+  if(m_paintEventBusy) return;
+  m_paintEventBusy=true;
+  QPainter painter(this);
+  int w = m_Size.width();
+  int h = (m_Size.height()-60)/2;
+  painter.drawPixmap(0,0,m_ScalePixmap);
+  painter.drawPixmap(0,30,m_WaterfallPixmap);
+  if(m_2Dspec) {
+    painter.drawPixmap(0,h+30,m_ScalePixmap);
+    painter.drawPixmap(0,h+60,m_2DPixmap);
+    m_paintEventBusy=false;
+    return;
+  }
+
+  painter.drawPixmap(0,h+30,m_ZoomScalePixmap);
+  painter.drawPixmap(0,h+60,m_ZoomWaterfallPixmap);
+
+  QRect target(0,h+30,w,30);           // (x,y,width,height)
+  QRect source(0,0,w,30);
+  painter.drawPixmap(target,m_ZoomScalePixmap,source);
+
+  float df=m_fSample/32768.0;
+  int x0=16384 + (0.001*(m_ZoomStartFreq+m_fCal)+m_fQSO-m_nkhz+1.27046) * \
+      1000.0/df + 0.5;
+
+  QPainter painter2(&amp;m_ZoomWaterfallPixmap);
+  for(int i=0; i&lt;w; i++) {                      //Paint the top row
+    painter2.setPen(m_ColorTbl[m_zwf[x0+i]]);
+    painter2.drawPoint(i,0);
+  }
+  if(m_paintAllZoom or (x0 != x00 and x00 != -99)) {
+    // If new fQSO, paint all rows
+    int k=x0;
+    for(int j=1; j&lt;h; j++) {
+      k += 32768;
+      for(int i=0; i&lt;w; i++) {
+        painter2.setPen(m_ColorTbl[m_zwf[i+k]]);
+        painter2.drawPoint(i,j);
+      }
+      if(j == 15) {
+        painter2.setPen(m_ColorTbl[255]);
+        painter2.drawText(5,10,m_sutc);
+      }
+    }
+  } else if(m_line == 15) {
+    painter2.setPen(m_ColorTbl[255]);
+    UTCstr();
+    painter2.drawText(5,10,m_sutc);
+  }
+  m_paintAllZoom=false;
+  x00=x0;
+
+  QRect target2(0,h+60,w,h);           // (x,y,width,height)
+  QRect source2(0,0,w,h);
+  painter.drawPixmap(target2,m_ZoomWaterfallPixmap,source2);
+  m_paintEventBusy=false;
+}
+
+void CPlotter::draw(float s[], int i0, float splot[])                       //draw()
+{
+  int i,j,k,w,h;
+  int ihr,imin;
+  float y;
+
+  m_i0=i0;
+  w = m_WaterfallPixmap.width();
+  h = m_WaterfallPixmap.height();
+  double gain = pow(10.0,0.05*(m_plotGain+7));
+
+  //move current data down one line
+  //(must do this before attaching a QPainter object)
+  m_WaterfallPixmap.scroll(0,1,0,0,w,h);
+  m_ZoomWaterfallPixmap.scroll(0,1,0,0, w, h);
+  memmove(&amp;m_zwf[32768],m_zwf,32768*(h-1));
+  QPainter painter1(&amp;m_WaterfallPixmap);
+  QPainter painter2D(&amp;m_2DPixmap);
+
+  for(i=0; i&lt;256; i++) {                     //Zero the histograms
+    m_hist1[i]=0;
+    m_hist2[i]=0;
+  }
+
+  painter2D.setPen(Qt::green);
+  QRect tmp(0,0,w,h);
+  painter2D.fillRect(tmp,Qt::black);
+  QPoint LineBuf[MAX_SCREENSIZE];
+  j=0;
+  bool strong0=false;
+  bool strong=false;
+
+  for(i=0; i&lt;w; i++) {
+    strong=false;
+    if(s[i]&lt;0) {
+      strong=true;
+      s[i]=-s[i];
+    }
+    y = 10.0*log10(s[i]);
+    int y1 = 5.0*gain*(y + 29 -m_plotZero);
+    if (y1&lt;0) y1=0;
+    if (y1&gt;254) y1=254;
+    if (s[i]&gt;1.e29) y1=255;
+    m_hist1[y1]++;
+    painter1.setPen(m_ColorTbl[y1]);
+    painter1.drawPoint(i,0);
+    if(m_2Dspec) {
+      int y2 = gain*(y + 34 -m_plotZero);
+      if (y2&lt;0) y2=0;
+      if (y2&gt;254) y2=254;
+      if (s[i]&gt;1.e29) y2=255;
+      if(strong != strong0 or i==w-1) {
+        painter2D.drawPolyline(LineBuf,j);
+        j=0;
+        strong0=strong;
+        if(strong0) painter2D.setPen(Qt::red);
+        if(!strong0) painter2D.setPen(Qt::green);
+      }
+      LineBuf[j].setX(i);
+      LineBuf[j].setY(h-y2);
+      j++;
+    }
+  }
+
+  for(i=0; i&lt;32768; i++) {
+    y = 10.0*log10(splot[i]);
+    int y1 = 5.0*gain*(y + 30 - m_plotZero);
+    if (y1&lt;0) y1=0;
+    if (y1&gt;254) y1=254;
+    if (splot[i]&gt;1.e29) y1=255;
+    m_hist2[y1]++;
+    m_zwf[i]=y1;
+  }
+
+  if(s[0]&gt;1.0e29) m_line=0;
+  m_line++;
+  if(m_line == 15) {
+    UTCstr();
+    painter1.setPen(m_ColorTbl[255]);
+    painter1.drawText(5,10,m_sutc);
+  }
+  update();                              //trigger a new paintEvent
+}
+
+void CPlotter::UTCstr()
+{
+  int ihr,imin;
+  if(datcom_.ndiskdat != 0) {
+    ihr=datcom_.nutc/100;
+    imin=datcom_.nutc%100;
+  } else {
+    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
+    imin=ms/60000;
+    ihr=imin/60;
+    imin=imin % 60;
+  }
+  sprintf(m_sutc,&quot;%2.2d:%2.2d&quot;,ihr,imin);
+}
+
+void CPlotter::DrawOverlay()                                 //DrawOverlay()
+{
+  if(m_WaterfallPixmap.isNull()) return;
+  int w = m_WaterfallPixmap.width();
+  int x,y;
+  float pixperdiv;
+
+  QRect rect0;
+  QPainter painter0(&amp;m_ScalePixmap);
+  painter0.initFrom(this);
+
+  //create Font to use for scales
+  QFont Font(&quot;Arial&quot;);
+  Font.setPointSize(12);
+  QFontMetrics metrics(Font);
+  Font.setWeight(QFont::Normal);
+  painter0.setFont(Font);
+  painter0.setPen(Qt::black);
+
+  m_binsPerPixel = m_nSpan * 32768.0/(w*0.001*m_fSample) + 0.5;
+  double FreqPerDiv=5.0;
+  double df = m_binsPerPixel*0.001*m_fSample/32768.0;
+  m_hdivs = w*df/FreqPerDiv + 0.9999;
+  m_fSpan = w*df;
+  m_ScalePixmap.fill(Qt::white);
+  painter0.drawRect(0, 0, w, 30);
+
+  //draw tick marks on wideband (upper) scale
+  pixperdiv = FreqPerDiv/df;
+  for( int i=1; i&lt;m_hdivs; i++) {     //major ticks
+    x = (int)( (float)i*pixperdiv );
+    painter0.drawLine(x,18,x,30);
+  }
+  for( int i=1; i&lt;5*m_hdivs; i++) {   //minor ticks
+    x = i*pixperdiv/5.0;
+    painter0.drawLine(x,24,x,30);
+  }
+
+  //draw frequency values
+  MakeFrequencyStrs();
+  for( int i=0; i&lt;=m_hdivs; i++) {
+    if(0==i) {
+      //left justify the leftmost text
+      x = (int)( (float)i*pixperdiv);
+      rect0.setRect(x,0, (int)pixperdiv, 20);
+      painter0.drawText(rect0, Qt::AlignLeft|Qt::AlignVCenter,
+                       m_HDivText[i]);
+    }
+    else if(m_hdivs == i) {
+      //right justify the rightmost text
+      x = (int)( (float)i*pixperdiv - pixperdiv);
+      rect0.setRect(x,0, (int)pixperdiv, 20);
+      painter0.drawText(rect0, Qt::AlignRight|Qt::AlignVCenter,
+                       m_HDivText[i]);
+    } else {
+      //center justify the rest of the text
+      x = (int)( (float)i*pixperdiv - pixperdiv/2);
+      rect0.setRect(x,0, (int)pixperdiv, 20);
+      painter0.drawText(rect0, Qt::AlignHCenter|Qt::AlignVCenter,
+                       m_HDivText[i]);
+    }
+  }
+
+
+  if(m_2Dspec) {
+    QPen pen0(Qt::green, 3);                 //Mark Cal Freq with green tick
+    painter0.setPen(pen0);
+    x = m_xClick;
+    painter0.drawLine(x,15,x,30);
+    int x0=(16384-m_i0)/m_binsPerPixel;
+    m_fGreen=(x-x0)*df;
+    x0 += (x0-x);
+    QPen pen3(Qt::red, 3);
+    painter0.setPen(pen3);
+    if(x0&gt;0 and x0&lt;w) painter0.drawLine(x0,15,x0,30);
+  } else {
+    QPen pen0(Qt::green, 3);                 //Mark fQSO with green tick
+    painter0.setPen(pen0);
+    x = XfromFreq(float(fQSO()));
+    painter0.drawLine(x,15,x,30);
+  }
+
+  // Now make the zoomed scale, using m_ZoomScalePixmap and painter3
+  QRect rect1;
+  QPainter painter3(&amp;m_ZoomScalePixmap);
+  painter3.initFrom(this);
+  painter3.setFont(Font);
+  painter3.setPen(Qt::black);
+
+  FreqPerDiv=0.2;
+  df = 0.001*m_fSample/32768.0;
+  m_hdivs = 32768*df/FreqPerDiv + 0.9999;
+  int nlabs=df*w/0.2 + 1.0;
+  m_ZoomScalePixmap.fill(Qt::white);
+  painter3.drawRect(0, 0, w, 30);
+
+  pixperdiv = FreqPerDiv/df;
+  for( int i=0; i&lt;10*nlabs; i++) {
+    x = i*pixperdiv/10;
+    y=24;
+    if ((i%5) == 0) y=18;
+    painter3.drawLine(x,y,x,30);
+  }
+
+  //draw frequency values
+  MakeFrequencyStrs();
+  for( int i=0; i&lt;=nlabs; i++) {
+    x = (int)( (float)i*pixperdiv - pixperdiv/2);
+    rect1.setRect(x,0, (int)pixperdiv, 20);
+    painter3.drawText(rect1, Qt::AlignHCenter|Qt::AlignVCenter,
+                      m_HDivText[i]);
+  }
+
+  df=m_fSample/32768.0;
+  x = (m_DF + m_mode65*66*11025.0/4096.0 - m_ZoomStartFreq)/df;
+  QPen pen2(Qt::red, 3);            //Mark top JT65B tone with red tick
+  painter3.setPen(pen2);
+  painter3.drawLine(x,15,x,30);
+  x = (m_DF - m_ZoomStartFreq)/df;
+  QPen pen1(Qt::green, 3);                //Mark DF with a green tick
+  painter3.setPen(pen1);
+  painter3.drawLine(x,15,x,30);
+  for(int i=2; i&lt;5; i++) {                //Mark the shorthand freqs
+    x = (m_DF + m_mode65*10*i*11025.0/4096.0 - m_ZoomStartFreq)/df;
+    painter3.drawLine(x,20,x,30);
+  }
+  int x1=(m_DF - m_tol - m_ZoomStartFreq)/df;
+  int x2=(m_DF + m_tol - m_ZoomStartFreq)/df;
+  pen1.setWidth(6);
+  painter3.drawLine(x1,28,x2,28);
+}
+
+void CPlotter::MakeFrequencyStrs()                       //MakeFrequencyStrs
+{
+  float StartFreq = m_StartFreq;
+  float freq;
+  int i,j;
+  int FreqPerDiv=5;
+
+  if(m_hdivs &gt; 100) {
+    m_FreqUnits = 1;
+    FreqPerDiv = 200;
+    int w = m_WaterfallPixmap.width();
+    float df=m_fSample/32768.0;
+    StartFreq = -w*df/2;
+    int n=StartFreq/FreqPerDiv;
+    StartFreq=n*200;
+    m_ZoomStartFreq = (int)StartFreq;
+  }
+  int numfractdigits = (int)log10((double)m_FreqUnits);
+
+  if(1 == m_FreqUnits) {
+    //if units is Hz then just output integer freq
+    for(int i=0; i&lt;=m_hdivs; i++) {
+      freq = StartFreq/(float)m_FreqUnits;
+      m_HDivText[i].setNum((int)freq);
+      StartFreq += FreqPerDiv;
+    }
+    return;
+  }
+  //here if is fractional frequency values
+  //so create max sized text based on frequency units
+  for(int i=0; i&lt;=m_hdivs; i++) {
+    freq = StartFreq/(float)m_FreqUnits;
+    m_HDivText[i].setNum(freq,'f', numfractdigits);
+    StartFreq += FreqPerDiv;
+  }
+  //now find the division text with the longest non-zero digit
+  //to the right of the decimal point.
+  int max = 0;
+  for(i=0; i&lt;=m_hdivs; i++) {
+    int dp = m_HDivText[i].indexOf('.');
+    int l = m_HDivText[i].length()-1;
+    for(j=l; j&gt;dp; j--) {
+      if(m_HDivText[i][j] != '0')
+        break;
+    }
+    if( (j-dp) &gt; max)
+      max = j-dp;
+  }
+  //truncate all strings to maximum fractional length
+  StartFreq = m_CenterFreq - 0.5*m_fSpan;
+  for( i=0; i&lt;=m_hdivs; i++) {
+    freq = (float)StartFreq/(float)m_FreqUnits;
+    m_HDivText[i].setNum(freq,'f', max);
+    StartFreq += FreqPerDiv;
+  }
+}
+
+int CPlotter::XfromFreq(float f)                               //XfromFreq()
+{
+  float w = m_WaterfallPixmap.width();
+  int x = (int) w * (f - m_StartFreq)/m_fSpan;
+  if(x&lt;0 ) return 0;
+  if(x&gt;(int)w) return m_WaterfallPixmap.width();
+  return x;
+}
+
+float CPlotter::FreqfromX(int x)                               //FreqfromX()
+{
+  float w = m_WaterfallPixmap.width();
+  float f =m_CenterFreq - 0.5*m_fSpan + m_fSpan * x/w;
+  return f;
+}
+
+void CPlotter::SetRunningState(bool running)              //SetRunningState()
+{
+  m_Running = running;
+}
+
+void CPlotter::setPlotZero(int plotZero)                  //setPlotZero()
+{
+  m_plotZero=plotZero;
+}
+
+int CPlotter::getPlotZero()                               //getPlotZero()
+{
+  return m_plotZero;
+}
+
+void CPlotter::setPlotGain(int plotGain)                  //setPlotGain()
+{
+  m_plotGain=plotGain;
+}
+
+int CPlotter::getPlotGain()                               //getPlotGain()
+{
+  return m_plotGain;
+}
+
+void CPlotter::SetCenterFreq(int f)                   //setCenterFreq()
+{
+// f is the integer kHz portion of cfreq, from Linrad packets
+  if(f&lt;0) f=m_nkhz;
+  int ns = (f+m_FreqOffset-0.5*m_fSpan)/5.0 + 0.5;
+  double fs = 5*ns;
+  m_CenterFreq = fs + 0.5*m_fSpan;
+}
+
+qint64 CPlotter::centerFreq()                             //centerFreq()
+{
+  return m_CenterFreq;
+}
+
+void CPlotter::SetStartFreq(quint64 f)                    //SetStartFreq()
+{
+  m_StartFreq=f;
+//    resizeEvent(NULL);
+  DrawOverlay();
+}
+
+qint64 CPlotter::startFreq()                              //startFreq()
+{
+  return m_StartFreq;
+}
+
+void CPlotter::SetFreqOffset(quint64 f)                   //SetFreqOffset()
+{
+  m_FreqOffset=f;
+  DrawOverlay();
+}
+
+qint64 CPlotter::freqOffset() {return m_FreqOffset;}         //freqOffset()
+int CPlotter::plotWidth(){return m_WaterfallPixmap.width();}
+void CPlotter::UpdateOverlay() {DrawOverlay();}
+void CPlotter::setDataFromDisk(bool b) {m_dataFromDisk=b;}
+
+void CPlotter::setTol(int n)                                 //setTol()
+{
+  m_tol=n;
+  DrawOverlay();
+}
+
+void CPlotter::setBinsPerPixel(int n) {m_binsPerPixel = n;}  //set nbpp
+
+int CPlotter::binsPerPixel(){return m_binsPerPixel;}         //get nbpp
+
+void CPlotter::setFQSO(int x, bool bf)                       //setFQSO()
+{
+  if(bf) {
+    m_fQSO=x;         // x is freq in kHz
+  } else {
+    if(x&lt;0) x=0;      // x is pixel number
+    if(x&gt;m_Size.width()) x=m_Size.width();
+    m_fQSO = int(FreqfromX(x)+0.5);
+    m_xClick=x;
+  }
+  DrawOverlay();
+  update();
+}
+
+void CPlotter::setFcal(int n)                                  //setFcal()
+{
+  m_fCal=n;
+}
+
+void CPlotter::setNkhz(int n)                                  //setNkhz()
+{
+  m_nkhz=n;
+}
+
+int CPlotter::fQSO() {return m_fQSO;}                          //get fQSO
+
+int CPlotter::DF() {return m_DF;}                              // get DF
+
+void CPlotter::mousePressEvent(QMouseEvent *event)       //mousePressEvent
+{
+  int h = (m_Size.height()-60)/2;
+  int x=event-&gt;x();
+  int y=event-&gt;y();
+  if(y &lt; h+30) {
+    setFQSO(x,false);                               // Wideband waterfall
+  } else {
+    m_DF=int(m_ZoomStartFreq + x*m_fSample/32768.0);  // Zoomed waterfall
+    DrawOverlay();
+    update();
+  }
+}
+
+void CPlotter::mouseDoubleClickEvent(QMouseEvent *event)  //mouse2click
+{
+  int h = (m_Size.height()-60)/2;
+  int x=event-&gt;x();
+  int y=event-&gt;y();
+  if(y &lt; h+30) {
+    m_DF=0;
+    setFQSO(x,false);
+    emit freezeDecode1(2);                  //### ???
+  } else {
+    float f = m_ZoomStartFreq + x*m_fSample/32768.0;
+    m_DF=int(f);
+    emit freezeDecode1(1);
+    DrawOverlay();
+  }
+}
+
+int CPlotter::autoZero()                                        //autoZero()
+{
+  m_z1=0;
+  m_z2=0;
+  int sum1=0;
+  for(int i=0; i&lt;256; i++) {
+    sum1 += m_hist1[i];
+    if(sum1 &gt; m_Size.width()/2) {
+      m_z1=i;
+      break;
+    }
+  }
+  int sum2=0;
+  for(int i=0; i&lt;256; i++) {
+    sum2 += m_hist2[i];
+    if(sum2 &gt; 16384) {
+      m_z2=i;
+      break;
+    }
+  }
+  double gain = pow(10.0,0.05*(m_plotGain+7));
+//  double dz1 = (m_z1-38)/(5.0*gain);
+  double dz2 = (m_z2-28)/(5.0*gain);
+  if(m_z2 &lt; 255) m_plotZero = int(m_plotZero + dz2 + 0.5);
+  return m_plotZero;
+}
+
+void CPlotter::setNSpan(int n)                                  //setNSpan()
+{
+  m_nSpan=n;
+}
+
+void CPlotter::setPalette(QString palette)                      //setPalette()
+{
+  if(palette==&quot;Linrad&quot;) {
+    float twopi=6.2831853;
+    float r,g,b,phi,x;
+    for(int i=0; i&lt;256; i++) {
+      r=0.0;
+      if(i&gt;105 and i&lt;=198) {
+        phi=(twopi/4.0) * (i-105.0)/(198.0-105.0);
+        r=sin(phi);
+      } else if(i&gt;=198) {
+          r=1.0;
+      }
+
+      g=0.0;
+      if(i&gt;35 and i&lt;198) {
+        phi=(twopi/4.0) * (i-35.0)/(122.5-35.0);
+        g=0.625*sin(phi);
+      } else if(i&gt;=198) {
+        x=(i-186.0);
+        g=-0.014 + 0.0144*x -0.00007*x*x +0.000002*x*x*x;
+        if(g&gt;1.0) g=1.0;
+      }
+
+      b=0.0;
+      if(i&lt;=117) {
+        phi=(twopi/2.0) * i/117.0;
+        b=0.4531*sin(phi);
+      } else if(i&gt;186) {
+        x=(i-186.0);
+        b=-0.014 + 0.0144*x -0.00007*x*x +0.000002*x*x*x;
+        if(b&gt;1.0) b=1.0;
+      }
+      m_ColorTbl[i].setRgb(int(255.0*r),int(255.0*g),int(255.0*b));
+    }
+    m_ColorTbl[255].setRgb(255,255,100);
+
+  }
+
+  if(palette==&quot;CuteSDR&quot;) {
+      for( int i=0; i&lt;256; i++) {
+      if( (i&lt;43) )
+        m_ColorTbl[i].setRgb( 0,0, 255*(i)/43);
+      if( (i&gt;=43) &amp;&amp; (i&lt;87) )
+        m_ColorTbl[i].setRgb( 0, 255*(i-43)/43, 255 );
+      if( (i&gt;=87) &amp;&amp; (i&lt;120) )
+        m_ColorTbl[i].setRgb( 0,255, 255-(255*(i-87)/32));
+      if( (i&gt;=120) &amp;&amp; (i&lt;154) )
+        m_ColorTbl[i].setRgb( (255*(i-120)/33), 255, 0);
+      if( (i&gt;=154) &amp;&amp; (i&lt;217) )
+        m_ColorTbl[i].setRgb( 255, 255 - (255*(i-154)/62), 0);
+      if( (i&gt;=217)  )
+        m_ColorTbl[i].setRgb( 255, 0, 128*(i-217)/38);
+    }
+    m_ColorTbl[255].setRgb(255,255,100);
+  }
+
+  if(palette==&quot;Blue&quot;) {
+    FILE* fp=fopen(&quot;blue.dat&quot;,&quot;r&quot;);
+    int n,r,g,b;
+    float xr,xg,xb;
+    for(int i=0; i&lt;256; i++) {
+      fscanf(fp,&quot;%d%f%f%f&quot;,&amp;n,&amp;xr,&amp;xg,&amp;xb);
+      r=255.0*xr + 0.5;
+      g=255.0*xg + 0.5;
+      b=255.0*xb + 0.5;
+      m_ColorTbl[i].setRgb(r,g,b);
+    }
+  }
+
+  if(palette==&quot;AFMHot&quot;) {
+    FILE* fp=fopen(&quot;afmhot.dat&quot;,&quot;r&quot;);
+    int n,r,g,b;
+    float xr,xg,xb;
+    for(int i=0; i&lt;256; i++) {
+      fscanf(fp,&quot;%d%f%f%f&quot;,&amp;n,&amp;xr,&amp;xg,&amp;xb);
+      r=255.0*xr + 0.5;
+      g=255.0*xg + 0.5;
+      b=255.0*xb + 0.5;
+      m_ColorTbl[i].setRgb(r,g,b);
+    }
+  }
+
+}
+
+void CPlotter::setFsample(int n)
+{
+  m_fSample=n;
+}
+
+void CPlotter::setMode65(int n)
+{
+  m_mode65=n;
+  DrawOverlay();                         //Redraw scales and ticks
+  update();                              //trigger a new paintEvent
+}
+
+void CPlotter::set2Dspec(bool b)
+{
+  m_2Dspec=b;
+  m_paintAllZoom=!b;
+  DrawOverlay();                         //Redraw scales and ticks
+  update();                              //trigger a new paintEvent}
+}
+
+double CPlotter::fGreen()
+{
+  return m_fGreen;
+}


Property changes on: branches/map65/plotter.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/plotter.h
===================================================================
--- branches/map65/plotter.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/plotter.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,127 +1,127 @@
-///////////////////////////////////////////////////////////////////////////
-// Some code in this file and accompanying files is based on work by
-// Moe Wheatley, AE4Y, released under the &quot;Simplified BSD License&quot;.
-// For more details see the accompanying file LICENSE_WHEATLEY.TXT
-///////////////////////////////////////////////////////////////////////////
-
-#ifndef PLOTTER_H
-#define PLOTTER_H
-
-#include &lt;QtGui&gt;
-#include &lt;QFrame&gt;
-#include &lt;QImage&gt;
-#include &lt;cstring&gt;
-#include &quot;commons.h&quot;
-
-#define VERT_DIVS 7	//specify grid screen divisions
-#define HORZ_DIVS 20
-
-class CPlotter : public QFrame
-{
-  Q_OBJECT
-public:
-  explicit CPlotter(QWidget *parent = 0);
-  ~CPlotter();
-
-  QSize minimumSizeHint() const;
-  QSize sizeHint() const;
-  QColor  m_ColorTbl[256];
-  int     m_plotZero;
-  int     m_plotGain;
-  float   m_fSpan;
-  qint32  m_nSpan;
-  qint32  m_binsPerPixel;
-  qint32  m_fQSO;
-  qint32  m_DF;
-  qint32  m_tol;
-  qint32  m_fCal;
-
-  void draw(float sw[], int i0, float splot[]);		//Update the waterfalls
-  void SetRunningState(bool running);
-  void setPlotZero(int plotZero);
-  int  getPlotZero();
-  void setPlotGain(int plotGain);
-  int  getPlotGain();
-  void SetCenterFreq(int f);
-  qint64 centerFreq();
-  void SetStartFreq(quint64 f);
-  qint64 startFreq();
-  void SetFreqOffset(quint64 f);
-  qint64 freqOffset();
-  int  plotWidth();
-  void setNSpan(int n);
-  void UpdateOverlay();
-  void setDataFromDisk(bool b);
-  void setTol(int n);
-  void setBinsPerPixel(int n);
-  int  binsPerPixel();
-  void setFQSO(int n, bool bf);
-  void setFcal(int n);
-  void setNkhz(int n);
-  void DrawOverlay();
-  int  fQSO();
-  int  DF();
-  int  autoZero();
-  void setPalette(QString palette);
-  void setFsample(int n);
-  void setMode65(int n);
-  void set2Dspec(bool b);
-  double fGreen();
-
-signals:
-  void freezeDecode0(int n);
-  void freezeDecode1(int n);
-
-protected:
-  //re-implemented widget event handlers
-  void paintEvent(QPaintEvent *event);
-  void resizeEvent(QResizeEvent* event);
-
-private:
-
-  void MakeFrequencyStrs();
-  void UTCstr();
-  int XfromFreq(float f);
-  float FreqfromX(int x);
-  qint64 RoundFreq(qint64 freq, int resolution);
-
-  QPixmap m_WaterfallPixmap;
-  QPixmap m_ZoomWaterfallPixmap;
-  QPixmap m_2DPixmap;
-  unsigned char m_zwf[32768*400];
-  QPixmap m_ScalePixmap;
-  QPixmap m_ZoomScalePixmap;
-  QSize   m_Size;
-  QString m_Str;
-  QString m_HDivText[483];
-  bool    m_Running;
-  bool    m_paintEventBusy;
-  bool    m_2Dspec;
-  bool    m_paintAllZoom;
-  double  m_CenterFreq;
-  double  m_fGreen;
-  qint64  m_StartFreq;
-  qint64  m_ZoomStartFreq;
-  qint64  m_FreqOffset;
-  qint32  m_dBStepSize;
-  qint32  m_FreqUnits;
-  qint32  m_hdivs;
-  bool    m_dataFromDisk;
-  char    m_sutc[5];
-  qint32  m_line;
-  qint32  m_hist1[256];
-  qint32  m_hist2[256];
-  qint32  m_z1;
-  qint32  m_z2;
-  qint32  m_nkhz;
-  qint32  m_fSample;
-  qint32  m_mode65;
-  qint32  m_i0;
-  qint32  m_xClick;
-
-private slots:
-  void mousePressEvent(QMouseEvent *event);
-  void mouseDoubleClickEvent(QMouseEvent *event);
-};
-
-#endif // PLOTTER_H
+///////////////////////////////////////////////////////////////////////////
+// Some code in this file and accompanying files is based on work by
+// Moe Wheatley, AE4Y, released under the &quot;Simplified BSD License&quot;.
+// For more details see the accompanying file LICENSE_WHEATLEY.TXT
+///////////////////////////////////////////////////////////////////////////
+
+#ifndef PLOTTER_H
+#define PLOTTER_H
+
+#include &lt;QtGui&gt;
+#include &lt;QFrame&gt;
+#include &lt;QImage&gt;
+#include &lt;cstring&gt;
+#include &quot;commons.h&quot;
+
+#define VERT_DIVS 7	//specify grid screen divisions
+#define HORZ_DIVS 20
+
+class CPlotter : public QFrame
+{
+  Q_OBJECT
+public:
+  explicit CPlotter(QWidget *parent = 0);
+  ~CPlotter();
+
+  QSize minimumSizeHint() const;
+  QSize sizeHint() const;
+  QColor  m_ColorTbl[256];
+  int     m_plotZero;
+  int     m_plotGain;
+  float   m_fSpan;
+  qint32  m_nSpan;
+  qint32  m_binsPerPixel;
+  qint32  m_fQSO;
+  qint32  m_DF;
+  qint32  m_tol;
+  qint32  m_fCal;
+
+  void draw(float sw[], int i0, float splot[]);		//Update the waterfalls
+  void SetRunningState(bool running);
+  void setPlotZero(int plotZero);
+  int  getPlotZero();
+  void setPlotGain(int plotGain);
+  int  getPlotGain();
+  void SetCenterFreq(int f);
+  qint64 centerFreq();
+  void SetStartFreq(quint64 f);
+  qint64 startFreq();
+  void SetFreqOffset(quint64 f);
+  qint64 freqOffset();
+  int  plotWidth();
+  void setNSpan(int n);
+  void UpdateOverlay();
+  void setDataFromDisk(bool b);
+  void setTol(int n);
+  void setBinsPerPixel(int n);
+  int  binsPerPixel();
+  void setFQSO(int n, bool bf);
+  void setFcal(int n);
+  void setNkhz(int n);
+  void DrawOverlay();
+  int  fQSO();
+  int  DF();
+  int  autoZero();
+  void setPalette(QString palette);
+  void setFsample(int n);
+  void setMode65(int n);
+  void set2Dspec(bool b);
+  double fGreen();
+
+signals:
+  void freezeDecode0(int n);
+  void freezeDecode1(int n);
+
+protected:
+  //re-implemented widget event handlers
+  void paintEvent(QPaintEvent *event);
+  void resizeEvent(QResizeEvent* event);
+
+private:
+
+  void MakeFrequencyStrs();
+  void UTCstr();
+  int XfromFreq(float f);
+  float FreqfromX(int x);
+  qint64 RoundFreq(qint64 freq, int resolution);
+
+  QPixmap m_WaterfallPixmap;
+  QPixmap m_ZoomWaterfallPixmap;
+  QPixmap m_2DPixmap;
+  unsigned char m_zwf[32768*400];
+  QPixmap m_ScalePixmap;
+  QPixmap m_ZoomScalePixmap;
+  QSize   m_Size;
+  QString m_Str;
+  QString m_HDivText[483];
+  bool    m_Running;
+  bool    m_paintEventBusy;
+  bool    m_2Dspec;
+  bool    m_paintAllZoom;
+  double  m_CenterFreq;
+  double  m_fGreen;
+  qint64  m_StartFreq;
+  qint64  m_ZoomStartFreq;
+  qint64  m_FreqOffset;
+  qint32  m_dBStepSize;
+  qint32  m_FreqUnits;
+  qint32  m_hdivs;
+  bool    m_dataFromDisk;
+  char    m_sutc[5];
+  qint32  m_line;
+  qint32  m_hist1[256];
+  qint32  m_hist2[256];
+  qint32  m_z1;
+  qint32  m_z2;
+  qint32  m_nkhz;
+  qint32  m_fSample;
+  qint32  m_mode65;
+  qint32  m_i0;
+  qint32  m_xClick;
+
+private slots:
+  void mousePressEvent(QMouseEvent *event);
+  void mouseDoubleClickEvent(QMouseEvent *event);
+};
+
+#endif // PLOTTER_H


Property changes on: branches/map65/plotter.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/set570.cpp
===================================================================
--- branches/map65/set570.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/set570.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,275 +1,275 @@
-
-/*   Linux / Windows program to control the frequency of a si570 synthesizer
-     ON5GN  6 jan 2012
-     Under Linux:
-       -use the linux version of function void si570_sleep(int us)
-       -compile with
-        gcc -Wall -o set_si570_freq set_si570_freq.c -lusb -lm
-       -run with sudo ./set_si570_freq
-     Under Windows:
-       -use the windows version of function void si570_sleep(int us)
-       -compile with mingw
-        C:\mingw\bin\mingw32-gcc -Wall -o set_si570_freq set_si570_freq.c -lusb -lm
-       -run with  set_si570_freq.exe
-*/
-
-#include &lt;stdio.h&gt;   /* Standard input/output definitions */
-#include &lt;string.h&gt;  /* String function definitions */
-#include &lt;unistd.h&gt;  /* UNIX standard function definitions */
-#include &lt;sys/time.h&gt;
-#include &lt;usb.h&gt;
-#include &lt;QDebug&gt;
-
-#define USB_SUCCESS	            0
-#define USB_ERROR_NOTFOUND      1
-#define USB_ERROR_ACCESS        2
-#define USB_ERROR_IO            3
-#define VENDOR_NAME	            &quot;www.obdev.at&quot;
-#define PRODUCT_NAME            &quot;DG8SAQ-I2C&quot;
-#define USBDEV_SHARED_VENDOR    0x16C0  // VOTI  VID
-#define USBDEV_SHARED_PRODUCT   0x05DC  // OBDEV PID
-                                     // Use obdev's generic shared VID/PID pair
-                                     // following the rules outlined in
-                                     // firmware/usbdrv/USBID-License.txt.
-#define REQUEST_SET_FREQ_BY_VALUE 0x32
-#define MAX_USB_ERR_CNT         6
-
-double freq_parm;
-double delay_average;
-int  from_freq;
-int  to_freq;
-int  increment_freq;
-int  retval = -1;
-int  display_freq = -1;
-int  delay;
-usb_dev_handle  *global_si570usb_handle = NULL;
-
-// ********sleep functions***************
-//use this function  under LINUX
-/*
-void si570_sleep(int us)
-{
-usleep(us);
-}
-*/
-
-//use this function under WINDOWS
-void si570_sleep(int us)
-{
-  Sleep(us/1000);
-}
-
-double round(double x)
-{
-  int i=x+0.5;
-  return (double)i;
-}
-
-double current_time(void) //for delay measurements
-{
-  struct timeval t;
-  gettimeofday(&amp;t,NULL);
-  return 0.000001*t.tv_usec+t.tv_sec;
-}
-
-int  usbGetStringAscii(usb_dev_handle *dev, int my_index,
-               int langid, char *buf, int buflen);
-unsigned char Si570usbOpenDevice(usb_dev_handle **device, char *usbSerialID);
-void setLongWord( int value, char * bytes);
-int setFreqByValue(usb_dev_handle * handle, double frequency);
-void sweepa_freq(void);
-void sweepm_freq(void);
-
-int set570(double freq_MHz)
-{
-  char * my_usbSerialID = NULL;
-
-// MAIN MENU DIALOG
-  retval=Si570usbOpenDevice(&amp;global_si570usb_handle, my_usbSerialID);
-  if (retval != 0) return -1;
-
-//SET FREQUENCY
-  if((freq_MHz &lt; 3.45)|(freq_MHz &gt; 866.0)) return -2;
-  retval=setFreqByValue(global_si570usb_handle,freq_MHz);
-  return 0;
-}
-
-int  usbGetStringAscii(usb_dev_handle *dev, int my_index,
-                       int langid, char *buf, int buflen)
-{
-  char    buffer[256];
-  int     rval, i;
-  if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR,
-     (USB_DT_STRING &lt;&lt; 8) + my_index, langid, buffer,
-     sizeof(buffer), 1000)) &lt; 0) return rval;
-  if(buffer[1] != USB_DT_STRING)  return 0;
-  if((unsigned char)buffer[0] &lt; rval) rval = (unsigned char)buffer[0];
-  rval /= 2;
-// lossy conversion to ISO Latin1
-  for(i=1;i&lt;rval;i++) {
-    if(i &gt; buflen) break;                       // destination buffer overflow
-    buf[i-1] = buffer[2 * i];
-    if(buffer[2 * i + 1] != 0)  buf[i-1] = '?'; // outside of ISO Latin1 range
-  }
-  buf[i-1] = 0;
-  return i-1;
-}
-
-unsigned char Si570usbOpenDevice(usb_dev_handle **device, char *usbSerialID)
-{
-  struct usb_bus      *bus;
-  struct usb_device   *dev;
-  usb_dev_handle      *handle = NULL;
-  unsigned char       errorCode = USB_ERROR_NOTFOUND;
-  char                string[256];
-  int                 len;
-  int  vendor        = USBDEV_SHARED_VENDOR;
-  char *vendorName   = VENDOR_NAME;
-  int  product       = USBDEV_SHARED_PRODUCT;
-  char *productName  = PRODUCT_NAME;
-  char serialNumberString[20];
-  static int  didUsbInit = 0;
-
-  if(!didUsbInit) {
-    didUsbInit = 1;
-    usb_init();
-  }
-  usb_find_busses();
-  usb_find_devices();
-  for(bus=usb_get_busses(); bus; bus=bus-&gt;next) {
-    for(dev=bus-&gt;devices; dev; dev=dev-&gt;next) {
-      if(dev-&gt;descriptor.idVendor == vendor &amp;&amp;
-     dev-&gt;descriptor.idProduct == product) {
-        handle = usb_open(dev); // open the device in order to query strings
-        if(!handle) {
-          errorCode = USB_ERROR_ACCESS;
-          printf(&quot;si570.c: Warning: cannot open Si570-USB device:\n&quot;);
-          printf(&quot;usb error message: %s\n&quot;,usb_strerror());
-          continue;
-    }
-        if(vendorName == NULL &amp;&amp; productName == NULL) {  //name does not matter
-          break;
-    }
-        // now check whether the names match
-        len = usbGetStringAscii(handle, dev-&gt;descriptor.iManufacturer, 0x0409, string, sizeof(string));
-        if(len &lt; 0) {
-          errorCode = USB_ERROR_IO;
-          printf(&quot;si570.c: Warning: cannot query manufacturer for Si570-USB device:\n&quot;);
-          printf(&quot;usb error message: %s\n&quot;,usb_strerror());
-    } else {
-          errorCode = USB_ERROR_NOTFOUND;
-           //fprintf(stderr, &quot;seen device from vendor -&gt;%s&lt;-\n&quot;, string);
-          if(strcmp(string, vendorName) == 0){
-            len = usbGetStringAscii(handle, dev-&gt;descriptor.iProduct,
-                    0x0409, string, sizeof(string));
-            if(len &lt; 0) {
-              errorCode = USB_ERROR_IO;
-              printf(&quot;si570.c: Warning: cannot query product for Si570-USB device: \n&quot;);
-              printf(&quot;usb error message: %s\n&quot;,usb_strerror());
-        } else {
-              errorCode = USB_ERROR_NOTFOUND;
-              // fprintf(stderr, &quot;seen product -&gt;%s&lt;-\n&quot;, string);
-              if(strcmp(string, productName) == 0) {
-        len = usbGetStringAscii(handle, dev-&gt;descriptor.iSerialNumber,
-             0x0409, serialNumberString, sizeof(serialNumberString));
-        if (len &lt; 0) {
-          errorCode = USB_ERROR_IO;
-          printf(&quot;si570.c: Warning: cannot query serial number for Si570-USB device: \n&quot;);
-                  printf(&quot;usb error message: %s\n&quot;,usb_strerror());
-        } else {
-          errorCode = USB_ERROR_NOTFOUND;
-          if ((usbSerialID == NULL) ||
-              (strcmp(serialNumberString, usbSerialID) == 0)) {
-//                    printf(&quot;\nOpen Si570 USB device: OK\n&quot;);
-//                    printf(&quot;usbSerialID          : %s\n&quot;,serialNumberString);
-            break;
-          }
-        }
-          }
-        }
-      }
-    }
-        usb_close(handle);
-        handle = NULL;
-      }
-    }
-    if(handle) break;
-  }
-  if(handle != NULL) {
-    errorCode = USB_SUCCESS;
-    *device = handle;
-  }
-  return errorCode;
-}
-
-void setLongWord( int value, char * bytes)
-{
-  bytes[0] = value &amp; 0xff;
-  bytes[1] = ((value &amp; 0xff00) &gt;&gt; 8) &amp; 0xff;
-  bytes[2] = ((value &amp; 0xff0000) &gt;&gt; 16) &amp; 0xff;
-  bytes[3] = ((value &amp; 0xff000000) &gt;&gt; 24) &amp; 0xff;
-}
-
-int setFreqByValue(usb_dev_handle * handle, double frequency)
-{
-// Windows Doc from PE0FKO:
-//
-// Command 0x32:
-// -------------
-// Set the oscillator frequency by value. The frequency is formatted in MHz
-// as 11.21 bits value.
-// The &quot;automatic band pass filter selection&quot;, &quot;smooth tune&quot;,
-// &quot;one side calibration&quot; and the &quot;frequency subtract multiply&quot; are all
-// done in this function. (if enabled in the firmware)
-//
-// Default:    None
-//
-// Parameters:
-//     requesttype:    USB_ENDPOINT_OUT
-//     request:         0x32
-//     value:           0
-//     index:           0
-//     bytes:           pointer 32 bits integer
-//     size:            4
-//
-// Code sample:
-//     uint32_t iFreq;
-//     double   dFreq;
-//
-//     dFreq = 30.123456; // MHz
-//     iFreq = (uint32_t)( dFreq * (1UL &lt;&lt; 21) )
-//     r = usbCtrlMsgOUT(0x32, 0, 0, (char *)&amp;iFreq, sizeof(iFreq));
-//     if (r &lt; 0) Error
-//
-
-  char   buffer[4];
-  int  i2cAddress = 0x55;
-  int    request = REQUEST_SET_FREQ_BY_VALUE;
-  int    value = 0x700 + i2cAddress;
-  int    my_index = 0;
-  int    retval;
-  int    err_cnt;
-
-  err_cnt =0;
- set_again:;
-  setLongWord(round(frequency * 2097152.0), buffer);  //   2097152=2^21
-  retval=usb_control_msg(
-         handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT,
-         request,
-         value,
-         my_index,
-         buffer,
-         sizeof(buffer),
-         5000);
-  if (retval != 4) {
-    err_cnt ++;
-    if(err_cnt &lt; MAX_USB_ERR_CNT) {
-      si570_sleep(1000);          // delay 1000 microsec
-      goto set_again;
-    } else {
-      printf(&quot;Error when setting frequency, returncode=%i\n&quot;,retval);
-      printf(&quot;usb error message: %s\n&quot;, usb_strerror());
-    }
-  }
-  return retval;
-}
+
+/*   Linux / Windows program to control the frequency of a si570 synthesizer
+     ON5GN  6 jan 2012
+     Under Linux:
+       -use the linux version of function void si570_sleep(int us)
+       -compile with
+        gcc -Wall -o set_si570_freq set_si570_freq.c -lusb -lm
+       -run with sudo ./set_si570_freq
+     Under Windows:
+       -use the windows version of function void si570_sleep(int us)
+       -compile with mingw
+        C:\mingw\bin\mingw32-gcc -Wall -o set_si570_freq set_si570_freq.c -lusb -lm
+       -run with  set_si570_freq.exe
+*/
+
+#include &lt;stdio.h&gt;   /* Standard input/output definitions */
+#include &lt;string.h&gt;  /* String function definitions */
+#include &lt;unistd.h&gt;  /* UNIX standard function definitions */
+#include &lt;sys/time.h&gt;
+#include &lt;usb.h&gt;
+#include &lt;QDebug&gt;
+
+#define USB_SUCCESS	            0
+#define USB_ERROR_NOTFOUND      1
+#define USB_ERROR_ACCESS        2
+#define USB_ERROR_IO            3
+#define VENDOR_NAME	            &quot;www.obdev.at&quot;
+#define PRODUCT_NAME            &quot;DG8SAQ-I2C&quot;
+#define USBDEV_SHARED_VENDOR    0x16C0  // VOTI  VID
+#define USBDEV_SHARED_PRODUCT   0x05DC  // OBDEV PID
+                                     // Use obdev's generic shared VID/PID pair
+                                     // following the rules outlined in
+                                     // firmware/usbdrv/USBID-License.txt.
+#define REQUEST_SET_FREQ_BY_VALUE 0x32
+#define MAX_USB_ERR_CNT         6
+
+double freq_parm;
+double delay_average;
+int  from_freq;
+int  to_freq;
+int  increment_freq;
+int  retval = -1;
+int  display_freq = -1;
+int  delay;
+usb_dev_handle  *global_si570usb_handle = NULL;
+
+// ********sleep functions***************
+//use this function  under LINUX
+/*
+void si570_sleep(int us)
+{
+usleep(us);
+}
+*/
+
+//use this function under WINDOWS
+void si570_sleep(int us)
+{
+  Sleep(us/1000);
+}
+
+double round(double x)
+{
+  int i=x+0.5;
+  return (double)i;
+}
+
+double current_time(void) //for delay measurements
+{
+  struct timeval t;
+  gettimeofday(&amp;t,NULL);
+  return 0.000001*t.tv_usec+t.tv_sec;
+}
+
+int  usbGetStringAscii(usb_dev_handle *dev, int my_index,
+               int langid, char *buf, int buflen);
+unsigned char Si570usbOpenDevice(usb_dev_handle **device, char *usbSerialID);
+void setLongWord( int value, char * bytes);
+int setFreqByValue(usb_dev_handle * handle, double frequency);
+void sweepa_freq(void);
+void sweepm_freq(void);
+
+int set570(double freq_MHz)
+{
+  char * my_usbSerialID = NULL;
+
+// MAIN MENU DIALOG
+  retval=Si570usbOpenDevice(&amp;global_si570usb_handle, my_usbSerialID);
+  if (retval != 0) return -1;
+
+//SET FREQUENCY
+  if((freq_MHz &lt; 3.45)|(freq_MHz &gt; 866.0)) return -2;
+  retval=setFreqByValue(global_si570usb_handle,freq_MHz);
+  return 0;
+}
+
+int  usbGetStringAscii(usb_dev_handle *dev, int my_index,
+                       int langid, char *buf, int buflen)
+{
+  char    buffer[256];
+  int     rval, i;
+  if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR,
+     (USB_DT_STRING &lt;&lt; 8) + my_index, langid, buffer,
+     sizeof(buffer), 1000)) &lt; 0) return rval;
+  if(buffer[1] != USB_DT_STRING)  return 0;
+  if((unsigned char)buffer[0] &lt; rval) rval = (unsigned char)buffer[0];
+  rval /= 2;
+// lossy conversion to ISO Latin1
+  for(i=1;i&lt;rval;i++) {
+    if(i &gt; buflen) break;                       // destination buffer overflow
+    buf[i-1] = buffer[2 * i];
+    if(buffer[2 * i + 1] != 0)  buf[i-1] = '?'; // outside of ISO Latin1 range
+  }
+  buf[i-1] = 0;
+  return i-1;
+}
+
+unsigned char Si570usbOpenDevice(usb_dev_handle **device, char *usbSerialID)
+{
+  struct usb_bus      *bus;
+  struct usb_device   *dev;
+  usb_dev_handle      *handle = NULL;
+  unsigned char       errorCode = USB_ERROR_NOTFOUND;
+  char                string[256];
+  int                 len;
+  int  vendor        = USBDEV_SHARED_VENDOR;
+  char *vendorName   = VENDOR_NAME;
+  int  product       = USBDEV_SHARED_PRODUCT;
+  char *productName  = PRODUCT_NAME;
+  char serialNumberString[20];
+  static int  didUsbInit = 0;
+
+  if(!didUsbInit) {
+    didUsbInit = 1;
+    usb_init();
+  }
+  usb_find_busses();
+  usb_find_devices();
+  for(bus=usb_get_busses(); bus; bus=bus-&gt;next) {
+    for(dev=bus-&gt;devices; dev; dev=dev-&gt;next) {
+      if(dev-&gt;descriptor.idVendor == vendor &amp;&amp;
+     dev-&gt;descriptor.idProduct == product) {
+        handle = usb_open(dev); // open the device in order to query strings
+        if(!handle) {
+          errorCode = USB_ERROR_ACCESS;
+          printf(&quot;si570.c: Warning: cannot open Si570-USB device:\n&quot;);
+          printf(&quot;usb error message: %s\n&quot;,usb_strerror());
+          continue;
+    }
+        if(vendorName == NULL &amp;&amp; productName == NULL) {  //name does not matter
+          break;
+    }
+        // now check whether the names match
+        len = usbGetStringAscii(handle, dev-&gt;descriptor.iManufacturer, 0x0409, string, sizeof(string));
+        if(len &lt; 0) {
+          errorCode = USB_ERROR_IO;
+          printf(&quot;si570.c: Warning: cannot query manufacturer for Si570-USB device:\n&quot;);
+          printf(&quot;usb error message: %s\n&quot;,usb_strerror());
+    } else {
+          errorCode = USB_ERROR_NOTFOUND;
+           //fprintf(stderr, &quot;seen device from vendor -&gt;%s&lt;-\n&quot;, string);
+          if(strcmp(string, vendorName) == 0){
+            len = usbGetStringAscii(handle, dev-&gt;descriptor.iProduct,
+                    0x0409, string, sizeof(string));
+            if(len &lt; 0) {
+              errorCode = USB_ERROR_IO;
+              printf(&quot;si570.c: Warning: cannot query product for Si570-USB device: \n&quot;);
+              printf(&quot;usb error message: %s\n&quot;,usb_strerror());
+        } else {
+              errorCode = USB_ERROR_NOTFOUND;
+              // fprintf(stderr, &quot;seen product -&gt;%s&lt;-\n&quot;, string);
+              if(strcmp(string, productName) == 0) {
+        len = usbGetStringAscii(handle, dev-&gt;descriptor.iSerialNumber,
+             0x0409, serialNumberString, sizeof(serialNumberString));
+        if (len &lt; 0) {
+          errorCode = USB_ERROR_IO;
+          printf(&quot;si570.c: Warning: cannot query serial number for Si570-USB device: \n&quot;);
+                  printf(&quot;usb error message: %s\n&quot;,usb_strerror());
+        } else {
+          errorCode = USB_ERROR_NOTFOUND;
+          if ((usbSerialID == NULL) ||
+              (strcmp(serialNumberString, usbSerialID) == 0)) {
+//                    printf(&quot;\nOpen Si570 USB device: OK\n&quot;);
+//                    printf(&quot;usbSerialID          : %s\n&quot;,serialNumberString);
+            break;
+          }
+        }
+          }
+        }
+      }
+    }
+        usb_close(handle);
+        handle = NULL;
+      }
+    }
+    if(handle) break;
+  }
+  if(handle != NULL) {
+    errorCode = USB_SUCCESS;
+    *device = handle;
+  }
+  return errorCode;
+}
+
+void setLongWord( int value, char * bytes)
+{
+  bytes[0] = value &amp; 0xff;
+  bytes[1] = ((value &amp; 0xff00) &gt;&gt; 8) &amp; 0xff;
+  bytes[2] = ((value &amp; 0xff0000) &gt;&gt; 16) &amp; 0xff;
+  bytes[3] = ((value &amp; 0xff000000) &gt;&gt; 24) &amp; 0xff;
+}
+
+int setFreqByValue(usb_dev_handle * handle, double frequency)
+{
+// Windows Doc from PE0FKO:
+//
+// Command 0x32:
+// -------------
+// Set the oscillator frequency by value. The frequency is formatted in MHz
+// as 11.21 bits value.
+// The &quot;automatic band pass filter selection&quot;, &quot;smooth tune&quot;,
+// &quot;one side calibration&quot; and the &quot;frequency subtract multiply&quot; are all
+// done in this function. (if enabled in the firmware)
+//
+// Default:    None
+//
+// Parameters:
+//     requesttype:    USB_ENDPOINT_OUT
+//     request:         0x32
+//     value:           0
+//     index:           0
+//     bytes:           pointer 32 bits integer
+//     size:            4
+//
+// Code sample:
+//     uint32_t iFreq;
+//     double   dFreq;
+//
+//     dFreq = 30.123456; // MHz
+//     iFreq = (uint32_t)( dFreq * (1UL &lt;&lt; 21) )
+//     r = usbCtrlMsgOUT(0x32, 0, 0, (char *)&amp;iFreq, sizeof(iFreq));
+//     if (r &lt; 0) Error
+//
+
+  char   buffer[4];
+  int  i2cAddress = 0x55;
+  int    request = REQUEST_SET_FREQ_BY_VALUE;
+  int    value = 0x700 + i2cAddress;
+  int    my_index = 0;
+  int    retval;
+  int    err_cnt;
+
+  err_cnt =0;
+ set_again:;
+  setLongWord(round(frequency * 2097152.0), buffer);  //   2097152=2^21
+  retval=usb_control_msg(
+         handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT,
+         request,
+         value,
+         my_index,
+         buffer,
+         sizeof(buffer),
+         5000);
+  if (retval != 4) {
+    err_cnt ++;
+    if(err_cnt &lt; MAX_USB_ERR_CNT) {
+      si570_sleep(1000);          // delay 1000 microsec
+      goto set_again;
+    } else {
+      printf(&quot;Error when setting frequency, returncode=%i\n&quot;,retval);
+      printf(&quot;usb error message: %s\n&quot;, usb_strerror());
+    }
+  }
+  return retval;
+}


Property changes on: branches/map65/set570.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/sleep.h
===================================================================
--- branches/map65/sleep.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/sleep.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,16 +1,16 @@
-#ifndef SLEEP_H
-#define SLEEP_H
-#include &lt;qthread.h&gt;
-
-class Sleep : public QThread
-{
-public:
-  static void msleep(int ms) {
-    QThread::msleep(ms);
-  }
-  static int idealThreadCount() {
-    return QThread::idealThreadCount();
-  }
-};
-
-#endif // SLEEP_H
+#ifndef SLEEP_H
+#define SLEEP_H
+#include &lt;qthread.h&gt;
+
+class Sleep : public QThread
+{
+public:
+  static void msleep(int ms) {
+    QThread::msleep(ms);
+  }
+  static int idealThreadCount() {
+    return QThread::idealThreadCount();
+  }
+};
+
+#endif // SLEEP_H


Property changes on: branches/map65/sleep.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/soundin.cpp
===================================================================
--- branches/map65/soundin.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/soundin.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,403 +1,403 @@
-#include &quot;soundin.h&quot;
-#include &lt;stdexcept&gt;
-
-#define NFFT 32768
-#define FRAMES_PER_BUFFER 1024
-
-extern &quot;C&quot; {
-#include &lt;portaudio.h&gt;
-extern struct {
-  double d8[2*60*96000];   //This is &quot;common/datcom/...&quot; in fortran
-  float ss[4*322*NFFT];
-  float savg[4*NFFT];
-  double fcenter;
-  int nutc;
-  int idphi;                        //Phase correction for Y pol'n, degrees
-  int mousedf;                      //User-selected DF
-  int mousefqso;                    //User-selected QSO freq (kHz)
-  int nagain;                       //1 ==&gt; decode only at fQSO +/- Tol
-  int ndepth;                       //How much hinted decoding to do?
-  int ndiskdat;                     //1 ==&gt; data read from *.tf2 or *.iq file
-  int neme;                         //Hinted decoding tries only for EME calls
-  int newdat;                       //1 ==&gt; new data, must do long FFT
-  int nfa;                          //Low decode limit (kHz)
-  int nfb;                          //High decode limit (kHz)
-  int nfcal;                        //Frequency correction, for calibration (Hz)
-  int nfshift;                      //Shift of displayed center freq (kHz)
-  int mcall3;                       //1 ==&gt; CALL3.TXT has been modified
-  int ntimeout;                     //Max for timeouts in Messages and BandMap
-  int ntol;                         //+/- decoding range around fQSO (Hz)
-  int nxant;                        //1 ==&gt; add 45 deg to measured pol angle
-  int map65RxLog;                   //Flags to control log files
-  int nfsample;                     //Input sample rate
-  int nxpol;                        //1 if using xpol antennas, 0 otherwise
-  int mode65;                       //JT65 sub-mode: A=1, B=2, C=4
-  char mycall[12];
-  char mygrid[6];
-  char hiscall[12];
-  char hisgrid[6];
-  char datetime[20];
-} datcom_;
-}
-
-typedef struct
-{
-  int kin;          //Parameters sent to/from the portaudio callback function
-  int nrx;
-  bool bzero;
-  bool iqswap;
-  bool b10db;
-} paUserData;
-
-//--------------------------------------------------------------- a2dCallback
-extern &quot;C&quot; int a2dCallback( const void *inputBuffer, void *outputBuffer,
-                         unsigned long framesToProcess,
-                         const PaStreamCallbackTimeInfo* timeInfo,
-                         PaStreamCallbackFlags statusFlags,
-                         void *userData )
-
-// This routine called by the PortAudio engine when samples are available.
-// It may be called at interrupt level, so don't do anything
-// that could mess up the system like calling malloc() or free().
-
-{
-  paUserData *udata=(paUserData*)userData;
-  (void) outputBuffer;          //Prevent unused variable warnings.
-  (void) timeInfo;
-  (void) userData;
-  int nbytes,i,j;
-  float d4[4*FRAMES_PER_BUFFER];
-  float d4a[4*FRAMES_PER_BUFFER];
-  float tmp;
-  float fac;
-
-  if( (statusFlags&amp;paInputOverflow) != 0) {
-    qDebug() &lt;&lt; &quot;Input Overflow&quot;;
-  }
-  if(udata-&gt;bzero) {           //Start of a new minute
-    udata-&gt;kin=0;              //Reset buffer pointer
-    udata-&gt;bzero=false;
-  }
-
-  nbytes=udata-&gt;nrx*8*framesToProcess;        //Bytes per frame
-  memcpy(d4,inputBuffer,nbytes);              //Copy all samples to d4
-
-  fac=32767.0;
-  if(udata-&gt;b10db) fac=103618.35;
-
-  if(udata-&gt;nrx==2) {
-    for(i=0; i&lt;4*int(framesToProcess); i++) {     //Negate odd-numbered frames
-      d4[i]=fac*d4[i];
-      j=i/4;
-      if((j%2)==1) d4[i]=-d4[i];
-    }
-    if(!udata-&gt;iqswap) {
-      for(i=0; i&lt;int(framesToProcess); i++) {
-        j=4*i;
-        tmp=d4[j];
-        d4[j]=d4[j+1];
-        d4[j+1]=tmp;
-        tmp=d4[j+2];
-        d4[j+2]=d4[j+3];
-        d4[j+3]=tmp;
-      }
-    }
-    memcpy(&amp;datcom_.d8[2*udata-&gt;kin],d4,nbytes); //Copy from d4 to dd()
-  } else {
-    int k=0;
-    for(i=0; i&lt;2*int(framesToProcess); i+=2) {    //Negate odd-numbered frames
-      j=i/2;
-      if(j%2==0) {
-        d4a[k++]=fac*d4[i];
-        d4a[k++]=fac*d4[i+1];
-      } else {
-        d4a[k++]=-fac*d4[i];
-        d4a[k++]=-fac*d4[i+1];
-      }
-      d4a[k++]=0.0;
-      d4a[k++]=0.0;
-    }
-    if(!udata-&gt;iqswap) {
-      for(i=0; i&lt;int(framesToProcess); i++) {
-        j=4*i;
-        tmp=d4a[j];
-        d4a[j]=d4a[j+1];
-        d4a[j+1]=tmp;
-      }
-    }
-    memcpy(&amp;datcom_.d8[2*udata-&gt;kin],d4a,2*nbytes); //Copy from d4a to dd()
-  }
-  udata-&gt;kin += framesToProcess;
-  return paContinue;
-}
-
-void SoundInThread::run()                           //SoundInThread::run()
-{
-  quitExecution = false;
-
-  if (m_net) {
-//    qDebug() &lt;&lt; &quot;Start inputUDP()&quot;;
-    inputUDP();
-//    qDebug() &lt;&lt; &quot;Finished inputUDP()&quot;;
-    return;
-  }
-
-//---------------------------------------------------- Soundcard Setup
-//  qDebug() &lt;&lt; &quot;Start souncard input&quot;;
-
-  PaError paerr;
-  PaStreamParameters inParam;
-  PaStream *inStream;
-  paUserData udata;
-
-  udata.kin=0;                              //Buffer pointer
-  udata.bzero=false;                        //Flag to request reset of kin
-  udata.nrx=m_nrx;                          //Number of polarizations
-  udata.iqswap=m_IQswap;
-  udata.b10db=m_10db;
-
-  inParam.device=m_nDevIn;                  //### Input Device Number ###
-  inParam.channelCount=2*m_nrx;             //Number of analog channels
-  inParam.sampleFormat=paFloat32;           //Get floats from Portaudio
-  inParam.suggestedLatency=0.05;
-  inParam.hostApiSpecificStreamInfo=NULL;
-
-  paerr=Pa_IsFormatSupported(&amp;inParam,NULL,96000.0);
-  if(paerr&lt;0) {
-    emit error(&quot;PortAudio says requested soundcard format not supported.&quot;);
-//    return;
-  }
-  paerr=Pa_OpenStream(&amp;inStream,            //Input stream
-        &amp;inParam,                           //Input parameters
-        NULL,                               //No output parameters
-        96000.0,                            //Sample rate
-        FRAMES_PER_BUFFER,                  //Frames per buffer
-//        paClipOff+paDitherOff,              //No clipping or dithering
-        paClipOff,                          //No clipping
-        a2dCallback,                        //Input callbeck routine
-        &amp;udata);                            //userdata
-
-  paerr=Pa_StartStream(inStream);
-  if(paerr&lt;0) {
-    emit error(&quot;Failed to start audio input stream.&quot;);
-    return;
-  }
-//  const PaStreamInfo* p=Pa_GetStreamInfo(inStream);
-
-  bool qe = quitExecution;
-  int n60z=99;
-  int k=0;
-  int nsec;
-  int n60;
-  int nBusy=0;
-  int nhsym0=0;
-
-//---------------------------------------------- Soundcard input loop
-  while (!qe) {
-    qe = quitExecution;
-    if (qe) break;
-    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
-    nsec = ms/1000;             // Time according to this computer
-    n60 = nsec % 60;
-
-// Reset buffer pointer and symbol number at start of minute
-    if(n60 &lt; n60z or !m_monitoring) {
-      nhsym0=0;
-      udata.bzero=true;
-    }
-    k=udata.kin;
-    udata.iqswap=m_IQswap;
-    udata.b10db=m_10db;
-    if(m_monitoring) {
-      if(m_bForceCenterFreq) {
-        datcom_.fcenter=m_dForceCenterFreq;\
-      } else {
-        datcom_.fcenter=144.125;
-      }
-      m_hsym=(k-2048)*11025.0/(2048.0*m_rate);
-      if(m_hsym != nhsym0) {
-        if(m_dataSinkBusy) {
-          nBusy++;
-        } else {
-          m_dataSinkBusy=true;
-          emit readyForFFT(k);         //Signal to compute new FFTs
-        }
-        nhsym0=m_hsym;
-      }
-    }
-    msleep(100);
-    n60z=n60;
-  }
-  Pa_StopStream(inStream);
-  Pa_CloseStream(inStream);
-}
-
-void SoundInThread::setSwapIQ(bool b)
-{
-  m_IQswap=b;
-}
-
-void SoundInThread::set10db(bool b)
-{
-  m_10db=b;
-}
-void SoundInThread::setPort(int n)                              //setPort()
-{
-  if (isRunning()) return;
-  this-&gt;m_udpPort=n;
-}
-
-void SoundInThread::setInputDevice(int n)                  //setInputDevice()
-{
-  if (isRunning()) return;
-  this-&gt;m_nDevIn=n;
-}
-
-void SoundInThread::setRate(double rate)                         //setRate()
-{
-  if (isRunning()) return;
-  this-&gt;m_rate = rate;
-}
-
-void SoundInThread::setBufSize(unsigned n)                      //setBufSize()
-{
-  if (isRunning()) return;
-  this-&gt;bufSize = n;
-}
-
-void SoundInThread::setFadd(double x)
-{
-  m_fAdd=x;
-}
-
-
-void SoundInThread::quit()                                       //quit()
-{
-  quitExecution = true;
-}
-
-void SoundInThread::setNetwork(bool b)                          //setNetwork()
-{
-  m_net = b;
-}
-
-void SoundInThread::setMonitoring(bool b)                    //setMonitoring()
-{
-  m_monitoring = b;
-}
-
-void SoundInThread::setForceCenterFreqBool(bool b)
-{
-  m_bForceCenterFreq=b;
-
-}
-
-void SoundInThread::setForceCenterFreqMHz(double d)
-{
-  m_dForceCenterFreq=d;
-}
-
-void SoundInThread::setNrx(int n)                              //setNrx()
-{
-  m_nrx = n;
-}
-
-int SoundInThread::nrx()
-{
-  return m_nrx;
-}
-
-int SoundInThread::mhsym()
-{
-  return m_hsym;
-}
-
-//--------------------------------------------------------------- inputUDP()
-void SoundInThread::inputUDP()
-{
-  udpSocket = new QUdpSocket();
-  if(!udpSocket-&gt;bind(m_udpPort,QUdpSocket::ShareAddress) )
-  {
-    emit error(tr(&quot;UDP Socket bind failed.&quot;));
-    return;
-  }
-
-  // Set this socket's total buffer space for received UDP packets
-  int v=141600;
-  ::setsockopt(udpSocket-&gt;socketDescriptor(), SOL_SOCKET, SO_RCVBUF,
-               (char *)&amp;v, sizeof(v));
-
-  bool qe = quitExecution;
-  struct linradBuffer {
-    double cfreq;
-    int msec;
-    float userfreq;
-    int iptr;
-    quint16 iblk;
-    qint8 nrx;
-    char iusb;
-    double d8[174];
-  } b;
-
-  int n60z=99;
-  int k=0;
-  int nsec;
-  int n60;
-  int nhsym0=0;
-  int iz=174;
-  int nBusy=0;
-
-  // Main loop for input of UDP packets over the network:
-  while (!qe) {
-    qe = quitExecution;
-    if (qe) break;
-    if (!udpSocket-&gt;hasPendingDatagrams()) {
-      msleep(2);                  // Sleep if no packet available
-    } else {
-      int nBytesRead = udpSocket-&gt;readDatagram((char *)&amp;b,1416);
-      if (nBytesRead != 1416) qDebug() &lt;&lt; &quot;UDP Read Error:&quot; &lt;&lt; nBytesRead;
-
-      qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
-      nsec = ms/1000;             // Time according to this computer
-      n60 = nsec % 60;
-
-// Reset buffer pointer and symbol number at start of minute
-      if(n60 &lt; n60z) {
-        k=0;
-        nhsym0=0;
-      }
-      n60z=n60;
-
-      if(m_monitoring) {
-        m_nrx=b.nrx;
-        if(m_nrx == +1) iz=348;                 //One RF channel, i*2 data
-        if(m_nrx == -1 or m_nrx == +2) iz=174;  //One Rf channel, r*4 data
-                                                // or 2 RF channels, i*2 data
-        if(m_nrx == -2) iz=87;                  // Two RF channels, r*4 data
-
-        // If buffer will not overflow, move data into datcom_
-        if ((k+iz) &lt;= 60*96000) {
-          int nsam=-1;
-          recvpkt_(&amp;nsam, &amp;b.iblk, &amp;b.nrx, &amp;k, b.d8, b.d8, b.d8);
-          if(m_bForceCenterFreq) {
-            datcom_.fcenter=m_dForceCenterFreq;
-          } else {
-            datcom_.fcenter=b.cfreq + m_fAdd;
-          }
-        }
-
-        m_hsym=(k-2048)*11025.0/(2048.0*m_rate);
-        if(m_hsym != nhsym0) {
-          if(m_dataSinkBusy) {
-            nBusy++;
-          } else {
-            m_dataSinkBusy=true;
-            emit readyForFFT(k);         //Signal to compute new FFTs
-          }
-          nhsym0=m_hsym;
-        }
-      }
-    }
-  }
-  delete udpSocket;
-}
+#include &quot;soundin.h&quot;
+#include &lt;stdexcept&gt;
+
+#define NFFT 32768
+#define FRAMES_PER_BUFFER 1024
+
+extern &quot;C&quot; {
+#include &lt;portaudio.h&gt;
+extern struct {
+  double d8[2*60*96000];   //This is &quot;common/datcom/...&quot; in fortran
+  float ss[4*322*NFFT];
+  float savg[4*NFFT];
+  double fcenter;
+  int nutc;
+  int idphi;                        //Phase correction for Y pol'n, degrees
+  int mousedf;                      //User-selected DF
+  int mousefqso;                    //User-selected QSO freq (kHz)
+  int nagain;                       //1 ==&gt; decode only at fQSO +/- Tol
+  int ndepth;                       //How much hinted decoding to do?
+  int ndiskdat;                     //1 ==&gt; data read from *.tf2 or *.iq file
+  int neme;                         //Hinted decoding tries only for EME calls
+  int newdat;                       //1 ==&gt; new data, must do long FFT
+  int nfa;                          //Low decode limit (kHz)
+  int nfb;                          //High decode limit (kHz)
+  int nfcal;                        //Frequency correction, for calibration (Hz)
+  int nfshift;                      //Shift of displayed center freq (kHz)
+  int mcall3;                       //1 ==&gt; CALL3.TXT has been modified
+  int ntimeout;                     //Max for timeouts in Messages and BandMap
+  int ntol;                         //+/- decoding range around fQSO (Hz)
+  int nxant;                        //1 ==&gt; add 45 deg to measured pol angle
+  int map65RxLog;                   //Flags to control log files
+  int nfsample;                     //Input sample rate
+  int nxpol;                        //1 if using xpol antennas, 0 otherwise
+  int mode65;                       //JT65 sub-mode: A=1, B=2, C=4
+  char mycall[12];
+  char mygrid[6];
+  char hiscall[12];
+  char hisgrid[6];
+  char datetime[20];
+} datcom_;
+}
+
+typedef struct
+{
+  int kin;          //Parameters sent to/from the portaudio callback function
+  int nrx;
+  bool bzero;
+  bool iqswap;
+  bool b10db;
+} paUserData;
+
+//--------------------------------------------------------------- a2dCallback
+extern &quot;C&quot; int a2dCallback( const void *inputBuffer, void *outputBuffer,
+                         unsigned long framesToProcess,
+                         const PaStreamCallbackTimeInfo* timeInfo,
+                         PaStreamCallbackFlags statusFlags,
+                         void *userData )
+
+// This routine called by the PortAudio engine when samples are available.
+// It may be called at interrupt level, so don't do anything
+// that could mess up the system like calling malloc() or free().
+
+{
+  paUserData *udata=(paUserData*)userData;
+  (void) outputBuffer;          //Prevent unused variable warnings.
+  (void) timeInfo;
+  (void) userData;
+  int nbytes,i,j;
+  float d4[4*FRAMES_PER_BUFFER];
+  float d4a[4*FRAMES_PER_BUFFER];
+  float tmp;
+  float fac;
+
+  if( (statusFlags&amp;paInputOverflow) != 0) {
+    qDebug() &lt;&lt; &quot;Input Overflow&quot;;
+  }
+  if(udata-&gt;bzero) {           //Start of a new minute
+    udata-&gt;kin=0;              //Reset buffer pointer
+    udata-&gt;bzero=false;
+  }
+
+  nbytes=udata-&gt;nrx*8*framesToProcess;        //Bytes per frame
+  memcpy(d4,inputBuffer,nbytes);              //Copy all samples to d4
+
+  fac=32767.0;
+  if(udata-&gt;b10db) fac=103618.35;
+
+  if(udata-&gt;nrx==2) {
+    for(i=0; i&lt;4*int(framesToProcess); i++) {     //Negate odd-numbered frames
+      d4[i]=fac*d4[i];
+      j=i/4;
+      if((j%2)==1) d4[i]=-d4[i];
+    }
+    if(!udata-&gt;iqswap) {
+      for(i=0; i&lt;int(framesToProcess); i++) {
+        j=4*i;
+        tmp=d4[j];
+        d4[j]=d4[j+1];
+        d4[j+1]=tmp;
+        tmp=d4[j+2];
+        d4[j+2]=d4[j+3];
+        d4[j+3]=tmp;
+      }
+    }
+    memcpy(&amp;datcom_.d8[2*udata-&gt;kin],d4,nbytes); //Copy from d4 to dd()
+  } else {
+    int k=0;
+    for(i=0; i&lt;2*int(framesToProcess); i+=2) {    //Negate odd-numbered frames
+      j=i/2;
+      if(j%2==0) {
+        d4a[k++]=fac*d4[i];
+        d4a[k++]=fac*d4[i+1];
+      } else {
+        d4a[k++]=-fac*d4[i];
+        d4a[k++]=-fac*d4[i+1];
+      }
+      d4a[k++]=0.0;
+      d4a[k++]=0.0;
+    }
+    if(!udata-&gt;iqswap) {
+      for(i=0; i&lt;int(framesToProcess); i++) {
+        j=4*i;
+        tmp=d4a[j];
+        d4a[j]=d4a[j+1];
+        d4a[j+1]=tmp;
+      }
+    }
+    memcpy(&amp;datcom_.d8[2*udata-&gt;kin],d4a,2*nbytes); //Copy from d4a to dd()
+  }
+  udata-&gt;kin += framesToProcess;
+  return paContinue;
+}
+
+void SoundInThread::run()                           //SoundInThread::run()
+{
+  quitExecution = false;
+
+  if (m_net) {
+//    qDebug() &lt;&lt; &quot;Start inputUDP()&quot;;
+    inputUDP();
+//    qDebug() &lt;&lt; &quot;Finished inputUDP()&quot;;
+    return;
+  }
+
+//---------------------------------------------------- Soundcard Setup
+//  qDebug() &lt;&lt; &quot;Start souncard input&quot;;
+
+  PaError paerr;
+  PaStreamParameters inParam;
+  PaStream *inStream;
+  paUserData udata;
+
+  udata.kin=0;                              //Buffer pointer
+  udata.bzero=false;                        //Flag to request reset of kin
+  udata.nrx=m_nrx;                          //Number of polarizations
+  udata.iqswap=m_IQswap;
+  udata.b10db=m_10db;
+
+  inParam.device=m_nDevIn;                  //### Input Device Number ###
+  inParam.channelCount=2*m_nrx;             //Number of analog channels
+  inParam.sampleFormat=paFloat32;           //Get floats from Portaudio
+  inParam.suggestedLatency=0.05;
+  inParam.hostApiSpecificStreamInfo=NULL;
+
+  paerr=Pa_IsFormatSupported(&amp;inParam,NULL,96000.0);
+  if(paerr&lt;0) {
+    emit error(&quot;PortAudio says requested soundcard format not supported.&quot;);
+//    return;
+  }
+  paerr=Pa_OpenStream(&amp;inStream,            //Input stream
+        &amp;inParam,                           //Input parameters
+        NULL,                               //No output parameters
+        96000.0,                            //Sample rate
+        FRAMES_PER_BUFFER,                  //Frames per buffer
+//        paClipOff+paDitherOff,              //No clipping or dithering
+        paClipOff,                          //No clipping
+        a2dCallback,                        //Input callbeck routine
+        &amp;udata);                            //userdata
+
+  paerr=Pa_StartStream(inStream);
+  if(paerr&lt;0) {
+    emit error(&quot;Failed to start audio input stream.&quot;);
+    return;
+  }
+//  const PaStreamInfo* p=Pa_GetStreamInfo(inStream);
+
+  bool qe = quitExecution;
+  int n60z=99;
+  int k=0;
+  int nsec;
+  int n60;
+  int nBusy=0;
+  int nhsym0=0;
+
+//---------------------------------------------- Soundcard input loop
+  while (!qe) {
+    qe = quitExecution;
+    if (qe) break;
+    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
+    nsec = ms/1000;             // Time according to this computer
+    n60 = nsec % 60;
+
+// Reset buffer pointer and symbol number at start of minute
+    if(n60 &lt; n60z or !m_monitoring) {
+      nhsym0=0;
+      udata.bzero=true;
+    }
+    k=udata.kin;
+    udata.iqswap=m_IQswap;
+    udata.b10db=m_10db;
+    if(m_monitoring) {
+      if(m_bForceCenterFreq) {
+        datcom_.fcenter=m_dForceCenterFreq;\
+      } else {
+        datcom_.fcenter=144.125;
+      }
+      m_hsym=(k-2048)*11025.0/(2048.0*m_rate);
+      if(m_hsym != nhsym0) {
+        if(m_dataSinkBusy) {
+          nBusy++;
+        } else {
+          m_dataSinkBusy=true;
+          emit readyForFFT(k);         //Signal to compute new FFTs
+        }
+        nhsym0=m_hsym;
+      }
+    }
+    msleep(100);
+    n60z=n60;
+  }
+  Pa_StopStream(inStream);
+  Pa_CloseStream(inStream);
+}
+
+void SoundInThread::setSwapIQ(bool b)
+{
+  m_IQswap=b;
+}
+
+void SoundInThread::set10db(bool b)
+{
+  m_10db=b;
+}
+void SoundInThread::setPort(int n)                              //setPort()
+{
+  if (isRunning()) return;
+  this-&gt;m_udpPort=n;
+}
+
+void SoundInThread::setInputDevice(int n)                  //setInputDevice()
+{
+  if (isRunning()) return;
+  this-&gt;m_nDevIn=n;
+}
+
+void SoundInThread::setRate(double rate)                         //setRate()
+{
+  if (isRunning()) return;
+  this-&gt;m_rate = rate;
+}
+
+void SoundInThread::setBufSize(unsigned n)                      //setBufSize()
+{
+  if (isRunning()) return;
+  this-&gt;bufSize = n;
+}
+
+void SoundInThread::setFadd(double x)
+{
+  m_fAdd=x;
+}
+
+
+void SoundInThread::quit()                                       //quit()
+{
+  quitExecution = true;
+}
+
+void SoundInThread::setNetwork(bool b)                          //setNetwork()
+{
+  m_net = b;
+}
+
+void SoundInThread::setMonitoring(bool b)                    //setMonitoring()
+{
+  m_monitoring = b;
+}
+
+void SoundInThread::setForceCenterFreqBool(bool b)
+{
+  m_bForceCenterFreq=b;
+
+}
+
+void SoundInThread::setForceCenterFreqMHz(double d)
+{
+  m_dForceCenterFreq=d;
+}
+
+void SoundInThread::setNrx(int n)                              //setNrx()
+{
+  m_nrx = n;
+}
+
+int SoundInThread::nrx()
+{
+  return m_nrx;
+}
+
+int SoundInThread::mhsym()
+{
+  return m_hsym;
+}
+
+//--------------------------------------------------------------- inputUDP()
+void SoundInThread::inputUDP()
+{
+  udpSocket = new QUdpSocket();
+  if(!udpSocket-&gt;bind(m_udpPort,QUdpSocket::ShareAddress) )
+  {
+    emit error(tr(&quot;UDP Socket bind failed.&quot;));
+    return;
+  }
+
+  // Set this socket's total buffer space for received UDP packets
+  int v=141600;
+  ::setsockopt(udpSocket-&gt;socketDescriptor(), SOL_SOCKET, SO_RCVBUF,
+               (char *)&amp;v, sizeof(v));
+
+  bool qe = quitExecution;
+  struct linradBuffer {
+    double cfreq;
+    int msec;
+    float userfreq;
+    int iptr;
+    quint16 iblk;
+    qint8 nrx;
+    char iusb;
+    double d8[174];
+  } b;
+
+  int n60z=99;
+  int k=0;
+  int nsec;
+  int n60;
+  int nhsym0=0;
+  int iz=174;
+  int nBusy=0;
+
+  // Main loop for input of UDP packets over the network:
+  while (!qe) {
+    qe = quitExecution;
+    if (qe) break;
+    if (!udpSocket-&gt;hasPendingDatagrams()) {
+      msleep(2);                  // Sleep if no packet available
+    } else {
+      int nBytesRead = udpSocket-&gt;readDatagram((char *)&amp;b,1416);
+      if (nBytesRead != 1416) qDebug() &lt;&lt; &quot;UDP Read Error:&quot; &lt;&lt; nBytesRead;
+
+      qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
+      nsec = ms/1000;             // Time according to this computer
+      n60 = nsec % 60;
+
+// Reset buffer pointer and symbol number at start of minute
+      if(n60 &lt; n60z) {
+        k=0;
+        nhsym0=0;
+      }
+      n60z=n60;
+
+      if(m_monitoring) {
+        m_nrx=b.nrx;
+        if(m_nrx == +1) iz=348;                 //One RF channel, i*2 data
+        if(m_nrx == -1 or m_nrx == +2) iz=174;  //One Rf channel, r*4 data
+                                                // or 2 RF channels, i*2 data
+        if(m_nrx == -2) iz=87;                  // Two RF channels, r*4 data
+
+        // If buffer will not overflow, move data into datcom_
+        if ((k+iz) &lt;= 60*96000) {
+          int nsam=-1;
+          recvpkt_(&amp;nsam, &amp;b.iblk, &amp;b.nrx, &amp;k, b.d8, b.d8, b.d8);
+          if(m_bForceCenterFreq) {
+            datcom_.fcenter=m_dForceCenterFreq;
+          } else {
+            datcom_.fcenter=b.cfreq + m_fAdd;
+          }
+        }
+
+        m_hsym=(k-2048)*11025.0/(2048.0*m_rate);
+        if(m_hsym != nhsym0) {
+          if(m_dataSinkBusy) {
+            nBusy++;
+          } else {
+            m_dataSinkBusy=true;
+            emit readyForFFT(k);         //Signal to compute new FFTs
+          }
+          nhsym0=m_hsym;
+        }
+      }
+    }
+  }
+  delete udpSocket;
+}


Property changes on: branches/map65/soundin.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/soundin.h
===================================================================
--- branches/map65/soundin.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/soundin.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,85 +1,85 @@
-#ifndef SOUNDIN_H
-#define SOUNDIN_H
-
-#include &lt;QtCore&gt;
-#include &lt;QtNetwork/QUdpSocket&gt;
-#include &lt;QDebug&gt;
-#include &lt;valarray&gt;
-
-#ifdef Q_OS_WIN32
-#include &lt;winsock.h&gt;
-#else
-#include &lt;sys/socket.h&gt;
-#endif //Q_OS_WIN32
-
-// Thread gets audio data from soundcard and signals when a buffer of
-// specified size is available.
-class SoundInThread : public QThread
-{
-  Q_OBJECT
-  bool quitExecution;           // if true, thread exits gracefully
-  double m_rate;                // sample rate
-  unsigned bufSize;             // user's buffer size
-
-protected:
-  virtual void run();
-
-public:
-  bool m_dataSinkBusy;
-
-  SoundInThread():
-    quitExecution(false),
-    m_dataSinkBusy(false),
-    m_rate(0),
-    bufSize(0)
-  {
-  }
-
-  void setSwapIQ(bool b);
-  void set10db(bool b);
-  void setPort(qint32 n);
-  void setInputDevice(qint32 n);
-  void setRate(double rate);
-  void setBufSize(unsigned bufSize);
-  void setNetwork(bool b);
-  void setMonitoring(bool b);
-  void setFadd(double x);
-  void setNrx(int n);
-  void setForceCenterFreqBool(bool b);
-  void setForceCenterFreqMHz(double d);
-  int  nrx();
-  int  mhsym();
-
-signals:
-  void bufferAvailable(std::valarray&lt;qint16&gt; samples, double rate);
-  void readyForFFT(int k);
-  void error(const QString&amp; message);
-  void status(const QString&amp; message);
-
-public slots:
-  void quit();
-
-private:
-  void inputUDP();
-
-  double m_fAdd;
-  bool   m_net;
-  bool   m_monitoring;
-  bool   m_bForceCenterFreq;
-  bool   m_IQswap;
-  bool   m_10db;
-  double m_dForceCenterFreq;
-  qint32 m_nrx;
-  qint32 m_hsym;
-  qint32 m_nDevIn;
-  qint32 m_udpPort;
-
-  QUdpSocket *udpSocket;
-};
-
-extern &quot;C&quot; {
-  void recvpkt_(int* nsam, quint16* iblk, qint8* nrx, int* k, double s1[],
-                double s2[], double s3[]);
-}
-
-#endif // SOUNDIN_H
+#ifndef SOUNDIN_H
+#define SOUNDIN_H
+
+#include &lt;QtCore&gt;
+#include &lt;QtNetwork/QUdpSocket&gt;
+#include &lt;QDebug&gt;
+#include &lt;valarray&gt;
+
+#ifdef Q_OS_WIN32
+#include &lt;winsock.h&gt;
+#else
+#include &lt;sys/socket.h&gt;
+#endif //Q_OS_WIN32
+
+// Thread gets audio data from soundcard and signals when a buffer of
+// specified size is available.
+class SoundInThread : public QThread
+{
+  Q_OBJECT
+  bool quitExecution;           // if true, thread exits gracefully
+  double m_rate;                // sample rate
+  unsigned bufSize;             // user's buffer size
+
+protected:
+  virtual void run();
+
+public:
+  bool m_dataSinkBusy;
+
+  SoundInThread():
+    quitExecution(false),
+    m_dataSinkBusy(false),
+    m_rate(0),
+    bufSize(0)
+  {
+  }
+
+  void setSwapIQ(bool b);
+  void set10db(bool b);
+  void setPort(qint32 n);
+  void setInputDevice(qint32 n);
+  void setRate(double rate);
+  void setBufSize(unsigned bufSize);
+  void setNetwork(bool b);
+  void setMonitoring(bool b);
+  void setFadd(double x);
+  void setNrx(int n);
+  void setForceCenterFreqBool(bool b);
+  void setForceCenterFreqMHz(double d);
+  int  nrx();
+  int  mhsym();
+
+signals:
+  void bufferAvailable(std::valarray&lt;qint16&gt; samples, double rate);
+  void readyForFFT(int k);
+  void error(const QString&amp; message);
+  void status(const QString&amp; message);
+
+public slots:
+  void quit();
+
+private:
+  void inputUDP();
+
+  double m_fAdd;
+  bool   m_net;
+  bool   m_monitoring;
+  bool   m_bForceCenterFreq;
+  bool   m_IQswap;
+  bool   m_10db;
+  double m_dForceCenterFreq;
+  qint32 m_nrx;
+  qint32 m_hsym;
+  qint32 m_nDevIn;
+  qint32 m_udpPort;
+
+  QUdpSocket *udpSocket;
+};
+
+extern &quot;C&quot; {
+  void recvpkt_(int* nsam, quint16* iblk, qint8* nrx, int* k, double s1[],
+                double s2[], double s3[]);
+}
+
+#endif // SOUNDIN_H


Property changes on: branches/map65/soundin.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/soundout.cpp
===================================================================
--- branches/map65/soundout.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/soundout.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,170 +1,170 @@
-#include &quot;soundout.h&quot;
-
-#define FRAMES_PER_BUFFER 256
-
-extern &quot;C&quot; {
-#include &lt;portaudio.h&gt;
-}
-
-extern float gran();                  //Noise generator (for tests only)
-
-extern short int iwave[60*11025];     //Wave file for Tx audio
-extern int nwave;
-extern bool btxok;
-extern double outputLatency;
-
-typedef struct   //Parameters sent to or received from callback function
-{
-  int dummy;
-} paUserData;
-
-//--------------------------------------------------------------- d2aCallback
-extern &quot;C&quot; int d2aCallback(const void *inputBuffer, void *outputBuffer,
-                           unsigned long framesToProcess,
-                           const PaStreamCallbackTimeInfo* timeInfo,
-                           PaStreamCallbackFlags statusFlags,
-                           void *userData )
-{
-  paUserData *udata=(paUserData*)userData;
-  short *wptr = (short*)outputBuffer;
-  unsigned int i,n;
-  static int ic=0;
-//  static int ic0=0;
-//  static int nsec0=-99;
-  static bool btxok0=false;
-  static int nminStart=0;
-//  static t0,t1;
-  double tsec,tstart;
-
-  int nsec;
-
-  // Get System time
-  qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
-  tsec = 0.001*ms;
-  nsec = ms/1000;
-
-  if(btxok and !btxok0) {       //Start (or re-start) a transmission
-    n=nsec/60;
-    tstart=tsec - n*60.0 - 1.0;
-
-    if(tstart&lt;1.0) {
-      ic=0;                      //Start of minute, set starting index to 0
-//      ic0=ic;
-      nminStart=n;
-//      t0=timeInfo-&gt;currentTime;
-    } else {
-      if(n != nminStart) { //Late start in new minute: compute starting index
-        ic=(int)(tstart*11025.0);
-//        ic0=ic;
-//        t0=timeInfo-&gt;currentTime;
-//        qDebug() &lt;&lt; &quot;B&quot; &lt;&lt; t0 &lt;&lt; ic0;
-        nminStart=n;
-      }
-    }
-    /*
-    qDebug() &lt;&lt; &quot;A&quot; &lt;&lt; n &lt;&lt; ic
-             &lt;&lt; QString::number( tsec, 'f', 3 )
-             &lt;&lt; QString::number( tstart, 'f', 3 )
-             &lt;&lt; QString::number( timeInfo-&gt;currentTime, 'f', 3 )
-             &lt;&lt; QString::number( timeInfo-&gt;outputBufferDacTime, 'f', 3 )
-             &lt;&lt; QString::number( timeInfo-&gt;outputBufferDacTime -
-                                 timeInfo-&gt;currentTime, 'f', 3 )
-             &lt;&lt; QString::number( timeInfo-&gt;currentTime - tsec, 'f', 3 );
-    */
-  }
-  btxok0=btxok;
-
-  /*
-  if(nsec!=nsec0) {
-    double txt=timeInfo-&gt;currentTime - t0;
-    double r=0.0;
-    if(txt&gt;0.0) r=(ic-ic0)/txt;
-    qDebug() &lt;&lt; &quot;C&quot; &lt;&lt; txt &lt;&lt; ic-ic0 &lt;&lt; r;
-    nsec0=nsec;
-  }
-  */
-
-  if(btxok) {
-    for(i=0 ; i&lt;framesToProcess; i++ )  {
-      short int i2=iwave[ic];
-      if(ic &gt; nwave) i2=0;
-//      i2 = 500.0*(i2/32767.0 + 5.0*gran());      //Add noise (tests only!)
-      if(!btxok) i2=0;
-      *wptr++ = i2;                   //left
-      *wptr++ = i2;                   //right
-      ic++;
-    }
-  } else {
-    for(i=0 ; i&lt;framesToProcess; i++ )  {
-      *wptr++ = 0;
-      *wptr++ = 0;
-      ic++;
-    }
-  }
-  if(ic &gt; nwave) {
-    btxok=0;
-    ic=0;
-  }
-  return 0;
-}
-
-void SoundOutThread::run()
-{
-  PaError paerr;
-  PaStreamParameters outParam;
-  PaStream *outStream;
-  paUserData udata;
-  quitExecution = false;
-
-  outParam.device=m_nDevOut;                 //Output device number
-  outParam.channelCount=2;                   //Number of analog channels
-  outParam.sampleFormat=paInt16;             //Send short ints to PortAudio
-  outParam.suggestedLatency=0.05;
-  outParam.hostApiSpecificStreamInfo=NULL;
-
-  paerr=Pa_IsFormatSupported(NULL,&amp;outParam,11025.0);
-  if(paerr&lt;0) {
-    qDebug() &lt;&lt; &quot;PortAudio says requested output format not supported.&quot;;
-    qDebug() &lt;&lt; paerr;
-    return;
-  }
-
-//  udata.nwave=m_nwave;
-//  udata.btxok=false;
-
-  paerr=Pa_OpenStream(&amp;outStream,           //Output stream
-        NULL,                               //No input parameters
-        &amp;outParam,                          //Output parameters
-        11025.0,                            //Sample rate
-        FRAMES_PER_BUFFER,                  //Frames per buffer
-        paClipOff,                          //No clipping
-        d2aCallback,                        //output callbeck routine
-        &amp;udata);                            //userdata
-
-  paerr=Pa_StartStream(outStream);
-  if(paerr&lt;0) {
-    qDebug() &lt;&lt; &quot;Failed to start audio output stream.&quot;;
-    return;
-  }
-  const PaStreamInfo* p=Pa_GetStreamInfo(outStream);
-  outputLatency = p-&gt;outputLatency;
-  bool qe = quitExecution;
-
-//---------------------------------------------- Soundcard output loop
-  while (!qe) {
-    qe = quitExecution;
-    if (qe) break;
-//    udata.nwave=m_nwave;
-//    if(m_txOK) udata.btxok=1;
-//    if(!m_txOK) udata.btxok=0;
-    msleep(100);
-  }
-  Pa_StopStream(outStream);
-  Pa_CloseStream(outStream);
-}
-
-void SoundOutThread::setOutputDevice(int n)      //setOutputDevice()
-{
-  if (isRunning()) return;
-  this-&gt;m_nDevOut=n;
-}
+#include &quot;soundout.h&quot;
+
+#define FRAMES_PER_BUFFER 256
+
+extern &quot;C&quot; {
+#include &lt;portaudio.h&gt;
+}
+
+extern float gran();                  //Noise generator (for tests only)
+
+extern short int iwave[60*11025];     //Wave file for Tx audio
+extern int nwave;
+extern bool btxok;
+extern double outputLatency;
+
+typedef struct   //Parameters sent to or received from callback function
+{
+  int dummy;
+} paUserData;
+
+//--------------------------------------------------------------- d2aCallback
+extern &quot;C&quot; int d2aCallback(const void *inputBuffer, void *outputBuffer,
+                           unsigned long framesToProcess,
+                           const PaStreamCallbackTimeInfo* timeInfo,
+                           PaStreamCallbackFlags statusFlags,
+                           void *userData )
+{
+  paUserData *udata=(paUserData*)userData;
+  short *wptr = (short*)outputBuffer;
+  unsigned int i,n;
+  static int ic=0;
+//  static int ic0=0;
+//  static int nsec0=-99;
+  static bool btxok0=false;
+  static int nminStart=0;
+//  static t0,t1;
+  double tsec,tstart;
+
+  int nsec;
+
+  // Get System time
+  qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
+  tsec = 0.001*ms;
+  nsec = ms/1000;
+
+  if(btxok and !btxok0) {       //Start (or re-start) a transmission
+    n=nsec/60;
+    tstart=tsec - n*60.0 - 1.0;
+
+    if(tstart&lt;1.0) {
+      ic=0;                      //Start of minute, set starting index to 0
+//      ic0=ic;
+      nminStart=n;
+//      t0=timeInfo-&gt;currentTime;
+    } else {
+      if(n != nminStart) { //Late start in new minute: compute starting index
+        ic=(int)(tstart*11025.0);
+//        ic0=ic;
+//        t0=timeInfo-&gt;currentTime;
+//        qDebug() &lt;&lt; &quot;B&quot; &lt;&lt; t0 &lt;&lt; ic0;
+        nminStart=n;
+      }
+    }
+    /*
+    qDebug() &lt;&lt; &quot;A&quot; &lt;&lt; n &lt;&lt; ic
+             &lt;&lt; QString::number( tsec, 'f', 3 )
+             &lt;&lt; QString::number( tstart, 'f', 3 )
+             &lt;&lt; QString::number( timeInfo-&gt;currentTime, 'f', 3 )
+             &lt;&lt; QString::number( timeInfo-&gt;outputBufferDacTime, 'f', 3 )
+             &lt;&lt; QString::number( timeInfo-&gt;outputBufferDacTime -
+                                 timeInfo-&gt;currentTime, 'f', 3 )
+             &lt;&lt; QString::number( timeInfo-&gt;currentTime - tsec, 'f', 3 );
+    */
+  }
+  btxok0=btxok;
+
+  /*
+  if(nsec!=nsec0) {
+    double txt=timeInfo-&gt;currentTime - t0;
+    double r=0.0;
+    if(txt&gt;0.0) r=(ic-ic0)/txt;
+    qDebug() &lt;&lt; &quot;C&quot; &lt;&lt; txt &lt;&lt; ic-ic0 &lt;&lt; r;
+    nsec0=nsec;
+  }
+  */
+
+  if(btxok) {
+    for(i=0 ; i&lt;framesToProcess; i++ )  {
+      short int i2=iwave[ic];
+      if(ic &gt; nwave) i2=0;
+//      i2 = 500.0*(i2/32767.0 + 5.0*gran());      //Add noise (tests only!)
+      if(!btxok) i2=0;
+      *wptr++ = i2;                   //left
+      *wptr++ = i2;                   //right
+      ic++;
+    }
+  } else {
+    for(i=0 ; i&lt;framesToProcess; i++ )  {
+      *wptr++ = 0;
+      *wptr++ = 0;
+      ic++;
+    }
+  }
+  if(ic &gt; nwave) {
+    btxok=0;
+    ic=0;
+  }
+  return 0;
+}
+
+void SoundOutThread::run()
+{
+  PaError paerr;
+  PaStreamParameters outParam;
+  PaStream *outStream;
+  paUserData udata;
+  quitExecution = false;
+
+  outParam.device=m_nDevOut;                 //Output device number
+  outParam.channelCount=2;                   //Number of analog channels
+  outParam.sampleFormat=paInt16;             //Send short ints to PortAudio
+  outParam.suggestedLatency=0.05;
+  outParam.hostApiSpecificStreamInfo=NULL;
+
+  paerr=Pa_IsFormatSupported(NULL,&amp;outParam,11025.0);
+  if(paerr&lt;0) {
+    qDebug() &lt;&lt; &quot;PortAudio says requested output format not supported.&quot;;
+    qDebug() &lt;&lt; paerr;
+    return;
+  }
+
+//  udata.nwave=m_nwave;
+//  udata.btxok=false;
+
+  paerr=Pa_OpenStream(&amp;outStream,           //Output stream
+        NULL,                               //No input parameters
+        &amp;outParam,                          //Output parameters
+        11025.0,                            //Sample rate
+        FRAMES_PER_BUFFER,                  //Frames per buffer
+        paClipOff,                          //No clipping
+        d2aCallback,                        //output callbeck routine
+        &amp;udata);                            //userdata
+
+  paerr=Pa_StartStream(outStream);
+  if(paerr&lt;0) {
+    qDebug() &lt;&lt; &quot;Failed to start audio output stream.&quot;;
+    return;
+  }
+  const PaStreamInfo* p=Pa_GetStreamInfo(outStream);
+  outputLatency = p-&gt;outputLatency;
+  bool qe = quitExecution;
+
+//---------------------------------------------- Soundcard output loop
+  while (!qe) {
+    qe = quitExecution;
+    if (qe) break;
+//    udata.nwave=m_nwave;
+//    if(m_txOK) udata.btxok=1;
+//    if(!m_txOK) udata.btxok=0;
+    msleep(100);
+  }
+  Pa_StopStream(outStream);
+  Pa_CloseStream(outStream);
+}
+
+void SoundOutThread::setOutputDevice(int n)      //setOutputDevice()
+{
+  if (isRunning()) return;
+  this-&gt;m_nDevOut=n;
+}


Property changes on: branches/map65/soundout.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/soundout.h
===================================================================
--- branches/map65/soundout.h	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/soundout.h	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,42 +1,42 @@
-#ifndef SOUNDOUT_H
-#define SOUNDOUT_H
-#include &lt;QtCore&gt;
-#include &lt;QDebug&gt;
-
-// An instance of this thread sends audio data to a specified soundcard.
-// Output can be muted while underway, preserving waveform timing when
-// transmission is resumed.
-
-class SoundOutThread : public QThread
-{
-  Q_OBJECT
-
-protected:
-  virtual void run();
-
-public:
-// Constructs (but does not start) a SoundOutThread
-  SoundOutThread()
-    :   quitExecution(false)           // Initialize some private members
-    ,   m_rate(0)
-    ,   m_nwave(48*11025)
-    ,   m_txOK(false)
-    ,   m_txMute(false)
-  {
-  }
-
-public:
-  void setOutputDevice(qint32 n);
-  bool quitExecution;           //If true, thread exits gracefully
-
-
-// Private members
-private:
-  double  m_rate;               //Sample rate
-  qint32  m_nDevOut;            //Output device number
-  qint32  m_nwave;              //Length of wave file
-  bool    m_txOK;               //Enable Tx audio
-  bool    m_txMute;             //Mute temporarily
-};
-
-#endif
+#ifndef SOUNDOUT_H
+#define SOUNDOUT_H
+#include &lt;QtCore&gt;
+#include &lt;QDebug&gt;
+
+// An instance of this thread sends audio data to a specified soundcard.
+// Output can be muted while underway, preserving waveform timing when
+// transmission is resumed.
+
+class SoundOutThread : public QThread
+{
+  Q_OBJECT
+
+protected:
+  virtual void run();
+
+public:
+// Constructs (but does not start) a SoundOutThread
+  SoundOutThread()
+    :   quitExecution(false)           // Initialize some private members
+    ,   m_rate(0)
+    ,   m_nwave(48*11025)
+    ,   m_txOK(false)
+    ,   m_txMute(false)
+  {
+  }
+
+public:
+  void setOutputDevice(qint32 n);
+  bool quitExecution;           //If true, thread exits gracefully
+
+
+// Private members
+private:
+  double  m_rate;               //Sample rate
+  qint32  m_nDevOut;            //Output device number
+  qint32  m_nwave;              //Length of wave file
+  bool    m_txOK;               //Enable Tx audio
+  bool    m_txMute;             //Mute temporarily
+};
+
+#endif


Property changes on: branches/map65/soundout.h
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: branches/map65/widegraph.cpp
===================================================================
--- branches/map65/widegraph.cpp	2012-05-22 16:40:03 UTC (rev 2463)
+++ branches/map65/widegraph.cpp	2012-05-22 17:09:48 UTC (rev 2464)
@@ -1,318 +1,318 @@
-#include &quot;widegraph.h&quot;
-#include &quot;ui_widegraph.h&quot;
-
-#define NFFT 32768
-
-WideGraph::WideGraph(QWidget *parent) :
-  QDialog(parent),
-  ui(new Ui::WideGraph)
-{
-  ui-&gt;setupUi(this);
-  this-&gt;setWindowFlags(Qt::Dialog);
-  this-&gt;installEventFilter(parent); //Installing the filter
-  ui-&gt;widePlot-&gt;setCursor(Qt::CrossCursor);
-  this-&gt;setMaximumWidth(2048);
-  this-&gt;setMaximumHeight(880);
-  ui-&gt;widePlot-&gt;setMaximumHeight(800);
-
-  connect(ui-&gt;widePlot, SIGNAL(freezeDecode1(int)),this,
-          SLOT(wideFreezeDecode(int)));
-
-  //Restore user's settings
-  QString inifile(QApplication::applicationDirPath());
-  inifile += &quot;/map65.ini&quot;;
-  QSettings settings(inifile, QSettings::IniFormat);
-
-  settings.beginGroup(&quot;WideGraph&quot;);
-  ui-&gt;widePlot-&gt;setPlotZero(settings.value(&quot;PlotZero&quot;, 20).toInt());
-  ui-&gt;widePlot-&gt;setPlotGain(settings.value(&quot;PlotGain&quot;, 0).toInt());
-  ui-&gt;zeroSpinBox-&gt;setValue(ui-&gt;widePlot-&gt;getPlotZero());
-  ui-&gt;gainSpinBox-&gt;setValue(ui-&gt;widePlot-&gt;getPlotGain());
-  int n = settings.value(&quot;FreqSpan&quot;,60).toInt();
-  int w = settings.value(&quot;PlotWidth&quot;,1000).toInt();
-  ui-&gt;freqSpanSpinBox-&gt;setValue(n);
-  ui-&gt;widePlot-&gt;setNSpan(n);
-  int nbpp = n * 32768.0/(w*96.0) + 0.5;
-  ui-&gt;widePlot-&gt;setBinsPerPixel(nbpp);
-  m_waterfallAvg = settings.value(&quot;WaterfallAvg&quot;,10).toInt();
-  ui-&gt;waterfallAvgSpinBox-&gt;setValue(m_waterfallAvg);
-  ui-&gt;freqOffsetSpinBox-&gt;setValue(settings.value(&quot;FreqOffset&quot;,0).toInt());
-  m_bForceCenterFreq=settings.value(&quot;ForceCenterFreqBool&quot;,false).toBool();
-  m_dForceCenterFreq=settings.value(&quot;ForceCenterFreqMHz&quot;,144.125).toDouble();
-  ui-&gt;cbFcenter-&gt;setChecked(m_bForceCenterFreq);
-  ui-&gt;fCenterLineEdit-&gt;setText(QString::number(m_dForceCenterFreq));
-  settings.endGroup();
-}
-
-
-WideGraph::~WideGraph()
-{
-  saveSettings();
-  delete ui;
-}
-
-void WideGraph::saveSettings()
-{
-  //Save user's settings
-  QString inifile(QApplication::applicationDirPath());
-  inifile += &quot;/map65.ini&quot;;
-  QSettings settings(inifile, QSettings::IniFormat);
-
-  settings.beginGroup(&quot;WideGraph&quot;);
-  settings.setValue(&quot;PlotZero&quot;,ui-&gt;widePlot-&gt;m_plotZero);
-  settings.setValue(&quot;PlotGain&quot;,ui-&gt;widePlot-&gt;m_plotGain);
-  settings.setValue(&quot;PlotWidth&quot;,ui-&gt;widePlot-&gt;plotWidth());
-  settings.setValue(&quot;FreqSpan&quot;,ui-&gt;freqSpanSpinBox-&gt;value());
-  settings.setValue(&quot;WaterfallAvg&quot;,ui-&gt;waterfallAvgSpinBox-&gt;value());
-  settings.setValue(&quot;FreqOffset&quot;,ui-&gt;widePlot-&gt;freqOffset());
-  settings.setValue(&quot;ForceCenterFreqBool&quot;,m_bForceCenterFreq);
-  settings.setValue(&quot;ForceCenterFreqMHz&quot;,m_dForceCenterFreq);
-  settings.endGroup();
-}
-
-void WideGraph::dataSink2(float s[], int nkhz, int ihsym, int ndiskdata,
-                          uchar lstrong[])
-{
-  static float splot[NFFT];
-  float swide[2048];
-  float smax;
-  double df;
-  int nbpp = ui-&gt;widePlot-&gt;binsPerPixel();
-  static int n=0;
-  static int nkhz0=-999;
-  static int n60z=0;
-
-  df = m_fSample/32768.0;
-  if(nkhz != nkhz0) {
-    ui-&gt;widePlot-&gt;setNkhz(nkhz);                   //Why do we need both?
-    ui-&gt;widePlot-&gt;SetCenterFreq(nkhz);             //Why do we need both?
-    ui-&gt;widePlot-&gt;setFQSO(nkhz,true);
-    nkhz0 = nkhz;
-  }
-
-  //Average spectra over specified number, m_waterfallAvg
-  if (n==0) {
-    for (int i=0; i&lt;NFFT; i++)
-      splot[i]=s[i];
-  } else {
-    for (int i=0; i&lt;NFFT; i++)
-      splot[i] += s[i];
-  }
-  n++;
-
-  if (n&gt;=m_waterfallAvg) {
-    for (int i=0; i&lt;NFFT; i++)
-        splot[i] /= n;                       //Normalize the average
-    n=0;
-
-    int w=ui-&gt;widePlot-&gt;plotWidth();
-    qint64 sf = nkhz + ui-&gt;widePlot-&gt;freqOffset() - 0.5*w*nbpp*df/1000.0;
-    if(sf != ui-&gt;widePlot-&gt;startFreq()) ui-&gt;widePlot-&gt;SetStartFreq(sf);
-    int i0=16384.0+(ui-&gt;widePlot-&gt;startFreq()-nkhz+1.27046+0.001*m_fCal) *
-        1000.0/df + 0.5;
-    int i=i0;
-    for (int j=0; j&lt;2048; j++) {
-        smax=0;
-        for (int k=0; k&lt;nbpp; k++) {
-            i++;
-            if(splot[i]&gt;smax) smax=splot[i];
-        }
-        swide[j]=smax;
-        if(lstrong[1 + i/32]!=0) swide[j]=-smax;   //Tag strong signals
-    }
-
-// Time according to this computer
-    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
-    int n60 = (ms/1000) % 60;
-
-    if((ndiskdata &amp;&amp; ihsym &lt;= m_waterfallAvg) || (!ndiskdata &amp;&amp; n60&lt;n60z)) {
-      for (int i=0; i&lt;2048; i++) {
-        swide[i] = 1.e30;
-      }
-      for (int i=0; i&lt;32768; i++) {
-        splot[i] = 1.e30;
-      }
-    }
-    n60z=n60;
-    ui-&gt;widePlot-&gt;draw(swide,i0,splot);
-  }
-}
-
-void WideGraph::on_freqOffsetSpinBox_valueChanged(int f)
-{
-  ui-&gt;widePlot-&gt;SetFreqOffset(f);
-}
-
-void WideGraph::on_freqSpanSpinBox_valueChanged(int n)
-{
-  ui-&gt;widePlot-&gt;setNSpan(n);
-  int w = ui-&gt;widePlot-&gt;plotWidth();
-  int nbpp = n * 32768.0/(w*96.0) + 0.5;
-  if(nbpp &lt; 1) nbpp=1;
-  if(w &gt; 0) {
-    ui-&gt;widePlot-&gt;setBinsPerPixel(nbpp);
-  }
-}
-
-void WideGraph::on_waterfallAvgSpinBox_valueChanged(int n)
-{
-  m_waterfallAvg = n;
-}
-
-void WideGraph::on_zeroSpinBox_valueChanged(int value)
-{
-  ui-&gt;widePlot-&gt;setPlotZero(value);
-}
-
-void WideGraph::on_gainSpinBox_valueChanged(int value)
-{
-  ui-&gt;widePlot-&gt;setPlotGain(value);
-}
-
-void WideGraph::keyPressEvent(QKeyEvent *e)
-{  
-  switch(e-&gt;key())
-  {
-  case Qt::Key_F11:
-    emit f11f12(11);
-    break;
-  case Qt::Key_F12:
-    emit f11f12(12);
-    break;
-  default:
-    e-&gt;ignore();
-  }
-}
-
-int WideGraph::QSOfreq()
-{
-  return ui-&gt;widePlot-&gt;fQSO();
-}
-
-int WideGraph::nSpan()
-{
-  return ui-&gt;widePlot-&gt;m_nSpan;
-}
-
-float WideGraph::fSpan()
-{
-  return ui-&gt;widePlot-&gt;m_fSpan;
-}
-
-int WideGraph::nStartFreq()
-{
-  return ui-&gt;widePlot-&gt;startFreq();
-}
-
-void WideGraph::wideFreezeDecode(int n)
-{
-  emit freezeDecode2(n);
-}
-
-void WideGraph::setTol(int n)
-{
-  ui-&gt;widePlot-&gt;m_tol=n;
-  ui-&gt;widePlot-&gt;DrawOverlay();
-  ui-&gt;widePlot-&gt;update();
-}
-
-int WideGraph::Tol()
-{
-  return ui-&gt;widePlot-&gt;m_tol;
-}
-
-void WideGraph::setDF(int n)
-{
-  ui-&gt;widePlot-&gt;m_DF=n;
-  ui-&gt;widePlot-&gt;DrawOverlay();
-  ui-&gt;widePlot-&gt;update();
-}
-
-void WideGraph::setFcal(int n)
-{
-  m_fCal=n;
-  ui-&gt;widePlot-&gt;setFcal(n);
-}
-
-
-int WideGraph::DF()
-{
-  return ui-&gt;widePlot-&gt;m_DF;
-}
-
-void WideGraph::on_autoZeroPushButton_clicked()
-{
-   int nzero=ui-&gt;widePlot-&gt;autoZero();
-   ui-&gt;zeroSpinBox-&gt;setValue(nzero);
-}
-
-void WideGraph::setPalette(QString palette)
-{
-  ui-&gt;widePlot-&gt;setPalette(palette);
-}
-void WideGraph::setFsample(int n)
-{
-  m_fSample=n;
-  ui-&gt;widePlot-&gt;setFsample(n);
-}
-
-void WideGraph::setMode65(int n)
-{
-  m_mode65=n;
-  ui-&gt;widePlot-&gt;setMode65(n);
-}
-
-void WideGraph::on_cbFcenter_stateChanged(int n)
-{
-  m_bForceCenterFreq = (n!=0);
-  if(m_bForceCenterFreq) {
-    ui-&gt;fCenterLineEdit-&gt;setEnabled(true);
-    ui-&gt;pbSetRxHardware-&gt;setEnabled(true);
-  } else {
-    ui-&gt;fCenterLineEdit-&gt;setDisabled(true);
-    ui-&gt;pbSetRxHardware-&gt;setDisabled(true);
-  }
-}
-
-void WideGraph::on_fCenterLineEdit_editingFinished()
-{
-  m_dForceCenterFreq=ui-&gt;fCenterLineEdit-&gt;text().toDouble();
-}
-
-void WideGraph::on_pbSetRxHardware_clicked()
-{
-#ifdef WIN32
-  int iret=set570(m_mult570*(1.0+0.000001*m_cal570)*m_dForceCenterFreq);
-  if(iret != 0) {
-    QMessageBox mb;
-    if(iret==-1) mb.setText(&quot;Failed to open Si570.&quot;);
-    if(iret==-2) mb.setText(&quot;Frequency out of permitted range.&quot;);
-    mb.exec();
-  }
-#endif
-}
-
-void WideGraph::initIQplus()
-{
-#ifdef WIN32
-  int iret=set570(288.0);
-  if(iret != 0) {
-    QMessageBox mb;
-    if(iret==-1) mb.setText(&quot;Failed to open Si570.&quot;);
-    if(iret==-2) mb.setText(&quot;Frequency out of permitted range.&quot;);
-    mb.exec();
-  } else {
-    on_pbSetRxHardware_clicked();
-  }
-#endif
-}
-
-void WideGraph::on_cbSpec2d_toggled(bool b)
-{
-  ui-&gt;widePlot-&gt;set2Dspec(b);
-}
-
-double WideGraph::fGreen()
-{
-  return ui-&gt;widePlot-&gt;fGreen();
-}
+#include &quot;widegraph.h&quot;
+#include &quot;ui_widegraph.h&quot;
+
+#define NFFT 32768
+
+WideGraph::WideGraph(QWidget *parent) :
+  QDialog(parent),
+  ui(new Ui::WideGraph)
+{
+  ui-&gt;setupUi(this);
+  this-&gt;setWindowFlags(Qt::Dialog);
+  this-&gt;installEventFilter(parent); //Installing the filter
+  ui-&gt;widePlot-&gt;setCursor(Qt::CrossCursor);
+  this-&gt;setMaximumWidth(2048);
+  this-&gt;setMaximumHeight(880);
+  ui-&gt;widePlot-&gt;setMaximumHeight(800);
+
+  connect(ui-&gt;widePlot, SIGNAL(freezeDecode1(int)),this,
+          SLOT(wideFreezeDecode(int)));
+
+  //Restore user's settings
+  QString inifile(QApplication::applicationDirPath());
+  inifile += &quot;/map65.ini&quot;;
+  QSettings settings(inifile, QSettings::IniFormat);
+
+  settings.beginGroup(&quot;WideGraph&quot;);
+  ui-&gt;widePlot-&gt;setPlotZero(settings.value(&quot;PlotZero&quot;, 20).toInt());
+  ui-&gt;widePlot-&gt;setPlotGain(settings.value(&quot;PlotGain&quot;, 0).toInt());
+  ui-&gt;zeroSpinBox-&gt;setValue(ui-&gt;widePlot-&gt;getPlotZero());
+  ui-&gt;gainSpinBox-&gt;setValue(ui-&gt;widePlot-&gt;getPlotGain());
+  int n = settings.value(&quot;FreqSpan&quot;,60).toInt();
+  int w = settings.value(&quot;PlotWidth&quot;,1000).toInt();
+  ui-&gt;freqSpanSpinBox-&gt;setValue(n);
+  ui-&gt;widePlot-&gt;setNSpan(n);
+  int nbpp = n * 32768.0/(w*96.0) + 0.5;
+  ui-&gt;widePlot-&gt;setBinsPerPixel(nbpp);
+  m_waterfallAvg = settings.value(&quot;WaterfallAvg&quot;,10).toInt();
+  ui-&gt;waterfallAvgSpinBox-&gt;setValue(m_waterfallAvg);
+  ui-&gt;freqOffsetSpinBox-&gt;setValue(settings.value(&quot;FreqOffset&quot;,0).toInt());
+  m_bForceCenterFreq=settings.value(&quot;ForceCenterFreqBool&quot;,false).toBool();
+  m_dForceCenterFreq=settings.value(&quot;ForceCenterFreqMHz&quot;,144.125).toDouble();
+  ui-&gt;cbFcenter-&gt;setChecked(m_bForceCenterFreq);
+  ui-&gt;fCenterLineEdit-&gt;setText(QString::number(m_dForceCenterFreq));
+  settings.endGroup();
+}
+
+
+WideGraph::~WideGraph()
+{
+  saveSettings();
+  delete ui;
+}
+
+void WideGraph::saveSettings()
+{
+  //Save user's settings
+  QString inifile(QApplication::applicationDirPath());
+  inifile += &quot;/map65.ini&quot;;
+  QSettings settings(inifile, QSettings::IniFormat);
+
+  settings.beginGroup(&quot;WideGraph&quot;);
+  settings.setValue(&quot;PlotZero&quot;,ui-&gt;widePlot-&gt;m_plotZero);
+  settings.setValue(&quot;PlotGain&quot;,ui-&gt;widePlot-&gt;m_plotGain);
+  settings.setValue(&quot;PlotWidth&quot;,ui-&gt;widePlot-&gt;plotWidth());
+  settings.setValue(&quot;FreqSpan&quot;,ui-&gt;freqSpanSpinBox-&gt;value());
+  settings.setValue(&quot;WaterfallAvg&quot;,ui-&gt;waterfallAvgSpinBox-&gt;value());
+  settings.setValue(&quot;FreqOffset&quot;,ui-&gt;widePlot-&gt;freqOffset());
+  settings.setValue(&quot;ForceCenterFreqBool&quot;,m_bForceCenterFreq);
+  settings.setValue(&quot;ForceCenterFreqMHz&quot;,m_dForceCenterFreq);
+  settings.endGroup();
+}
+
+void WideGraph::dataSink2(float s[], int nkhz, int ihsym, int ndiskdata,
+                          uchar lstrong[])
+{
+  static float splot[NFFT];
+  float swide[2048];
+  float smax;
+  double df;
+  int nbpp = ui-&gt;widePlot-&gt;binsPerPixel();
+  static int n=0;
+  static int nkhz0=-999;
+  static int n60z=0;
+
+  df = m_fSample/32768.0;
+  if(nkhz != nkhz0) {
+    ui-&gt;widePlot-&gt;setNkhz(nkhz);                   //Why do we need both?
+    ui-&gt;widePlot-&gt;SetCenterFreq(nkhz);             //Why do we need both?
+    ui-&gt;widePlot-&gt;setFQSO(nkhz,true);
+    nkhz0 = nkhz;
+  }
+
+  //Average spectra over specified number, m_waterfallAvg
+  if (n==0) {
+    for (int i=0; i&lt;NFFT; i++)
+      splot[i]=s[i];
+  } else {
+    for (int i=0; i&lt;NFFT; i++)
+      splot[i] += s[i];
+  }
+  n++;
+
+  if (n&gt;=m_waterfallAvg) {
+    for (int i=0; i&lt;NFFT; i++)
+        splot[i] /= n;                       //Normalize the average
+    n=0;
+
+    int w=ui-&gt;widePlot-&gt;plotWidth();
+    qint64 sf = nkhz + ui-&gt;widePlot-&gt;freqOffset() - 0.5*w*nbpp*df/1000.0;
+    if(sf != ui-&gt;widePlot-&gt;startFreq()) ui-&gt;widePlot-&gt;SetStartFreq(sf);
+    int i0=16384.0+(ui-&gt;widePlot-&gt;startFreq()-nkhz+1.27046+0.001*m_fCal) *
+        1000.0/df + 0.5;
+    int i=i0;
+    for (int j=0; j&lt;2048; j++) {
+        smax=0;
+        for (int k=0; k&lt;nbpp; k++) {
+            i++;
+            if(splot[i]&gt;smax) smax=splot[i];
+        }
+        swide[j]=smax;
+        if(lstrong[1 + i/32]!=0) swide[j]=-smax;   //Tag strong signals
+    }
+
+// Time according to this computer
+    qint64 ms = QDateTime::currentMSecsSinceEpoch() % 86400000;
+    int n60 = (ms/1000) % 60;
+
+    if((ndiskdata &amp;&amp; ihsym &lt;= m_waterfallAvg) || (!ndiskdata &amp;&amp; n60&lt;n60z)) {
+      for (int i=0; i&lt;2048; i++) {
+        swide[i] = 1.e30;
+      }
+      for (int i=0; i&lt;32768; i++) {
+        splot[i] = 1.e30;
+      }
+    }
+    n60z=n60;
+    ui-&gt;widePlot-&gt;draw(swide,i0,splot);
+  }
+}
+
+void WideGraph::on_freqOffsetSpinBox_valueChanged(int f)
+{
+  ui-&gt;widePlot-&gt;SetFreqOffset(f);
+}
+
+void WideGraph::on_freqSpanSpinBox_valueChanged(int n)
+{
+  ui-&gt;widePlot-&gt;setNSpan(n);
+  int w = ui-&gt;widePlot-&gt;plotWidth();
+  int nbpp = n * 32768.0/(w*96.0) + 0.5;
+  if(nbpp &lt; 1) nbpp=1;
+  if(w &gt; 0) {
+    ui-&gt;widePlot-&gt;setBinsPerPixel(nbpp);
+  }
+}
+
+void WideGraph::on_waterfallAvgSpinBox_valueChanged(int n)
+{
+  m_waterfallAvg = n;
+}
+
+void WideGraph::on_zeroSpinBox_valueChanged(int value)
+{
+  ui-&gt;widePlot-&gt;setPlotZero(value);
+}
+
+void WideGraph::on_gainSpinBox_valueChanged(int value)
+{
+  ui-&gt;widePlot-&gt;setPlotGain(value);
+}
+
+void WideGraph::keyPressEvent(QKeyEvent *e)
+{  
+  switch(e-&gt;key())
+  {
+  case Qt::Key_F11:
+    emit f11f12(11);
+    break;
+  case Qt::Key_F12:
+    emit f11f12(12);
+    break;
+  default:
+    e-&gt;ignore();
+  }
+}
+
+int WideGraph::QSOfreq()
+{
+  return ui-&gt;widePlot-&gt;fQSO();
+}
+
+int WideGraph::nSpan()
+{
+  return ui-&gt;widePlot-&gt;m_nSpan;
+}
+
+float WideGraph::fSpan()
+{
+  return ui-&gt;widePlot-&gt;m_fSpan;
+}
+
+int WideGraph::nStartFreq()
+{
+  return ui-&gt;widePlot-&gt;startFreq();
+}
+
+void WideGraph::wideFreezeDecode(int n)
+{
+  emit freezeDecode2(n);
+}
+
+void WideGraph::setTol(int n)
+{
+  ui-&gt;widePlot-&gt;m_tol=n;
+  ui-&gt;widePlot-&gt;DrawOverlay();
+  ui-&gt;widePlot-&gt;update();
+}
+
+int WideGraph::Tol()
+{
+  return ui-&gt;widePlot-&gt;m_tol;
+}
+
+void WideGraph::setDF(int n)
+{
+  ui-&gt;widePlot-&gt;m_DF=n;
+  ui-&gt;widePlot-&gt;DrawOverlay();
+  ui-&gt;widePlot-&gt;update();
+}
+
+void WideGraph::setFcal(int n)
+{
+  m_fCal=n;
+  ui-&gt;widePlot-&gt;setFcal(n);
+}
+
+
+int WideGraph::DF()
+{
+  return ui-&gt;widePlot-&gt;m_DF;
+}
+
+void WideGraph::on_autoZeroPushButton_clicked()
+{
+   int nzero=ui-&gt;widePlot-&gt;autoZero();
+   ui-&gt;zeroSpinBox-&gt;setValue(nzero);
+}
+
+void WideGraph::setPalette(QString palette)
+{
+  ui-&gt;widePlot-&gt;setPalette(palette);
+}
+void WideGraph::setFsample(int n)
+{
+  m_fSample=n;
+  ui-&gt;widePlot-&gt;setFsample(n);
+}
+
+void WideGraph::setMode65(int n)
+{
+  m_mode65=n;
+  ui-&gt;widePlot-&gt;setMode65(n);
+}
+
+void WideGraph::on_cbFcenter_stateChanged(int n)
+{
+  m_bForceCenterFreq = (n!=0);
+  if(m_bForceCenterFreq) {
+    ui-&gt;fCenterLineEdit-&gt;setEnabled(true);
+    ui-&gt;pbSetRxHardware-&gt;setEnabled(true);
+  } else {
+    ui-&gt;fCenterLineEdit-&gt;setDisabled(true);
+    ui-&gt;pbSetRxHardware-&gt;setDisabled(true);
+  }
+}
+
+void WideGraph::on_fCenterLineEdit_editingFinished()
+{
+  m_dForceCenterFreq=ui-&gt;fCenterLineEdit-&gt;text().toDouble();
+}
+
+void WideGraph::on_pbSetRxHardware_clicked()
+{
+#ifdef WIN32
+  int iret=set570(m_mult570*(1.0+0.000001*m_cal570)*m_dForceCenterFreq);
+  if(iret != 0) {
+    QMessageBox mb;
+    if(iret==-1) mb.setText(&quot;Failed to open Si570.&quot;);
+    if(iret==-2) mb.setText(&quot;Frequency out of permitted range.&quot;);
+    mb.exec();
+  }
+#endif
+}
+
+void WideGraph::initIQplus()
+{
+#ifdef WIN32
+  int iret=set570(288.0);
+  if(iret != 0) {
+    QMessageBox mb;
+    if(iret==-1) mb.setText(&quot;Failed to open Si570.&quot;);
+    if(iret==-2) mb.setText(&quot;Frequency out of permitted range.&quot;);
+    mb.exec();
+  } else {
+    on_pbSetRxHardware_clicked();
+  }
+#endif
+}
+
+void WideGraph::on_cbSpec2d_toggled(bool b)
+{
+  ui-&gt;widePlot-&gt;set2Dspec(b);
+}
+
+double WideGraph::fGreen()
+{
+  return ui-&gt;widePlot-&gt;fGreen();
+}


Property changes on: branches/map65/widegraph.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002155.html">[WSJT-SVN] r2463 - branches/map65
</A></li>
	<LI>Next message: <A HREF="002156.html">[WSJT-SVN] r2465 - branches/map65
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2157">[ date ]</a>
              <a href="thread.html#2157">[ thread ]</a>
              <a href="subject.html#2157">[ subject ]</a>
              <a href="author.html#2157">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
