<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2455 - branches/map65
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2011-October/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2455%20-%20branches/map65&In-Reply-To=%3C20111003200258.BEB8D4812C1%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="002148.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2455 - branches/map65</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2455%20-%20branches/map65&In-Reply-To=%3C20111003200258.BEB8D4812C1%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r2455 - branches/map65">k1jt at mail.berlios.de
       </A><BR>
    <I>Mon Oct  3 22:02:58 CEST 2011</I>
    <P><UL>
        
        <LI>Next message: <A HREF="002148.html">[WSJT-SVN] r2456 - branches/map65
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2147">[ date ]</a>
              <a href="thread.html#2147">[ thread ]</a>
              <a href="subject.html#2147">[ subject ]</a>
              <a href="author.html#2147">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2011-10-03 22:02:58 +0200 (Mon, 03 Oct 2011)
New Revision: 2455

Added:
   branches/map65/astro.f
   branches/map65/astro0.f90
   branches/map65/audio_init.f90
   branches/map65/decode1.f90
   branches/map65/deep65.f
   branches/map65/display.f90
   branches/map65/fivehz.f90
   branches/map65/flushqqq.f90
   branches/map65/ftn_init.f90
   branches/map65/getfile.f90
   branches/map65/getfile2.f90
   branches/map65/map65a.f90
   branches/map65/recvpkt.f90
   branches/map65/rfile3a.f90
   branches/map65/runqqq.f90
   branches/map65/savetf2.f90
   branches/map65/sec_midn.f90
   branches/map65/wsjtgen.f90
Removed:
   branches/map65/astro.F
   branches/map65/astro0.F90
   branches/map65/audio_init.F90
   branches/map65/decode1.F90
   branches/map65/deep65.F
   branches/map65/display.F90
   branches/map65/fivehz.F90
   branches/map65/flushqqq.F90
   branches/map65/ftn_init.F90
   branches/map65/getfile.F90
   branches/map65/getfile2.F90
   branches/map65/map65a.F90
   branches/map65/recvpkt.F90
   branches/map65/rfile3a.F90
   branches/map65/runqqq.F90
   branches/map65/savetf2.F90
   branches/map65/sec_midn.F90
   branches/map65/wsjtgen.F90
Modified:
   branches/map65/plrs.F90
   branches/map65/plrs_subs.c
Log:
Change file names .F to .f, .F90 to .f90


Deleted: branches/map65/astro.F
===================================================================
--- branches/map65/astro.F	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/astro.F	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,115 +0,0 @@
-      subroutine astro(AppDir,nyear,month,nday,uth,nfreq,Mygrid,
-     +     NStation,mode,MoonDX,AzSun,ElSun,AzMoon,ElMoon0,
-     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
-     +     poloffset,xnr,auxra,auxdec,azaux,elaux)
-
-C  Computes astronomical quantities for display in JT65, CW, and EME Echo mode.
-C  NB: may want to smooth the Tsky map to 10 degrees or so.
-
-      character*80 AppDir,fname
-      character*6 MyGrid,HisGrid
-      logical first,ltsky
-      real LST
-      real lat,lon
-      real ldeg
-      integer*1 n1sky(129600)
-      integer*2 nsky
-      common/sky/ nsky(360,180)
-      common/echo/xdop(2),techo,ElMoon,mjd
-      equivalence (n1sky,nsky)
-      data first/.true./
-      data rad/57.2957795/
-      save
-
-      if(first) then
-	do i=80,1,-1
-	   if(ichar(AppDir(i:i)).ne.0 .and. 
-     +            ichar(AppDir(i:i)).ne.32) go to 1
-	enddo
- 1	lenappdir=i
-        call zero(nsky,180*180)
-	fname=Appdir(1:lenappdir)//'/TSKY.DAT'
-        call cs_lock('astro')
-#ifdef CVF
-        open(13,file=fname,status='old',form='binary',err=10)
-        read(13) nsky
-        close(13)
-#else
-        open(13,file=fname,status='old',access='stream',err=10)
-        read(13) nsky
-        close(13)
-#endif
-        ltsky=.true.
-        first=.false.
-        call cs_unlock
-      endif
-      go to 20
- 10   ltsky=.false.
-      call cs_unlock
-
- 20   call grid2deg(MyGrid,elon,lat)
-      lon=-elon
-      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
-     +    AzSun,ElSun,mjd)
-
-      freq=nfreq*1.e6
-
-      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
-     +  LST,HA,AzMoon,ElMoon,ldeg,bdeg,vr,dist)
-
-C  Compute spatial polarization offset
-      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
-     +     cos(AzMoon/rad)*sin(ElMoon/rad)
-      yy=cos(lat/rad)*sin(AzMoon/rad)
-      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
-      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
-
-      techo=2.0 * dist/2.99792458e5                 !Echo delay time
-      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
-      t408=ftsky(ldeg,bdeg)                         !Read sky map
-      tsky=t408*(408.0/nfreq)**2.6                  !Tsky for obs freq
-      if(ltsky.and.(tsky.lt.3.0)) tsky=3.0          !Minimum = 3 Kelvin
-
-      xdop(NStation)=doppler
-      if(NStation.eq.2) then
-         HisGrid=MyGrid
-         go to 900
-      endif
-
-      doppler00=2.0*xdop(1)
-      if(mode.eq.2 .or. mode.eq.5) doppler=xdop(1)+xdop(2)
-      if(mode.eq.3) doppler=2.0*xdop(1)
-      dBMoon=-40.0*log10(dist/356903.)
-      sd=16.23*370152.0/dist
-
-!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
-!     +    (mode.eq.2 .or. mode.eq.5)) then
-      if(NStation.eq.1 .and. MoonDX.ne.0) then
-         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
-         if(poloffset.gt.90.0) poloffset=poloffset-180.0
-         x1=abs(cos(2*poloffset/rad))
-         if(x1.lt.0.056234) x1=0.056234
-         xnr=-20.0*log10(x1)
-         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'Z') xnr=0
-      endif
-
-      tr=80.0                              !Good preamp
-      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
-      tsysmin=tskymin+tr
-      tsys=tsky+tr
-      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
-
- 900  ElMoon0=Elmoon
-      ntsky=nint(tsky)
-
-      auxHA = 15.0*(LST-auxra)                       !HA in degrees
-      pi=3.14159265
-      pio2=0.5*pi
-      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
-     +  auxdec/rad,azaux,elaux)
-      AzAux=azaux*rad
-      ElAux=ElAux*rad
-
-      return
-
-      end

Copied: branches/map65/astro.f (from rev 2454, branches/map65/astro.F)
===================================================================
--- branches/map65/astro.f	                        (rev 0)
+++ branches/map65/astro.f	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,115 @@
+      subroutine astro(AppDir,nyear,month,nday,uth,nfreq,Mygrid,
+     +     NStation,mode,MoonDX,AzSun,ElSun,AzMoon,ElMoon0,
+     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
+     +     poloffset,xnr,auxra,auxdec,azaux,elaux)
+
+C  Computes astronomical quantities for display in JT65, CW, and EME Echo mode.
+C  NB: may want to smooth the Tsky map to 10 degrees or so.
+
+      character*80 AppDir,fname
+      character*6 MyGrid,HisGrid
+      logical first,ltsky
+      real LST
+      real lat,lon
+      real ldeg
+      integer*1 n1sky(129600)
+      integer*2 nsky
+      common/sky/ nsky(360,180)
+      common/echo/xdop(2),techo,ElMoon,mjd
+      equivalence (n1sky,nsky)
+      data first/.true./
+      data rad/57.2957795/
+      save
+
+      if(first) then
+	do i=80,1,-1
+	   if(ichar(AppDir(i:i)).ne.0 .and. 
+     +            ichar(AppDir(i:i)).ne.32) go to 1
+	enddo
+ 1	lenappdir=i
+        call zero(nsky,180*180)
+	fname=Appdir(1:lenappdir)//'/TSKY.DAT'
+        call cs_lock('astro')
+#ifdef CVF
+        open(13,file=fname,status='old',form='binary',err=10)
+        read(13) nsky
+        close(13)
+#else
+        open(13,file=fname,status='old',access='stream',err=10)
+        read(13) nsky
+        close(13)
+#endif
+        ltsky=.true.
+        first=.false.
+        call cs_unlock
+      endif
+      go to 20
+ 10   ltsky=.false.
+      call cs_unlock
+
+ 20   call grid2deg(MyGrid,elon,lat)
+      lon=-elon
+      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
+     +    AzSun,ElSun,mjd)
+
+      freq=nfreq*1.e6
+
+      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
+     +  LST,HA,AzMoon,ElMoon,ldeg,bdeg,vr,dist)
+
+C  Compute spatial polarization offset
+      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
+     +     cos(AzMoon/rad)*sin(ElMoon/rad)
+      yy=cos(lat/rad)*sin(AzMoon/rad)
+      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
+      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
+
+      techo=2.0 * dist/2.99792458e5                 !Echo delay time
+      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
+      t408=ftsky(ldeg,bdeg)                         !Read sky map
+      tsky=t408*(408.0/nfreq)**2.6                  !Tsky for obs freq
+      if(ltsky.and.(tsky.lt.3.0)) tsky=3.0          !Minimum = 3 Kelvin
+
+      xdop(NStation)=doppler
+      if(NStation.eq.2) then
+         HisGrid=MyGrid
+         go to 900
+      endif
+
+      doppler00=2.0*xdop(1)
+      if(mode.eq.2 .or. mode.eq.5) doppler=xdop(1)+xdop(2)
+      if(mode.eq.3) doppler=2.0*xdop(1)
+      dBMoon=-40.0*log10(dist/356903.)
+      sd=16.23*370152.0/dist
+
+!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
+!     +    (mode.eq.2 .or. mode.eq.5)) then
+      if(NStation.eq.1 .and. MoonDX.ne.0) then
+         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
+         if(poloffset.gt.90.0) poloffset=poloffset-180.0
+         x1=abs(cos(2*poloffset/rad))
+         if(x1.lt.0.056234) x1=0.056234
+         xnr=-20.0*log10(x1)
+         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'Z') xnr=0
+      endif
+
+      tr=80.0                              !Good preamp
+      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
+      tsysmin=tskymin+tr
+      tsys=tsky+tr
+      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
+
+ 900  ElMoon0=Elmoon
+      ntsky=nint(tsky)
+
+      auxHA = 15.0*(LST-auxra)                       !HA in degrees
+      pi=3.14159265
+      pio2=0.5*pi
+      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
+     +  auxdec/rad,azaux,elaux)
+      AzAux=azaux*rad
+      ElAux=ElAux*rad
+
+      return
+
+      end

Deleted: branches/map65/astro0.F90
===================================================================
--- branches/map65/astro0.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/astro0.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,123 +0,0 @@
-subroutine astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
-     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
-     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
-     RaAux8,DecAux8,AzAux8,ElAux8)
-
-!f2py intent(in) nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec
-!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8
-
-  character grid*6
-  character*9 cauxra,cauxdec
-  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,AzAux8,ElAux8
-  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0
-  real*8 sd8,poloffset8
-  include 'gcom2.f90'
-  data uth8z/0.d0/,imin0/-99/
-  save
-
-  call cs_lock('astro0a')
-  auxra=0.
-  i=index(cauxra,':')
-  if(i.eq.0) then
-     read(cauxra,*,err=1,end=1) auxra
-  else
-     read(cauxra(1:i-1),*,err=1,end=1) ih
-     read(cauxra(i+1:i+2),*,err=1,end=1) im
-     read(cauxra(i+4:i+5),*,err=1,end=1) is
-     auxra=ih + im/60.0 + is/3600.0
-  endif
-1 auxdec=0.
-  i=index(cauxdec,':')
-  if(i.eq.0) then
-     read(cauxdec,*,err=2,end=2) auxdec
-  else
-     read(cauxdec(1:i-1),*,err=2,end=2) id
-     read(cauxdec(i+1:i+2),*,err=2,end=2) im
-     read(cauxdec(i+4:i+5),*,err=2,end=2) is
-     auxdec=abs(id) + im/60.0 + is/3600.0
-     if(cauxdec(1:1).eq.'-') auxdec=-auxdec
-  endif
-
-2 nmode=1
-  if(mode(1:4).eq.'JT65') then
-     nmode=2
-     if(mode(5:5).eq.'A') mode65=1
-     if(mode(5:5).eq.'B') mode65=2
-     if(mode(5:5).eq.'C') mode65=4
-  endif
-  if(mode.eq.'Echo') nmode=3
-  if(mode.eq.'JT6M') nmode=4
-  uth=uth8
-
-  call cs_unlock
-  call astro(AppDir,nyear,month,nday,uth,nfreq,hisgrid,2,nmode,1,    &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
-  AzMoonB8=AzMoon
-  ElMoonB8=ElMoon
-  call astro(AppDir,nyear,month,nday,uth,nfreq,grid,1,nmode,1,       &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
-
-  RaAux8=auxra
-  DecAux8=auxdec
-  AzSun8=AzSun
-  ElSun8=ElSun
-  AzMoon8=AzMoon
-  ElMoon8=ElMoon
-  dbMoon8=dbMoon
-  RAMoon8=RAMoon/15.0
-  DecMoon8=DecMoon
-  HA8=HA
-  Dgrd8=Dgrd
-  sd8=sd
-  poloffset8=poloffset
-  xnr8=xnr
-  AzAux8=AzAux
-  ElAux8=ElAux
-  ndop=nint(doppler)
-  ndop00=nint(doppler00)
-
-  if(uth8z.eq.0.d0) then
-     uth8z=uth8-1.d0/3600.d0
-     dopplerz=doppler
-     doppler00z=doppler00
-  endif
-     
-  dt=60.0*(uth8-uth8z)
-  if(dt.le.0) dt=1.d0/60.d0
-  dfdt=(doppler-dopplerz)/dt
-  dfdt0=(doppler00-doppler00z)/dt
-  uth8z=uth8
-  dopplerz=doppler
-  doppler00z=doppler00
-
-  imin=60*uth8
-  isec=3600*uth8
-
-  if(isec.ne.isec0 .and. ndecoding.eq.0) then
-     call cs_lock('astro0b')
-     ih=uth8
-     im=mod(imin,60)
-     is=mod(isec,60)
-     rewind 14
-     write(14,1010) ih,im,is,AzMoon,ElMoon,                          &amp;
-        ih,im,is,AzSun,ElSun,                                        &amp;
-        ih,im,is,AzAux,ElAux,                                        &amp;
-        nfreq,doppler,dfdt,doppler00,dfdt0,                          &amp;
-        mousefqso,nsetftx
-1010 format(i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Moon'/        &amp;
-            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Sun'/         &amp;
-            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Source'/      &amp;
-            i4,',',f8.1,',',f8.2,',',f8.1,',',f8.2,',Doppler'/       &amp;
-            i4,',',i1,',fQSO')
-     call flushqqq(14)
-     nsetftx=0
-     isec0=isec
-     call cs_unlock
-  endif
-
-  return
-end subroutine astro0

Copied: branches/map65/astro0.f90 (from rev 2454, branches/map65/astro0.F90)
===================================================================
--- branches/map65/astro0.f90	                        (rev 0)
+++ branches/map65/astro0.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,123 @@
+subroutine astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
+     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
+     RaAux8,DecAux8,AzAux8,ElAux8)
+
+!f2py intent(in) nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec
+!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8
+
+  character grid*6
+  character*9 cauxra,cauxdec
+  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,AzAux8,ElAux8
+  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0
+  real*8 sd8,poloffset8
+  include 'gcom2.f90'
+  data uth8z/0.d0/,imin0/-99/
+  save
+
+  call cs_lock('astro0a')
+  auxra=0.
+  i=index(cauxra,':')
+  if(i.eq.0) then
+     read(cauxra,*,err=1,end=1) auxra
+  else
+     read(cauxra(1:i-1),*,err=1,end=1) ih
+     read(cauxra(i+1:i+2),*,err=1,end=1) im
+     read(cauxra(i+4:i+5),*,err=1,end=1) is
+     auxra=ih + im/60.0 + is/3600.0
+  endif
+1 auxdec=0.
+  i=index(cauxdec,':')
+  if(i.eq.0) then
+     read(cauxdec,*,err=2,end=2) auxdec
+  else
+     read(cauxdec(1:i-1),*,err=2,end=2) id
+     read(cauxdec(i+1:i+2),*,err=2,end=2) im
+     read(cauxdec(i+4:i+5),*,err=2,end=2) is
+     auxdec=abs(id) + im/60.0 + is/3600.0
+     if(cauxdec(1:1).eq.'-') auxdec=-auxdec
+  endif
+
+2 nmode=1
+  if(mode(1:4).eq.'JT65') then
+     nmode=2
+     if(mode(5:5).eq.'A') mode65=1
+     if(mode(5:5).eq.'B') mode65=2
+     if(mode(5:5).eq.'C') mode65=4
+  endif
+  if(mode.eq.'Echo') nmode=3
+  if(mode.eq.'JT6M') nmode=4
+  uth=uth8
+
+  call cs_unlock
+  call astro(AppDir,nyear,month,nday,uth,nfreq,hisgrid,2,nmode,1,    &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
+       AzAux,ElAux)
+  AzMoonB8=AzMoon
+  ElMoonB8=ElMoon
+  call astro(AppDir,nyear,month,nday,uth,nfreq,grid,1,nmode,1,       &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
+       AzAux,ElAux)
+
+  RaAux8=auxra
+  DecAux8=auxdec
+  AzSun8=AzSun
+  ElSun8=ElSun
+  AzMoon8=AzMoon
+  ElMoon8=ElMoon
+  dbMoon8=dbMoon
+  RAMoon8=RAMoon/15.0
+  DecMoon8=DecMoon
+  HA8=HA
+  Dgrd8=Dgrd
+  sd8=sd
+  poloffset8=poloffset
+  xnr8=xnr
+  AzAux8=AzAux
+  ElAux8=ElAux
+  ndop=nint(doppler)
+  ndop00=nint(doppler00)
+
+  if(uth8z.eq.0.d0) then
+     uth8z=uth8-1.d0/3600.d0
+     dopplerz=doppler
+     doppler00z=doppler00
+  endif
+     
+  dt=60.0*(uth8-uth8z)
+  if(dt.le.0) dt=1.d0/60.d0
+  dfdt=(doppler-dopplerz)/dt
+  dfdt0=(doppler00-doppler00z)/dt
+  uth8z=uth8
+  dopplerz=doppler
+  doppler00z=doppler00
+
+  imin=60*uth8
+  isec=3600*uth8
+
+  if(isec.ne.isec0 .and. ndecoding.eq.0) then
+     call cs_lock('astro0b')
+     ih=uth8
+     im=mod(imin,60)
+     is=mod(isec,60)
+     rewind 14
+     write(14,1010) ih,im,is,AzMoon,ElMoon,                          &amp;
+        ih,im,is,AzSun,ElSun,                                        &amp;
+        ih,im,is,AzAux,ElAux,                                        &amp;
+        nfreq,doppler,dfdt,doppler00,dfdt0,                          &amp;
+        mousefqso,nsetftx
+1010 format(i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Moon'/        &amp;
+            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Sun'/         &amp;
+            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Source'/      &amp;
+            i4,',',f8.1,',',f8.2,',',f8.1,',',f8.2,',Doppler'/       &amp;
+            i4,',',i1,',fQSO')
+     call flushqqq(14)
+     nsetftx=0
+     isec0=isec
+     call cs_unlock
+  endif
+
+  return
+end subroutine astro0

Deleted: branches/map65/audio_init.F90
===================================================================
--- branches/map65/audio_init.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/audio_init.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,74 +0,0 @@
-!------------------------------------------------ audio_init
-subroutine audio_init(ndin,ndout)
-
-#ifdef CVF
-  use dfmt
-  integer Thread1,Thread2,Thread3
-  external a2d,decode1,recvpkt
-#endif
-
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  nmode=2
-  if(mode(5:5).eq.'A') mode65=1
-  if(mode(5:5).eq.'B') mode65=2
-  if(mode(5:5).eq.'C') mode65=4
-  ndevout=ndout
-  TxOK=0
-  Transmitting=0
-  nfsample=11025
-  nspb=1024
-  nbufs=2048
-  nmax=nbufs*nspb
-  nwave=60*nfsample
-  ngo=1
-  f0=800.0
-  do i=1,nwave
-     iwave(i)=nint(32767.0*sin(6.283185307*i*f0/nfsample))
-  enddo
-
-#ifdef CVF
-!  Priority classes (for processes):
-!     IDLE_PRIORITY_CLASS               64
-!     NORMAL_PRIORITY_CLASS             32
-!     HIGH_PRIORITY_CLASS              128
-
-!  Priority definitions (for threads):
-!     THREAD_PRIORITY_IDLE             -15
-!     THREAD_PRIORITY_LOWEST            -2
-!     THREAD_PRIORITY_BELOW_NORMAL      -1
-!     THREAD_PRIORITY_NORMAL             0
-!     THREAD_PRIORITY_ABOVE_NORMAL       1
-!     THREAD_PRIORITY_HIGHEST            2
-!     THREAD_PRIORITY_TIME_CRITICAL     15
-    
-  m0=SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS)
-!  m0=SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS)
-
-! Start a thread for doing A/D and D/A with sound card.
-!  (actually, only D/A is used in MAP65)
-  Thread1=CreateThread(0,0,a2d,0,CREATE_SUSPENDED,id1)
-  m1=SetThreadPriority(Thread1,THREAD_PRIORITY_ABOVE_NORMAL)
-  m2=ResumeThread(Thread1)
-
-! Start a thread for background decoding.
-  Thread2=CreateThread(0,0,decode1,0,CREATE_SUSPENDED,id2)
-  m3=SetThreadPriority(Thread2,THREAD_PRIORITY_BELOW_NORMAL)
-  m4=ResumeThread(Thread2)
-
-! Start a thread to receive packets from Linrad
-  Thread3=CreateThread(0,0,recvpkt,0,CREATE_SUSPENDED,id3)
-  m5=SetThreadPriority(Thread3,THREAD_PRIORITY_ABOVE_NORMAL)
-  m6=ResumeThread(Thread3)
-
-#else
-!  print*,'Audio INIT called.'
-  ierr=start_threads(ndevin,ndevout,y1,y2,nmax,iwrite,iwave,nwave,    &amp;
-       11025,NSPB,TRPeriod,TxOK,ndebug,Transmitting,            &amp;
-       Tsec,ngo,nmode,tbuf,ibuf,ndsec,PttPort,devin_name,devout_name)
-
-#endif
-
-  return
-end subroutine audio_init

Copied: branches/map65/audio_init.f90 (from rev 2454, branches/map65/audio_init.F90)
===================================================================
--- branches/map65/audio_init.f90	                        (rev 0)
+++ branches/map65/audio_init.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,74 @@
+!------------------------------------------------ audio_init
+subroutine audio_init(ndin,ndout)
+
+#ifdef CVF
+  use dfmt
+  integer Thread1,Thread2,Thread3
+  external a2d,decode1,recvpkt
+#endif
+
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+
+  nmode=2
+  if(mode(5:5).eq.'A') mode65=1
+  if(mode(5:5).eq.'B') mode65=2
+  if(mode(5:5).eq.'C') mode65=4
+  ndevout=ndout
+  TxOK=0
+  Transmitting=0
+  nfsample=11025
+  nspb=1024
+  nbufs=2048
+  nmax=nbufs*nspb
+  nwave=60*nfsample
+  ngo=1
+  f0=800.0
+  do i=1,nwave
+     iwave(i)=nint(32767.0*sin(6.283185307*i*f0/nfsample))
+  enddo
+
+#ifdef CVF
+!  Priority classes (for processes):
+!     IDLE_PRIORITY_CLASS               64
+!     NORMAL_PRIORITY_CLASS             32
+!     HIGH_PRIORITY_CLASS              128
+
+!  Priority definitions (for threads):
+!     THREAD_PRIORITY_IDLE             -15
+!     THREAD_PRIORITY_LOWEST            -2
+!     THREAD_PRIORITY_BELOW_NORMAL      -1
+!     THREAD_PRIORITY_NORMAL             0
+!     THREAD_PRIORITY_ABOVE_NORMAL       1
+!     THREAD_PRIORITY_HIGHEST            2
+!     THREAD_PRIORITY_TIME_CRITICAL     15
+    
+  m0=SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS)
+!  m0=SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS)
+
+! Start a thread for doing A/D and D/A with sound card.
+!  (actually, only D/A is used in MAP65)
+  Thread1=CreateThread(0,0,a2d,0,CREATE_SUSPENDED,id1)
+  m1=SetThreadPriority(Thread1,THREAD_PRIORITY_ABOVE_NORMAL)
+  m2=ResumeThread(Thread1)
+
+! Start a thread for background decoding.
+  Thread2=CreateThread(0,0,decode1,0,CREATE_SUSPENDED,id2)
+  m3=SetThreadPriority(Thread2,THREAD_PRIORITY_BELOW_NORMAL)
+  m4=ResumeThread(Thread2)
+
+! Start a thread to receive packets from Linrad
+  Thread3=CreateThread(0,0,recvpkt,0,CREATE_SUSPENDED,id3)
+  m5=SetThreadPriority(Thread3,THREAD_PRIORITY_ABOVE_NORMAL)
+  m6=ResumeThread(Thread3)
+
+#else
+!  print*,'Audio INIT called.'
+  ierr=start_threads(ndevin,ndevout,y1,y2,nmax,iwrite,iwave,nwave,    &amp;
+       11025,NSPB,TRPeriod,TxOK,ndebug,Transmitting,            &amp;
+       Tsec,ngo,nmode,tbuf,ibuf,ndsec,PttPort,devin_name,devout_name)
+
+#endif
+
+  return
+end subroutine audio_init

Deleted: branches/map65/decode1.F90
===================================================================
--- branches/map65/decode1.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/decode1.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,87 +0,0 @@
-subroutine decode1(iarg)
-
-! Get data and parameters from gcom, then call the decoders when needed.
-! This routine runs in a background thread and will never return.
-
-#ifdef CVF
-  use dflib
-#endif
-
-  character sending0*28,mode0*6,cshort*11
-  integer sendingsh0
-
-  include 'datcom.f90'
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  include 'gcom4.f90'
-  data kbuf0/0/,ns00/-999/
-  data sending0/'                      '/
-  save
-
-  kkdone=-99
-  ns0=999999
-  newdat2=0
-  kbuf=1
-
-10 continue
-  if(newdat2.gt.0) then
-     call getfile2(fname80,nlen)
-     newdat2=0
-     kbuf=1
-     kk=NSMAX
-     kkdone=0
-     newdat=1
-  endif
-
-  if(kbuf.ne.kbuf0) kkdone=0
-  kbuf0=kbuf
-  kkk=kk
-  if(kbuf.eq.2) kkk=kk-5760000
-  n=Tsec
-
-  if((ndiskdat.eq.1 .or. ndecoding.eq.0) .and. ((kkk-kkdone).gt.32768)) then
-     call symspec(dd,kbuf,kk,kkdone,nutc,newdat)
-     call sleep_msec(10)
-  endif
-
-  if(ndecoding.gt.0 .and. mode(1:4).eq.'JT65') then
-     ndecdone=0
-     call map65a(newdat)
-     if(mousebutton.eq.0) ndecoding0=ndecoding
-     ndecoding=0
-  endif
-
-  if(ns0.lt.0) then
-     rewind 21
-     ns0=999999
-  endif
-  if(n.lt.ns0 .and. utcdate(1:1).eq.'2') then
-     call cs_lock('decode1a')
-     write(21,1001) utcdate(:11)
-1001 format(/'UTC Date: ',a11/'---------------------')
-     ns0=n
-     call cs_unlock
-  endif
-
-  if(transmitting.eq.1 .and. (sending.ne.sending0 .or.       &amp;
-       sendingsh.ne.sendingsh0 .or. mode.ne.mode0)) then
-     ih=n/3600
-     im=mod(n/60,60)
-     is=mod(n,60)
-     cshort='           '
-     if(sendingsh.eq.1) cshort='(Shorthand)'
-     call cs_lock('decode1b')
-     write(21,1010) ih,im,is,mode,sending,cshort
-1010 format(3i2.2,'  Transmitting: ',a6,2x,a28,2x,a11)
-     call flushqqq(21)
-     call cs_unlock
-     sending0=sending
-     sendingsh0=sendingsh
-     mode0=mode
-  endif
-
-  call sleep_msec(100)                  !### was 100
-  go to 10
-
-end subroutine decode1

Copied: branches/map65/decode1.f90 (from rev 2454, branches/map65/decode1.F90)
===================================================================
--- branches/map65/decode1.f90	                        (rev 0)
+++ branches/map65/decode1.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,87 @@
+subroutine decode1(iarg)
+
+! Get data and parameters from gcom, then call the decoders when needed.
+! This routine runs in a background thread and will never return.
+
+#ifdef CVF
+  use dflib
+#endif
+
+  character sending0*28,mode0*6,cshort*11
+  integer sendingsh0
+
+  include 'datcom.f90'
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  include 'gcom4.f90'
+  data kbuf0/0/,ns00/-999/
+  data sending0/'                      '/
+  save
+
+  kkdone=-99
+  ns0=999999
+  newdat2=0
+  kbuf=1
+
+10 continue
+  if(newdat2.gt.0) then
+     call getfile2(fname80,nlen)
+     newdat2=0
+     kbuf=1
+     kk=NSMAX
+     kkdone=0
+     newdat=1
+  endif
+
+  if(kbuf.ne.kbuf0) kkdone=0
+  kbuf0=kbuf
+  kkk=kk
+  if(kbuf.eq.2) kkk=kk-5760000
+  n=Tsec
+
+  if((ndiskdat.eq.1 .or. ndecoding.eq.0) .and. ((kkk-kkdone).gt.32768)) then
+     call symspec(dd,kbuf,kk,kkdone,nutc,newdat)
+     call sleep_msec(10)
+  endif
+
+  if(ndecoding.gt.0 .and. mode(1:4).eq.'JT65') then
+     ndecdone=0
+     call map65a(newdat)
+     if(mousebutton.eq.0) ndecoding0=ndecoding
+     ndecoding=0
+  endif
+
+  if(ns0.lt.0) then
+     rewind 21
+     ns0=999999
+  endif
+  if(n.lt.ns0 .and. utcdate(1:1).eq.'2') then
+     call cs_lock('decode1a')
+     write(21,1001) utcdate(:11)
+1001 format(/'UTC Date: ',a11/'---------------------')
+     ns0=n
+     call cs_unlock
+  endif
+
+  if(transmitting.eq.1 .and. (sending.ne.sending0 .or.       &amp;
+       sendingsh.ne.sendingsh0 .or. mode.ne.mode0)) then
+     ih=n/3600
+     im=mod(n/60,60)
+     is=mod(n,60)
+     cshort='           '
+     if(sendingsh.eq.1) cshort='(Shorthand)'
+     call cs_lock('decode1b')
+     write(21,1010) ih,im,is,mode,sending,cshort
+1010 format(3i2.2,'  Transmitting: ',a6,2x,a28,2x,a11)
+     call flushqqq(21)
+     call cs_unlock
+     sending0=sending
+     sendingsh0=sendingsh
+     mode0=mode
+  endif
+
+  call sleep_msec(100)                  !### was 100
+  go to 10
+
+end subroutine decode1

Deleted: branches/map65/deep65.F
===================================================================
--- branches/map65/deep65.F	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/deep65.F	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,186 +0,0 @@
-      subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,
-     +  hisgrid,decoded,qual)
-
-      parameter (MAXCALLS=7000,MAXRPT=63)
-      real s3(64,63)
-      character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
-      character*12 mycall,hiscall
-      character mycall0*12,hiscall0*12,hisgrid0*6
-      character*22 decoded
-      character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
-      character*15 callgrid(MAXCALLS)
-      character*180 line
-      character*4 rpt(MAXRPT)
-      integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
-      real pp(2*MAXCALLS + 2 + MAXRPT)
-      common/mrscom/ mrs(63),mrs2(63)
-      common/c3com/ mcall3a
-
-      data neme0/-99/
-      data rpt/'-01','-02','-03','-04','-05',
-     +         '-06','-07','-08','-09','-10',
-     +         '-11','-12','-13','-14','-15',
-     +         '-16','-17','-18','-19','-20',
-     +         '-21','-22','-23','-24','-25',
-     +         '-26','-27','-28','-29','-30',
-     +         'R-01','R-02','R-03','R-04','R-05',
-     +         'R-06','R-07','R-08','R-09','R-10',
-     +         'R-11','R-12','R-13','R-14','R-15',
-     +         'R-16','R-17','R-18','R-19','R-20',
-     +         'R-21','R-22','R-23','R-24','R-25',
-     +         'R-26','R-27','R-28','R-29','R-30',
-     +         'RO','RRR','73'/
-      save
-
-      if(mycall.eq.mycall0 .and. hiscall.eq.hiscall0 .and. 
-     +   hisgrid.eq.hisgrid0 .and. mcall3a.eq.0 .and.
-     +   neme.eq.neme0) go to 30
-
-      mcall3a=0
-      call cs_lock('deep65a')
-      rewind 23
-      k=0
-      icall=0
-      do n=1,MAXCALLS
-         if(n.eq.1) then
-            callsign=hiscall
-            do i=4,12
-               if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
-            enddo
-            grid=hisgrid(1:4)
-            if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
-            if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
-         else
-            read(23,1002,end=20) line
- 1002       format (A80)
-            if(line(1:4).eq.'ZZZZ') go to 20
-            if(line(1:2).eq.'//') go to 10
-            i1=index(line,',')
-            if(i1.lt.4) go to 10
-            i2=index(line(i1+1:),',')
-            if(i2.lt.5) go to 10
-            i2=i2+i1
-            i3=index(line(i2+1:),',')
-            if(i3.lt.1) i3=index(line(i2+1:),' ')
-            i3=i2+i3
-            callsign=line(1:i1-1)
-            grid=line(i1+1:i2-1)
-            ceme=line(i2+1:i3-1)
-            if(neme.eq.1 .and. ceme.ne.'EME') go to 10
-         endif
-
-         icall=icall+1
-         j1=index(mycall,' ') - 1
-         if(j1.le.-1) j1=12
-         if(j1.lt.3) j1=6
-         j2=index(callsign,' ') - 1
-         if(j2.le.-1) j2=12
-         if(j2.lt.3) j2=6
-         j3=index(mycall,'/')                 ! j3&gt;0 means compound mycall
-         j4=index(callsign,'/')               ! j4&gt;0 means compound hiscall
-         callgrid(icall)=callsign(1:j2)
-
-         mz=1
-! Allow MyCall + HisCall + rpt (?)
-         if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.
-     +     flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
-         do m=1,mz
-            if(m.gt.1) grid=rpt(m-1)
-            if(j3.lt.1 .and.j4.lt.1) 
-     +         callgrid(icall)=callsign(1:j2)//' '//grid
-            message=mycall(1:j1)//' '//callgrid(icall)
-            k=k+1
-            testmsg(k)=message
-            call encode65(message,ncode(1,k))
-
-            if(n.ge.2) then
-C  Insert CQ message
-               if(j4.lt.1) callgrid(icall)=callsign(1:j2)//' '//grid
-               message='CQ '//callgrid(icall)
-               k=k+1
-               testmsg(k)=message
-               call encode65(message,ncode(1,k))
-            endif
-         enddo
- 10      continue
-      enddo
-
- 20   continue
-      call cs_unlock
-      ntot=k
-      neme0=neme
-
- 30   mycall0=mycall
-      hiscall0=hiscall
-      hisgrid0=hisgrid
-      modified0=modified
-      ref0=0.
-      do j=1,63
-         ref0=ref0 + s3(mrs(j),j)
-      enddo
-
-      p1=-1.e30
-      p2=-1.e30
-      do k=1,ntot
-         pp(k)=0.
-! Test all messages if flip=+1; skip the CQ messages if flip=-1.
-         if(flip.gt.0.0 .or. testmsg(k)(1:3).ne.'CQ ') then
-            sum=0.
-            ref=ref0
-            do j=1,63
-               i=ncode(j,k)+1
-               sum=sum + s3(i,j)
-               if(i.eq.mrs(j)) then
-                  ref=ref - s3(i,j) + s3(mrs2(j),j)
-               endif
-            enddo
-            p=sum/ref
-            pp(k)=p
-            if(p.gt.p1) then
-               p1=p
-               ip1=k
-            endif
-         endif
-      enddo
-
-      do i=1,ntot
-         if(pp(i).gt.p2 .and. pp(i).ne.p1) p2=pp(i)
-      enddo
-
-C  ### DO NOT REMOVE ### 
-      call cs_lock('deep65b')
-      rewind 77
-      write(77,*) p1,p2
-      call cs_unlock
-
-C  ### Works OK without it (in both Windows and Linux) if compiled 
-C  ### without optimization.  However, in Windows this is a colossal 
-C  ### pain because of the way McMillan Installer wants to run the 
-C  ### compile step.
-
-      if(mode65.eq.1) bias=max(1.12*p2,0.335)
-      if(mode65.eq.2) bias=max(1.08*p2,0.405)
-      if(mode65.ge.4) bias=max(1.04*p2,0.505)
-
-      if(p2.eq.p1 .and. p1.ne.-1.e30) stop 'Error in deep65'
-      qual=100.0*(p1-bias)
-
-      decoded='                      '
-      c=' '
-
-      if(qual.gt.1.0) then
-         if(qual.lt.6.0) c='?'
-         decoded=testmsg(ip1)
-      else
-         qual=0.
-      endif
-      decoded(22:22)=c
-
-C  Make sure everything is upper case.
-      do i=1,22
-         if(decoded(i:i).ge.'a' .and. decoded(i:i).le.'z') 
-     +     decoded(i:i)=char(ichar(decoded(i:i))-32)
-      enddo
-
-      return
-      end

Copied: branches/map65/deep65.f (from rev 2454, branches/map65/deep65.F)
===================================================================
--- branches/map65/deep65.f	                        (rev 0)
+++ branches/map65/deep65.f	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,186 @@
+      subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,
+     +  hisgrid,decoded,qual)
+
+      parameter (MAXCALLS=7000,MAXRPT=63)
+      real s3(64,63)
+      character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
+      character*12 mycall,hiscall
+      character mycall0*12,hiscall0*12,hisgrid0*6
+      character*22 decoded
+      character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
+      character*15 callgrid(MAXCALLS)
+      character*180 line
+      character*4 rpt(MAXRPT)
+      integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
+      real pp(2*MAXCALLS + 2 + MAXRPT)
+      common/mrscom/ mrs(63),mrs2(63)
+      common/c3com/ mcall3a
+
+      data neme0/-99/
+      data rpt/'-01','-02','-03','-04','-05',
+     +         '-06','-07','-08','-09','-10',
+     +         '-11','-12','-13','-14','-15',
+     +         '-16','-17','-18','-19','-20',
+     +         '-21','-22','-23','-24','-25',
+     +         '-26','-27','-28','-29','-30',
+     +         'R-01','R-02','R-03','R-04','R-05',
+     +         'R-06','R-07','R-08','R-09','R-10',
+     +         'R-11','R-12','R-13','R-14','R-15',
+     +         'R-16','R-17','R-18','R-19','R-20',
+     +         'R-21','R-22','R-23','R-24','R-25',
+     +         'R-26','R-27','R-28','R-29','R-30',
+     +         'RO','RRR','73'/
+      save
+
+      if(mycall.eq.mycall0 .and. hiscall.eq.hiscall0 .and. 
+     +   hisgrid.eq.hisgrid0 .and. mcall3a.eq.0 .and.
+     +   neme.eq.neme0) go to 30
+
+      mcall3a=0
+      call cs_lock('deep65a')
+      rewind 23
+      k=0
+      icall=0
+      do n=1,MAXCALLS
+         if(n.eq.1) then
+            callsign=hiscall
+            do i=4,12
+               if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
+            enddo
+            grid=hisgrid(1:4)
+            if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
+            if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
+         else
+            read(23,1002,end=20) line
+ 1002       format (A80)
+            if(line(1:4).eq.'ZZZZ') go to 20
+            if(line(1:2).eq.'//') go to 10
+            i1=index(line,',')
+            if(i1.lt.4) go to 10
+            i2=index(line(i1+1:),',')
+            if(i2.lt.5) go to 10
+            i2=i2+i1
+            i3=index(line(i2+1:),',')
+            if(i3.lt.1) i3=index(line(i2+1:),' ')
+            i3=i2+i3
+            callsign=line(1:i1-1)
+            grid=line(i1+1:i2-1)
+            ceme=line(i2+1:i3-1)
+            if(neme.eq.1 .and. ceme.ne.'EME') go to 10
+         endif
+
+         icall=icall+1
+         j1=index(mycall,' ') - 1
+         if(j1.le.-1) j1=12
+         if(j1.lt.3) j1=6
+         j2=index(callsign,' ') - 1
+         if(j2.le.-1) j2=12
+         if(j2.lt.3) j2=6
+         j3=index(mycall,'/')                 ! j3&gt;0 means compound mycall
+         j4=index(callsign,'/')               ! j4&gt;0 means compound hiscall
+         callgrid(icall)=callsign(1:j2)
+
+         mz=1
+! Allow MyCall + HisCall + rpt (?)
+         if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.
+     +     flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
+         do m=1,mz
+            if(m.gt.1) grid=rpt(m-1)
+            if(j3.lt.1 .and.j4.lt.1) 
+     +         callgrid(icall)=callsign(1:j2)//' '//grid
+            message=mycall(1:j1)//' '//callgrid(icall)
+            k=k+1
+            testmsg(k)=message
+            call encode65(message,ncode(1,k))
+
+            if(n.ge.2) then
+C  Insert CQ message
+               if(j4.lt.1) callgrid(icall)=callsign(1:j2)//' '//grid
+               message='CQ '//callgrid(icall)
+               k=k+1
+               testmsg(k)=message
+               call encode65(message,ncode(1,k))
+            endif
+         enddo
+ 10      continue
+      enddo
+
+ 20   continue
+      call cs_unlock
+      ntot=k
+      neme0=neme
+
+ 30   mycall0=mycall
+      hiscall0=hiscall
+      hisgrid0=hisgrid
+      modified0=modified
+      ref0=0.
+      do j=1,63
+         ref0=ref0 + s3(mrs(j),j)
+      enddo
+
+      p1=-1.e30
+      p2=-1.e30
+      do k=1,ntot
+         pp(k)=0.
+! Test all messages if flip=+1; skip the CQ messages if flip=-1.
+         if(flip.gt.0.0 .or. testmsg(k)(1:3).ne.'CQ ') then
+            sum=0.
+            ref=ref0
+            do j=1,63
+               i=ncode(j,k)+1
+               sum=sum + s3(i,j)
+               if(i.eq.mrs(j)) then
+                  ref=ref - s3(i,j) + s3(mrs2(j),j)
+               endif
+            enddo
+            p=sum/ref
+            pp(k)=p
+            if(p.gt.p1) then
+               p1=p
+               ip1=k
+            endif
+         endif
+      enddo
+
+      do i=1,ntot
+         if(pp(i).gt.p2 .and. pp(i).ne.p1) p2=pp(i)
+      enddo
+
+C  ### DO NOT REMOVE ### 
+      call cs_lock('deep65b')
+      rewind 77
+      write(77,*) p1,p2
+      call cs_unlock
+
+C  ### Works OK without it (in both Windows and Linux) if compiled 
+C  ### without optimization.  However, in Windows this is a colossal 
+C  ### pain because of the way McMillan Installer wants to run the 
+C  ### compile step.
+
+      if(mode65.eq.1) bias=max(1.12*p2,0.335)
+      if(mode65.eq.2) bias=max(1.08*p2,0.405)
+      if(mode65.ge.4) bias=max(1.04*p2,0.505)
+
+      if(p2.eq.p1 .and. p1.ne.-1.e30) stop 'Error in deep65'
+      qual=100.0*(p1-bias)
+
+      decoded='                      '
+      c=' '
+
+      if(qual.gt.1.0) then
+         if(qual.lt.6.0) c='?'
+         decoded=testmsg(ip1)
+      else
+         qual=0.
+      endif
+      decoded(22:22)=c
+
+C  Make sure everything is upper case.
+      do i=1,22
+         if(decoded(i:i).ge.'a' .and. decoded(i:i).le.'z') 
+     +     decoded(i:i)=char(ichar(decoded(i:i))-32)
+      enddo
+
+      return
+      end

Deleted: branches/map65/display.F90
===================================================================
--- branches/map65/display.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/display.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,174 +0,0 @@
-subroutine display(nkeep)
-
-#ifdef CVF
-  use dfport
-#endif
-
-  parameter (MAXLINES=500,MX=500)
-  integer indx(MAXLINES),indx2(MX)
-  character*81 line(MAXLINES),line2(MX),line3(MAXLINES)
-  character out*50,cfreq0*3
-  character*6 callsign,callsign0
-  character*12 freqcall(100)
-  character*40 bm2
-  real freqkHz(MAXLINES)
-  integer utc(MAXLINES),utc2(MX),utcz
-  real*8 f0
-
-  call cs_lock('display')
-  ftol=0.02
-  rewind 26
-
-  do i=1,MAXLINES
-     read(26,1010,end=10) line(i)
-1010 format(a80)
-     read(line(i),1020) f0,ndf,nh,nm
-1020 format(f7.3,i5,26x,i3,i2)
-     utc(i)=60*nh + nm
-     freqkHz(i)=1000.d0*(f0-144.d0) + 0.001d0*ndf
-  enddo
-
-10 nz=i-1
-  utcz=utc(nz)
-  nz=nz-1
-  if(nz.lt.1) go to 999
-  nquad=max(nkeep/4,3)
-  do i=1,nz
-     nage=utcz-utc(i)
-     if(nage.lt.0) nage=nage+1440
-     iage=(nage/nquad) + 1
-     if(nage.le.1) iage=0
-     write(line(i)(78:81),1021) iage
-1021 format(i4)
-  enddo
-
-  nage=utcz-utc(1)
-  if(nage.lt.0) nage=nage+1440
-  if(nage.gt.nkeep) then
-     do i=1,nz
-        nage=utcz-utc(i)
-        if(nage.lt.0) nage=nage+1440
-        if(nage.le.nkeep) go to 20
-     enddo
-20   i0=i
-     nz=nz-i0+1
-     rewind 26
-     if(nz.lt.1) go to 999
-     do i=1,nz
-        j=i+i0-1
-        line(i)=line(j)
-        utc(i)=utc(j)
-        freqkHz(i)=freqkHz(j)
-        write(26,1010) line(i)
-     enddo
-  endif
-
-  call flushqqq(26)
-  call indexx(nz,freqkHz,indx)
-
-  nstart=1
-  k3=0
-  k=1
-  m=indx(1)
-  if(m.lt.1 .or. m.gt.MAXLINES) then
-     print*,'Error in display.F90: ',nz,m
-     m=1
-  endif
-  line2(1)=line(m)
-  utc2(1)=utc(m)
-  do i=2,nz
-     j0=indx(i-1)
-     j=indx(i)
-     if(freqkHz(j)-freqkHz(j0).gt.ftol) then
-        if(nstart.eq.0) then
-           k=k+1
-           line2(k)=&quot;&quot;
-           utc2(k)=-1
-        endif
-        kz=k
-        if(nstart.eq.1) then
-           call indexx(kz,utc2,indx2)
-           k3=0
-           do k=1,kz
-              k3=min(k3+1,500)
-              line3(k3)=line2(indx2(k))
-           enddo
-           nstart=0
-        else
-           call indexx(kz,utc2,indx2)
-           do k=1,kz
-              k3=min(k3+1,500)
-              line3(k3)=line2(indx2(k))
-           enddo
-        endif
-        k=0
-     endif
-     if(i.eq.nz) then
-        k=k+1
-        line2(k)=&quot;&quot;
-        utc2(k)=-1
-     endif
-     k=k+1
-     line2(k)=line(j)
-     utc2(k)=utc(j)
-     j0=j
-  enddo
-  kz=k
-  call indexx(kz,utc2,indx2)
-  do k=1,kz
-     k3=k3+1
-     line3(k3)=line2(indx2(k))
-  enddo
-
-  rewind 19
-  rewind 20
-  cfreq0='   '
-  nc=0
-  callsign0='          '
-  do k=1,k3
-     out=line3(k)(5:12)//line3(k)(28:31)//line3(k)(39:43)//       &amp;
-          line3(k)(35:38)//line3(k)(44:67)//line3(k)(77:81)
-     if(out(1:3).ne.'   ') then
-        if(out(1:3).eq.cfreq0) then
-           out(1:3)='   '
-        else
-           cfreq0=out(1:3)
-        endif
-        write(19,1030) out
-1030    format(a50)
-        i1=index(out(24:),' ')
-        callsign=out(i1+24:)
-        i2=index(callsign,' ')
-        if(i2.gt.1) callsign(i2:)='      '
-        if(callsign.ne.'      ' .and. callsign.ne.callsign0) then
-           len=i2-1
-           if(len.lt.0) len=6
-           if(len.ge.4) then                        !Omit short &quot;callsigns&quot;
-              nc=nc+1
-              freqcall(nc)=cfreq0//' '//callsign//line3(k)(80:81)
-              callsign0=callsign
-           endif
-        endif
-        if(callsign.ne.'      ' .and. callsign.eq.callsign0) then
-           freqcall(nc)=cfreq0//' '//callsign//line3(k)(80:81)
-        endif
-     endif
-  enddo
-  call flushqqq(19)
-  nc=nc+1
-  freqcall(nc)='            '
-  nc=nc+1
-  freqcall(nc)='            '
-  freqcall(nc+1)='            '
-  freqcall(nc+2)='            '
-  iz=(nc+2)/3
-  do i=1,iz
-     bm2=freqcall(i)//'  '//freqcall(i+iz)//'  '//freqcall(i+2*iz)
-     write(20,1040) bm2
-1040 format(a40)
-  enddo
-  call flushqqq(20)
-999  continue
-  call cs_unlock
-  return
-end subroutine display

Copied: branches/map65/display.f90 (from rev 2454, branches/map65/display.F90)
===================================================================
--- branches/map65/display.f90	                        (rev 0)
+++ branches/map65/display.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,174 @@
+subroutine display(nkeep)
+
+#ifdef CVF
+  use dfport
+#endif
+
+  parameter (MAXLINES=500,MX=500)
+  integer indx(MAXLINES),indx2(MX)
+  character*81 line(MAXLINES),line2(MX),line3(MAXLINES)
+  character out*50,cfreq0*3
+  character*6 callsign,callsign0
+  character*12 freqcall(100)
+  character*40 bm2
+  real freqkHz(MAXLINES)
+  integer utc(MAXLINES),utc2(MX),utcz
+  real*8 f0
+
+  call cs_lock('display')
+  ftol=0.02
+  rewind 26
+
+  do i=1,MAXLINES
+     read(26,1010,end=10) line(i)
+1010 format(a80)
+     read(line(i),1020) f0,ndf,nh,nm
+1020 format(f7.3,i5,26x,i3,i2)
+     utc(i)=60*nh + nm
+     freqkHz(i)=1000.d0*(f0-144.d0) + 0.001d0*ndf
+  enddo
+
+10 nz=i-1
+  utcz=utc(nz)
+  nz=nz-1
+  if(nz.lt.1) go to 999
+  nquad=max(nkeep/4,3)
+  do i=1,nz
+     nage=utcz-utc(i)
+     if(nage.lt.0) nage=nage+1440
+     iage=(nage/nquad) + 1
+     if(nage.le.1) iage=0
+     write(line(i)(78:81),1021) iage
+1021 format(i4)
+  enddo
+
+  nage=utcz-utc(1)
+  if(nage.lt.0) nage=nage+1440
+  if(nage.gt.nkeep) then
+     do i=1,nz
+        nage=utcz-utc(i)
+        if(nage.lt.0) nage=nage+1440
+        if(nage.le.nkeep) go to 20
+     enddo
+20   i0=i
+     nz=nz-i0+1
+     rewind 26
+     if(nz.lt.1) go to 999
+     do i=1,nz
+        j=i+i0-1
+        line(i)=line(j)
+        utc(i)=utc(j)
+        freqkHz(i)=freqkHz(j)
+        write(26,1010) line(i)
+     enddo
+  endif
+
+  call flushqqq(26)
+  call indexx(nz,freqkHz,indx)
+
+  nstart=1
+  k3=0
+  k=1
+  m=indx(1)
+  if(m.lt.1 .or. m.gt.MAXLINES) then
+     print*,'Error in display.F90: ',nz,m
+     m=1
+  endif
+  line2(1)=line(m)
+  utc2(1)=utc(m)
+  do i=2,nz
+     j0=indx(i-1)
+     j=indx(i)
+     if(freqkHz(j)-freqkHz(j0).gt.ftol) then
+        if(nstart.eq.0) then
+           k=k+1
+           line2(k)=&quot;&quot;
+           utc2(k)=-1
+        endif
+        kz=k
+        if(nstart.eq.1) then
+           call indexx(kz,utc2,indx2)
+           k3=0
+           do k=1,kz
+              k3=min(k3+1,500)
+              line3(k3)=line2(indx2(k))
+           enddo
+           nstart=0
+        else
+           call indexx(kz,utc2,indx2)
+           do k=1,kz
+              k3=min(k3+1,500)
+              line3(k3)=line2(indx2(k))
+           enddo
+        endif
+        k=0
+     endif
+     if(i.eq.nz) then
+        k=k+1
+        line2(k)=&quot;&quot;
+        utc2(k)=-1
+     endif
+     k=k+1
+     line2(k)=line(j)
+     utc2(k)=utc(j)
+     j0=j
+  enddo
+  kz=k
+  call indexx(kz,utc2,indx2)
+  do k=1,kz
+     k3=k3+1
+     line3(k3)=line2(indx2(k))
+  enddo
+
+  rewind 19
+  rewind 20
+  cfreq0='   '
+  nc=0
+  callsign0='          '
+  do k=1,k3
+     out=line3(k)(5:12)//line3(k)(28:31)//line3(k)(39:43)//       &amp;
+          line3(k)(35:38)//line3(k)(44:67)//line3(k)(77:81)
+     if(out(1:3).ne.'   ') then
+        if(out(1:3).eq.cfreq0) then
+           out(1:3)='   '
+        else
+           cfreq0=out(1:3)
+        endif
+        write(19,1030) out
+1030    format(a50)
+        i1=index(out(24:),' ')
+        callsign=out(i1+24:)
+        i2=index(callsign,' ')
+        if(i2.gt.1) callsign(i2:)='      '
+        if(callsign.ne.'      ' .and. callsign.ne.callsign0) then
+           len=i2-1
+           if(len.lt.0) len=6
+           if(len.ge.4) then                        !Omit short &quot;callsigns&quot;
+              nc=nc+1
+              freqcall(nc)=cfreq0//' '//callsign//line3(k)(80:81)
+              callsign0=callsign
+           endif
+        endif
+        if(callsign.ne.'      ' .and. callsign.eq.callsign0) then
+           freqcall(nc)=cfreq0//' '//callsign//line3(k)(80:81)
+        endif
+     endif
+  enddo
+  call flushqqq(19)
+  nc=nc+1
+  freqcall(nc)='            '
+  nc=nc+1
+  freqcall(nc)='            '
+  freqcall(nc+1)='            '
+  freqcall(nc+2)='            '
+  iz=(nc+2)/3
+  do i=1,iz
+     bm2=freqcall(i)//'  '//freqcall(i+iz)//'  '//freqcall(i+2*iz)
+     write(20,1040) bm2
+1040 format(a40)
+  enddo
+  call flushqqq(20)
+999  continue
+  call cs_unlock
+  return
+end subroutine display

Deleted: branches/map65/fivehz.F90
===================================================================
--- branches/map65/fivehz.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/fivehz.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,250 +0,0 @@
-subroutine fivehz
-
-!  Called at interrupt level from the PortAudio callback routine.
-!  For nspb=2048 the callback rate is nfsample/nspb = 5.38 Hz.
-!  Thus, we should be able to control the timing of T/R sequence events
-!  here to within about 0.2 s.
-
-!  Do not do anything very time consuming in this routine!!
-!  Disk I/O is a bad idea.  Writing to stdout (for diagnostic purposes)
-!  seems to be OK.
-
-#ifdef CVF
-  use dflib
-  use dfport
-#endif
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,txtime,filled
-  integer ptt
-  integer TxOKz
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  data first/.true./,nc0/1/,nc1/1/
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     rxdelay=0.2
-     txdelay=0.4
-     tlatency=1.0
-     first=.false.
-     iptt=0
-     ntr0=-99
-     rxdone=.false.
-     ibuf00=-99
-     ncall=-1
-     u=0.05d0
-     fsample=11025.d0
-     mfsample=110250
-     filled=.false.
-  endif
-
-  if(txdelay.lt.0.2d0) txdelay=0.2d0
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-!  if(ncall.ge.10 .and. mod(ncall,2).eq.1) then
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample=nint(10.d0*fsample)
-     endif
-  endif
-
-  if(trperiod.le.0) trperiod=30
-  tx1=0.0                              !Time to start a TX sequence
-  tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
-  if(mode(1:4).eq.'JT65') then
-     if(nwave.lt.126*4096) nwave=126*4096
-     tx2=txdelay + nwave/11025.0
-     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
-  endif
-
-  if(TxFirst.eq.0) then
-     tx1=tx1+trperiod
-     tx2=tx2+trperiod
-  endif
-
-  t=mod(Tsec,2.d0*trperiod)
-  txtime = t.ge.tx1 .and. t.lt.tx2
-
-! If we're transmitting, freeze the input buffer pointers where they were.
-  receiving=1
-  if(((txtime .and. (lauto.eq.1)) .or. TxOK.eq.1 .or. transmitting.eq.1) &amp; 
-       .and. (mute.eq.0)) then
-     receiving=0
-     ibuf=ibuf000
-     iwrite=iwrite000
-  endif
-  ibuf000=ibuf
-  iwrite000=iwrite
-  nsec=Tsec
-  ntr=mod(nsec/trperiod,2)             !ntr=0 in 1st sequence, 1 in 2nd
-
-  if(ntr.ne.ntr0) then
-     ibuf0=ibuf                        !Start of new sequence, save ibuf
-!     if(mode(1:4).ne.'JT65') then
-!        ibuf0=ibuf0+3                  !So we don't copy our own Tx
-!        if(ibuf0.gt.1024) ibuf0=ibuf0-1024
-!     endif
-     ntime=time()                      !Save start time
-     if(mantx.eq.1 .and. iptt.eq.1) then
-        mantx=0
-        TxOK=0
-     endif
-  endif
-
-! Switch PTT line and TxOK appropriately
-  if(lauto.eq.1) then
-     if(txtime .and. iptt.eq.0 .and.          &amp;
-          mute.eq.0) i1=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(.not.txtime .or. mute.eq.1) TxOK=0               !Lower TxOK
-  else
-     if(mantx.eq.1 .and. iptt.eq.0 .and.      &amp;
-          mute.eq.0) i2=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(mantx.eq.0 .or. mute.eq.1) TxOK=0                !Lower TxOK
-  endif
-
-! Calculate Tx waveform as needed
-  if((iptt.eq.1 .and. iptt0.eq.0) .or. nrestart.eq.1) then
-     call wsjtgen
-     nrestart=0
-  endif
-
-! If PTT was just raised, start a countdown for raising TxOK:
-  nc1a=txdelay/0.18576
-  if(nc1a.lt.2) nc1a=2
-  if(iptt.eq.1 .and. iptt0.eq.0) nc1=-nc1a-1
-  if(nc1.le.0) nc1=nc1+1
-  if(nc1.eq.0) TxOK=1                               ! We are transmitting
-
-! If TxOK was just lowered, start a countdown for lowering PTT:
-  nc0a=(tlatency+txdelay)/0.18576
-  if(nc0a.lt.5) nc0a=5
-  if(TxOK.eq.0 .and. TxOKz.eq.1 .and. iptt.eq.1) nc0=-nc0a-1
-  if(nc0.le.0) nc0=nc0+1
-  if(nc0.eq.0) i3=ptt(nport,pttport,0,iptt)
-
-  if(iptt.eq.0 .and.TxOK.eq.0) then
-     sending=&quot;                      &quot;
-     sendingsh=0
-  endif
-
-  nbufs=ibuf-ibuf0
-  if(nbufs.lt.0) nbufs=nbufs+1024
-  tdata=nbufs*2048.0/11025.0
-  if(mode(1:4).eq.'JT65' .and. monitoring.eq.1 .and. tdata.gt.53.0    &amp;
-       .and. ibuf0.ne.ibuf00) then
-     rxdone=.true.
-     ibuf00=ibuf0
-  endif
-  iptt0=iptt
-  TxOKz=TxOK
-  ntr0=ntr
-
-  return
-end subroutine fivehz
-
-subroutine fivehztx
-
-!  Called at interrupt level from the PortAudio output callback.
-
-#ifdef CVF
-  use dflib
-  use dfport
-#endif
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,filled
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  data first/.true./
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     first=.false.
-     ncall=-1
-     fsample=11025.d0
-     u=0.05d0
-     mfsample2=110250
-     filled=.false.
-  endif
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample2=nint(10.d0*fsample)
-     endif
-  endif
-
-  return
-end subroutine fivehztx
-
-subroutine addnoise(n)
-  integer*2 n
-  real*8 txsnrdb0
-  include 'gcom1.f90'
-  data idum/0/
-  save
-
-  if(txsnrdb.gt.40.0) return
-  if(txsnrdb.ne.txsnrdb0) then
-     snr=10.0**(0.05*(txsnrdb-1))
-     fac=3000.0
-     if(snr.gt.1.0) fac=3000.0/snr
-     txsnrdb0=txsnrdb
-  endif
-  i=fac*(gran(idum) + n*snr/32768.0)
-  if(i&gt;32767) i=32767;
-  if(i&lt;-32767) i=-32767;
-  n=i
-
-  return
-end subroutine addnoise
-
-real function gran(idum)
-  real r(12)
-  if(idum.lt.0) then
-     call random_seed
-     idum=0
-  endif
-  call random_number(r)
-  gran=sum(r)-6.0
-end function gran

Copied: branches/map65/fivehz.f90 (from rev 2454, branches/map65/fivehz.F90)
===================================================================
--- branches/map65/fivehz.f90	                        (rev 0)
+++ branches/map65/fivehz.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,250 @@
+subroutine fivehz
+
+!  Called at interrupt level from the PortAudio callback routine.
+!  For nspb=2048 the callback rate is nfsample/nspb = 5.38 Hz.
+!  Thus, we should be able to control the timing of T/R sequence events
+!  here to within about 0.2 s.
+
+!  Do not do anything very time consuming in this routine!!
+!  Disk I/O is a bad idea.  Writing to stdout (for diagnostic purposes)
+!  seems to be OK.
+
+#ifdef CVF
+  use dflib
+  use dfport
+#endif
+
+  parameter (NTRING=64)
+  real*8 tt1(0:NTRING-1)
+  logical first,txtime,filled
+  integer ptt
+  integer TxOKz
+  real*8 fs,fsample,tt,u
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  data first/.true./,nc0/1/,nc1/1/
+  save
+
+  n1=time()
+  n2=mod(n1,86400)
+  tt=n1-n2+tsec-0.1d0*ndsec
+
+  if(first) then
+     rxdelay=0.2
+     txdelay=0.4
+     tlatency=1.0
+     first=.false.
+     iptt=0
+     ntr0=-99
+     rxdone=.false.
+     ibuf00=-99
+     ncall=-1
+     u=0.05d0
+     fsample=11025.d0
+     mfsample=110250
+     filled=.false.
+  endif
+
+  if(txdelay.lt.0.2d0) txdelay=0.2d0
+
+! Measure average sampling frequency over a recent interval
+  ncall=ncall+1
+  if(ncall.eq.9) then
+     ntt0=0
+     ntt1=0
+     tt1(ntt1)=tt
+  endif
+!  if(ncall.ge.10 .and. mod(ncall,2).eq.1) then
+  if(ncall.ge.10) then
+     ntt1=iand(ntt1+1,NTRING-1)
+     tt1(ntt1)=tt
+     if(ntt1.eq.NTRING-1) filled=.true.
+     if(filled) ntt0=iand(ntt1+1,NTRING-1)
+     if(mod(ncall,2).eq.1) then
+        nd=ntt1-ntt0
+        if(nd.lt.0) nd=nd+NTRING
+        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
+        fsample=u*fs + (1.d0-u)*fsample
+        mfsample=nint(10.d0*fsample)
+     endif
+  endif
+
+  if(trperiod.le.0) trperiod=30
+  tx1=0.0                              !Time to start a TX sequence
+  tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
+  if(mode(1:4).eq.'JT65') then
+     if(nwave.lt.126*4096) nwave=126*4096
+     tx2=txdelay + nwave/11025.0
+     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
+  endif
+
+  if(TxFirst.eq.0) then
+     tx1=tx1+trperiod
+     tx2=tx2+trperiod
+  endif
+
+  t=mod(Tsec,2.d0*trperiod)
+  txtime = t.ge.tx1 .and. t.lt.tx2
+
+! If we're transmitting, freeze the input buffer pointers where they were.
+  receiving=1
+  if(((txtime .and. (lauto.eq.1)) .or. TxOK.eq.1 .or. transmitting.eq.1) &amp; 
+       .and. (mute.eq.0)) then
+     receiving=0
+     ibuf=ibuf000
+     iwrite=iwrite000
+  endif
+  ibuf000=ibuf
+  iwrite000=iwrite
+  nsec=Tsec
+  ntr=mod(nsec/trperiod,2)             !ntr=0 in 1st sequence, 1 in 2nd
+
+  if(ntr.ne.ntr0) then
+     ibuf0=ibuf                        !Start of new sequence, save ibuf
+!     if(mode(1:4).ne.'JT65') then
+!        ibuf0=ibuf0+3                  !So we don't copy our own Tx
+!        if(ibuf0.gt.1024) ibuf0=ibuf0-1024
+!     endif
+     ntime=time()                      !Save start time
+     if(mantx.eq.1 .and. iptt.eq.1) then
+        mantx=0
+        TxOK=0
+     endif
+  endif
+
+! Switch PTT line and TxOK appropriately
+  if(lauto.eq.1) then
+     if(txtime .and. iptt.eq.0 .and.          &amp;
+          mute.eq.0) i1=ptt(nport,pttport,1,iptt)        !Raise PTT
+     if(.not.txtime .or. mute.eq.1) TxOK=0               !Lower TxOK
+  else
+     if(mantx.eq.1 .and. iptt.eq.0 .and.      &amp;
+          mute.eq.0) i2=ptt(nport,pttport,1,iptt)        !Raise PTT
+     if(mantx.eq.0 .or. mute.eq.1) TxOK=0                !Lower TxOK
+  endif
+
+! Calculate Tx waveform as needed
+  if((iptt.eq.1 .and. iptt0.eq.0) .or. nrestart.eq.1) then
+     call wsjtgen
+     nrestart=0
+  endif
+
+! If PTT was just raised, start a countdown for raising TxOK:
+  nc1a=txdelay/0.18576
+  if(nc1a.lt.2) nc1a=2
+  if(iptt.eq.1 .and. iptt0.eq.0) nc1=-nc1a-1
+  if(nc1.le.0) nc1=nc1+1
+  if(nc1.eq.0) TxOK=1                               ! We are transmitting
+
+! If TxOK was just lowered, start a countdown for lowering PTT:
+  nc0a=(tlatency+txdelay)/0.18576
+  if(nc0a.lt.5) nc0a=5
+  if(TxOK.eq.0 .and. TxOKz.eq.1 .and. iptt.eq.1) nc0=-nc0a-1
+  if(nc0.le.0) nc0=nc0+1
+  if(nc0.eq.0) i3=ptt(nport,pttport,0,iptt)
+
+  if(iptt.eq.0 .and.TxOK.eq.0) then
+     sending=&quot;                      &quot;
+     sendingsh=0
+  endif
+
+  nbufs=ibuf-ibuf0
+  if(nbufs.lt.0) nbufs=nbufs+1024
+  tdata=nbufs*2048.0/11025.0
+  if(mode(1:4).eq.'JT65' .and. monitoring.eq.1 .and. tdata.gt.53.0    &amp;
+       .and. ibuf0.ne.ibuf00) then
+     rxdone=.true.
+     ibuf00=ibuf0
+  endif
+  iptt0=iptt
+  TxOKz=TxOK
+  ntr0=ntr
+
+  return
+end subroutine fivehz
+
+subroutine fivehztx
+
+!  Called at interrupt level from the PortAudio output callback.
+
+#ifdef CVF
+  use dflib
+  use dfport
+#endif
+
+  parameter (NTRING=64)
+  real*8 tt1(0:NTRING-1)
+  logical first,filled
+  real*8 fs,fsample,tt,u
+  include 'gcom1.f90'
+  data first/.true./
+  save
+
+  n1=time()
+  n2=mod(n1,86400)
+  tt=n1-n2+tsec-0.1d0*ndsec
+
+  if(first) then
+     first=.false.
+     ncall=-1
+     fsample=11025.d0
+     u=0.05d0
+     mfsample2=110250
+     filled=.false.
+  endif
+
+! Measure average sampling frequency over a recent interval
+  ncall=ncall+1
+  if(ncall.eq.9) then
+     ntt0=0
+     ntt1=0
+     tt1(ntt1)=tt
+  endif
+  if(ncall.ge.10) then
+     ntt1=iand(ntt1+1,NTRING-1)
+     tt1(ntt1)=tt
+     if(ntt1.eq.NTRING-1) filled=.true.
+     if(filled) ntt0=iand(ntt1+1,NTRING-1)
+     if(mod(ncall,2).eq.1) then
+        nd=ntt1-ntt0
+        if(nd.lt.0) nd=nd+NTRING
+        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
+        fsample=u*fs + (1.d0-u)*fsample
+        mfsample2=nint(10.d0*fsample)
+     endif
+  endif
+
+  return
+end subroutine fivehztx
+
+subroutine addnoise(n)
+  integer*2 n
+  real*8 txsnrdb0
+  include 'gcom1.f90'
+  data idum/0/
+  save
+
+  if(txsnrdb.gt.40.0) return
+  if(txsnrdb.ne.txsnrdb0) then
+     snr=10.0**(0.05*(txsnrdb-1))
+     fac=3000.0
+     if(snr.gt.1.0) fac=3000.0/snr
+     txsnrdb0=txsnrdb
+  endif
+  i=fac*(gran(idum) + n*snr/32768.0)
+  if(i&gt;32767) i=32767;
+  if(i&lt;-32767) i=-32767;
+  n=i
+
+  return
+end subroutine addnoise
+
+real function gran(idum)
+  real r(12)
+  if(idum.lt.0) then
+     call random_seed
+     idum=0
+  endif
+  call random_number(r)
+  gran=sum(r)-6.0
+end function gran

Deleted: branches/map65/flushqqq.F90
===================================================================
--- branches/map65/flushqqq.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/flushqqq.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,10 +0,0 @@
-subroutine flushqqq(lu)
-
-#ifdef CVF
-  use dfport
-#endif
-
-  call flush(lu)
-
-  return
-end subroutine flushqqq

Copied: branches/map65/flushqqq.f90 (from rev 2454, branches/map65/flushqqq.F90)
===================================================================
--- branches/map65/flushqqq.f90	                        (rev 0)
+++ branches/map65/flushqqq.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,10 @@
+subroutine flushqqq(lu)
+
+#ifdef CVF
+  use dfport
+#endif
+
+  call flush(lu)
+
+  return
+end subroutine flushqqq

Deleted: branches/map65/ftn_init.F90
===================================================================
--- branches/map65/ftn_init.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/ftn_init.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,171 +0,0 @@
-! Fortran logical units used in WSJT6
-!
-!   10  binary input data, *.tf2 files
-!   11  decoded.txt
-!   12  decoded.ave
-!   13  tsky.dat
-!   14  azel.dat
-!   15  
-!   16
-!   17  saved *.tf2 files
-!   18  test file to be transmitted (wsjtgen.f90)
-!   19  messages.txt
-!   20  bandmap.txt
-!   21  ALL65.TXT
-!   22  kvasd.dat
-!   23  CALL3.TXT
-!   24  meas24.dat
-!   25  meas25.dat
-!   26  tmp26.txt
-!   27  dphi.txt
-!   28  fftw_wisdom.dat
-!   29  debug.txt
-!------------------------------------------------ ftn_init
-subroutine ftn_init
-
-  character*1 cjunk
-  integer ptt
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  include 'gcom4.f90'
-
-  call cs_init
-  call cs_lock('ftn_init')
-  i=ptt(nport,pttport,0,iptt)                       !Clear the PTT line
-  addpfx='    '
-  nrw26=0
-
-  do i=80,1,-1
-     if(AppDir(i:i).ne.' ') goto 1
-  enddo
-1 iz=i
-  lenappdir=iz
-  call pfxdump(appdir(:iz)//'/prefixes.txt')
-
-  do i=80,1,-1
-     if(AzElDir(i:i).ne.' ') goto 2
-  enddo
-2 iz2=i
-
-#ifdef CVF
-  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
-       share='denynone',err=910)
-#else
-  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
-       err=910)
-#endif
-  endfile 11
-
-#ifdef CVF
-  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
-       share='denynone',err=920)
-#else
-  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
-       err=920)
-#endif
-  endfile 12
-
-#ifdef CVF
-  open(14,file=azeldir(:iz2)//'/azel.dat',status='unknown',                  &amp;
-       share='denynone',err=930)
-#else
-  open(14,file=azeldir(:iz2)//'/azel.dat',status='unknown',                  &amp;
-       err=930)
-#endif
-
-#ifdef CVF
-  open(19,file=appdir(:iz)//'/messages.txt',status='unknown',               &amp;
-       share='denynone',err=911)
-#else
-  open(19,file=appdir(:iz)//'/messages.txt',status='unknown',               &amp;
-       err=911)
-#endif
-  endfile 19
-
-#ifdef CVF
-  open(20,file=appdir(:iz)//'/bandmap.txt',status='unknown',               &amp;
-       share='denynone',err=912)
-#else
-  open(20,file=appdir(:iz)//'/bandmap.txt',status='unknown',               &amp;
-       err=912)
-#endif
-  endfile 20
-
-#ifdef CVF
-  open(21,file=appdir(:iz)//'/ALL65.TXT',status='unknown',                   &amp;
-       access='append',share='denynone',err=950)
-#else
-  open(21,file=appdir(:iz)//'/ALL65.TXT',status='unknown',                   &amp;
-	access='append',err=950)
-  do i=1,9999999
-     read(21,*,end=10) cjunk
-  enddo
-10 continue
-#endif
-
-#ifdef CVF
-  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
-       status='unknown',share='denynone')
-#else
-  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
-       status='unknown')
-#endif
-
-#ifdef CVF
-  open(24,file=appdir(:iz)//'/meas24.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(24,file=appdir(:iz)//'/meas24.txt',status='unknown')
-#endif
-
-#ifdef CVF
-  open(25,file=appdir(:iz)//'/meas25.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(25,file=appdir(:iz)//'/meas25.txt',status='unknown')
-#endif
-
-#ifdef CVF
-  open(26,file=appdir(:iz)//'/tmp26.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(26,file=appdir(:iz)//'/tmp26.txt',status='unknown')
-#endif
-
-#ifdef CVF
-  open(27,file=appdir(:iz)//'/dphi.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(27,file=appdir(:iz)//'/dphi.txt',status='unknown')
-  open(28,file='fftw_wisdom.dat',status='unknown')
-  call import_wisdom_from_file(isuccess,28)
-  close(28)
-  if(isuccess.ne.0) write(*,1000) 
-1000 format('Using optimized FFTs.')
-#endif
-
-#ifdef CVF
-  open(29,file=appdir(:iz)//'/debug.txt',status='unknown',                 &amp;
-       share='denynone')
-#else
-  open(29,file=appdir(:iz)//'/debug.txt',status='unknown')
-#endif
-
-  call cs_unlock
-  return
-
-910 print*,'Error opening DECODED.TXT'
-  stop
-911 print*,'Error opening messages.txt'
-  stop
-912 print*,'Error opening bandmap.txt'
-  stop
-920 print*,'Error opening DECODED.AVE'
-  stop
-930 print*,'Error opening AZEL.DAT'
-  stop
-950 print*,'Error opening ALL65.TXT'
-  stop
-
-end subroutine ftn_init

Copied: branches/map65/ftn_init.f90 (from rev 2454, branches/map65/ftn_init.F90)
===================================================================
--- branches/map65/ftn_init.f90	                        (rev 0)
+++ branches/map65/ftn_init.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,171 @@
+! Fortran logical units used in WSJT6
+!
+!   10  binary input data, *.tf2 files
+!   11  decoded.txt
+!   12  decoded.ave
+!   13  tsky.dat
+!   14  azel.dat
+!   15  
+!   16
+!   17  saved *.tf2 files
+!   18  test file to be transmitted (wsjtgen.f90)
+!   19  messages.txt
+!   20  bandmap.txt
+!   21  ALL65.TXT
+!   22  kvasd.dat
+!   23  CALL3.TXT
+!   24  meas24.dat
+!   25  meas25.dat
+!   26  tmp26.txt
+!   27  dphi.txt
+!   28  fftw_wisdom.dat
+!   29  debug.txt
+!------------------------------------------------ ftn_init
+subroutine ftn_init
+
+  character*1 cjunk
+  integer ptt
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  include 'gcom4.f90'
+
+  call cs_init
+  call cs_lock('ftn_init')
+  i=ptt(nport,pttport,0,iptt)                       !Clear the PTT line
+  addpfx='    '
+  nrw26=0
+
+  do i=80,1,-1
+     if(AppDir(i:i).ne.' ') goto 1
+  enddo
+1 iz=i
+  lenappdir=iz
+  call pfxdump(appdir(:iz)//'/prefixes.txt')
+
+  do i=80,1,-1
+     if(AzElDir(i:i).ne.' ') goto 2
+  enddo
+2 iz2=i
+
+#ifdef CVF
+  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
+       share='denynone',err=910)
+#else
+  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
+       err=910)
+#endif
+  endfile 11
+
+#ifdef CVF
+  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
+       share='denynone',err=920)
+#else
+  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
+       err=920)
+#endif
+  endfile 12
+
+#ifdef CVF
+  open(14,file=azeldir(:iz2)//'/azel.dat',status='unknown',                  &amp;
+       share='denynone',err=930)
+#else
+  open(14,file=azeldir(:iz2)//'/azel.dat',status='unknown',                  &amp;
+       err=930)
+#endif
+
+#ifdef CVF
+  open(19,file=appdir(:iz)//'/messages.txt',status='unknown',               &amp;
+       share='denynone',err=911)
+#else
+  open(19,file=appdir(:iz)//'/messages.txt',status='unknown',               &amp;
+       err=911)
+#endif
+  endfile 19
+
+#ifdef CVF
+  open(20,file=appdir(:iz)//'/bandmap.txt',status='unknown',               &amp;
+       share='denynone',err=912)
+#else
+  open(20,file=appdir(:iz)//'/bandmap.txt',status='unknown',               &amp;
+       err=912)
+#endif
+  endfile 20
+
+#ifdef CVF
+  open(21,file=appdir(:iz)//'/ALL65.TXT',status='unknown',                   &amp;
+       access='append',share='denynone',err=950)
+#else
+  open(21,file=appdir(:iz)//'/ALL65.TXT',status='unknown',                   &amp;
+	access='append',err=950)
+  do i=1,9999999
+     read(21,*,end=10) cjunk
+  enddo
+10 continue
+#endif
+
+#ifdef CVF
+  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
+       status='unknown',share='denynone')
+#else
+  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
+       status='unknown')
+#endif
+
+#ifdef CVF
+  open(24,file=appdir(:iz)//'/meas24.txt',status='unknown',                 &amp;
+       share='denynone')
+#else
+  open(24,file=appdir(:iz)//'/meas24.txt',status='unknown')
+#endif
+
+#ifdef CVF
+  open(25,file=appdir(:iz)//'/meas25.txt',status='unknown',                 &amp;
+       share='denynone')
+#else
+  open(25,file=appdir(:iz)//'/meas25.txt',status='unknown')
+#endif
+
+#ifdef CVF
+  open(26,file=appdir(:iz)//'/tmp26.txt',status='unknown',                 &amp;
+       share='denynone')
+#else
+  open(26,file=appdir(:iz)//'/tmp26.txt',status='unknown')
+#endif
+
+#ifdef CVF
+  open(27,file=appdir(:iz)//'/dphi.txt',status='unknown',                 &amp;
+       share='denynone')
+#else
+  open(27,file=appdir(:iz)//'/dphi.txt',status='unknown')
+  open(28,file='fftw_wisdom.dat',status='unknown')
+  call import_wisdom_from_file(isuccess,28)
+  close(28)
+  if(isuccess.ne.0) write(*,1000) 
+1000 format('Using optimized FFTs.')
+#endif
+
+#ifdef CVF
+  open(29,file=appdir(:iz)//'/debug.txt',status='unknown',                 &amp;
+       share='denynone')
+#else
+  open(29,file=appdir(:iz)//'/debug.txt',status='unknown')
+#endif
+
+  call cs_unlock
+  return
+
+910 print*,'Error opening DECODED.TXT'
+  stop
+911 print*,'Error opening messages.txt'
+  stop
+912 print*,'Error opening bandmap.txt'
+  stop
+920 print*,'Error opening DECODED.AVE'
+  stop
+930 print*,'Error opening AZEL.DAT'
+  stop
+950 print*,'Error opening ALL65.TXT'
+  stop
+
+end subroutine ftn_init

Deleted: branches/map65/getfile.F90
===================================================================
--- branches/map65/getfile.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/getfile.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,14 +0,0 @@
-!----------------------------------------------------- getfile
-subroutine getfile(fname,len)
-  character*(*) fname
-
-  include 'datcom.f90'
-  include 'gcom2.f90'
-
-  fname80=fname
-  nlen=len
-  newdat2=1
-  ierr=0
-
-  return
-end subroutine getfile

Copied: branches/map65/getfile.f90 (from rev 2454, branches/map65/getfile.F90)
===================================================================
--- branches/map65/getfile.f90	                        (rev 0)
+++ branches/map65/getfile.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,14 @@
+!----------------------------------------------------- getfile
+subroutine getfile(fname,len)
+  character*(*) fname
+
+  include 'datcom.f90'
+  include 'gcom2.f90'
+
+  fname80=fname
+  nlen=len
+  newdat2=1
+  ierr=0
+
+  return
+end subroutine getfile

Deleted: branches/map65/getfile2.F90
===================================================================
--- branches/map65/getfile2.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/getfile2.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,71 +0,0 @@
-subroutine getfile2(fname,len)
-
-#ifdef CVF
-  use dflib
-#endif
-
-  character*(*) fname
-  real*8 sq
-
-  include 'datcom.f90'
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom4.f90'
-  integer*2 id(4,NSMAX)
-
-1 if(ndecoding.eq.0) go to 2
-#ifdef CVF
-  call sleepqq(100)
-#else
-  call usleep(100*1000)
-#endif
-
-  go to 1
-
-2 do i=len,1,-1
-     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
-  enddo
-  i=0
-10 filename=fname(i+1:)
-  ierr=0
-
-  n=8*NSMAX
-  ndecoding=4
-  monitoring=0
-  kbuf=1
-
-  call cs_lock('getfile2a')
-!###
-! NB: not really necessary to read whole file at once.  Save memory!
-  call rfile3a(fname,id,n,ierr)
-  do i=1,NSMAX
-     dd(1,i,1)=id(1,i)
-     dd(2,i,1)=id(2,i)
-  enddo
-!###
-
-  call cs_unlock
-  if(ierr.ne.0) then
-     print*,'Error opening or reading file: ',fname,ierr
-     go to 999
-  endif
-
-  sq=0.
-  ka=0.1*NSMAX
-  kb=0.8*NSMAX
-  do k=ka,kb
-     sq=sq + dd(1,k,1)**2 + dd(2,k,1)**2 + dd(3,k,1)**2 + dd(4,k,1)**2
-  enddo
-  sqave=174*sq/(kb-ka+1)
-  rxnoise=10.0*log10(sqave) - 48.0
-  call cs_lock('getfile2b')
-  read(filename(8:11),*,err=20,end=20) nutc
-  call cs_unlock
-  go to 30
-20 nutc=0
-
-30 ndiskdat=1
-  mousebutton=0
-
-999 return
-end subroutine getfile2

Copied: branches/map65/getfile2.f90 (from rev 2454, branches/map65/getfile2.F90)
===================================================================
--- branches/map65/getfile2.f90	                        (rev 0)
+++ branches/map65/getfile2.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,71 @@
+subroutine getfile2(fname,len)
+
+#ifdef CVF
+  use dflib
+#endif
+
+  character*(*) fname
+  real*8 sq
+
+  include 'datcom.f90'
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom4.f90'
+  integer*2 id(4,NSMAX)
+
+1 if(ndecoding.eq.0) go to 2
+#ifdef CVF
+  call sleepqq(100)
+#else
+  call usleep(100*1000)
+#endif
+
+  go to 1
+
+2 do i=len,1,-1
+     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
+  enddo
+  i=0
+10 filename=fname(i+1:)
+  ierr=0
+
+  n=8*NSMAX
+  ndecoding=4
+  monitoring=0
+  kbuf=1
+
+  call cs_lock('getfile2a')
+!###
+! NB: not really necessary to read whole file at once.  Save memory!
+  call rfile3a(fname,id,n,ierr)
+  do i=1,NSMAX
+     dd(1,i,1)=id(1,i)
+     dd(2,i,1)=id(2,i)
+  enddo
+!###
+
+  call cs_unlock
+  if(ierr.ne.0) then
+     print*,'Error opening or reading file: ',fname,ierr
+     go to 999
+  endif
+
+  sq=0.
+  ka=0.1*NSMAX
+  kb=0.8*NSMAX
+  do k=ka,kb
+     sq=sq + dd(1,k,1)**2 + dd(2,k,1)**2 + dd(3,k,1)**2 + dd(4,k,1)**2
+  enddo
+  sqave=174*sq/(kb-ka+1)
+  rxnoise=10.0*log10(sqave) - 48.0
+  call cs_lock('getfile2b')
+  read(filename(8:11),*,err=20,end=20) nutc
+  call cs_unlock
+  go to 30
+20 nutc=0
+
+30 ndiskdat=1
+  mousebutton=0
+
+999 return
+end subroutine getfile2

Deleted: branches/map65/map65a.F90
===================================================================
--- branches/map65/map65a.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/map65a.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,411 +0,0 @@
-subroutine map65a(newdat)
-
-!  Processes timf2 data from Linrad to find and decode JT65 signals.
-
-  parameter (MAXMSG=1000)            !Size of decoded message list
-  real tavg(-50:50)                  !Temp for finding local base level
-  real base(4)                       !Local basel level at 4 pol'ns
-  real tmp (200)                     !Temp storage for pctile sorting
-  real sig(MAXMSG,30)                !Parameters of detected signals
-  real a(5)
-  character*22 msg(MAXMSG)
-  character*3 shmsg0(4)
-  integer indx(MAXMSG),nsiz(MAXMSG)
-  logical done(MAXMSG)
-  character decoded*22,blank*22
-  include 'spcom.f90'
-  real short(3,NFFT)                 !SNR dt ipol for potential shorthands
-  real qphi(12)
-  include 'gcom2.f90'
-  include 'datcom.f90'
-  common/c3com/ mcall3a
-  
-  data blank/'                      '/
-  data shmsg0/'ATT','RO ','RRR','73 '/
-  data nfile/0/,nutc0/-999/,nid/0/,ip000/1/,ip001/1/,mousefqso0/-999/
-  save
-
-  mcall3a=mcall3
-  if(mcall3.eq.1) mcall3=0
-  if(mousefqso.ne.mousefqso0 .and. nagain.eq.1) newspec=2
-  mousefqso0=mousefqso
-  nfoffset=nint(1000*(fcenter-144.125d0))
-  mfqso=mousefqso - nfoffset
-
-  rewind 11
-  rewind 12
-  if(nrw26.ne.0) then
-     endfile (26)              !Compiler bug?  Don't write &quot;end file 26&quot; !!!
-     rewind 26
-     rewind 19
-     endfile (19)
-     rewind 19
-     nrw26=0
-  endif
-
-#ifdef CVF
-  open(23,file='CALL3.TXT',status='unknown',share='denynone')
-#else
-  open(23,file='CALL3.TXT',status='unknown')
-#endif
-
-  if(nutc.ne.nutc0) nfile=nfile+1
-  nutc0=nutc
-  df=96000.0/NFFT                     !df = 96000/NFFT = 2.930 Hz
-  ftol=0.020                          !Frequency tolerance (kHz)
-  foffset=0.001*(1270 + nfcal)
-  fselect=mfqso + foffset
-  dphi=idphi/57.2957795
-
-  do i=12,3,-1
-     if(hiscall(i:i).ne.' ') go to 1
-  enddo
-  i=0
-1 len_hiscall=i
-
-  iloop=0
-2 if(ndphi.eq.1) dphi=30*iloop/57.2957795
-  do nqd=1,0,-1
-     if(nqd.eq.1) then                     !Quick decode, at fQSO
-        fa=1000.0*(fselect+0.001*mousedf-100.0) - dftolerance
-        fb=1000.0*(fselect+0.001*mousedf-100.0) + dftolerance + 4*53.8330078
-        ia=nint((fa+23000.0)/df + 1.0)     ! 23000 = 48000 - 25000
-        ib=nint((fb+23000.0)/df + 1.0)
-     else                                  !Wideband decode at all freqs
-        fa=1000*(nfa-100)
-        fb=1000*(nfb-100)
-        ia=nint((fa+23000.0)/df + 1.0)     ! 23000 = 48000 - 25000
-        ib=nint((fb+23000.0)/df + 1.0)
-     endif
-
-     km=0
-     nkm=1
-     nz=n/8
-
-     do i=1,NFFT
-        short(1,i)=0.
-        short(2,i)=0.
-        short(3,i)=0.
-     enddo
-
-     freq0=-999.
-     sync10=-999.
-     fshort0=-999.
-     sync20=-999.
-     ntry=0
-     do i=ia,ib                               !Search over freq range
-        call sleep_msec(0)
-        freq=0.001*((i-1)*df - 23000) + 100.0
-!  Find the local base level for each polarization; update every 10 bins.
-        if(mod(i-ia,10).eq.0) then
-           do jp=1,4
-              do ii=-50,50
-                 iii=i+ii
-                 if(iii.ge.1 .and. iii.le.32768) then
-                    tavg(ii)=savg(jp,iii)
-                 else
-                    print*,'Error in iii:',iii,ia,ib,fa,fb
-                    go to 999
-                 endif
-              enddo
-              call pctile(tavg,tmp,101,50,base(jp))
-           enddo
-           bmax=max(base(1),base(2),base(3),base(4))
-        endif
-
-!  Do not process extremely strong signals
-        if(nqd.eq.0 .and. bmax.gt.1000.0) go to 70
-
-!  Find max signal at this frequency
-        smax=0.
-        do jp=1,4
-           if(savg(jp,i)/base(jp).gt.smax) smax=savg(jp,i)/base(jp)
-        enddo
-
-        if(smax.gt.1.1) then
-           ntry=ntry+1
-!  Look for JT65 sync patterns and shorthand square-wave patterns.
-           call ccf65(ss(1,1,i),nhsym,sync1,ipol,dt,flipk,              &amp;
-                syncshort,snr2,ipol2,dt2)
-
-! ########################### Search for Shorthand Messages #################
-!  Is there a shorthand tone above threshold?
-           thresh0=1.0
-!  Use lower thresh0 at fQSO
-           if(nqd.eq.1 .and. dftolerance.le.100) thresh0=0.
-
-           if(syncshort.gt.thresh0) then
-! ### Do shorthand AFC here (or maybe after finding a pair?) ###
-              short(1,i)=syncshort
-              short(2,i)=dt2
-              short(3,i)=ipol2
-!  Check to see if lower tone of shorthand pair was found.
-              do j=2,4
-                 i0=i-nint(j*53.8330078/df)
-!  Should this be i0 +/- 1, or just i0?
-!  Should we also insist that difference in DT be either 1.5 or -1.5 s?
-                 if(short(1,i0).gt.1.0) then
-                    fshort=0.001*((i0-1)*df - 23000) + 100.0
-
-                    noffset=0
-                    if(nqd.eq.1) noffset=nint(1000.0*  &amp;
-                         (fshort-foffset-mfqso)-mousedf)
-                    if(abs(noffset).le.dftolerance) then
-!  Keep only the best candidate within ftol.
-!### NB: sync2 was not defined here!
-                       sync2=syncshort                   !### try this ???
-                       if(fshort-fshort0.le.ftol .and. sync2.gt.sync20    &amp;
-                            .and. nkm.eq.2) km=km-1
-                       if(fshort-fshort0.gt.ftol .or.                     &amp;
-                            sync2.gt.sync20) then
-                          km=km+1
-                          sig(km,1)=nfile
-                          sig(km,2)=nutc
-                          sig(km,3)=fshort
-                          sig(km,4)=syncshort
-                          sig(km,5)=dt2
-                          sig(km,6)=45*(ipol2-1)/57.2957795
-                          sig(km,7)=0
-                          sig(km,8)=snr2
-                          sig(km,9)=0
-                          sig(km,10)=0
-!                           sig(km,11)=rms0
-                          sig(km,12)=savg(ipol2,i)
-                          sig(km,13)=0
-                          sig(km,14)=0
-                          sig(km,15)=0
-                          sig(km,16)=0
-!                           sig(km,17)=0
-                          sig(km,18)=0
-                          msg(km)=shmsg0(j)
-                          fshort0=fshort
-                          sync20=sync2
-                          nkm=2
-                       endif
-                    endif
-                 endif
-              enddo
-           endif
-
-! ########################### Search for Normal Messages ###########
-!  Is sync1 above threshold?
-           thresh1=1.0
-!  Use lower thresh1 at fQSO
-           if(nqd.eq.1 .and. dftolerance.le.100) thresh1=0.
-           noffset=0
-           if(nqd.eq.1) noffset=nint(1000.0*(freq-foffset-mfqso)-mousedf)
-           if(sync1.gt.thresh1 .and. abs(noffset).le.dftolerance) then
-!  Keep only the best candidate within ftol.
-!  (Am I deleting any good decodes by doing this?)
-              if(freq-freq0.le.ftol .and. sync1.gt.sync10 .and.               &amp;
-                   nkm.eq.1) km=km-1
-              if(freq-freq0.gt.ftol .or. sync1.gt.sync10) then
-                 nflip=nint(flipk)
-                 call decode1a(dd(1,1,kbuf),newdat,freq,nflip,        &amp;
-                      mycall,hiscall,hisgrid,neme,ndepth,nqd,dphi,ndphi,    &amp;
-                      ipol,sync2,a,dt,pol,nkv,nhist,qual,decoded)
-
-!  If hiscall or hisgrid is in decoded message, save the pol'n angle.
-                 i1=index(decoded,hiscall(1:len_hiscall))
-                 i2=index(decoded,hisgrid(1:4))
-                 if(i1.ge.5 .or. i2.ge.9) then
-                    nhispol=nint(57.2957795*pol)
-                 endif
-                 km=km+1
-                 sig(km,1)=nfile
-                 sig(km,2)=nutc
-                 sig(km,3)=freq
-                 sig(km,4)=sync1
-                 sig(km,5)=dt
-                 sig(km,6)=pol
-                 sig(km,7)=flipk
-                 sig(km,8)=sync2
-                 sig(km,9)=nkv
-                 sig(km,10)=qual
-!                 sig(km,11)=idphi
-                 sig(km,12)=savg(ipol,i)
-                 sig(km,13)=a(1)
-                 sig(km,14)=a(2)
-                 sig(km,15)=a(3)
-                 sig(km,16)=a(4)
-!                     sig(km,17)=a(5)
-                 sig(km,18)=nhist
-                 msg(km)=decoded
-                 freq0=freq
-                 sync10=sync1
-                 nkm=1
-              endif
-           endif
-        endif
-70      continue
-     enddo
-     if(nqd.eq.1) then
-        nwrite=0
-        do k=1,km
-           decoded=msg(k)
-           if(decoded.ne.'                      ') then
-              nutc=sig(k,2)
-              freq=sig(k,3)
-              sync1=sig(k,4)
-              dt=sig(k,5)
-              npol=nint(57.2957795*sig(k,6))
-              flip=sig(k,7)
-              sync2=sig(k,8)
-              nkv=sig(k,9)
-              nqual=sig(k,10)
-!              idphi=nint(sig(k,11))
-              if(flip.lt.0.0) then
-                 do i=22,1,-1
-                    if(decoded(i:i).ne.' ') go to 8
-                 enddo
-                 stop 'Error in message format'
-8                if(i.le.18) decoded(i+2:i+4)='OOO'
-              endif
-              nkHz=nint(freq-foffset) + nfoffset
-              f0=144.0+0.001*nkHz
-              ndf=nint(1000.0*(freq-foffset-nkHz+nfoffset))
-
-!              ndf0=nint(a(1))
-!              ndf1=nint(a(2))
-!              ndf2=nint(a(3))
-              nsync1=sync1
-              nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
-              if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
-                 decoded(1:4).eq.'73  ') nsync2=nsync2-6
-              nwrite=nwrite+1
-              if(nxant.ne.0) then
-                 npol=npol-45
-                 if(npol.lt.0) npol=npol+180
-              endif
-              call cs_lock('map65aa')
-              if(ndphi.eq.0) then
-                 write(11,1010) nkHz,ndf,npol,nutc,dt,nsync2,decoded,nkv,nqual
-1010             format(i3,i5,i4,i5.4,f5.1,i4,2x,a22,i5,i4,i4)
-              else
-		 if(iloop.ge.1) qphi(iloop)=sig(k,10)
-                 write(11,1010) nkHz,ndf,npol,nutc,dt,nsync2,decoded,nkv,  &amp;
-                      nqual,30*iloop
-                 write(27,1011) 30*iloop,nkHz,ndf,npol,nutc,  &amp;
-                      dt,sync2,nkv,nqual,decoded
-1011             format(i3,i4,i5,i4,i5.4,f5.1,f7.1,i3,i5,2x,a22)
-              endif
-              call cs_unlock
-           endif
-        enddo
-        if(nwrite.eq.0) then
-           nfqso=mfqso + nfoffset
-           call cs_lock('map65ab')
-           write(11,1012) nfqso,nutc
-1012          format(i3,9x,i5.4)
-           call cs_unlock
-        endif
-   
-     endif
-     if(ndphi.eq.1 .and.iloop.lt.12) then
-        iloop=iloop+1
-        go to 2
-     endif
-     if(ndphi.eq.1 .and.iloop.eq.12) call getdphi(qphi)
-     if(nqd.eq.1) then
-        write(11,*) '$EOF'
-        call flushqqq(11)
-        ndecdone=1
-     endif
-     if(nagain.eq.1) go to 999
-  enddo
-
-!  Trim the list and produce a sorted index and sizes of groups.
-!  (Should trimlist remove all but best SNR for given UTC and message content?)
-  call trimlist(sig,km,indx,nsiz,nz)
-
-  do i=1,km
-     done(i)=.false.
-  enddo
-  j=0
-  ilatest=-1
-  do n=1,nz
-     ifile0=0
-     do m=1,nsiz(n)
-        i=indx(j+m)
-        ifile=sig(i,1)
-        if(ifile.gt.ifile0 .and.msg(i).ne.blank) then
-           ilatest=i
-           ifile0=ifile
-        endif
-     enddo
-     i=ilatest
-
-     if(i.ge.1) then
-        if(.not.done(i)) then
-           done(i)=.true.
-           nutc=sig(i,2)
-           freq=sig(i,3)
-           sync1=sig(i,4)
-           dt=sig(i,5)
-           npol=nint(57.2957795*sig(i,6))
-           flip=sig(i,7)
-           sync2=sig(i,8)
-           nkv=sig(i,9)
-           nqual=min(sig(i,10),10.0)
-!                  rms0=sig(i,11)
-           do k=1,5
-              a(k)=sig(i,12+k)
-           enddo
-           nhist=sig(i,18)
-           decoded=msg(i)
-           
-           if(flip.lt.0.0) then
-              do i=22,1,-1
-                 if(decoded(i:i).ne.' ') go to 10
-              enddo
-              stop 'Error in message format'
-10            if(i.le.18) decoded(i+2:i+4)='OOO'
-           endif
-           nkHz=nint(freq-foffset) + nfoffset
-           f0=144.0+0.001*nkHz
-           ndf=nint(1000.0*(freq-foffset-nkHz+nfoffset))
-           ndf0=nint(a(1))
-           ndf1=nint(a(2))
-           ndf2=nint(a(3))
-           nsync1=sync1
-           nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
-           if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
-                decoded(1:4).eq.'73  ') nsync2=nsync2-6
-           if(nxant.ne.0) then
-              npol=npol-45
-              if(npol.lt.0) npol=npol+180
-           endif
-           call cs_lock('map65ac')
-           write(26,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
-                nsync2,nutc,decoded,nkv,nqual,nhist
-           write(21,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
-                nsync2,nutc,decoded,nkv,nqual,nhist
-1014       format(f7.3,i5,3i3,f5.1,i5,i3,i4,i5.4,2x,a22,3i3)
-           call cs_unlock
-
-        endif
-     endif
-     j=j+nsiz(n)
-  enddo
-  call cs_lock('map65ad')
-  write(26,1015) nutc
-1015 format(39x,i4.4)
-  call flushqqq(26)
-  call cs_unlock
-  call display(nkeep)
-  ndecdone=2
-
-!### Temporarily disable the optional saving of raw data
-!  if(nsave.gt.0 .and. ndiskdat.eq.0) call savetf2(id(1,1,kbuf),       &amp;
-!       fnamedate,savedir)
-!###
-
-999 close(23)
-  ndphi=0
-  if(kbuf.eq.1) kkdone=60*96000
-  if(kbuf.eq.2 .or. ndiskdat.eq.1) kkdone=0
-  kk=kkdone
-  nagain=0
-
-  return
-end subroutine map65a

Copied: branches/map65/map65a.f90 (from rev 2454, branches/map65/map65a.F90)
===================================================================
--- branches/map65/map65a.f90	                        (rev 0)
+++ branches/map65/map65a.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,411 @@
+subroutine map65a(newdat)
+
+!  Processes timf2 data from Linrad to find and decode JT65 signals.
+
+  parameter (MAXMSG=1000)            !Size of decoded message list
+  real tavg(-50:50)                  !Temp for finding local base level
+  real base(4)                       !Local basel level at 4 pol'ns
+  real tmp (200)                     !Temp storage for pctile sorting
+  real sig(MAXMSG,30)                !Parameters of detected signals
+  real a(5)
+  character*22 msg(MAXMSG)
+  character*3 shmsg0(4)
+  integer indx(MAXMSG),nsiz(MAXMSG)
+  logical done(MAXMSG)
+  character decoded*22,blank*22
+  include 'spcom.f90'
+  real short(3,NFFT)                 !SNR dt ipol for potential shorthands
+  real qphi(12)
+  include 'gcom2.f90'
+  include 'datcom.f90'
+  common/c3com/ mcall3a
+  
+  data blank/'                      '/
+  data shmsg0/'ATT','RO ','RRR','73 '/
+  data nfile/0/,nutc0/-999/,nid/0/,ip000/1/,ip001/1/,mousefqso0/-999/
+  save
+
+  mcall3a=mcall3
+  if(mcall3.eq.1) mcall3=0
+  if(mousefqso.ne.mousefqso0 .and. nagain.eq.1) newspec=2
+  mousefqso0=mousefqso
+  nfoffset=nint(1000*(fcenter-144.125d0))
+  mfqso=mousefqso - nfoffset
+
+  rewind 11
+  rewind 12
+  if(nrw26.ne.0) then
+     endfile (26)              !Compiler bug?  Don't write &quot;end file 26&quot; !!!
+     rewind 26
+     rewind 19
+     endfile (19)
+     rewind 19
+     nrw26=0
+  endif
+
+#ifdef CVF
+  open(23,file='CALL3.TXT',status='unknown',share='denynone')
+#else
+  open(23,file='CALL3.TXT',status='unknown')
+#endif
+
+  if(nutc.ne.nutc0) nfile=nfile+1
+  nutc0=nutc
+  df=96000.0/NFFT                     !df = 96000/NFFT = 2.930 Hz
+  ftol=0.020                          !Frequency tolerance (kHz)
+  foffset=0.001*(1270 + nfcal)
+  fselect=mfqso + foffset
+  dphi=idphi/57.2957795
+
+  do i=12,3,-1
+     if(hiscall(i:i).ne.' ') go to 1
+  enddo
+  i=0
+1 len_hiscall=i
+
+  iloop=0
+2 if(ndphi.eq.1) dphi=30*iloop/57.2957795
+  do nqd=1,0,-1
+     if(nqd.eq.1) then                     !Quick decode, at fQSO
+        fa=1000.0*(fselect+0.001*mousedf-100.0) - dftolerance
+        fb=1000.0*(fselect+0.001*mousedf-100.0) + dftolerance + 4*53.8330078
+        ia=nint((fa+23000.0)/df + 1.0)     ! 23000 = 48000 - 25000
+        ib=nint((fb+23000.0)/df + 1.0)
+     else                                  !Wideband decode at all freqs
+        fa=1000*(nfa-100)
+        fb=1000*(nfb-100)
+        ia=nint((fa+23000.0)/df + 1.0)     ! 23000 = 48000 - 25000
+        ib=nint((fb+23000.0)/df + 1.0)
+     endif
+
+     km=0
+     nkm=1
+     nz=n/8
+
+     do i=1,NFFT
+        short(1,i)=0.
+        short(2,i)=0.
+        short(3,i)=0.
+     enddo
+
+     freq0=-999.
+     sync10=-999.
+     fshort0=-999.
+     sync20=-999.
+     ntry=0
+     do i=ia,ib                               !Search over freq range
+        call sleep_msec(0)
+        freq=0.001*((i-1)*df - 23000) + 100.0
+!  Find the local base level for each polarization; update every 10 bins.
+        if(mod(i-ia,10).eq.0) then
+           do jp=1,4
+              do ii=-50,50
+                 iii=i+ii
+                 if(iii.ge.1 .and. iii.le.32768) then
+                    tavg(ii)=savg(jp,iii)
+                 else
+                    print*,'Error in iii:',iii,ia,ib,fa,fb
+                    go to 999
+                 endif
+              enddo
+              call pctile(tavg,tmp,101,50,base(jp))
+           enddo
+           bmax=max(base(1),base(2),base(3),base(4))
+        endif
+
+!  Do not process extremely strong signals
+        if(nqd.eq.0 .and. bmax.gt.1000.0) go to 70
+
+!  Find max signal at this frequency
+        smax=0.
+        do jp=1,4
+           if(savg(jp,i)/base(jp).gt.smax) smax=savg(jp,i)/base(jp)
+        enddo
+
+        if(smax.gt.1.1) then
+           ntry=ntry+1
+!  Look for JT65 sync patterns and shorthand square-wave patterns.
+           call ccf65(ss(1,1,i),nhsym,sync1,ipol,dt,flipk,              &amp;
+                syncshort,snr2,ipol2,dt2)
+
+! ########################### Search for Shorthand Messages #################
+!  Is there a shorthand tone above threshold?
+           thresh0=1.0
+!  Use lower thresh0 at fQSO
+           if(nqd.eq.1 .and. dftolerance.le.100) thresh0=0.
+
+           if(syncshort.gt.thresh0) then
+! ### Do shorthand AFC here (or maybe after finding a pair?) ###
+              short(1,i)=syncshort
+              short(2,i)=dt2
+              short(3,i)=ipol2
+!  Check to see if lower tone of shorthand pair was found.
+              do j=2,4
+                 i0=i-nint(j*53.8330078/df)
+!  Should this be i0 +/- 1, or just i0?
+!  Should we also insist that difference in DT be either 1.5 or -1.5 s?
+                 if(short(1,i0).gt.1.0) then
+                    fshort=0.001*((i0-1)*df - 23000) + 100.0
+
+                    noffset=0
+                    if(nqd.eq.1) noffset=nint(1000.0*  &amp;
+                         (fshort-foffset-mfqso)-mousedf)
+                    if(abs(noffset).le.dftolerance) then
+!  Keep only the best candidate within ftol.
+!### NB: sync2 was not defined here!
+                       sync2=syncshort                   !### try this ???
+                       if(fshort-fshort0.le.ftol .and. sync2.gt.sync20    &amp;
+                            .and. nkm.eq.2) km=km-1
+                       if(fshort-fshort0.gt.ftol .or.                     &amp;
+                            sync2.gt.sync20) then
+                          km=km+1
+                          sig(km,1)=nfile
+                          sig(km,2)=nutc
+                          sig(km,3)=fshort
+                          sig(km,4)=syncshort
+                          sig(km,5)=dt2
+                          sig(km,6)=45*(ipol2-1)/57.2957795
+                          sig(km,7)=0
+                          sig(km,8)=snr2
+                          sig(km,9)=0
+                          sig(km,10)=0
+!                           sig(km,11)=rms0
+                          sig(km,12)=savg(ipol2,i)
+                          sig(km,13)=0
+                          sig(km,14)=0
+                          sig(km,15)=0
+                          sig(km,16)=0
+!                           sig(km,17)=0
+                          sig(km,18)=0
+                          msg(km)=shmsg0(j)
+                          fshort0=fshort
+                          sync20=sync2
+                          nkm=2
+                       endif
+                    endif
+                 endif
+              enddo
+           endif
+
+! ########################### Search for Normal Messages ###########
+!  Is sync1 above threshold?
+           thresh1=1.0
+!  Use lower thresh1 at fQSO
+           if(nqd.eq.1 .and. dftolerance.le.100) thresh1=0.
+           noffset=0
+           if(nqd.eq.1) noffset=nint(1000.0*(freq-foffset-mfqso)-mousedf)
+           if(sync1.gt.thresh1 .and. abs(noffset).le.dftolerance) then
+!  Keep only the best candidate within ftol.
+!  (Am I deleting any good decodes by doing this?)
+              if(freq-freq0.le.ftol .and. sync1.gt.sync10 .and.               &amp;
+                   nkm.eq.1) km=km-1
+              if(freq-freq0.gt.ftol .or. sync1.gt.sync10) then
+                 nflip=nint(flipk)
+                 call decode1a(dd(1,1,kbuf),newdat,freq,nflip,        &amp;
+                      mycall,hiscall,hisgrid,neme,ndepth,nqd,dphi,ndphi,    &amp;
+                      ipol,sync2,a,dt,pol,nkv,nhist,qual,decoded)
+
+!  If hiscall or hisgrid is in decoded message, save the pol'n angle.
+                 i1=index(decoded,hiscall(1:len_hiscall))
+                 i2=index(decoded,hisgrid(1:4))
+                 if(i1.ge.5 .or. i2.ge.9) then
+                    nhispol=nint(57.2957795*pol)
+                 endif
+                 km=km+1
+                 sig(km,1)=nfile
+                 sig(km,2)=nutc
+                 sig(km,3)=freq
+                 sig(km,4)=sync1
+                 sig(km,5)=dt
+                 sig(km,6)=pol
+                 sig(km,7)=flipk
+                 sig(km,8)=sync2
+                 sig(km,9)=nkv
+                 sig(km,10)=qual
+!                 sig(km,11)=idphi
+                 sig(km,12)=savg(ipol,i)
+                 sig(km,13)=a(1)
+                 sig(km,14)=a(2)
+                 sig(km,15)=a(3)
+                 sig(km,16)=a(4)
+!                     sig(km,17)=a(5)
+                 sig(km,18)=nhist
+                 msg(km)=decoded
+                 freq0=freq
+                 sync10=sync1
+                 nkm=1
+              endif
+           endif
+        endif
+70      continue
+     enddo
+     if(nqd.eq.1) then
+        nwrite=0
+        do k=1,km
+           decoded=msg(k)
+           if(decoded.ne.'                      ') then
+              nutc=sig(k,2)
+              freq=sig(k,3)
+              sync1=sig(k,4)
+              dt=sig(k,5)
+              npol=nint(57.2957795*sig(k,6))
+              flip=sig(k,7)
+              sync2=sig(k,8)
+              nkv=sig(k,9)
+              nqual=sig(k,10)
+!              idphi=nint(sig(k,11))
+              if(flip.lt.0.0) then
+                 do i=22,1,-1
+                    if(decoded(i:i).ne.' ') go to 8
+                 enddo
+                 stop 'Error in message format'
+8                if(i.le.18) decoded(i+2:i+4)='OOO'
+              endif
+              nkHz=nint(freq-foffset) + nfoffset
+              f0=144.0+0.001*nkHz
+              ndf=nint(1000.0*(freq-foffset-nkHz+nfoffset))
+
+!              ndf0=nint(a(1))
+!              ndf1=nint(a(2))
+!              ndf2=nint(a(3))
+              nsync1=sync1
+              nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
+              if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
+                 decoded(1:4).eq.'73  ') nsync2=nsync2-6
+              nwrite=nwrite+1
+              if(nxant.ne.0) then
+                 npol=npol-45
+                 if(npol.lt.0) npol=npol+180
+              endif
+              call cs_lock('map65aa')
+              if(ndphi.eq.0) then
+                 write(11,1010) nkHz,ndf,npol,nutc,dt,nsync2,decoded,nkv,nqual
+1010             format(i3,i5,i4,i5.4,f5.1,i4,2x,a22,i5,i4,i4)
+              else
+		 if(iloop.ge.1) qphi(iloop)=sig(k,10)
+                 write(11,1010) nkHz,ndf,npol,nutc,dt,nsync2,decoded,nkv,  &amp;
+                      nqual,30*iloop
+                 write(27,1011) 30*iloop,nkHz,ndf,npol,nutc,  &amp;
+                      dt,sync2,nkv,nqual,decoded
+1011             format(i3,i4,i5,i4,i5.4,f5.1,f7.1,i3,i5,2x,a22)
+              endif
+              call cs_unlock
+           endif
+        enddo
+        if(nwrite.eq.0) then
+           nfqso=mfqso + nfoffset
+           call cs_lock('map65ab')
+           write(11,1012) nfqso,nutc
+1012          format(i3,9x,i5.4)
+           call cs_unlock
+        endif
+   
+     endif
+     if(ndphi.eq.1 .and.iloop.lt.12) then
+        iloop=iloop+1
+        go to 2
+     endif
+     if(ndphi.eq.1 .and.iloop.eq.12) call getdphi(qphi)
+     if(nqd.eq.1) then
+        write(11,*) '$EOF'
+        call flushqqq(11)
+        ndecdone=1
+     endif
+     if(nagain.eq.1) go to 999
+  enddo
+
+!  Trim the list and produce a sorted index and sizes of groups.
+!  (Should trimlist remove all but best SNR for given UTC and message content?)
+  call trimlist(sig,km,indx,nsiz,nz)
+
+  do i=1,km
+     done(i)=.false.
+  enddo
+  j=0
+  ilatest=-1
+  do n=1,nz
+     ifile0=0
+     do m=1,nsiz(n)
+        i=indx(j+m)
+        ifile=sig(i,1)
+        if(ifile.gt.ifile0 .and.msg(i).ne.blank) then
+           ilatest=i
+           ifile0=ifile
+        endif
+     enddo
+     i=ilatest
+
+     if(i.ge.1) then
+        if(.not.done(i)) then
+           done(i)=.true.
+           nutc=sig(i,2)
+           freq=sig(i,3)
+           sync1=sig(i,4)
+           dt=sig(i,5)
+           npol=nint(57.2957795*sig(i,6))
+           flip=sig(i,7)
+           sync2=sig(i,8)
+           nkv=sig(i,9)
+           nqual=min(sig(i,10),10.0)
+!                  rms0=sig(i,11)
+           do k=1,5
+              a(k)=sig(i,12+k)
+           enddo
+           nhist=sig(i,18)
+           decoded=msg(i)
+           
+           if(flip.lt.0.0) then
+              do i=22,1,-1
+                 if(decoded(i:i).ne.' ') go to 10
+              enddo
+              stop 'Error in message format'
+10            if(i.le.18) decoded(i+2:i+4)='OOO'
+           endif
+           nkHz=nint(freq-foffset) + nfoffset
+           f0=144.0+0.001*nkHz
+           ndf=nint(1000.0*(freq-foffset-nkHz+nfoffset))
+           ndf0=nint(a(1))
+           ndf1=nint(a(2))
+           ndf2=nint(a(3))
+           nsync1=sync1
+           nsync2=nint(10.0*log10(sync2)) - 40 !### empirical ###
+           if(decoded(1:4).eq.'RO  ' .or. decoded(1:4).eq.'RRR  ' .or.  &amp;
+                decoded(1:4).eq.'73  ') nsync2=nsync2-6
+           if(nxant.ne.0) then
+              npol=npol-45
+              if(npol.lt.0) npol=npol+180
+           endif
+           call cs_lock('map65ac')
+           write(26,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
+                nsync2,nutc,decoded,nkv,nqual,nhist
+           write(21,1014) f0,ndf,ndf0,ndf1,ndf2,dt,npol,nsync1,       &amp;
+                nsync2,nutc,decoded,nkv,nqual,nhist
+1014       format(f7.3,i5,3i3,f5.1,i5,i3,i4,i5.4,2x,a22,3i3)
+           call cs_unlock
+
+        endif
+     endif
+     j=j+nsiz(n)
+  enddo
+  call cs_lock('map65ad')
+  write(26,1015) nutc
+1015 format(39x,i4.4)
+  call flushqqq(26)
+  call cs_unlock
+  call display(nkeep)
+  ndecdone=2
+
+!### Temporarily disable the optional saving of raw data
+!  if(nsave.gt.0 .and. ndiskdat.eq.0) call savetf2(id(1,1,kbuf),       &amp;
+!       fnamedate,savedir)
+!###
+
+999 close(23)
+  ndphi=0
+  if(kbuf.eq.1) kkdone=60*96000
+  if(kbuf.eq.2 .or. ndiskdat.eq.1) kkdone=0
+  kk=kkdone
+  nagain=0
+
+  return
+end subroutine map65a

Modified: branches/map65/plrs.F90
===================================================================
--- branches/map65/plrs.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/plrs.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -12,6 +12,11 @@
   integer*1 userx_no,iusb
   integer*2 nblock
   real*8 d(NZ),buf8
+
+  real*8 buf8a(174)
+  integer*2 id(4,174)
+  real*4 buf4(4,87)
+
   integer fd
   integer open,read,close
   integer nm(11)
@@ -19,12 +24,14 @@
   logical fast,pause
   real*8 center_freq,dmsec,dtmspacket,tmsec
   common/plrscom/center_freq,msec2,fsample,iptr,nblock,userx_no,iusb,buf8(174)
+  equivalence (id,buf8a)
+  equivalence (buf8,buf4)
   data nm/45,46,48,50,52,54,55,56,57,58,59/
   data nblock/0/,fast/.false./,pause/.false./
 
   nargs=iargc()
-  if(nargs.ne.4) then
-     print*,'Usage: plrs &lt;fast|pause|slow&gt; &lt;minutes&gt; &lt;iters&gt; &lt;iwait&gt;'
+  if(nargs.ne.5) then
+     print*,'Usage: plrs &lt;fast|pause|slow&gt; &lt;minutes&gt; &lt;iters&gt; &lt;iwait&gt; &lt;ifloat&gt;'
      go to 999
   endif
 
@@ -37,6 +44,8 @@
   read(arg,*) iters
   call getarg(4,arg)
   read(arg,*) iwait
+  call getarg(5,arg)
+  read(arg,*) ifloat
 
   if(iwait.ne.0) then
 1    if(mod(int(sec_midn()),60).eq.0) go to 2
@@ -45,10 +54,12 @@
   endif
 
 2 fname=&quot;all.tf2&quot;//char(0)
-  userx_no=0
+  userx_no=2
+  if(ifloat.ne.0) userx_no=-2
   iusb=1
   center_freq=144.125d0
   dtmspacket=1000.d0*NBPP/(8.d0*96000.d0)
+  if(ifloat.ne.0) dtmspacket=0.5*dtmspacket
   fsample=96000.0
   npkt=0
 
@@ -61,7 +72,7 @@
      fd=open(fname,RMODE)                  !Open file for reading
 #endif
      dmsec=-dtmspacket
-     nsec0=sec_midn()
+     sec0=sec_midn()
 
      do ifile=1,nfiles
         ns0=0
@@ -82,13 +93,43 @@
               go to 999
            endif
 #endif
+           if(ifloat.ne.0) then
+              buf8a=buf8
+              do i=1,87
+                 buf4(1,i)=id(1,i)
+                 buf4(2,i)=id(2,i)
+                 buf4(3,i)=id(3,i)
+                 buf4(4,i)=id(4,i)
+              enddo
+           endif
+
            nblock=nblock+1
            call send_pkt(center_freq)
            npkt=npkt+1
+
+           if(ifloat.ne.0) then
+! Send a second packet if format is floating point
+              do i=1,87
+                 buf4(1,i)=id(1,i+87)
+                 buf4(2,i)=id(2,i+87)
+                 buf4(3,i)=id(3,i+87)
+                 buf4(4,i)=id(4,i+87)
+              enddo
+
+              dmsec=dmsec+dtmspacket
+              tmsec=tmsec+dtmspacket
+              msec2=nint(tmsec)
+              msec=nint(dmsec)
+              nblock=nblock+1
+              call send_pkt(center_freq)
+              npkt=npkt+1
+           endif
+
+
               
            if(mod(npkt,100).eq.0) then
-              nsec=int(sec_midn())-nsec0
-              nwait=msec-1000*nsec
+              sec=int(sec_midn())-sec0
+              nwait=msec-1000*sec
 !  Pace the data at close to its real-time rate
               if(nwait.gt.0 .and. .not.fast) call sleep_msec(nwait)
            endif

Modified: branches/map65/plrs_subs.c
===================================================================
--- branches/map65/plrs_subs.c	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/plrs_subs.c	2011-10-03 20:02:58 UTC (rev 2455)
@@ -27,7 +27,8 @@
   /* set up destination address */
   memset(&amp;addr,0,sizeof(addr));
   addr.sin_family=AF_INET;
-  addr.sin_addr.s_addr=inet_addr(HELLO_GROUP);
+  //  addr.sin_addr.s_addr=inet_addr(HELLO_GROUP);
+  addr.sin_addr.s_addr=inet_addr(&quot;128.112.87.74&quot;);
   addr.sin_port=htons(HELLO_PORT);
 }
 

Deleted: branches/map65/recvpkt.F90
===================================================================
--- branches/map65/recvpkt.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/recvpkt.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,181 +0,0 @@
-subroutine recvpkt(iarg)
-
-! Receive timf2 packets from Linrad and stuff data into array dd().
-! (This routine runs in a background thread and will never return.)
-
-  parameter (NSZ=2*60*96000)
-  integer*1 userx_no,iusb
-  integer*2 nblock,nblock0
-  logical first,synced
-  real*8 center_freq,d8,buf8
-  complex*16 c16,buf16(87)
-  integer*2 jd(4)
-  real*4 xd(4)
-  common/plrscom/center_freq,msec,fqso,iptr,nblock,userx_no,iusb,buf8(174)
-  include 'datcom.f90'
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  equivalence (jd,d8)
-  equivalence (xd,c16)
-  equivalence (buf8,buf16)
-  data nblock0/0/,kb/1/,ns00/99/,first/.true./
-  data sqave/0.0/,rxnoise/0.0/,pctblank/0.0/,kbuf/1/,lost_tot/0/
-  data multicast0/-99/
-  save
-
-1 continue
-  call cs_lock('recvpkt')
-  call setup_rsocket(multicast)     !Open socket for multicast/unicast data
-  call cs_unlock
-  k=0
-  kk=0
-  kxp=0
-  kb=1
-  nsec0=-999
-  fcenter=144.125                   !Default (startup) frequency)
-  multicast0=multicast
-  ntx=0
-  synced=.false.
-
-10 if(multicast.ne.multicast0) go to 1
-  call recv_pkt(center_freq)
-
-  if(userx_no.lt.0) then
-     nfloat=1
-  else
-     nfloat=0
-  endif
-
-  iz=174
-  if(nfloat.ne.0) iz=87
-
-! Should receive a new packet every 174/96000 = 0.0018125 s
-  nsec=mod(Tsec,86400.d0)           !Time according to MAP65
-  nseclr=msec/1000                  !Time according to Linrad
-  fcenter=center_freq
-  if(forcefcenter.gt.0.0) fcenter=forcefcenter
-
-! Reset buffer pointers at start of minute.
-  ns=mod(nsec,60)
-  if(ns.lt.ns00 .and. (lauto+monitoring.ne.0)) then
-!     print*,'new minute:',mod(nsec/60,60),ns00,ns,ntx,kb
-     if(ntx.eq.0) kb=3-kb
-     if(first) kb=1
-     k=(kb-1)*60*96000
-     kxp=k
-     ndone1=0
-     ndone2=0
-     lost_tot=0
-     synced=.true.
-     ntx=0
-  endif
-  ns00=ns
-
-  if(transmitting.eq.1) ntx=1
-
-! Test for buffer full
-  if((kb.eq.1 .and. (k+iz).gt.NSMAX) .or.                          &amp;
-       (kb.eq.2 .and. (k+iz).gt.2*NSMAX)) go to 20
-
-  if(.not.first) then
-! Check for lost packets
-     lost=nblock-nblock0-1
-     if(lost.ne.0) then
-        nb=nblock
-        if(nb.lt.0) nb=nb+65536
-        nb0=nblock0
-        if(nb0.lt.0) nb0=nb0+65536
-        lost_tot=lost_tot + lost               ! Insert zeros for the lost data.
-!###
-!        do i=1,iz*lost
-!           k=k+1
-!           d8(k)=0
-!        enddo
-!###
-     endif
-  endif
-  first=.false.
-  nblock0=nblock
-
-  tdiff=mod(0.001d0*msec,60.d0)-mod(Tsec,60.d0)
-  if(tdiff.lt.-30.) tdiff=tdiff+60.
-  if(tdiff.gt.30.) tdiff=tdiff-60.
-
-! Move data into Rx buffer and compute average signal level.
-  sq=0.
-  do i=1,iz
-     k=k+1
-     k2=k
-     n=1
-     if(k.gt.NSMAX) then
-        k2=k2-NSMAX
-        n=2
-     endif
-
-     if(nfloat.eq.0) then
-        d8=buf8(i)
-        x1=jd(1)
-        x2=jd(2)
-        x3=jd(3)
-        x4=jd(4)
-        dd(1,k2,n)=x1
-        dd(2,k2,n)=x2
-        dd(3,k2,n)=x3
-        dd(4,k2,n)=x4
-        sq=sq + x1*x1 + x2*x2 + x3*x3 + x4*x4
-     else
-        c16=buf16(i)
-        x1=xd(1)
-        x2=xd(2)
-        x3=xd(3)
-        x4=xd(4)
-        dd(1,k2,n)=x1
-        dd(2,k2,n)=x2
-        dd(3,k2,n)=x3
-        dd(4,k2,n)=x4
-        sq=sq + x1*x1 + x2*x2 + x3*x3 + x4*x4
-     endif
-  enddo
-  sq=sq/(2.0*iz)
-  u=0.001
-  if(nfloat.ne.1) u=2.0*u
-  sqave=sqave + u*(sq-sqave)
-  rxnoise=10.0*log10(sqave) - 20.0            ! Was -48.0
-  kxp=k
-
-20 if(nsec.ne.nsec0) then
-     nsec0=nsec
-     mutch=nseclr/3600
-     mutcm=mod(nseclr/60,60)
-     mutc=100*mutch + mutcm
-
-! If we have not transmitted in this minute, see if it's time to start FFTs
-     if(ntx.eq.0 .and. lauto+monitoring.ne.0) then
-        if(ns.ge.nt1 .and. ndone1.eq.0 .and. synced) then
-           nutc=mutc
-           fcenter=center_freq
-           if(forcefcenter.gt.0.0) fcenter=forcefcenter
-           kbuf=kb
-           kk=k
-           ndiskdat=0
-           ndone1=1
-        endif
-
-! See if it's time to start the full decoding procedure.
-        nhsym=(k-(kbuf-1)*60*96000)/17832.9252
-        if(ndone1.eq.1 .and. nhsym.ge.279 .and.ndone2.eq.0) then
-           kk=k
-           nlost=lost_tot                         ! Save stats for printout
-           ndone2=1
-!           print*,'recvpkt 2:',ns,kb,k
-        endif
-     endif
-
-!     if(ns.le.5 .or. ns.ge.46) write(*,3001) ns,ndone1,kb,  &amp;
-!          kbuf,ntx,kk,tdiff
-!3001 format(5i4,i11,f8.2)
-
-  endif
-  go to 10
-
-end subroutine recvpkt

Copied: branches/map65/recvpkt.f90 (from rev 2454, branches/map65/recvpkt.F90)
===================================================================
--- branches/map65/recvpkt.f90	                        (rev 0)
+++ branches/map65/recvpkt.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,181 @@
+subroutine recvpkt(iarg)
+
+! Receive timf2 packets from Linrad and stuff data into array dd().
+! (This routine runs in a background thread and will never return.)
+
+  parameter (NSZ=2*60*96000)
+  integer*1 userx_no,iusb
+  integer*2 nblock,nblock0
+  logical first,synced
+  real*8 center_freq,d8,buf8
+  complex*16 c16,buf16(87)
+  integer*2 jd(4)
+  real*4 xd(4)
+  common/plrscom/center_freq,msec,fqso,iptr,nblock,userx_no,iusb,buf8(174)
+  include 'datcom.f90'
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  equivalence (jd,d8)
+  equivalence (xd,c16)
+  equivalence (buf8,buf16)
+  data nblock0/0/,kb/1/,ns00/99/,first/.true./
+  data sqave/0.0/,rxnoise/0.0/,pctblank/0.0/,kbuf/1/,lost_tot/0/
+  data multicast0/-99/
+  save
+
+1 continue
+  call cs_lock('recvpkt')
+  call setup_rsocket(multicast)     !Open socket for multicast/unicast data
+  call cs_unlock
+  k=0
+  kk=0
+  kxp=0
+  kb=1
+  nsec0=-999
+  fcenter=144.125                   !Default (startup) frequency)
+  multicast0=multicast
+  ntx=0
+  synced=.false.
+
+10 if(multicast.ne.multicast0) go to 1
+  call recv_pkt(center_freq)
+
+  if(userx_no.lt.0) then
+     nfloat=1
+  else
+     nfloat=0
+  endif
+
+  iz=174
+  if(nfloat.ne.0) iz=87
+
+! Should receive a new packet every 174/96000 = 0.0018125 s
+  nsec=mod(Tsec,86400.d0)           !Time according to MAP65
+  nseclr=msec/1000                  !Time according to Linrad
+  fcenter=center_freq
+  if(forcefcenter.gt.0.0) fcenter=forcefcenter
+
+! Reset buffer pointers at start of minute.
+  ns=mod(nsec,60)
+  if(ns.lt.ns00 .and. (lauto+monitoring.ne.0)) then
+!     print*,'new minute:',mod(nsec/60,60),ns00,ns,ntx,kb
+     if(ntx.eq.0) kb=3-kb
+     if(first) kb=1
+     k=(kb-1)*60*96000
+     kxp=k
+     ndone1=0
+     ndone2=0
+     lost_tot=0
+     synced=.true.
+     ntx=0
+  endif
+  ns00=ns
+
+  if(transmitting.eq.1) ntx=1
+
+! Test for buffer full
+  if((kb.eq.1 .and. (k+iz).gt.NSMAX) .or.                          &amp;
+       (kb.eq.2 .and. (k+iz).gt.2*NSMAX)) go to 20
+
+  if(.not.first) then
+! Check for lost packets
+     lost=nblock-nblock0-1
+     if(lost.ne.0) then
+        nb=nblock
+        if(nb.lt.0) nb=nb+65536
+        nb0=nblock0
+        if(nb0.lt.0) nb0=nb0+65536
+        lost_tot=lost_tot + lost               ! Insert zeros for the lost data.
+!###
+!        do i=1,iz*lost
+!           k=k+1
+!           d8(k)=0
+!        enddo
+!###
+     endif
+  endif
+  first=.false.
+  nblock0=nblock
+
+  tdiff=mod(0.001d0*msec,60.d0)-mod(Tsec,60.d0)
+  if(tdiff.lt.-30.) tdiff=tdiff+60.
+  if(tdiff.gt.30.) tdiff=tdiff-60.
+
+! Move data into Rx buffer and compute average signal level.
+  sq=0.
+  do i=1,iz
+     k=k+1
+     k2=k
+     n=1
+     if(k.gt.NSMAX) then
+        k2=k2-NSMAX
+        n=2
+     endif
+
+     if(nfloat.eq.0) then
+        d8=buf8(i)
+        x1=jd(1)
+        x2=jd(2)
+        x3=jd(3)
+        x4=jd(4)
+        dd(1,k2,n)=x1
+        dd(2,k2,n)=x2
+        dd(3,k2,n)=x3
+        dd(4,k2,n)=x4
+        sq=sq + x1*x1 + x2*x2 + x3*x3 + x4*x4
+     else
+        c16=buf16(i)
+        x1=xd(1)
+        x2=xd(2)
+        x3=xd(3)
+        x4=xd(4)
+        dd(1,k2,n)=x1
+        dd(2,k2,n)=x2
+        dd(3,k2,n)=x3
+        dd(4,k2,n)=x4
+        sq=sq + x1*x1 + x2*x2 + x3*x3 + x4*x4
+     endif
+  enddo
+  sq=sq/(2.0*iz)
+  u=0.001
+  if(nfloat.ne.1) u=2.0*u
+  sqave=sqave + u*(sq-sqave)
+  rxnoise=10.0*log10(sqave) - 20.0            ! Was -48.0
+  kxp=k
+
+20 if(nsec.ne.nsec0) then
+     nsec0=nsec
+     mutch=nseclr/3600
+     mutcm=mod(nseclr/60,60)
+     mutc=100*mutch + mutcm
+
+! If we have not transmitted in this minute, see if it's time to start FFTs
+     if(ntx.eq.0 .and. lauto+monitoring.ne.0) then
+        if(ns.ge.nt1 .and. ndone1.eq.0 .and. synced) then
+           nutc=mutc
+           fcenter=center_freq
+           if(forcefcenter.gt.0.0) fcenter=forcefcenter
+           kbuf=kb
+           kk=k
+           ndiskdat=0
+           ndone1=1
+        endif
+
+! See if it's time to start the full decoding procedure.
+        nhsym=(k-(kbuf-1)*60*96000)/17832.9252
+        if(ndone1.eq.1 .and. nhsym.ge.279 .and.ndone2.eq.0) then
+           kk=k
+           nlost=lost_tot                         ! Save stats for printout
+           ndone2=1
+!           print*,'recvpkt 2:',ns,kb,k
+        endif
+     endif
+
+!     if(ns.le.5 .or. ns.ge.46) write(*,3001) ns,ndone1,kb,  &amp;
+!          kbuf,ntx,kk,tdiff
+!3001 format(5i4,i11,f8.2)
+
+  endif
+  go to 10
+
+end subroutine recvpkt

Deleted: branches/map65/rfile3a.F90
===================================================================
--- branches/map65/rfile3a.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/rfile3a.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,18 +0,0 @@
-!----------------------------------------------------- rfile3a
-subroutine rfile3a(infile,ibuf,n,ierr)
-
-  character*(*) infile
-  integer*1 ibuf(n)
-
-#ifdef CVF
-  open(10,file=infile,form='binary',status='old',err=998)
-#else
-  open(10,file=infile,access='stream',status='old',err=998)
-#endif
-  read(10,end=998) ibuf
-  ierr=0
-  go to 999
-998 ierr=1002
-999 close(10)
-  return
-end subroutine rfile3a

Copied: branches/map65/rfile3a.f90 (from rev 2454, branches/map65/rfile3a.F90)
===================================================================
--- branches/map65/rfile3a.f90	                        (rev 0)
+++ branches/map65/rfile3a.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,18 @@
+!----------------------------------------------------- rfile3a
+subroutine rfile3a(infile,ibuf,n,ierr)
+
+  character*(*) infile
+  integer*1 ibuf(n)
+
+#ifdef CVF
+  open(10,file=infile,form='binary',status='old',err=998)
+#else
+  open(10,file=infile,access='stream',status='old',err=998)
+#endif
+  read(10,end=998) ibuf
+  ierr=0
+  go to 999
+998 ierr=1002
+999 close(10)
+  return
+end subroutine rfile3a

Deleted: branches/map65/runqqq.F90
===================================================================
--- branches/map65/runqqq.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/runqqq.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,17 +0,0 @@
-subroutine runqqq(fname,cmnd,iret)
-
-#ifdef CVF
-  use dflib
-#endif
-  integer system
-
-  character*(*) fname,cmnd
-
-#ifdef CVF
-  iret=runqq(fname,cmnd)
-#else
-  iret=system('KVASD_g95 -q &gt; dev_null')
-#endif
-
-  return
-end subroutine runqqq

Copied: branches/map65/runqqq.f90 (from rev 2454, branches/map65/runqqq.F90)
===================================================================
--- branches/map65/runqqq.f90	                        (rev 0)
+++ branches/map65/runqqq.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,17 @@
+subroutine runqqq(fname,cmnd,iret)
+
+#ifdef CVF
+  use dflib
+#endif
+  integer system
+
+  character*(*) fname,cmnd
+
+#ifdef CVF
+  iret=runqq(fname,cmnd)
+#else
+  iret=system('KVASD_g95 -q &gt; dev_null')
+#endif
+
+  return
+end subroutine runqqq

Deleted: branches/map65/savetf2.F90
===================================================================
--- branches/map65/savetf2.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/savetf2.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,58 +0,0 @@
-subroutine savetf2(id,fnamedate,savedir)
-
-  parameter (NZ=60*96000)
-  parameter (NSPP=174)
-  parameter (NPKTS=NZ/NSPP)
-  integer*2 id(4,NZ)
-  character*80 savedir,fname
-  character cdate*8,ctime2*10,czone*5,fnamedate*6
-  integer  itt(8)
-  data nloc/-1/
-  save nloc
-
-  call cs_lock('savetf2')
-  call date_and_time(cdate,ctime2,czone,itt)
-  nh=itt(5)-itt(4)/60
-  nm=itt(6)
-  ns=itt(7)
-  if(ns.lt.50) nm=nm-1
-  if(nm.lt.0) then
-     nm=nm+60
-     nh=nh-1
-  endif
-  if(nh.lt.0) nh=nh+24
-  if(nh.ge.24) nh=nh-24
-  write(fname,1001) fnamedate,nh,nm
-1001 format('/',a6,'_',2i2.2,'.tf2')
-  do i=80,1,-1
-     if(savedir(i:i).ne.' ') go to 1
-  enddo
-1 iz=i
-  fname=savedir(1:iz)//fname
-#ifdef CVF
-  open(17,file=fname,status='unknown',form='binary',err=998)
-#else
-  open(17,file=fname,status='unknown',access='stream',err=998)
-#endif
-
-  if(nloc.eq.-1) nloc=loc(id)
-  n=abs(loc(id)-nloc)
-  if(n.eq.0 .or. n.eq.46080000) then
-     write(17,err=997) id
-  else
-     print*,'Address of id() clobbered???',nloc,loc(id)
-  endif
-  close(17)
-  go to 999
-
-997 print*,'Error writing tf2 file'
-  print*,fname
-  go to 999
-
-998 print*,'Cannot open file:'
-  print*,fname
-
-999 continue
-  call cs_unlock
-  return
-end subroutine savetf2

Copied: branches/map65/savetf2.f90 (from rev 2454, branches/map65/savetf2.F90)
===================================================================
--- branches/map65/savetf2.f90	                        (rev 0)
+++ branches/map65/savetf2.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,58 @@
+subroutine savetf2(id,fnamedate,savedir)
+
+  parameter (NZ=60*96000)
+  parameter (NSPP=174)
+  parameter (NPKTS=NZ/NSPP)
+  integer*2 id(4,NZ)
+  character*80 savedir,fname
+  character cdate*8,ctime2*10,czone*5,fnamedate*6
+  integer  itt(8)
+  data nloc/-1/
+  save nloc
+
+  call cs_lock('savetf2')
+  call date_and_time(cdate,ctime2,czone,itt)
+  nh=itt(5)-itt(4)/60
+  nm=itt(6)
+  ns=itt(7)
+  if(ns.lt.50) nm=nm-1
+  if(nm.lt.0) then
+     nm=nm+60
+     nh=nh-1
+  endif
+  if(nh.lt.0) nh=nh+24
+  if(nh.ge.24) nh=nh-24
+  write(fname,1001) fnamedate,nh,nm
+1001 format('/',a6,'_',2i2.2,'.tf2')
+  do i=80,1,-1
+     if(savedir(i:i).ne.' ') go to 1
+  enddo
+1 iz=i
+  fname=savedir(1:iz)//fname
+#ifdef CVF
+  open(17,file=fname,status='unknown',form='binary',err=998)
+#else
+  open(17,file=fname,status='unknown',access='stream',err=998)
+#endif
+
+  if(nloc.eq.-1) nloc=loc(id)
+  n=abs(loc(id)-nloc)
+  if(n.eq.0 .or. n.eq.46080000) then
+     write(17,err=997) id
+  else
+     print*,'Address of id() clobbered???',nloc,loc(id)
+  endif
+  close(17)
+  go to 999
+
+997 print*,'Error writing tf2 file'
+  print*,fname
+  go to 999
+
+998 print*,'Cannot open file:'
+  print*,fname
+
+999 continue
+  call cs_unlock
+  return
+end subroutine savetf2

Deleted: branches/map65/sec_midn.F90
===================================================================
--- branches/map65/sec_midn.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/sec_midn.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,19 +0,0 @@
-real function sec_midn()
-  sec_midn=secnds(0.0)
-  return
-end function sec_midn
-
-subroutine sleep_msec(n)
-
-#ifdef CVF
-  use dflib
-#endif
-
-#ifdef CVF
-  call sleepqq(n)
-#else
-  call usleep(1000*n)
-#endif
-
-  return
-end subroutine sleep_msec

Copied: branches/map65/sec_midn.f90 (from rev 2454, branches/map65/sec_midn.F90)
===================================================================
--- branches/map65/sec_midn.f90	                        (rev 0)
+++ branches/map65/sec_midn.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,19 @@
+real function sec_midn()
+  sec_midn=secnds(0.0)
+  return
+end function sec_midn
+
+subroutine sleep_msec(n)
+
+#ifdef CVF
+  use dflib
+#endif
+
+#ifdef CVF
+  call sleepqq(n)
+#else
+  call usleep(1000*n)
+#endif
+
+  return
+end subroutine sleep_msec

Deleted: branches/map65/wsjtgen.F90
===================================================================
--- branches/map65/wsjtgen.F90	2011-09-29 19:00:54 UTC (rev 2454)
+++ branches/map65/wsjtgen.F90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -1,131 +0,0 @@
-subroutine wsjtgen
-
-! Compute the waveform to be transmitted.  
-
-! Input:    txmsg        message to be transmitted, up to 28 characters
-!           samfacout    fsample_out/11025.d0
-
-! Output:   iwave        waveform data, i*2 format
-!           nwave        number of samples
-!           sendingsh    0=normal; 1=shorthand (FSK441) or plain text (JT65)
-
-  parameter (NMSGMAX=28)             !Max characters per message
-  parameter (NSPD=25)                !Samples per dit
-  parameter (NDPC=3)                 !Dits per character
-  parameter (NWMAX=661500)           !Max length of waveform = 60*11025
-  parameter (NTONES=4)               !Number of FSK tones
-  character msg*28,msgsent*22,idmsg*22
-  real*8 freq,dpha,twopi
-  character testfile*27
-  logical lcwid
-  integer*2 icwid(110250),jwave(NWMAX)
-
-  integer*1 hdr(44)
-  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-  character*4 ariff,awave,afmt,adata
-  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
-     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,jwave
-  equivalence (ariff,hdr)
-
-  data twopi/6.28318530718d0/
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  fsample_out=11025.d0*samfacout
-  lcwid=.false.
-  if(idinterval.gt.0) then
-     n=(mod(int(tsec/60.d0),idinterval))
-     if(n.eq.(1-txfirst)) lcwid=.true.
-     if(idinterval.eq.1) lcwid=.true.
-  endif
-
-  msg=txmsg
-  call msgtrim(msg,nmsg)
-  txmsg=msg
-  ntxnow=ntxreq
-  nmsg0=nmsg
-
-  if(msg(1:1).eq.'@') then
-     if(msg(2:2).eq.'/' .or. ichar(msg(2:2)).eq.92) then
-        txmsg=msg
-        testfile=msg(2:)
-#ifdef CVF
-        open(18,file=testfile,form='binary',status='old',err=12)
-#else
-        open(18,file=testfile,access='stream',status='old',err=12)
-#endif
-        go to 14
-12      print*,'Cannot open test file ',msg(2:)
-        go to 999
-14      call cs_lock('wsjtgena')
-        read(18) hdr
-        if(ndata.gt.NTxMax) ndata=NTxMax
-        call rfile(18,iwave,ndata,ierr)
-        close(18)
-        call cs_unlock
-        if(ierr.ne.0) print*,'Error reading test file ',msg(2:)
-        nwave=ndata/2
-        do i=nwave,NTXMAX
-           iwave(i)=0
-        enddo
-	sending=txmsg
-	sendingsh=2
-        go to 999
-     endif
-
-! Transmit a fixed tone at specified frequency
-     freq=1000.0
-     if(msg(2:2).eq.'A' .or. msg(2:2).eq.'a') freq=882
-     if(msg(2:2).eq.'B' .or. msg(2:2).eq.'b') freq=1323
-     if(msg(2:2).eq.'C' .or. msg(2:2).eq.'c') freq=1764
-     if(msg(2:2).eq.'D' .or. msg(2:2).eq.'d') freq=2205
-     if(freq.eq.1000.0) then
-        call cs_lock('wsjtgenb')
-        read(msg(2:),*,err=1) freq
-        goto 2
-1       txmsg='@1000'
-        nmsg=5
-        nmsg0=5
-2       call cs_unlock
-     endif
-     nwave=60*fsample_out
-     dpha=twopi*freq/fsample_out
-     do i=1,nwave
-        iwave(i)=32767.0*sin(i*dpha)
-     enddo
-     goto 900
-  endif
-
-!  We're in JT65 mode.
-  if(mode(5:5).eq.'A') mode65=1
-  if(mode(5:5).eq.'B') mode65=2
-  if(mode(5:5).eq.'C') mode65=4
-  call cs_lock('wsjtgenc')
-  call gen65(msg,mode65,samfacout,iwave,nwave,sendingsh,msgsent)
-  call cs_unlock
-
-  if(lcwid) then
-!  Generate and insert the CW ID.
-     wpm=25.
-     freqcw=800.
-     idmsg=MyCall//'          '
-     call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
-     k=nwave
-     do i=1,ncwid
-        k=k+1
-        iwave(k)=icwid(i)
-     enddo
-     do i=1,2205                   !Add 0.2 s of silence
-        k=k+1
-        iwave(k)=0
-     enddo
-     nwave=k
-  endif
-
-900 sending=txmsg
-  if(sendingsh.ne.1) sending=msgsent
-  nmsg=nmsg0
-
-999  return
-end subroutine wsjtgen
-

Copied: branches/map65/wsjtgen.f90 (from rev 2454, branches/map65/wsjtgen.F90)
===================================================================
--- branches/map65/wsjtgen.f90	                        (rev 0)
+++ branches/map65/wsjtgen.f90	2011-10-03 20:02:58 UTC (rev 2455)
@@ -0,0 +1,131 @@
+subroutine wsjtgen
+
+! Compute the waveform to be transmitted.  
+
+! Input:    txmsg        message to be transmitted, up to 28 characters
+!           samfacout    fsample_out/11025.d0
+
+! Output:   iwave        waveform data, i*2 format
+!           nwave        number of samples
+!           sendingsh    0=normal; 1=shorthand (FSK441) or plain text (JT65)
+
+  parameter (NMSGMAX=28)             !Max characters per message
+  parameter (NSPD=25)                !Samples per dit
+  parameter (NDPC=3)                 !Dits per character
+  parameter (NWMAX=661500)           !Max length of waveform = 60*11025
+  parameter (NTONES=4)               !Number of FSK tones
+  character msg*28,msgsent*22,idmsg*22
+  real*8 freq,dpha,twopi
+  character testfile*27
+  logical lcwid
+  integer*2 icwid(110250),jwave(NWMAX)
+
+  integer*1 hdr(44)
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,jwave
+  equivalence (ariff,hdr)
+
+  data twopi/6.28318530718d0/
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+
+  fsample_out=11025.d0*samfacout
+  lcwid=.false.
+  if(idinterval.gt.0) then
+     n=(mod(int(tsec/60.d0),idinterval))
+     if(n.eq.(1-txfirst)) lcwid=.true.
+     if(idinterval.eq.1) lcwid=.true.
+  endif
+
+  msg=txmsg
+  call msgtrim(msg,nmsg)
+  txmsg=msg
+  ntxnow=ntxreq
+  nmsg0=nmsg
+
+  if(msg(1:1).eq.'@') then
+     if(msg(2:2).eq.'/' .or. ichar(msg(2:2)).eq.92) then
+        txmsg=msg
+        testfile=msg(2:)
+#ifdef CVF
+        open(18,file=testfile,form='binary',status='old',err=12)
+#else
+        open(18,file=testfile,access='stream',status='old',err=12)
+#endif
+        go to 14
+12      print*,'Cannot open test file ',msg(2:)
+        go to 999
+14      call cs_lock('wsjtgena')
+        read(18) hdr
+        if(ndata.gt.NTxMax) ndata=NTxMax
+        call rfile(18,iwave,ndata,ierr)
+        close(18)
+        call cs_unlock
+        if(ierr.ne.0) print*,'Error reading test file ',msg(2:)
+        nwave=ndata/2
+        do i=nwave,NTXMAX
+           iwave(i)=0
+        enddo
+	sending=txmsg
+	sendingsh=2
+        go to 999
+     endif
+
+! Transmit a fixed tone at specified frequency
+     freq=1000.0
+     if(msg(2:2).eq.'A' .or. msg(2:2).eq.'a') freq=882
+     if(msg(2:2).eq.'B' .or. msg(2:2).eq.'b') freq=1323
+     if(msg(2:2).eq.'C' .or. msg(2:2).eq.'c') freq=1764
+     if(msg(2:2).eq.'D' .or. msg(2:2).eq.'d') freq=2205
+     if(freq.eq.1000.0) then
+        call cs_lock('wsjtgenb')
+        read(msg(2:),*,err=1) freq
+        goto 2
+1       txmsg='@1000'
+        nmsg=5
+        nmsg0=5
+2       call cs_unlock
+     endif
+     nwave=60*fsample_out
+     dpha=twopi*freq/fsample_out
+     do i=1,nwave
+        iwave(i)=32767.0*sin(i*dpha)
+     enddo
+     goto 900
+  endif
+
+!  We're in JT65 mode.
+  if(mode(5:5).eq.'A') mode65=1
+  if(mode(5:5).eq.'B') mode65=2
+  if(mode(5:5).eq.'C') mode65=4
+  call cs_lock('wsjtgenc')
+  call gen65(msg,mode65,samfacout,iwave,nwave,sendingsh,msgsent)
+  call cs_unlock
+
+  if(lcwid) then
+!  Generate and insert the CW ID.
+     wpm=25.
+     freqcw=800.
+     idmsg=MyCall//'          '
+     call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
+     k=nwave
+     do i=1,ncwid
+        k=k+1
+        iwave(k)=icwid(i)
+     enddo
+     do i=1,2205                   !Add 0.2 s of silence
+        k=k+1
+        iwave(k)=0
+     enddo
+     nwave=k
+  endif
+
+900 sending=txmsg
+  if(sendingsh.ne.1) sending=msgsent
+  nmsg=nmsg0
+
+999  return
+end subroutine wsjtgen
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="002148.html">[WSJT-SVN] r2456 - branches/map65
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2147">[ date ]</a>
              <a href="thread.html#2147">[ thread ]</a>
              <a href="subject.html#2147">[ subject ]</a>
              <a href="author.html#2147">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
