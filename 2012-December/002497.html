<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2804 - in branches/wsprx: . lib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2012-December/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2804%20-%20in%20branches/wsprx%3A%20.%20lib&In-Reply-To=%3C20121213153623.41CED55B0C%40scm.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002495.html">
   <LINK REL="Next"  HREF="002496.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2804 - in branches/wsprx: . lib</H1>
    <B>k1jt at scm.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2804%20-%20in%20branches/wsprx%3A%20.%20lib&In-Reply-To=%3C20121213153623.41CED55B0C%40scm.berlios.de%3E"
       TITLE="[WSJT-SVN] r2804 - in branches/wsprx: . lib">k1jt at scm.berlios.de
       </A><BR>
    <I>Thu Dec 13 16:36:22 CET 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="002495.html">[WSJT-SVN] r2803 - branches/wsprx
</A></li>
        <LI>Next message: <A HREF="002496.html">[WSJT-SVN] r2805 - in branches/wsprx: . lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2497">[ date ]</a>
              <a href="thread.html#2497">[ thread ]</a>
              <a href="subject.html#2497">[ subject ]</a>
              <a href="author.html#2497">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2012-12-13 16:36:21 +0100 (Thu, 13 Dec 2012)
New Revision: 2804

Added:
   branches/wsprx/lib/Makefile
   branches/wsprx/lib/ccf2.f
   branches/wsprx/lib/cs_stubs.f90
   branches/wsprx/lib/decode162.f
   branches/wsprx/lib/fchisq.f
   branches/wsprx/lib/flat3.f
   branches/wsprx/lib/genmept.f
   branches/wsprx/lib/getrms.f
   branches/wsprx/lib/getutc.f90
   branches/wsprx/lib/gmtime2.c
   branches/wsprx/lib/hash.f90
   branches/wsprx/lib/inter_mept.f
   branches/wsprx/lib/mept162.f
   branches/wsprx/lib/mix162.f
   branches/wsprx/lib/nhash.c
   branches/wsprx/lib/pack50.f
   branches/wsprx/lib/packpfx.f90
   branches/wsprx/lib/ps162.f
   branches/wsprx/lib/set.f
   branches/wsprx/lib/sound.c
   branches/wsprx/lib/spec162.f
   branches/wsprx/lib/sync162.f
   branches/wsprx/lib/twkfreq.f
   branches/wsprx/lib/unpack50.f
   branches/wsprx/lib/unpackpfx.f90
   branches/wsprx/lib/wfile5.f
   branches/wsprx/lib/wqdecode.f90
   branches/wsprx/lib/wqencode.f90
   branches/wsprx/lib/wspr0.f90
   branches/wsprx/lib/wspr0_rx.f90
   branches/wsprx/lib/wspr0_tx.f90
   branches/wsprx/lib/xfft.f
Removed:
   branches/wsprx/lib/afc9.f90
   branches/wsprx/lib/analytic.f90
   branches/wsprx/lib/bpskmetrics.dat
   branches/wsprx/lib/conv232.f90
   branches/wsprx/lib/cutil.c
   branches/wsprx/lib/decode9.f90
   branches/wsprx/lib/decode9a.f90
   branches/wsprx/lib/decode_rs.c
   branches/wsprx/lib/decoder.f90
   branches/wsprx/lib/downsam9.f90
   branches/wsprx/lib/encode_rs.c
   branches/wsprx/lib/entail.f90
   branches/wsprx/lib/f77_wisdom.f
   branches/wsprx/lib/fchisq.f90
   branches/wsprx/lib/fil61.f90
   branches/wsprx/lib/genjt9.f90
   branches/wsprx/lib/genmet.f90
   branches/wsprx/lib/getlags.f90
   branches/wsprx/lib/getpfx1.f
   branches/wsprx/lib/getpfx2.f
   branches/wsprx/lib/graycode.f90
   branches/wsprx/lib/grid2k.f
   branches/wsprx/lib/grid2n.f90
   branches/wsprx/lib/igray.c
   branches/wsprx/lib/indexx.f
   branches/wsprx/lib/init_rs.c
   branches/wsprx/lib/int.h
   branches/wsprx/lib/interleave8.f90
   branches/wsprx/lib/interleave9.f90
   branches/wsprx/lib/ipcomm.cpp
   branches/wsprx/lib/jt9.f90
   branches/wsprx/lib/jt9a.F90
   branches/wsprx/lib/jt9code.f90
   branches/wsprx/lib/jt9sim.f90
   branches/wsprx/lib/jt9test.f90
   branches/wsprx/lib/k2grid.f
   branches/wsprx/lib/met8.21
   branches/wsprx/lib/msgs.txt
   branches/wsprx/lib/n2grid.f90
   branches/wsprx/lib/nchar.f
   branches/wsprx/lib/noisegen.f90
   branches/wsprx/lib/packbits.f90
   branches/wsprx/lib/packdxcc.f
   branches/wsprx/lib/packmsg.f90
   branches/wsprx/lib/packtext.f
   branches/wsprx/lib/peakdf9.f90
   branches/wsprx/lib/peakdt9.f90
   branches/wsprx/lib/pfx.f
   branches/wsprx/lib/pfxdump.f
   branches/wsprx/lib/ptt_unix.c
   branches/wsprx/lib/rs.h
   branches/wsprx/lib/sec_midn.f90
   branches/wsprx/lib/sleep.h
   branches/wsprx/lib/sleep_msec.f90
   branches/wsprx/lib/spec9.f90
   branches/wsprx/lib/symspec2.f90
   branches/wsprx/lib/sync9.f90
   branches/wsprx/lib/tab.c
   branches/wsprx/lib/timer.f90
   branches/wsprx/lib/timeval.h
   branches/wsprx/lib/twkfreq.f90
   branches/wsprx/lib/unpackbits.f90
   branches/wsprx/lib/unpackmsg.f90
   branches/wsprx/lib/unpacktext.f
   branches/wsprx/lib/vit216.c
Modified:
   branches/wsprx/mainwindow.cpp
   branches/wsprx/mainwindow.h
   branches/wsprx/wsprx.pro
Log:
Removed JT9 fortran; added WSPR fortran.


Added: branches/wsprx/lib/Makefile
===================================================================
--- branches/wsprx/lib/Makefile	                        (rev 0)
+++ branches/wsprx/lib/Makefile	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,53 @@
+# Makefile for MinGW on Windows
+# Windows re-direct:
+#   C&gt; make &gt; junk1 2&gt;&amp;1
+
+CC = gcc
+FC = g95
+
+FFLAGS = -O2 -fbounds-check -Wall -Wno-precision-loss -fno-second-underscore
+CFLAGS = -I. -fbounds-check -mno-stack-arg-probe
+
+# Default rules
+%.o: %.c
+	${CC} ${CFLAGS} -c $&lt;
+%.o: %.f
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.f90
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F90
+	${FC} ${FFLAGS} -c $&lt;
+
+all:    libwspr.a wspr0.exe
+
+OBJS1 = symspec.o timf2.o fil3.o four2a.o pctile.o redsync.o \
+	sort.o ssort.o db.o 
+
+libwspr.a: $(OBJS1)
+	ar cr libwspr.a $(OBJS1) 
+	ranlib libwspr.a
+
+OBJS2 = wspr0.o wspr0_tx.o sound.o ptt.o gmtime2.o wfile5.o \
+	cs_stubs.o genmept.o wqencode.o wqdecode.o inter_mept.o \
+	encode232.o gran.o packcall.o packgrid.o pack50.o packpfx.o \
+	hash.o unpackcall.o unpackgrid.o unpackpfx.o unpack50.o \
+	grid2deg.o deg2grid.o nhash.o nchar.o wspr0_rx.o getrms.o \
+	mept162.o mix162.o spec162.o sync162.o twkfreq.o \
+	decode162.o getutc.o set.o xfft.o four2a.o flat3.o ps162.o \
+	pctile.o fchisq.o db.o fano232.o sort.o ssort.o ccf2.o
+
+wspr0.exe: $(OBJS2)
+	$(FC) -o wspr0 $(FFLAGS) $(OBJS2) libportaudio.a \
+	   c:\MinGW\lib\libwinmm.a libfftw3f_win.a
+
+sound.o: sound.c
+	$(CC) -c sound.c
+gmtime2.o: gmtime2.c
+	$(CC) -c -DWin32=1 gmtime2.c
+
+.PHONY : clean
+
+clean:
+	rm -f *.o libwspr.a 

Deleted: branches/wsprx/lib/afc9.f90
===================================================================
--- branches/wsprx/lib/afc9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/afc9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,58 +0,0 @@
-subroutine afc9(c3,npts,fsample,a,syncpk)
-
-  complex c3(0:npts-1)
-  real a(3),deltaa(3)
-
-  a(1)=0.                                   !f0
-  a(2)=0.                                   !f1
-  a(3)=0.                                   !f2
-  deltaa(1)=0.2
-  deltaa(2)=0.01
-  deltaa(3)=0.01
-  nterms=3
-
-! Start the iteration
-  chisqr=0.
-  chisqr0=1.e6
-  do iter=1,4                               !One iteration is enough?
-     do j=1,nterms
-        chisq1=fchisq(c3,npts,fsample,a)
-        fn=0.
-        delta=deltaa(j)
-10      a(j)=a(j)+delta
-        chisq2=fchisq(c3,npts,fsample,a)
-        if(chisq2.eq.chisq1) go to 10
-        if(chisq2.gt.chisq1) then
-           delta=-delta                      !Reverse direction
-           a(j)=a(j)+delta
-           tmp=chisq1
-           chisq1=chisq2
-           chisq2=tmp
-        endif
-20      fn=fn+1.0
-        a(j)=a(j)+delta
-        chisq3=fchisq(c3,npts,fsample,a)
-        if(chisq3.lt.chisq2) then
-           chisq1=chisq2
-           chisq2=chisq3
-           go to 20
-        endif
-
-! Find minimum of parabola defined by last three points
-        delta=delta*(1./(1.+(chisq1-chisq2)/(chisq3-chisq2))+0.5)
-        a(j)=a(j)-delta
-        deltaa(j)=deltaa(j)*fn/3.
-!        write(*,4000) iter,j,a,deltaa,-chisq2
-!4000    format(i1,i2,6f10.4,f9.3)
-     enddo
-     chisqr=fchisq(c3,npts,fsample,a)
-     if(chisqr/chisqr0.gt.0.9999) exit
-     chisqr0=chisqr
-  enddo
-
-  syncpk=-chisqr
-!  write(*,4001) a,deltaa,-chisq2
-!4001 format(3x,6f10.4,f9.3)
-
-  return
-end subroutine afc9

Deleted: branches/wsprx/lib/analytic.f90
===================================================================
--- branches/wsprx/lib/analytic.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/analytic.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,25 +0,0 @@
-subroutine analytic(d,npts,nfft,s,c)
-
-! Convert real data to analytic signal
-
-  parameter (NFFTMAX=128*1024)
-  real d(npts)
-  real s(npts)
-  complex c(NFFTMAX)
-
-  nh=nfft/2
-  fac=2.0/nfft
-  c(1:npts)=fac*d(1:npts)
-  c(npts+1:nfft)=0.
-  call four2a(c,nfft,1,-1,1)               !Forward c2c FFT
-
-  do i=1,nh
-     s(i)=real(c(i))**2 + aimag(c(i))**2
-  enddo
-
-  c(1)=0.5*c(1)
-  c(nh+2:nfft)=0.
-  call four2a(c,nfft,1,1,1)                !Inverse c2c FFT
-
-  return
-end subroutine analytic

Deleted: branches/wsprx/lib/bpskmetrics.dat
===================================================================
--- branches/wsprx/lib/bpskmetrics.dat	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/bpskmetrics.dat	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,256 +0,0 @@
-  -12.8   1.000  -9.966 1.000000 0.000000
-  -12.7   1.000  -9.966 1.000000 0.000000
-  -12.6   1.000  -9.966 1.000000 0.000000
-  -12.5   1.000  -9.966 1.000000 0.000000
-  -12.4   1.000  -9.966 1.000000 0.000000
-  -12.3   1.000  -9.966 1.000000 0.000000
-  -12.2   1.000  -9.966 1.000000 0.000000
-  -12.1   1.000  -9.966 1.000000 0.000000
-  -12.0   1.000  -9.966 1.000000 0.000000
-  -11.9   1.000  -9.966 1.000000 0.000000
-  -11.8   1.000  -9.966 1.000000 0.000000
-  -11.7   1.000  -9.966 1.000000 0.000000
-  -11.6   1.000  -9.966 1.000000 0.000000
-  -11.5   1.000  -9.966 1.000000 0.000000
-  -11.4   1.000  -9.966 1.000000 0.000000
-  -11.3   1.000  -9.966 1.000000 0.000000
-  -11.2   1.000  -9.966 1.000000 0.000000
-  -11.1   1.000  -9.966 1.000000 0.000000
-  -11.0   1.000  -9.966 1.000000 0.000000
-  -10.9   1.000  -9.966 1.000000 0.000000
-  -10.8   1.000  -9.966 1.000000 0.000000
-  -10.7   1.000  -9.966 1.000000 0.000000
-  -10.6   1.000  -9.966 1.000000 0.000000
-  -10.5   1.000  -9.966 1.000000 0.000000
-  -10.4   1.000  -9.966 1.000000 0.000000
-  -10.3   1.000  -9.966 1.000000 0.000000
-  -10.2   1.000  -9.966 1.000000 0.000000
-  -10.1   1.000  -9.966 1.000000 0.000000
-  -10.0   1.000  -9.966 1.000000 0.000000
-   -9.9   1.000  -9.966 1.000000 0.000000
-   -9.8   1.000  -9.966 1.000000 0.000000
-   -9.7   1.000  -9.966 1.000000 0.000000
-   -9.6   1.000  -9.966 1.000000 0.000000
-   -9.5   1.000  -9.966 1.000000 0.000000
-   -9.4   1.000  -9.966 1.000000 0.000000
-   -9.3   1.000  -9.966 1.000000 0.000000
-   -9.2   1.000  -9.966 1.000000 0.000000
-   -9.1   1.000  -9.966 1.000000 0.000000
-   -9.0   1.000  -9.966 1.000000 0.000000
-   -8.9   1.000  -9.966 1.000000 0.000000
-   -8.8   1.000  -9.966 1.000000 0.000000
-   -8.7   1.000  -9.966 1.000000 0.000000
-   -8.6   1.000  -9.966 1.000000 0.000000
-   -8.5   1.000  -9.966 1.000000 0.000000
-   -8.4   1.000  -9.966 1.000000 0.000000
-   -8.3   1.000  -9.966 1.000000 0.000000
-   -8.2   1.000  -9.966 1.000000 0.000000
-   -8.1   1.000  -9.966 1.000000 0.000000
-   -8.0   1.000  -9.966 1.000000 0.000000
-   -7.9   1.000  -9.966 1.000000 0.000000
-   -7.8   1.000  -9.966 1.000000 0.000000
-   -7.7   1.000  -9.966 1.000000 0.000000
-   -7.6   1.000  -9.966 1.000000 0.000000
-   -7.5   1.000  -9.966 1.000000 0.000000
-   -7.4   1.000  -9.966 1.000000 0.000000
-   -7.3   1.000  -9.966 1.000000 0.000000
-   -7.2   1.000  -9.966 1.000000 0.000000
-   -7.1   1.000  -9.966 1.000000 0.000000
-   -7.0   1.000  -9.966 1.000000 0.000000
-   -6.9   1.000  -9.966 1.000000 0.000000
-   -6.8   1.000  -9.966 1.000000 0.000000
-   -6.7   1.000  -9.966 1.000000 0.000000
-   -6.6   1.000  -9.966 1.000000 0.000000
-   -6.5   1.000  -9.966 1.000000 0.000000
-   -6.4   1.000  -9.966 1.000000 0.000000
-   -6.3   1.000  -9.966 1.000000 0.000000
-   -6.2   1.000  -9.966 1.000000 0.000000
-   -6.1   1.000  -9.966 1.000000 0.000000
-   -6.0   1.000  -9.966 1.000000 0.000000
-   -5.9   1.000  -9.966 1.000000 0.000000
-   -5.8   1.000  -9.966 1.000000 0.000000
-   -5.7   1.000  -9.966 1.000000 0.000000
-   -5.6   1.000  -9.966 1.000000 0.000000
-   -5.5   1.000  -9.966 1.000000 0.000000
-   -5.4   1.000  -9.966 1.000000 0.000000
-   -5.3   1.000  -9.966 1.000000 0.000000
-   -5.2   1.000  -9.966 1.000000 0.000000
-   -5.1   1.000  -9.966 1.000000 0.000000
-   -5.0   1.000  -9.966 1.000000 0.000000
-   -4.9   1.000  -9.966 1.000000 0.000000
-   -4.8   1.000  -9.966 1.000000 0.000000
-   -4.7   1.000  -9.966 1.000000 0.000000
-   -4.6   1.000  -9.966 1.000000 0.000000
-   -4.5   1.000  -9.966 1.000000 0.000000
-   -4.4   1.000  -9.966 1.000000 0.000000
-   -4.3   1.000  -9.966 1.000000 0.000000
-   -4.2   1.000  -9.966 1.000000 0.000000
-   -4.1   1.000  -9.966 1.000000 0.000000
-   -4.0   1.000  -9.966 1.000000 0.000000
-   -3.9   1.000  -9.966 1.000000 0.000000
-   -3.8   1.000  -9.966 1.000000 0.000000
-   -3.7   1.000  -9.966 1.000000 0.000000
-   -3.6   1.000  -9.966 1.000000 0.000000
-   -3.5   1.000  -9.966 1.000000 0.000000
-   -3.4   1.000  -9.966 1.000000 0.000000
-   -3.3   1.000  -9.966 1.000000 0.000000
-   -3.2   1.000  -9.966 1.000000 0.000000
-   -3.1   1.000  -9.966 1.000000 0.000000
-   -3.0   1.000  -9.966 1.000000 0.000000
-   -2.9   1.000  -9.966 1.000000 0.000000
-   -2.8   1.000  -9.966 0.999955 0.000045
-   -2.7   1.000  -9.966 0.999968 0.000032
-   -2.6   1.000  -9.966 0.999909 0.000091
-   -2.5   1.000  -9.966 0.999983 0.000017
-   -2.4   1.000  -9.966 0.999937 0.000063
-   -2.3   1.000  -9.966 0.999914 0.000086
-   -2.2   1.000  -9.966 0.999813 0.000187
-   -2.1   1.000  -9.966 0.999775 0.000225
-   -2.0   1.000  -9.966 0.999671 0.000329
-   -1.9   0.999  -9.966 0.999531 0.000469
-   -1.8   0.999  -9.308 0.999211 0.000789
-   -1.7   0.998  -8.893 0.998948 0.001052
-   -1.6   0.998  -8.191 0.998290 0.001710
-   -1.5   0.996  -7.655 0.997519 0.002481
-   -1.4   0.994  -7.037 0.996192 0.003808
-   -1.3   0.992  -6.513 0.994525 0.005475
-   -1.2   0.988  -5.931 0.991804 0.008196
-   -1.1   0.982  -5.359 0.987816 0.012184
-   -1.0   0.974  -4.789 0.981916 0.018084
-   -0.9   0.961  -4.217 0.973110 0.026890
-   -0.8   0.942  -3.672 0.960785 0.039215
-   -0.7   0.915  -3.123 0.942613 0.057387
-   -0.6   0.874  -2.582 0.916477 0.083523
-   -0.5   0.816  -2.062 0.880296 0.119704
-   -0.4   0.734  -1.573 0.831905 0.168095
-   -0.3   0.619  -1.109 0.768168 0.231832
-   -0.2   0.465  -0.690 0.690103 0.309897
-   -0.1   0.260  -0.317 0.598759 0.401241
-    0.0   0.000   0.000 0.500000 0.500000
-    0.1  -0.317   0.260 0.401241 0.598759
-    0.2  -0.690   0.465 0.309897 0.690103
-    0.3  -1.109   0.619 0.231832 0.768168
-    0.4  -1.573   0.734 0.168095 0.831905
-    0.5  -2.062   0.816 0.119704 0.880296
-    0.6  -2.582   0.874 0.083523 0.916477
-    0.7  -3.123   0.915 0.057387 0.942613
-    0.8  -3.672   0.942 0.039215 0.960785
-    0.9  -4.217   0.961 0.026890 0.973110
-    1.0  -4.789   0.974 0.018084 0.981916
-    1.1  -5.359   0.982 0.012184 0.987816
-    1.2  -5.931   0.988 0.008196 0.991804
-    1.3  -6.513   0.992 0.005475 0.994525
-    1.4  -7.037   0.994 0.003808 0.996192
-    1.5  -7.655   0.996 0.002481 0.997519
-    1.6  -8.191   0.998 0.001710 0.998290
-    1.7  -8.893   0.998 0.001052 0.998948
-    1.8  -9.308   0.999 0.000789 0.999211
-    1.9  -9.966   0.999 0.000469 0.999531
-    2.0  -9.966   1.000 0.000329 0.999671
-    2.1  -9.966   1.000 0.000225 0.999775
-    2.2  -9.966   1.000 0.000187 0.999813
-    2.3  -9.966   1.000 0.000086 0.999914
-    2.4  -9.966   1.000 0.000063 0.999937
-    2.5  -9.966   1.000 0.000017 0.999983
-    2.6  -9.966   1.000 0.000091 0.999909
-    2.7  -9.966   1.000 0.000032 0.999968
-    2.8  -9.966   1.000 0.000045 0.999955
-    2.9  -9.966   1.000 0.000000 1.000000
-    3.0  -9.966   1.000 0.000000 1.000000
-    3.1  -9.966   1.000 0.000000 1.000000
-    3.2  -9.966   1.000 0.000000 1.000000
-    3.3  -9.966   1.000 0.000000 1.000000
-    3.4  -9.966   1.000 0.000000 1.000000
-    3.5  -9.966   1.000 0.000000 1.000000
-    3.6  -9.966   1.000 0.000000 1.000000
-    3.7  -9.966   1.000 0.000000 1.000000
-    3.8  -9.966   1.000 0.000000 1.000000
-    3.9  -9.966   1.000 0.000000 1.000000
-    4.0  -9.966   1.000 0.000000 1.000000
-    4.1  -9.966   1.000 0.000000 1.000000
-    4.2  -9.966   1.000 0.000000 1.000000
-    4.3  -9.966   1.000 0.000000 1.000000
-    4.4  -9.966   1.000 0.000000 1.000000
-    4.5  -9.966   1.000 0.000000 1.000000
-    4.6  -9.966   1.000 0.000000 1.000000
-    4.7  -9.966   1.000 0.000000 1.000000
-    4.8  -9.966   1.000 0.000000 1.000000
-    4.9  -9.966   1.000 0.000000 1.000000
-    5.0  -9.966   1.000 0.000000 1.000000
-    5.1  -9.966   1.000 0.000000 1.000000
-    5.2  -9.966   1.000 0.000000 1.000000
-    5.3  -9.966   1.000 0.000000 1.000000
-    5.4  -9.966   1.000 0.000000 1.000000
-    5.5  -9.966   1.000 0.000000 1.000000
-    5.6  -9.966   1.000 0.000000 1.000000
-    5.7  -9.966   1.000 0.000000 1.000000
-    5.8  -9.966   1.000 0.000000 1.000000
-    5.9  -9.966   1.000 0.000000 1.000000
-    6.0  -9.966   1.000 0.000000 1.000000
-    6.1  -9.966   1.000 0.000000 1.000000
-    6.2  -9.966   1.000 0.000000 1.000000
-    6.3  -9.966   1.000 0.000000 1.000000
-    6.4  -9.966   1.000 0.000000 1.000000
-    6.5  -9.966   1.000 0.000000 1.000000
-    6.6  -9.966   1.000 0.000000 1.000000
-    6.7  -9.966   1.000 0.000000 1.000000
-    6.8  -9.966   1.000 0.000000 1.000000
-    6.9  -9.966   1.000 0.000000 1.000000
-    7.0  -9.966   1.000 0.000000 1.000000
-    7.1  -9.966   1.000 0.000000 1.000000
-    7.2  -9.966   1.000 0.000000 1.000000
-    7.3  -9.966   1.000 0.000000 1.000000
-    7.4  -9.966   1.000 0.000000 1.000000
-    7.5  -9.966   1.000 0.000000 1.000000
-    7.6  -9.966   1.000 0.000000 1.000000
-    7.7  -9.966   1.000 0.000000 1.000000
-    7.8  -9.966   1.000 0.000000 1.000000
-    7.9  -9.966   1.000 0.000000 1.000000
-    8.0  -9.966   1.000 0.000000 1.000000
-    8.1  -9.966   1.000 0.000000 1.000000
-    8.2  -9.966   1.000 0.000000 1.000000
-    8.3  -9.966   1.000 0.000000 1.000000
-    8.4  -9.966   1.000 0.000000 1.000000
-    8.5  -9.966   1.000 0.000000 1.000000
-    8.6  -9.966   1.000 0.000000 1.000000
-    8.7  -9.966   1.000 0.000000 1.000000
-    8.8  -9.966   1.000 0.000000 1.000000
-    8.9  -9.966   1.000 0.000000 1.000000
-    9.0  -9.966   1.000 0.000000 1.000000
-    9.1  -9.966   1.000 0.000000 1.000000
-    9.2  -9.966   1.000 0.000000 1.000000
-    9.3  -9.966   1.000 0.000000 1.000000
-    9.4  -9.966   1.000 0.000000 1.000000
-    9.5  -9.966   1.000 0.000000 1.000000
-    9.6  -9.966   1.000 0.000000 1.000000
-    9.7  -9.966   1.000 0.000000 1.000000
-    9.8  -9.966   1.000 0.000000 1.000000
-    9.9  -9.966   1.000 0.000000 1.000000
-   10.0  -9.966   1.000 0.000000 1.000000
-   10.1  -9.966   1.000 0.000000 1.000000
-   10.2  -9.966   1.000 0.000000 1.000000
-   10.3  -9.966   1.000 0.000000 1.000000
-   10.4  -9.966   1.000 0.000000 1.000000
-   10.5  -9.966   1.000 0.000000 1.000000
-   10.6  -9.966   1.000 0.000000 1.000000
-   10.7  -9.966   1.000 0.000000 1.000000
-   10.8  -9.966   1.000 0.000000 1.000000
-   10.9  -9.966   1.000 0.000000 1.000000
-   11.0  -9.966   1.000 0.000000 1.000000
-   11.1  -9.966   1.000 0.000000 1.000000
-   11.2  -9.966   1.000 0.000000 1.000000
-   11.3  -9.966   1.000 0.000000 1.000000
-   11.4  -9.966   1.000 0.000000 1.000000
-   11.5  -9.966   1.000 0.000000 1.000000
-   11.6  -9.966   1.000 0.000000 1.000000
-   11.7  -9.966   1.000 0.000000 1.000000
-   11.8  -9.966   1.000 0.000000 1.000000
-   11.9  -9.966   1.000 0.000000 1.000000
-   12.0  -9.966   1.000 0.000000 1.000000
-   12.1  -9.966   1.000 0.000000 1.000000
-   12.2  -9.966   1.000 0.000000 1.000000
-   12.3  -9.966   1.000 0.000000 1.000000
-   12.4  -9.966   1.000 0.000000 1.000000
-   12.5  -9.966   1.000 0.000000 1.000000
-   12.6  -9.966   1.000 0.000000 1.000000
-   12.7  -9.966   1.000 0.000000 1.000000

Added: branches/wsprx/lib/ccf2.f
===================================================================
--- branches/wsprx/lib/ccf2.f	                        (rev 0)
+++ branches/wsprx/lib/ccf2.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,47 @@
+      subroutine ccf2(ss,nz,lag1,lag2,ccfbest,lagpk)
+
+      parameter (LAGMAX=200)
+      real ss(nz)
+!      real ccf(-LAGMAX:LAGMAX)
+      real pr(162)
+      logical first
+
+C  The WSPR pseudo-random sync pattern:
+      integer npr(162)
+      data npr/
+     +       1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     +       0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     +       0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     +       1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     +       0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     +       0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     +       0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     +       0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     +       0,0/
+      data first/.true./
+      save
+
+      if(first) then
+         nsym=162
+         do i=1,nsym
+            pr(i)=2*npr(i)-1
+         enddo
+      endif
+
+      ccfbest=0.
+
+      do lag=lag1,lag2
+         x=0.
+         do i=1,nsym
+            j=16*i + lag
+            if(j.ge.1 .and. j.le.nz) x=x+ss(j)*pr(i)
+         enddo
+!         ccf(lag)=x
+         if(x.gt.ccfbest) then
+            ccfbest=x
+            lagpk=lag
+         endif
+      enddo
+
+      return
+      end

Deleted: branches/wsprx/lib/conv232.f90
===================================================================
--- branches/wsprx/lib/conv232.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/conv232.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,38 +0,0 @@
-! Layland-Lushbaugh polynomials for a K=32, r=1/2 convolutional code,
-! and 8-bit parity lookup table.
-
-      data npoly1/-221228207/,npoly2/-463389625/
-      integer*1 partab(0:255)
-      data partab/                &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         0, 1, 1, 0, 1, 0, 0, 1,  &amp;
-         1, 0, 0, 1, 0, 1, 1, 0/

Added: branches/wsprx/lib/cs_stubs.f90
===================================================================
--- branches/wsprx/lib/cs_stubs.f90	                        (rev 0)
+++ branches/wsprx/lib/cs_stubs.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,8 @@
+subroutine cs_lock(csub)
+  character*(*) csub
+  return
+end subroutine cs_lock
+
+subroutine cs_unlock
+  return
+end subroutine cs_unlock

Deleted: branches/wsprx/lib/cutil.c
===================================================================
--- branches/wsprx/lib/cutil.c	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/cutil.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,93 +0,0 @@
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;fcntl.h&gt;
-// #include &lt;sys/times.h&gt;
-// #include &lt;time.h&gt;
-// #include &lt;sys/time.h&gt;
-#include &quot;sleep.h&quot;
-#include &quot;timeval.h&quot;
-
-/*  FORTRAN:  fd = close(filedes)      */
-int close_(int *filedes)
-{
-return(close(*filedes));
-}
-/*  FORTRAN:  fd = open(filnam,mode)  */
-int open_(char filnam[], int *mode)
-{
-  return(open(filnam,*mode));
-}
-/* FORTRAN:  fd = creat(filnam,mode) */
-int creat_(char filnam[],int *mode)
-{
-  return(creat(filnam,*mode));
-}
-/* FORTRAN:  nread = read(fd,buf,n) */
-int read_(int *fd, char buf[], int *n)
-{
-  return(read(*fd,buf,*n));
-}
-/* FORTRAN:  nwrt = write(fd,buf,n) */
-int write_(int *fd, char buf[], int *n)
-{
-  return(write(*fd,buf,*n));
-}
-/* FORTRAN: ns = lseek(fd,offset,origin) */
-int lseek_(int *fd,int *offset, int *origin)
-{
-  return(lseek(*fd,*offset,*origin));
-}
-/* times(2) */
-//int times_(struct tms *buf)
-//{
-//  return (times(buf));
-//}
-/* ioperm(2) */
-//ioperm_(from,num,turn_on)
-//unsigned long *from,*num,*turn_on;
-//{
-//  return (ioperm(*from,*num,*turn_on));
-//   return (i386_get_ioperm(*from,*num,*turn_on));
-//}
-
-/* usleep(3) */
-void usleep_(unsigned long *microsec)
-{
-  usleep(*microsec);
-}
-
-/* returns random numbers between 0 and 32767 to FORTRAN program */
-int iran_(int *arg)
-{
-  return (rand());
-}
-
-int exit_(int *n)
-{
-  printf(&quot;\n\n&quot;);
-  exit(*n);
-}
-
-/*
-struct tm *
-gmtime_r_(const time_t *clock, struct tm *result)
-{
-  gmtime_r(clock, result);
-}
-*/
-
-time_t time_(void)
-{
-     return time(0);
-}
-
-/* hrtime() */
-double hrtime_(void)
-{
-  struct timeval tv;
-  gettimeofday(&amp;tv,NULL);
-  return(tv.tv_sec+1.e-6*tv.tv_usec);
-}

Added: branches/wsprx/lib/decode162.f
===================================================================
--- branches/wsprx/lib/decode162.f	                        (rev 0)
+++ branches/wsprx/lib/decode162.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,137 @@
+      subroutine decode162(c4,npts,message,ncycles,metric,nerr)
+
+C  Decode MEPT_JT data, assuming that DT and DF have already been determined.
+
+      complex c4(npts)
+      character*22 message
+      real*8 dt,df,twopi,f0,f1,dphi0,dphi1
+      complex*16 c0,c1
+      complex*16 w0,w1,ws0,ws1
+      integer*1 symbol(162)
+      integer*1 data1(11)
+      integer amp
+      integer mettab(0:255,0:1)
+      logical first
+      data first/.true./
+      integer npr3(162)
+      data npr3/
+     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     + 0,0/
+      data mettab/
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
+     +   2,   2,   2,   2,   1,   1,   1,   1,   0,   0,
+     +  -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,
+     +  -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,
+     + -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,
+     + -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,
+     + -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,
+     + -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,
+     + -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,
+     + -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,
+     + -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,
+     + -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,
+     + -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,
+     + -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,
+     + -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,
+     + -84, -87, -86, -87, -88, -89, -89, -89, -88, -87,
+     + -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,
+     + -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,
+     + -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,
+     + -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,
+     + -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,
+     + -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,
+     + -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,
+     + -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,
+     + -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,
+     + -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,
+     + -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,
+     + -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,
+     +  -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,
+     +  -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,
+     +   2,   2,   2,   2,   3,   3,   3,   3,   3,   3,
+     +   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5/
+      save
+
+      if(first) then
+         twopi=8*atan(1.d0)
+         dt=1.d0/375.d0                        !Sample interval
+         df=375.d0/256.d0
+         nsym=162
+         nbits=50+31
+         amp=20                                !### 32 ??? ###
+         ndelta=50
+         limit=10000
+         first=.false.
+      endif
+
+C  Should amp be adjusted according to signal strength?
+C  Compute soft symbols
+      k=0
+      nsps=256
+      fac2=0.001
+      w0=1.0
+      w1=1.0
+
+      do j=1,nsym
+         f0=(npr3(j)-1.5)*df
+         f1=(2+npr3(j)-1.5)*df
+         dphi0=twopi*dt*f0
+         dphi1=twopi*dt*f1
+         ws0=dcmplx(cos(dphi0),-sin(dphi0))
+         ws1=dcmplx(cos(dphi1),-sin(dphi1))
+         c0=0.
+         c1=0.
+         do i=1,nsps
+            k=k+1
+            w0=w0*ws0
+            w1=w1*ws1
+            c0=c0 + w0*c4(k)
+            c1=c1 + w1*c4(k)
+         enddo
+
+         sq0=fac2*(real(c0)**2 + aimag(c0)**2)
+         sq1=fac2*(real(c1)**2 + aimag(c1)**2)
+         rsym=amp*(sq1-sq0)
+         r=rsym+128.
+         if(r.gt.255.0) r=255.0
+         if(r.lt.0.0) r=0.0
+         n4=nint(r)
+         if(n4.gt.127) n4=n4-256
+         symbol(j)=n4
+      enddo
+
+      call inter_mept(symbol,-1)                      !Remove interleaving
+      call fano232(symbol,nbits,mettab,ndelta,limit,
+     +     data1,ncycles,metric,nerr)
+      message='                      '
+      if(nerr.ge.0) call wqdecode(data1,message,ntype2)
+
+      return
+      end

Deleted: branches/wsprx/lib/decode9.f90
===================================================================
--- branches/wsprx/lib/decode9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/decode9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,90 +0,0 @@
-subroutine decode9(i1SoftSymbols,limit,nlim,msg)
-
-! Decoder for JT9
-! Input:   i1SoftSymbols(207) - Single-bit soft symbols
-! Output:  msg                - decoded message (blank if erasure)
-
-  character*22 msg
-  integer*4 i4DecodedBytes(9)
-  integer*4 i4Decoded6BitWords(12)
-  integer*1 i1DecodedBytes(13)   !72 bits and zero tail as 8-bit bytes
-  integer*1 i1SoftSymbols(207)
-  integer*1 i1DecodedBits(72)
-
-  real*4 xx0(0:255)
-
-  integer*1 i1
-  logical first
-  integer*4 mettab(0:255,0:1)
-  equivalence (i1,i4)
-  data first/.true./
-  data xx0/                                                      &amp;
-        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
-        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
-        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
-        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
-        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
-        1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000,  &amp;
-        0.988, 1.000, 0.991, 0.993, 1.000, 0.995, 1.000, 0.991,  &amp;
-        1.000, 0.991, 0.992, 0.991, 0.990, 0.990, 0.992, 0.996,  &amp;
-        0.990, 0.994, 0.993, 0.991, 0.992, 0.989, 0.991, 0.987,  &amp;
-        0.985, 0.989, 0.984, 0.983, 0.979, 0.977, 0.971, 0.975,  &amp;
-        0.974, 0.970, 0.970, 0.970, 0.967, 0.962, 0.960, 0.957,  &amp;
-        0.956, 0.953, 0.942, 0.946, 0.937, 0.933, 0.929, 0.920,  &amp;
-        0.917, 0.911, 0.903, 0.895, 0.884, 0.877, 0.869, 0.858,  &amp;
-        0.846, 0.834, 0.821, 0.806, 0.790, 0.775, 0.755, 0.737,  &amp;
-        0.713, 0.691, 0.667, 0.640, 0.612, 0.581, 0.548, 0.510,  &amp;
-        0.472, 0.425, 0.378, 0.328, 0.274, 0.212, 0.146, 0.075,  &amp;
-        0.000,-0.079,-0.163,-0.249,-0.338,-0.425,-0.514,-0.606,  &amp;
-       -0.706,-0.796,-0.895,-0.987,-1.084,-1.181,-1.280,-1.376,  &amp;
-       -1.473,-1.587,-1.678,-1.790,-1.882,-1.992,-2.096,-2.201,  &amp;
-       -2.301,-2.411,-2.531,-2.608,-2.690,-2.829,-2.939,-3.058,  &amp;
-       -3.164,-3.212,-3.377,-3.463,-3.550,-3.768,-3.677,-3.975,  &amp;
-       -4.062,-4.098,-4.186,-4.261,-4.472,-4.621,-4.623,-4.608,  &amp;
-       -4.822,-4.870,-4.652,-4.954,-5.108,-5.377,-5.544,-5.995,  &amp;
-       -5.632,-5.826,-6.304,-6.002,-6.559,-6.369,-6.658,-7.016,  &amp;
-       -6.184,-7.332,-6.534,-6.152,-6.113,-6.288,-6.426,-6.313,  &amp;
-       -9.966,-6.371,-9.966,-7.055,-9.966,-6.629,-6.313,-9.966,  &amp;
-       -5.858,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
-       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
-       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
-       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
-       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,  &amp;
-       -9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966,-9.966/
-  save
-
-  if(first) then
-! Get the metric table
-!     bias=0.37                         !To be optimized, in decoder program
-     bias=0.5
-     scale=10                           !  ... ditto ...
-     do i=0,255
-        mettab(i,0)=nint(scale*(xx0(i)-bias))
-        if(i.ge.1) mettab(256-i,1)=mettab(i,0)
-     enddo
-    close(19)
-     first=.false.
-  endif
-
-  msg='                      '
-  nbits=72
-  ndelta=17
-  call fano232(i1SoftSymbols,nbits+31,mettab,ndelta,limit,i1DecodedBytes,   &amp;
-       ncycles,metric,ierr)
-
-  nlim=ncycles/nbits
-  if(ncycles.lt.(nbits*limit)) then
-     nbytes=(nbits+7)/8
-     do i=1,nbytes
-        n=i1DecodedBytes(i)
-        i4DecodedBytes(i)=iand(n,255)
-     enddo
-     call unpackbits(i4DecodedBytes,nbytes,8,i1DecodedBits)
-     call packbits(i1DecodedBits,12,6,i4Decoded6BitWords)
-     call unpackmsg(i4Decoded6BitWords,msg)                !Unpack decoded msg
-     if(index(msg,'000AAA ').gt.0) msg='                      '
-!     if(index(msg,'15P6715P67WCV').gt.0) msg='                      '
-  endif
-
-  return
-end subroutine decode9

Deleted: branches/wsprx/lib/decode9a.f90
===================================================================
--- branches/wsprx/lib/decode9a.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/decode9a.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,47 +0,0 @@
-subroutine decode9a(c0,npts8,nsps8,fpk,syncpk,snrdb,xdt,freq,drift,   &amp;
-     i1SoftSymbols)
-
-  complex c0(0:npts8-1)
-  complex c2(0:4096-1)
-  complex c3(0:4096-1)
-  complex c5(0:4096-1)
-  complex z
-  real a(3),aa(3)
-  integer*1 i1SoftSymbolsScrambled(207)
-  integer*1 i1SoftSymbols(207)
-  character*22 msg
-  include 'jt9sync.f90'
-
-  nspsd=16
-  ndown=nsps8/nspsd
-
-! Downsample to 16 samples/symbol
-  call downsam9(c0,npts8,nsps8,nspsd,fpk,c2,nz2)
-
-  call peakdt9(c2,nz2,nsps8,nspsd,c3,nz3,xdt)
-
-  fsample=1500.0/ndown
-  a=0.
-  call afc9(c3,nz3,fsample,a,syncpk)
-
-  call twkfreq(c3,c5,nz3,fsample,a)
-
-  call symspec2(c5,nz3,nsps8,nspsd,fsample,snrdb,i1SoftSymbolsScrambled)
-
-  call interleave9(i1SoftSymbolsScrambled,-1,i1SoftSymbols)
-!  limit=10000
-!  call decode9(i1SoftSymbols,limit,nlim,msg)
-
-!###
-!  do j=1,85
-!     write(71,2101) j,nint(1.e-3*ss2(0:8,j))
-!2101 format(i2,2x,9i6)
-!  enddo
-  
-  freq=fpk - a(1)
-  drift=-2.0*a(2)
-!  write(*,1100) nutc,nsync,nsnr,xdt,freq,a(2),msg
-!1100 format(i4.4,i5,i5,f6.1,f9.2,f8.2,2x,a22)
-
-  return
-end subroutine decode9a

Deleted: branches/wsprx/lib/decode_rs.c
===================================================================
--- branches/wsprx/lib/decode_rs.c	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/decode_rs.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,263 +0,0 @@
-/* Reed-Solomon decoder
- * Copyright 2002 Phil Karn, KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-
-#ifdef DEBUG
-#include &lt;stdio.h&gt;
-#endif
-
-#include &lt;string.h&gt;
-
-#define NULL ((void *)0)
-#define	min(a,b)	((a) &lt; (b) ? (a) : (b))
-
-#ifdef FIXED
-#include &quot;fixed.h&quot;
-#elif defined(BIGSYM)
-#include &quot;int.h&quot;
-#else
-#include &quot;char.h&quot;
-#endif
-
-int DECODE_RS(
-#ifdef FIXED
-DTYPE *data, int *eras_pos, int no_eras,int pad){
-#else
-void *p,DTYPE *data, int *eras_pos, int no_eras){
-  struct rs *rs = (struct rs *)p;
-#endif
-  int deg_lambda, el, deg_omega;
-  int i, j, r,k;
-  DTYPE u,q,tmp,num1,num2,den,discr_r;
-  DTYPE lambda[NROOTS+1], s[NROOTS];	/* Err+Eras Locator poly
-					 * and syndrome poly */
-  DTYPE b[NROOTS+1], t[NROOTS+1], omega[NROOTS+1];
-  DTYPE root[NROOTS], reg[NROOTS+1], loc[NROOTS];
-  int syn_error, count;
-
-#ifdef FIXED
-  /* Check pad parameter for validity */
-  if(pad &lt; 0 || pad &gt;= NN)
-    return -1;
-#endif
-
-  /* form the syndromes; i.e., evaluate data(x) at roots of g(x) */
-  for(i=0;i&lt;NROOTS;i++)
-    s[i] = data[0];
-
-  for(j=1;j&lt;NN-PAD;j++){
-    for(i=0;i&lt;NROOTS;i++){
-      if(s[i] == 0){
-	s[i] = data[j];
-      } else {
-	s[i] = data[j] ^ ALPHA_TO[MODNN(INDEX_OF[s[i]] + (FCR+i)*PRIM)];
-      }
-    }
-  }
-
-  /* Convert syndromes to index form, checking for nonzero condition */
-  syn_error = 0;
-  for(i=0;i&lt;NROOTS;i++){
-    syn_error |= s[i];
-    s[i] = INDEX_OF[s[i]];
-  }
-
-  if (!syn_error) {
-    /* if syndrome is zero, data[] is a codeword and there are no
-     * errors to correct. So return data[] unmodified
-     */
-    count = 0;
-    goto finish;
-  }
-  memset(&amp;lambda[1],0,NROOTS*sizeof(lambda[0]));
-  lambda[0] = 1;
-
-  if (no_eras &gt; 0) {
-    /* Init lambda to be the erasure locator polynomial */
-    lambda[1] = ALPHA_TO[MODNN(PRIM*(NN-1-eras_pos[0]))];
-    for (i = 1; i &lt; no_eras; i++) {
-      u = MODNN(PRIM*(NN-1-eras_pos[i]));
-      for (j = i+1; j &gt; 0; j--) {
-	tmp = INDEX_OF[lambda[j - 1]];
-	if(tmp != A0)
-	  lambda[j] ^= ALPHA_TO[MODNN(u + tmp)];
-      }
-    }
-
-#if DEBUG &gt;= 1
-    /* Test code that verifies the erasure locator polynomial just constructed
-       Needed only for decoder debugging. */
-    
-    /* find roots of the erasure location polynomial */
-    for(i=1;i&lt;=no_eras;i++)
-      reg[i] = INDEX_OF[lambda[i]];
-
-    count = 0;
-    for (i = 1,k=IPRIM-1; i &lt;= NN; i++,k = MODNN(k+IPRIM)) {
-      q = 1;
-      for (j = 1; j &lt;= no_eras; j++)
-	if (reg[j] != A0) {
-	  reg[j] = MODNN(reg[j] + j);
-	  q ^= ALPHA_TO[reg[j]];
-	}
-      if (q != 0)
-	continue;
-      /* store root and error location number indices */
-      root[count] = i;
-      loc[count] = k;
-      count++;
-    }
-    if (count != no_eras) {
-      printf(&quot;count = %d no_eras = %d\n lambda(x) is WRONG\n&quot;,count,no_eras);
-      count = -1;
-      goto finish;
-    }
-#if DEBUG &gt;= 2
-    printf(&quot;\n Erasure positions as determined by roots of Eras Loc Poly:\n&quot;);
-    for (i = 0; i &lt; count; i++)
-      printf(&quot;%d &quot;, loc[i]);
-    printf(&quot;\n&quot;);
-#endif
-#endif
-  }
-  for(i=0;i&lt;NROOTS+1;i++)
-    //    printf(&quot;%d  %d  %d\n&quot;,i,lambda[i],INDEX_OF[lambda[i]]);
-    b[i] = INDEX_OF[lambda[i]];
-  
-  /*
-   * Begin Berlekamp-Massey algorithm to determine error+erasure
-   * locator polynomial
-   */
-  r = no_eras;
-  el = no_eras;
-  while (++r &lt;= NROOTS) {	/* r is the step number */
-    /* Compute discrepancy at the r-th step in poly-form */
-    discr_r = 0;
-    for (i = 0; i &lt; r; i++){
-      if ((lambda[i] != 0) &amp;&amp; (s[r-i-1] != A0)) {
-	discr_r ^= ALPHA_TO[MODNN(INDEX_OF[lambda[i]] + s[r-i-1])];
-      }
-    }
-    discr_r = INDEX_OF[discr_r];	/* Index form */
-    if (discr_r == A0) {
-      /* 2 lines below: B(x) &lt;-- x*B(x) */
-      memmove(&amp;b[1],b,NROOTS*sizeof(b[0]));
-      b[0] = A0;
-    } else {
-      /* 7 lines below: T(x) &lt;-- lambda(x) - discr_r*x*b(x) */
-      t[0] = lambda[0];
-      for (i = 0 ; i &lt; NROOTS; i++) {
-	if(b[i] != A0)
-	  t[i+1] = lambda[i+1] ^ ALPHA_TO[MODNN(discr_r + b[i])];
-	else
-	  t[i+1] = lambda[i+1];
-      }
-      if (2 * el &lt;= r + no_eras - 1) {
-	el = r + no_eras - el;
-	/*
-	 * 2 lines below: B(x) &lt;-- inv(discr_r) *
-	 * lambda(x)
-	 */
-	for (i = 0; i &lt;= NROOTS; i++)
-	  b[i] = (lambda[i] == 0) ? A0 : MODNN(INDEX_OF[lambda[i]] - discr_r + NN);
-      } else {
-	/* 2 lines below: B(x) &lt;-- x*B(x) */
-	memmove(&amp;b[1],b,NROOTS*sizeof(b[0]));
-	b[0] = A0;
-      }
-      memcpy(lambda,t,(NROOTS+1)*sizeof(t[0]));
-    }
-  }
-
-  /* Convert lambda to index form and compute deg(lambda(x)) */
-  deg_lambda = 0;
-  for(i=0;i&lt;NROOTS+1;i++){
-    lambda[i] = INDEX_OF[lambda[i]];
-    if(lambda[i] != A0)
-      deg_lambda = i;
-  }
-  /* Find roots of the error+erasure locator polynomial by Chien search */
-  memcpy(&amp;reg[1],&amp;lambda[1],NROOTS*sizeof(reg[0]));
-  count = 0;		/* Number of roots of lambda(x) */
-  for (i = 1,k=IPRIM-1; i &lt;= NN; i++,k = MODNN(k+IPRIM)) {
-    q = 1; /* lambda[0] is always 0 */
-    for (j = deg_lambda; j &gt; 0; j--){
-      if (reg[j] != A0) {
-	reg[j] = MODNN(reg[j] + j);
-	q ^= ALPHA_TO[reg[j]];
-      }
-    }
-    if (q != 0)
-      continue; /* Not a root */
-    /* store root (index-form) and error location number */
-#if DEBUG&gt;=2
-    printf(&quot;count %d root %d loc %d\n&quot;,count,i,k);
-#endif
-    root[count] = i;
-    loc[count] = k;
-    /* If we've already found max possible roots,
-     * abort the search to save time
-     */
-    if(++count == deg_lambda)
-      break;
-  }
-  if (deg_lambda != count) {
-    /*
-     * deg(lambda) unequal to number of roots =&gt; uncorrectable
-     * error detected
-     */
-    count = -1;
-    goto finish;
-  }
-  /*
-   * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo
-   * x**NROOTS). in index form. Also find deg(omega).
-   */
-  deg_omega = deg_lambda-1;
-  for (i = 0; i &lt;= deg_omega;i++){
-    tmp = 0;
-    for(j=i;j &gt;= 0; j--){
-      if ((s[i - j] != A0) &amp;&amp; (lambda[j] != A0))
-	tmp ^= ALPHA_TO[MODNN(s[i - j] + lambda[j])];
-    }
-    omega[i] = INDEX_OF[tmp];
-  }
-
-  /*
-   * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =
-   * inv(X(l))**(FCR-1) and den = lambda_pr(inv(X(l))) all in poly-form
-   */
-  for (j = count-1; j &gt;=0; j--) {
-    num1 = 0;
-    for (i = deg_omega; i &gt;= 0; i--) {
-      if (omega[i] != A0)
-	num1  ^= ALPHA_TO[MODNN(omega[i] + i * root[j])];
-    }
-    num2 = ALPHA_TO[MODNN(root[j] * (FCR - 1) + NN)];
-    den = 0;
-    
-    /* lambda[i+1] for i even is the formal derivative lambda_pr of lambda[i] */
-    for (i = min(deg_lambda,NROOTS-1) &amp; ~1; i &gt;= 0; i -=2) {
-      if(lambda[i+1] != A0)
-	den ^= ALPHA_TO[MODNN(lambda[i+1] + i * root[j])];
-    }
-#if DEBUG &gt;= 1
-    if (den == 0) {
-      printf(&quot;\n ERROR: denominator = 0\n&quot;);
-      count = -1;
-      goto finish;
-    }
-#endif
-    /* Apply error to data */
-    if (num1 != 0 &amp;&amp; loc[j] &gt;= PAD) {
-      data[loc[j]-PAD] ^= ALPHA_TO[MODNN(INDEX_OF[num1] + INDEX_OF[num2] + NN - INDEX_OF[den])];
-    }
-  }
- finish:
-  if(eras_pos != NULL){
-    for(i=0;i&lt;count;i++)
-      eras_pos[i] = loc[i];
-  }
-  return count;
-}

Deleted: branches/wsprx/lib/decoder.f90
===================================================================
--- branches/wsprx/lib/decoder.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/decoder.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,141 +0,0 @@
-subroutine decoder(ss,c0)
-
-! Decoder for JT9.
-
-  parameter (NMAX=1800*12000)        !Total sample intervals per 30 minutes
-  parameter (NDMAX=1800*1500)        !Sample intervals at 1500 Hz rate
-  parameter (NSMAX=22000)            !Max length of saved spectra
-  real ss(184,NSMAX)
-  character*22 msg
-  character*33 line
-  character*80 fmt,fmt14
-  character*20 datetime
-  real*4 ccfred(NSMAX)
-  integer*1 i1SoftSymbols(207)
-  integer*2 id2
-  integer ii(1)
-  complex c0(NDMAX)
-  complex c1(NDMAX)
-  common/npar/nutc,ndiskdat,ntrperiod,nfqso,newdat,npts8,nfa,nfb,ntol,  &amp;
-       kin,nzhsym,nsave,nagain,ndepth,nrxlog,nfsample,datetime
-  common/tracer/limtrace,lu
-  save
-
-  call timer('decoder ',0)
-
-  ntrMinutes=ntrperiod/60
-  newdat=1
-  nsynced=0
-  ndecoded=0
-  limit=200
-  if(ndepth.ge.2) limit=2000
-  if(ndepth.ge.3) limit=20000
-
-  nsps=0
-  if(ntrMinutes.eq.1) then
-     nsps=6912
-     df3=1500.0/2048.0
-     fmt='(i4.4,i4,i5,f6.1,f8.0,i4,3x,a22)'
-     fmt14='(i4.4,i4,i5,f6.1,f8.0,i4,3x,a22,i8,i3)'
-  else if(ntrMinutes.eq.2) then
-     nsps=15360
-     df3=1500.0/2048.0
-     fmt='(i4.4,i4,i5,f6.1,f8.1,i4,3x,a22)'
-     fmt14='(i4.4,i4,i5,f6.1,f8.1,i4,3x,a22,i8,i3)'
-  else if(ntrMinutes.eq.5) then
-     nsps=40960
-     df3=1500.0/6144.0
-     fmt='(i4.4,i4,i5,f6.1,f8.1,i4,3x,a22)' 
-     fmt14='(i4.4,i4,i5,f6.1,f8.1,i4,3x,a22,i8,i3)'
- else if(ntrMinutes.eq.10) then
-     nsps=82944
-     df3=1500.0/12288.0
-     fmt='(i4.4,i4,i5,f6.1,f8.2,i4,3x,a22)'
-     fmt14='(i4.4,i4,i5,f6.1,f8.2,i4,3x,a22,i8,i3)'
-  else if(ntrMinutes.eq.30) then
-     nsps=252000
-     df3=1500.0/32768.0
-     fmt='(i4.4,i4,i5,f6.1,f8.2,i4,3x,a22)'
-     fmt14='(i4.4,i4,i5,f6.1,f8.2,i4,3x,a22,i8,i3)'
-  endif
-  if(nsps.eq.0) stop 'Error: bad TRperiod'    !Better: return an error code###
-
-  kstep=nsps/2
-  tstep=kstep/12000.0
-
-  call timer('sync9   ',0)
-  call sync9(ss,nzhsym,tstep,df3,ntol,nfqso,ccfred,ia,ib,ipk)  !Compute ccfred
-  call timer('sync9   ',1)
-
-!  open(13,file='decoded.txt',status='unknown')
-!  rewind 13
-  if(iand(nRxLog,2).ne.0) rewind 14
-  if(iand(nRxLog,1).ne.0) then
-! Write date and time to lu 14     
-  endif
-
-  nRxLog=0
-  fgood=0.
-  nsps8=nsps/8
-  df8=1500.0/nsps8
-  sbest=-1.0
-  dblim=db(864.0/nsps8) - 26.2
-
-10 ii=maxloc(ccfred(ia:ib))
-  i=ii(1) + ia - 1
-  f=(i-1)*df3
-  if((i.eq.ipk .or. ccfred(i).ge.3.0) .and. abs(f-fgood).gt.10.0*df8) then
-
-     call timer('decode9a',0)
-     fpk=1000.0 + df3*(i-1)
-     c1(1:npts8)=conjg(c0(1:npts8))
-     call decode9a(c1,npts8,nsps8,fpk,syncpk,snrdb,xdt,freq,drift,i1SoftSymbols)
-     call timer('decode9a',1)
-
-     call timer('decode9 ',0)
-     call decode9(i1SoftSymbols,limit,nlim,msg)
-     call timer('decode9 ',1)
- 
-     sync=(syncpk-1.0)/2.0
-     if(sync.lt.0.0 .or. snrdb.lt.dblim-2.0) sync=0.0
-     nsync=sync
-     if(nsync.gt.10) nsync=10
-     nsnr=nint(snrdb)
-     ndrift=nint(drift/df3)
-     
-     if(sync.gt.sbest .and. fgood.eq.0.0) then
-        sbest=sync
-        write(line,fmt) nutc,nsync,nsnr,xdt,freq,ndrift
-        if(nsync.gt.0) nsynced=1
-     endif
-
-     if(msg.ne.'                      ') then
-        write(*,fmt) nutc,nsync,nsnr,xdt,freq,ndrift,msg
-        write(14,fmt14) nutc,nsync,nsnr,xdt,freq,ndrift,msg,nlim,ntrMinutes
-        fgood=f
-        nsynced=1
-        ndecoded=1
-        ccfred(max(ia,i-3):min(ib,i+11))=0.
-     endif
-  endif
-  ccfred(i)=0.
-  if(maxval(ccfred(ia:ib)).gt.3.0) go to 10
-
-  if(fgood.eq.0.0) then
-     write(*,1020) line
-     write(14,1020) line
-1020 format(a33)
-  endif
-
-  write(*,1010) nsynced,ndecoded
-1010 format('&lt;DecodeFinished&gt;',2i4)
-  flush(6)
-
-  call flush(6)
-  call flush(14)
-
-  call timer('decoder ',1)
-  if(nstandalone.eq.0) call timer('decoder ',101)
-
-  return
-end subroutine decoder

Deleted: branches/wsprx/lib/downsam9.f90
===================================================================
--- branches/wsprx/lib/downsam9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/downsam9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,53 +0,0 @@
-subroutine downsam9(c0,npts8,nsps8,nspsd,fpk,c2,nz2)     
-
-!Downsample to nspsd samples per symbol, info centered at fpk
-
-  parameter (NMAX=128*31500)
-  complex c0(0:npts8-1)
-  complex c1(0:NMAX-1)
-  complex c2(0:4096-1)
-  real s(1000)
-
-  fac=1.e-4
-  c1(0:npts8-1)=fac*c0                     !Copy c0 into c1
-  do i=1,npts8-1,2
-     c1(i)=-c1(i)
-  enddo
-  c1(npts8:)=0.                            !Zero the rest of c1
-  nfft1=128*nsps8                          !Forward FFT length
-  nh1=nfft1/2
-  df1=1500.0/nfft1
-  call four2a(c1,nfft1,1,-1,1)             !Forward FFT
-
-  ia=nint(250.0/df1)
-  nadd=1.0/df1
-  j=250/df1
-  s=0.
-  do i=1,1000
-     do n=1,nadd
-        j=j+1
-        s(i)=s(i)+real(c1(j))**2 + aimag(c1(j))**2
-     enddo
-  enddo
-  call pctile(s,1000,40,avenoise)
-  
-  ndown=nsps8/16                           !Downsample factor
-  nfft2=nfft1/ndown                        !Backward FFT length
-  nh2=nfft2/2
-   
-  fshift=fpk-1500.0
-  i0=nh1 + fshift/df1
-  fac=sqrt(1.0/avenoise)
-  do i=0,nfft2-1
-     j=i0+i
-     if(i.gt.nh2) j=j-nfft2
-     c2(i)=fac*c1(j)
-  enddo
-
-  call four2a(c2,nfft2,1,1,1)              !Backward FFT
-
-  nspsd=nsps8/ndown
-  nz2=npts8/ndown
-
-  return
-end subroutine downsam9

Deleted: branches/wsprx/lib/encode_rs.c
===================================================================
--- branches/wsprx/lib/encode_rs.c	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/encode_rs.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,52 +0,0 @@
-/* Reed-Solomon encoder
- * Copyright 2002, Phil Karn, KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-#include &lt;string.h&gt;
-
-#ifdef FIXED
-#include &quot;fixed.h&quot;
-#elif defined(BIGSYM)
-#include &quot;int.h&quot;
-#else
-#include &quot;char.h&quot;
-#endif
-
-void ENCODE_RS(
-#ifdef FIXED
-DTYPE *data, DTYPE *bb,int pad){
-#else
-void *p,DTYPE *data, DTYPE *bb){
-  struct rs *rs = (struct rs *)p;
-#endif
-  int i, j;
-  DTYPE feedback;
-
-#ifdef FIXED
-  /* Check pad parameter for validity */
-  if(pad &lt; 0 || pad &gt;= NN)
-    return;
-#endif
-
-  memset(bb,0,NROOTS*sizeof(DTYPE));
-
-  for(i=0;i&lt;NN-NROOTS-PAD;i++){
-    feedback = INDEX_OF[data[i] ^ bb[0]];
-    if(feedback != A0){      /* feedback term is non-zero */
-#ifdef UNNORMALIZED
-      /* This line is unnecessary when GENPOLY[NROOTS] is unity, as it must
-       * always be for the polynomials constructed by init_rs()
-       */
-      feedback = MODNN(NN - GENPOLY[NROOTS] + feedback);
-#endif
-      for(j=1;j&lt;NROOTS;j++)
-	bb[j] ^= ALPHA_TO[MODNN(feedback + GENPOLY[NROOTS-j])];
-    }
-    /* Shift */
-    memmove(&amp;bb[0],&amp;bb[1],sizeof(DTYPE)*(NROOTS-1));
-    if(feedback != A0)
-      bb[NROOTS-1] = ALPHA_TO[MODNN(feedback + GENPOLY[0])];
-    else
-      bb[NROOTS-1] = 0;
-  }
-}

Deleted: branches/wsprx/lib/entail.f90
===================================================================
--- branches/wsprx/lib/entail.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/entail.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,30 +0,0 @@
-subroutine entail(dgen,data0)
-
-! Move 72-bit packed data from 6-bit to 8-bit symbols and add a zero tail.
-  integer dgen(13)
-  integer*1 data0(13)
-
-  i4=0
-  k=0
-  m=0
-  do i=1,12
-     n=dgen(i)
-     do j=1,6
-        k=k+1
-        i4=i4+i4+iand(1,ishft(n,j-6))
-        i4=iand(i4,255)
-        if(k.eq.8) then
-           m=m+1
-           if(i4.gt.127) i4=i4-256
-           data0(m)=i4
-           k=0
-        endif
-     enddo
-  enddo
-  do m=10,13
-     data0(m)=0
-  enddo
-
-  return
-end subroutine entail
-

Deleted: branches/wsprx/lib/f77_wisdom.f
===================================================================
--- branches/wsprx/lib/f77_wisdom.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/f77_wisdom.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,45 +0,0 @@
-      subroutine write_char(c, iunit)
-      character c
-      integer iunit
-      write(iunit,1000) c
- 1000 format(a,$)
-      end      
-
-      subroutine export_wisdom_to_file(iunit)
-      integer iunit
-      external write_char
-c      call dfftw_export_wisdom(write_char, iunit)
-      call sfftw_export_wisdom(write_char, iunit)
-      end
-
-      subroutine read_char(ic, iunit)
-      integer ic
-      integer iunit
-      character*256 buf
-      save buf
-      integer ibuf
-      data ibuf/257/
-      save ibuf
-      if (ibuf .lt. 257) then
-         ic = ichar(buf(ibuf:ibuf))
-         ibuf = ibuf + 1
-         return
-      endif
-      read(iunit,1000,end=10) buf
- 1000 format(a256)
-      ic = ichar(buf(1:1))
-      ibuf = 2
-      return
- 10   ic = -1
-      ibuf = 257
-      rewind iunit
-      return
-      end
-      
-      subroutine import_wisdom_from_file(isuccess, iunit)
-      integer isuccess
-      integer iunit
-      external read_char
-c      call dfftw_import_wisdom(isuccess, read_char, iunit)
-      call sfftw_import_wisdom(isuccess, read_char, iunit)
-      end

Added: branches/wsprx/lib/fchisq.f
===================================================================
--- branches/wsprx/lib/fchisq.f	                        (rev 0)
+++ branches/wsprx/lib/fchisq.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,99 @@
+      real function fchisq(cx,npts,fsample,a,lag1,lag2,ccfmax,dtmax)
+
+      parameter (NMAX=120*375)
+      complex cx(npts)
+      real a(5)
+      complex*16 w1,ws1
+      complex*16 w2,ws2
+      complex*16 w3,ws3
+      complex*16 w4,ws4
+      complex*16 cs1(0:NMAX)
+      complex*16 cs2(0:NMAX)
+      complex*16 cs3(0:NMAX)
+      complex*16 cs4(0:NMAX)
+      complex z1,z2,z3,z4
+      real*8 twopi,baud,p2
+!      real ss(2812)
+      real ss(5624)
+      save
+
+      twopi=8.d0*atan(1.d0)
+      baud=12000.d0/8192
+
+C  Mix and integrate four channels
+      cs1(0)=0.
+      cs2(0)=0.
+      cs3(0)=0.
+      cs4(0)=0.
+      w1=1.0
+      w2=1.0
+      w3=1.0
+      w4=1.0
+      x0=0.5*(npts+1)           !Middle sample
+      s=2.0/npts
+      dt=1.0/fsample
+      do i=1,npts
+         x=s*(i-x0)             !x runs from -1 to +1
+         if(mod(i,100).eq.1) then
+            p2=1.5*x*x - 0.5
+!           p3=2.5*(x**3) - 1.5*x
+!           p4=4.375*(x**4) - 3.75*(x**2) + 0.375
+            dphi1=twopi*dt*(a(1) + x*a(2) + p2*a(3) + 1.5*baud)
+            dphi2=twopi*dt*(a(1) + x*a(2) + p2*a(3) + 0.5*baud)
+            dphi3=twopi*dt*(a(1) + x*a(2) + p2*a(3) - 0.5*baud)
+            dphi4=twopi*dt*(a(1) + x*a(2) + p2*a(3) - 1.5*baud)
+            ws1=cmplx(cos(dphi1),sin(dphi1))
+            ws2=cmplx(cos(dphi2),sin(dphi2))
+            ws3=cmplx(cos(dphi3),sin(dphi3))
+            ws4=cmplx(cos(dphi4),sin(dphi4))
+         endif
+         w1=w1*ws1
+         w2=w2*ws2
+         w3=w3*ws3
+         w4=w4*ws4
+         cs1(i)=cs1(i-1) + w1*cx(i)
+         cs2(i)=cs2(i-1) + w2*cx(i)
+         cs3(i)=cs3(i-1) + w3*cx(i)
+         cs4(i)=cs4(i-1) + w4*cx(i)
+      enddo
+
+C  Compute full-symbol powers at 1/16-symbol steps.
+      nsps=nint(fsample/baud)                  !Samples per symbol
+      ndiv=16                                  !Steps per symbol
+      nout=ndiv*npts/nsps                      !Total steps
+      dtstep=1.0/(ndiv*baud)                   !Time per output step
+      fac=1.e-5
+
+      ss=0.
+      do i=1,nout
+         j=i*nsps/ndiv
+         k=j - nsps
+         ss(i)=0.
+         if(k.ge.1) then
+            z1=cs1(j)-cs1(k)
+            z2=cs2(j)-cs2(k)
+            z3=cs3(j)-cs3(k)
+            z4=cs4(j)-cs4(k)
+
+            p1=real(z1)**2 + aimag(z1)**2
+            p2=real(z2)**2 + aimag(z2)**2
+            p3=real(z3)**2 + aimag(z3)**2
+            p4=real(z4)**2 + aimag(z4)**2
+
+!            ss(i)=fac*(max(p2,p4) - max(p1,p3))
+            ss(i)=fac*((p2+p4) - (p1+p3))
+         endif
+      enddo
+
+      ccfmax=0.
+      call ccf2(ss,nout,lag1,lag2,ccf,lagpk)
+      if(ccf.gt.ccfmax) then
+         ccfmax=ccf
+         dtmax=lagpk*dtstep
+      endif
+
+! Reverse sign (and offset!) because we will be minimizing fchisq
+      fchisq=-ccfmax + 100.0
+
+      return
+      end

Deleted: branches/wsprx/lib/fchisq.f90
===================================================================
--- branches/wsprx/lib/fchisq.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/fchisq.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,42 +0,0 @@
-real function fchisq(c3,npts,fsample,a)
-
-  parameter (NMAX=85*16)
-  complex c3(npts)
-  complex c4(NMAX)
-  real a(3)
-  complex z
-  complex w,wstep
-  data a1,a2,a3/99.,99.,99./
-  include 'jt9sync.f90'
-  save
-
-  if(a(1).ne.a1 .or. a(2).ne.a2 .or. a(3).ne.a3) then
-     a1=a(1)
-     a2=a(2)
-     a3=a(3)
-     call twkfreq(c3,c4,npts,fsample,a)
-  endif
-
-! Get sync power.
-  nspsd=16
-  sum1=0.
-  sum0=0.
-  k=-1
-  do i=1,85
-     z=0.
-     do j=1,nspsd
-        k=k+1
-        z=z+c4(k+1)
-     enddo
-     pp=real(z)**2 + aimag(z)**2     
-     if(isync(i).eq.1) then
-        sum1=sum1+pp
-     else
-        sum0=sum0+pp
-     endif
-  enddo
-  sync=(sum1/16.0)/(sum0/69.0) - 1.0
-  fchisq=-sync
-
-  return
-end function fchisq

Deleted: branches/wsprx/lib/fil61.f90
===================================================================
--- branches/wsprx/lib/fil61.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/fil61.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,64 +0,0 @@
-12000 61 250 750 0.2 50, mix at 1500
-
-
--0.000000000000  0.001944450121
--0.000668730681  0.000668730681
--0.000974850191 -0.000000000000
--0.000581679123 -0.000581679123
- 0.000000000000 -0.000439648787
--0.000148911451  0.000148911451
--0.001140891736 -0.000000000000
--0.001653102965 -0.001653102965
- 0.000000000000 -0.003749915818
- 0.003740834397 -0.003740834397
- 0.006834087490  0.000000000000
- 0.005812808655  0.005812808655
--0.000000000000  0.009262713933
--0.006900370427  0.006900370427
--0.009503248519 -0.000000000000
--0.005874581677 -0.005874581677
- 0.000000000000 -0.006017530719
- 0.001785268072 -0.001785268072
--0.002214736448 -0.000000000000
--0.005777038427 -0.005777038427
- 0.000000000000 -0.015228682747
- 0.016402831440 -0.016402831440
- 0.031806920774  0.000000000000
- 0.028800401613  0.028800401613
--0.000000000000  0.049589395998
--0.041000303659  0.041000303659
--0.065514139214 -0.000000000000
--0.050781544715 -0.050781544715
- 0.000000000000 -0.076562341482
- 0.056225821996 -0.056225821996
- 0.080516569816  0.000000000000
- 0.056225821996  0.056225821996
--0.000000000000  0.076562341482
--0.050781544715  0.050781544715
--0.065514139214 -0.000000000000
--0.041000303659 -0.041000303659
- 0.000000000000 -0.049589395998
- 0.028800401613 -0.028800401613
- 0.031806920774  0.000000000000
- 0.016402831440  0.016402831440
--0.000000000000  0.015228682747
--0.005777038427  0.005777038427
--0.002214736448 -0.000000000000
- 0.001785268072  0.001785268072
--0.000000000000  0.006017530719
--0.005874581677  0.005874581677
--0.009503248519 -0.000000000000
--0.006900370427 -0.006900370427
- 0.000000000000 -0.009262713933
- 0.005812808655 -0.005812808655
- 0.006834087490  0.000000000000
- 0.003740834397  0.003740834397
--0.000000000000  0.003749915818
--0.001653102965  0.001653102965
--0.001140891736 -0.000000000000
--0.000148911451 -0.000148911451
--0.000000000000  0.000439648787
--0.000581679123  0.000581679123
--0.000974850191 -0.000000000000
--0.000668730681 -0.000668730681
- 0.000000000000 -0.001944450121

Added: branches/wsprx/lib/flat3.f
===================================================================
--- branches/wsprx/lib/flat3.f	                        (rev 0)
+++ branches/wsprx/lib/flat3.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,27 @@
+      subroutine flat3(ss0,n,nsum)
+
+      parameter (NZ=256)
+      real ss0(NZ)
+      real ss(NZ)
+      real ref(NZ)
+      real tmp(NZ)
+
+      call move(ss0,ss(129),128)
+      call move(ss0(129),ss,128)
+
+      nsmo=20
+      base=50*(float(nsum)**1.5)
+      ia=nsmo+1
+      ib=n-nsmo-1
+      do i=ia,ib
+         call pctile(ss(i-nsmo),tmp,2*nsmo+1,35,ref(i))
+      enddo
+      do i=ia,ib
+         ss(i)=base*ss(i)/ref(i)
+      enddo
+
+      call move(ss(129),ss0,128)
+      call move(ss,ss0(129),128)
+
+      return
+      end

Deleted: branches/wsprx/lib/genjt9.f90
===================================================================
--- branches/wsprx/lib/genjt9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/genjt9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,58 +0,0 @@
-subroutine genjt9(msg0,ichk,msgsent,i4tone,itext)
-
-! Encodes a JT9 message and returns msgsent, the message as it will
-! be decoded, and an integer array i4tone(85) of 9-FSK tone values 
-! in the range 0-8.  
-
-  character*22 msg0
-  character*22 message                    !Message to be generated
-  character*22 msgsent                    !Message as it will be received
-  integer*4 i4Msg6BitWords(13)            !72-bit message as 6-bit words
-  integer*1 i1Msg8BitBytes(13)            !72 bits and zero tail as 8-bit bytes
-  integer*1 i1EncodedBits(207)            !Encoded information-carrying bits
-  integer*1 i1ScrambledBits(207)          !Encoded bits after interleaving
-  integer*4 i4DataSymbols(69)             !Data symbols (values 0-7)
-  integer*4 i4GrayCodedSymbols(69)        !Gray-coded symbols (values 0-7)
-  integer*4 i4tone(85)                    !Tone #s, data and sync (values 0-8)
-  logical text
-  include 'jt9sync.f90'
-  save
-
-  message=msg0
-  do i=1,22
-     if(ichar(message(i:i)).eq.0) then
-        message(i:)='                      '
-        exit
-     endif
-  enddo
-
-  do i=1,22                               !Omit leading blanks
-     if(message(1:1).ne.' ') exit
-     message=message(i+1:)
-  enddo
-
-  call packmsg(message,i4Msg6BitWords,text)   !Pack message into 12 6-bit bytes
-  itext=0
-  if(text) itext=1
-  call unpackmsg(i4Msg6BitWords,msgsent)      !Unpack to get msgsent
-  if(ichk.ne.0) go to 999
-  call entail(i4Msg6BitWords,i1Msg8BitBytes)  !Add tail, convert to 8-bit bytes
-  nsym2=206
-  call encode232(i1Msg8BitBytes,nsym2,i1EncodedBits)   !Encode K=32, r=1/2
-  call interleave9(i1EncodedBits,1,i1ScrambledBits)    !Interleave the bits
-  call packbits(i1ScrambledBits,nsym2,3,i4DataSymbols) !Pack 3-bits into words
-  call graycode(i4DataSymbols,69,1,i4GrayCodedSymbols) !Apply Gray code
-
-! Insert sync symbols at ntone=0 and add 1 to the data-tone numbers.
-  j=0
-  do i=1,85
-     if(isync(i).eq.1) then
-        i4tone(i)=0
-     else
-        j=j+1
-        i4tone(i)=i4GrayCodedSymbols(j)+1
-     endif
-  enddo
-
-999 return
-end subroutine genjt9

Added: branches/wsprx/lib/genmept.f
===================================================================
--- branches/wsprx/lib/genmept.f	                        (rev 0)
+++ branches/wsprx/lib/genmept.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,101 @@
+      subroutine genmept(message,ntxdf,snrdb,iwave)
+
+C  Encode a WSPR message and generate the corresponding wavefile.
+
+      character*22 message
+      parameter (NMAX=120*12000)     !Max length of wave file
+      integer*2 iwave(NMAX)          !Generated wave file
+      parameter (MAXSYM=176)
+      integer*1 symbol(MAXSYM)
+      integer*1 data0(11),i1
+      integer npr3(162)
+      logical first
+      real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,tsymbol
+      equivalence(i1,i4)
+      data npr3/
+     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     + 0,0/
+
+      data first/.true./,idum/0/
+      save
+
+      if(first) then
+         pi=4.d0*atan(1.d0)
+         twopi=2.d0*pi
+         first=.false.
+      endif
+
+      call wqencode(message,ntype,data0)
+      nbytes=(50+31+7)/8
+      call encode232(data0,nbytes,symbol,MAXSYM)  !Convolutional encoding
+      call inter_mept(symbol,1)                   !Apply interleaving
+      do i=1,162
+         i4=0
+         i1=symbol(i)
+      enddo
+
+C  Set up necessary constants
+      tsymbol=8192.d0/12000.d0
+      dt=1.d0/12000.d0
+      f0=1500 + ntxdf
+      dfgen=12000.d0/8192.d0                     !1.4649 Hz
+      nsigs=1
+      if(snrdb.eq.10.0) nsigs=10
+      do isig=1,nsigs
+         if(nsigs.eq.1) snr=10.0**(0.05*(snrdb-1))   !Bandwidth correction?
+         fac=3000.0
+         if(snr.gt.1.0) fac=3000.0/snr
+         if(nsigs.eq.10) then
+            snr=10.0**(0.05*(-20-isig))
+            f0=1390 + 20*isig
+         endif
+         t=-2.d0 - 0.1*(isig-1)
+         phi=0.d0
+         j0=0
+
+         do i=1,NMAX
+            t=t+dt
+            j=int(t/tsymbol) + 1                          !Symbol number
+            sig=0.
+            if(j.ge.1 .and. j.le.162) then
+               if(j.ne.j0) then
+                  f=f0 + dfgen*(npr3(j)+2*symbol(j)-1.5)
+                  j0=j
+                  if(snrdb.eq.11.0) then
+                     k=npr3(j) + 2*symbol(j)
+                     write(*,1000) j,k,f
+ 1000                format(i3,i3,f10.3)
+                     go to 10
+                  else
+                     dphi=twopi*dt*f
+                  endif
+               endif
+               sig=0.9999
+            endif
+            phi=phi+dphi
+            if(snrdb.gt.50.0) then
+               n=32767.0*sin(phi)           !Normal transmission, signal only
+            else
+               if(isig.eq.1) then
+                  n=fac*(gran(idum) + sig*snr*sin(phi))
+               else
+                  n=iwave(i) + fac*sig*snr*sin(phi)
+               endif
+               if(n.gt.32767) n=32767
+               if(n.lt.-32767) n=-32767
+            endif
+            iwave(i)=n
+ 10         continue
+         enddo
+      enddo
+
+      return
+      end
+

Deleted: branches/wsprx/lib/genmet.f90
===================================================================
--- branches/wsprx/lib/genmet.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/genmet.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,88 +0,0 @@
-program genmet
-
-! Former name: tstprob
-
-  character*12 arg
-  real*4 r(0:255)
-  integer hist(2,-128:128)
-  data hist/514*0/,idum/-1/
-
-  lim(x)=min(127,max(-128,nint(scale*x)))
-
-  nargs=iargc()
-  if(nargs.ne.5) then
-     print*,'Usage: genmet ncoh nadd m0 snr iters'
-     go to 999
-  endif
-  call getarg(1,arg)
-  read(arg,*) ncoh
-  call getarg(2,arg)
-  read(arg,*) nadd
-  call getarg(3,arg)
-  read(arg,*) m0
-  call getarg(4,arg)
-  read(arg,*) snr
-  call getarg(5,arg)
-  read(arg,*) iters
-
-  ntones=2**m0
-  xm0=m0
-  scale=5.0
-  fac=sqrt(1.0/nadd)
-  s=sqrt(10.0**(0.1*snr))
-  hist=0
-  nerr=0
-
-  do iter=1,iters
-     do i=0,ntones-1
-        r(i)=0.
-        do n=1,nadd
-           x1=0.707*gran()
-           y1=0.707*gran()
-           if(i.eq.0) x1=x1+s
-           if(ncoh.eq.0) r(i)=r(i) + x1*x1 + y1*y1
-           if(ncoh.ne.0) r(i)=r(i) + x1
-        enddo
-        r(i)=fac*r(i)
-     enddo
-     do m=0,m0-1
-        n=2**m
-        r1=0.
-        r2=0.
-        do i=0,ntones-1
-           if(iand(i,n).ne.0) r1=max(r1,r(i))
-           if(iand(i,n).eq.0) r2=max(r2,r(i))
-        enddo
-        don=r2-r1
-        doff=r1-r2
-        if(don.lt.0.0) nerr=nerr+1
-        j1=lim(doff)
-        hist(1,j1)=hist(1,j1)+1
-        j2=lim(don)
-        hist(2,j2)=hist(2,j2)+1
-     enddo
-  enddo
-
-  do i=-128,127
-     write(13,1010) i/scale,hist(1,i)/(xm0*iters),hist(2,i)/(xm0*iters)
-1010 format(f8.3,2f12.9)
-  enddo
-
-  ber=nerr/(xm0*iters)
-  write(*,1020) nadd,m0,snr,ber
-1020 format('nadd:',i3,'   m0:',i2,'   snr: 'f5.1,'   BER:',f8.3)
-      
-  xln2=log(2.0)
-  do i=-128,127
-     p1=hist(2,i)/(xm0*iters)
-     p0=hist(1,i)/(xm0*iters)
-     if(p0+p1.eq.0.0 .and. i.lt.0) p0=1.e-6
-     if(p0+p1.eq.0.0 .and. i.gt.0) p1=1.e-6
-     xlhd0=log(max(0.001,2.0*p0/(p0+p1)))/xln2
-     xlhd1=log(max(0.001,2.0*p1/(p0+p1)))/xln2
-     write(14,1012) i/scale,xlhd0,xlhd1,p0/(p0+p1),p1/(p0+p1)
-1012 format(f7.1,2f8.3,2f9.6)
-  enddo
-      
-999 end program genmet
-

Deleted: branches/wsprx/lib/getlags.f90
===================================================================
--- branches/wsprx/lib/getlags.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/getlags.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,27 +0,0 @@
-subroutine getlags(nsps8,lag0,lag1,lag2)
-  if(nsps8.eq.864) then
-     lag1=39
-     lag2=291
-     lag0=123
-  else if(nsps8.eq.1920) then
-     lag1=70
-     lag2=184
-     lag0=108
-  else if(nsps8.eq.5120) then
-     lag1=84
-     lag2=129
-     lag0=99
-  else if(nsps8.eq.10368) then
-     lag1=91
-     lag2=112
-     lag0=98
-  else if(nsps8.eq.31500) then
-     lag1=93
-     lag2=102
-     lag0=96
-  else 
-     stop 'Error in getlags'
-  endif
-
-  return
-end subroutine getlags

Deleted: branches/wsprx/lib/getpfx1.f
===================================================================
--- branches/wsprx/lib/getpfx1.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/getpfx1.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,96 +0,0 @@
-      subroutine getpfx1(callsign,k,nv2)
-
-      character*12 callsign0,callsign,lof,rof
-      character*8 c
-      character addpfx*8,tpfx*4,tsfx*3
-      logical ispfx,issfx,invalid
-      common/pfxcom/addpfx
-      include 'pfx.f'
-
-      callsign0=callsign
-      nv2=0
-      iz=index(callsign,' ') - 1
-      if(iz.lt.0) iz=12
-      islash=index(callsign(1:iz),'/')
-      k=0
-      c='   '
-      if(islash.gt.0 .and. islash.le.(iz-4)) then
-!  Add-on prefix
-         c=callsign(1:islash-1)
-         callsign=callsign(islash+1:iz)
-         do i=1,NZ
-            if(pfx(i)(1:4).eq.c) then
-               k=i
-               go to 10
-            endif
-         enddo
-         if(addpfx.eq.c) then
-            k=449
-            go to 10
-         endif
-
-      else if(islash.eq.(iz-1)) then
-!  Add-on suffix
-         c=callsign(islash+1:iz)
-         callsign=callsign(1:islash-1)
-         do i=1,NZ2
-            if(sfx(i).eq.c(1:1)) then
-               k=400+i
-               go to 10
-            endif
-         enddo
-      endif
-
- 10   if(islash.ne.0 .and.k.eq.0) then
-!  Original JT65 would force this compound callsign to be treated as
-!  plain text.  In JT65v2, we will encode the prefix or suffix into nc1.
-!  The task here is to compute the proper value of k.
-         lof=callsign0(:islash-1)
-         rof=callsign0(islash+1:)
-         llof=len_trim(lof)
-         lrof=len_trim(rof)
-         ispfx=(llof.gt.0 .and. llof.le.4)
-         issfx=(lrof.gt.0 .and. lrof.le.3)
-         invalid=.not.(ispfx.or.issfx)
-         if(ispfx.and.issfx) then
-            if(llof.lt.3) issfx=.false.
-            if(lrof.lt.3) ispfx=.false.
-            if(ispfx.and.issfx) then
-               i=ichar(callsign0(islash-1:islash-1))
-               if(i.ge.ichar('0') .and. i.le.ichar('9')) then
-                  issfx=.false.
-               else
-                  ispfx=.false.
-               endif
-            endif
-         endif
-
-         if(invalid) then
-            k=-1
-         else
-            if(ispfx) then
-               tpfx=lof(1:4)
-               k=nchar(tpfx(1:1))
-               k=37*k + nchar(tpfx(2:2))
-               k=37*k + nchar(tpfx(3:3))
-               k=37*k + nchar(tpfx(4:4))
-               nv2=1
-               i=index(callsign0,'/')
-               callsign=callsign0(:i-1)
-               callsign=callsign0(i+1:)
-            endif
-            if(issfx) then
-               tsfx=rof(1:3)
-               k=nchar(tsfx(1:1))
-               k=37*k + nchar(tsfx(2:2))
-               k=37*k + nchar(tsfx(3:3))
-               nv2=2
-               i=index(callsign0,'/')
-               callsign=callsign0(:i-1)
-            endif
-         endif
-      endif
-
-      return
-      end
-

Deleted: branches/wsprx/lib/getpfx2.f
===================================================================
--- branches/wsprx/lib/getpfx2.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/getpfx2.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,24 +0,0 @@
-      subroutine getpfx2(k0,callsign)
-
-      character callsign*12
-      include 'pfx.f'
-      character addpfx*8
-      common/pfxcom/addpfx
-
-      k=k0
-      if(k.gt.450) k=k-450
-      if(k.ge.1 .and. k.le.NZ) then
-         iz=index(pfx(k),' ') - 1
-         callsign=pfx(k)(1:iz)//'/'//callsign
-      else if(k.ge.401 .and. k.le.400+NZ2) then
-         iz=index(callsign,' ') - 1
-         callsign=callsign(1:iz)//'/'//sfx(k-400)
-      else if(k.eq.449) then
-         iz=index(addpfx,' ') - 1
-         if(iz.lt.1) iz=8
-         callsign=addpfx(1:iz)//'/'//callsign
-      endif
-
-      return
-      end
-

Added: branches/wsprx/lib/getrms.f
===================================================================
--- branches/wsprx/lib/getrms.f	                        (rev 0)
+++ branches/wsprx/lib/getrms.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,32 @@
+      subroutine getrms(iwave,npts,ave,rms)
+
+      parameter (NMAX=120*12000)
+      integer*2 iwave(NMAX)
+      real*8 sq
+
+      s=0.
+      do i=1,npts
+         s=s + iwave(i)
+      enddo
+      ave=s/npts
+      sq=0.
+      do i=1,npts
+         sq=sq + (iwave(i)-ave)**2
+      enddo
+      rms=sqrt(sq/npts)
+      fac=3000.0/rms
+      do i=1,npts
+         n=nint(fac*(iwave(i)-ave))
+         if(n.gt.32767) n=32767
+         if(n.lt.-32767) n=-32767
+         iwave(i)=n
+      enddo
+
+      if(npts.lt.NMAX) then
+         do i=npts+1,NMAX
+            iwave(i)=0
+         enddo
+      endif
+
+      return
+      end

Added: branches/wsprx/lib/getutc.f90
===================================================================
--- branches/wsprx/lib/getutc.f90	                        (rev 0)
+++ branches/wsprx/lib/getutc.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,32 @@
+subroutine getutc(cdate,ctime,tsec)
+
+  character cdate*8,ctime*10
+  real*8 tsec
+  integer nt(9)
+!        1    2    3    4     5    6    7    8   9
+!  nt:  sec  min  ihr  day  month year dweek 0   0
+
+  call gmtime2(nt,tsec)
+  cdate(1:1)=char(48+nt(6)/1000)
+  cdate(2:2)=char(48+mod(nt(6),1000)/100)
+  cdate(3:3)=char(48+mod(nt(6),100)/10)
+  cdate(4:4)=char(48+mod(nt(6),10))
+  cdate(5:5)=char(48+nt(5)/10)
+  cdate(6:6)=char(48+mod(nt(5),10))
+  cdate(7:7)=char(48+nt(4)/10)
+  cdate(8:8)=char(48+mod(nt(4),10))
+  ctime(1:1)=char(48+nt(3)/10)
+  ctime(2:2)=char(48+mod(nt(3),10))
+  ctime(3:3)=char(48+nt(2)/10)
+  ctime(4:4)=char(48+mod(nt(2),10))
+  ctime(5:5)=char(48+nt(1)/10)
+  ctime(6:6)=char(48+mod(nt(1),10))
+  ctime(7:7)='.'
+  nsec=tsec
+  msec=1000*(tsec-nsec)
+  ctime(8:8)=char(48+msec/100)
+  ctime(9:9)=char(48+mod(msec,100)/10)
+  ctime(10:10)=char(48+mod(msec,10))
+
+  return
+end subroutine getutc

Added: branches/wsprx/lib/gmtime2.c
===================================================================
--- branches/wsprx/lib/gmtime2.c	                        (rev 0)
+++ branches/wsprx/lib/gmtime2.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,54 @@
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+typedef struct _SYSTEMTIME
+{
+  short   Year;
+  short   Month;
+  short   DayOfWeek;
+  short   Day;
+  short   Hour;
+  short   Minute;
+  short   Second;
+  short   Millisecond;
+} SYSTEMTIME;
+
+#ifdef Win32
+extern void __stdcall GetSystemTime(SYSTEMTIME *st);
+#else
+#include &lt;sys/time.h&gt;
+#include &lt;time.h&gt;
+
+void GetSystemTime(SYSTEMTIME *st){
+  struct timeval tmptimeofday;
+  struct tm tmptmtime;
+  gettimeofday(&amp;tmptimeofday,NULL);
+  gmtime_r((const time_t *)&amp;tmptimeofday.tv_sec,&amp;tmptmtime);
+  st-&gt;Year = (short)tmptmtime.tm_year;
+  st-&gt;Month = (short)tmptmtime.tm_mon+1;
+  st-&gt;DayOfWeek = (short)tmptmtime.tm_wday;
+  st-&gt;Day = (short)tmptmtime.tm_mday;
+  st-&gt;Hour = (short)tmptmtime.tm_hour;
+  st-&gt;Minute = (short)tmptmtime.tm_min;
+  st-&gt;Second = (short)tmptmtime.tm_sec;
+  st-&gt;Millisecond = (short)(tmptimeofday.tv_usec/1000);
+}
+#endif
+
+extern void gmtime2_(int it[], double *stime)
+{
+  SYSTEMTIME st;
+
+  GetSystemTime(&amp;st);
+  it[0]=st.Second;
+  it[1]=st.Minute;
+  it[2]=st.Hour;
+  it[3]=st.Day;
+  it[4]=st.Month;
+  it[5]=st.Year;
+  it[6]=st.DayOfWeek;
+  it[7]=0;
+  it[8]=0;
+  *stime = st.Hour*3600.0 + st.Minute*60.0 + st.Second + st.Millisecond*0.001;
+}
+

Deleted: branches/wsprx/lib/graycode.f90
===================================================================
--- branches/wsprx/lib/graycode.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/graycode.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,9 +0,0 @@
-subroutine graycode(ia,n,idir,ib)
-
-  integer ia(n),ib(n)
-  do i=1,n
-     ib(i)=igray(ia(i),idir)
-  enddo
-
-  return
-end subroutine graycode

Deleted: branches/wsprx/lib/grid2k.f
===================================================================
--- branches/wsprx/lib/grid2k.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/grid2k.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,12 +0,0 @@
-      subroutine grid2k(grid,k)
-
-      character*6 grid
-
-      call grid2deg(grid,xlong,xlat)
-      nlong=nint(xlong)
-      nlat=nint(xlat)
-      k=0
-      if(nlat.ge.85) k=5*(nlong+179)/2 + nlat-84
-
-      return
-      end

Deleted: branches/wsprx/lib/grid2n.f90
===================================================================
--- branches/wsprx/lib/grid2n.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/grid2n.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,10 +0,0 @@
-subroutine grid2n(grid,n)
-  character*4 grid
-
-  i1=ichar(grid(1:1))-ichar('A')
-  i2=ichar(grid(3:3))-ichar('0')
-  i=10*i1 + i2
-  n=-i - 31
-
-  return
-end subroutine grid2n

Added: branches/wsprx/lib/hash.f90
===================================================================
--- branches/wsprx/lib/hash.f90	                        (rev 0)
+++ branches/wsprx/lib/hash.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,15 @@
+subroutine hash(string,len,ihash)
+
+  parameter (MASK15=32767)
+  character*(*) string
+  integer*1 ic(12)
+
+     do i=1,len
+        ic(i)=ichar(string(i:i))
+     enddo
+     i=nhash(ic,len,146)
+     ihash=iand(i,MASK15)
+
+!     print*,'C',ihash,len,string
+  return
+end subroutine hash

Deleted: branches/wsprx/lib/igray.c
===================================================================
--- branches/wsprx/lib/igray.c	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/igray.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,18 +0,0 @@
-int igray_(int *n0, int *idir)
-{
-  int n;
-  unsigned long sh;
-  unsigned long nn;
-  n=*n0;
-
-  if(*idir&gt;0) return (n ^ (n &gt;&gt; 1));
-
-  sh = 1;
-  nn = (n &gt;&gt; sh);
-  while (nn &gt; 0) {
-    n ^= nn;
-    sh &lt;&lt;= 1;
-    nn = (n &gt;&gt; sh);
-  }
-  return (n);
-}

Deleted: branches/wsprx/lib/indexx.f
===================================================================
--- branches/wsprx/lib/indexx.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/indexx.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,19 +0,0 @@
-      subroutine indexx(n,arr,indx)
-
-      parameter (NMAX=3000)
-      integer indx(n)
-      real arr(n)
-      real brr(NMAX)
-      if(n.gt.NMAX) then
-         print*,'n=',n,' too big in indexx.'
-         stop
-      endif
-      do i=1,n
-         brr(i)=arr(i)
-         indx(i)=i
-      enddo
-      call ssort(brr,indx,n,2)
-
-      return
-      end
-

Deleted: branches/wsprx/lib/init_rs.c
===================================================================
--- branches/wsprx/lib/init_rs.c	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/init_rs.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,126 +0,0 @@
-/* Initialize a RS codec
- *
- * Copyright 2002 Phil Karn, KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-#include &lt;stdlib.h&gt;
-
-#ifdef CCSDS
-#include &quot;ccsds.h&quot;
-#elif defined(BIGSYM)
-#include &quot;int.h&quot;
-#else
-#include &quot;char.h&quot;
-#endif
-
-#define NULL ((void *)0)
-
-void FREE_RS(void *p){
-  struct rs *rs = (struct rs *)p;
-
-  free(rs-&gt;alpha_to);
-  free(rs-&gt;index_of);
-  free(rs-&gt;genpoly);
-  free(rs);
-}
-
-/* Initialize a Reed-Solomon codec
- * symsize = symbol size, bits (1-8)
- * gfpoly = Field generator polynomial coefficients
- * fcr = first root of RS code generator polynomial, index form
- * prim = primitive element to generate polynomial roots
- * nroots = RS code generator polynomial degree (number of roots)
- * pad = padding bytes at front of shortened block
- */
-void *INIT_RS(int symsize,int gfpoly,int fcr,int prim,
-	int nroots,int pad){
-  struct rs *rs;
-  int i, j, sr,root,iprim;
-
-  /* Check parameter ranges */
-  if(symsize &lt; 0 || symsize &gt; 8*sizeof(DTYPE))
-    return NULL; /* Need version with ints rather than chars */
-
-  if(fcr &lt; 0 || fcr &gt;= (1&lt;&lt;symsize))
-    return NULL;
-  if(prim &lt;= 0 || prim &gt;= (1&lt;&lt;symsize))
-    return NULL;
-  if(nroots &lt; 0 || nroots &gt;= (1&lt;&lt;symsize))
-    return NULL; /* Can't have more roots than symbol values! */
-  if(pad &lt; 0 || pad &gt;= ((1&lt;&lt;symsize) -1 - nroots))
-    return NULL; /* Too much padding */
-
-  rs = (struct rs *)calloc(1,sizeof(struct rs));
-  rs-&gt;mm = symsize;
-  rs-&gt;nn = (1&lt;&lt;symsize)-1;
-  rs-&gt;pad = pad;
-
-  rs-&gt;alpha_to = (DTYPE *)malloc(sizeof(DTYPE)*(rs-&gt;nn+1));
-  if(rs-&gt;alpha_to == NULL){
-    free(rs);
-    return NULL;
-  }
-  rs-&gt;index_of = (DTYPE *)malloc(sizeof(DTYPE)*(rs-&gt;nn+1));
-  if(rs-&gt;index_of == NULL){
-    free(rs-&gt;alpha_to);
-    free(rs);
-    return NULL;
-  }
-
-  /* Generate Galois field lookup tables */
-  rs-&gt;index_of[0] = A0; /* log(zero) = -inf */
-  rs-&gt;alpha_to[A0] = 0; /* alpha**-inf = 0 */
-  sr = 1;
-  for(i=0;i&lt;rs-&gt;nn;i++){
-    rs-&gt;index_of[sr] = i;
-    rs-&gt;alpha_to[i] = sr;
-    sr &lt;&lt;= 1;
-    if(sr &amp; (1&lt;&lt;symsize))
-      sr ^= gfpoly;
-    sr &amp;= rs-&gt;nn;
-  }
-  if(sr != 1){
-    /* field generator polynomial is not primitive! */
-    free(rs-&gt;alpha_to);
-    free(rs-&gt;index_of);
-    free(rs);
-    return NULL;
-  }
-
-  /* Form RS code generator polynomial from its roots */
-  rs-&gt;genpoly = (DTYPE *)malloc(sizeof(DTYPE)*(nroots+1));
-  if(rs-&gt;genpoly == NULL){
-    free(rs-&gt;alpha_to);
-    free(rs-&gt;index_of);
-    free(rs);
-    return NULL;
-  }
-  rs-&gt;fcr = fcr;
-  rs-&gt;prim = prim;
-  rs-&gt;nroots = nroots;
-
-  /* Find prim-th root of 1, used in decoding */
-  for(iprim=1;(iprim % prim) != 0;iprim += rs-&gt;nn)
-    ;
-  rs-&gt;iprim = iprim / prim;
-
-  rs-&gt;genpoly[0] = 1;
-  for (i = 0,root=fcr*prim; i &lt; nroots; i++,root += prim) {
-    rs-&gt;genpoly[i+1] = 1;
-
-    /* Multiply rs-&gt;genpoly[] by  @**(root + x) */
-    for (j = i; j &gt; 0; j--){
-      if (rs-&gt;genpoly[j] != 0)
-	rs-&gt;genpoly[j] = rs-&gt;genpoly[j-1] ^ rs-&gt;alpha_to[modnn(rs,rs-&gt;index_of[rs-&gt;genpoly[j]] + root)];
-      else
-	rs-&gt;genpoly[j] = rs-&gt;genpoly[j-1];
-    }
-    /* rs-&gt;genpoly[0] can never be zero */
-    rs-&gt;genpoly[0] = rs-&gt;alpha_to[modnn(rs,rs-&gt;index_of[rs-&gt;genpoly[0]] + root)];
-  }
-  /* convert rs-&gt;genpoly[] to index form for quicker encoding */
-  for (i = 0; i &lt;= nroots; i++)
-    rs-&gt;genpoly[i] = rs-&gt;index_of[rs-&gt;genpoly[i]];
-
-  return rs;
-}

Deleted: branches/wsprx/lib/int.h
===================================================================
--- branches/wsprx/lib/int.h	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/int.h	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,57 +0,0 @@
-/* Include file to configure the RS codec for integer symbols
- *
- * Copyright 2002, Phil Karn, KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-#define DTYPE int
-
-/* Reed-Solomon codec control block */
-struct rs {
-  int mm;              /* Bits per symbol */
-  int nn;              /* Symbols per block (= (1&lt;&lt;mm)-1) */
-  DTYPE *alpha_to;     /* log lookup table */
-  DTYPE *index_of;     /* Antilog lookup table */
-  DTYPE *genpoly;      /* Generator polynomial */
-  int nroots;     /* Number of generator roots = number of parity symbols */
-  int fcr;        /* First consecutive root, index form */
-  int prim;       /* Primitive element, index form */
-  int iprim;      /* prim-th root of 1, index form */
-  int pad;        /* Padding bytes in shortened block */
-};
-
-static int modnn(struct rs *rs,int x){
-  while (x &gt;= rs-&gt;nn) {
-    x -= rs-&gt;nn;
-    x = (x &gt;&gt; rs-&gt;mm) + (x &amp; rs-&gt;nn);
-  }
-  return x;
-}
-#define MODNN(x) modnn(rs,x)
-
-#define MM (rs-&gt;mm)
-#define NN (rs-&gt;nn)
-#define ALPHA_TO (rs-&gt;alpha_to) 
-#define INDEX_OF (rs-&gt;index_of)
-#define GENPOLY (rs-&gt;genpoly)
-//#define NROOTS (rs-&gt;nroots)
-#define NROOTS (51)
-#define FCR (rs-&gt;fcr)
-#define PRIM (rs-&gt;prim)
-#define IPRIM (rs-&gt;iprim)
-#define PAD (rs-&gt;pad)
-#define A0 (NN)
-
-#define ENCODE_RS encode_rs_int
-#define DECODE_RS decode_rs_int
-#define INIT_RS init_rs_int
-#define FREE_RS free_rs_int
-
-void ENCODE_RS(void *p,DTYPE *data,DTYPE *parity);
-int DECODE_RS(void *p,DTYPE *data,int *eras_pos,int no_eras);
-void *INIT_RS(int symsize,int gfpoly,int fcr,
-		   int prim,int nroots,int pad);
-void FREE_RS(void *p);
-
-
-
-

Added: branches/wsprx/lib/inter_mept.f
===================================================================
--- branches/wsprx/lib/inter_mept.f	                        (rev 0)
+++ branches/wsprx/lib/inter_mept.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,45 @@
+      subroutine inter_mept(id,ndir)
+
+C  Interleave (ndir=1) or de-interleave (ndir=-1) the array id.
+
+      integer*1 id(0:161),itmp(0:161)
+      integer j0(0:161)
+      logical first
+      data first/.true./
+      save
+
+      if(first) then
+! Compute the interleave table using bit reversal.
+         k=-1
+         do i=0,255
+            n=0
+            ii=i
+            do j=0,7
+               n=n+n
+               if(iand(ii,1).ne.0) n=n+1
+               ii=ii/2
+            enddo
+            if(n.le.161) then
+               k=k+1
+               j0(k)=n
+            endif
+         enddo
+         first=.false.
+      endif
+
+      if(ndir.eq.1) then
+         do i=0,161
+            itmp(j0(i))=id(i)
+         enddo
+      else
+         do i=0,161
+            itmp(i)=id(j0(i))
+         enddo
+      endif
+
+      do i=0,161
+         id(i)=itmp(i)
+      enddo
+
+      return
+      end

Deleted: branches/wsprx/lib/interleave8.f90
===================================================================
--- branches/wsprx/lib/interleave8.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/interleave8.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,17 +0,0 @@
-subroutine interleave8(idat,jdat)
-
-  integer idat(66),jdat(66)
-  integer ii(66),jj(66)
-  data ii/                                                            &amp;
-       64,32,16,48, 8,40,24,56, 4,36,20,52,12,44,28,60, 2,66,34,18,   &amp;
-       50,10,42,26,58, 6,38,22,54,14,46,30,62, 1,65,33,17,49, 9,41,   &amp;
-       25,57, 5,37,21,53,13,45,29,61, 3,35,19,51,11,43,27,59, 7,39,   &amp;
-       23,55,15,47,31,63/
-  data jj/                                                            &amp;
-       34,17,51, 9,43,26,59, 5,39,22,55,13,47,30,63, 3,37,20,53,11,   &amp;
-       45,28,61, 7,41,24,57,15,49,32,65, 2,36,19,52,10,44,27,60, 6,   &amp;
-       40,23,56,14,48,31,64, 4,38,21,54,12,46,29,62, 8,42,25,58,16,   &amp;
-       50,33,66, 1,35,18/
-
-  return
-end subroutine interleave8

Deleted: branches/wsprx/lib/interleave9.f90
===================================================================
--- branches/wsprx/lib/interleave9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/interleave9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,39 +0,0 @@
-subroutine interleave9(ia,ndir,ib)
-  integer*1 ia(0:205),ib(0:205)
-  integer j0(0:205)
-  logical first
-  data first/.true./
-  save first,j0                     !Save not working, or j0 overwritten ???
-
-  if(first) then
-     k=-1
-     do i=0,255
-        m=i
-        n=iand(m,1)
-        n=2*n + iand(m/2,1)
-        n=2*n + iand(m/4,1)
-        n=2*n + iand(m/8,1)
-        n=2*n + iand(m/16,1)
-        n=2*n + iand(m/32,1)
-        n=2*n + iand(m/64,1)
-        n=2*n + iand(m/128,1)
-        if(n.le.205) then
-           k=k+1
-           j0(k)=n
-        endif
-     enddo
-!     first=.false.
-  endif
-
-  if(ndir.gt.0) then
-     do i=0,205
-        ib(j0(i))=ia(i)
-     enddo
-  else
-     do i=0,205
-        ib(i)=ia(j0(i))
-     enddo
-  endif
-
-  return
-end subroutine interleave9

Deleted: branches/wsprx/lib/ipcomm.cpp
===================================================================
--- branches/wsprx/lib/ipcomm.cpp	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/ipcomm.cpp	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,34 +0,0 @@
-#include &lt;QDebug&gt;
-#include &lt;qsharedmemory.h&gt;
-#include &lt;QSystemSemaphore&gt;
-
-QSharedMemory mem_jt9(&quot;mem_jt9&quot;);
-QSystemSemaphore sem_jt9(&quot;sem_jt9&quot;, 1, QSystemSemaphore::Open);
-
-extern &quot;C&quot; {
-  bool attach_jt9_();
-  bool create_jt9_(int nsize);
-  bool detach_jt9_();
-  bool lock_jt9_();
-  bool unlock_jt9_();
-  char* address_jt9_();
-  int size_jt9_();
-
-  bool acquire_jt9_();
-  bool release_jt9_();
-
-  extern struct {
-    char c[10];
-  } jt9com_;
-}
-
-bool attach_jt9_() {return mem_jt9.attach();}
-bool create_jt9_(int nsize) {return mem_jt9.create(nsize);}
-bool detach_jt9_() {return mem_jt9.detach();}
-bool lock_jt9_() {return mem_jt9.lock();}
-bool unlock_jt9_() {return mem_jt9.unlock();}
-char* address_jt9_() {return (char*)mem_jt9.constData();}
-int size_jt9_() {return (int)mem_jt9.size();}
-
-bool acquire_jt9_() {return sem_jt9.acquire();}
-bool release_jt9_() {return sem_jt9.release();}

Deleted: branches/wsprx/lib/jt9.f90
===================================================================
--- branches/wsprx/lib/jt9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/jt9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,181 +0,0 @@
-program jt9
-
-! Decoder for JT9.  Can run stand-alone, reading data from *.wav files;
-! or as the back end of wsjt-x, with data placed in a shared memory region.
-
-! NB: For unknown reason, ***MUST*** be compiled by g95 with -O0 !!!
-
-  character*80 arg,infile
-  parameter (NMAX=1800*12000)        !Total sample intervals per 30 minutes
-  parameter (NDMAX=1800*1500)        !Sample intervals at 1500 Hz rate
-  parameter (NSMAX=22000)            !Max length of saved spectra
-  integer*4 ihdr(11)
-  real*4 s(NSMAX)
-  real*4 ccfred(NSMAX)
-  logical*1 lstrong(0:1023)
-  integer*1 i1SoftSymbols(207)
-  character*22 msg
-  character*33 line
-  integer*2 id2
-  complex c0
-  complex c1(NDMAX)
-  common/jt9com/ss(184,NSMAX),savg(NSMAX),c0(NDMAX),id2(NMAX),nutc,ndiskdat,  &amp;
-       ntr,mousefqso,newdat,nfa,nfb,ntol,kin,nzhsym,nsynced,ndecoded
-  common/tracer/limtrace,lu
-
-  nargs=iargc()
-  if(nargs.lt.1) then
-     print*,'Usage: jt9 TRperiod file1 [file2 ...]'
-     print*,'       Reads data from *.wav files.'
-     print*,''
-     print*,'       jt9 -s'
-     print*,'       Gets data from shared memory region.'
-     go to 999
-  endif
-  call getarg(1,arg)
-  if(arg(1:2).eq.'-s') then
-     call jt9a
-!    call ftnquit
-     go to 999
-  endif
-  read(arg,*) ntrperiod
-
-  ifile1=2
-
-  limtrace=0
-  lu=12
-  nfa=1000
-  nfb=2000
-  ntol=500
-  nfqso=1500
-  newdat=1
-  nb=0
-  nbslider=100
-  limit=20000
-  ndiskdat=1
-
-  do ifile=ifile1,nargs
-     call getarg(ifile,infile)
-     open(10,file=infile,access='stream',status='old',err=998)
-     read(10) ihdr
-     i1=index(infile,'.wav')
-     read(infile(i1-4:i1-1),*,err=1) nutc0
-     go to 2
-1    nutc0=0
-2    nsps=0
-     if(ntrperiod.eq.1)  then
-        nsps=6912
-        nzhsym=181
-     else if(ntrperiod.eq.2)  then
-        nsps=15360
-        nzhsym=178
-     else if(ntrperiod.eq.5)  then
-        nsps=40960
-        nzhsym=172
-     else if(ntrperiod.eq.10) then
-        nsps=82944
-        nzhsym=171
-     else if(ntrperiod.eq.30) then
-        nsps=252000
-        nzhsym=167
-     endif
-     if(nsps.eq.0) stop 'Error: bad TRperiod'
-
-     kstep=nsps/2
-     tstep=kstep/12000.0
-     k=0
-     nhsym0=-999
-     npts=(60*ntrperiod-6)*12000
-     if(ifile.eq.ifile1) then
-        open(12,file='timer.out',status='unknown')
-        call timer('jt9     ',0)
-     endif
-
-!     do i=1,npts
-!        id2(i)=100.0*sin(6.283185307*1600.0*i/12000.0)
-!     enddo
-
-     do iblk=1,npts/kstep
-        k=iblk*kstep
-        call timer('read_wav',0)
-        read(10,end=10) id2(k-kstep+1:k)
-        call timer('read_wav',1)
-
-        nhsym=(k-2048)/kstep
-        if(nhsym.ge.1 .and. nhsym.ne.nhsym0) then
-! Emit signal readyForFFT
-           ingain=0
-           call timer('symspec ',0)
-           call symspec(k,ntrperiod,nsps,ingain,nb,nbslider,pxdb,   &amp;
-                s,ccfred,df3,ihsym,nzap,slimit,lstrong,npts8)
-           call timer('symspec ',1)
-           nhsym0=nhsym
-           if(ihsym.ge.184) go to 10
-        endif
-     enddo
-
-10   close(10)
-     iz=1000.0/df3
-     nutc=nutc0
-
-     call timer('sync9   ',0)
-     call sync9(ss,nzhsym,tstep,df3,ntol,nfqso,ccfred,ia,ib,ipk) !Get sync, freq
-     call timer('sync9   ',1)
-
-     fgood=0.
-     nsps8=nsps/8
-     df8=1500.0/nsps8
-     sbest=0.
-     do i=ia,ib
-        f=(i-1)*df3
-        if((i.eq.ipk .or. ccfred(i).ge.3.0) .and. f.gt.fgood+10.0*df8) then
-
-           call timer('decode9a',0)
-           fpk=1000.0 + df3*(i-1)
-           c1(1:npts8)=conjg(c0(1:npts8))
-           call decode9a(c1,npts8,nsps8,fpk,syncpk,snrdb,xdt,freq,    &amp;
-                drift,i1SoftSymbols)
-           call timer('decode9a',1)
-
-           call timer('decode9 ',0)
-           call decode9(i1SoftSymbols,limit,nlim,msg)
-           call timer('decode9 ',1)
- 
-           sync=(syncpk-1.0)/2.0
-           if(sync.lt.0.0 .or. snrdb.lt.dblim-2.0) sync=0.0
-           nsync=sync
-           if(nsync.gt.10) nsync=10
-           nsnr=nint(snrdb)
-
-           if(sync.gt.sbest .and. fgood.eq.0.0) then
-              sbest=sync
-              write(line,1010) nutc,nsync,nsnr,xdt,freq,drift
-              if(nsync.gt.0) nsynced=1
-           endif
-
-           if(msg.ne.'                      ') then
-              write(*,1010) nutc,nsync,nsnr,xdt,freq,drift,msg
-1010          format(i4.4,i4,i5,f6.1,f8.2,f6.2,3x,a22)
-              fgood=f
-              nsynced=1
-              ndecoded=1
-           endif
-        endif
-     enddo
-
-     if(fgood.eq.0.0) then
-        write(*,1020) line
-1020    format(a33)
-     endif
-
-  enddo
-
-  call timer('jt9     ',1)
-  call timer('jt9     ',101)
-!  call ftnquit
-  go to 999
-
-998 print*,'Cannot open file:'
-  print*,infile
-
-999 end program jt9

Deleted: branches/wsprx/lib/jt9a.F90
===================================================================
--- branches/wsprx/lib/jt9a.F90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/jt9a.F90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,104 +0,0 @@
-subroutine jt9a
-
-! NB: this interface block is required by g95, but must be omitted
-!     for gfortran.  (????)
-
-#ifndef UNIX
-  interface
-     function address_jt9()
-     end function address_jt9
-  end interface
-#endif
-  
-  integer*1 attach_jt9,lock_jt9,unlock_jt9
-  integer size_jt9
-  integer*1, pointer :: address_jt9,p_jt9
-  character*80 cwd
-  logical fileExists
-  common/tracer/limtrace,lu
-
-  call getcwd(cwd)
-!  call ftninit(trim(cwd))
-  open(12,file='timer.out',status='unknown')
-  open(14,file='wsjtx_rx.log',status='unknown',position='append')
-
-  limtrace=0
-  lu=12
-  i1=attach_jt9()
-
-10 inquire(file=trim(cwd)//'/.lock',exist=fileExists)
-  if(fileExists) then
-     call sleep_msec(100)
-     go to 10
-  endif
-
-  inquire(file=trim(cwd)//'/.quit',exist=fileExists)
-  if(fileExists) then
-!     call ftnquit
-     i=detach_jt9()
-     go to 999
-  endif
-  
-  nbytes=size_jt9()
-  if(nbytes.le.0) then
-     print*,'jt9a: Shared memory mem_jt9 does not exist.' 
-     print*,&quot;Must start 'jt9 -s' from within WSJT-X.&quot;
-     go to 999
-  endif
-  p_jt9=&gt;address_jt9()
-  call jt9b(p_jt9,nbytes)
-
-!  write(*,1010) 
-!1010 format('&lt;jt9aFinished&gt;')
-!  flush(6)
-
-100 inquire(file=trim(cwd)//'/.lock',exist=fileExists)
-  if(fileExists) go to 10
-  call sleep_msec(100)
-  go to 100
-
-999 return
-end subroutine jt9a
-
-subroutine jt9b(jt9com,nbytes)
-  integer*1 jt9com(0:nbytes-1)
-  kss=0
-  ksavg=kss + 4*184*22000
-  kc0=ksavg + 4*22000
-  kid2=kc0 + 2*4*1800*1500
-  knutc=kid2 + 2*1800*12000
-  call jt9c(jt9com(kss),jt9com(ksavg),jt9com(kc0),jt9com(kid2),jt9com(knutc))
-  return
-end subroutine jt9b
-
-subroutine jt9c(ss,savg,c0,id2,nparams0)
-  parameter (NSMAX=22000)
-  integer*1 detach_jt9
-  real*4 ss(184*NSMAX),savg(NSMAX)
-  complex c0(1800*1500)
-  integer*2 id2(1800*12000)
-
-  integer nparams0(21),nparams(21)
-  character*20 datetime
-  common/npar/nutc,ndiskdat,ntrperiod,nfqso,newdat,npts8,nfa,nfb,ntol,  &amp;
-       kin,nzhsym,nsave,nagain,ndepth,nrxlog,nfsample,datetime
-  equivalence (nparams,nutc)
-  
-  nparams=nparams0                     !Copy parameters into common/npar/
-  npatience=1
-
-  call flush(6)
-
-  if(iand(nrxlog,1).ne.0) then
-     write(14,1000) datetime(:17)
-1000 format(/'UTC Date: 'a17/78('-'))
-     flush(14)
-  endif
-  if(iand(nrxlog,2).ne.0) rewind 14
-!  if(iand(nrxlog,4).ne.0) rewind 26
-
-  nstandalone=0
-  if(sum(nparams).ne.0) call decoder(ss,c0)
-
-  return
-end subroutine jt9c

Deleted: branches/wsprx/lib/jt9code.f90
===================================================================
--- branches/wsprx/lib/jt9code.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/jt9code.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,39 +0,0 @@
-program jt9code
-
-! Generate simulated data for testing of WSJT-X
-
-  parameter (NMAX=1800*12000)
-  character msg*22,msg0*22,decoded*22
-
-  integer*4 i4tone(85)             !Channel symbols (values 0-8)
-  integer*4 i4data(69)
-  integer*4 i4DataSymNoGray(69)    !Data Symbols, values 0-7
-  integer*1 i1ScrambledBits(207)   !Unpacked bits, scrambled order
-  integer*1 i1Bits(207)            !Encoded information-carrying bits
-  integer*1 i1SoftSymbols(207)
-  integer*1 i1
-  equivalence (i1,i4)
-  include 'jt9sync.f90'
-  common/acom/dat(NMAX),iwave(NMAX)
-
-  nargs=iargc()
-  if(nargs.ne.1) then
-     print*,'Usage: jt9code &quot;message&quot;'
-     go to 999
-  endif
-
-  call getarg(1,msg0)
-  write(*,1000) msg0
-1000 format('Message:',3x,a22)
-  msg=msg0
-  ichk=0
-  itext=0
-  call genjt9(msg,ichk,decoded,i4tone,itext)       !Encode message into tone #s
-  write(*,1002) i4tone
-1002 format('Channel symbols:'/(30i2))
-  if(itext.eq.0) write(*,1004) decoded
-1004 format('Decoded message:',1x,a22)
-  if(itext.ne.0) write(*,1005) decoded
-1005 format('Decoded message:',1x,a22,3x,'(free text)')
-
-999 end program jt9code

Deleted: branches/wsprx/lib/jt9sim.f90
===================================================================
--- branches/wsprx/lib/jt9sim.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/jt9sim.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,165 +0,0 @@
-program jt9sim
-
-! Generate simulated data for testing of WSJT-X
-
-  parameter (NMAX=1800*12000)
-  integer ihdr(11)
-  integer*2 iwave                  !Generated waveform (no noise)
-  real*8 f0,f,dt,twopi,phi,dphi,baud,fspan,fsample,freq
-  character msg*22,msg0*22,message*22,msgsent*22,arg*8,fname*11
-
-  integer*4 i4tone(85)             !Channel symbols (values 0-8)
-  integer*4 i4DataSymNoGray(69)    !Data Symbols, values 0-7
-  integer*1 i1ScrambledBits(207)   !Unpacked bits, scrambled order
-  integer*1 i1Bits(207)            !Encoded information-carrying bits
-  integer*1 i1SoftSymbols(207)
-  integer*1 i1
-  equivalence (i1,i4)
-  include 'jt9sync.f90'
-  common/acom/dat(NMAX),iwave(NMAX)
-
-  nargs=iargc()
-  if(nargs.ne.6) then
-     print*,'Usage: jt9sim &quot;message&quot; fspan nsigs minutes SNR nfiles'
-     print*,'Example:  &quot;CQ K1ABC FN42&quot; 200  20      2    -28    1'
-     print*,' '
-     print*,'Enter message = &quot;&quot; to use entries in msgs.txt.'
-     print*,'Enter SNR = 0 to generate a range of SNRs.'
-     go to 999
-  endif
-
-  call getarg(1,msg0)
-  message=msg0                       !Transmitted message
-  call getarg(2,arg)
-  read(arg,*) fspan                  !Total freq range (Hz)
-  call getarg(3,arg)
-  read(arg,*) nsigs                  !Number of signals in each file
-  call getarg(4,arg)
-  read(arg,*) minutes                !Length of file (1 2 5 10 30 minutes)
-  call getarg(5,arg)
-  read(arg,*) snrdb                  !S/N in dB (2500 hz reference BW)
-  call getarg(6,arg)
-  read(arg,*) nfiles                 !Number of files
-
-  rmsdb=25.
-  rms=10.0**(0.05*rmsdb)
-  fsample=12000.d0                   !Sample rate (Hz)
-  dt=1.d0/fsample                    !Sample interval (s)
-  twopi=8.d0*atan(1.d0)
-  npts=12000*(60*minutes-6)
-  nsps=0
-  if(minutes.eq.1)  nsps=6912
-  if(minutes.eq.2)  nsps=15360
-  if(minutes.eq.5)  nsps=40960
-  if(minutes.eq.10) nsps=82944
-  if(minutes.eq.30) nsps=252000
-  if(nsps.eq.0) stop 'Bad value for minutes.'
-
-  f0=1400.d0                         !Center frequency (MHz)
-!  f0=1500.0
-!  if(minutes.eq.5)  f0=1100.
-!  if(minutes.eq.10) f0=1050.
-!  if(minutes.eq.30) f0=1025.
-  
-  ihdr=0                             !Temporary ###
-
-  if(msg0(1:3).eq.'sin') read(msg0(4:),*) sinfreq
-  
-  open(12,file='msgs.txt',status='old')
-
-  write(*,1000)
-1000 format('File  N    freq      S/N  Message'/    &amp;
-            '---------------------------------------------------')
-
-  do ifile=1,nfiles                            !Loop over all files
-     nmin=(ifile-1)*minutes
-     ihr=nmin/60
-     imin=mod(nmin,60)
-     write(fname,1002) ihr,imin                !Create output filename
-1002 format('000000_',2i2.2)
-     open(10,file=fname//'.wav',access='stream',status='unknown')
-
-     if(snrdb.lt.90) then
-        do i=1,npts
-           dat(i)=gran()
-        enddo
-     else
-        dat(1:npts)=0.
-     endif
-
-     if(msg0.ne.'                      ') then
-        call genjt9(message,msgsent,i4tone) !Encode message into tone #s
-     endif
-
-     rewind 12
-     do isig=1,nsigs                            !Loop over multiple signals
-
-        if(msg0.eq.'                      ') then
-           read(12,1004) message                !Use pre-generated message texts
-1004       format(a22)
-           call genjt9(message,msgsent,i4tone)
-        endif
-
-        f=f0
-        if(nsigs.gt.1) f=f0 - 0.5d0*fspan + fspan*(isig-1.d0)/(nsigs-1.d0)
-        snrdbx=snrdb 
-!        snrdbx=snrdb + (ifile-1)*4.0
-        sig=10.0**(0.05*snrdbx)
-        write(*,1020) ifile,isig,f,snrdbx,msgsent
-1020    format(i3,i4,f10.3,f7.1,2x,a22)
-
-        phi=0.
-        baud=12000.d0/nsps
-        k=12000                             !Start audio at t = 1.0 s
-!        f1=0.0001 * (ifile-1)
-        f1=0.
-!        print*,ifile-1,f1
-        dphi2=0.
-        ddphi2=twopi*f1*dt/60.0
-        do isym=1,85
-           freq=f + i4tone(isym)*baud
-           if(msg0(1:3).eq.'sin') freq=sinfreq
-           dphi=twopi*freq*dt + dphi2
-           do i=1,nsps
-              phi=phi + dphi
-              dphi2=dphi2 + ddphi2
-              if(phi.lt.-twopi) phi=phi+twopi
-              if(phi.gt.twopi) phi=phi-twopi
-              xphi=phi
-              k=k+1
-              dat(k)=dat(k) + sig*sin(xphi)  !Use lookup table for i*2 sin(x) ?
-           enddo
-        enddo
-     enddo
-
-     do i=1,npts
-        iwave(i)=nint(rms*dat(i))
-     enddo
-
-     write(10) ihdr,iwave(1:npts)
-     close(10)
-
-! We're done!  Now decode the data symbols from i4tone, as a test.
-     if(msg0.ne.'                      ') then
-        j=0
-        do i=1,85
-           if(isync(i).eq.1) cycle
-           j=j+1
-           i4DataSymNoGray(j)=igray(i4tone(i)-1,-1)
-        enddo
-        call unpackbits(i4DataSymNoGray,69,3,i1ScrambledBits)
-        call interleave9(i1ScrambledBits,-1,i1Bits)
- 
-        do i=1,206
-           i4=-10
-           if(i1Bits(i).eq.1) i4=10
-           i4=i4+128
-           i1SoftSymbols(i)=i1
-        enddo
-        limit=1000
-        call decode9(i1SoftSymbols,limit,nlim,msg)
-        if(msg.ne.msg0) print*,'Decode error: ',msg0,' ',msg
-     endif
-  enddo
-
-999 end program jt9sim

Deleted: branches/wsprx/lib/jt9test.f90
===================================================================
--- branches/wsprx/lib/jt9test.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/jt9test.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,182 +0,0 @@
-program jt9test
-
-! Decoder for JT9.  Can run stand-alone, reading data from *.wav files;
-! or as the back end of wsjt-x, with data placed in a shared memory region.
-
-! NB: For unknown reason, ***MUST*** be compiled by g95 with -O0 !!!
-
-  character*80 arg,infile
-  parameter (NMAX=1800*12000)        !Total sample intervals per 30 minutes
-  parameter (NDMAX=1800*1500)        !Sample intervals at 1500 Hz rate
-  parameter (NSMAX=22000)            !Max length of saved spectra
-  integer*4 ihdr(11)
-  real*4 s(NSMAX)
-  real*4 ccfred(NSMAX)
-  logical*1 lstrong(0:1023)
-  integer*1 i1SoftSymbols(207)
-  character*22 msg
-  character*33 line
-  integer*2 id2
-  complex c0
-  complex c1(0:2700000)
-  common/jt9com/ss(184,NSMAX),savg(NSMAX),c0(NDMAX),id2(NMAX),nutc,ndiskdat,  &amp;
-       ntr,mousefqso,newdat,nfa,nfb,ntol,kin,nzhsym,nsynced,ndecoded
-  common/tracer/limtrace,lu
-
-  nargs=iargc()
-  if(nargs.lt.1) then
-     print*,'Usage: jt9 TRperiod file1 [file2 ...]'
-     print*,'       Reads data from *.wav files.'
-     print*,''
-     print*,'       jt9 -s'
-     print*,'       Gets data from shared memory region.'
-     go to 999
-  endif
-  call getarg(1,arg)
-  if(arg(1:2).eq.'-s') then
-!     call jt9a
-!    call ftnquit
-     go to 999
-  endif
-  read(arg,*) ntrperiod
-
-  ifile1=2
-
-  limtrace=0
-  lu=12
-  nfa=1000
-  nfb=2000
-  ntol=500
-  nfqso=1500
-  newdat=1
-  nb=0
-  nbslider=100
-  limit=20000
-  ndiskdat=1
-
-  do ifile=ifile1,nargs
-     call getarg(ifile,infile)
-     open(10,file=infile,access='stream',status='old',err=998)
-     read(10) ihdr
-     i1=index(infile,'.wav')
-     read(infile(i1-4:i1-1),*,err=1) nutc0
-     go to 2
-1    nutc0=0
-2    nsps=0
-     if(ntrperiod.eq.1)  then
-        nsps=6912
-        nzhsym=181
-     else if(ntrperiod.eq.2)  then
-        nsps=15360
-        nzhsym=178
-     else if(ntrperiod.eq.5)  then
-        nsps=40960
-        nzhsym=172
-     else if(ntrperiod.eq.10) then
-        nsps=82944
-        nzhsym=171
-     else if(ntrperiod.eq.30) then
-        nsps=252000
-        nzhsym=167
-     endif
-     if(nsps.eq.0) stop 'Error: bad TRperiod'
-
-     kstep=nsps/2
-     tstep=kstep/12000.0
-     k=0
-     nhsym0=-999
-     npts=(60*ntrperiod-6)*12000
-     if(ifile.eq.ifile1) then
-        open(12,file='timer.out',status='unknown')
-        call timer('jt9     ',0)
-     endif
-
-!     do i=1,npts
-!        id2(i)=100.0*sin(6.283185307*1600.0*i/12000.0)
-!     enddo
-
-     do iblk=1,npts/kstep
-        k=iblk*kstep
-        call timer('read_wav',0)
-        read(10,end=10) id2(k-kstep+1:k)
-        call timer('read_wav',1)
-
-        nhsym=(k-2048)/kstep
-        if(nhsym.ge.1 .and. nhsym.ne.nhsym0) then
-! Emit signal readyForFFT
-           ingain=0
-           call timer('symspec ',0)
-           call symspec(k,ntrperiod,nsps,ingain,nb,nbslider,pxdb,   &amp;
-                s,ccfred,df3,ihsym,nzap,slimit,lstrong,npts8)
-           call timer('symspec ',1)
-           nhsym0=nhsym
-           if(ihsym.ge.184) go to 10
-        endif
-     enddo
-10   close(10)
-
-     nsps8=nsps/8
-     iz=1000.0/df3
-     nutc=nutc0
-
-     call timer('sync9   ',0)
-     call sync9(ss,nzhsym,tstep,df3,ntol,nfqso,ccfred,ia,ib,ipk) !Get sync, freq
-     call timer('sync9   ',1)
-
-     fgood=0.
-     df8=1500.0/(nsps/8)
-     sbest=0.
-     do i=ia,ib
-        f=(i-1)*df3
-        if((i.eq.ipk .or. ccfred(i).ge.3.0) .and. f.gt.fgood+10.0*df8) then
-
-           call timer('test9   ',0)
-           fpk=1000.0 + df3*(i-1)
-           c1(0:npts8-1)=conjg(c0(1:npts8))
-           call test9(c1,npts8,nsps8,fpk,syncpk,snrdb,xdt,freq,drift,   &amp;
-                i1SoftSymbols)
-           call timer('test9   ',1)
-
-           call timer('decode9 ',0)
-           call decode9(i1SoftSymbols,limit,nlim,msg)
-           call timer('decode9 ',1)
-           snr=snrdb
-           sync=syncpk - 2.0
-           if(sync.lt.0.0) sync=0.0
-           nsync=sync
-           if(nsync.gt.10) nsync=10
-           nsnr=nint(snr)
-           width=0.0
-
-           if(sync.gt.sbest .and. fgood.eq.0.0) then
-              sbest=sync
-              write(line,1010) nutc,nsync,nsnr,xdt,1000.0+fpk,width
-              if(nsync.gt.0) nsynced=1
-           endif
-
-           if(msg.ne.'                      ') then
-              write(*,1010) nutc,nsync,nsnr,xdt,freq,drift,msg
-1010          format(i4.4,i4,i5,f6.1,f8.2,f6.2,3x,a22)
-              fgood=f
-              nsynced=1
-              ndecoded=1
-           endif
-        endif
-     enddo
-
-     if(fgood.eq.0.0) then
-        write(*,1020) line
-1020    format(a33)
-     endif
-
-  enddo
-
-  call timer('jt9     ',1)
-  call timer('jt9     ',101)
-!  call ftnquit
-  go to 999
-
-998 print*,'Cannot open file:'
-  print*,infile
-
-999 end program jt9test

Deleted: branches/wsprx/lib/k2grid.f
===================================================================
--- branches/wsprx/lib/k2grid.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/k2grid.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,12 +0,0 @@
-      subroutine k2grid(k,grid)
-      character grid*6
-
-      nlong=2*mod((k-1)/5,90)-179
-      if(k.gt.450) nlong=nlong+180
-      nlat=mod(k-1,5)+ 85
-      dlat=nlat
-      dlong=nlong
-      call deg2grid(dlong,dlat,grid)
-
-      return
-      end

Added: branches/wsprx/lib/mept162.f
===================================================================
--- branches/wsprx/lib/mept162.f	                        (rev 0)
+++ branches/wsprx/lib/mept162.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,112 @@
+      subroutine mept162(outfile,appdir,nappdir,f0,ncmdline,id,npts,
+     +  nbfo,ierr)
+
+C  Orchestrates the process of finding, synchronizing, and decoding 
+C  WSPR signals.
+
+      integer*2 id(npts)
+      character*22 message
+      character*80 outfile,appdir,alltxt
+      character*11 datetime
+      character cdate*8,ctime*10
+      real*8 f0,freq,tsec
+      real ps(-256:256)
+      real sstf(5,275)
+      real a(5)
+      complex c2(65536)
+      complex c3(45000),c4(45000)
+
+C  Mix from &quot;nbfo&quot; +/- 100 Hz to baseband, and downsample by 1/32
+      call mix162(id,npts,nbfo,c2,jz,ps)
+
+      if(ncmdline.eq.0) then
+C  Compute pixmap.dat
+         call spec162(c2,jz,appdir,nappdir)
+      endif
+
+C  Look for sync patterns, get DF and DT
+      call sync162(c2,jz,ps,sstf,kz)
+      ierr = 0
+      if(kz.eq.0) go to 900
+      if (kz.gt.275 .or. kz.lt.0) then
+        call getutc(cdate,ctime,tsec)
+
+        call cs_lock('mept162')
+        write(*,1000) ctime,kz
+ 1000   format('Time ',a8,'. Error from sync162: kz is',i10)
+        call cs_unlock
+
+        ierr = 1
+        return
+      endif
+      do k=1,kz
+         snrsync=sstf(1,k)
+         snrx=sstf(2,k)
+         dtx=sstf(3,k)
+         dfx=sstf(4,k)
+         drift=sstf(5,k)
+         a(1)=-dfx
+         a(2)=-0.5*drift
+         a(3)=0.
+         call twkfreq(c2,c3,jz,a)                    !Remove drift
+
+         minsync=1                                   !####
+         nsync=nint(snrsync)
+         nsnrx=nint(snrx)
+         if(nsnrx.lt.-33) nsnrx=-33
+         if(nsync.lt.0) nsync=0
+         freq=f0 + 1.d-6*(dfx+nbfo)
+         message='                      '
+         if(nsync.ge.minsync .and. nsnrx.ge.-33) then      !### -31 dB limit?
+
+            dt=1.0/375
+            do idt=0,128
+               ii=(idt+1)/2
+               if(mod(idt,2).eq.1) ii=-ii
+               i1=nint((dtx+2.0)/dt) + ii !Start index for synced symbols
+               if(i1.ge.1) then
+!  Fix this earlier!
+                  c4(1:jz-i1+1)=c3(i1:)
+                  c4(jz-i1+2:)=0.
+               else
+                  c4(:-i1+1)=0.
+                  c4(-i1+2:jz)=c3(:i1+jz-1)
+                  if(jz.lt.45000) c4(jz:)=0.
+               endif
+               call decode162(c4,45000,message,ncycles,metric,nerr)
+               if(message(1:6).ne.'      ' .and. 
+     +            message(1:6).ne.'000AAA' .and.
+     +            index(message,'A000AA').le.0) go to 23
+            enddo
+            go to 24
+
+ 23         i2=index(outfile,'.wav')-1
+            if(i2.le.0) i2=index(outfile,'.WAV')-1
+            datetime=outfile(max(1,i2-10):i2)
+            datetime(7:7)=' '
+            nf1=nint(-a(2))
+            alltxt=appdir(:nappdir)//'/ALL_WSPR.TXT'
+
+            call cs_lock('mept162a')
+            if(ncmdline.eq.0) then
+               open(13,file=alltxt,status='unknown',position='append')
+               write(13,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,
+     +           ncycles/81,ii
+               close(13)
+            else
+               write(*,1008) datetime(8:11),nsnrx,dtx,freq,message
+ 1008          format(a4,i4,f5.1,f11.6,2x,a22,i3,i6,i5)
+            endif
+            write(14,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,
+     +           ncycles/81,ii
+ 1010       format(a11,i4,i4,f5.1,f11.6,2x,a22,i3,i6,i5)
+            call flush(14)
+            i1=index(message,' ')
+            call cs_unlock
+
+         endif
+ 24      continue
+      enddo
+
+ 900  return
+      end

Deleted: branches/wsprx/lib/met8.21
===================================================================
--- branches/wsprx/lib/met8.21	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/met8.21	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,256 +0,0 @@
-  -25.6   1.000  -9.966 1.000000 0.000000
-  -25.4   1.000  -9.966 1.000000 0.000000
-  -25.2   1.000  -9.966 1.000000 0.000000
-  -25.0   1.000  -9.966 1.000000 0.000000
-  -24.8   1.000  -9.966 1.000000 0.000000
-  -24.6   1.000  -9.966 1.000000 0.000000
-  -24.4   1.000  -9.966 1.000000 0.000000
-  -24.2   1.000  -9.966 1.000000 0.000000
-  -24.0   1.000  -9.966 1.000000 0.000000
-  -23.8   1.000  -9.966 1.000000 0.000000
-  -23.6   1.000  -9.966 1.000000 0.000000
-  -23.4   1.000  -9.966 1.000000 0.000000
-  -23.2   1.000  -9.966 1.000000 0.000000
-  -23.0   1.000  -9.966 1.000000 0.000000
-  -22.8   1.000  -9.966 1.000000 0.000000
-  -22.6   1.000  -9.966 1.000000 0.000000
-  -22.4   1.000  -9.966 1.000000 0.000000
-  -22.2   1.000  -9.966 1.000000 0.000000
-  -22.0   1.000  -9.966 1.000000 0.000000
-  -21.8   1.000  -9.966 1.000000 0.000000
-  -21.6   1.000  -9.966 1.000000 0.000000
-  -21.4   1.000  -9.966 1.000000 0.000000
-  -21.2   1.000  -9.966 1.000000 0.000000
-  -21.0   1.000  -9.966 1.000000 0.000000
-  -20.8   1.000  -9.966 1.000000 0.000000
-  -20.6   1.000  -9.966 1.000000 0.000000
-  -20.4   1.000  -9.966 1.000000 0.000000
-  -20.2   1.000  -9.966 1.000000 0.000000
-  -20.0   1.000  -9.966 1.000000 0.000000
-  -19.8   1.000  -9.966 1.000000 0.000000
-  -19.6   1.000  -9.966 1.000000 0.000000
-  -19.4   1.000  -9.966 1.000000 0.000000
-  -19.2   1.000  -9.966 1.000000 0.000000
-  -19.0   1.000  -9.966 1.000000 0.000000
-  -18.8   1.000  -9.966 1.000000 0.000000
-  -18.6   1.000  -9.966 1.000000 0.000000
-  -18.4   1.000  -9.966 1.000000 0.000000
-  -18.2   1.000  -9.966 1.000000 0.000000
-  -18.0   1.000  -9.966 1.000000 0.000000
-  -17.8   1.000  -9.966 1.000000 0.000000
-  -17.6   1.000  -9.966 1.000000 0.000000
-  -17.4   1.000  -9.966 1.000000 0.000000
-  -17.2   1.000  -9.966 1.000000 0.000000
-  -17.0   1.000  -9.966 1.000000 0.000000
-  -16.8   1.000  -9.966 1.000000 0.000000
-  -16.6   1.000  -9.966 1.000000 0.000000
-  -16.4   1.000  -9.966 1.000000 0.000000
-  -16.2   1.000  -9.966 1.000000 0.000000
-  -16.0   0.988  -5.858 0.991379 0.008621
-  -15.8   1.000  -9.966 1.000000 0.000000
-  -15.6   0.991  -6.313 0.993711 0.006289
-  -15.4   0.993  -6.629 0.994950 0.005051
-  -15.2   1.000  -9.966 1.000000 0.000000
-  -15.0   0.995  -7.055 0.996241 0.003759
-  -14.8   1.000  -9.966 1.000000 0.000000
-  -14.6   0.991  -6.371 0.993958 0.006042
-  -14.4   1.000  -9.966 1.000000 0.000000
-  -14.2   0.991  -6.313 0.993711 0.006289
-  -14.0   0.992  -6.426 0.994186 0.005814
-  -13.8   0.991  -6.288 0.993600 0.006400
-  -13.6   0.990  -6.113 0.992775 0.007225
-  -13.4   0.990  -6.152 0.992968 0.007032
-  -13.2   0.992  -6.534 0.994606 0.005394
-  -13.0   0.996  -7.332 0.996898 0.003102
-  -12.8   0.990  -6.184 0.993121 0.006879
-  -12.6   0.994  -7.016 0.996136 0.003864
-  -12.4   0.993  -6.658 0.995049 0.004950
-  -12.2   0.991  -6.369 0.993953 0.006047
-  -12.0   0.992  -6.559 0.994699 0.005301
-  -11.8   0.989  -6.002 0.992197 0.007803
-  -11.6   0.991  -6.304 0.993671 0.006329
-  -11.4   0.987  -5.826 0.991188 0.008812
-  -11.2   0.985  -5.632 0.989919 0.010081
-  -11.0   0.989  -5.995 0.992162 0.007838
-  -10.8   0.984  -5.544 0.989284 0.010717
-  -10.6   0.983  -5.377 0.987966 0.012034
-  -10.4   0.979  -5.108 0.985502 0.014498
-  -10.2   0.977  -4.954 0.983869 0.016131
-  -10.0   0.971  -4.652 0.980118 0.019882
-   -9.8   0.975  -4.870 0.982896 0.017104
-   -9.6   0.974  -4.822 0.982324 0.017676
-   -9.4   0.970  -4.608 0.979490 0.020510
-   -9.2   0.970  -4.623 0.979702 0.020298
-   -9.0   0.970  -4.621 0.979679 0.020321
-   -8.8   0.967  -4.472 0.977465 0.022535
-   -8.6   0.962  -4.261 0.973915 0.026085
-   -8.4   0.960  -4.186 0.972538 0.027462
-   -8.2   0.957  -4.098 0.970806 0.029194
-   -8.0   0.956  -4.062 0.970061 0.029939
-   -7.8   0.953  -3.975 0.968209 0.031791
-   -7.6   0.942  -3.677 0.960918 0.039082
-   -7.4   0.946  -3.768 0.963301 0.036699
-   -7.2   0.937  -3.550 0.957308 0.042692
-   -7.0   0.933  -3.463 0.954652 0.045348
-   -6.8   0.929  -3.377 0.951866 0.048134
-   -6.6   0.920  -3.212 0.946042 0.053958
-   -6.4   0.917  -3.164 0.944202 0.055798
-   -6.2   0.911  -3.058 0.939981 0.060019
-   -6.0   0.903  -2.939 0.934818 0.065182
-   -5.8   0.895  -2.829 0.929642 0.070358
-   -5.6   0.884  -2.690 0.922540 0.077459
-   -5.4   0.877  -2.608 0.917972 0.082028
-   -5.2   0.869  -2.531 0.913509 0.086491
-   -5.0   0.858  -2.411 0.905967 0.094033
-   -4.8   0.846  -2.301 0.898525 0.101475
-   -4.6   0.834  -2.201 0.891269 0.108731
-   -4.4   0.821  -2.096 0.883085 0.116915
-   -4.2   0.806  -1.992 0.874340 0.125660
-   -4.0   0.790  -1.882 0.864307 0.135693
-   -3.8   0.775  -1.790 0.855445 0.144555
-   -3.6   0.755  -1.678 0.843726 0.156274
-   -3.4   0.737  -1.587 0.833538 0.166462
-   -3.2   0.713  -1.473 0.819841 0.180159
-   -3.0   0.691  -1.376 0.807345 0.192655
-   -2.8   0.667  -1.280 0.794093 0.205907
-   -2.6   0.640  -1.181 0.779404 0.220596
-   -2.4   0.612  -1.084 0.764178 0.235822
-   -2.2   0.581  -0.987 0.747708 0.252292
-   -2.0   0.548  -0.895 0.731037 0.268963
-   -1.8   0.510  -0.796 0.712035 0.287965
-   -1.6   0.472  -0.706 0.693474 0.306526
-   -1.4   0.425  -0.606 0.671514 0.328486
-   -1.2   0.378  -0.514 0.649948 0.350053
-   -1.0   0.328  -0.425 0.627452 0.372548
-   -0.8   0.274  -0.338 0.604549 0.395451
-   -0.6   0.212  -0.249 0.579151 0.420849
-   -0.4   0.146  -0.163 0.553389 0.446611
-   -0.2   0.075  -0.079 0.526648 0.473352
-    0.0   0.000   0.000 0.500000 0.500000
-    0.2  -0.079   0.075 0.473352 0.526648
-    0.4  -0.163   0.146 0.446611 0.553389
-    0.6  -0.249   0.212 0.420849 0.579151
-    0.8  -0.338   0.274 0.395451 0.604549
-    1.0  -0.425   0.328 0.372548 0.627452
-    1.2  -0.514   0.378 0.350053 0.649948
-    1.4  -0.606   0.425 0.328486 0.671514
-    1.6  -0.706   0.472 0.306526 0.693474
-    1.8  -0.796   0.510 0.287965 0.712035
-    2.0  -0.895   0.548 0.268963 0.731037
-    2.2  -0.987   0.581 0.252292 0.747708
-    2.4  -1.084   0.612 0.235822 0.764178
-    2.6  -1.181   0.640 0.220596 0.779404
-    2.8  -1.280   0.667 0.205907 0.794093
-    3.0  -1.376   0.691 0.192655 0.807345
-    3.2  -1.473   0.713 0.180159 0.819841
-    3.4  -1.587   0.737 0.166462 0.833538
-    3.6  -1.678   0.755 0.156274 0.843726
-    3.8  -1.790   0.775 0.144555 0.855445
-    4.0  -1.882   0.790 0.135693 0.864307
-    4.2  -1.992   0.806 0.125660 0.874340
-    4.4  -2.096   0.821 0.116915 0.883085
-    4.6  -2.201   0.834 0.108731 0.891269
-    4.8  -2.301   0.846 0.101475 0.898525
-    5.0  -2.411   0.858 0.094033 0.905967
-    5.2  -2.531   0.869 0.086491 0.913509
-    5.4  -2.608   0.877 0.082028 0.917972
-    5.6  -2.690   0.884 0.077459 0.922540
-    5.8  -2.829   0.895 0.070358 0.929642
-    6.0  -2.939   0.903 0.065182 0.934818
-    6.2  -3.058   0.911 0.060019 0.939981
-    6.4  -3.164   0.917 0.055798 0.944202
-    6.6  -3.212   0.920 0.053958 0.946042
-    6.8  -3.377   0.929 0.048134 0.951866
-    7.0  -3.463   0.933 0.045348 0.954652
-    7.2  -3.550   0.937 0.042692 0.957308
-    7.4  -3.768   0.946 0.036699 0.963301
-    7.6  -3.677   0.942 0.039082 0.960918
-    7.8  -3.975   0.953 0.031791 0.968210
-    8.0  -4.062   0.956 0.029939 0.970061
-    8.2  -4.098   0.957 0.029194 0.970806
-    8.4  -4.186   0.960 0.027462 0.972538
-    8.6  -4.261   0.962 0.026085 0.973915
-    8.8  -4.472   0.967 0.022535 0.977465
-    9.0  -4.621   0.970 0.020321 0.979679
-    9.2  -4.623   0.970 0.020298 0.979702
-    9.4  -4.608   0.970 0.020510 0.979490
-    9.6  -4.822   0.974 0.017676 0.982324
-    9.8  -4.870   0.975 0.017104 0.982896
-   10.0  -4.652   0.971 0.019882 0.980118
-   10.2  -4.954   0.977 0.016131 0.983869
-   10.4  -5.108   0.979 0.014498 0.985502
-   10.6  -5.377   0.983 0.012034 0.987966
-   10.8  -5.544   0.984 0.010717 0.989284
-   11.0  -5.995   0.989 0.007838 0.992162
-   11.2  -5.632   0.985 0.010081 0.989919
-   11.4  -5.826   0.987 0.008812 0.991188
-   11.6  -6.304   0.991 0.006329 0.993671
-   11.8  -6.002   0.989 0.007803 0.992197
-   12.0  -6.559   0.992 0.005301 0.994699
-   12.2  -6.369   0.991 0.006047 0.993953
-   12.4  -6.658   0.993 0.004950 0.995049
-   12.6  -7.016   0.994 0.003864 0.996136
-   12.8  -6.184   0.990 0.006879 0.993121
-   13.0  -7.332   0.996 0.003102 0.996898
-   13.2  -6.534   0.992 0.005394 0.994606
-   13.4  -6.152   0.990 0.007032 0.992968
-   13.6  -6.113   0.990 0.007225 0.992775
-   13.8  -6.288   0.991 0.006400 0.993600
-   14.0  -6.426   0.992 0.005814 0.994186
-   14.2  -6.313   0.991 0.006289 0.993711
-   14.4  -9.966   1.000 0.000000 1.000000
-   14.6  -6.371   0.991 0.006042 0.993958
-   14.8  -9.966   1.000 0.000000 1.000000
-   15.0  -7.055   0.995 0.003759 0.996241
-   15.2  -9.966   1.000 0.000000 1.000000
-   15.4  -6.629   0.993 0.005051 0.994949
-   15.6  -6.313   0.991 0.006289 0.993711
-   15.8  -9.966   1.000 0.000000 1.000000
-   16.0  -5.858   0.988 0.008621 0.991379
-   16.2  -9.966   1.000 0.000000 1.000000
-   16.4  -9.966   1.000 0.000000 1.000000
-   16.6  -9.966   1.000 0.000000 1.000000
-   16.8  -9.966   1.000 0.000000 1.000000
-   17.0  -9.966   1.000 0.000000 1.000000
-   17.2  -9.966   1.000 0.000000 1.000000
-   17.4  -9.966   1.000 0.000000 1.000000
-   17.6  -9.966   1.000 0.000000 1.000000
-   17.8  -9.966   1.000 0.000000 1.000000
-   18.0  -9.966   1.000 0.000000 1.000000
-   18.2  -9.966   1.000 0.000000 1.000000
-   18.4  -9.966   1.000 0.000000 1.000000
-   18.6  -9.966   1.000 0.000000 1.000000
-   18.8  -9.966   1.000 0.000000 1.000000
-   19.0  -9.966   1.000 0.000000 1.000000
-   19.2  -9.966   1.000 0.000000 1.000000
-   19.4  -9.966   1.000 0.000000 1.000000
-   19.6  -9.966   1.000 0.000000 1.000000
-   19.8  -9.966   1.000 0.000000 1.000000
-   20.0  -9.966   1.000 0.000000 1.000000
-   20.2  -9.966   1.000 0.000000 1.000000
-   20.4  -9.966   1.000 0.000000 1.000000
-   20.6  -9.966   1.000 0.000000 1.000000
-   20.8  -9.966   1.000 0.000000 1.000000
-   21.0  -9.966   1.000 0.000000 1.000000
-   21.2  -9.966   1.000 0.000000 1.000000
-   21.4  -9.966   1.000 0.000000 1.000000
-   21.6  -9.966   1.000 0.000000 1.000000
-   21.8  -9.966   1.000 0.000000 1.000000
-   22.0  -9.966   1.000 0.000000 1.000000
-   22.2  -9.966   1.000 0.000000 1.000000
-   22.4  -9.966   1.000 0.000000 1.000000
-   22.6  -9.966   1.000 0.000000 1.000000
-   22.8  -9.966   1.000 0.000000 1.000000
-   23.0  -9.966   1.000 0.000000 1.000000
-   23.2  -9.966   1.000 0.000000 1.000000
-   23.4  -9.966   1.000 0.000000 1.000000
-   23.6  -9.966   1.000 0.000000 1.000000
-   23.8  -9.966   1.000 0.000000 1.000000
-   24.0  -9.966   1.000 0.000000 1.000000
-   24.2  -9.966   1.000 0.000000 1.000000
-   24.4  -9.966   1.000 0.000000 1.000000
-   24.6  -9.966   1.000 0.000000 1.000000
-   24.8  -9.966   1.000 0.000000 1.000000
-   25.0  -9.966   1.000 0.000000 1.000000
-   25.2  -9.966   1.000 0.000000 1.000000
-   25.4  -9.966   1.000 0.000000 1.000000

Added: branches/wsprx/lib/mix162.f
===================================================================
--- branches/wsprx/lib/mix162.f	                        (rev 0)
+++ branches/wsprx/lib/mix162.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,56 @@
+      subroutine mix162(id,npts,nbfo,c2,jz,ps)
+
+C  Mix from &quot;nbfo&quot; +/- 100 Hz to baseband, and downsample by 1/32
+
+      parameter (NFFT1=2*1024*1024)
+      parameter (NFFT2=NFFT1/32)
+      parameter (NH2=NFFT2/2)
+      integer*2 id(npts)
+      real x(NFFT1)
+      real ps(-256:256)
+      real*8 df
+      complex c(0:NFFT1)
+      complex c2(0:65535)
+      equivalence (x,c)
+
+C  Load data into real array x; pad with zeros up to nfft.
+      fac=1.e-4
+      do i=1,npts
+         x(i)=fac*id(i)
+      enddo
+      call zero(x(npts+1),NFFT1-npts)
+
+C  Do the real-to-complex FFT
+      call xfft(x,NFFT1)
+
+      df=12000.d0/NFFT1
+      i0=nint(nbfo/df)
+      ia=i0-NH2 + 1
+      ib=i0+NH2
+
+      k=-257
+      do i=ia-64,ib,128
+         k=k+1
+         sq=0.
+         do n=0,127
+            sq=sq + real(c(i+n))**2 + aimag(c(i+n))**2
+         enddo
+         ps(k)=4.085e-8*sq
+      enddo
+
+      do i=0,NFFT2-1
+         j=i0 + i
+         if(i.gt.NH2) j=j-NFFT2
+         c2(i)=c(j)
+      enddo
+
+      call four2a(c2,NFFT2,1,1,1)        !Return to time domain
+
+      fac=1.e-5
+      jz=npts/32
+      do i=0,jz-1
+         c2(i)=fac*c2(i)
+      enddo
+
+      return
+      end

Deleted: branches/wsprx/lib/msgs.txt
===================================================================
--- branches/wsprx/lib/msgs.txt	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/msgs.txt	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,60 +0,0 @@
-W1AAA K2BBB EM00
-W2CCC K3DDD EM01
-W3EEE K4FFF EM02
-W5GGG K6HHH EM03
-W7III K8JJJ EM04
-W9KKK K0LLL EM05
-G0MMM F1NNN JN06
-G2OOO F3PPP JN07
-G4QQQ F5RRR JN08
-G6SSS F7TTT JN09
-W1XAA K2XBB EM10
-W2XCC K3XDD EM11
-W3XEE K4XFF EM12
-W5XGG K6XHH EM13
-W7XII K8XJJ EM14
-W9XKK K0XLL EM15
-G0XMM F1XNN JN16
-G2XOO F3XPP JN17
-G4XQQ F5XRR JN18
-G6XSS F7XTT JN19
-W1YAA K2YBB EM20
-W2YCC K3YDD EM21
-W3YEE K4YFF EM22
-W5YGG K6YHH EM23
-W7YII K8YJJ EM24
-W9YKK K0YLL EM25
-G0YMM F1YNN JN26
-G2YOO F3YPP JN27
-G4YQQ F5YRR JN28
-G6YSS F7YTT JN29
-W1ZAA K2ZBB EM30
-W2ZCC K3ZDD EM31
-W3ZEE K4ZFF EM32
-W5ZGG K6ZHH EM33
-W7ZII K8ZJJ EM34
-W9ZKK K0ZLL EM35
-G0ZMM F1ZNN JN36
-G2ZOO F3ZPP JN37
-G4ZQQ F5ZRR JN38
-G6ZSS F7ZTT JN39
-W1AXA K2BXB EM40
-W2CXC K3DXD EM41
-W3EXE K4FXF EM42
-W5GXG K6HXH EM43
-W7IXI K8JXJ EM44
-W9KXK K0LXL EM45
-G0MXM F1NXN JN46
-G2OXO F3PXP JN47
-G4QXQ F5RXR JN48
-G6SXS F7TXT JN49
-W1AYA K2BYB EM50
-W2CYC K3DYD EM51
-W3EYE K4FYF EM52
-W5GYG K6HYH EM53
-W7IYI K8JYJ EM54
-W9KYK K0LYL EM55
-G0MYM F1NYN JN56
-G2OYO F3PYP JN57
-G4QYQ F5RYR JN58
-G6SYS F7TYT JN59

Deleted: branches/wsprx/lib/n2grid.f90
===================================================================
--- branches/wsprx/lib/n2grid.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/n2grid.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,14 +0,0 @@
-subroutine n2grid(n,grid)
-  character*4 grid
-
-  if(n.gt.-31 .or. n.lt.-70) stop 'Error in n2grid'
-  i=-(n+31)                           !NB: 0 &lt;= i &lt;= 39
-  i1=i/10
-  i2=mod(i,10)
-  grid(1:1)=char(ichar('A')+i1)
-  grid(2:2)='A'
-  grid(3:3)=char(ichar('0')+i2)
-  grid(4:4)='0'
-
-  return
-end subroutine n2grid

Deleted: branches/wsprx/lib/nchar.f
===================================================================
--- branches/wsprx/lib/nchar.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/nchar.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,23 +0,0 @@
-      function nchar(c)
-
-C  Convert ascii number, letter, or space to 0-36 for callsign packing.
-
-      character c*1
-
-      n=0                                    !Silence compiler warning
-      if(c.ge.'0' .and. c.le.'9') then
-         n=ichar(c)-ichar('0')
-      else if(c.ge.'A' .and. c.le.'Z') then
-         n=ichar(c)-ichar('A') + 10
-      else if(c.ge.'a' .and. c.le.'z') then
-         n=ichar(c)-ichar('a') + 10
-      else if(c.ge.' ') then
-         n=36
-      else
-         Print*,'Invalid character in callsign ',c,' ',ichar(c)
-         stop
-      endif
-      nchar=n
-
-      return
-      end

Added: branches/wsprx/lib/nhash.c
===================================================================
--- branches/wsprx/lib/nhash.c	                        (rev 0)
+++ branches/wsprx/lib/nhash.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,353 @@
+/*
+-------------------------------------------------------------------------------
+lookup3.c, by Bob Jenkins, May 2006, Public Domain.
+
+These are functions for producing 32-bit hashes for hash table lookup.
+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() 
+are externally useful functions.  Routines to test the hash are included 
+if SELF_TEST is defined.  You can use this free for any purpose.  It's in
+the public domain.  It has no warranty.
+
+You probably want to use hashlittle().  hashlittle() and hashbig()
+hash byte arrays.  hashlittle() is is faster than hashbig() on
+little-endian machines.  Intel and AMD are little-endian machines.
+On second thought, you probably want hashlittle2(), which is identical to
+hashlittle() except it returns two 32-bit hashes for the price of one.  
+You could implement hashbig2() if you wanted but I haven't bothered here.
+
+If you want to find a hash of, say, exactly 7 integers, do
+  a = i1;  b = i2;  c = i3;
+  mix(a,b,c);
+  a += i4; b += i5; c += i6;
+  mix(a,b,c);
+  a += i7;
+  final(a,b,c);
+then use c as the hash value.  If you have a variable length array of
+4-byte integers to hash, use hashword().  If you have a byte array (like
+a character string), use hashlittle().  If you have several byte arrays, or
+a mix of things, see the comments above hashlittle().  
+
+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, 
+then mix those integers.  This is fast (you can do a lot more thorough
+mixing with 12*3 instructions on 3 integers than you can with 3 instructions
+on 1 byte), but shoehorning those bytes into integers efficiently is messy.
+-------------------------------------------------------------------------------
+*/
+#define SELF_TEST 1
+
+#include &lt;stdio.h&gt;      /* defines printf for tests */
+#include &lt;time.h&gt;       /* defines time_t for timings in the test */
+#ifdef Win32
+#include &quot;win_stdint.h&quot;	/* defines uint32_t etc */
+#else
+#include &lt;stdint.h&gt;	/* defines uint32_t etc */
+#endif
+//#include &lt;sys/param.h&gt;  /* attempt to define endianness */
+//#ifdef linux
+//# include &lt;endian.h&gt;    /* attempt to define endianness */
+//#endif
+
+#define HASH_LITTLE_ENDIAN 1
+
+#define hashsize(n) ((uint32_t)1&lt;&lt;(n))
+#define hashmask(n) (hashsize(n)-1)
+#define rot(x,k) (((x)&lt;&lt;(k)) | ((x)&gt;&gt;(32-(k))))
+
+/*
+-------------------------------------------------------------------------------
+mix -- mix 3 32-bit values reversibly.
+
+This is reversible, so any information in (a,b,c) before mix() is
+still in (a,b,c) after mix().
+
+If four pairs of (a,b,c) inputs are run through mix(), or through
+mix() in reverse, there are at least 32 bits of the output that
+are sometimes the same for one pair and different for another pair.
+This was tested for:
+* pairs that differed by one bit, by two bits, in any combination
+  of top bits of (a,b,c), or in any combination of bottom bits of
+  (a,b,c).
+* &quot;differ&quot; is defined as +, -, ^, or ~^.  For + and -, I transformed
+  the output delta to a Gray code (a^(a&gt;&gt;1)) so a string of 1's (as
+  is commonly produced by subtraction) look like a single 1-bit
+  difference.
+* the base values were pseudorandom, all zero but one bit set, or 
+  all zero plus a counter that starts at zero.
+
+Some k values for my &quot;a-=c; a^=rot(c,k); c+=b;&quot; arrangement that
+satisfy this are
+    4  6  8 16 19  4
+    9 15  3 18 27 15
+   14  9  3  7 17  3
+Well, &quot;9 15 3 18 27 15&quot; didn't quite get 32 bits diffing
+for &quot;differ&quot; defined as + with a one-bit base and a two-bit delta.  I
+used <A HREF="http://burtleburtle.net/bob/hash/avalanche.html">http://burtleburtle.net/bob/hash/avalanche.html</A> to choose 
+the operations, constants, and arrangements of the variables.
+
+This does not achieve avalanche.  There are input bits of (a,b,c)
+that fail to affect some output bits of (a,b,c), especially of a.  The
+most thoroughly mixed value is c, but it doesn't really even achieve
+avalanche in c.
+
+This allows some parallelism.  Read-after-writes are good at doubling
+the number of bits affected, so the goal of mixing pulls in the opposite
+direction as the goal of parallelism.  I did what I could.  Rotates
+seem to cost as much as shifts on every machine I could lay my hands
+on, and rotates are much kinder to the top and bottom bits, so I used
+rotates.
+-------------------------------------------------------------------------------
+*/
+#define mix(a,b,c) \
+{ \
+  a -= c;  a ^= rot(c, 4);  c += b; \
+  b -= a;  b ^= rot(a, 6);  a += c; \
+  c -= b;  c ^= rot(b, 8);  b += a; \
+  a -= c;  a ^= rot(c,16);  c += b; \
+  b -= a;  b ^= rot(a,19);  a += c; \
+  c -= b;  c ^= rot(b, 4);  b += a; \
+}
+
+/*
+-------------------------------------------------------------------------------
+final -- final mixing of 3 32-bit values (a,b,c) into c
+
+Pairs of (a,b,c) values differing in only a few bits will usually
+produce values of c that look totally different.  This was tested for
+* pairs that differed by one bit, by two bits, in any combination
+  of top bits of (a,b,c), or in any combination of bottom bits of
+  (a,b,c).
+* &quot;differ&quot; is defined as +, -, ^, or ~^.  For + and -, I transformed
+  the output delta to a Gray code (a^(a&gt;&gt;1)) so a string of 1's (as
+  is commonly produced by subtraction) look like a single 1-bit
+  difference.
+* the base values were pseudorandom, all zero but one bit set, or 
+  all zero plus a counter that starts at zero.
+
+These constants passed:
+ 14 11 25 16 4 14 24
+ 12 14 25 16 4 14 24
+and these came close:
+  4  8 15 26 3 22 24
+ 10  8 15 26 3 22 24
+ 11  8 15 26 3 22 24
+-------------------------------------------------------------------------------
+*/
+#define final(a,b,c) \
+{ \
+  c ^= b; c -= rot(b,14); \
+  a ^= c; a -= rot(c,11); \
+  b ^= a; b -= rot(a,25); \
+  c ^= b; c -= rot(b,16); \
+  a ^= c; a -= rot(c,4);  \
+  b ^= a; b -= rot(a,14); \
+  c ^= b; c -= rot(b,24); \
+}
+
+/*
+-------------------------------------------------------------------------------
+hashlittle() -- hash a variable-length key into a 32-bit value
+  k       : the key (the unaligned variable-length array of bytes)
+  length  : the length of the key, counting by bytes
+  initval : can be any 4-byte value
+Returns a 32-bit value.  Every bit of the key affects every bit of
+the return value.  Two keys differing by one or two bits will have
+totally different hash values.
+
+The best hash table sizes are powers of 2.  There is no need to do
+mod a prime (mod is sooo slow!).  If you need less than 32 bits,
+use a bitmask.  For example, if you need only 10 bits, do
+  h = (h &amp; hashmask(10));
+In which case, the hash table should have hashsize(10) elements.
+
+If you are hashing n strings (uint8_t **)k, do it like this:
+  for (i=0, h=0; i&lt;n; ++i) h = hashlittle( k[i], len[i], h);
+
+By Bob Jenkins, 2006.  <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">bob_jenkins at burtleburtle.net.</A>  You may use this
+code any way you wish, private, educational, or commercial.  It's free.
+
+Use for hash table lookup, or anything where one collision in 2^^32 is
+acceptable.  Do NOT use for cryptographic purposes.
+-------------------------------------------------------------------------------
+*/
+
+//uint32_t hashlittle( const void *key, size_t length, uint32_t initval)
+#ifdef STDCALL
+uint32_t __stdcall NHASH( const void *key, size_t *length0, uint32_t *initval0)
+#else
+uint32_t nhash_( const void *key, int *length0, uint32_t *initval0)
+#endif
+{
+  uint32_t a,b,c;                                          /* internal state */
+  size_t length;
+  uint32_t initval;
+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */
+
+  length=*length0;
+  initval=*initval0;
+
+  /* Set up the internal state */
+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;
+
+  u.ptr = key;
+  if (HASH_LITTLE_ENDIAN &amp;&amp; ((u.i &amp; 0x3) == 0)) {
+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */
+    const uint8_t  *k8;
+
+    k8=0;                                     //Silence compiler warning
+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
+    while (length &gt; 12)
+    {
+      a += k[0];
+      b += k[1];
+      c += k[2];
+      mix(a,b,c);
+      length -= 12;
+      k += 3;
+    }
+
+    /*----------------------------- handle the last (probably partial) block */
+    /* 
+     * &quot;k[2]&amp;0xffffff&quot; actually reads beyond the end of the string, but
+     * then masks off the part it's not allowed to read.  Because the
+     * string is aligned, the masked-off tail is in the same word as the
+     * rest of the string.  Every machine with memory protection I've seen
+     * does it on word boundaries, so is OK with this.  But VALGRIND will
+     * still catch it and complain.  The masking trick does make the hash
+     * noticably faster for short strings (like English words).
+     */
+#ifndef VALGRIND
+
+    switch(length)
+    {
+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;
+    case 11: c+=k[2]&amp;0xffffff; b+=k[1]; a+=k[0]; break;
+    case 10: c+=k[2]&amp;0xffff; b+=k[1]; a+=k[0]; break;
+    case 9 : c+=k[2]&amp;0xff; b+=k[1]; a+=k[0]; break;
+    case 8 : b+=k[1]; a+=k[0]; break;
+    case 7 : b+=k[1]&amp;0xffffff; a+=k[0]; break;
+    case 6 : b+=k[1]&amp;0xffff; a+=k[0]; break;
+    case 5 : b+=k[1]&amp;0xff; a+=k[0]; break;
+    case 4 : a+=k[0]; break;
+    case 3 : a+=k[0]&amp;0xffffff; break;
+    case 2 : a+=k[0]&amp;0xffff; break;
+    case 1 : a+=k[0]&amp;0xff; break;
+    case 0 : return c;              /* zero length strings require no mixing */
+    }
+
+#else /* make valgrind happy */
+
+    k8 = (const uint8_t *)k;
+    switch(length)
+    {
+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;
+    case 11: c+=((uint32_t)k8[10])&lt;&lt;16;  /* fall through */
+    case 10: c+=((uint32_t)k8[9])&lt;&lt;8;    /* fall through */
+    case 9 : c+=k8[8];                   /* fall through */
+    case 8 : b+=k[1]; a+=k[0]; break;
+    case 7 : b+=((uint32_t)k8[6])&lt;&lt;16;   /* fall through */
+    case 6 : b+=((uint32_t)k8[5])&lt;&lt;8;    /* fall through */
+    case 5 : b+=k8[4];                   /* fall through */
+    case 4 : a+=k[0]; break;
+    case 3 : a+=((uint32_t)k8[2])&lt;&lt;16;   /* fall through */
+    case 2 : a+=((uint32_t)k8[1])&lt;&lt;8;    /* fall through */
+    case 1 : a+=k8[0]; break;
+    case 0 : return c;
+    }
+
+#endif /* !valgrind */
+
+  } else if (HASH_LITTLE_ENDIAN &amp;&amp; ((u.i &amp; 0x1) == 0)) {
+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */
+    const uint8_t  *k8;
+
+    /*--------------- all but last block: aligned reads and different mixing */
+    while (length &gt; 12)
+    {
+      a += k[0] + (((uint32_t)k[1])&lt;&lt;16);
+      b += k[2] + (((uint32_t)k[3])&lt;&lt;16);
+      c += k[4] + (((uint32_t)k[5])&lt;&lt;16);
+      mix(a,b,c);
+      length -= 12;
+      k += 6;
+    }
+
+    /*----------------------------- handle the last (probably partial) block */
+    k8 = (const uint8_t *)k;
+    switch(length)
+    {
+    case 12: c+=k[4]+(((uint32_t)k[5])&lt;&lt;16);
+             b+=k[2]+(((uint32_t)k[3])&lt;&lt;16);
+             a+=k[0]+(((uint32_t)k[1])&lt;&lt;16);
+             break;
+    case 11: c+=((uint32_t)k8[10])&lt;&lt;16;     /* fall through */
+    case 10: c+=k[4];
+             b+=k[2]+(((uint32_t)k[3])&lt;&lt;16);
+             a+=k[0]+(((uint32_t)k[1])&lt;&lt;16);
+             break;
+    case 9 : c+=k8[8];                      /* fall through */
+    case 8 : b+=k[2]+(((uint32_t)k[3])&lt;&lt;16);
+             a+=k[0]+(((uint32_t)k[1])&lt;&lt;16);
+             break;
+    case 7 : b+=((uint32_t)k8[6])&lt;&lt;16;      /* fall through */
+    case 6 : b+=k[2];
+             a+=k[0]+(((uint32_t)k[1])&lt;&lt;16);
+             break;
+    case 5 : b+=k8[4];                      /* fall through */
+    case 4 : a+=k[0]+(((uint32_t)k[1])&lt;&lt;16);
+             break;
+    case 3 : a+=((uint32_t)k8[2])&lt;&lt;16;      /* fall through */
+    case 2 : a+=k[0];
+             break;
+    case 1 : a+=k8[0];
+             break;
+    case 0 : return c;                     /* zero length requires no mixing */
+    }
+
+  } else {                        /* need to read the key one byte at a time */
+    const uint8_t *k = (const uint8_t *)key;
+
+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
+    while (length &gt; 12)
+    {
+      a += k[0];
+      a += ((uint32_t)k[1])&lt;&lt;8;
+      a += ((uint32_t)k[2])&lt;&lt;16;
+      a += ((uint32_t)k[3])&lt;&lt;24;
+      b += k[4];
+      b += ((uint32_t)k[5])&lt;&lt;8;
+      b += ((uint32_t)k[6])&lt;&lt;16;
+      b += ((uint32_t)k[7])&lt;&lt;24;
+      c += k[8];
+      c += ((uint32_t)k[9])&lt;&lt;8;
+      c += ((uint32_t)k[10])&lt;&lt;16;
+      c += ((uint32_t)k[11])&lt;&lt;24;
+      mix(a,b,c);
+      length -= 12;
+      k += 12;
+    }
+
+    /*-------------------------------- last block: affect all 32 bits of (c) */
+    switch(length)                   /* all the case statements fall through */
+    {
+    case 12: c+=((uint32_t)k[11])&lt;&lt;24;
+    case 11: c+=((uint32_t)k[10])&lt;&lt;16;
+    case 10: c+=((uint32_t)k[9])&lt;&lt;8;
+    case 9 : c+=k[8];
+    case 8 : b+=((uint32_t)k[7])&lt;&lt;24;
+    case 7 : b+=((uint32_t)k[6])&lt;&lt;16;
+    case 6 : b+=((uint32_t)k[5])&lt;&lt;8;
+    case 5 : b+=k[4];
+    case 4 : a+=((uint32_t)k[3])&lt;&lt;24;
+    case 3 : a+=((uint32_t)k[2])&lt;&lt;16;
+    case 2 : a+=((uint32_t)k[1])&lt;&lt;8;
+    case 1 : a+=k[0];
+             break;
+    case 0 : return c;
+    }
+  }
+
+  final(a,b,c);
+  return c;
+}
+
+//uint32_t __stdcall NHASH(const void *key, size_t length, uint32_t initval)

Deleted: branches/wsprx/lib/noisegen.f90
===================================================================
--- branches/wsprx/lib/noisegen.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/noisegen.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,13 +0,0 @@
-subroutine noisegen(d4,nmax)
-
-  real*4 d4(4,nmax)
-
-  do i=1,nmax
-     d4(1,i)=gran()
-     d4(2,i)=gran()
-     d4(3,i)=gran()
-     d4(4,i)=gran()
-  enddo
-
-  return
-end subroutine noisegen

Added: branches/wsprx/lib/pack50.f
===================================================================
--- branches/wsprx/lib/pack50.f	                        (rev 0)
+++ branches/wsprx/lib/pack50.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,26 @@
+      subroutine pack50(n1,n2,dat)
+
+      integer*1 dat(11),i1
+
+      i1=iand(ishft(n1,-20),255)                !8 bits
+      dat(1)=i1
+      i1=iand(ishft(n1,-12),255)                 !8 bits
+      dat(2)=i1
+      i1=iand(ishft(n1, -4),255)                 !8 bits
+      dat(3)=i1
+      i1=16*iand(n1,15)+iand(ishft(n2,-18),15)   !4+4 bits
+      dat(4)=i1
+      i1=iand(ishft(n2,-10),255)                 !8 bits
+      dat(5)=i1
+      i1=iand(ishft(n2, -2),255)                 !8 bits
+      dat(6)=i1
+      i1=64*iand(n2,3)                           !2 bits
+      dat(7)=i1
+      dat(8)=0
+      dat(9)=0
+      dat(10)=0
+      dat(11)=0
+
+      return
+      end
+

Deleted: branches/wsprx/lib/packbits.f90
===================================================================
--- branches/wsprx/lib/packbits.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/packbits.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,21 +0,0 @@
-subroutine packbits(dbits,nsymd,m0,sym)
-
-! Pack 0s and 1s from dbits() into sym() with m0 bits per word.
-! NB: nsymd is the number of packed output words.
-
-  integer sym(nsymd)
-  integer*1 dbits(*)
-
-  k=0
-  do i=1,nsymd
-     n=0
-     do j=1,m0
-        k=k+1
-        m=dbits(k)
-        n=ior(ishft(n,1),m)
-     enddo
-     sym(i)=n
-  enddo
-
-  return
-end subroutine packbits

Deleted: branches/wsprx/lib/packdxcc.f
===================================================================
--- branches/wsprx/lib/packdxcc.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/packdxcc.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,64 +0,0 @@
-      subroutine packdxcc(c,ng,ldxcc)
-
-      character*3 c
-      logical ldxcc
-
-      parameter (NZ=303)
-      character*5 pfx(NZ)
-      data pfx/
-     +  '1A   ','1S   ','3A   ','3B6  ','3B8  ','3B9  ','3C   ','3C0  ',
-     +  '3D2  ',                '3DA  ','3V   ','3W   ','3X   ','3Y   ',
-     +          '4J   ','4L   ','4S   ','4U1  ',                '4W   ',
-     +  '4X   ','5A   ','5B   ','5H   ','5N   ','5R   ','5T   ','5U   ',
-     +  '5V   ','5W   ','5X   ','5Z   ','6W   ','6Y   ','7O   ','7P   ',
-     +  '7Q   ','7X   ','8P   ','8Q   ','8R   ','9A   ','9G   ','9H   ',
-     +  '9J   ','9K   ','9L   ','9M2  ','9M6  ','9N   ','9Q   ','9U   ',
-     +  '9V   ','9X   ','9Y   ','A2   ','A3   ','A4   ','A5   ','A6   ',
-     +  'A7   ','A9   ','AP   ','BS7  ','BV   ','BV9  ','BY   ','C2   ',
-     +  'C3   ','C5   ','C6   ','C9   ','CE   ','CE0  ',                
-     +  'CE9  ','CM   ','CN   ','CP   ','CT   ','CT3  ','CU   ','CX   ',
-     +  'CY0  ','CY9  ','D2   ','D4   ','D6   ','DL   ','DU   ','E3   ',
-     +  'E4   ','EA   ','EA6  ','EA8  ','EA9  ','EI   ','EK   ','EL   ',
-     +  'EP   ','ER   ','ES   ','ET   ','EU   ','EX   ','EY   ','EZ   ',
-     +  'F    ','FG   ','FH   ','FJ   ','FK   ',        'FM   ','FO   ',
-     +                          'FP   ','FR   ',                        
-     +  'FT5  ',                'FW   ','FY   ','M    ','MD   ','MI   ',
-     +  'MJ   ','MM   ',        'MU   ','MW   ','H4   ','H40  ','HA   ',
-     +  'HB   ','HB0  ','HC   ','HC8  ','HH   ','HI   ','HK   ','HK0  ',
-     +          'HL   ','HM   ','HP   ','HR   ','HS   ','HV   ','HZ   ',
-     +  'I    ','IG9  ','IS   ','IT9  ','J2   ','J3   ','J5   ','J6   ',
-     +  'J7   ','J8   ','JA   ','JD   ',        'JT   ','JW   ',        
-     +  'JX   ','JY   ','K    ','KG4  ','KH0  ','KH1  ','KH2  ','KH3  ',
-     +  'KH4  ','KH5  ',        'KH6  ','KH7  ','KH8  ','KH9  ','KL   ',
-     +  'KP1  ','KP2  ','KP4  ','KP5  ','LA   ','LU   ','LX   ','LY   ',
-     +  'LZ   ','OA   ','OD   ','OE   ','OH   ','OH0  ','OJ0  ','OK   ',
-     +  'OM   ','ON   ','OX   ','OY   ','OZ   ','P2   ','P4   ','PA   ',
-     +  'PJ2  ','PJ7  ','PY   ','PY0  ',                'PZ   ','R1F  ',
-     +  'R1M  ','S0   ','S2   ','S5   ','S7   ','S9   ','SM   ','SP   ',
-     +  'ST   ','SU   ','SV   ',        'SV5  ','SV9  ','T2   ','T30  ',
-     +  'T31  ','T32  ','T33  ','T5   ','T7   ','T8   ','T9   ','TA   ',
-     +  'TA1  ','TF   ','TG   ','TI   ','TI9  ','TJ   ','TK   ','TL   ',
-     +  'TN   ','TR   ','TT   ','TU   ','TY   ','TZ   ','UA   ','UA2  ',
-     +  'UA9  ','UK   ','UN   ','UR   ','V2   ','V3   ','V4   ','V5   ',
-     +  'V6   ','V7   ','V8   ','VE   ','VK   ','VK0  ',        'VK9  ',
-     +                                          'VP2  ',                
-     +  'VP5  ','VP6  ',        'VP8  ',                                
-     +  'VP9  ','VQ9  ','VR   ','VU   ','VU4  ','VU7  ','XE   ','XF4  ',
-     +  'XT   ','XU   ','XW   ','XX9  ','XZ   ','YA   ','YB   ','YI   ',
-     +  'YJ   ','YK   ','YL   ','YN   ','YO   ','YS   ','YU   ','YV   ',
-     +  'YV0  ','Z2   ','Z3   ','ZA   ','ZB   ','ZC4  ','ZD7  ','ZD8  ',
-     +  'ZD9  ','ZF   ','ZK1  ',        'ZK2  ','ZK3  ','ZL   ','ZL7  ',
-     +  'ZL8  ','ZL9  ','ZP   ','ZS   ','ZS8  '/
-
-      ldxcc=.false.
-      ng=0
-      do i=1,NZ
-         if(pfx(i)(1:3).eq.c) go to 10
-      enddo
-      go to 20
-
- 10   ng=180*180+61+i
-      ldxcc=.true.
-
- 20   return
-      end

Deleted: branches/wsprx/lib/packmsg.f90
===================================================================
--- branches/wsprx/lib/packmsg.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/packmsg.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,113 +0,0 @@
-subroutine packmsg(msg,dat,text)
-
-  parameter (NBASE=37*36*10*27*27*27)
-  parameter (NBASE2=262178562)
-  character*22 msg
-  integer dat(12)
-  character*12 c1,c2
-  character*4 c3
-  character*6 grid6
-  logical text1,text2,text3,text
-
-  text=.false.
-! Convert all letters to upper case
-  iz=22
-  do i=1,22
-     if(msg(i:i).ge.'a' .and. msg(i:i).le.'z')                       &amp;
-          msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
-     if(msg(i:i).ne.' ') iz=i
-  enddo
-  do iter=1,5                           !Collapse multiple blanks into one
-     ib2=index(msg(1:iz),'  ')
-     if(ib2.lt.1) go to 5
-     msg=msg(1:ib2)//msg(ib2+2:)
-     iz=iz-1
-  enddo
-
-5 if(msg(1:6).eq.'CQ DX ') msg(3:3)='9'
-
-! See if it's a CQ message
-  if(msg(1:3).eq.'CQ ') then
-     i=3
-! ... and if so, does it have a reply frequency?
-     if(msg(4:4).ge.'0' .and. msg(4:4).le.'9' .and.                  &amp;
-          msg(5:5).ge.'0' .and. msg(5:5).le.'9' .and.                &amp;
-          msg(6:6).ge.'0' .and. msg(6:6).le.'9') i=7
-     go to 1
-  endif
-
-  do i=1,22
-     if(msg(i:i).eq.' ') go to 1       !Get 1st blank
-  enddo
-  go to 10                             !Consider msg as plain text
-      
-1 ia=i
-  c1=msg(1:ia-1)
-  do i=ia+1,22
-     if(msg(i:i).eq.' ') go to 2       !Get 2nd blank
-  enddo
-  go to 10                             !Consider msg as plain text
-
-2 ib=i
-  c2=msg(ia+1:ib-1)
-
-  do i=ib+1,22
-     if(msg(i:i).eq.' ') go to 3       !Get 3rd blank
-  enddo
-  go to 10                             !Consider msg as plain text
-
-3 ic=i
-  c3='    '
-  if(ic.ge.ib+1) c3=msg(ib+1:ic)
-  if(c3.eq.'OOO ') c3='    '           !Strip out the OOO flag
-  call getpfx1(c1,k1,junk)
-  call packcall(c1,nc1,text1)
-  call getpfx1(c2,k2,nv2)
-  call packcall(c2,nc2,text2)
-  if(nv2.eq.0) then
-     if(k1.lt.0 .or. k2.lt.0 .or. k1*k2.ne.0) go to 10
-     if(k2.gt.0) k2=k2+450
-     k=max(k1,k2)
-     if(k.gt.0) then
-        call k2grid(k,grid6)
-        c3=grid6(:4)
-     endif
-  endif
-  call packgrid(c3,ng,text3)
-  if(nv2.eq.0 .and. (.not.text1) .and. (.not.text2) .and.           &amp;
-       (.not.text3)) go to 20
-  if(nv2.gt.0) then
-     if(nv2.eq.1) then
-        if(c1(1:3).eq.'CQ ')  nc1=262178563 + k2
-        if(c1(1:4).eq.'QRZ ') nc1=264002072 + k2 
-        if(c1(1:3).eq.'DE ')  nc1=265825581 + k2
-     endif
-     if(nv2.eq.2) then
-        if(c1(1:3).eq.'CQ ')  nc1=267649090 + k2
-        if(c1(1:4).eq.'QRZ ') nc1=267698375 + k2
-        if(c1(1:3).eq.'DE ')  nc1=267747660 + k2
-     endif
-     go to 20
-  endif
-
-! The message will be treated as plain text.
-10 text=.true.
-  call packtext(msg,nc1,nc2,ng)
-  ng=ng+32768
-
-! Encode data into 6-bit words
-20 dat(1)=iand(ishft(nc1,-22),63)               !6 bits
-  dat(2)=iand(ishft(nc1,-16),63)                !6 bits
-  dat(3)=iand(ishft(nc1,-10),63)                !6 bits
-  dat(4)=iand(ishft(nc1, -4),63)                !6 bits
-  dat(5)=4*iand(nc1,15)+iand(ishft(nc2,-26),3)  !4+2 bits
-  dat(6)=iand(ishft(nc2,-20),63)                !6 bits
-  dat(7)=iand(ishft(nc2,-14),63)                !6 bits
-  dat(8)=iand(ishft(nc2, -8),63)                !6 bits
-  dat(9)=iand(ishft(nc2, -2),63)                !6 bits
-  dat(10)=16*iand(nc2,3)+iand(ishft(ng,-12),15) !2+4 bits
-  dat(11)=iand(ishft(ng,-6),63)
-  dat(12)=iand(ng,63)
-
-  return
-end subroutine packmsg

Added: branches/wsprx/lib/packpfx.f90
===================================================================
--- branches/wsprx/lib/packpfx.f90	                        (rev 0)
+++ branches/wsprx/lib/packpfx.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,59 @@
+subroutine packpfx(call1,n1,ng,nadd)
+
+  character*12 call1,call0
+  character*3 pfx
+  logical text
+
+  i1=index(call1,'/')
+  if(call1(i1+2:i1+2).eq.' ') then
+! Single-character add-on suffix (maybe also fourth suffix letter?)
+     call0=call1(:i1-1)
+     call packcall(call0,n1,text)
+     nadd=1
+     nc=ichar(call1(i1+1:i1+1))
+     if(nc.ge.48 .and. nc.le.57) then
+        n=nc-48
+     else if(nc.ge.65 .and. nc.le.90) then
+        n=nc-65+10
+     else
+        n=38
+     endif
+     nadd=1
+     ng=60000-32768+n
+  else if(call1(i1+3:i1+3).eq.' ') then
+! Two-character numerical suffix, /10 to /99
+     call0=call1(:i1-1)
+     call packcall(call0,n1,text)
+     nadd=1
+     n=10*(ichar(call1(i1+1:i1+1))-48) + ichar(call1(i1+2:i1+2)) - 48
+     nadd=1
+     ng=60000 + 26 + n
+  else
+! Prefix of 1 to 3 characters
+     pfx=call1(:i1-1)
+     if(pfx(3:3).eq.' ') pfx=' '//pfx
+     if(pfx(3:3).eq.' ') pfx=' '//pfx
+     call0=call1(i1+1:)
+     call packcall(call0,n1,text)
+
+     ng=0
+     do i=1,3
+        nc=ichar(pfx(i:i))
+        if(nc.ge.48 .and. nc.le.57) then
+           n=nc-48
+        else if(nc.ge.65 .and. nc.le.90) then
+           n=nc-65+10
+        else
+           n=36
+        endif
+        ng=37*ng + n
+     enddo
+     nadd=0
+     if(ng.ge.32768) then
+        ng=ng-32768
+        nadd=1
+     endif
+  endif
+
+  return
+end subroutine packpfx

Deleted: branches/wsprx/lib/packtext.f
===================================================================
--- branches/wsprx/lib/packtext.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/packtext.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,47 +0,0 @@
-      subroutine packtext(msg,nc1,nc2,nc3)
-
-      parameter (MASK28=2**28 - 1)
-      character*13 msg
-      character*44 c
-      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?'/
-
-      nc1=0
-      nc2=0
-      nc3=0
-
-      do i=1,5                                !First 5 characters in nc1
-         do j=1,44                            !Get character code
-            if(msg(i:i).eq.c(j:j)) go to 10
-         enddo
-         j=37
- 10      j=j-1                                !Codes should start at zero
-         nc1=42*nc1 + j
-      enddo
-
-      do i=6,10                               !Characters 6-10 in nc2
-         do j=1,44                            !Get character code
-            if(msg(i:i).eq.c(j:j)) go to 20
-         enddo
-         j=37
- 20      j=j-1                                !Codes should start at zero
-         nc2=42*nc2 + j
-      enddo
-
-      do i=11,13                              !Characters 11-13 in nc3
-         do j=1,44                            !Get character code
-            if(msg(i:i).eq.c(j:j)) go to 30
-         enddo
-         j=37
- 30      j=j-1                                !Codes should start at zero
-         nc3=42*nc3 + j
-      enddo
-
-C  We now have used 17 bits in nc3.  Must move one each to nc1 and nc2.
-      nc1=nc1+nc1
-      if(iand(nc3,32768).ne.0) nc1=nc1+1
-      nc2=nc2+nc2
-      if(iand(nc3,65536).ne.0) nc2=nc2+1
-      nc3=iand(nc3,32767)
-
-      return
-      end

Deleted: branches/wsprx/lib/peakdf9.f90
===================================================================
--- branches/wsprx/lib/peakdf9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/peakdf9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,32 +0,0 @@
-subroutine peakdf9(c0,npts8,nsps8,istart,foffset,idfpk)
-
-  complex c0(0:npts8-1)
-  complex zsum
-  include 'jt9sync.f90'
-
-  twopi=8.0*atan(1.0)
-  df=1500.0/nsps8
-  smax=0.
-  do idf=-5,5
-     f0=foffset + 0.1*df*idf
-     dphi=twopi*f0/1500.0
-     sum=0.
-     do j=1,16
-        i1=(ii(j)-1)*nsps8 + istart
-        phi=0.
-        zsum=0.
-        do i=i1,i1+nsps8-1
-           if(i.lt.0 .or. i.gt.npts8-1) cycle
-           phi=phi + dphi
-           zsum=zsum + c0(i) * cmplx(cos(phi),-sin(phi))
-        enddo
-        sum=sum + real(zsum)**2 + aimag(zsum)**2
-     enddo
-     if(sum.gt.smax) then
-        idfpk=idf
-        smax=sum
-     endif
-  enddo
-
-  return
-end subroutine peakdf9

Deleted: branches/wsprx/lib/peakdt9.f90
===================================================================
--- branches/wsprx/lib/peakdt9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/peakdt9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,59 +0,0 @@
-subroutine peakdt9(c2,nz2,nsps8,nspsd,c3,nz3,xdt)
-
-  complex c2(0:4096-1)
-  complex c3(0:4096-1)
-  complex z
-  real p(0:3300)
-  include 'jt9sync.f90'
-
-  p=0.
-  i0=5*nspsd
-  do i=0,nz2-1
-     z=1.e-3*sum(c2(max(i-(nspsd-1),0):i))       !Integrate
-     p(i0+i)=real(z)**2 + aimag(z)**2      !Symbol power at freq=0
-! Option here for coherent processing ?
-!     write(53,3301) i,z,p(i0+i),atan2(aimag(z),real(z))
-!3301 format(i6,4e12.3)
-  enddo
-
-  call getlags(nsps8,lag0,lag1,lag2)
-  tsymbol=nsps8/1500.0
-  dtlag=tsymbol/nspsd
-  smax=0.
-  lagpk=0
-  do lag=lag1,lag2
-     sum0=0.
-     sum1=0.
-     j=-nspsd
-     do i=1,85
-        j=j+nspsd
-        if(isync(i).eq.1) then
-           sum1=sum1+p(j+lag)
-        else
-           sum0=sum0+p(j+lag)
-        endif
-     enddo
-     ss=(sum1/16.0)/(sum0/69.0) - 1.0
-     xdt=(lag-lag0)*dtlag
-!     write(52,3001) lag,xdt,ss
-!3001 format(i5,2f12.3)
-     if(ss.gt.smax) then
-        smax=ss
-        lagpk=lag
-     endif
-  enddo
-
-  xdt=(lagpk-lag0)*dtlag
-
-  nz3=nspsd*85
-  do i=0,nz3-1
-     j=i+lagpk-i0-nspsd+1
-     if(j.ge.0 .and. j.le.nz2) then
-        c3(i)=c2(j)
-     else
-        c3(i)=0.
-     endif
-  enddo
- 
-  return
-end subroutine peakdt9

Deleted: branches/wsprx/lib/pfx.f
===================================================================
--- branches/wsprx/lib/pfx.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/pfx.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,50 +0,0 @@
-      parameter (NZ=339)                     !Total number of prefixes
-      parameter (NZ2=12)                     !Total number of suffixes
-      character*1 sfx(NZ2)
-      character*5 pfx(NZ)
-
-      data sfx/'P','0','1','2','3','4','5','6','7','8','9','A'/
-      data pfx/
-     +  '1A   ','1S   ','3A   ','3B6  ','3B8  ','3B9  ','3C   ','3C0  ',
-     +  '3D2  ','3D2C ','3D2R ','3DA  ','3V   ','3W   ','3X   ','3Y   ',
-     +  '3YB  ','3YP  ','4J   ','4L   ','4S   ','4U1I ','4U1U ','4W   ',
-     +  '4X   ','5A   ','5B   ','5H   ','5N   ','5R   ','5T   ','5U   ',
-     +  '5V   ','5W   ','5X   ','5Z   ','6W   ','6Y   ','7O   ','7P   ',
-     +  '7Q   ','7X   ','8P   ','8Q   ','8R   ','9A   ','9G   ','9H   ',
-     +  '9J   ','9K   ','9L   ','9M2  ','9M6  ','9N   ','9Q   ','9U   ',
-     +  '9V   ','9X   ','9Y   ','A2   ','A3   ','A4   ','A5   ','A6   ',
-     +  'A7   ','A9   ','AP   ','BS7  ','BV   ','BV9  ','BY   ','C2   ',
-     +  'C3   ','C5   ','C6   ','C9   ','CE   ','CE0X ','CE0Y ','CE0Z ',
-     +  'CE9  ','CM   ','CN   ','CP   ','CT   ','CT3  ','CU   ','CX   ',
-     +  'CY0  ','CY9  ','D2   ','D4   ','D6   ','DL   ','DU   ','E3   ',
-     +  'E4   ','EA   ','EA6  ','EA8  ','EA9  ','EI   ','EK   ','EL   ',
-     +  'EP   ','ER   ','ES   ','ET   ','EU   ','EX   ','EY   ','EZ   ',
-     +  'F    ','FG   ','FH   ','FJ   ','FK   ','FKC  ','FM   ','FO   ',
-     +  'FOA  ','FOC  ','FOM  ','FP   ','FR   ','FRG  ','FRJ  ','FRT  ',
-     +  'FT5W ','FT5X ','FT5Z ','FW   ','FY   ','M    ','MD   ','MI   ',
-     +  'MJ   ','MM   ',        'MU   ','MW   ','H4   ','H40  ','HA   ',
-     +  'HB   ','HB0  ','HC   ','HC8  ','HH   ','HI   ','HK   ','HK0A ',
-     +  'HK0M ','HL   ','HM   ','HP   ','HR   ','HS   ','HV   ','HZ   ',
-     +  'I    ','IS   ','IS0  ',        'J2   ','J3   ','J5   ','J6   ',
-     +  'J7   ','J8   ','JA   ','JDM  ','JDO  ','JT   ','JW   ',        
-     +  'JX   ','JY   ','K    ','KG4  ','KH0  ','KH1  ','KH2  ','KH3  ',
-     +  'KH4  ','KH5  ','KH5K ','KH6  ','KH7  ','KH8  ','KH9  ','KL   ',
-     +  'KP1  ','KP2  ','KP4  ','KP5  ','LA   ','LU   ','LX   ','LY   ',
-     +  'LZ   ','OA   ','OD   ','OE   ','OH   ','OH0  ','OJ0  ','OK   ',
-     +  'OM   ','ON   ','OX   ','OY   ','OZ   ','P2   ','P4   ','PA   ',
-     +  'PJ2  ','PJ7  ','PY   ','PY0F ','PT0S ','PY0T ','PZ   ','R1F  ',
-     +  'R1M  ','S0   ','S2   ','S5   ','S7   ','S9   ','SM   ','SP   ',
-     +  'ST   ','SU   ','SV   ','SVA  ','SV5  ','SV9  ','T2   ','T30  ',
-     +  'T31  ','T32  ','T33  ','T5   ','T7   ','T8   ','T9   ','TA   ',
-     +          'TF   ','TG   ','TI   ','TI9  ','TJ   ','TK   ','TL   ',
-     +  'TN   ','TR   ','TT   ','TU   ','TY   ','TZ   ','UA   ','UA2  ',
-     +  'UA9  ','UK   ','UN   ','UR   ','V2   ','V3   ','V4   ','V5   ',
-     +  'V6   ','V7   ','V8   ','VE   ','VK   ','VK0H ','VK0M ','VK9C ',
-     +  'VK9L ','VK9M ','VK9N ','VK9W ','VK9X ','VP2E ','VP2M ','VP2V ',
-     +  'VP5  ','VP6  ','VP6D ','VP8  ','VP8G ','VP8H ','VP8O ','VP8S ',
-     +  'VP9  ','VQ9  ','VR   ','VU   ','VU4  ','VU7  ','XE   ','XF4  ',
-     +  'XT   ','XU   ','XW   ','XX9  ','XZ   ','YA   ','YB   ','YI   ',
-     +  'YJ   ','YK   ','YL   ','YN   ','YO   ','YS   ','YU   ','YV   ',
-     +  'YV0  ','Z2   ','Z3   ','ZA   ','ZB   ','ZC4  ','ZD7  ','ZD8  ',
-     +  'ZD9  ','ZF   ','ZK1N ','ZK1S ','ZK2  ','ZK3  ','ZL   ','ZL7  ',
-     +  'ZL8  ','ZL9  ','ZP   ','ZS   ','ZS8  ','KC4  ','E5   '/

Deleted: branches/wsprx/lib/pfxdump.f
===================================================================
--- branches/wsprx/lib/pfxdump.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/pfxdump.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,13 +0,0 @@
-      subroutine pfxdump(fname)
-      character*(*) fname
-      include 'pfx.f'
-
-      open(11,file=fname,status='unknown')
-      write(11,1001) sfx
- 1001 format('Supported Suffixes:'/(11('/',a1,2x)))
-      write(11,1002) pfx
- 1002 format(/'Supported Add-On DXCC Prefixes:'/(15(a5,1x)))
-      close(11)
-
-      return
-      end

Added: branches/wsprx/lib/ps162.f
===================================================================
--- branches/wsprx/lib/ps162.f	                        (rev 0)
+++ branches/wsprx/lib/ps162.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,27 @@
+      subroutine ps162(c2,s)
+
+      parameter (NFFT=512,NH=256)
+      complex c2(0:NFFT)
+      real s(-NH:NH)
+!      real work(2*NMAX)
+      complex c(0:NFFT)
+
+      do i=0,NH-1
+         c(i)=c2(i)
+      enddo
+      do i=nh,nfft-1
+         c(i)=0.
+      enddo
+
+      call four2a(c,nfft,1,-1,1)
+
+      fac=1.0/nfft
+      do i=0,NFFT-1
+         j=i
+         if(j.gt.NH) j=j-NFFT
+         s(j)=fac*(real(c(i))**2 + aimag(c(i))**2)
+      enddo
+      s(-NH)=s(-NH+1)
+
+      return
+      end

Deleted: branches/wsprx/lib/ptt_unix.c
===================================================================
--- branches/wsprx/lib/ptt_unix.c	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/ptt_unix.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,393 +0,0 @@
-/*
- * WSJT is Copyright (c) 2001-2006 by Joseph H. Taylor, Jr., K1JT, 
- * and is licensed under the GNU General Public License (GPL).
- *
- * Code used from cwdaemon for parallel port ptt only.
- *
- * cwdaemon - morse sounding daemon for the parallel or serial port
- * Copyright (C) 2002 -2005 Joop Stakenborg &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">pg4i at amsat.org</A>&gt;
- *                       and many authors, see the AUTHORS file.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Library General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-# if HAVE_STDIO_H
-# include &lt;stdio.h&gt;
-#endif
-#if STDC_HEADERS
-# include &lt;stdlib.h&gt;
-# include &lt;stddef.h&gt;
-#else
-# if HAVE_STDLIB_H
-#  include &lt;stdlib.h&gt;
-# endif
-#endif
-#if HAVE_UNISTD_H
-# include &lt;unistd.h&gt;
-#endif
-#if HAVE_SYS_IOCTL_H
-# include &lt;sys/ioctl.h&gt;
-#endif
-//#if HAVE_FCNTL_H
-# include &lt;fcntl.h&gt;
-//#endif
-#include &lt;stdio.h&gt;
-#include &lt;sys/ioctl.h&gt;
-
-#ifdef HAVE_LINUX_PPDEV_H
-# include &lt;linux/ppdev.h&gt;
-# include &lt;linux/parport.h&gt;
-#endif
-#ifdef HAVE_DEV_PPBUS_PPI_H
-# include &lt;dev/ppbus/ppi.h&gt;
-# include &lt;dev/ppbus/ppbconf.h&gt;
-#endif
-
-int lp_reset (int fd);
-int lp_ptt (int fd, int onoff);
-
-#ifdef HAVE_SYS_STAT_H
-# include &lt;sys/stat.h&gt;
-#endif
-#if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG)
-# include &lt;sys/param.h&gt;
-#endif
-
-#include &lt;string.h&gt;
-/* parport functions */
-
-int dev_is_parport(int fd);
-int ptt_parallel(int fd, int *ntx, int *iptt);
-int ptt_serial(int fd, int *ntx, int *iptt);
-
-int fd=-1;		/* Used for both serial and parallel */
-
-/*
- * ptt_
- *
- * generic unix PTT routine called from Fortran
- *
- * Inputs	
- * unused	Unused, to satisfy old windows calling convention
- * ptt_port	device name serial or parallel
- * ntx		pointer to fortran command on or off
- * iptt		pointer to fortran command status on or off
- * Returns	- non 0 if error
-*/
-
-/* Tiny state machine */
-#define STATE_PORT_CLOSED		0
-#define STATE_PORT_OPEN_PARALLEL	1
-#define STATE_PORT_OPEN_SERIAL		2
-
-//int ptt_(int *unused, char *ptt_port, int *ntx, int *iptt)
-int ptt_(int *unused, int *ntx, int *iptt)
-{
-  static int state=0;
-  char *p;
-
-// ### Temporary:
-  char* ptt_port;
-  if(*unused != -99) {
-    *iptt=*ntx;
-    return 0;
-  }
-// ###
-
-  /* In the very unlikely event of a NULL pointer, just return.
-   * Yes, I realise this should not be possible in WSJT.
-   */
-  if (ptt_port == NULL) {
-    *iptt = *ntx;
-    return (0);
-  }
-    
-  switch (state) {
-  case STATE_PORT_CLOSED:
-
-     /* Remove trailing ' ' */
-    if ((p = strchr(ptt_port, ' ')) != NULL)
-      *p = '\0';
-
-    /* If all that is left is a '\0' then also just return */
-    if (*ptt_port == '\0') {
-      *iptt = *ntx;
-      return(0);
-    }
-
-    if ((fd = open(ptt_port, O_RDWR|O_NONBLOCK)) &lt; 0) {
-	fprintf(stderr, &quot;Can't open %s.\n&quot;, ptt_port);
-	return (1);
-    }
-
-    if (dev_is_parport(fd)) {
-      state = STATE_PORT_OPEN_PARALLEL;
-      lp_reset(fd);
-      ptt_parallel(fd, ntx, iptt);
-    } else {
-      state = STATE_PORT_OPEN_SERIAL;
-      ptt_serial(fd, ntx, iptt);
-    }
-    break;
-
-  case STATE_PORT_OPEN_PARALLEL:
-    ptt_parallel(fd, ntx, iptt);
-    break;
-
-  case STATE_PORT_OPEN_SERIAL:
-    ptt_serial(fd, ntx, iptt);
-    break;
-
-  default:
-    close(fd);
-    fd = -1;
-    state = STATE_PORT_CLOSED;
-    break;
-  }
-  return(0);
-}
-
-/*
- * ptt_serial
- *
- * generic serial unix PTT routine called indirectly from Fortran
- *
- * fd		- already opened file descriptor
- * ntx		- pointer to fortran command on or off
- * iptt		- pointer to fortran command status on or off
- */
-
-int
-ptt_serial(int fd, int *ntx, int *iptt)
-{
-  int control = TIOCM_RTS | TIOCM_DTR;
-
-  if(*ntx) {
-    ioctl(fd, TIOCMBIS, &amp;control);               /* Set DTR and RTS */
-    *iptt = 1;
-  } else {
-    ioctl(fd, TIOCMBIC, &amp;control);
-    *iptt = 0;
-  }
-  return(0);
-}
-
-
-/* parport functions */
-
-/*
- * dev_is_parport(fd):
- *
- * inputs	- Already open fd
- * output	- 1 if parallel port, 0 if not
- * side effects	- Unfortunately, this is platform specific.
- */
-
-#if defined(HAVE_LINUX_PPDEV_H)                /* Linux (ppdev) */
-
-int
-dev_is_parport(int fd)
-{
-       struct stat st;
-       int m;
-
-       if ((fstat(fd, &amp;st) == -1) ||
-	   ((st.st_mode &amp; S_IFMT) != S_IFCHR) ||
-	   (ioctl(fd, PPGETMODE, &amp;m) == -1))
-	 return(0);
-
-       return(1);
-}
-
-#elif defined(HAVE_DEV_PPBUS_PPI_H)    /* FreeBSD (ppbus/ppi) */
-
-int
-dev_is_parport(int fd)
-{
-       struct stat st;
-       unsigned char c;
-
-       if ((fstat(fd, &amp;st) == -1) ||
-	   ((st.st_mode &amp; S_IFMT) != S_IFCHR) ||
-	   (ioctl(fd, PPISSTATUS, &amp;c) == -1))
-	 return(0);
-
-       return(1);
-}
-
-#else                                  /* Fallback (nothing) */
-
-int
-dev_is_parport(int fd)
-{
-       return(0);
-}
-
-#endif
-/* Linux wrapper around PPFCONTROL */
-#ifdef HAVE_LINUX_PPDEV_H
-static void
-parport_control (int fd, unsigned char controlbits, int values)
-{
-	struct ppdev_frob_struct frob;
-	frob.mask = controlbits;
-	frob.val = values;
-
-	if (ioctl (fd, PPFCONTROL, &amp;frob) == -1)
-	{
-		fprintf(stderr, &quot;Parallel port PPFCONTROL&quot;);
-		exit (1);
-	}
-}
-#endif
-
-/* FreeBSD wrapper around PPISCTRL */
-#ifdef HAVE_DEV_PPBUS_PPI_H
-static void
-parport_control (int fd, unsigned char controlbits, int values)
-{
-	unsigned char val;
-
-	if (ioctl (fd, PPIGCTRL, &amp;val) == -1)
-	{
-		fprintf(stderr, &quot;Parallel port PPIGCTRL&quot;);
-		exit (1);
-	}
-
-	val &amp;= ~controlbits;
-	val |= values;
-
-	if (ioctl (fd, PPISCTRL, &amp;val) == -1)
-	{
-		fprintf(stderr, &quot;Parallel port PPISCTRL&quot;);
-		exit (1);
-	}
-}
-#endif
-
-/* Initialise a parallel port, given open fd */
-int
-lp_init (int fd)
-{
-#ifdef HAVE_LINUX_PPDEV_H
-	int mode;
-#endif
-
-#ifdef HAVE_LINUX_PPDEV_H
-	mode = PARPORT_MODE_PCSPP;
-
-	if (ioctl (fd, PPSETMODE, &amp;mode) == -1)
-	{
-		fprintf(stderr, &quot;Setting parallel port mode&quot;);
-		close (fd);
-		return(-1);
-	}
-
-	if (ioctl (fd, PPEXCL, NULL) == -1)
-	{
-		fprintf(stderr, &quot;Parallel port is already in use.\n&quot;);
-		close (fd);
-		return(-1);
-	}
-	if (ioctl (fd, PPCLAIM, NULL) == -1)
-	{
-		fprintf(stderr, &quot;Claiming parallel port.\n&quot;);
-		fprintf(stderr, &quot;HINT: did you unload the lp kernel module?&quot;);
-		close (fd);
-		return(-1);
-	}
-
-	/* Enable CW &amp; PTT - /STROBE bit (pin 1) */
-	parport_control (fd, PARPORT_CONTROL_STROBE, PARPORT_CONTROL_STROBE);
-#endif
-#ifdef HAVE_DEV_PPBUS_PPI_H
-	parport_control (fd, STROBE, STROBE);
-#endif
-	lp_reset (fd);
-	return(0);
-}
-
-/* release ppdev and close port */
-int
-lp_free (int fd)
-{
-#ifdef HAVE_LINUX_PPDEV_H
-	lp_reset (fd);
-
-	/* Disable CW &amp; PTT - /STROBE bit (pin 1) */
-	parport_control (fd, PARPORT_CONTROL_STROBE, 0);
-
-	ioctl (fd, PPRELEASE);
-#endif
-#ifdef HAVE_DEV_PPBUS_PPI_H
-	/* Disable CW &amp; PTT - /STROBE bit (pin 1) */
-	parport_control (fd, STROBE, 0);
-#endif
-	close (fd);
-	return(0);
-}
-
-/* set to a known state */
-int
-lp_reset (int fd)
-{
-#if defined (HAVE_LINUX_PPDEV_H) || defined (HAVE_DEV_PPBUS_PPI_H)
-	lp_ptt (fd, 0);
-#endif
-	return(0);
-}
-
-/* SSB PTT keying - /INIT bit (pin 16) (inverted) */
-int
-lp_ptt (int fd, int onoff)
-{
-#ifdef HAVE_LINUX_PPDEV_H
-	if (onoff == 1)
-		parport_control (fd, PARPORT_CONTROL_INIT,
-				PARPORT_CONTROL_INIT);
-	else
-		parport_control (fd, PARPORT_CONTROL_INIT, 0);
-#endif
-#ifdef HAVE_DEV_PPBUS_PPI_H
-	if (onoff == 1)
-		parport_control (fd, nINIT,
-				nINIT);
-	else
-		parport_control (fd, nINIT, 0);
-#endif
-	return(0);
-}
-
-/*
- * ptt_parallel
- *
- * generic parallel unix PTT routine called indirectly from Fortran
- *
- * fd		- already opened file descriptor
- * ntx		- pointer to fortran command on or off
- * iptt		- pointer to fortran command status on or off
- */
-
-int
-ptt_parallel(int fd, int *ntx, int *iptt)
-{
-  if(*ntx) {
-    lp_ptt(fd, 1);
-    *iptt=1;
-  }  else {
-    lp_ptt(fd, 0);
-    *iptt=0;
-  }
-  return(0);
-}

Deleted: branches/wsprx/lib/rs.h
===================================================================
--- branches/wsprx/lib/rs.h	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/rs.h	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,35 +0,0 @@
-/* User include file for the Reed-Solomon codec
- * Copyright 2002, Phil Karn KA9Q
- * May be used under the terms of the GNU General Public License (GPL)
- */
-
-/* General purpose RS codec, 8-bit symbols */
-void encode_rs_char(void *rs,unsigned char *data,unsigned char *parity);
-int decode_rs_char(void *rs,unsigned char *data,int *eras_pos,
-		   int no_eras);
-void *init_rs_char(int symsize,int gfpoly,
-		   int fcr,int prim,int nroots,
-		   int pad);
-void free_rs_char(void *rs);
-
-/* General purpose RS codec, integer symbols */
-void encode_rs_int(void *rs,int *data,int *parity);
-int decode_rs_int(void *rs,int *data,int *eras_pos,int no_eras);
-void *init_rs_int(int symsize,int gfpoly,int fcr,
-		  int prim,int nroots,int pad);
-void free_rs_int(void *rs);
-
-/* CCSDS standard (255,223) RS codec with conventional (*not* dual-basis)
- * symbol representation
- */
-void encode_rs_8(unsigned char *data,unsigned char *parity,int pad);
-int decode_rs_8(unsigned char *data,int *eras_pos,int no_eras,int pad);
-
-/* CCSDS standard (255,223) RS codec with dual-basis symbol representation */
-void encode_rs_ccsds(unsigned char *data,unsigned char *parity,int pad);
-int decode_rs_ccsds(unsigned char *data,int *eras_pos,int no_eras,int pad);
-
-/* Tables to map from conventional-&gt;dual (Taltab) and
- * dual-&gt;conventional (Tal1tab) bases
- */
-extern unsigned char Taltab[],Tal1tab[];

Deleted: branches/wsprx/lib/sec_midn.f90
===================================================================
--- branches/wsprx/lib/sec_midn.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/sec_midn.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,11 +0,0 @@
-real function sec_midn()
-  sec_midn=secnds(0.0)
-  return
-end function sec_midn
-
-subroutine sleep_msec(n)
-
-  call usleep(1000*n)
-
-  return
-end subroutine sleep_msec

Added: branches/wsprx/lib/set.f
===================================================================
--- branches/wsprx/lib/set.f	                        (rev 0)
+++ branches/wsprx/lib/set.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,31 @@
+      subroutine set(a,y,n)
+      real y(n)
+      do i=1,n
+         y(i)=a
+      enddo
+      return
+      end
+
+      subroutine move(x,y,n)
+      real x(n),y(n)
+      do i=1,n
+         y(i)=x(i)
+      enddo
+      return
+      end
+
+      subroutine zero(x,n)
+      real x(n)
+      do i=1,n
+         x(i)=0.0
+      enddo
+      return
+      end
+
+      subroutine add(a,b,c,n)
+      real a(n),b(n),c(n)
+      do i=1,n
+         c(i)=a(i)+b(i)
+      enddo
+      return
+      end

Deleted: branches/wsprx/lib/sleep.h
===================================================================
--- branches/wsprx/lib/sleep.h	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/sleep.h	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,32 +0,0 @@
-/*
- * sleep.h  1.0 02/03/10
- *
- * Defines cross-platform sleep, usleep, etc.
- *
- * By Wu Yongwei
- *
- */
-
-#ifndef _SLEEP_H
-#define _SLEEP_H
-
-#ifdef _WIN32
-# if defined(_NEED_SLEEP_ONLY) &amp;&amp; (defined(_MSC_VER) || defined(__MINGW32__))
-#  include &lt;stdlib.h&gt;
-#  define sleep(t) _sleep((t) * 1000)
-# else
-#  include &lt;windows.h&gt;
-#  define sleep(t)  Sleep((t) * 1000)
-# endif
-# ifndef _NEED_SLEEP_ONLY
-#  define msleep(t) Sleep(t)
-#  define usleep(t) Sleep((t) / 1000)
-# endif
-#else
-# include &lt;unistd.h&gt;
-# ifndef _NEED_SLEEP_ONLY
-#  define msleep(t) usleep((t) * 1000)
-# endif
-#endif
-
-#endif /* _SLEEP_H */

Deleted: branches/wsprx/lib/sleep_msec.f90
===================================================================
--- branches/wsprx/lib/sleep_msec.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/sleep_msec.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,3 +0,0 @@
-subroutine sleep_msec(n)
-  return
-end subroutine sleep_msec

Added: branches/wsprx/lib/sound.c
===================================================================
--- branches/wsprx/lib/sound.c	                        (rev 0)
+++ branches/wsprx/lib/sound.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,154 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;portaudio.h&quot;
+
+/* #define DITHER_FLAG     (paDitherOff)  */
+#define DITHER_FLAG     (0) /**/
+#define PA_SAMPLE_TYPE  paInt16
+typedef short SAMPLE;
+
+int soundinit_(void)
+{
+  PaError err;
+  err = Pa_Initialize();
+  if( err == paNoError ) {
+    return 0;
+  }
+  else {
+//    Pa_Terminate();
+    fprintf( stderr, &quot;An error occured when initializing the audio stream\n&quot;);
+    fprintf( stderr, &quot;Error number: %d\n&quot;, err );
+    fprintf( stderr, &quot;WSPR will now exit/n&quot;);
+    exit(255);
+  }
+}
+
+int soundexit_(void)
+{
+  Pa_Terminate();
+  return 0;
+}
+
+int soundin_(int *idevin, int *nrate0, short recordedSamples[], 
+	     int *nframes0, int *iqmode)
+{
+    PaStreamParameters inputParameters;
+    PaStream *stream;
+    PaError err;
+    int i;
+    int totalFrames;
+    int numSamples;
+    int numBytes;
+    int num_channels;
+    int nrate;
+    int frames_per_buffer=1024;
+
+    nrate=*nrate0;
+    if(nrate&gt;12000) frames_per_buffer=4096;
+    totalFrames=*nframes0;
+    num_channels=*iqmode + 1;
+    numSamples = totalFrames * num_channels;
+    numBytes = numSamples * sizeof(SAMPLE);
+    for( i=0; i&lt;numSamples; i++ ) 
+      recordedSamples[i] = 0;
+
+    inputParameters.device = *idevin;
+    if(*idevin&lt;0) inputParameters.device = Pa_GetDefaultInputDevice();
+    inputParameters.channelCount = num_channels;
+    inputParameters.sampleFormat = PA_SAMPLE_TYPE;
+    inputParameters.suggestedLatency = 0.4;
+    inputParameters.hostApiSpecificStreamInfo = NULL;
+
+    err = Pa_OpenStream(
+              &amp;stream,
+              &amp;inputParameters,
+              NULL,                  /* &amp;outputParameters, */
+              nrate,
+              frames_per_buffer,
+              paClipOff,
+              NULL, /* no callback, use blocking API */
+              NULL ); /* no callback, so no callback userData */
+    if( err != paNoError ) goto error;
+
+    err = Pa_StartStream( stream );
+    if( err != paNoError ) goto error;
+
+    err = Pa_ReadStream( stream, recordedSamples, totalFrames );
+    if( err != paNoError ) goto error;
+    
+    err = Pa_CloseStream( stream );
+    if( err != paNoError ) goto error;
+    return 0;
+
+error:
+    Pa_Terminate();
+    fprintf( stderr, &quot;An error occured while using the portaudio stream\n&quot; );
+    fprintf( stderr, &quot;Error number: %d\n&quot;, err );
+    fprintf( stderr, &quot;Error message: %s\n&quot;, Pa_GetErrorText( err ) );
+    soundinit_();
+    return -1;
+}
+
+int soundout_(int *idevout, int *nrate0, short recordedSamples[], 
+	      int *nframes0, int *iqmode)
+{
+    PaStreamParameters outputParameters;
+    PaStream *stream;
+    PaError err;
+    int totalFrames;
+    int numSamples;
+    int numBytes;
+    int num_channels;
+    int nrate;
+    int frames_per_buffer=1024;
+
+    nrate=*nrate0;
+    if(nrate&gt;12000) frames_per_buffer=4096;
+    totalFrames=*nframes0;
+    num_channels=*iqmode + 1;
+    numSamples = totalFrames * num_channels;
+    numBytes = numSamples * sizeof(SAMPLE);
+    outputParameters.device = *idevout;
+    if(*idevout&lt;0) outputParameters.device = Pa_GetDefaultOutputDevice();
+    outputParameters.channelCount = num_channels;
+    outputParameters.sampleFormat =  PA_SAMPLE_TYPE;
+    outputParameters.suggestedLatency = 0.4;
+    outputParameters.hostApiSpecificStreamInfo = NULL;
+
+    err = Pa_OpenStream(
+              &amp;stream,
+              NULL, /* no input */
+              &amp;outputParameters,
+              nrate,
+              frames_per_buffer,
+              paClipOff,
+              NULL, /* no callback, use blocking API */
+              NULL ); /* no callback, so no callback userData */
+    if( err != paNoError ) goto error;
+
+    if( stream )
+    {
+        err = Pa_StartStream( stream );
+        if( err != paNoError ) goto error;
+
+        err = Pa_WriteStream( stream, recordedSamples, totalFrames );
+        if( err != paNoError ) goto error;
+
+        err = Pa_CloseStream( stream );
+        if( err != paNoError ) goto error;
+    }
+    return 0;
+
+error:
+    Pa_Terminate();
+    fprintf( stderr, &quot;An error occured while using the portaudio stream\n&quot; );
+    fprintf( stderr, &quot;Error number: %d\n&quot;, err );
+    fprintf( stderr, &quot;Error message: %s\n&quot;, Pa_GetErrorText( err ) );
+    soundinit_();
+    return -1;
+}
+
+void msleep_(int *msec0)
+{
+  Pa_Sleep(*msec0);
+}

Added: branches/wsprx/lib/spec162.f
===================================================================
--- branches/wsprx/lib/spec162.f	                        (rev 0)
+++ branches/wsprx/lib/spec162.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,98 @@
+      subroutine spec162(c2,jz,appdir,nappdir)
+
+      parameter(NX=500,NY=160)
+      complex c2(65536)
+      complex c(0:255)
+      character*80 appdir,pixmap
+      real s(120,0:255)
+      real ss(0:255)
+      real w(0:255)
+      real savg(0:255)
+      integer*2 a(NX,NY)
+      common/bcom/ntransmitted
+
+      nfft=256
+      twopi=6.2831853
+      pi=0.5*twopi
+      do i=0,nfft-1
+         w(i)=sin(i*pi/nfft)
+      enddo
+
+      nadd=9
+      call zero(s,120*256)
+      call zero(savg,256)
+      istep=nfft/2
+      nsteps=(jz-nfft)/(nadd*istep)
+      pixmap=appdir(:nappdir)//'/pixmap.dat'
+
+      call cs_lock('spec162')
+      open(16,file=pixmap,access='stream',status='unknown',err=1)
+      read(16,end=1) a
+      go to 2
+ 1    call zero(a,NX*NY/2)
+
+ 2    nmove=nsteps+1
+      call cs_unlock
+
+      do j=1,NY                 !Move waterfall left
+         do i=1,NX-nmove
+            a(i,j)=a(i+nmove,j)
+         enddo
+         a(NX-nmove+1,j)=255*ntransmitted
+      enddo
+      ntransmitted=0
+
+      i0=-istep+1
+      k=0
+      do n=1,nsteps
+         k=k+1
+         call zero(ss,256)
+         do m=1,nadd
+            i0=i0+istep
+            do i=0,nfft-1
+               c(i)=w(i)*c2(i0+i)
+            enddo
+            call four2a(c,nfft,1,-1,1)
+            do i=0,nfft-1
+               sq=real(c(i))**2 + imag(c(i))**2
+               ss(i)=ss(i) + sq
+               savg(i)=savg(i) + sq
+            enddo
+         enddo
+         call flat3(ss,256,nadd)
+         do i=0,nfft-1
+            s(k,i)=ss(i)
+         enddo
+      enddo
+      kz=k
+
+      gain=40
+      offset=-90.
+      fac=20.0/nadd
+
+      do k=1,kz
+         j=k-kz+NX
+         do i=-80,-1
+            x=fac*s(k,i+nfft)
+            n=0
+            if(x.gt.0.0) n=gain*log10(x) + offset
+            n=min(252,max(0,n))
+            a(j,NY-i-80)=n
+         enddo
+         do i=0,79
+            x=fac*s(k,i)
+            n=0
+            if(x.gt.0.0) n=gain*log10(x) + offset
+            n=min(252,max(0,n))
+            a(j,NY-i-80)=n
+         enddo
+      enddo
+
+      call cs_lock('spec162')
+      rewind 16
+      write(16) a
+      close(16)
+      call cs_unlock
+
+      return
+      end

Deleted: branches/wsprx/lib/spec9.f90
===================================================================
--- branches/wsprx/lib/spec9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/spec9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,133 +0,0 @@
-subroutine spec9(c0,npts8,nsps,fpk0,fpk,xdt,snrdb,i1SoftSymbols)
-
-  parameter (MAXFFT=31500)
-  complex c0(0:npts8-1)
-  complex c1(0:2700000)
-  real*4 ssym(0:7,69)
-  real*4 sx(0:31500-1)
-  complex c(0:MAXFFT-1)
-  integer*1 i1SoftSymbolsScrambled(207)
-  integer*1 i1SoftSymbols(207)
-  integer*1 i1
-  equivalence (i1,i4)
-  include 'jt9sync.f90'
-
-! Fix up the data in c0()
-  sum=0.
-  do i=0,npts8-1
-     sum=sum + real(c0(i))**2 + aimag(c0(i))**2
-  enddo
-  rms=sqrt(sum/npts8)
-  fac=1.0/rms
-  twopi=8.0*atan(1.0)
-  phi=0.
-  dphi=twopi*500.0/1500.0
-  do i=0,npts8-1
-     phi=phi+dphi
-     if(phi.gt.twopi) phi=phi-twopi
-     if(phi.lt.-twopi) phi=phi+twopi
-     c1(i)=fac*cmplx(aimag(c0(i)),real(c0(i)))*cmplx(cos(phi),sin(phi))
-  enddo
-
-  nsps8=nsps/8
-  foffset=fpk0
-  istart=1520
-
-  call timer('peakdt9 ',0)
-  call peakdt9(c1,npts8,nsps8,istart,foffset,idt)
-  call timer('peakdt9 ',1)
-  istart=istart + nint(0.0625*nsps8*idt)
-  xdt=istart/1500.0 - 1.0
-
-  call timer('peakdf9 ',0)
-  call peakdf9(c1,npts8,nsps8,istart,foffset,idf)
-  call timer('peakdf9 ',1)
-
-  fpk=fpk0 + idf*0.1*1500.0/nsps8
-  foffset=foffset + idf*0.1*1500.0/nsps8
-
-  twopi=8.0*atan(1.0)
-  dphi=twopi*foffset/1500.0
-  nfft=nsps8
-  nsym=min((npts8-istart)/nsps8,85)
-
-  k=0
-  do j=1,nsym
-     if(isync(j).eq.1) cycle
-     k=k+1
-     ia=(j-1)*nsps8 + istart
-
-!     c(0:nfft-1)=c1(ia:ib)
-     do i=0,nfft-1
-        c(i)=0.
-        if(ia+i.ge.0 .and. ia+i.lt.2700000-1) c(i)=c1(ia+i)
-     enddo
-
-     phi=0.
-     do i=0,nfft-1
-        phi=phi + dphi
-        c(i)=c(i) * cmplx(cos(phi),-sin(phi))
-     enddo
-
-     call four2a(c,nfft,1,-1,1)
-     do i=0,nfft-1
-        sx(i)=real(c(i))**2 + aimag(c(i))**2
-        if(i.ge.1 .and. i.le.8) ssym(i-1,k)=sx(i)
-     enddo
-  enddo
-
-  sum=0.
-  sig=0.
-  do j=1,69
-     smax=0.
-     do i=0,7
-        smax=max(smax,ssym(i,j))
-        sum=sum+ssym(i,j)
-     enddo
-     sig=sig+smax
-     sum=sum-smax
-  enddo
-  ave=sum/(69*7)
-  call pctile(sx,nsps8,50,xmed)
-  ssym=ssym/ave
-
-  sig=sig/69.
-  df8=1500.0/nsps8
-  t=max(1.0,sig/xmed - 1.0)
-  snrdb=db(t) - db(2500.0/df8) - 5.0
-     
-  m0=3
-  k=0
-  do j=1,69
-        smax=0.
-        do i=0,7
-           if(ssym(i,j).gt.smax) then
-              smax=ssym(i,j)
-              ipk=i
-           endif
-        enddo
-
-     do m=m0-1,0,-1                   !Get bit-wise soft symbols
-        if(m.eq.2) then
-           r1=max(ssym(4,j),ssym(5,j),ssym(6,j),ssym(7,j))
-           r0=max(ssym(0,j),ssym(1,j),ssym(2,j),ssym(3,j))
-        else if(m.eq.1) then
-           r1=max(ssym(2,j),ssym(3,j),ssym(4,j),ssym(5,j))
-           r0=max(ssym(0,j),ssym(1,j),ssym(6,j),ssym(7,j))
-        else
-           r1=max(ssym(1,j),ssym(2,j),ssym(4,j),ssym(7,j))
-           r0=max(ssym(0,j),ssym(3,j),ssym(5,j),ssym(6,j))
-        endif
-
-        k=k+1
-        i4=nint(10.0*(r1-r0))
-        if(i4.lt.-127) i4=-127
-        if(i4.gt.127) i4=127
-        i4=i4+128
-        i1SoftSymbolsScrambled(k)=i1
-     enddo
-  enddo
-  call interleave9(i1SoftSymbolsScrambled,-1,i1SoftSymbols)
-
-  return
-end subroutine spec9

Deleted: branches/wsprx/lib/symspec2.f90
===================================================================
--- branches/wsprx/lib/symspec2.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/symspec2.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,85 +0,0 @@
-subroutine symspec2(c5,nz3,nsps8,nspsd,fsample,snrdb,i1SoftSymbolsScrambled)
-
-  complex c5(0:4096-1)
-  complex z
-  integer*1 i1SoftSymbolsScrambled(207)
-  real aa(3)
-  real ss2(0:8,85)
-  real ss3(0:7,69)
-  integer*1 i1
-  equivalence (i1,i4)
-  include 'jt9sync.f90' 
-
-  aa(1)=-1500.0/nsps8
-  aa(2)=0.
-  aa(3)=0.
-  do i=0,8
-     if(i.ge.1) call twkfreq(c5,c5,nz3,fsample,aa)
-     m=0
-     k=-1
-     do j=1,85
-        z=0.
-        do n=1,nspsd
-           k=k+1
-           z=z+c5(k)
-        enddo
-        ss2(i,j)=real(z)**2 + aimag(z)**2
-        if(i.ge.1 .and. isync(j).eq.0) then
-           m=m+1
-           ss3(i-1,m)=ss2(i,j)
-        endif
-     enddo
-  enddo
-
-!###
-  ss=0.
-  sig=0.
-  do j=1,69
-     smax=0.
-     do i=0,7
-        smax=max(smax,ss3(i,j))
-        ss=ss+ss3(i,j)
-     enddo
-     sig=sig+smax
-     ss=ss-smax
-  enddo
-  ave=ss/(69*7) 
-  call pctile(ss2,9*85,35,xmed)
-  ss3=ss3/ave
-
-  sig=sig/69.
-  df8=1500.0/nsps8
-  t=max(1.0,sig - 1.0)
-  snrdb=db(t) - 61.3
-     
-  m0=3
-  k=0
-  do j=1,69
-        smax=0.
-        do i=0,7
-           if(ss3(i,j).gt.smax) smax=ss3(i,j)
-        enddo
-
-     do m=m0-1,0,-1                   !Get bit-wise soft symbols
-        if(m.eq.2) then
-           r1=max(ss3(4,j),ss3(5,j),ss3(6,j),ss3(7,j))
-           r0=max(ss3(0,j),ss3(1,j),ss3(2,j),ss3(3,j))
-        else if(m.eq.1) then
-           r1=max(ss3(2,j),ss3(3,j),ss3(4,j),ss3(5,j))
-           r0=max(ss3(0,j),ss3(1,j),ss3(6,j),ss3(7,j))
-        else
-           r1=max(ss3(1,j),ss3(2,j),ss3(4,j),ss3(7,j))
-           r0=max(ss3(0,j),ss3(3,j),ss3(5,j),ss3(6,j))
-        endif
-
-        k=k+1
-        i4=nint(10.0*(r1-r0))
-        if(i4.lt.-127) i4=-127
-        if(i4.gt.127) i4=127
-        i4=i4+128
-        i1SoftSymbolsScrambled(k)=i1
-     enddo
-  enddo
-
-  return
-end subroutine symspec2

Added: branches/wsprx/lib/sync162.f
===================================================================
--- branches/wsprx/lib/sync162.f	                        (rev 0)
+++ branches/wsprx/lib/sync162.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,199 @@
+      subroutine sync162(c2,jz,ps,sstf,kz)
+
+C  Find MEPT_JT sync signals, with best-fit DT and DF.  
+
+      complex c2(jz)
+      parameter (NFFT=512)             !Length of FFTs
+      parameter (NH=NFFT/2)            !Length of power spectra
+      parameter (NSMAX=351)            !Number of half-symbol steps
+      parameter (NF0=136,NF1=10)
+      parameter (LAGMAX=26)
+      real psavg(-NH:NH)               !Average spectrum of whole record
+      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
+      real ps(-NH:NH)
+      real psmo(-NH:NH)
+      real freq(-NH:NH)
+      real p1(-NH:NH)
+      real drift(-NH:NH)
+      real dtx(-NH:NH)
+      integer keep0(-NH:NH)
+      integer keep(-NH:NH)
+      real a(5)
+      real sstf(5,275)
+      real tmp(275)
+      integer npr3(162)
+      real pr3(162)
+      data npr3/
+     +  1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     +  0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     +  0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     +  1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     +  0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     +  0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     +  0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     +  0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     +  0,0/
+      save
+
+      nsym=162
+      do i=1,nsym
+         pr3(i)=2*npr3(i)-1
+      enddo
+
+C  Do FFTs of twice symbol length, stepped by half symbols.  
+      nq=NFFT/4
+      nsteps=jz/nq - 1
+      df=375.0/nfft
+      dt=1.0/375.0
+      call zero(psavg,NFFT+1)
+
+C  Compute power spectrum for each step, and get average
+      do j=1,nsteps
+         k=(j-1)*nq + 1
+         call ps162(c2(k),s2(-NH,j))
+         call add(psavg,s2(-NH,j),psavg,NFFT)
+      enddo
+
+! Normalize and subtract baseline from psavg.
+      call pctile(psavg(-136),tmp,273,35,base)
+      psavg=psavg/base - 1.0
+      base=base/351.0
+      s2=s2/base - 1.0
+
+! Boxcar-smooth the average spectrum over the WSPR signal bandwidth.
+      do i=-NH+3,NH-3
+         psmo(i)=0.
+         do k=-3,3
+            psmo(i)=psmo(i)+ps(i+k)
+         enddo
+         psmo(i)=psmo(i)/7.0
+      enddo
+
+! Mark potential suspects for WSPR signals.  
+! (Keep only the best one within a surrounding range of +/- 8 bins.)
+
+      plimit=0.1                      !### Are the plimit values OK? ###
+      do i=-NF0,NF0
+         keep0(i)=0
+         keep(i)=0
+         ia=i-4
+         ib=i+4
+         pmax=-1.e30
+         do ii=ia,ib
+            if(psmo(ii).gt.pmax) then
+               ipk=ii
+               pmax=psmo(ii)
+            endif
+         enddo
+         if(ipk.eq.i .and. pmax.ge.plimit) then
+            keep0(i)=1
+! Kill all smaller peaks leading up to this maximum.
+            do ii=ia,i-1
+               keep0(ii)=0
+            enddo
+         endif
+      enddo
+
+! Now mark the bins +/- 1 from each one already marked.
+      do i=-NF0+1,NF0-1
+         if(keep0(i).eq.1) then
+            keep(i-1)=1
+            keep(i)=1
+            keep(i+1)=1
+         endif
+      enddo
+
+! Now do the main search over DT, DF, and drift.  (Do CCFs in all marked
+! frequency bins and over a range of reasonable fdot values and lags.)
+      p1=0.
+      do i=-NF0,NF0
+         if(keep(i).eq.0) go to 10
+         smax=0.
+         do k=-NF1,NF1
+            if(abs(k).ne.1) then
+               do lag=0,LAGMAX
+                  sum=0.
+                  n=lag-1
+                  do j=1,162
+                     n=n+2
+                     ii=i + nint(k*(j-81)/162.0)
+                     x=max(s2(ii-1,n),s2(ii+3,n)) - 
+     +                    max(s2(ii-3,n),s2(ii+1,n))
+                     sum=sum + x*pr3(j)
+                  enddo
+                  if(sum.gt.smax) then
+                     kpk=k
+                     lagpk=lag
+                     smax=sum
+                  endif
+               enddo
+            endif
+         enddo
+
+! Save the CCF value, frequency, drift rate, and DT.
+         p1(i)=smax
+         freq(i)=df*i
+         drift(i)=df*kpk
+         dtx(i)=128.0*dt*lagpk
+ 10      continue
+      enddo
+
+! Eliminate potential duplicates and peaks smaller than plimit.
+      keep=0
+      plimit=1.0
+      do i=-NF0,NF0
+         ia=max(-NF0,i-8)
+         ib=min(NF0,i+8)
+         pmax=-1.e30
+         do ii=ia,ib
+            if(p1(ii).gt.pmax) then
+               ipk=ii
+               pmax=p1(ii)
+            endif
+         enddo
+         if(ipk.eq.i .and. pmax.ge.plimit) then
+            keep(i)=1
+            do ii=ia,i-1
+               keep(ii)=0
+            enddo
+         endif
+      enddo
+
+! Compress the candidate list, saving only the potentially important ones.
+! Recalibrate sync indicator p1 on a dB scale.  
+! (NB: p1 sould be compared with snrx!)
+      k=0
+      do i=-NF0,NF0
+         if(keep(i).ne.0) then
+            x=10.0*log10(p1(i)) - 22
+            if(x.ge.0.5) then
+               k=min(k+1,275)
+               p1(k)=x
+               freq(k)=freq(i)
+               drift(k)=drift(i)
+               dtx(k)=dtx(i) - 2.0
+            endif
+         endif
+      enddo
+      kz=k
+
+      do k=1,kz
+         a(1)=-freq(k)
+         a(2)=-0.5*drift(k)
+         a(3)=0.
+         lagpk=nint((dtx(k)+2)/(128*dt))
+         lag1=max(-200,8*lagpk-16)
+         lag2=min(200,8*lagpk+16)
+         ccf=fchisq(c2,jz,375.0,a,lag1,lag2,ccfbest,dtbest)
+         ipk=nint(freq(k)/df)
+         snrx=db(max(psavg(ipk),0.0001)) - 26.5         !Empirical
+         sstf(1,k)=p1(k)
+         sstf(2,k)=snrx
+         sstf(3,k)=dtbest-2.0
+         sstf(4,k)=freq(k)
+         sstf(5,k)=drift(k)
+      enddo
+      
+      return
+      end
+

Deleted: branches/wsprx/lib/sync9.f90
===================================================================
--- branches/wsprx/lib/sync9.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/sync9.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,53 +0,0 @@
-subroutine sync9(ss,nzhsym,tstep,df3,ntol,nfqso,ccfred,ia,ib,ipkbest)
-
-  parameter (NSMAX=22000)            !Max length of saved spectra
-  real ss(184,NSMAX)
-  real ccfred(NSMAX)
-  include 'jt9sync.f90'
-
-  ipk=0
-  ipkbest=0
-  ia=1
-  ib=min(1000,nint(1000.0/df3))
-
-  if(ntol.lt.1000) then
-     ia=nint((nfqso-1000-ntol)/df3)
-     ib=nint((nfqso-1000+ntol)/df3)
-     if(ia.lt.1) ia=1
-     if(ib.gt.NSMAX) ib=NSMAX
-  endif
-
-  sbest=0.
-  lag1=-(2.5/tstep + 0.9999)
-  lag2=5.0/tstep + 0.9999
-  ccfred=0.
-
-  do i=ia,ib
-     smax=0.
-     do lag=lag1,lag2
-        sum=0.
-        do j=1,16
-           k=ii2(j) + lag
-           kaa=ka(j)+lag
-           kbb=kb(j)+lag
-           if(k.ge.1 .and. k.le.nzhsym) sum=sum + ss(k,i) -      &amp;
-                0.5*(ss(kaa,i)+ss(kbb,i))
-        enddo
-        if(sum.gt.smax) then
-           smax=sum
-           ipk=i
-        endif
-     enddo
-     ccfred(i)=smax                        !Best at this freq, over all lags
-     if(smax.gt.sbest) then
-        sbest=smax
-        ipkbest=ipk
-     endif
-  enddo
-
-  call pctile(ccfred(ia),ib-ia+1,50,xmed)
-  if(xmed.le.0.0) xmed=1.0
-  ccfred=ccfred/xmed
-
-  return
-end subroutine sync9

Deleted: branches/wsprx/lib/tab.c
===================================================================
--- branches/wsprx/lib/tab.c	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/tab.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,36 +0,0 @@
-/* 8-bit parity lookup table, generated by partab.c */
-unsigned char Partab[] = {
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 0, 1, 1, 0, 1, 0, 0, 1,
- 1, 0, 0, 1, 0, 1, 1, 0,
-};
-

Deleted: branches/wsprx/lib/timer.f90
===================================================================
--- branches/wsprx/lib/timer.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/timer.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,110 +0,0 @@
-subroutine timer(dname,k)
-
-! Times procedure number n between a call with k=0 (tstart) and with
-! k=1 (tstop). Accumulates sums of these times in array ut (user time).
-! Also traces all calls (for debugging purposes) if limtrace.gt.0
-
-  character*8 dname,name(50),space,ename
-  character*16 sname
-  logical on(50)
-  real ut(50),ut0(50),dut(50),tt(2)
-  integer ncall(50),nlevel(50),nparent(50)
-  integer onlevel(0:10)
-  common/tracer/ limtrace,lu
-  data eps/0.000001/,ntrace/0/
-  data level/0/,nmax/0/,space/'        '/
-  data limtrace/0/,lu/-1/
-  save
-
-  if(limtrace.lt.0) go to 999
-  if(lu.lt.1) lu=6
-  if(k.gt.1) go to 40                        !Check for &quot;all done&quot; (k&gt;1)
-  onlevel(0)=0
-
-  do n=1,nmax                                !Check for existing name
-     if(name(n).eq.dname) go to 20
-  enddo
-
-  nmax=nmax+1                                !This is a new one
-  n=nmax
-  ncall(n)=0
-  on(n)=.false.
-  ut(n)=eps
-  name(n)=dname
-
-20 if(k.eq.0) then                                !Get start times (k=0)
-     if(on(n)) print*,'Error in timer: ',dname,' already on.'
-     level=level+1                                !Increment the level
-     on(n)=.true.
-     ut0(n)=etime(tt)
-     ncall(n)=ncall(n)+1
-     if(ncall(n).gt.1.and.nlevel(n).ne.level) then
-        nlevel(n)=-1
-     else
-        nlevel(n)=level
-     endif
-     nparent(n)=onlevel(level-1)
-     onlevel(level)=n
-
-  else if(k.eq.1) then        !Get stop times and accumulate sums. (k=1)
-     if(on(n)) then
-        on(n)=.false.
-        ut1=etime(tt)
-        ut(n)=ut(n)+ut1-ut0(n)
-     endif
-     level=level-1
-  endif
-
-  ntrace=ntrace+1
-  if(ntrace.lt.limtrace) write(lu,1020) ntrace,dname,k,level,nparent(n)
-1020 format(i8,': ',a8,3i5)
-  go to 998
-
-! Write out the timer statistics
-
-40 write(lu,1040)
-1040 format(/'     name                 time  frac     dtime',       &amp;
-             ' dfrac  calls level parent'/73('-'))
-
-  if(k.gt.100) then
-     ndiv=k-100
-     do i=1,nmax
-        ncall(i)=ncall(i)/ndiv
-        ut(i)=ut(i)/ndiv
-     enddo
-  endif
-
-  total=ut(1)
-  sum=0.
-  sumf=0.
-  do i=1,nmax
-     dut(i)=ut(i)
-     do j=i,nmax
-        if(nparent(j).eq.i) dut(i)=dut(i)-ut(j)
-     enddo
-     utf=ut(i)/total
-     dutf=dut(i)/total
-     sum=sum+dut(i)
-     sumf=sumf+dutf
-     kk=nlevel(i)
-     sname=space(1:kk)//name(i)//space(1:8-kk)
-     ename=space
-     if(i.ge.2) ename=name(nparent(i))
-     write(lu,1060) float(i),sname,ut(i),utf,dut(i),dutf,           &amp;
-          ncall(i),nlevel(i),ename
-1060 format(f4.0,a16,2(f10.2,f6.2),i7,i5,2x,a8)
-  enddo
-
-  write(lu,1070) sum,sumf
-1070 format(/36x,f10.2,f6.2)
-  nmax=0
-  eps=0.000001
-  ntrace=0
-  level=0
-  space='        '
-  onlevel(0)=0
-
-998 flush(lu)
-
-999 return
-end subroutine timer

Deleted: branches/wsprx/lib/timeval.h
===================================================================
--- branches/wsprx/lib/timeval.h	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/timeval.h	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,74 +0,0 @@
-/*
- * timeval.h    1.0 01/12/19
- *
- * Defines gettimeofday, timeval, etc. for Win32
- *
- * By Wu Yongwei
- *
- */
-
-#ifndef _TIMEVAL_H
-#define _TIMEVAL_H
-
-#ifdef _WIN32
-
-#define WIN32_LEAN_AND_MEAN
-#include &lt;windows.h&gt;
-#include &lt;time.h&gt;
-
-#ifndef __GNUC__
-#define EPOCHFILETIME (116444736000000000i64)
-#else
-#define EPOCHFILETIME (116444736000000000LL)
-#endif
-
-//struct timeval {
-//    long tv_sec;        /* seconds */
-//    long tv_usec;  /* microseconds */
-//};
-
-struct timezone {
-    int tz_minuteswest; /* minutes W of Greenwich */
-    int tz_dsttime;     /* type of dst correction */
-};
-
-__inline int gettimeofday(struct timeval *tv, struct timezone *tz)
-{
-    FILETIME        ft;
-    LARGE_INTEGER   li;
-    __int64         t;
-    static int      tzflag;
-
-    if (tv)
-    {
-        GetSystemTimeAsFileTime(&amp;ft);
-        li.LowPart  = ft.dwLowDateTime;
-        li.HighPart = ft.dwHighDateTime;
-        t  = li.QuadPart;       /* In 100-nanosecond intervals */
-        t -= EPOCHFILETIME;     /* Offset to the Epoch time */
-        t /= 10;                /* In microseconds */
-        tv-&gt;tv_sec  = (long)(t / 1000000);
-        tv-&gt;tv_usec = (long)(t % 1000000);
-    }
-
-    if (tz)
-    {
-        if (!tzflag)
-        {
-            _tzset();
-            tzflag++;
-        }
-        tz-&gt;tz_minuteswest = _timezone / 60;
-        tz-&gt;tz_dsttime = _daylight;
-    }
-
-    return 0;
-}
-
-#else  /* _WIN32 */
-
-#include &lt;sys/time.h&gt;
-
-#endif /* _WIN32 */
-
-#endif /* _TIMEVAL_H */

Added: branches/wsprx/lib/twkfreq.f
===================================================================
--- branches/wsprx/lib/twkfreq.f	                        (rev 0)
+++ branches/wsprx/lib/twkfreq.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,31 @@
+      subroutine twkfreq(ca,cb,jz,a)
+
+C  Apply AFC corrections to ca, returning corrected data in cb
+
+      complex ca(jz),cb(jz)
+      real a(5)
+      real*8 twopi
+      complex*16 w,wstep
+      data twopi/0.d0/
+      save twopi
+
+      if(twopi.eq.0.d0) twopi=8.d0*atan(1.d0)
+      w=1.d0
+      wstep=1.d0
+      x0=0.5*(jz+1)
+      s=2.0/jz
+      do i=1,jz
+         x=s*(i-x0)
+         if(mod(i,100).eq.1) then
+            p2=1.5*x*x - 0.5
+!            p3=2.5*(x**3) - 1.5*x
+!            p4=4.375*(x**4) - 3.75*(x**2) + 0.375
+            dphi=(a(1) + x*a(2) + p2*a(3)) * (twopi/375.0)
+            wstep=cmplx(cos(dphi),sin(dphi))
+         endif
+         w=w*wstep
+         cb(i)=w*ca(i)
+      enddo
+
+      return
+      end

Deleted: branches/wsprx/lib/twkfreq.f90
===================================================================
--- branches/wsprx/lib/twkfreq.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/twkfreq.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,28 +0,0 @@
-subroutine twkfreq(c3,c4,npts,fsample,a)
-
-  complex c3(npts)
-  complex c4(npts)
-  complex w,wstep
-  real a(3)
-  data twopi/6.283185307/
-
-! Mix the complex signal
-  w=1.0
-  wstep=1.0
-  x0=0.5*(npts+1)
-  s=2.0/npts
-  do i=1,npts
-     x=s*(i-x0)
-!     if(mod(i,100).eq.1) then
-        p2=1.5*x*x - 0.5
-!          p3=2.5*(x**3) - 1.5*x
-!          p4=4.375*(x**4) - 3.75*(x**2) + 0.375
-        dphi=(a(1) + x*a(2) + p2*a(3)) * (twopi/fsample)
-        wstep=cmplx(cos(dphi),sin(dphi))
-!     endif
-     w=w*wstep
-     c4(i)=w*c3(i)
-  enddo
-
-  return
-end subroutine twkfreq

Added: branches/wsprx/lib/unpack50.f
===================================================================
--- branches/wsprx/lib/unpack50.f	                        (rev 0)
+++ branches/wsprx/lib/unpack50.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,30 @@
+      subroutine unpack50(dat,n1,n2)
+
+      integer*1 dat(11)
+
+      i=dat(1)
+      i4=iand(i,255)
+      n1=ishft(i4,20)
+      i=dat(2)
+      i4=iand(i,255)
+      n1=n1 + ishft(i4,12)
+      i=dat(3)
+      i4=iand(i,255)
+      n1=n1 + ishft(i4,4)
+      i=dat(4)
+      i4=iand(i,255)
+      n1=n1 + iand(ishft(i4,-4),15)
+      n2=ishft(iand(i4,15),18)
+      i=dat(5)
+      i4=iand(i,255)
+      n2=n2 + ishft(i4,10)
+      i=dat(6)
+      i4=iand(i,255)
+      n2=n2 + ishft(i4,2)
+      i=dat(7)
+      i4=iand(i,255)
+      n2=n2 + iand(ishft(i4,-6),3)
+
+      return
+      end
+

Deleted: branches/wsprx/lib/unpackbits.f90
===================================================================
--- branches/wsprx/lib/unpackbits.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/unpackbits.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,24 +0,0 @@
-subroutine unpackbits(sym,nsymd,m0,dbits)
-
-! Unpack bits from sym() into dbits(), one bit per byte.
-! NB: nsymd is the number of input words, and m0 their length.
-! there will be m0*nsymd output bytes, each 0 or 1.
-
-  integer sym(nsymd)
-  integer*1 dbits(*)
-  integer*1 n1
-  equivalence (n,n1)
-
-  k=0
-  do i=1,nsymd
-     mask=ishft(1,m0-1)
-     do j=1,m0
-        k=k+1
-        dbits(k)=0
-        if(iand(mask,sym(i)).ne.0) dbits(k)=1
-        mask=ishft(mask,-1)
-     enddo
-  enddo
-
-  return
-end subroutine unpackbits

Deleted: branches/wsprx/lib/unpackmsg.f90
===================================================================
--- branches/wsprx/lib/unpackmsg.f90	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/unpackmsg.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,103 +0,0 @@
-subroutine unpackmsg(dat,msg)
-
-  parameter (NBASE=37*36*10*27*27*27)
-  parameter (NGBASE=180*180)
-  integer dat(12)
-  character c1*12,c2*12,grid*4,msg*22,grid6*6,psfx*4,junk2*4
-  logical cqnnn
-
-  cqnnn=.false.
-  nc1=ishft(dat(1),22) + ishft(dat(2),16) + ishft(dat(3),10)+         &amp;
-       ishft(dat(4),4) + iand(ishft(dat(5),-2),15)
-
-  nc2=ishft(iand(dat(5),3),26) + ishft(dat(6),20) +                   &amp;
-       ishft(dat(7),14) + ishft(dat(8),8) + ishft(dat(9),2) +         &amp;
-       iand(ishft(dat(10),-4),3)
-
-  ng=ishft(iand(dat(10),15),12) + ishft(dat(11),6) + dat(12)
-
-  if(ng.gt.32768) then
-     call unpacktext(nc1,nc2,ng,msg)
-     go to 100
-  endif
-
-  call unpackcall(nc1,c1,iv2,psfx)
-  if(iv2.eq.0) then
-! This is an &quot;original JT65&quot; message
-     if(nc1.eq.NBASE+1) c1='CQ    '
-     if(nc1.eq.NBASE+2) c1='QRZ   '
-     nfreq=nc1-NBASE-3
-     if(nfreq.ge.0 .and. nfreq.le.999) then
-        write(c1,1002) nfreq
-1002    format('CQ ',i3.3)
-        cqnnn=.true.
-     endif
-  endif
-
-  call unpackcall(nc2,c2,junk1,junk2)
-  call unpackgrid(ng,grid)
-
-  if(iv2.gt.0) then
-! This is a JT65v2 message
-     n1=len_trim(psfx)
-     n2=len_trim(c2)
-     if(iv2.eq.1) msg='CQ '//psfx(:n1)//'/'//c2(:n2)//' '//grid
-     if(iv2.eq.2) msg='QRZ '//psfx(:n1)//'/'//c2(:n2)//' '//grid
-     if(iv2.eq.3) msg='DE '//psfx(:n1)//'/'//c2(:n2)//' '//grid
-     if(iv2.eq.4) msg='CQ '//c2(:n2)//'/'//psfx(:n1)//' '//grid
-     if(iv2.eq.5) msg='QRZ '//c2(:n2)//'/'//psfx(:n1)//' '//grid
-     if(iv2.eq.6) msg='DE '//c2(:n2)//'/'//psfx(:n1)//' '//grid
-     if(iv2.eq.7) msg='DE '//c2(:n2)//' '//grid
-     go to 100
-  else
-     
-  endif
-
-  grid6=grid//'ma'
-  call grid2k(grid6,k)
-  if(k.ge.1 .and. k.le.450)   call getpfx2(k,c1)
-  if(k.ge.451 .and. k.le.900) call getpfx2(k,c2)
-
-  i=index(c1,char(0))
-  if(i.ge.3) c1=c1(1:i-1)//'            '
-  i=index(c2,char(0))
-  if(i.ge.3) c2=c2(1:i-1)//'            '
-
-  msg='                      '
-  j=0
-  if(cqnnn) then
-     msg=c1//'          '
-     j=7                                  !### ??? ###
-     go to 10
-  endif
-
-  do i=1,12
-     j=j+1
-     msg(j:j)=c1(i:i)
-     if(c1(i:i).eq.' ') go to 10
-  enddo
-  j=j+1
-  msg(j:j)=' '
-
-10 do i=1,12
-     if(j.le.21) j=j+1
-     msg(j:j)=c2(i:i)
-     if(c2(i:i).eq.' ') go to 20
-  enddo
-  if(j.le.21) j=j+1
-  msg(j:j)=' '
-
-20 if(k.eq.0) then
-     do i=1,4
-        if(j.le.21) j=j+1
-        msg(j:j)=grid(i:i)
-     enddo
-     if(j.le.21) j=j+1
-     msg(j:j)=' '
-  endif
-
-100 continue
-  if(msg(1:6).eq.'CQ9DX ') msg(3:3)=' '
-
-  return
-end subroutine unpackmsg

Added: branches/wsprx/lib/unpackpfx.f90
===================================================================
--- branches/wsprx/lib/unpackpfx.f90	                        (rev 0)
+++ branches/wsprx/lib/unpackpfx.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,39 @@
+subroutine unpackpfx(ng,call1)
+
+  character*12 call1
+  character*3 pfx
+
+  if(ng.lt.60000) then
+! Add-on prefix of 1 to 3 characters
+     n=ng
+     do i=3,1,-1
+        nc=mod(n,37)
+        if(nc.ge.0 .and. nc.le.9) then
+           pfx(i:i)=char(nc+48)
+        else if(nc.ge.10 .and. nc.le.35) then
+           pfx(i:i)=char(nc+55)
+        else
+           pfx(i:i)=' '
+        endif
+        n=n/37
+     enddo
+     call1=pfx//'/'//call1
+     if(call1(1:1).eq.' ') call1=call1(2:)
+     if(call1(1:1).eq.' ') call1=call1(2:)
+  else
+! Add-on suffix, one or teo characters
+     i1=index(call1,' ')
+     nc=ng-60000
+     if(nc.ge.0 .and. nc.le.9) then
+        call1=call1(:i1-1)//'/'//char(nc+48)
+     else if(nc.ge.10 .and. nc.le.35) then
+        call1=call1(:i1-1)//'/'//char(nc+55)
+     else if(nc.ge.36 .and. nc.le.125) then
+        nc1=(nc-26)/10
+        nc2=mod(nc-26,10)
+        call1=call1(:i1-1)//'/'//char(nc1+48)//char(nc2+48)
+     endif
+  endif
+
+  return
+end subroutine unpackpfx

Deleted: branches/wsprx/lib/unpacktext.f
===================================================================
--- branches/wsprx/lib/unpacktext.f	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/unpacktext.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,35 +0,0 @@
-      subroutine unpacktext(nc1,nc2,nc3,msg)
-
-      character*22 msg
-      character*44 c
-      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?'/
-
-      nc3=iand(nc3,32767)                      !Remove the &quot;plain text&quot; bit
-      if(iand(nc1,1).ne.0) nc3=nc3+32768
-      nc1=nc1/2
-      if(iand(nc2,1).ne.0) nc3=nc3+65536
-      nc2=nc2/2
-
-      do i=5,1,-1
-         j=mod(nc1,42)+1
-         msg(i:i)=c(j:j)
-         nc1=nc1/42
-      enddo
-
-      do i=10,6,-1
-         j=mod(nc2,42)+1
-         msg(i:i)=c(j:j)
-         nc2=nc2/42
-      enddo
-
-      do i=13,11,-1
-         j=mod(nc3,42)+1
-         msg(i:i)=c(j:j)
-         nc3=nc3/42
-      enddo
-      msg(14:22) = '         '
-
-      return
-      end
-
-

Deleted: branches/wsprx/lib/vit216.c
===================================================================
--- branches/wsprx/lib/vit216.c	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/lib/vit216.c	2012-12-13 15:36:21 UTC (rev 2804)
@@ -1,219 +0,0 @@
-/* Viterbi decoder for arbitrary convolutional code
- * viterbi27 and viterbi37 for the r=1/2 and r=1/3 K=7 codes are faster
- * Copyright 1999 Phil Karn, KA9Q
- * May be used under the terms of the GNU Public License
- */
-
-/* Select code here */
-
-#define V216
-
-
-#ifdef V216
-#define	K 16			/* Constraint length */
-#define N 2			/* Number of symbols per data bit */
-#define Polys	Poly216		/* Select polynomials here */
-#endif
-
-/* Rate 1/2 codes */
-unsigned int Poly216[] = {0126723, 0152711};	/* k = 16  */
-
-#include &lt;memory.h&gt;
-#define NULL ((void *)0)
-
-#define LONGBITS 32
-#define LOGLONGBITS 5
-
-#undef max
-#define max(x,y) ((x) &gt; (y) ? (x) : (y))
-#define D       (1 &lt;&lt; max(0,K-LOGLONGBITS-1))
-#define MAXNBITS 200            /* Maximum frame size (user bits) */
-
-extern unsigned char Partab[];	/* Parity lookup table */
-
-int Syms[1 &lt;&lt; K];
-int VDInit = 0;
-
-int parity(int x)
-{
-  x ^= (x &gt;&gt; 16);
-  x ^= (x &gt;&gt; 8);
-  return Partab[x &amp; 0xff];
-}
-
-// Wrapper for calling &quot;encode&quot; from Fortran:
-//void __stdcall ENCODE(
-void enc216_(
-unsigned char data[],           // User data, 8 bits per byte
-int *nbits,                     // Number of user bits
-unsigned char symbols[],        // Encoded one-bit symbols, 8 per byte
-int *nsymbols,                  // Number of symbols
-int *kk,                        // K
-int *nn)                        // N
-{
-  int nbytes;
-  nbytes=(*nbits+7)/8;          // Always encode multiple of 8 information bits
-  enc216(symbols,data,nbytes,0,0); // Do the encoding
-  *nsymbols=(*nbits+K-1)*N;        // Return number of encoded symbols
-  *kk=K;
-  *nn=N;
-}
-
-/* Convolutionally encode data into binary symbols */
-  enc216(unsigned char symbols[], unsigned char data[],
-       unsigned int nbytes, unsigned int startstate,
-       unsigned int endstate)
-{
-  int i,j,k,n=-1;
-  unsigned int encstate = startstate;
-
-  for(k=0; k&lt;nbytes; k++) {
-    for(i=7;i&gt;=0;i--){
-      encstate = (encstate + encstate) + ((data[k] &gt;&gt; i) &amp; 1);
-      for(j=0;j&lt;N;j++) {
-	n=n+1;
-	symbols[n] = parity(encstate &amp; Polys[j]);
-      }
-    }
-  }
-  // Flush out with zero tail.  (No need, if tail-biting code.)
-  for(i=0; i&lt;K-1;i++){
-    encstate = (encstate &lt;&lt; 1) | ((endstate &gt;&gt; i) &amp; 1);
-    for(j=0;j&lt;N;j++) {
-      n=n+1;
-      symbols[n] = parity(encstate &amp; Polys[j]);
-    }
-  }
-  return 0;
-}
-
-// Wrapper for calling &quot;viterbi&quot; from Fortran:
-//void __stdcall VITERBI(
-void vit216_(
-unsigned char symbols[],  /* Raw deinterleaved input symbols */
-unsigned int *Nbits,	  /* Number of decoded information bits */
-int mettab[2][256],	  /* Metric table, [sent sym][rx symbol] */
-unsigned char ddec[],	  /* Decoded output data */
-long *Metric              /* Final path metric (bigger is better) */
-){
-  long metric;
-  vit216(&amp;metric,ddec,symbols,*Nbits,mettab,0,0);
-  *Metric=metric;
-}
-
-/* Viterbi decoder */
-int vit216(
-long *metric,           /* Final path metric (returned value) */
-unsigned char *data,	/* Decoded output data */
-unsigned char *symbols,	/* Raw deinterleaved input symbols */
-unsigned int nbits,	/* Number of output bits */
-int mettab[2][256],	/* Metric table, [sent sym][rx symbol] */
-unsigned int startstate,         /* Encoder starting state */
-unsigned int endstate            /* Encoder ending state */
-){
-  int bitcnt = -(K-1);
-  long m0,m1;
-  int i,j,sym,ipp;
-  int mets[1 &lt;&lt; N];
-  unsigned long paths[(MAXNBITS+K-1)*D];
-  unsigned long *pp,mask;
-  long cmetric[1 &lt;&lt; (K-1)],nmetric[1 &lt;&lt; (K-1)];
-  
-  memset(paths,0,sizeof(paths));
-
-  // Initialize on first time through:
-  if(!VDInit){
-    for(i=0;i&lt;(1&lt;&lt;K);i++){
-      sym = 0;
-      for(j=0;j&lt;N;j++)
-	sym = (sym &lt;&lt; 1) + parity(i &amp; Polys[j]);
-      Syms[i] = sym;
-    }
-    VDInit++;
-  }
-
-  // Keep only lower K-1 bits of specified startstate and endstate
-  startstate &amp;= ~((1&lt;&lt;(K-1)) - 1);
-  endstate &amp;=   ~((1&lt;&lt;(K-1)) - 1);
-
-  /* Initialize starting metrics */
-  for(i=0;i&lt; 1&lt;&lt;(K-1);i++)
-    cmetric[i] = -999999;
-  cmetric[startstate] = 0;
-
-  pp = paths;
-  ipp=0;
-  for(;;){ /* For each data bit */
-    /* Read input symbols and compute branch metrics */
-    for(i=0;i&lt; 1&lt;&lt;N;i++){
-      mets[i] = 0;
-      for(j=0;j&lt;N;j++){
-	mets[i] += mettab[(i &gt;&gt; (N-j-1)) &amp; 1][symbols[j]];
-      }
-    }
-    symbols += N;
-    /* Run the add-compare-select operations */
-    mask = 1;
-    for(i=0;i&lt; 1 &lt;&lt; (K-1);i+=2){
-      int b1,b2;
-      
-      b1 = mets[Syms[i]];
-      nmetric[i] = m0 = cmetric[i/2] + b1; 
-      b2 = mets[Syms[i+1]];
-      b1 -= b2;
-      m1 = cmetric[(i/2) + (1&lt;&lt;(K-2))] + b2;
-
-      if(m1 &gt; m0){
-	nmetric[i] = m1;
-	*pp |= mask;
-      }
-
-      m0 -= b1;
-      nmetric[i+1] = m0;
-      m1 += b1;
-
-      if(m1 &gt; m0){
-	nmetric[i+1] = m1;
-	*pp |= mask &lt;&lt; 1;
-      }
-
-      mask &lt;&lt;= 2;
-      if(mask == 0){
-	mask = 1;
-	pp++;
-	ipp++;
-      }
-    }
-    if(mask != 1){
-      pp++;
-      ipp++;
-    }
-    if(++bitcnt == nbits){
-      *metric = nmetric[endstate];
-      break;
-    }
-    memcpy(cmetric,nmetric,sizeof(cmetric));
-  }
-
-  /* Chain back from terminal state to produce decoded data */
-  if(data == NULL)
-    return 0;/* Discard output */
-  memset(data,0,(nbits+7)/8); /* round up in case nbits % 8 != 0 */
-
-  for(i=nbits-1;i &gt;= 0;i--){
-    //    int a0,a1;
-    pp -= D;
-    ipp -= D;
-    m0=endstate &gt;&gt; LOGLONGBITS;
-    m1=1L &lt;&lt; (endstate &amp; (LONGBITS-1));
-    if(pp[m0] &amp; m1) {
-      //      a0=nmetric[endstate];
-      endstate |= (1 &lt;&lt; (K-1));
-      //      a1=nmetric[endstate];
-      data[i&gt;&gt;3] |= 0x80 &gt;&gt; (i&amp;7);
-      //      printf(&quot;B  %d  %d  %d  %d\n&quot;,*metric,i,a0,a1);
-    }
-    endstate &gt;&gt;= 1;
-  }
-  return 0;
-}

Added: branches/wsprx/lib/wfile5.f
===================================================================
--- branches/wsprx/lib/wfile5.f	                        (rev 0)
+++ branches/wsprx/lib/wfile5.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,89 @@
+      subroutine wfile5(iwave,nmax,nfsample,outfile)
+
+C  Write a wavefile to disk.
+
+      integer*1 n4 
+      integer*2 iwave(nmax)
+      character*80 outfile
+
+      integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+      character*4 ariff,awave,afmt,adata
+      integer*1 hdr(44)
+      integer*2 iswap_short
+      common/hdr/ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,
+     +     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata
+      equivalence (hdr,ariff),(nfmt2,n4)
+
+C  Generate the header
+      ariff='RIFF'
+      awave='WAVE'
+      afmt='fmt '
+      adata='data'
+      lenfmt=16                             !Rest of this sub-chunk is 16 bytes long
+      nfmt2=1                               !PCM = 1
+      nchan2=1                              !1=mono, 2=stereo
+      nbitsam2=16                           !Bits per sample
+      nsamrate=nfsample
+      nbytesec=nfsample*nchan2*nbitsam2/8   !Bytes per second
+      nbytesam2=nchan2*nbitsam2/8           !Block-align               
+      ndata=nmax*nchan2*nbitsam2/8
+      nbytes=ndata+44
+      nchunk=nbytes-8
+
+      call cs_lock('wfile5')
+      open(12,file=outfile,access='stream',status='unknown')
+      if (n4.ne.nfmt2) then
+        call change_endian                  !Change hdr to little-endian
+        do i=1,nmax
+            iwave(i) = iswap_short(iwave(i))!Change data to little-endian
+        enddo
+      endif
+      write(12) hdr
+      write(12) iwave
+      close(12)
+      call cs_unlock
+
+      return
+      end
+
+      subroutine change_endian
+
+      integer*1 hdr(44)
+      integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+      integer*2 iswap_short
+      character*4 ariff,awave,afmt,adata
+      common/hdr/ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2, 
+     +       nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata
+      equivalence (ariff,hdr)
+
+      nchunk = iswap_int(nchunk)
+      lenfmt = iswap_int(lenfmt)
+      nfmt2 = iswap_short(nfmt2)
+      nchan2 = iswap_short(nchan2)
+      nsamrate = iswap_int(nsamrate)
+      nbytesec = iswap_int(nbytesec)
+      nbytesam2 = iswap_short(nbytesam2)
+      nbitsam2 = iswap_short(nbitsam2)
+      ndata = iswap_int(ndata)
+
+      return
+      end subroutine change_endian
+
+      integer function iswap_int(idat)
+
+      itemp1 = ior(ishft(idat,24), iand(ishft(idat,8), z'00ff0000'))
+      itemp0 = ior(iand(ishft(idat,-8), z'0000ff00'), 
+     +             iand(ishft(idat,-24),z'000000ff'))
+      iswap_int = ior(itemp1,itemp0)
+      
+      end function iswap_int
+
+      integer*2 function iswap_short(idat)
+
+      integer*2 idat,m2
+      data m2/255/
+
+      iswap_short = ior(ishft(idat,8), iand(ishft(idat,-8), m2))
+
+      end function iswap_short
+

Added: branches/wsprx/lib/wqdecode.f90
===================================================================
--- branches/wsprx/lib/wqdecode.f90	                        (rev 0)
+++ branches/wsprx/lib/wqdecode.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,73 @@
+subroutine wqdecode(data0,message,ntype)
+
+  parameter (N15=32768)
+  integer*1 data0(11)
+  character*22 message
+  character*12 callsign
+  character*3 cdbm
+  character grid4*4,grid6*6
+  logical first
+  character*12 dcall(0:N15-1)
+  data first/.true./
+  save first,dcall
+
+  call cs_lock('wqdecode')
+! May want to have a timeout (say, one hour?) on calls fetched 
+! from the hash table.
+
+  if(first) then
+     dcall='            '
+     first=.false.
+  endif
+
+  message='                      '
+  call unpack50(data0,n1,n2)
+  call unpackcall(n1,callsign)
+  i1=index(callsign,' ')
+  call unpackgrid(n2/128,grid4)
+  ntype=iand(n2,127) -64
+
+! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
+  if(ntype.ge.0 .and. ntype.le.62) then
+     nu=mod(ntype,10)
+     if(nu.eq.0 .or. nu.eq.3 .or. nu.eq.7) then
+        write(cdbm,'(i3)'),ntype
+        if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+        if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+        message=callsign(1:i1)//grid4//' '//cdbm
+        call hash(callsign,i1-1,ih)
+        dcall(ih)=callsign(:i1)
+     else
+        nadd=nu
+        if(nu.gt.3) nadd=nu-3
+        if(nu.gt.7) nadd=nu-7
+        ng=n2/128 + 32768*(nadd-1)
+        call unpackpfx(ng,callsign)
+        ndbm=ntype-nadd
+        write(cdbm,'(i3)'),ndbm
+        if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+        if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+        i2=index(callsign,' ')
+        message=callsign(:i2)//cdbm
+        call hash(callsign,i2-1,ih)
+        dcall(ih)=callsign(:i2)
+     endif
+  else if(ntype.lt.0) then
+     ndbm=-(ntype+1)
+     grid6=callsign(6:6)//callsign(1:5)
+     ih=(n2-ntype-64)/128
+     callsign=dcall(ih)
+     write(cdbm,'(i3)'),ndbm
+     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+     i2=index(callsign,' ')
+     if(dcall(ih)(1:1).ne.' ') then
+        message='&lt;'//callsign(:i2-1)//'&gt; '//grid6//' '//cdbm
+     else
+        message='&lt;...&gt; '//grid6//' '//cdbm
+     endif
+  endif
+  call cs_unlock
+
+  return
+end subroutine wqdecode

Added: branches/wsprx/lib/wqencode.f90
===================================================================
--- branches/wsprx/lib/wqencode.f90	                        (rev 0)
+++ branches/wsprx/lib/wqencode.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,66 @@
+subroutine wqencode(msg,ntype,data0)
+
+!  Parse and encode a WSPR message.
+
+  parameter (MASK15=32767)
+  character*22 msg
+  character*12 call1,call2
+  character grid4*4,grid6*6
+  logical lbad1,lbad2
+  integer*1 data0(11)
+  integer nu(0:9)
+  data nu/0,-1,1,0,-1,2,1,0,-1,1/
+
+  call cs_lock('wqencode')
+! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
+  i1=index(msg,' ')
+  i2=index(msg,'/')
+  i3=index(msg,'&lt;')
+  call1=msg(:i1-1)
+  if(i1.lt.3 .or. i1.gt.7 .or. i2.gt.0 .or. i3.gt.0) go to 10
+  grid4=msg(i1+1:i1+4)
+  call packcall(call1,n1,lbad1)
+  call packgrid(grid4,ng,lbad2)
+  if(lbad1 .or. lbad2) go to 10
+  ndbm=0
+  read(msg(i1+5:),*) ndbm
+  if(ndbm.lt.0) ndbm=0
+  if(ndbm.gt.60) ndbm=60
+  ndbm=ndbm+nu(mod(ndbm,10))
+  n2=128*ng + (ndbm+64)
+  call pack50(n1,n2,data0)
+  ntype=ndbm
+  go to 900
+
+10 if(i2.ge.2 .and. i3.lt.1) then
+     call packpfx(call1,n1,ng,nadd)
+     ndbm=0
+     read(msg(i1+1:),*) ndbm
+     if(ndbm.lt.0) ndbm=0
+     if(ndbm.gt.60) ndbm=60
+     ndbm=ndbm+nu(mod(ndbm,10))
+     ntype=ndbm + 1 + nadd
+     n2=128*ng + ntype + 64
+     call pack50(n1,n2,data0)
+  else if(i3.eq.1) then
+     i4=index(msg,'&gt;')
+     call1=msg(2:i4-1)
+     call hash(call1,i4-2,ih)
+     grid6=msg(i1+1:i1+6)
+     call2=grid6(2:6)//grid6(1:1)//'      '
+     call packcall(call2,n1,lbad1)
+     ndbm=0
+     read(msg(i1+8:),*) ndbm
+     if(ndbm.lt.0) ndbm=0
+     if(ndbm.gt.60) ndbm=60
+     ndbm=ndbm+nu(mod(ndbm,10))
+     ntype=-(ndbm+1)
+     n2=128*ih + ntype + 64
+     call pack50(n1,n2,data0)
+  endif
+  go to 900
+
+900 continue
+  call cs_unlock
+  return
+end subroutine wqencode

Added: branches/wsprx/lib/wspr0.f90
===================================================================
--- branches/wsprx/lib/wspr0.f90	                        (rev 0)
+++ branches/wsprx/lib/wspr0.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,99 @@
+program wspr0
+
+! Command-line version of WSPR.
+
+  character*12 arg
+  integer nt(9)
+  integer soundexit
+  real*8 f0,tsec
+  character*11 utcdate
+  character*3 month(12)
+  data month/'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'/
+
+  nargs=iargc()
+10 if(nargs.eq.0) then
+     print*,' '
+     print*,'wspr0 -- version 1.0'
+     print*,' '
+     print*,'Usage: wspr0 Tx  f0 ftx nport call grid dBm [snr] [outfile | nfiles]'
+     print*,'       wspr0 T/R f0 ftx nport call grid dBm pctx'
+     print*,'       wspr0 Rx  f0 [infile ...]'
+     print*,' '
+     print*,'       f0 is the transceiver dial frequency (MHz)'
+     print*,'       ftx is the signal frequency (MHz)'
+     print*,'       nport is the COM port number for PTT control'
+     print*,'       snr is the S/N in 2500 Hz bandwidth (for test files)'
+     print*,'       pctx is the percentage of 2-minute periods to Tx'
+     print*,' '
+     print*,'Examples:'
+     print*,'       wspr0 Tx  10.1387 10.140200 1 K1JT FN20 30'
+     print*,'       wspr0 Tx  10.1387 10.140200 0 K1JT FN20 30 -22 test.wav'
+     print*,'       wspr0 T/R 10.1387 10.140200 0 K1JT FN20 30 25'
+     print*,'       wspr0 Rx  10.1387'
+     print*,'       wspr0 Rx  10.1387 00001.wav 00002.wav 00003.wav'
+     print*,' '
+     print*,'For more information see:'
+     print*,'       physics.princeton.edu/pulsar/K1JT/WSPR0_Instructions.TXT'
+     go to 999
+  endif
+
+  ntr=0
+  nsec0=999999
+  open(14,file='ALL_WSPR0.TXT',status='unknown',access='append')
+  call soundinit
+  call getarg(1,arg)
+  if(arg(1:2).eq.'TX'.or. arg(1:2).eq.'Tx' .or. arg(1:2).eq.'tx') then
+! Transmit only
+     if(nargs.lt.7) then
+        nargs=0
+        go to 10
+     endif
+     call wspr0_tx(nargs,ntr)
+  else if(arg(1:2).eq.'RX'.or. arg(1:2).eq.'Rx' .or. arg(1:2).eq.'rx') then
+! Receive only
+        write(*,1026)
+1026    format(' UTC  dB   DT    Freq       Message'/54('-'))
+        write(14,1028)
+1028    format(' Date   UTC Sync dB   DT    Freq       Message'/50('-'))
+     call wspr0_rx(nargs,ntr)
+  else if(arg(1:3).eq.'T/R'.or. arg(1:3).eq.'t/r') then
+! Transmit and receive, choosing sequences randomly
+     if(nargs.ne.8) then
+        nargs=0
+        go to 10
+     endif
+     call random_seed
+     ntr=1
+     call getarg(2,arg)
+     read(arg,*) f0
+     call getarg(8,arg)
+     read(arg,*) pctx
+     pctx=min(max(pctx,0.0),100.0)
+20   nsec=time()
+     call gmtime2(nt,tsec)
+     nsec=tsec
+     write(utcdate,1001) nt(4),month(nt(5)),nt(6)
+1001 format(i2,'-',a3,'-',i4)
+     nsec=mod(nsec,86400)
+     if(nsec.lt.nsec0) then
+        write(*,1026)
+        write(14,1028)
+     endif
+     nsec0=nsec
+
+     call random_number(x)
+     if(100.0*x.lt.pctx) then
+        call wspr0_tx(nargs,ntr)
+     else
+        call wspr0_rx(nargs,ntr)
+     endif
+     call msleep(100)
+     go to 20
+  else
+! Illegal set of command parameters
+     nargs=0
+     go to 10
+  endif
+  ierr=soundexit()
+
+999 end program wspr0

Added: branches/wsprx/lib/wspr0_rx.f90
===================================================================
--- branches/wsprx/lib/wspr0_rx.f90	                        (rev 0)
+++ branches/wsprx/lib/wspr0_rx.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,78 @@
+subroutine wspr0_rx(nargs,ntr)
+
+!  Read Rx command-line args and the decode MEPT_JT signals from disk
+!  or real-time data.
+
+!  use dfport
+
+  parameter (NMAX=120*12000)                          !Max length of waveform
+  integer*2 iwave(NMAX)                               !Generated waveform
+  integer*1 i1
+  integer*1 hdr(44)
+  integer npr3(162)
+  integer soundin
+  real*8 f0
+  character*20 arg
+  character*80 infile,appdir,thisfile
+  character*6 cfile6,cdate*8,utctime*10
+  equivalence(i1,i4)
+  data appdir/'.'/,nappdir/1/,minsync/1/,nbfo/1500/
+  data npr3/                                          &amp;
+      1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,        &amp;
+      0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,        &amp;
+      0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,        &amp;
+      1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,        &amp;
+      0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,        &amp;
+      0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,        &amp;
+      0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,        &amp;
+      0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,        &amp;
+      0,0/
+
+  data nsec0/999999/
+  save
+
+  call getarg(2,arg)
+  read(arg,*) f0
+  nfiles=0
+  if(ntr.eq.0) nfiles=nargs-2
+  npts=114*12000
+
+  if(nfiles.ge.1) then
+     do ifile=1,nfiles
+        call getarg(2+ifile,infile)
+        open(10,file=infile,access='stream',status='old')
+        read(10) hdr
+        read(10) (iwave(i),i=1,npts)
+        close(10)
+        cfile6=infile
+        i1=index(infile,'.')
+        if(i1.ge.2) then
+           i0=max(1,i1-4)
+           cfile6=infile(i0:i1-1)
+        endif
+        call getrms(iwave,npts,ave,rms)
+        call mept162(infile,appdir,nappdir,f0,1,iwave,NMAX,nbfo,ierr)
+     enddo
+  else
+20   nsec=time()
+     isec=mod(nsec,86400)
+     ih=isec/3600
+     im=(isec-ih*3600)/60
+     is=mod(isec,60)
+     is120=mod(isec,120)
+     if(is120.eq.0) then
+        call getutc(cdate,utctime,tsec)
+        thisfile=cdate(3:8)//'_'//utctime(1:4)//'.'//'wav'
+        ierr=soundin(-1,12000,iwave,114*12000,0)
+        npts=114*12000
+        call getrms(iwave,npts,ave,rms)
+        call mept162(thisfile,appdir,nappdir,f0,1,iwave,NMAX,nbfo,ierr)
+        if(ntr.ne.0) go to 999
+     endif
+30   call msleep(100)
+     go to 20
+  endif
+      
+999 return
+end subroutine wspr0_rx
+

Added: branches/wsprx/lib/wspr0_tx.f90
===================================================================
--- branches/wsprx/lib/wspr0_tx.f90	                        (rev 0)
+++ branches/wsprx/lib/wspr0_tx.f90	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,89 @@
+subroutine wspr0_tx(nargs,ntr)
+
+!  Read command-line arguments and generate Tx data for the MEPT_JT mode.
+
+  parameter (NMAX=120*12000)
+  real*8 f0,ftx
+  character*70 arg
+  character*12 call1
+  character*4 grid
+  character*3 cdbm
+  character*22 message
+  character*80 outfile
+  integer*2 iwave(NMAX)
+  integer ptt,soundout
+
+  snrdb=99.
+  outfile=''
+  nfiles=9999
+  call getarg(2,arg)
+  read(arg,*) f0
+  call getarg(3,arg)
+  read(arg,*) ftx
+  ntxdf=nint(1.d6*(ftx-f0))-1500
+  if(abs(ntxdf).gt.100) then
+     print*,'Error: ftx must be above f0 by 1400 to 1600 Hz'
+     stop
+  endif
+  call getarg(4,arg)
+  read(arg,*) nport
+  call getarg(5,call1)
+  call getarg(6,grid)
+  call getarg(7,arg)
+  read(arg,*) ndbm
+  if(nargs.lt.8 .or. ntr.ne.0) go to 10
+  call getarg(8,arg)
+  read(arg,*) snrdb
+  if(nargs.lt.9) go to 10
+  call getarg(9,outfile)
+  read(outfile,1008,err=1) nfiles
+1008  format(i4)
+  outfile=&quot;&quot;
+  go to 10
+1 nfiles=1
+
+10 i1=index(call1,' ')
+  write(cdbm,'(i3)'),ndbm
+  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+  message=call1(1:i1)//grid//' '//cdbm
+  do ifile=1,nfiles
+     if(nfiles.gt.1 .and. nfiles.lt.9999) write(outfile,1010) ifile
+1010 format(i5.5,'.wav')
+     call genmept(message,ntxdf,snrdb,iwave)
+     if(snrdb.eq.11.0) go to 999
+     if(outfile.ne.&quot;&quot;) then
+        call wfile5(iwave,NMAX,12000,outfile)
+        write(*,1020) f0,ftx,snrdb,message,outfile(1:24)
+1020    format(2f11.6,f6.1,2x,a22,2x,a24)
+     else
+20      nsec=time()
+        isec=mod(nsec,86400)
+        ih=isec/3600
+        im=(isec-ih*3600)/60
+        is=mod(isec,60)
+        is120=mod(isec,120)
+        if(is120.eq.0) then
+           if(nport.gt.0) ierr=ptt(nport,junk,1,iptt)
+!           if(ntr.eq.0) write(*,1030) ih,im,is,f0,ftx,message
+!1030       format(i2.2,':',i2.2,':',i2.2,2f11.6,2x,a22)
+           do i=22,1,-1
+              if(message(i:i).ne.' ') go to 25
+           enddo
+25         iz=i
+           write(*,1031) ih,im,ftx,message(1:iz)
+1031       format(2i2.2,9x,f11.6,'  Transmitting &quot;',a,'&quot;')
+           write(14,1032) ih,im,ftx,message(1:iz)
+1032       format(7x,2i2.2,13x,f11.6,'  Transmitting &quot;',a,'&quot;')
+           ierr=soundout(-1,12000,iwave,114*12000,0)
+           if(nport.gt.0) ierr=ptt(nport,junk,0,iptt)
+           if(ntr.ne.0) go to 999
+        endif
+        call msleep(100)
+        go to 20
+     endif
+     if(nfiles.eq.9999) go to 999
+  enddo
+
+999 return
+end subroutine wspr0_tx

Added: branches/wsprx/lib/xfft.f
===================================================================
--- branches/wsprx/lib/xfft.f	                        (rev 0)
+++ branches/wsprx/lib/xfft.f	2012-12-13 15:36:21 UTC (rev 2804)
@@ -0,0 +1,12 @@
+      subroutine xfft(x,nfft)
+
+C  Real-to-complex FFT.
+
+      real x(nfft)
+
+!      call four2(x,nfft,1,-1,0)
+      call four2a(x,nfft,1,-1,0)
+
+      return
+      end
+

Modified: branches/wsprx/mainwindow.cpp
===================================================================
--- branches/wsprx/mainwindow.cpp	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/mainwindow.cpp	2012-12-13 15:36:21 UTC (rev 2804)
@@ -758,10 +758,12 @@
     QByteArray t=proc_jt9.readLine();
     if(t.indexOf(&quot; UTC &quot;) != 0 and t.indexOf(&quot;-----&quot;) != 0) {
       int n=t.length();
+      /*
       QString bg=&quot;white&quot;;
       if(t.indexOf(&quot; CQ &quot;)&gt;0) bg=&quot;#66ff66&quot;;                //Light green
       if(t.indexOf(&quot; &quot;+m_myCall+&quot; &quot;)&gt;0) bg=&quot;#ff6666&quot;;      //Light red
       ui-&gt;decodedTextBrowser-&gt;setTextBackgroundColor(bg);
+      */
       t=t.mid(0,n-2) + &quot;                                                  &quot;;
       ui-&gt;decodedTextBrowser-&gt;append(t);
     }
@@ -836,7 +838,7 @@
 //    ba2msg(ba,msgsent);
     int len1=22;
     int ichk=0,itext=0;
-    genjt9_(message,&amp;ichk,msgsent,itone,&amp;itext,len1,len1);
+//    genjt9_(message,&amp;ichk,msgsent,itone,&amp;itext,len1,len1);
     msgsent[22]=0;
     lab5-&gt;setText(&quot;Last Tx:  &quot; + QString::fromAscii(msgsent));
     if(m_restart) {

Modified: branches/wsprx/mainwindow.h
===================================================================
--- branches/wsprx/mainwindow.h	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/mainwindow.h	2012-12-13 15:36:21 UTC (rev 2804)
@@ -197,10 +197,10 @@
               int* m_NBslider, float* px, float s[], float red[],
               float* df3, int* nhsym, int* nzap, float* slimit,
               uchar lstrong[], int* npts8);
-
+/*
 void genjt9_(char* msg, int* ichk, char* msgsent, int itone[],
              int* itext, int len1, int len2);
-
+*/
 //void decoder_(int* ntrperiod, int* ndepth, int* mRxLog, float c0[]);
 }
 

Modified: branches/wsprx/wsprx.pro
===================================================================
--- branches/wsprx/wsprx.pro	2012-12-13 13:29:59 UTC (rev 2803)
+++ branches/wsprx/wsprx.pro	2012-12-13 15:36:21 UTC (rev 2804)
@@ -54,14 +54,14 @@
 unix {
 INCLUDEPATH += $$quote(/usr/include/qwt-qt4)
 LIBS += -lfftw3f /usr/lib/libgfortran.so.3
-LIBS += ../wsprx/lib/libjt9.a
+LIBS += ../wsprx/lib/libwspr.a
 LIBS += /usr/lib/libqwt-qt4.so
 LIBS += -lportaudio
 }
 
 win32 {
 INCLUDEPATH += c:/qwt-6.0.1/include
-LIBS += ../wsprx/lib/libjt9.a
+LIBS += ../wsprx/lib/libwspr.a
 LIBS += ../wsprx/libfftw3f_win.a
 LIBS += ../QtSupport/palir-02.dll
 LIBS += libwsock32

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002495.html">[WSJT-SVN] r2803 - branches/wsprx
</A></li>
	<LI>Next message: <A HREF="002496.html">[WSJT-SVN] r2805 - in branches/wsprx: . lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2497">[ date ]</a>
              <a href="thread.html#2497">[ thread ]</a>
              <a href="subject.html#2497">[ subject ]</a>
              <a href="author.html#2497">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
