<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2844 - branches/wspr
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2012-December/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2844%20-%20branches/wspr&In-Reply-To=%3C20121221161236.AC55255B0C%40scm.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002535.html">
   <LINK REL="Next"  HREF="002537.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2844 - branches/wspr</H1>
    <B>k1jt at scm.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2844%20-%20branches/wspr&In-Reply-To=%3C20121221161236.AC55255B0C%40scm.berlios.de%3E"
       TITLE="[WSJT-SVN] r2844 - branches/wspr">k1jt at scm.berlios.de
       </A><BR>
    <I>Fri Dec 21 17:12:36 CET 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="002535.html">[WSJT-SVN] r2843 - branches/wspr
</A></li>
        <LI>Next message: <A HREF="002537.html">[WSJT-SVN] r2845 - branches/wspr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2536">[ date ]</a>
              <a href="thread.html#2536">[ thread ]</a>
              <a href="subject.html#2536">[ subject ]</a>
              <a href="author.html#2536">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2012-12-21 17:12:36 +0100 (Fri, 21 Dec 2012)
New Revision: 2844

Added:
   branches/wspr/decode162.f90
   branches/wspr/encode232.f
   branches/wspr/mept162.f90
   branches/wspr/mix162.f90
   branches/wspr/ps162.f90
   branches/wspr/spec162.f90
   branches/wspr/sync162.f90
Removed:
   branches/wspr/decode162.f
   branches/wspr/encode232.f
   branches/wspr/mept162.f
   branches/wspr/mix162.f
   branches/wspr/ps162.f
   branches/wspr/spec162.f
   branches/wspr/sync162.f
Modified:
   branches/wspr/rx.f90
   branches/wspr/wspr.py
Log:
Moving some *.f to *.f90.


Deleted: branches/wspr/decode162.f
===================================================================
--- branches/wspr/decode162.f	2012-12-20 19:16:42 UTC (rev 2843)
+++ branches/wspr/decode162.f	2012-12-21 16:12:36 UTC (rev 2844)
@@ -1,137 +0,0 @@
-      subroutine decode162(c4,npts,message,ncycles,metric,nerr)
-
-C  Decode MEPT_JT data, assuming that DT and DF have already been determined.
-
-      complex c4(npts)
-      character*22 message
-      real*8 dt,df,twopi,f0,f1,dphi0,dphi1
-      complex*16 c0,c1
-      complex*16 w0,w1,ws0,ws1
-      integer*1 symbol(162)
-      integer*1 data1(11)
-      integer amp
-      integer mettab(0:255,0:1)
-      logical first
-      data first/.true./
-      integer npr3(162)
-      data npr3/
-     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     + 0,0/
-      data mettab/
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
-     +   2,   2,   2,   2,   1,   1,   1,   1,   0,   0,
-     +  -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,
-     +  -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,
-     + -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,
-     + -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,
-     + -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,
-     + -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,
-     + -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,
-     + -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,
-     + -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,
-     + -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,
-     + -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,
-     + -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,
-     + -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,
-     + -84, -87, -86, -87, -88, -89, -89, -89, -88, -87,
-     + -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,
-     + -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,
-     + -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,
-     + -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,
-     + -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,
-     + -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,
-     + -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,
-     + -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,
-     + -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,
-     + -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,
-     + -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,
-     + -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,
-     +  -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,
-     +  -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,
-     +   2,   2,   2,   2,   3,   3,   3,   3,   3,   3,
-     +   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5/
-      save
-
-      if(first) then
-         twopi=8*atan(1.d0)
-         dt=1.d0/375.d0                        !Sample interval
-         df=375.d0/256.d0
-         nsym=162
-         nbits=50+31
-         amp=20                                !### 32 ??? ###
-         ndelta=50
-         limit=10000
-         first=.false.
-      endif
-
-C  Should amp be adjusted according to signal strength?
-C  Compute soft symbols
-      k=0
-      nsps=256
-      fac2=0.001
-      w0=1.0
-      w1=1.0
-
-      do j=1,nsym
-         f0=(npr3(j)-1.5)*df
-         f1=(2+npr3(j)-1.5)*df
-         dphi0=twopi*dt*f0
-         dphi1=twopi*dt*f1
-         ws0=dcmplx(cos(dphi0),-sin(dphi0))
-         ws1=dcmplx(cos(dphi1),-sin(dphi1))
-         c0=0.
-         c1=0.
-         do i=1,nsps
-            k=k+1
-            w0=w0*ws0
-            w1=w1*ws1
-            c0=c0 + w0*c4(k)
-            c1=c1 + w1*c4(k)
-         enddo
-
-         sq0=fac2*(real(c0)**2 + aimag(c0)**2)
-         sq1=fac2*(real(c1)**2 + aimag(c1)**2)
-         rsym=amp*(sq1-sq0)
-         r=rsym+128.
-         if(r.gt.255.0) r=255.0
-         if(r.lt.0.0) r=0.0
-         n4=nint(r)
-         if(n4.gt.127) n4=n4-256
-         symbol(j)=n4
-      enddo
-
-      call inter_mept(symbol,-1)                      !Remove interleaving
-      call fano232(symbol,nbits,mettab,ndelta,limit,
-     +     data1,ncycles,metric,nerr)
-      message='                      '
-      if(nerr.ge.0) call wqdecode(data1,message,ntype2)
-
-      return
-      end

Copied: branches/wspr/decode162.f90 (from rev 2843, branches/wspr/decode162.f)
===================================================================
--- branches/wspr/decode162.f90	                        (rev 0)
+++ branches/wspr/decode162.f90	2012-12-21 16:12:36 UTC (rev 2844)
@@ -0,0 +1,137 @@
+subroutine decode162(c4,npts,message,ncycles,metric,nerr)
+
+! Decode MEPT_JT data, assuming that DT and DF have already been determined.
+
+  complex c4(npts)
+  character*22 message
+  real*8 dt,df,twopi,f0,f1,dphi0,dphi1
+  complex*16 c0,c1
+  complex*16 w0,w1,ws0,ws1
+  integer*1 symbol(162)
+  integer*1 data1(11)
+  integer amp
+  integer mettab(0:255,0:1)
+  logical first
+  data first/.true./
+  integer npr3(162)
+  data npr3/                                             &amp;
+       1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,          &amp;
+       0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,          &amp;
+       0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,          &amp;
+       1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,          &amp;
+       0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,          &amp;
+       0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,          &amp;
+       0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,          &amp;
+       0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,          &amp;
+       0,0/
+
+  data mettab/                                           &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   4,   &amp;
+       4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   &amp;
+       4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   &amp;
+       3,   3,   3,   3,   3,   3,   3,   3,   3,   2,   &amp;
+       2,   2,   2,   2,   1,   1,   1,   1,   0,   0,   &amp;
+       -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,  &amp;
+       -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,  &amp;
+       -15, -16, -17, -17, -18, -19, -20, -21, -22, -22, &amp;
+       -23, -24, -25, -26, -26, -27, -28, -29, -30, -30, &amp;
+       -31, -32, -33, -33, -34, -35, -36, -36, -37, -38, &amp;
+       -38, -39, -40, -41, -41, -42, -43, -43, -44, -45, &amp;
+       -45, -46, -47, -47, -48, -49, -49, -50, -51, -51, &amp;
+       -52, -53, -53, -54, -54, -55, -56, -56, -57, -57, &amp;
+       -58, -59, -59, -60, -60, -61, -62, -62, -62, -63, &amp;
+       -64, -64, -65, -65, -66, -67, -67, -67, -68, -69, &amp;
+       -69, -70, -70, -71, -72, -72, -72, -72, -73, -74, &amp;
+       -75, -75, -75, -77, -76, -76, -78, -78, -80, -81, &amp;
+       -80, -79, -83, -82, -81, -82, -82, -83, -84, -84, &amp;
+       -84, -87, -86, -87, -88, -89, -89, -89, -88, -87, &amp;
+       -86, -87, -84, -84, -84, -83, -82, -82, -81, -82, &amp;
+       -83, -79, -80, -81, -80, -78, -78, -76, -76, -77, &amp;
+       -75, -75, -75, -74, -73, -72, -72, -72, -72, -71, &amp;
+       -70, -70, -69, -69, -68, -67, -67, -67, -66, -65, &amp;
+       -65, -64, -64, -63, -62, -62, -62, -61, -60, -60, &amp;
+       -59, -59, -58, -57, -57, -56, -56, -55, -54, -54, &amp;
+       -53, -53, -52, -51, -51, -50, -49, -49, -48, -47, &amp;
+       -47, -46, -45, -45, -44, -43, -43, -42, -41, -41, &amp;
+       -40, -39, -38, -38, -37, -36, -36, -35, -34, -33, &amp;
+       -33, -32, -31, -30, -30, -29, -28, -27, -26, -26, &amp;
+       -25, -24, -23, -22, -22, -21, -20, -19, -18, -17, &amp;
+       -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9, &amp;
+       -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,  &amp;
+       -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,  &amp;
+       2,   2,   2,   2,   3,   3,   3,   3,   3,   3,   &amp;
+       3,   3,   3,   4,   4,   4,   4,   4,   4,   4,   &amp;
+       4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   &amp;
+       4,   4,   4,   4,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+       5,   5/
+  save
+
+  if(first) then
+     twopi=8*atan(1.d0)
+     dt=1.d0/375.d0                        !Sample interval
+     df=375.d0/256.d0
+     nsym=162
+     nbits=50+31
+     amp=20                                !### 32 ??? ###
+     ndelta=50
+     limit=10000
+     first=.false.
+  endif
+
+! Should amp be adjusted according to signal strength?
+! Compute soft symbols
+  k=0
+  nsps=256
+  fac2=0.001
+  w0=1.0
+  w1=1.0
+
+  do j=1,nsym
+     f0=(npr3(j)-1.5)*df
+     f1=(2+npr3(j)-1.5)*df
+     dphi0=twopi*dt*f0
+     dphi1=twopi*dt*f1
+     ws0=dcmplx(cos(dphi0),-sin(dphi0))
+     ws1=dcmplx(cos(dphi1),-sin(dphi1))
+     c0=0.
+     c1=0.
+     do i=1,nsps
+        k=k+1
+        w0=w0*ws0
+        w1=w1*ws1
+        c0=c0 + w0*c4(k)
+        c1=c1 + w1*c4(k)
+     enddo
+
+     sq0=fac2*(real(c0)**2 + aimag(c0)**2)
+     sq1=fac2*(real(c1)**2 + aimag(c1)**2)
+     rsym=amp*(sq1-sq0)
+     r=rsym+128.
+     if(r.gt.255.0) r=255.0
+     if(r.lt.0.0) r=0.0
+     n4=nint(r)
+     if(n4.gt.127) n4=n4-256
+     symbol(j)=n4
+  enddo
+
+  call inter_mept(symbol,-1)                      !Remove interleaving
+  call fano232(symbol,nbits,mettab,ndelta,limit,data1,ncycles,metric,nerr)
+  message='                      '
+  if(nerr.ge.0) call wqdecode(data1,message,ntype2)
+
+  return
+end subroutine decode162

Deleted: branches/wspr/encode232.f
===================================================================
--- branches/wspr/encode232.f	2012-12-20 19:16:42 UTC (rev 2843)
+++ branches/wspr/encode232.f	2012-12-21 16:12:36 UTC (rev 2844)
@@ -1,30 +0,0 @@
-      subroutine encode232(dat,nbytes,symbol,maxsym)
-
-C  Convolutional encoder for a K=32, r=1/2 code.
-
-      integer*1 dat(nbytes)             !User data, packed 8 bits per byte
-      integer*1 symbol(maxsym)          !Channel symbols, one bit per byte
-      integer*1 i1
-      include 'conv232.f'
-
-      nstate=0
-      k=0
-      do j=1,nbytes
-         do i=7,0,-1
-            i1=dat(j)
-            i4=i1
-            if (i4.lt.0) i4=i4+256
-            nstate=ior(ishft(nstate,1),iand(ishft(i4,-i),1))
-            n=iand(nstate,npoly1)
-            n=ieor(n,ishft(n,-16))
-            k=k+1
-            symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
-            n=iand(nstate,npoly2)
-            n=ieor(n,ishft(n,-16))
-            k=k+1
-            symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
-         enddo
-      enddo
-
-      return
-      end

Added: branches/wspr/encode232.f
===================================================================
--- branches/wspr/encode232.f	                        (rev 0)
+++ branches/wspr/encode232.f	2012-12-21 16:12:36 UTC (rev 2844)
@@ -0,0 +1,30 @@
+      subroutine encode232(dat,nbytes,symbol,maxsym)
+
+C  Convolutional encoder for a K=32, r=1/2 code.
+
+      integer*1 dat(nbytes)             !User data, packed 8 bits per byte
+      integer*1 symbol(maxsym)          !Channel symbols, one bit per byte
+      integer*1 i1
+      include 'conv232.f'
+
+      nstate=0
+      k=0
+      do j=1,nbytes
+         do i=7,0,-1
+            i1=dat(j)
+            i4=i1
+            if (i4.lt.0) i4=i4+256
+            nstate=ior(ishft(nstate,1),iand(ishft(i4,-i),1))
+            n=iand(nstate,npoly1)
+            n=ieor(n,ishft(n,-16))
+            k=k+1
+            symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
+            n=iand(nstate,npoly2)
+            n=ieor(n,ishft(n,-16))
+            k=k+1
+            symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
+         enddo
+      enddo
+
+      return
+      end

Deleted: branches/wspr/mept162.f
===================================================================
--- branches/wspr/mept162.f	2012-12-20 19:16:42 UTC (rev 2843)
+++ branches/wspr/mept162.f	2012-12-21 16:12:36 UTC (rev 2844)
@@ -1,112 +0,0 @@
-      subroutine mept162(outfile,appdir,nappdir,f0,ncmdline,id,npts,
-     +  nbfo,ierr)
-
-C  Orchestrates the process of finding, synchronizing, and decoding 
-C  WSPR signals.
-
-      integer*2 id(npts)
-      character*22 message
-      character*80 outfile,appdir,alltxt
-      character*11 datetime
-      character cdate*8,ctime*10
-      real*8 f0,freq,tsec
-      real ps(-256:256)
-      real sstf(5,275)
-      real a(5)
-      complex c2(65536)
-      complex c3(45000),c4(45000)
-
-C  Mix from &quot;nbfo&quot; +/- 100 Hz to baseband, and downsample by 1/32
-      call mix162(id,npts,nbfo,c2,jz,ps)
-
-      if(ncmdline.eq.0) then
-C  Compute pixmap.dat
-         call spec162(c2,jz,appdir,nappdir)
-      endif
-
-C  Look for sync patterns, get DF and DT
-      call sync162(c2,jz,ps,sstf,kz)
-      ierr = 0
-      if(kz.eq.0) go to 900
-      if (kz.gt.275 .or. kz.lt.0) then
-        call getutc(cdate,ctime,tsec)
-
-        call cs_lock('mept162')
-        write(*,1000) ctime,kz
- 1000   format('Time ',a8,'. Error from sync162: kz is',i10)
-        call cs_unlock
-
-        ierr = 1
-        return
-      endif
-      do k=1,kz
-         snrsync=sstf(1,k)
-         snrx=sstf(2,k)
-         dtx=sstf(3,k)
-         dfx=sstf(4,k)
-         drift=sstf(5,k)
-         a(1)=-dfx
-         a(2)=-0.5*drift
-         a(3)=0.
-         call twkfreq(c2,c3,jz,a)                    !Remove drift
-
-         minsync=1                                   !####
-         nsync=nint(snrsync)
-         nsnrx=nint(snrx)
-         if(nsnrx.lt.-33) nsnrx=-33
-         if(nsync.lt.0) nsync=0
-         freq=f0 + 1.d-6*(dfx+nbfo)
-         message='                      '
-         if(nsync.ge.minsync .and. nsnrx.ge.-33) then      !### -31 dB limit?
-
-            dt=1.0/375
-            do idt=0,128
-               ii=(idt+1)/2
-               if(mod(idt,2).eq.1) ii=-ii
-               i1=nint((dtx+2.0)/dt) + ii !Start index for synced symbols
-               if(i1.ge.1) then
-!  Fix this earlier!
-                  c4(1:jz-i1+1)=c3(i1:)
-                  c4(jz-i1+2:)=0.
-               else
-                  c4(:-i1+1)=0.
-                  c4(-i1+2:jz)=c3(:i1+jz-1)
-                  if(jz.lt.45000) c4(jz:)=0.
-               endif
-               call decode162(c4,45000,message,ncycles,metric,nerr)
-               if(message(1:6).ne.'      ' .and. 
-     +            message(1:6).ne.'000AAA' .and.
-     +            index(message,'A000AA').le.0) go to 23
-            enddo
-            go to 24
-
- 23         i2=index(outfile,'.wav')-1
-            if(i2.le.0) i2=index(outfile,'.WAV')-1
-            datetime=outfile(max(1,i2-10):i2)
-            datetime(7:7)=' '
-            nf1=nint(-a(2))
-            alltxt=appdir(:nappdir)//'/ALL_WSPR.TXT'
-
-            call cs_lock('mept162a')
-            if(ncmdline.eq.0) then
-               open(13,file=alltxt,status='unknown',position='append')
-               write(13,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,
-     +           ncycles/81,ii
-               close(13)
-            else
-               write(*,1008) datetime(8:11),nsnrx,dtx,freq,message
- 1008          format(a4,i4,f5.1,f11.6,2x,a22,i3,i6,i5)
-            endif
-            write(14,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,
-     +           ncycles/81,ii
- 1010       format(a11,i4,i4,f5.1,f11.6,2x,a22,i3,i6,i5)
-            call flush(14)
-            i1=index(message,' ')
-            call cs_unlock
-
-         endif
- 24      continue
-      enddo
-
- 900  return
-      end

Copied: branches/wspr/mept162.f90 (from rev 2843, branches/wspr/mept162.f)
===================================================================
--- branches/wspr/mept162.f90	                        (rev 0)
+++ branches/wspr/mept162.f90	2012-12-21 16:12:36 UTC (rev 2844)
@@ -0,0 +1,104 @@
+subroutine mept162(outfile,appdir,nappdir,f0,ncmdline,id,npts,nbfo,ierr)
+
+! Orchestrates the process of finding, synchronizing, and decoding 
+! WSPR signals.
+
+  integer*2 id(npts)
+  character*22 message
+  character*80 outfile,appdir,alltxt
+  character*11 datetime
+  character cdate*8,ctime*10
+  real*8 f0,freq,tsec
+  real ps(-256:256)
+  real sstf(5,275)
+  real a(5)
+  complex c2(65536)
+  complex c3(45000),c4(45000)
+
+! Mix from &quot;nbfo&quot; +/- 100 Hz to baseband, and downsample by 1/32
+  call mix162(id,npts,nbfo,c2,jz,ps)
+
+  if(ncmdline.eq.0) then
+! Compute pixmap.dat
+     call spec162(c2,jz,appdir,nappdir)
+  endif
+
+! Look for sync patterns, get DF and DT
+  call sync162(c2,jz,ps,sstf,kz)
+  ierr = 0
+  if(kz.eq.0) go to 900
+  if (kz.gt.275 .or. kz.lt.0) then
+     call getutc(cdate,ctime,tsec)
+     write(*,1000) ctime,kz
+1000 format('Time ',a8,'. Error from sync162: kz is',i10)
+     ierr = 1
+     return
+  endif
+  do k=1,kz
+     snrsync=sstf(1,k)
+     snrx=sstf(2,k)
+     dtx=sstf(3,k)
+     dfx=sstf(4,k)
+     drift=sstf(5,k)
+     a(1)=-dfx
+     a(2)=-0.5*drift
+     a(3)=0.
+     call twkfreq(c2,c3,jz,a)                    !Remove drift
+
+     minsync=1                                   !####
+     nsync=nint(snrsync)
+     nsnrx=nint(snrx)
+     if(nsnrx.lt.-33) nsnrx=-33
+     if(nsync.lt.0) nsync=0
+     freq=f0 + 1.d-6*(dfx+nbfo)
+     message='                      '
+     if(nsync.ge.minsync .and. nsnrx.ge.-33) then      !### -31 dB limit?
+
+        dt=1.0/375
+        do idt=0,128
+           ii=(idt+1)/2
+           if(mod(idt,2).eq.1) ii=-ii
+           i1=nint((dtx+2.0)/dt) + ii !Start index for synced symbols
+           if(i1.ge.1) then
+! Fix this earlier!
+              c4(1:jz-i1+1)=c3(i1:)
+              c4(jz-i1+2:)=0.
+           else
+              c4(:-i1+1)=0.
+              c4(-i1+2:jz)=c3(:i1+jz-1)
+              if(jz.lt.45000) c4(jz:)=0.
+           endif
+           call decode162(c4,45000,message,ncycles,metric,nerr)
+           if(message(1:6).ne.'      ' .and. message(1:6).ne.'000AAA' .and. &amp;
+                index(message,'A000AA').le.0) go to 23
+        enddo
+        go to 24
+
+23      i2=index(outfile,'.wav')-1
+        if(i2.le.0) i2=index(outfile,'.WAV')-1
+        datetime=outfile(max(1,i2-10):i2)
+        datetime(7:7)=' '
+        nf1=nint(-a(2))
+        alltxt=appdir(:nappdir)//'/ALL_WSPR.TXT'
+
+        if(ncmdline.eq.0) then
+           open(13,file=alltxt,status='unknown',position='append')
+           write(13,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,    &amp;
+                ncycles/81,ii
+           close(13)
+        else
+           write(*,1008) datetime(8:11),nsnrx,dtx,freq,nf1,message
+1008       format(a4,i4,f5.1,f11.6,i3,2x,a22)
+        endif
+        write(14,1010) datetime,nsync,nsnrx,dtx,freq,message,nf1,       &amp;
+             ncycles/81,ii
+1010    format(a11,i4,i4,f5.1,f11.6,2x,a22,i3,i6,i5)
+        call flush(14)
+        i1=index(message,' ')
+
+     endif
+24   continue
+  enddo
+
+900 return
+end subroutine mept162

Deleted: branches/wspr/mix162.f
===================================================================
--- branches/wspr/mix162.f	2012-12-20 19:16:42 UTC (rev 2843)
+++ branches/wspr/mix162.f	2012-12-21 16:12:36 UTC (rev 2844)
@@ -1,56 +0,0 @@
-      subroutine mix162(id,npts,nbfo,c2,jz,ps)
-
-C  Mix from &quot;nbfo&quot; +/- 100 Hz to baseband, and downsample by 1/32
-
-      parameter (NFFT1=2*1024*1024)
-      parameter (NFFT2=NFFT1/32)
-      parameter (NH2=NFFT2/2)
-      integer*2 id(npts)
-      real x(NFFT1)
-      real ps(-256:256)
-      real*8 df
-      complex c(0:NFFT1)
-      complex c2(0:65535)
-      equivalence (x,c)
-
-C  Load data into real array x; pad with zeros up to nfft.
-      fac=1.e-4
-      do i=1,npts
-         x(i)=fac*id(i)
-      enddo
-      call zero(x(npts+1),NFFT1-npts)
-
-C  Do the real-to-complex FFT
-      call xfft(x,NFFT1)
-
-      df=12000.d0/NFFT1
-      i0=nint(nbfo/df)
-      ia=i0-NH2 + 1
-      ib=i0+NH2
-
-      k=-257
-      do i=ia-64,ib,128
-         k=k+1
-         sq=0.
-         do n=0,127
-            sq=sq + real(c(i+n))**2 + aimag(c(i+n))**2
-         enddo
-         ps(k)=4.085e-8*sq
-      enddo
-
-      do i=0,NFFT2-1
-         j=i0 + i
-         if(i.gt.NH2) j=j-NFFT2
-         c2(i)=c(j)
-      enddo
-
-      call four2a(c2,NFFT2,1,1,1)        !Return to time domain
-
-      fac=1.e-5
-      jz=npts/32
-      do i=0,jz-1
-         c2(i)=fac*c2(i)
-      enddo
-
-      return
-      end

Copied: branches/wspr/mix162.f90 (from rev 2843, branches/wspr/mix162.f)
===================================================================
--- branches/wspr/mix162.f90	                        (rev 0)
+++ branches/wspr/mix162.f90	2012-12-21 16:12:36 UTC (rev 2844)
@@ -0,0 +1,56 @@
+subroutine mix162(id,npts,nbfo,c2,jz,ps)
+
+! Mix from &quot;nbfo&quot; +/- 100 Hz to baseband, and downsample by 1/32
+
+  parameter (NFFT1=2*1024*1024)
+  parameter (NFFT2=NFFT1/32)
+  parameter (NH2=NFFT2/2)
+  integer*2 id(npts)
+  real x(NFFT1)
+  real ps(-256:256)
+  real*8 df
+  complex c(0:NFFT1)
+  complex c2(0:65535)
+  equivalence (x,c)
+
+! Load data into real array x; pad with zeros up to nfft.
+  fac=1.e-4
+  do i=1,npts
+     x(i)=fac*id(i)
+  enddo
+  call zero(x(npts+1),NFFT1-npts)
+
+! Do the real-to-complex FFT
+  call xfft(x,NFFT1)
+
+  df=12000.d0/NFFT1
+  i0=nint(nbfo/df)
+  ia=i0-NH2 + 1
+  ib=i0+NH2
+
+  k=-257
+  do i=ia-64,ib,128
+     k=k+1
+     sq=0.
+     do n=0,127
+        sq=sq + real(c(i+n))**2 + aimag(c(i+n))**2
+     enddo
+     ps(k)=4.085e-8*sq
+  enddo
+
+  do i=0,NFFT2-1
+     j=i0 + i
+     if(i.gt.NH2) j=j-NFFT2
+     c2(i)=c(j)
+  enddo
+
+  call four2a(c2,NFFT2,1,1,1)        !Return to time domain
+
+  fac=1.e-5
+  jz=npts/32
+  do i=0,jz-1
+     c2(i)=fac*c2(i)
+  enddo
+
+  return
+end subroutine mix162

Deleted: branches/wspr/ps162.f
===================================================================
--- branches/wspr/ps162.f	2012-12-20 19:16:42 UTC (rev 2843)
+++ branches/wspr/ps162.f	2012-12-21 16:12:36 UTC (rev 2844)
@@ -1,27 +0,0 @@
-      subroutine ps162(c2,s)
-
-      parameter (NFFT=512,NH=256)
-      complex c2(0:NFFT)
-      real s(-NH:NH)
-!      real work(2*NMAX)
-      complex c(0:NFFT)
-
-      do i=0,NH-1
-         c(i)=c2(i)
-      enddo
-      do i=nh,nfft-1
-         c(i)=0.
-      enddo
-
-      call four2a(c,nfft,1,-1,1)
-
-      fac=1.0/nfft
-      do i=0,NFFT-1
-         j=i
-         if(j.gt.NH) j=j-NFFT
-         s(j)=fac*(real(c(i))**2 + aimag(c(i))**2)
-      enddo
-      s(-NH)=s(-NH+1)
-
-      return
-      end

Copied: branches/wspr/ps162.f90 (from rev 2843, branches/wspr/ps162.f)
===================================================================
--- branches/wspr/ps162.f90	                        (rev 0)
+++ branches/wspr/ps162.f90	2012-12-21 16:12:36 UTC (rev 2844)
@@ -0,0 +1,26 @@
+subroutine ps162(c2,s)
+
+  parameter (NFFT=512,NH=256)
+  complex c2(0:NFFT)
+  real s(-NH:NH)
+  complex c(0:NFFT)
+
+  do i=0,NH-1
+     c(i)=c2(i)
+  enddo
+  do i=nh,nfft-1
+     c(i)=0.
+  enddo
+
+  call four2a(c,nfft,1,-1,1)
+
+  fac=1.0/nfft
+  do i=0,NFFT-1
+     j=i
+     if(j.gt.NH) j=j-NFFT
+     s(j)=fac*(real(c(i))**2 + aimag(c(i))**2)
+  enddo
+  s(-NH)=s(-NH+1)
+
+  return
+end subroutine ps162

Modified: branches/wspr/rx.f90
===================================================================
--- branches/wspr/rx.f90	2012-12-20 19:16:42 UTC (rev 2843)
+++ branches/wspr/rx.f90	2012-12-21 16:12:36 UTC (rev 2844)
@@ -1,6 +1,6 @@
 subroutine rx
 
-!  Receive and decode MEPT_JT signals for one 2-minute sequence.
+! Receive WSPR signals for one 2-minute sequence.
 
   integer time
 
@@ -11,24 +11,28 @@
   if(ntrminutes.eq.15) npts=890*12000
   if(ncal.eq.1) npts=65536
   nsec1=time()
-  nfhopok=0                                ! Don't hop! 
+  nfhopok=0                                !Don't hop! 
   f0a=f0                                   !Save rx frequency at start
   ierr=soundin(ndevin,48000,kwave,4*npts,iqmode)
-  nfhopok=1                                ! Data acquisition done, can hop 
+  if(f0a.ne.f0) then
+     call cs_lock('rx')
+     print*,'Error in rx.f90:',f0,f0a
+     call cs_unlock
+  endif
+  nfhopok=1                                !Data acquisition done, can hop 
   if(ierr.ne.0) then
      print*,'Error in soundin',ierr
      stop
   endif
 
-
   if(iqmode.eq.1) then
      call iqdemod(kwave,4*npts,nfiq,nbfo,iqrx,iqrxapp,gain,phase,iwave)
   else
-     call fil1(kwave,4*npts,iwave,n2)         !Filter and downsample
+     call fil1(kwave,4*npts,iwave,n2)       !Filter and downsample
      npts=n2
   endif
   nsec2=time()
-  call getrms(iwave,npts,ave,rms)          !### is this needed any more??
+  call getrms(iwave,npts,ave,rms)           !### is this needed any more??
   call cs_lock('rx')
   nrxdone=1
   if(ncal.eq.1) ncal=2

Deleted: branches/wspr/spec162.f
===================================================================
--- branches/wspr/spec162.f	2012-12-20 19:16:42 UTC (rev 2843)
+++ branches/wspr/spec162.f	2012-12-21 16:12:36 UTC (rev 2844)
@@ -1,98 +0,0 @@
-      subroutine spec162(c2,jz,appdir,nappdir)
-
-      parameter(NX=500,NY=160)
-      complex c2(65536)
-      complex c(0:255)
-      character*80 appdir,pixmap
-      real s(120,0:255)
-      real ss(0:255)
-      real w(0:255)
-      real savg(0:255)
-      integer*2 a(NX,NY)
-      common/bcom/ntransmitted
-
-      nfft=256
-      twopi=6.2831853
-      pi=0.5*twopi
-      do i=0,nfft-1
-         w(i)=sin(i*pi/nfft)
-      enddo
-
-      nadd=9
-      call zero(s,120*256)
-      call zero(savg,256)
-      istep=nfft/2
-      nsteps=(jz-nfft)/(nadd*istep)
-      pixmap=appdir(:nappdir)//'/pixmap.dat'
-
-      call cs_lock('spec162')
-      open(16,file=pixmap,access='stream',status='unknown',err=1)
-      read(16,end=1) a
-      go to 2
- 1    call zero(a,NX*NY/2)
-
- 2    nmove=nsteps+1
-      call cs_unlock
-
-      do j=1,NY                 !Move waterfall left
-         do i=1,NX-nmove
-            a(i,j)=a(i+nmove,j)
-         enddo
-         a(NX-nmove+1,j)=255*ntransmitted
-      enddo
-      ntransmitted=0
-
-      i0=-istep+1
-      k=0
-      do n=1,nsteps
-         k=k+1
-         call zero(ss,256)
-         do m=1,nadd
-            i0=i0+istep
-            do i=0,nfft-1
-               c(i)=w(i)*c2(i0+i)
-            enddo
-            call four2a(c,nfft,1,-1,1)
-            do i=0,nfft-1
-               sq=real(c(i))**2 + imag(c(i))**2
-               ss(i)=ss(i) + sq
-               savg(i)=savg(i) + sq
-            enddo
-         enddo
-         call flat3(ss,256,nadd)
-         do i=0,nfft-1
-            s(k,i)=ss(i)
-         enddo
-      enddo
-      kz=k
-
-      gain=40
-      offset=-90.
-      fac=20.0/nadd
-
-      do k=1,kz
-         j=k-kz+NX
-         do i=-80,-1
-            x=fac*s(k,i+nfft)
-            n=0
-            if(x.gt.0.0) n=gain*log10(x) + offset
-            n=min(252,max(0,n))
-            a(j,NY-i-80)=n
-         enddo
-         do i=0,79
-            x=fac*s(k,i)
-            n=0
-            if(x.gt.0.0) n=gain*log10(x) + offset
-            n=min(252,max(0,n))
-            a(j,NY-i-80)=n
-         enddo
-      enddo
-
-      call cs_lock('spec162')
-      rewind 16
-      write(16) a
-      close(16)
-      call cs_unlock
-
-      return
-      end

Copied: branches/wspr/spec162.f90 (from rev 2843, branches/wspr/spec162.f)
===================================================================
--- branches/wspr/spec162.f90	                        (rev 0)
+++ branches/wspr/spec162.f90	2012-12-21 16:12:36 UTC (rev 2844)
@@ -0,0 +1,94 @@
+subroutine spec162(c2,jz,appdir,nappdir)
+
+  parameter(NX=500,NY=160)
+  complex c2(65536)
+  complex c(0:255)
+  character*80 appdir,pixmap
+  real s(120,0:255)
+  real ss(0:255)
+  real w(0:255)
+  real savg(0:255)
+  integer*2 a(NX,NY)
+  common/bcom/ntransmitted
+
+  nfft=256
+  twopi=6.2831853
+  pi=0.5*twopi
+  do i=0,nfft-1
+     w(i)=sin(i*pi/nfft)
+  enddo
+
+  nadd=9
+  call zero(s,120*256)
+  call zero(savg,256)
+  istep=nfft/2
+  nsteps=(jz-nfft)/(nadd*istep)
+  pixmap=appdir(:nappdir)//'/pixmap.dat'
+
+  open(16,file=pixmap,access='stream',status='unknown',err=1)
+  read(16,end=1) a
+  go to 2
+1 call zero(a,NX*NY/2)
+
+2 nmove=nsteps+1
+
+  do j=1,NY                 !Move waterfall left
+     do i=1,NX-nmove
+        a(i,j)=a(i+nmove,j)
+     enddo
+     a(NX-nmove+1,j)=255*ntransmitted
+  enddo
+  ntransmitted=0
+
+  i0=-istep+1
+  k=0
+  do n=1,nsteps
+     k=k+1
+     call zero(ss,256)
+     do m=1,nadd
+        i0=i0+istep
+        do i=0,nfft-1
+           c(i)=w(i)*c2(i0+i)
+        enddo
+        call four2a(c,nfft,1,-1,1)
+        do i=0,nfft-1
+           sq=real(c(i))**2 + imag(c(i))**2
+           ss(i)=ss(i) + sq
+           savg(i)=savg(i) + sq
+        enddo
+     enddo
+     call flat3(ss,256,nadd)
+     do i=0,nfft-1
+        s(k,i)=ss(i)
+     enddo
+  enddo
+  kz=k
+
+  gain=40
+  offset=-90.
+  fac=20.0/nadd
+
+  do k=1,kz
+     j=k-kz+NX
+     do i=-80,-1
+        x=fac*s(k,i+nfft)
+        n=0
+        if(x.gt.0.0) n=gain*log10(x) + offset
+        n=min(252,max(0,n))
+        a(j,NY-i-80)=n
+     enddo
+     do i=0,79
+        x=fac*s(k,i)
+        n=0
+        if(x.gt.0.0) n=gain*log10(x) + offset
+        n=min(252,max(0,n))
+        a(j,NY-i-80)=n
+     enddo
+  enddo
+
+  rewind 16
+  write(16) a
+  close(16)
+
+  return
+end subroutine spec162

Deleted: branches/wspr/sync162.f
===================================================================
--- branches/wspr/sync162.f	2012-12-20 19:16:42 UTC (rev 2843)
+++ branches/wspr/sync162.f	2012-12-21 16:12:36 UTC (rev 2844)
@@ -1,199 +0,0 @@
-      subroutine sync162(c2,jz,ps,sstf,kz)
-
-C  Find MEPT_JT sync signals, with best-fit DT and DF.  
-
-      complex c2(jz)
-      parameter (NFFT=512)             !Length of FFTs
-      parameter (NH=NFFT/2)            !Length of power spectra
-      parameter (NSMAX=351)            !Number of half-symbol steps
-      parameter (NF0=136,NF1=10)
-      parameter (LAGMAX=26)
-      real psavg(-NH:NH)               !Average spectrum of whole record
-      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
-      real ps(-NH:NH)
-      real psmo(-NH:NH)
-      real freq(-NH:NH)
-      real p1(-NH:NH)
-      real drift(-NH:NH)
-      real dtx(-NH:NH)
-      integer keep0(-NH:NH)
-      integer keep(-NH:NH)
-      real a(5)
-      real sstf(5,275)
-      real tmp(275)
-      integer npr3(162)
-      real pr3(162)
-      data npr3/
-     +  1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     +  0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     +  0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     +  1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     +  0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     +  0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     +  0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     +  0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     +  0,0/
-      save
-
-      nsym=162
-      do i=1,nsym
-         pr3(i)=2*npr3(i)-1
-      enddo
-
-C  Do FFTs of twice symbol length, stepped by half symbols.  
-      nq=NFFT/4
-      nsteps=jz/nq - 1
-      df=375.0/nfft
-      dt=1.0/375.0
-      call zero(psavg,NFFT+1)
-
-C  Compute power spectrum for each step, and get average
-      do j=1,nsteps
-         k=(j-1)*nq + 1
-         call ps162(c2(k),s2(-NH,j))
-         call add(psavg,s2(-NH,j),psavg,NFFT)
-      enddo
-
-! Normalize and subtract baseline from psavg.
-      call pctile(psavg(-136),tmp,273,35,base)
-      psavg=psavg/base - 1.0
-      base=base/351.0
-      s2=s2/base - 1.0
-
-! Boxcar-smooth the average spectrum over the WSPR signal bandwidth.
-      do i=-NH+3,NH-3
-         psmo(i)=0.
-         do k=-3,3
-            psmo(i)=psmo(i)+ps(i+k)
-         enddo
-         psmo(i)=psmo(i)/7.0
-      enddo
-
-! Mark potential suspects for WSPR signals.  
-! (Keep only the best one within a surrounding range of +/- 8 bins.)
-
-      plimit=0.1                      !### Are the plimit values OK? ###
-      do i=-NF0,NF0
-         keep0(i)=0
-         keep(i)=0
-         ia=i-4
-         ib=i+4
-         pmax=-1.e30
-         do ii=ia,ib
-            if(psmo(ii).gt.pmax) then
-               ipk=ii
-               pmax=psmo(ii)
-            endif
-         enddo
-         if(ipk.eq.i .and. pmax.ge.plimit) then
-            keep0(i)=1
-! Kill all smaller peaks leading up to this maximum.
-            do ii=ia,i-1
-               keep0(ii)=0
-            enddo
-         endif
-      enddo
-
-! Now mark the bins +/- 1 from each one already marked.
-      do i=-NF0+1,NF0-1
-         if(keep0(i).eq.1) then
-            keep(i-1)=1
-            keep(i)=1
-            keep(i+1)=1
-         endif
-      enddo
-
-! Now do the main search over DT, DF, and drift.  (Do CCFs in all marked
-! frequency bins and over a range of reasonable fdot values and lags.)
-      p1=0.
-      do i=-NF0,NF0
-         if(keep(i).eq.0) go to 10
-         smax=0.
-         do k=-NF1,NF1
-            if(abs(k).ne.1) then
-               do lag=0,LAGMAX
-                  sum=0.
-                  n=lag-1
-                  do j=1,162
-                     n=n+2
-                     ii=i + nint(k*(j-81)/162.0)
-                     x=max(s2(ii-1,n),s2(ii+3,n)) - 
-     +                    max(s2(ii-3,n),s2(ii+1,n))
-                     sum=sum + x*pr3(j)
-                  enddo
-                  if(sum.gt.smax) then
-                     kpk=k
-                     lagpk=lag
-                     smax=sum
-                  endif
-               enddo
-            endif
-         enddo
-
-! Save the CCF value, frequency, drift rate, and DT.
-         p1(i)=smax
-         freq(i)=df*i
-         drift(i)=df*kpk
-         dtx(i)=128.0*dt*lagpk
- 10      continue
-      enddo
-
-! Eliminate potential duplicates and peaks smaller than plimit.
-      keep=0
-      plimit=1.0
-      do i=-NF0,NF0
-         ia=max(-NF0,i-8)
-         ib=min(NF0,i+8)
-         pmax=-1.e30
-         do ii=ia,ib
-            if(p1(ii).gt.pmax) then
-               ipk=ii
-               pmax=p1(ii)
-            endif
-         enddo
-         if(ipk.eq.i .and. pmax.ge.plimit) then
-            keep(i)=1
-            do ii=ia,i-1
-               keep(ii)=0
-            enddo
-         endif
-      enddo
-
-! Compress the candidate list, saving only the potentially important ones.
-! Recalibrate sync indicator p1 on a dB scale.  
-! (NB: p1 sould be compared with snrx!)
-      k=0
-      do i=-NF0,NF0
-         if(keep(i).ne.0) then
-            x=10.0*log10(p1(i)) - 22
-            if(x.ge.0.5) then
-               k=min(k+1,275)
-               p1(k)=x
-               freq(k)=freq(i)
-               drift(k)=drift(i)
-               dtx(k)=dtx(i) - 2.0
-            endif
-         endif
-      enddo
-      kz=k
-
-      do k=1,kz
-         a(1)=-freq(k)
-         a(2)=-0.5*drift(k)
-         a(3)=0.
-         lagpk=nint((dtx(k)+2)/(128*dt))
-         lag1=max(-200,8*lagpk-16)
-         lag2=min(200,8*lagpk+16)
-         ccf=fchisq(c2,jz,375.0,a,lag1,lag2,ccfbest,dtbest)
-         ipk=nint(freq(k)/df)
-         snrx=db(max(psavg(ipk),0.0001)) - 26.5         !Empirical
-         sstf(1,k)=p1(k)
-         sstf(2,k)=snrx
-         sstf(3,k)=dtbest-2.0
-         sstf(4,k)=freq(k)
-         sstf(5,k)=drift(k)
-      enddo
-      
-      return
-      end
-

Copied: branches/wspr/sync162.f90 (from rev 2843, branches/wspr/sync162.f)
===================================================================
--- branches/wspr/sync162.f90	                        (rev 0)
+++ branches/wspr/sync162.f90	2012-12-21 16:12:36 UTC (rev 2844)
@@ -0,0 +1,197 @@
+subroutine sync162(c2,jz,ps,sstf,kz)
+
+! Find MEPT_JT sync signals, with best-fit DT and DF.  
+
+  complex c2(jz)
+  parameter (NFFT=512)             !Length of FFTs
+  parameter (NH=NFFT/2)            !Length of power spectra
+  parameter (NSMAX=351)            !Number of half-symbol steps
+  parameter (NF0=136,NF1=10)
+  parameter (LAGMAX=26)
+  real psavg(-NH:NH)               !Average spectrum of whole record
+  real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
+  real ps(-NH:NH)
+  real psmo(-NH:NH)
+  real freq(-NH:NH)
+  real p1(-NH:NH)
+  real drift(-NH:NH)
+  real dtx(-NH:NH)
+  integer keep0(-NH:NH)
+  integer keep(-NH:NH)
+  real a(5)
+  real sstf(5,275)
+  integer npr3(162)
+  real pr3(162)
+  data npr3/                                        &amp;
+       1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,     &amp;
+       0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,     &amp;
+       0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,     &amp;
+       1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,     &amp;
+       0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,     &amp;
+       0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,     &amp;
+       0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,     &amp;
+       0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,     &amp;
+       0,0/
+  save
+
+  nsym=162
+  do i=1,nsym
+     pr3(i)=2*npr3(i)-1
+  enddo
+
+! Do FFTs of twice symbol length, stepped by half symbols.  
+  nq=NFFT/4
+  nsteps=jz/nq - 1
+  df=375.0/nfft
+  dt=1.0/375.0
+  call zero(psavg,NFFT+1)
+
+! Compute power spectrum for each step, and get average
+  do j=1,nsteps
+     k=(j-1)*nq + 1
+     call ps162(c2(k),s2(-NH,j))
+     call add(psavg,s2(-NH,j),psavg,NFFT)
+  enddo
+
+! Normalize and subtract baseline from psavg.
+  call pctile(psavg(-136),273,35,base)
+  psavg=psavg/base - 1.0
+  base=base/351.0
+  s2=s2/base - 1.0
+
+! Boxcar-smooth the average spectrum over the WSPR signal bandwidth.
+  do i=-NH+3,NH-3
+     psmo(i)=0.
+     do k=-3,3
+        psmo(i)=psmo(i)+ps(i+k)
+     enddo
+     psmo(i)=psmo(i)/7.0
+  enddo
+
+! Mark potential suspects for WSPR signals.  
+! (Keep only the best one within a surrounding range of +/- 8 bins.)
+
+  plimit=0.1                      !### Are the plimit values OK? ###
+  do i=-NF0,NF0
+     keep0(i)=0
+     keep(i)=0
+     ia=i-4
+     ib=i+4
+     pmax=-1.e30
+     do ii=ia,ib
+        if(psmo(ii).gt.pmax) then
+           ipk=ii
+           pmax=psmo(ii)
+        endif
+     enddo
+     if(ipk.eq.i .and. pmax.ge.plimit) then
+        keep0(i)=1
+! Kill all smaller peaks leading up to this maximum.
+        do ii=ia,i-1
+           keep0(ii)=0
+        enddo
+     endif
+  enddo
+
+! Now mark the bins +/- 1 from each one already marked.
+  do i=-NF0+1,NF0-1
+     if(keep0(i).eq.1) then
+        keep(i-1)=1
+        keep(i)=1
+        keep(i+1)=1
+     endif
+  enddo
+
+! Now do the main search over DT, DF, and drift.  (Do CCFs in all marked
+! frequency bins and over a range of reasonable fdot values and lags.)
+  p1=0.
+  do i=-NF0,NF0
+     if(keep(i).eq.0) go to 10
+     smax=0.
+     do k=-NF1,NF1
+        if(abs(k).ne.1) then
+           do lag=0,LAGMAX
+              sum=0.
+              n=lag-1
+              do j=1,162
+                 n=n+2
+                 ii=i + nint(k*(j-81)/162.0)
+                 x=max(s2(ii-1,n),s2(ii+3,n)) - max(s2(ii-3,n),s2(ii+1,n))
+                 sum=sum + x*pr3(j)
+              enddo
+              if(sum.gt.smax) then
+                 kpk=k
+                 lagpk=lag
+                 smax=sum
+              endif
+           enddo
+        endif
+     enddo
+
+! Save the CCF value, frequency, drift rate, and DT.
+     p1(i)=smax
+     freq(i)=df*i
+     drift(i)=df*kpk
+     dtx(i)=128.0*dt*lagpk
+10   continue
+  enddo
+
+! Eliminate potential duplicates and peaks smaller than plimit.
+  keep=0
+  plimit=1.0
+  do i=-NF0,NF0
+     ia=max(-NF0,i-8)
+     ib=min(NF0,i+8)
+     pmax=-1.e30
+     do ii=ia,ib
+        if(p1(ii).gt.pmax) then
+           ipk=ii
+           pmax=p1(ii)
+        endif
+     enddo
+     if(ipk.eq.i .and. pmax.ge.plimit) then
+        keep(i)=1
+        do ii=ia,i-1
+           keep(ii)=0
+        enddo
+     endif
+  enddo
+
+! Compress the candidate list, saving only the potentially important ones.
+! Recalibrate sync indicator p1 on a dB scale.  
+! (NB: p1 sould be compared with snrx!)
+  k=0
+  do i=-NF0,NF0
+     if(keep(i).ne.0) then
+        x=10.0*log10(p1(i)) - 22
+        if(x.ge.0.5) then
+           k=min(k+1,275)
+           p1(k)=x
+           freq(k)=freq(i)
+           drift(k)=drift(i)
+           dtx(k)=dtx(i) - 2.0
+        endif
+     endif
+  enddo
+  kz=k
+
+  do k=1,kz
+     a(1)=-freq(k)
+     a(2)=-0.5*drift(k)
+     a(3)=0.
+     lagpk=nint((dtx(k)+2)/(128*dt))
+     lag1=max(-200,8*lagpk-16)
+     lag2=min(200,8*lagpk+16)
+     ccf=fchisq(c2,jz,375.0,a,lag1,lag2,ccfbest,dtbest)
+     ipk=nint(freq(k)/df)
+     snrx=db(max(psavg(ipk),0.0001)) - 26.5         !Empirical
+     sstf(1,k)=p1(k)
+     sstf(2,k)=snrx
+     sstf(3,k)=dtbest-2.0
+     sstf(4,k)=freq(k)
+     sstf(5,k)=drift(k)
+  enddo
+      
+  return
+end subroutine sync162
+

Modified: branches/wspr/wspr.py
===================================================================
--- branches/wspr/wspr.py	2012-12-20 19:16:42 UTC (rev 2843)
+++ branches/wspr/wspr.py	2012-12-21 16:12:36 UTC (rev 2844)
@@ -1,4 +1,4 @@
-#--------------------------------------------------------------------- WSPR
+#---------------------------------------------------------------------- WSPR
 # $Date: 2008-03-17 08:29:04 -0400 (Mon, 17 Mar 2008) $ $Revision$
 #
 # WSPR (pronounced &quot;whisper&quot;) stands for &quot;Weak Signal

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002535.html">[WSJT-SVN] r2843 - branches/wspr
</A></li>
	<LI>Next message: <A HREF="002537.html">[WSJT-SVN] r2845 - branches/wspr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2536">[ date ]</a>
              <a href="thread.html#2536">[ thread ]</a>
              <a href="subject.html#2536">[ subject ]</a>
              <a href="author.html#2536">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
