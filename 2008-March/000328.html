<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r640 - in branches: . wspr wspr/save
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r640%20-%20in%20branches%3A%20.%20wspr%20wspr/save&In-Reply-To=%3C200803201228.m2KCSSWf016574%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000326.html">
   <LINK REL="Next"  HREF="000327.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r640 - in branches: . wspr wspr/save</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r640%20-%20in%20branches%3A%20.%20wspr%20wspr/save&In-Reply-To=%3C200803201228.m2KCSSWf016574%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r640 - in branches: . wspr wspr/save">k1jt at mail.berlios.de
       </A><BR>
    <I>Thu Mar 20 13:28:28 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000326.html">[WSJT-SVN] r639 - trunk
</A></li>
        <LI>Next message: <A HREF="000327.html">[WSJT-SVN] r641 - branches/wspr/save
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#328">[ date ]</a>
              <a href="thread.html#328">[ thread ]</a>
              <a href="subject.html#328">[ subject ]</a>
              <a href="author.html#328">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2008-03-20 13:27:22 +0100 (Thu, 20 Mar 2008)
New Revision: 640

Added:
   branches/wspr/
   branches/wspr/ALL_MEPT.TXT
   branches/wspr/DFINC.MAK
   branches/wspr/Makefile
   branches/wspr/Makefile.CVF
   branches/wspr/Makefile.MinGW
   branches/wspr/Pmw.py
   branches/wspr/PmwBlt.py
   branches/wspr/PmwColor.py
   branches/wspr/WSPR.INI
   branches/wspr/WSPR_Announcement.TXT
   branches/wspr/WSPR_Instructions.TXT
   branches/wspr/conv232.f
   branches/wspr/db.f
   branches/wspr/decode162.f
   branches/wspr/deg2grid.f
   branches/wspr/encode232.f
   branches/wspr/fano232.f
   branches/wspr/four1.f
   branches/wspr/four2.f
   branches/wspr/g.py
   branches/wspr/genmept.f
   branches/wspr/getrms.f
   branches/wspr/getsound.c
   branches/wspr/gran.f90
   branches/wspr/grid2deg.f
   branches/wspr/inter_mept.f
   branches/wspr/libportaudio.a
   branches/wspr/mept162.f
   branches/wspr/mept_jt.f90
   branches/wspr/mept_rx.f90
   branches/wspr/mept_tx.f90
   branches/wspr/mix162.f
   branches/wspr/nchar.f
   branches/wspr/options.py
   branches/wspr/pa.lib
   branches/wspr/pack50.f
   branches/wspr/packcall.f
   branches/wspr/packgrid.f
   branches/wspr/packmept.f
   branches/wspr/palettes.py
   branches/wspr/pctile.f
   branches/wspr/peakup.f
   branches/wspr/playsound.c
   branches/wspr/portaudio.h
   branches/wspr/ps162.f
   branches/wspr/ptt.c
   branches/wspr/save/
   branches/wspr/save/1222.wav
   branches/wspr/set.f
   branches/wspr/slope.f
   branches/wspr/sort.f
   branches/wspr/ssort.f
   branches/wspr/sync162.f
   branches/wspr/unpack50.f
   branches/wspr/unpackcall.f
   branches/wspr/unpackgrid.f
   branches/wspr/unpackmept.f
   branches/wspr/wfile5.f
   branches/wspr/wsjt.ico
   branches/wspr/wspr.f90
   branches/wspr/wspr.py
   branches/wspr/wspr_rx.f90
   branches/wspr/wspr_tx.f90
   branches/wspr/wsprrc.win
   branches/wspr/xcor162.f
   branches/wspr/xfft.f
Log:
Initial import of WSPR branch.

Added: branches/wspr/ALL_MEPT.TXT
===================================================================
--- branches/wspr/ALL_MEPT.TXT	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/ALL_MEPT.TXT	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,537 @@
+1302  25  -4   0.5  10.140150  K1JT FN20 25             -20.3
+1312   1 -17   0.4  10.140157  TF3HZ HP94 35              7.6
+1432   3  -3  -0.1  10.140127  N3TFM EN72 30             14.3
+1432   9   4  -0.3  10.140141  VE1VDM FN85 23            14.3
+1440   7   8   0.3  10.140141  VE1VDM FN85 23            18.4
+1440   1 -11   0.3  10.140158  W8LIW EN81 27             18.4
+1442   3 -12   0.4  10.140159  W8LIW EN81 27             10.6
+1446  12   5   0.3  10.140141  VE1VDM FN85 23            11.7
+1446   2 -12   0.3  10.140158  W8LIW EN81 27             11.7
+1448   6 -10   0.1  10.140122  N4AU EM62 20               8.0
+1448   6 -14   0.8  10.140137  K7EK CN87 37               8.0
+1450  14   8   0.3  10.140141  VE1VDM FN85 23            15.1
+1452  10  -5   0.5  10.140127  N3TFM EN72 30             12.9
+1504   6   3   0.3  10.140141  VE1VDM FN85 23            13.4
+1504   2   6   1.1  10.140167  K9FH EN62 30              13.4
+1510  14   2   0.4  10.140127  N3TFM EN72 30             15.0
+1510  12   5   0.4  10.140141  VE1VDM FN85 23            15.0
+1510   1 -11   0.3  10.140157  W8LIW EN81 27             15.0
+1512   3   4   0.4  10.140141  VE1VDM FN85 23            14.8
+1512   9   1   1.3  10.140169  K9FH EN62 30              14.8
+1512   1   3   0.6  10.140203  NC5O EM12 20              14.8
+1516   7   0   0.5  10.140127  N3TFM EN72 30              6.3
+1524   4   1   0.4  10.140141  VE1VDM FN85 23            12.2
+1526   7 -17   0.4  10.140157                            14.5
+1526   9   3   1.4  10.140168  K9FH EN62 30              14.5
+1528   2 -19   0.4  10.140158  TF3HZ HP94 35              9.4
+1530   8 -19   0.4  10.140147  OZ1PIF JO65 30            11.8
+1532   4 -14   0.4  10.140128  N3TFM EN72 30             11.7
+1532   3 -20   0.8  10.140137  K7EK CN87 37              11.7
+1532   1 -25   0.3  10.140157  TF3HZ HP94 35             11.7
+1538   2  -9   0.3  10.140158  W8LIW EN81 27             24.2
+1538   7   4   1.5  10.140168  K9FH EN62 30              24.2
+
+Wed Mar 19 15:42:51 2008 UTC
+ UTC Sync dB    DT     Freq    Message                  Noise
+-------------------------------------------------------------
+1550   1  -2  -0.1  10.140044  W9SE EN50 27              14.9
+1550   4   1   0.4  10.140164  W7IUV DN07 35             14.9
+1554   9   1  -0.2  10.140044  W9SE EN50 27              14.6
+1554   2 -18   0.4  10.140158  TF3HZ HP94 35             14.6
+1556   4   2   0.4  10.140128  N3TFM EN72 30              8.1
+1556   1 -19   0.3  10.140157  TF3HZ HP94 35              8.1
+1558   4  -5   0.6  10.140127  N3TFM EN72 30             15.1
+1558   1   3   1.6  10.140169  K9FH EN62 30              15.1
+1600   4  -6   0.4  10.140158  W8LIW EN81 27              8.4
+1602   5  -6   1.5  10.140169  K9FH EN62 30              22.4
+1604   1 -16   0.4  10.140157  TF3HZ HP94 35             19.0
+1606   7   2  -0.3  10.140044  W9SE EN50 27              10.9
+1606   6 -19   0.3  10.140157  TF3HZ HP94 35             10.9
+1608   1 -25   2.5  10.140106                             7.2
+1608  10 -17   0.4  10.140157  TF3HZ HP94 35              7.2
+1610  10   6  -0.0  10.140044  W9SE EN50 27              12.7
+1610   4 -23   1.1  10.140137  K7EK CN87 37              12.7
+1610   2 -20   0.4  10.140157  TF3HZ HP94 35             12.7
+1612   4 -14   0.4  10.140128  N3TFM EN72 30             11.9
+1612   4 -20   0.7  10.140136  K7EK CN87 37              11.9
+1612   2 -19   0.3  10.140158  TF3HZ HP94 35             11.9
+1614  11 -12   0.5  10.140127  N3TFM EN72 30             11.9
+1614   4   7   0.0  10.140144  W9SE EN50 27              11.9
+1614   1 -15   0.4  10.140158  TF3HZ HP94 35             11.9
+1618  12 -16   0.5  10.140127  N3TFM EN72 30             10.1
+1618   4   5   0.4  10.140168  W7IUV DN07 35             10.1
+1620   3   3   0.4  10.140144  W9SE EN50 27              16.1
+1622   6  -2   0.4  10.140158  W8LIW EN81 27             16.1
+1626   2 -18   0.3  10.140147  OZ1PIF JO65 30            10.8
+1632   2 -18   0.6  10.140112                            21.8
+1632   3 -18   0.4  10.140128                            21.8
+1632   1 -22   0.4  10.140158                            21.8
+1638   3  -1   0.4  10.140150  NC5O EM12 30              12.9
+1650   2 -22   0.1  10.140112  F8RZ IN95 30              15.2
+1650   8  -9   0.4  10.140127  N3TFM EN72 30             15.2
+
+ Wed Mar 19 16:53:59 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1654   2 -23   0.0  10.140112  F8RZ IN95 30          
+1656   6  -3   0.4  10.140152  NC5O EM12 27          
+1656   4  -1   0.4  10.140165  W7IUV DN07 35         
+1658   8  -3   0.5  10.140128  N3TFM EN72 30         
+
+ Wed Mar 19 17:00:59 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1702   6   0   0.4  10.140127  N3TFM EN72 30         
+
+ Wed Mar 19 17:05:36 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1706   7 -13   0.4  10.140147  OZ1PIF JO65 30 
+1708   3   0   0.4  10.140127  N3TFM EN72 30  
+1708   9 -19   0.4  10.140146  OZ1PIF JO65 30 
+1708   7 -21   0.4  10.140157  TF3HZ HP94 30  
+
+ Wed Mar 19 17:11:01 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1712   5  -4   0.4  10.140127  N3TFM EN72 30  
+1712   7  -9   0.4  10.140151  NC5O EM12 27   
+1714   2 -16   0.3  10.140158  W8LIW EN81 27  
+
+ Wed Mar 19 17:18:29 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1720   1  -7   0.2  10.140152  NC5O EM12 27   
+1722   5  -4   0.4  10.140150  NC5O EM12 27   
+1722   1 -18   0.4  10.140160                 
+1724   9 -13   0.4  10.140164  W7IUV DN07 35  
+1726   7 -24   0.4  10.140146  OZ1PIF JO65 30 
+1726   5 -26   0.3  10.140157  TF3HZ HP94 30  
+
+ Wed Mar 19 17:28:41 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1730  10 -19   0.4  10.140147  OZ1PIF JO65 30 
+1732   2 -29   0.0  10.140111  F8RZ IN95 30   
+1732   7 -11   0.4  10.140127  N3TFM EN72 30  
+
+ Wed Mar 19 17:35:53 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1736  13  -8   0.4  10.140127  N3TFM EN72 30  
+1736   4 -22   0.4  10.140147  OZ1PIF JO65 30 
+1736   4 -18   0.3  10.140164  W7IUV DN07 35  
+1738   3  -9   0.3  10.140141  VE1VDM FN85 23 
+1738   4 -25   0.3  10.140157  TF3HZ HP94 30  
+
+ Wed Mar 19 17:40:03 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1742   4 -21   0.4  10.140157  TF3HZ HP94 30  
+1744   8 -10   0.5  10.140127  N3TFM EN72 30  
+1746   8 -15  -0.1  10.140122  N4AU EM62 20   
+1746   1 -24   0.4  10.140165  W7IUV DN07 35  
+1750   6 -20   0.4  10.140146  OZ1PIF JO65 30 
+1752   7 -17   0.4  10.140164  W7IUV DN07 35  
+1754   7   0   0.5  10.140127  N3TFM EN72 30  
+1754   9  -7   0.4  10.140152  NC5O EM12 27   
+1756   6 -10   0.4  10.140151  NC5O EM12 27   
+1756   4 -12   0.4  10.140157  W8LIW EN81 27  
+1758  14  -2   0.3  10.140141  VE1VDM FN85 23 
+1800  17  -8   0.5  10.140127  N3TFM EN72 30  
+1800   4 -19   0.4  10.140164  W7IUV DN07 35  
+1802   8 -16   0.4  10.140158                 
+1804   5 -10  -0.0  10.140114  N4AU EM62 20   
+1804  13  -4   0.4  10.140127  N3TFM EN72 30  
+1804  10  -7   0.4  10.140152  NC5O EM12 27   
+
+ Wed Mar 19 18:13:08 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1814   1 -21   0.4  10.140146  OZ1PIF JO65 30 
+1816  10  -8   0.5  10.140127  N3TFM EN72 30  
+1818   9  -2   0.4  10.140157  W8LIW EN81 27  
+
+ Wed Mar 19 18:20:15 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+
+ Wed Mar 19 18:20:25 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1822  15  -6   0.4  10.140151  NC5O EM12 27   
+1824  11 -13   0.4  10.140127  N3TFM EN72 30  
+1824   6 -12   0.0  10.140133  N4AU EM62 20   
+1824   3 -17   0.3  10.140150  NC5O EM12 27   
+1824   3 -27   0.4  10.140165  W7IUV DN07 35  
+1826   4  -2   0.5  10.140126  N3TFM EN72 30  
+1832   2 -26   0.7  10.140203  GI8HXY IO64 37 
+1836   8  -4   0.4  10.140127  N3TFM EN72 30  
+1836   6   5   0.4  10.140141  VE1VDM FN85 23 
+1836  11 -16   0.4  10.140165  W7IUV DN07 35  
+1838   6  -8   1.3  10.140147  N4AU EM62 20   
+1838   4 -22   0.4  10.140157                 
+1840  11   3   0.4  10.140141  VE1VDM FN85 23 
+1840   4  -7   1.1  10.140150  000AAA RA90 -64
+
+ Wed Mar 19 18:43:30 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1844   3  -5   0.5  10.140127  N3TFM EN72 30  
+1844   5 -24   0.4  10.140162                 
+1846   3   1   0.4  10.140141  VE1VDM FN85 23 
+1848   6 -15   0.3  10.140164  W7IUV DN07 35  
+
+ Wed Mar 19 18:51:03 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1854   8 -17   0.3  10.140147  OZ1PIF JO65 30 
+1854   6 -12   0.4  10.140164  W7IUV DN07 35  
+
+ Wed Mar 19 18:56:08 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1858   5 -11   0.1  10.140129  N4AU EM62 20   
+1900   3 -20   0.3  10.140162  W8LIW EN81 27  
+
+ Wed Mar 19 19:03:05 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+
+ Wed Mar 19 19:05:18 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1906   6 -17   0.3  10.140147  OZ1PIF JO65 30 
+1906   1 -27   0.3  10.140157                 
+1908   9 -15   0.4  10.140128  N3TFM EN72 30  
+1910  10 -14   0.4  10.140127  N3TFM EN72 30  
+1910   2   5   0.3  10.140141  VE1VDM FN85 23 
+1912   8   1   0.1  10.140122  N4AU EM62 20   
+1914   2 -26   0.8  10.140136                 
+1914   2 -22   1.1  10.140178                 
+1916   4 -16   0.4  10.140146                 
+1922   3  -8   0.3  10.140147  OZ1PIF JO65 30 
+1924  12  -1   0.4  10.140128  N3TFM EN72 30  
+1924   4  -9   0.4  10.140182  GI8HXY IO64 37 
+1926   4   4   0.3  10.140141  VE1VDM FN85 23 
+1926   3  -1   0.5  10.140182  GI8HXY IO64 37 
+1928   4  -9   0.5  10.140127  N3TFM EN72 30  
+1928   4 -24   0.4  10.140157  TF3HZ HP94 27  
+1930   3 -11   0.4  10.140147  OZ1PIF JO65 30 
+1932  10  -1   0.3  10.140121  N4AU EM62 20   
+1932   6  -4   0.4  10.140178  GI8HXY IO64 37 
+1934   3 -19  -0.9  10.140163  W8LIW EN81 27  
+1936   8 -10   0.4  10.140128  N3TFM EN72 30  
+1936   4 -25   0.3  10.140157  TF3HZ HP94 27  
+1938  17 -12   0.4  10.140127  N3TFM EN72 30  
+1940  10  -2   0.4  10.140121  N4AU EM62 20   
+1940   1 -28   0.3  10.140157                 
+1940  12 -13   0.3  10.140167  W7IUV DN07 35  
+1944   8  -7   0.4  10.140127  N3TFM EN72 30  
+1948  10  -2   0.4  10.140120  N4AU EM62 20   
+1948   1 -31   0.4  10.140149                 
+1950   1 -23   0.4  10.140157  TF3HZ HP94 27  
+1954   2 -23   0.3  10.140157                 
+1954   5 -12   0.4  10.140167  W7IUV DN07 35  
+2004   2 -21   0.3  10.140157  TF3HZ HP94 27  
+2008  11   0   0.4  10.140127  N3TFM EN72 30  
+2008   3   6   0.3  10.140141  VE1VDM FN85 23 
+2014  11  -6   0.4  10.140128  N3TFM EN72 30  
+2014   7   6   0.3  10.140141  VE1VDM FN85 23 
+2016   5  -5   0.4  10.140127  N3TFM EN72 30  
+2016   2   3   0.6  10.140178  GI8HXY IO64 37 
+2018   1 -27   0.8  10.140138  K7EK CN87 37   
+2018   9   1   0.4  10.140163  W8LIW EN81 27  
+2020   5 -30   0.8  10.140138                 
+2022  13  -3   0.4  10.140127  N3TFM EN72 30  
+2022   5 -14   0.3  10.140167  W7IUV DN07 35  
+
+ Wed Mar 19 20:27:54 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+2028   2 -17   0.4  10.140157  TF3HZ HP94 27  
+2028  10 -12   0.4  10.140165  W7IUV DN07 35  
+2032   5  -3   0.7  10.140182  GI8HXY IO64 37 
+2034   1 -27   1.1  10.140138                 
+2034   4   5   0.6  10.140182  GI8HXY IO64 37 
+2036   8  -5   0.4  10.140127  N3TFM EN72 30  
+2036   8 -12   0.4  10.140147  OZ1PIF JO65 30 
+2036   1 -19   0.4  10.140157                 
+2036   9   3   0.4  10.140182  GI8HXY IO64 37 
+2040   3 -27   0.4  10.140114                 
+2040   2  -3  -0.4  10.140157  W9SE EN50 27   
+2042   8 -12   0.4  10.140165  W7IUV DN07 35  
+2044   6 -22   0.8  10.140137  K7EK CN87 37   
+
+ Wed Mar 19 20:47:34 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+2048   3  -9   0.4  10.140147  OZ1PIF JO65 30 
+2050   4   3   0.3  10.140141  VE1VDM FN85 23 
+2052  12  -3   0.4  10.140128  N3TFM EN72 30  
+2054   1 -29   0.3  10.140113                 
+2054   5   4   0.4  10.140181  GI8HXY IO64 37 
+2056   1 -23   0.4  10.140113                 
+2056   8   2   0.3  10.140141  VE1VDM FN85 23 
+2058  11  -3   0.4  10.140127  N3TFM EN72 30  
+2058   6 -19   0.8  10.140137                 
+2102   4 -22   0.4  10.140113  WB3ANQ FM19 28 
+2102   3 -12   0.5  10.140167  W7IUV DN07 35  
+2104  13  -2   0.4  10.140127  N3TFM EN72 30  
+2104   8   1   0.3  10.140141  VE1VDM FN85 23 
+
+ Wed Mar 19 21:07:34 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+2108   4  -3   0.4  10.140127  N3TFM EN72 30  
+2110   8   1   0.3  10.140141  VE1VDM FN85 23 
+2112   3 -23   0.3  10.140112                 
+2112   6  -5   0.4  10.140127  N3TFM EN72 30  
+2114   9 -24   0.3  10.140064                 
+
+ Wed Mar 19 21:16:37 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+2118   7 -18   0.3  10.140146  OZ1PIF JO65 30 
+2118   1  -1   0.6  10.140178  GI8HXY IO64 37 
+2120   5  -4   0.7  10.140179  GI8HXY IO64 37 
+2122   8 -10   0.4  10.140127  N3TFM EN72 30  
+2122   3 -26   0.1  10.140163                 
+2124   7 -12   0.3  10.140147  OZ1PIF JO65 30 
+2124   6 -14   0.4  10.140166  W7IUV DN07 35  
+2128   6 -14   0.4  10.140147  OZ1PIF JO65 30 
+2130  12  -4   0.4  10.140127  N3TFM EN72 30  
+2132   5 -12   0.6  10.140157  TF3HZ HP94 35  
+2134   1 -23   0.3  10.140113  WB3ANQ FM19 28 
+2136   8 -13   0.4  10.140166  W7IUV DN07 35  
+2136   2  -5   0.5  10.140176  GI8HXY IO64 37 
+2138   2 -13   0.4  10.140109  G0NBD IO83 35  
+2140   8  -4   0.5  10.140128  N3TFM EN72 30  
+2140   2 -15   0.4  10.140157  TF3HZ HP94 35  
+2142   7 -16   0.4  10.140157  TF3HZ HP94 35  
+2144   4 -24   0.3  10.140112  WB3ANQ FM19 28 
+2144   9  -6   0.3  10.140141  VE1VDM FN85 23 
+2144   3 -15   0.4  10.140166  W7IUV DN07 35  
+2146   7 -23   0.3  10.140064  VE6OG DO33 36  
+2146   5  -9   0.3  10.140141  VE1VDM FN85 23 
+2146   1 -17   0.4  10.140157  TF3HZ HP94 35  
+2148   8   1   0.2  10.140141  VE1VDM FN85 23 
+2148   2 -18   0.1  10.140162  W8LIW EN81 27  
+2150   6 -17   0.4  10.140112  WB3ANQ FM19 28 
+2150  14   1   0.3  10.140141  VE1VDM FN85 23 
+2150   5 -14   0.4  10.140157  TF3HZ HP94 35  
+2152   2 -19   0.4  10.140108  G0NBD IO83 35  
+2154  13 -18   0.4  10.140108  G0NBD IO83 35  
+2154  10   3   0.4  10.140141  VE1VDM FN85 23 
+2154   6 -10   0.4  10.140164  W7IUV DN07 35  
+2156   9  -1   0.4  10.140128  N3TFM EN72 30  
+2156   4   2   0.3  10.140141  VE1VDM FN85 23 
+2158  13  -1   0.4  10.140127  N3TFM EN72 30  
+2158   8   3   0.2  10.140141  VE1VDM FN85 23 
+2200  13   1   0.5  10.140127  N3TFM EN72 30  
+2202   1  -8   0.4  10.140107  G0NBD IO83 35  
+2202   8  -2   0.4  10.140126  N3TFM EN72 30  
+2204   6 -16   0.4  10.140164  W7IUV DN07 35  
+2206   5 -16   0.4  10.140107  G0NBD IO83 35  
+2210   3 -19   0.4  10.140106  G0NBD IO83 35  
+2210  12 -12   0.4  10.140127  N3TFM EN72 30  
+2212   7 -11   0.4  10.140127  N3TFM EN72 30  
+
+ Wed Mar 19 22:15:16 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+2216   2 -25   0.3  10.140111  WB3ANQ FM19 28 
+2216   4 -11   0.4  10.140165                 
+2218   2 -11   0.4  10.140106  G0NBD IO83 35  
+2218   2 -19   0.4  10.140127  N3TFM EN72 30  
+2218   9   3   0.3  10.140141  VE1VDM FN85 23 
+2220   6   2   0.3  10.140141  VE1VDM FN85 23 
+2220   6  -5   0.4  10.140151  NC5O EM12 27   
+
+ Wed Mar 19 22:22:39 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+2226   4  -9   0.4  10.140154  TF3HZ HP94 35  
+2228   3 -11   0.4  10.140154  TF3HZ HP94 35  
+2228   3 -17   0.4  10.140162  W8LIW EN81 27  
+2230   1 -18   0.1  10.140112  WB3ANQ FM19 28 
+2230  10  -8   0.3  10.140165  W7IUV DN07 35  
+2232   6 -16   0.3  10.140064  VE6OG DO33 36  
+2232   7 -21   0.8  10.140137  K7EK CN87 37   
+2234   5 -15   0.3  10.140106  KA3BPN FN11 37 
+2236   3 -12   0.3  10.140065  VE6OG DO33 36  
+2236   6   0   0.4  10.140151  NC5O EM12 27   
+2240   2  -8   0.3  10.140157  TF3HZ HP94 35  
+2244   8 -17   0.1  10.140112  WB3ANQ FM19 28 
+2244   3   2   0.3  10.140151  NC5O EM12 27   
+2246  16   4   0.3  10.140141  VE1VDM FN85 23 
+2246   8   0   0.3  10.140151  NC5O EM12 27   
+2248   8 -16   0.3  10.140106  KA3BPN FN11 37 
+2250   5 -19   0.3  10.140064  VE6OG DO33 36  
+2250   6   2   0.3  10.140151  NC5O EM12 27   
+2252   7 -18   0.3  10.140106  KA3BPN FN11 37 
+2252  15   2   0.3  10.140151  NC5O EM12 27   
+2254  12   5   0.3  10.140141  VE1VDM FN85 23 
+2254   5 -10   1.0  10.140157  TF3HZ HP94 35  
+2254   1 -25   1.4  10.140177                 
+2256   3   4   0.3  10.140141  VE1VDM FN85 23 
+2256   3 -11   0.4  10.140157  TF3HZ HP94 35  
+2258   6 -11   0.7  10.140157  TF3HZ HP94 35  
+2300   3   8   0.2  10.140141  VE1VDM FN85 23 
+2302   1 -11   0.7  10.140157  TF3HZ HP94 35  
+2304   5   1   0.4  10.140151  NC5O EM12 27   
+2306   3 -17   0.3  10.140106  KA3BPN FN11 37 
+2306  13   8   0.3  10.140141  VE1VDM FN85 23 
+2306   2 -10   0.8  10.140157  TF3HZ HP94 35  
+2308   3 -15   0.3  10.140106  KA3BPN FN11 37 
+2312   7   8   0.3  10.140141  VE1VDM FN85 23 
+2314   3 -15   0.3  10.140106  KA3BPN FN11 37 
+2316  11   6   0.3  10.140151  NC5O EM12 27   
+2316   5  -9   0.4  10.140167  W7IUV DN07 35  
+2318   1 -17   0.2  10.140106  KA3BPN FN11 37 
+2318  13   8   0.4  10.140141  VE1VDM FN85 23 
+2318   4  -9   0.4  10.140169  W7IUV DN07 35  
+2320   5 -15   0.3  10.140106  KA3BPN FN11 37 
+2320   6 -20   0.8  10.140137  K7EK CN87 37   
+2322   7   2   0.4  10.140151  NC5O EM12 27   
+2324  10   2   0.4  10.140151  NC5O EM12 27   
+2326   2   4   0.3  10.140151  NC5O EM12 27   
+2328   7 -15   0.3  10.140106  KA3BPN FN11 37 
+2330   2 -19   0.1  10.140113  WB3ANQ FM19 28 
+2330   2   5   0.2  10.140141  VE1VDM FN85 23 
+2330  12  -6   0.4  10.140164  W7IUV DN07 35  
+2332  10 -16   0.3  10.140106  KA3BPN FN11 37 
+2334   3 -19   0.2  10.140111  WB3ANQ FM19 28 
+2334   3  -7   0.4  10.140169  W7IUV DN07 35  
+2336   2 -26   0.3  10.140064                 
+2336   5   5   0.3  10.140151  NC5O EM12 27   
+2340   9   3   0.3  10.140151  NC5O EM12 27   
+2340   6 -18   0.3  10.140174  WD4KPD FM15 30 
+2344   5 -18   0.1  10.140112  WB3ANQ FM19 28 
+2344   5 -16   0.4  10.140163  W8LIW EN81 27  
+2346   3   0   0.3  10.140109  WB2JEP FM29 10 
+2352   7   2   0.4  10.140151  NC5O EM12 27   
+2352   3  -7   0.4  10.140164  W7IUV DN07 35  
+2354   1 -16   0.1  10.140162  W8LIW EN81 27  
+2356   4 -10   0.6  10.140109  WB2JEP FM29 20 
+2358   4 -11   0.4  10.140109  WB2JEP FM29 20 
+2358   3 -14   0.8  10.140138  K7EK CN87 37   
+2358   7   6   0.3  10.140151  NC5O EM12 27   
+2358   3  -2   0.5  10.140163  W7IUV DN07 35  
+0000   5 -14   0.8  10.140138  K7EK CN87 37   
+0000   6   7   0.3  10.140151  NC5O EM12 27   
+0002   3 -11   0.5  10.140109  WB2JEP FM29 20 
+0002   4  -1   0.4  10.140165  W7IUV DN07 35  
+0006  11 -16   0.7  10.140138  K7EK CN87 37   
+0006  10  -8   0.4  10.140166  W7IUV DN07 35  
+0008   2 -25   0.3  10.140112  WB3ANQ FM19 28 
+0008   5   3   0.4  10.140151  NC5O EM12 27   
+0010   6   5   0.4  10.140151  NC5O EM12 27   
+0012   3 -10   0.4  10.140163  W7IUV DN07 35  
+0014   1 -24   0.0  10.140112  WB3ANQ FM19 28 
+0016   7   4   0.4  10.140151  NC5O EM12 27   
+0020   4 -18  -0.3  10.140106  KA3BPN FN11 37 
+0020   3   5   0.3  10.140150  NC5O EM12 27   
+0022   1 -25   0.1  10.140112                 
+0024   3 -13   0.7  10.140138  K7EK CN87 37   
+0026   9 -10   0.4  10.140165  W7IUV DN07 35  
+0028   5 -20   0.4  10.140162  W8LIW EN81 27  
+0030   5 -17   0.4  10.140150  VE7TIL CN89 30 
+0034   3 -15   0.5  10.140146  N5UKZ EM40 37  
+0034   1 -19   0.3  10.140162  W8LIW EN81 27  
+0036   4  -5   0.4  10.140164  W7IUV DN07 35  
+0038   1 -26   0.0  10.140112  WB3ANQ FM19 27 
+0044  11  -5   0.4  10.140164  W7IUV DN07 35  
+0046   7  -6   0.8  10.140138  K7EK CN87 37   
+0046   6 -20   0.4  10.140162  W8LIW EN81 27  
+0048   5 -14   0.4  10.140150  VE7TIL CN89 30 
+0050   1  12  -0.3  10.140157                 
+0052   1  13  -0.7  10.140157                 
+0056   2  13  -1.0  10.140157                 
+0058   1 -22   0.3  10.140110                 
+0058   4  12  -0.3  10.140157  W9SE EN50 33   
+0100   7  -9   0.8  10.140138  K7EK CN87 37   
+0100   3   5  -0.1  10.140185                 
+0108   3  13  -0.6  10.140157                 
+0110   1 -12   0.9  10.140137  K7EK CN87 37   
+0110   5  12  -0.7  10.140157                 
+0112   3 -20   0.3  10.140109  WB2JEP FM29 20 
+0112   4 -10   0.9  10.140137  K7EK CN87 37   
+0114   2 -25   1.8  10.140122  K3UK FN02 37   
+0116   3 -13   0.8  10.140138  K7EK CN87 37   
+0116   3  -2  -0.5  10.140183                 
+
+ Thu Mar 20 01:20:24 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+0122   4 -21   0.4  10.140109  WB2JEP FM29 20 
+0122  14  -3   0.3  10.140151  NC5O EM12 27   
+0126   3 -23   0.3  10.140109                 
+0126  15   0   0.3  10.140151  NC5O EM12 27   
+0132  13  -9   0.7  10.140138  K7EK CN87 37   
+
+ Thu Mar 20 01:39:43 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+0142   6 -15   1.1  10.140091  KE7ACY CN94 37 
+0142   3  -9   0.4  10.140147                 
+0142   2   6  -0.5  10.140187                 
+0146  10 -13   1.1  10.140091  KE7ACY CN94 37 
+0146   8  -8   0.8  10.140138  K7EK CN87 37   
+0146   3  -1  -0.1  10.140187                 
+0148   4  -6   1.1  10.140091  KE7ACY CN94 37 
+0148   1 -24   0.3  10.140163  W8LIW EN81 27  
+0150   8 -11   1.1  10.140091  KE7ACY CN94 37 
+0150   7 -14   0.9  10.140138  K7EK CN87 37   
+0150  16   1   0.3  10.140152  NC5O EM12 27   
+0156   1 -10  -0.1  10.140182                 
+0200   4 -20   0.4  10.140152  VE7TIL CN89 30 
+0206   5   1   0.5  10.140150  VE3CDX DM26 30 
+0208   4   0   0.4  10.140150  VE3CDX DM26 30 
+
+ Thu Mar 20 02:10:12 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+0212   3 -23   0.4  10.140109                 
+0212   8  -7   0.9  10.140138  K7EK CN87 37   
+0214   5   1   0.5  10.140150  VE3CDX DM26 30 
+0222  12  -8   1.1  10.140091  KE7ACY CN94 37 
+0222   7  -2   0.5  10.140150  VE3CDX DM26 30 
+0222   2   1  -0.3  10.140183                 
+0232   6 -10   1.2  10.140091  KE7ACY CN94 37 
+0234   2 -24   0.3  10.140109  WB2JEP FM29 2  
+0234   6 -17   0.8  10.140138  K7EK CN87 37   
+0234   1   8  -0.6  10.140182                 
+0236  11 -16   1.1  10.140090  KE7ACY CN94 37 
+0252  14   8   0.3  10.140152  NC5O EM12 27   
+0316   3 -17  -0.1  10.140182                 
+0346   4   1  -0.3  10.140188                 
+0356   2 -22   0.3  10.140109  WB2JEP FM29 2  
+1006   2 -25   0.4  10.140147  OZ1PIF JO65 30 
+1010   5 -24   0.4  10.140147  OZ1PIF JO65 30 
+1022   6 -25   0.5  10.140147  OZ1PIF JO65 30 
+1026   3 -25   0.3  10.140147  OZ1PIF JO65 30 
+1034   3 -16   1.0  10.140098  ZL1ANY RF74 36 
+1034   5 -16   0.4  10.140147  OZ1PIF JO65 30 
+1036   6 -15   0.7  10.140163  TF3HZ HP94 30  
+1040   6 -15   0.4  10.140163  TF3HZ HP94 30  
+1054  11 -18   0.5  10.140163  TF3HZ HP94 30  
+1104   7 -21   0.4  10.140147  OZ1PIF JO65 30 
+1108   9 -15   1.1  10.140100  ZL1ANY RF74 36 
+1108  11 -23   0.4  10.140147  OZ1PIF JO65 30 
+1110   5 -15   1.1  10.140101  ZL1ANY RF74 36 
+1120   7 -16   1.1  10.140105  ZL1ANY RF74 36 
+1120   1 -20   0.4  10.140147  OZ1PIF JO65 30 
+1124   3 -24   0.4  10.140163  W8LIW EN81 27  
+
+ Thu Mar 20 12:10:24 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1216   5 -26   0.1  10.140100  K1JT FN20 30   
+
+ Thu Mar 20 12:17:57 2008 UTC
+ UTC Sync dB    DT     Freq    Message          
+------------------------------------------------
+1218   6 -26   0.4  10.140100  K1JT FN20 30   
+1220   4 -26   0.3  10.140100  K1JT FN20 30   
+1222   5 -26   0.4  10.140100  K1JT FN20 30   

Added: branches/wspr/DFINC.MAK
===================================================================
--- branches/wspr/DFINC.MAK	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/DFINC.MAK	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,87 @@
+#+
+# DFINC.MAK - Visual Fortran application master NMAKE definitions file
+#
+# This software DFINC.MAK is part of the Visual Fortran kit.
+# 
+# This file should be included at the top of all MAKEFILEs as follows:
+#  !include &lt;dfinc.mak&gt;
+# 
+# NMAKE Options:
+#
+# Use the table below to determine the additional options for NMAKE
+# Application Information Type         Invoke NMAKE
+# ----------------------------         ------------
+# For Debugging Info                   nmake debug=1
+# For linker map                       nmake linkmap=1
+# For linking with the DLLs            nmake linkdll=1
+#-
+
+# Set the defaults for all the MSVCxx versions
+
+crtimplib=msvcrt.lib
+
+!IFNDEF link
+link = link
+!ENDIF
+!IFNDEF libr
+libr = lib
+!ENDIF
+
+# Define the compiler verbs.
+FOR = df
+
+# Macros for the compiler
+!IFDEF DEBUG
+df_debug =  /debug:full
+lnk_debug = /debug:full /debugtype:both
+!ELSE
+df_debug =
+lnk_debug = /debug:none
+!ENDIF
+
+!IFDEF LINKDLL
+df_dll   = /call_dll
+dflibs   = dfordll.lib $(crtimplib) kernel32.lib
+!ELSE
+df_dll   =
+dflibs   = dfor.lib libc.lib kernel32.lib
+!ENDIF
+
+fflags    = $(df_debug) $(df_dll) 
+
+# Macros for the FPP Preprocesor 
+fppflags =
+fpp = $(FOR) $(fflags) /fpp=&quot;$(fppflags)&quot;
+
+# Macros for the linker.
+!IFDEF LINKMAP
+lflags = /map:$(*B).map $(lflags)
+!ELSE
+lflags = $(lflags)
+!ENDIF
+
+# SUFFIXES list
+.SUFFIXES: .exe .obj .asm .c .bas .cbl .fpp .for .f90 .pas .res .rc 
+
+# Define the inference rules
+.obj.exe:
+   $(FOR) $(df_dll) $(df_debug) /link $(lflags) $(lnk_debug) $*.obj 
+
+.for.exe:
+   $(FOR) $(fflags) $*.for /link $(lflags)
+
+.f90.exe:
+   $(FOR) $(fflags) $*.f90 /link $(lflags)
+
+.fpp.exe:
+   $(fpp) $*.fpp /link $(lflags)
+
+.for.obj:
+   $(FOR) $(df_debug) $*.for /nolink /object:$@
+
+.f90.obj:
+   $(FOR) $(df_debug) $*.f90 /nolink /object:$@
+
+.fpp.obj:
+   $(FOR) $(df_debug) /nolink /object:$@ /fpp:&quot;$(fppflags)&quot; $*.fpp
+

Added: branches/wspr/Makefile
===================================================================
--- branches/wspr/Makefile	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/Makefile	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,61 @@
+#Makefile for Windows and MinGW
+CC = gcc
+FC = g95
+
+FFLAGS = -cpp
+CFLAGS = -I. -fbounds-check
+
+OBJS1 = wspr.o mept_tx.o mept_rx.o genmept.o inter_mept.o \
+	mix162.o xfft.o four1.o four2.o sync162.o ps162.o \
+	mept162.o wfile5.o nchar.o grid2deg.o \
+	packcall.o packgrid.o pack50.o unpack50.o unpackcall.o \
+	unpackgrid.o deg2grid.o gran.o getrms.o ptt.o \
+	set.o encode232.o fano232.o \
+	xcor162.o slope.o peakup.o pctile.o db.o sort.o \
+	ssort.o decode162.o playsound.o getsound.o
+
+OBJS2 = wspr_tx.o genmept.o inter_mept.o nchar.o grid2deg.o \
+	packcall.o packgrid.o pack50.o unpack50.o unpackcall.o \
+	unpackgrid.o deg2grid.o ptt.o set.o gran.o encode232.o \
+	playsound.o 
+
+OBJS3 = wspr_rx.o inter_mept.o \
+	mix162.o xfft.o four1.o four2.o sync162.o ps162.o \
+	mept162.o nchar.o grid2deg.o unpack50.o unpackcall.o \
+	unpackgrid.o deg2grid.o getrms.o \
+	set.o encode232.o fano232.o wfile5.o \
+	xcor162.o slope.o peakup.o pctile.o db.o sort.o \
+	ssort.o decode162.o getsound.o
+
+
+all:    wspr.exe wspr_tx.exe wspr_rx.exe
+
+wspr.exe: $(OBJS1)
+	$(FC) -o wspr.exe $(FFLAGS) $(OBJS1) libportaudio.a -lwinmm
+
+wspr_tx.exe: $(OBJS2)
+	$(FC) -o wspr_tx.exe $(FFLAGS) $(OBJS2) libportaudio.a -lwinmm
+
+wspr_rx.exe: $(OBJS3)
+	$(FC) -o wspr_rx.exe $(FFLAGS) $(OBJS3) libportaudio.a -lwinmm
+
+gran.o: gran.f90
+	$(FC) -c $(FFLAGS) gran.f90
+mept_rx.o: mept_rx.f90
+	$(FC) -c $(FFLAGS) mept_rx.f90
+mept_tx.o: mept_tx.f90
+	$(FC) -c $(FFLAGS) mept_tx.f90
+wspr.o: wspr.f90
+	$(FC) -c $(FFLAGS) wspr.f90
+wspr_rx.o: wspr_rx.f90
+	$(FC) -c $(FFLAGS) wspr_rx.f90
+wspr_tx.o: wspr_tx.f90
+	$(FC) -c $(FFLAGS) wspr_tx.f90
+
+.PHONY : clean
+
+clean:
+	rm *.o wspr.exe wspr_tx.exe wspr_rx.exe
+
+
+

Added: branches/wspr/Makefile.CVF
===================================================================
--- branches/wspr/Makefile.CVF	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/Makefile.CVF	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,29 @@
+#Makefile for Windows
+!include &lt;dfinc.mak&gt;   #Some definitions for Compaq Visual Fortran
+CC = cl
+FC = df
+#FFLAGS = /traceback /fast /nologo /check:all /fpp /DCVF
+FFLAGS = /traceback /fast /nologo /fpp /DCVF
+CFLAGS = /DWin32 /I. 
+
+OBJS1 = mept_jt.obj mept_tx.obj mept_rx.obj genmept.obj inter_mept.obj \
+	mix162.obj xfft.obj four1.obj four2.obj sync162.obj ps162.obj \
+	mept162.obj wfile5.obj nchar.obj grid2deg.obj \
+	packcall.obj packgrid.obj pack50.obj unpack50.obj unpackcall.obj \
+	unpackgrid.obj deg2grid.obj gran.obj getrms.obj ptt.obj \
+	set.obj encode232.obj fano232.obj \
+	xcor162.obj slope.obj peakup.obj pctile.obj db.obj sort.obj \
+	ssort.obj decode162.obj smooth.obj playsound.obj getsound.obj
+
+all:    mept_jt.exe
+
+mept_jt.exe: $(OBJS1)
+	$(FC) $(FFLAGS) /exe:mept_jt.exe $(OBJS1) pa.lib
+
+.PHONY : clean
+
+clean:
+    -del *.obj mept_jt.exe
+
+
+

Added: branches/wspr/Makefile.MinGW
===================================================================
--- branches/wspr/Makefile.MinGW	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/Makefile.MinGW	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,61 @@
+#Makefile for Windows and MinGW
+CC = gcc
+FC = g95
+
+FFLAGS = -cpp
+CFLAGS = -I. -fbounds-check
+
+OBJS1 = wspr.o mept_tx.o mept_rx.o genmept.o inter_mept.o \
+	mix162.o xfft.o four1.o four2.o sync162.o ps162.o \
+	mept162.o wfile5.o nchar.o grid2deg.o \
+	packcall.o packgrid.o pack50.o unpack50.o unpackcall.o \
+	unpackgrid.o deg2grid.o gran.o getrms.o ptt.o \
+	set.o encode232.o fano232.o \
+	xcor162.o slope.o peakup.o pctile.o db.o sort.o \
+	ssort.o decode162.o playsound.o getsound.o
+
+OBJS2 = wspr_tx.o genmept.o inter_mept.o nchar.o grid2deg.o \
+	packcall.o packgrid.o pack50.o unpack50.o unpackcall.o \
+	unpackgrid.o deg2grid.o ptt.o set.o gran.o encode232.o \
+	playsound.o 
+
+OBJS3 = wspr_rx.o inter_mept.o \
+	mix162.o xfft.o four1.o four2.o sync162.o ps162.o \
+	mept162.o nchar.o grid2deg.o unpack50.o unpackcall.o \
+	unpackgrid.o deg2grid.o getrms.o \
+	set.o encode232.o fano232.o wfile5.o \
+	xcor162.o slope.o peakup.o pctile.o db.o sort.o \
+	ssort.o decode162.o getsound.o
+
+
+all:    wspr.exe wspr_tx.exe wspr_rx.exe
+
+wspr.exe: $(OBJS1)
+	$(FC) -o wspr.exe $(FFLAGS) $(OBJS1) libportaudio.a -lwinmm
+
+wspr_tx.exe: $(OBJS2)
+	$(FC) -o wspr_tx.exe $(FFLAGS) $(OBJS2) libportaudio.a -lwinmm
+
+wspr_rx.exe: $(OBJS3)
+	$(FC) -o wspr_rx.exe $(FFLAGS) $(OBJS3) libportaudio.a -lwinmm
+
+gran.o: gran.f90
+	$(FC) -c $(FFLAGS) gran.f90
+mept_rx.o: mept_rx.f90
+	$(FC) -c $(FFLAGS) mept_rx.f90
+mept_tx.o: mept_tx.f90
+	$(FC) -c $(FFLAGS) mept_tx.f90
+wspr.o: wspr.f90
+	$(FC) -c $(FFLAGS) wspr.f90
+wspr_rx.o: wspr_rx.f90
+	$(FC) -c $(FFLAGS) wspr_rx.f90
+wspr_tx.o: wspr_tx.f90
+	$(FC) -c $(FFLAGS) wspr_tx.f90
+
+.PHONY : clean
+
+clean:
+	rm *.o wspr.exe wspr_tx.exe wspr_rx.exe
+
+
+

Added: branches/wspr/Pmw.py
===================================================================
--- branches/wspr/Pmw.py	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/Pmw.py	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,9233 @@
+
+import PmwColor
+Color = PmwColor
+del PmwColor
+
+import PmwBlt
+Blt = PmwBlt
+del PmwBlt
+
+
+### Loader functions:
+
+_VERSION = '1.2'
+
+def setversion(version):
+    if version != _VERSION:
+        raise ValueError, 'Dynamic versioning not available'
+
+def setalphaversions(*alpha_versions):
+    if alpha_versions != ():
+	raise ValueError, 'Dynamic versioning not available'
+
+def version(alpha = 0):
+    if alpha:
+        return ()
+    else:
+        return _VERSION
+
+def installedversions(alpha = 0):
+    if alpha:
+        return ()
+    else:
+        return (_VERSION,)
+
+
+######################################################################
+### File: PmwBase.py
+# Pmw megawidget base classes.
+
+# This module provides a foundation for building megawidgets.  It
+# contains the MegaArchetype class which manages component widgets and
+# configuration options.  Also provided are the MegaToplevel and
+# MegaWidget classes, derived from the MegaArchetype class.  The
+# MegaToplevel class contains a Tkinter Toplevel widget to act as the
+# container of the megawidget.  This is used as the base class of all
+# megawidgets that are contained in their own top level window, such
+# as a Dialog window.  The MegaWidget class contains a Tkinter Frame
+# to act as the container of the megawidget.  This is used as the base
+# class of all other megawidgets, such as a ComboBox or ButtonBox.
+#
+# Megawidgets are built by creating a class that inherits from either
+# the MegaToplevel or MegaWidget class.
+
+import os
+import string
+import sys
+import traceback
+import types
+import Tkinter
+
+# Special values used in index() methods of several megawidgets.
+END = ['end']
+SELECT = ['select']
+DEFAULT = ['default']
+
+# Constant used to indicate that an option can only be set by a call
+# to the constructor.
+INITOPT = ['initopt']
+_DEFAULT_OPTION_VALUE = ['default_option_value']
+_useTkOptionDb = 0
+
+# Symbolic constants for the indexes into an optionInfo list.
+_OPT_DEFAULT         = 0
+_OPT_VALUE           = 1
+_OPT_FUNCTION        = 2
+
+# Stacks
+
+_busyStack = []
+    # Stack which tracks nested calls to show/hidebusycursor (called
+    # either directly or from activate()/deactivate()).  Each element
+    # is a dictionary containing:
+    #   'newBusyWindows' :  List of windows which had busy_hold called
+    #                       on them during a call to showbusycursor(). 
+    #                       The corresponding call to hidebusycursor()
+    #                       will call busy_release on these windows.
+    #   'busyFocus' :       The blt _Busy window which showbusycursor()
+    #                       set the focus to.
+    #   'previousFocus' :   The focus as it was when showbusycursor()
+    #                       was called.  The corresponding call to
+    #                       hidebusycursor() will restore this focus if
+    #                       the focus has not been changed from busyFocus.
+
+_grabStack = []
+    # Stack of grabbed windows.  It tracks calls to push/popgrab()
+    # (called either directly or from activate()/deactivate()).  The
+    # window on the top of the stack is the window currently with the
+    # grab.  Each element is a dictionary containing:
+    #   'grabWindow' :      The window grabbed by pushgrab().  The
+    #                       corresponding call to popgrab() will release
+    #                       the grab on this window and restore the grab
+    #                       on the next window in the stack (if there is one).
+    #   'globalMode' :      True if the grabWindow was grabbed with a
+    #                       global grab, false if the grab was local
+    #                       and 'nograb' if no grab was performed.
+    #   'previousFocus' :   The focus as it was when pushgrab()
+    #                       was called.  The corresponding call to
+    #                       popgrab() will restore this focus.
+    #   'deactivateFunction' :
+    #       The function to call (usually grabWindow.deactivate) if
+    #       popgrab() is called (usually from a deactivate() method)
+    #       on a window which is not at the top of the stack (that is,
+    #       does not have the grab or focus).  For example, if a modal
+    #       dialog is deleted by the window manager or deactivated by
+    #       a timer.  In this case, all dialogs above and including
+    #       this one are deactivated, starting at the top of the
+    #       stack.
+
+    # Note that when dealing with focus windows, the name of the Tk
+    # widget is used, since it may be the '_Busy' window, which has no
+    # python instance associated with it.
+
+#=============================================================================
+
+# Functions used to forward methods from a class to a component.
+
+# Fill in a flattened method resolution dictionary for a class (attributes are 
+# filtered out). Flattening honours the MI method resolution rules 
+# (depth-first search of bases in order). The dictionary has method names
+# for keys and functions for values.
+def __methodDict(cls, dict):
+
+    # the strategy is to traverse the class in the _reverse_ of the normal
+    # order, and overwrite any duplicates.
+    baseList = list(cls.__bases__)
+    baseList.reverse()
+    
+    # do bases in reverse order, so first base overrides last base
+    for super in baseList:
+	__methodDict(super, dict)
+
+    # do my methods last to override base classes
+    for key, value in cls.__dict__.items():
+	# ignore class attributes
+	if type(value) == types.FunctionType:
+	    dict[key] = value
+
+def __methods(cls):
+    # Return all method names for a class.
+
+    # Return all method names for a class (attributes are filtered
+    # out).  Base classes are searched recursively.
+
+    dict = {}
+    __methodDict(cls, dict)
+    return dict.keys()
+	
+# Function body to resolve a forwarding given the target method name and the 
+# attribute name. The resulting lambda requires only self, but will forward 
+# any other parameters.
+__stringBody = (
+    'def %(method)s(this, *args, **kw): return ' +
+    'apply(this.%(attribute)s.%(method)s, args, kw)')
+
+# Get a unique id
+__counter = 0
+def __unique():
+  global __counter
+  __counter = __counter + 1
+  return str(__counter)
+
+# Function body to resolve a forwarding given the target method name and the
+# index of the resolution function. The resulting lambda requires only self, 
+# but will forward any other parameters. The target instance is identified 
+# by invoking the resolution function.
+__funcBody = (
+    'def %(method)s(this, *args, **kw): return ' +
+    'apply(this.%(forwardFunc)s().%(method)s, args, kw)')
+
+def forwardmethods(fromClass, toClass, toPart, exclude = ()):
+    # Forward all methods from one class to another.
+
+    # Forwarders will be created in fromClass to forward method
+    # invocations to toClass.  The methods to be forwarded are
+    # identified by flattening the interface of toClass, and excluding
+    # methods identified in the exclude list.  Methods already defined
+    # in fromClass, or special methods with one or more leading or
+    # trailing underscores will not be forwarded.
+
+    # For a given object of class fromClass, the corresponding toClass
+    # object is identified using toPart.  This can either be a String
+    # denoting an attribute of fromClass objects, or a function taking
+    # a fromClass object and returning a toClass object.
+
+    # Example:
+    #     class MyClass:
+    #     ...
+    #         def __init__(self):
+    #             ...
+    #             self.__target = TargetClass()
+    #             ...
+    #         def findtarget(self):
+    #             return self.__target
+    #     forwardmethods(MyClass, TargetClass, '__target', ['dangerous1', 'dangerous2'])
+    #     # ...or...
+    #     forwardmethods(MyClass, TargetClass, MyClass.findtarget, 
+    #             ['dangerous1', 'dangerous2'])
+
+    # In both cases, all TargetClass methods will be forwarded from
+    # MyClass except for dangerous1, dangerous2, special methods like
+    # __str__, and pre-existing methods like findtarget.
+
+
+    # Allow an attribute name (String) or a function to determine the instance
+    if type(toPart) != types.StringType:
+
+	# check that it is something like a function
+	if callable(toPart):
+
+	    # If a method is passed, use the function within it
+	    if hasattr(toPart, 'im_func'):
+		toPart = toPart.im_func
+		
+	    # After this is set up, forwarders in this class will use
+	    # the forwarding function. The forwarding function name is
+	    # guaranteed to be unique, so that it can't be hidden by subclasses
+	    forwardName = '__fwdfunc__' + __unique()
+	    fromClass.__dict__[forwardName] = toPart
+
+	# It's not a valid type
+	else:
+	    raise TypeError, 'toPart must be attribute name, function or method'
+
+    # get the full set of candidate methods
+    dict = {}
+    __methodDict(toClass, dict)
+
+    # discard special methods
+    for ex in dict.keys():
+	if ex[:1] == '_' or ex[-1:] == '_':
+	    del dict[ex]
+    # discard dangerous methods supplied by the caller
+    for ex in exclude:
+	if dict.has_key(ex):
+	    del dict[ex]
+    # discard methods already defined in fromClass
+    for ex in __methods(fromClass):
+	if dict.has_key(ex):
+	    del dict[ex]
+
+    for method, func in dict.items():
+	d = {'method': method, 'func': func}
+	if type(toPart) == types.StringType:
+	    execString = \
+		__stringBody % {'method' : method, 'attribute' : toPart}
+	else:
+	    execString = \
+		__funcBody % {'forwardFunc' : forwardName, 'method' : method}
+
+	exec execString in d
+
+	# this creates a method
+	fromClass.__dict__[method] = d[method]
+
+#=============================================================================
+
+def setgeometryanddeiconify(window, geom):
+    # To avoid flashes on X and to position the window correctly on NT
+    # (caused by Tk bugs).
+
+    if os.name == 'nt' or \
+            (os.name == 'posix' and sys.platform[:6] == 'cygwin'):
+        # Require overrideredirect trick to stop window frame
+        # appearing momentarily.
+        redirect = window.overrideredirect()
+        if not redirect:
+            window.overrideredirect(1)
+        window.deiconify()
+        if geom is not None:
+            window.geometry(geom)
+        # Call update_idletasks to ensure NT moves the window to the
+        # correct position it is raised.
+        window.update_idletasks()
+        window.tkraise()
+        if not redirect:
+            window.overrideredirect(0)
+    else:
+        if geom is not None:
+            window.geometry(geom)
+
+        # Problem!?  Which way around should the following two calls
+        # go?  If deiconify() is called first then I get complaints
+        # from people using the enlightenment or sawfish window
+        # managers that when a dialog is activated it takes about 2
+        # seconds for the contents of the window to appear.  But if
+        # tkraise() is called first then I get complaints from people
+        # using the twm window manager that when a dialog is activated
+        # it appears in the top right corner of the screen and also
+        # takes about 2 seconds to appear.
+
+        #window.tkraise()
+        # Call update_idletasks to ensure certain window managers (eg: 
+        # enlightenment and sawfish) do not cause Tk to delay for
+        # about two seconds before displaying window.
+        #window.update_idletasks()
+        #window.deiconify()
+
+        window.deiconify()
+        if window.overrideredirect():
+            # The window is not under the control of the window manager
+            # and so we need to raise it ourselves.
+            window.tkraise()
+
+#=============================================================================
+
+class MegaArchetype:
+    # Megawidget abstract root class.
+
+    # This class provides methods which are inherited by classes
+    # implementing useful bases (this class doesn't provide a
+    # container widget inside which the megawidget can be built).
+
+    def __init__(self, parent = None, hullClass = None):
+
+	# Mapping from each megawidget option to a list of information
+	# about the option
+	#   - default value
+	#   - current value
+	#   - function to call when the option is initialised in the
+	#     call to initialiseoptions() in the constructor or
+	#     modified via configure().  If this is INITOPT, the
+	#     option is an initialisation option (an option that can
+	#     be set by the call to the constructor but can not be
+	#     used with configure).
+	# This mapping is not initialised here, but in the call to
+	# defineoptions() which precedes construction of this base class.
+	#
+	# self._optionInfo = {}
+
+	# Mapping from each component name to a tuple of information
+	# about the component.
+	#   - component widget instance
+	#   - configure function of widget instance
+	#   - the class of the widget (Frame, EntryField, etc)
+	#   - cget function of widget instance
+	#   - the name of the component group of this component, if any
+	self.__componentInfo = {}
+
+	# Mapping from alias names to the names of components or
+	# sub-components.
+	self.__componentAliases = {}
+
+	# Contains information about the keywords provided to the
+	# constructor.  It is a mapping from the keyword to a tuple
+	# containing:
+	#    - value of keyword
+	#    - a boolean indicating if the keyword has been used.
+	# A keyword is used if, during the construction of a megawidget,
+	#    - it is defined in a call to defineoptions() or addoptions(), or
+	#    - it references, by name, a component of the megawidget, or
+	#    - it references, by group, at least one component
+	# At the end of megawidget construction, a call is made to
+	# initialiseoptions() which reports an error if there are
+	# unused options given to the constructor.
+        #
+        # After megawidget construction, the dictionary contains
+        # keywords which refer to a dynamic component group, so that
+        # these components can be created after megawidget
+        # construction and still use the group options given to the
+        # constructor.
+	#
+	# self._constructorKeywords = {}
+
+        # List of dynamic component groups.  If a group is included in
+        # this list, then it not an error if a keyword argument for
+        # the group is given to the constructor or to configure(), but
+        # no components with this group have been created.
+        # self._dynamicGroups = ()
+
+	if hullClass is None:
+	    self._hull = None
+	else:
+	    if parent is None:
+		parent = Tkinter._default_root
+
+	    # Create the hull.
+	    self._hull = self.createcomponent('hull',
+		    (), None,
+		    hullClass, (parent,))
+	    _hullToMegaWidget[self._hull] = self
+
+	    if _useTkOptionDb:
+		# Now that a widget has been created, query the Tk
+		# option database to get the default values for the
+		# options which have not been set in the call to the
+		# constructor.  This assumes that defineoptions() is
+		# called before the __init__().
+		option_get = self.option_get
+		_VALUE = _OPT_VALUE
+		_DEFAULT = _OPT_DEFAULT
+		for name, info in self._optionInfo.items():
+		    value = info[_VALUE]
+		    if value is _DEFAULT_OPTION_VALUE:
+			resourceClass = string.upper(name[0]) + name[1:]
+			value = option_get(name, resourceClass)
+			if value != '':
+			    try:
+				# Convert the string to int/float/tuple, etc
+				value = eval(value, {'__builtins__': {}})
+			    except:
+				pass
+			    info[_VALUE] = value
+			else:
+			    info[_VALUE] = info[_DEFAULT]
+
+    def destroy(self):
+        # Clean up optionInfo in case it contains circular references
+        # in the function field, such as self._settitle in class
+        # MegaToplevel.
+
+	self._optionInfo = {}
+        if self._hull is not None:
+            del _hullToMegaWidget[self._hull]
+            self._hull.destroy()
+
+    #======================================================================
+    # Methods used (mainly) during the construction of the megawidget.
+
+    def defineoptions(self, keywords, optionDefs, dynamicGroups = ()):
+	# Create options, providing the default value and the method
+	# to call when the value is changed.  If any option created by
+	# base classes has the same name as one in &lt;optionDefs&gt;, the
+	# base class's value and function will be overriden.
+
+	# This should be called before the constructor of the base
+	# class, so that default values defined in the derived class
+	# override those in the base class.
+
+	if not hasattr(self, '_constructorKeywords'):
+            # First time defineoptions has been called.
+	    tmp = {}
+	    for option, value in keywords.items():
+		tmp[option] = [value, 0]
+	    self._constructorKeywords = tmp
+	    self._optionInfo = {}
+	    self._initialiseoptions_counter = 0
+        self._initialiseoptions_counter = self._initialiseoptions_counter + 1
+
+        if not hasattr(self, '_dynamicGroups'):
+            self._dynamicGroups = ()
+        self._dynamicGroups = self._dynamicGroups + tuple(dynamicGroups)
+	self.addoptions(optionDefs)
+
+    def addoptions(self, optionDefs):
+	# Add additional options, providing the default value and the
+	# method to call when the value is changed.  See
+	# &quot;defineoptions&quot; for more details
+
+	# optimisations:
+	optionInfo = self._optionInfo
+	optionInfo_has_key = optionInfo.has_key
+	keywords = self._constructorKeywords
+	keywords_has_key = keywords.has_key
+	FUNCTION = _OPT_FUNCTION
+
+	for name, default, function in optionDefs:
+	    if '_' not in name:
+		# The option will already exist if it has been defined
+		# in a derived class.  In this case, do not override the
+		# default value of the option or the callback function
+		# if it is not None.
+		if not optionInfo_has_key(name):
+		    if keywords_has_key(name):
+			value = keywords[name][0]
+			optionInfo[name] = [default, value, function]
+			del keywords[name]
+		    else:
+			if _useTkOptionDb:
+			    optionInfo[name] = \
+				    [default, _DEFAULT_OPTION_VALUE, function]
+			else:
+			    optionInfo[name] = [default, default, function]
+		elif optionInfo[name][FUNCTION] is None:
+		    optionInfo[name][FUNCTION] = function
+	    else:
+		# This option is of the form &quot;component_option&quot;.  If this is
+		# not already defined in self._constructorKeywords add it.
+		# This allows a derived class to override the default value
+		# of an option of a component of a base class.
+		if not keywords_has_key(name):
+		    keywords[name] = [default, 0]
+
+    def createcomponent(self, componentName, componentAliases,
+            componentGroup, widgetClass, *widgetArgs, **kw):
+	# Create a component (during construction or later).
+
+	if self.__componentInfo.has_key(componentName):
+	    raise ValueError, 'Component &quot;%s&quot; already exists' % componentName
+
+	if '_' in componentName:
+	    raise ValueError, \
+                    'Component name &quot;%s&quot; must not contain &quot;_&quot;' % componentName
+
+	if hasattr(self, '_constructorKeywords'):
+	    keywords = self._constructorKeywords
+	else:
+	    keywords = {}
+	for alias, component in componentAliases:
+	    # Create aliases to the component and its sub-components.
+	    index = string.find(component, '_')
+	    if index &lt; 0:
+		self.__componentAliases[alias] = (component, None)
+	    else:
+		mainComponent = component[:index]
+		subComponent = component[(index + 1):]
+		self.__componentAliases[alias] = (mainComponent, subComponent)
+
+	    # Remove aliases from the constructor keyword arguments by
+	    # replacing any keyword arguments that begin with *alias*
+	    # with corresponding keys beginning with *component*.
+
+	    alias = alias + '_'
+	    aliasLen = len(alias)
+	    for option in keywords.keys():
+		if len(option) &gt; aliasLen and option[:aliasLen] == alias:
+		    newkey = component + '_' + option[aliasLen:]
+		    keywords[newkey] = keywords[option]
+		    del keywords[option]
+
+	componentPrefix = componentName + '_'
+	nameLen = len(componentPrefix)
+	for option in keywords.keys():
+	    if len(option) &gt; nameLen and option[:nameLen] == componentPrefix:
+		# The keyword argument refers to this component, so add
+		# this to the options to use when constructing the widget.
+		kw[option[nameLen:]] = keywords[option][0]
+		del keywords[option]
+	    else:
+		# Check if this keyword argument refers to the group
+		# of this component.  If so, add this to the options
+		# to use when constructing the widget.  Mark the
+		# keyword argument as being used, but do not remove it
+		# since it may be required when creating another
+		# component.
+		index = string.find(option, '_')
+		if index &gt;= 0 and componentGroup == option[:index]:
+		    rest = option[(index + 1):]
+		    kw[rest] = keywords[option][0]
+		    keywords[option][1] = 1
+
+	if kw.has_key('pyclass'):
+	    widgetClass = kw['pyclass']
+	    del kw['pyclass']
+	if widgetClass is None:
+	    return None
+        if len(widgetArgs) == 1 and type(widgetArgs[0]) == types.TupleType:
+            # Arguments to the constructor can be specified as either
+            # multiple trailing arguments to createcomponent() or as a
+            # single tuple argument.
+            widgetArgs = widgetArgs[0]
+	widget = apply(widgetClass, widgetArgs, kw)
+	componentClass = widget.__class__.__name__
+	self.__componentInfo[componentName] = (widget, widget.configure,
+		componentClass, widget.cget, componentGroup)
+
+	return widget
+
+    def destroycomponent(self, name):
+	# Remove a megawidget component.
+
+	# This command is for use by megawidget designers to destroy a
+	# megawidget component.
+
+	self.__componentInfo[name][0].destroy()
+	del self.__componentInfo[name]
+
+    def createlabel(self, parent, childCols = 1, childRows = 1):
+
+	labelpos = self['labelpos']
+	labelmargin = self['labelmargin']
+	if labelpos is None:
+	    return
+
+	label = self.createcomponent('label',
+		(), None,
+		Tkinter.Label, (parent,))
+
+	if labelpos[0] in 'ns':
+	    # vertical layout
+	    if labelpos[0] == 'n':
+		row = 0
+		margin = 1
+	    else:
+		row = childRows + 3
+		margin = row - 1
+	    label.grid(column=2, row=row, columnspan=childCols, sticky=labelpos)
+	    parent.grid_rowconfigure(margin, minsize=labelmargin)
+	else:
+	    # horizontal layout
+	    if labelpos[0] == 'w':
+		col = 0
+		margin = 1
+	    else:
+		col = childCols + 3
+		margin = col - 1
+	    label.grid(column=col, row=2, rowspan=childRows, sticky=labelpos)
+	    parent.grid_columnconfigure(margin, minsize=labelmargin)
+
+    def initialiseoptions(self, dummy = None):
+        self._initialiseoptions_counter = self._initialiseoptions_counter - 1
+	if self._initialiseoptions_counter == 0:
+	    unusedOptions = []
+	    keywords = self._constructorKeywords
+	    for name in keywords.keys():
+		used = keywords[name][1]
+		if not used:
+                    # This keyword argument has not been used.  If it
+                    # does not refer to a dynamic group, mark it as
+                    # unused.
+                    index = string.find(name, '_')
+                    if index &lt; 0 or name[:index] not in self._dynamicGroups:
+                        unusedOptions.append(name)
+	    if len(unusedOptions) &gt; 0:
+		if len(unusedOptions) == 1:
+		    text = 'Unknown option &quot;'
+		else:
+		    text = 'Unknown options &quot;'
+		raise KeyError, text + string.join(unusedOptions, ', ') + \
+			'&quot; for ' + self.__class__.__name__
+
+	    # Call the configuration callback function for every option.
+	    FUNCTION = _OPT_FUNCTION
+	    for info in self._optionInfo.values():
+		func = info[FUNCTION]
+		if func is not None and func is not INITOPT:
+		    func()
+
+    #======================================================================
+    # Method used to configure the megawidget.
+
+    def configure(self, option=None, **kw):
+	# Query or configure the megawidget options.
+	#
+	# If not empty, *kw* is a dictionary giving new
+	# values for some of the options of this megawidget or its
+	# components.  For options defined for this megawidget, set
+	# the value of the option to the new value and call the
+	# configuration callback function, if any.  For options of the
+	# form &lt;component&gt;_&lt;option&gt;, where &lt;component&gt; is a component
+	# of this megawidget, call the configure method of the
+	# component giving it the new value of the option.  The
+	# &lt;component&gt; part may be an alias or a component group name.
+	#
+	# If *option* is None, return all megawidget configuration
+	# options and settings.  Options are returned as standard 5
+	# element tuples
+	#
+	# If *option* is a string, return the 5 element tuple for the
+	# given configuration option.
+
+	# First, deal with the option queries.
+	if len(kw) == 0:
+	    # This configure call is querying the values of one or all options.
+	    # Return 5-tuples:
+	    #     (optionName, resourceName, resourceClass, default, value)
+	    if option is None:
+		rtn = {}
+		for option, config in self._optionInfo.items():
+		    resourceClass = string.upper(option[0]) + option[1:]
+		    rtn[option] = (option, option, resourceClass,
+			    config[_OPT_DEFAULT], config[_OPT_VALUE])
+		return rtn
+	    else:
+		config = self._optionInfo[option]
+		resourceClass = string.upper(option[0]) + option[1:]
+		return (option, option, resourceClass, config[_OPT_DEFAULT],
+			config[_OPT_VALUE])
+
+	# optimisations:
+	optionInfo = self._optionInfo
+	optionInfo_has_key = optionInfo.has_key
+	componentInfo = self.__componentInfo
+	componentInfo_has_key = componentInfo.has_key
+	componentAliases = self.__componentAliases
+	componentAliases_has_key = componentAliases.has_key
+	VALUE = _OPT_VALUE
+	FUNCTION = _OPT_FUNCTION
+
+	# This will contain a list of options in *kw* which
+	# are known to this megawidget.
+	directOptions = []
+
+	# This will contain information about the options in
+	# *kw* of the form &lt;component&gt;_&lt;option&gt;, where
+	# &lt;component&gt; is a component of this megawidget.  It is a
+	# dictionary whose keys are the configure method of each
+	# component and whose values are a dictionary of options and
+	# values for the component.
+	indirectOptions = {}
+	indirectOptions_has_key = indirectOptions.has_key
+
+	for option, value in kw.items():
+	    if optionInfo_has_key(option):
+		# This is one of the options of this megawidget. 
+		# Make sure it is not an initialisation option.
+		if optionInfo[option][FUNCTION] is INITOPT:
+		    raise KeyError, \
+			    'Cannot configure initialisation option &quot;' \
+			    + option + '&quot; for ' + self.__class__.__name__
+		optionInfo[option][VALUE] = value
+		directOptions.append(option)
+	    else:
+		index = string.find(option, '_')
+		if index &gt;= 0:
+		    # This option may be of the form &lt;component&gt;_&lt;option&gt;.
+		    component = option[:index]
+		    componentOption = option[(index + 1):]
+
+		    # Expand component alias
+		    if componentAliases_has_key(component):
+			component, subComponent = componentAliases[component]
+			if subComponent is not None:
+			    componentOption = subComponent + '_' \
+				    + componentOption
+
+			# Expand option string to write on error
+			option = component + '_' + componentOption
+
+		    if componentInfo_has_key(component):
+			# Configure the named component
+			componentConfigFuncs = [componentInfo[component][1]]
+		    else:
+			# Check if this is a group name and configure all
+			# components in the group.
+			componentConfigFuncs = []
+			for info in componentInfo.values():
+			    if info[4] == component:
+			        componentConfigFuncs.append(info[1])
+
+                        if len(componentConfigFuncs) == 0 and \
+                                component not in self._dynamicGroups:
+			    raise KeyError, 'Unknown option &quot;' + option + \
+				    '&quot; for ' + self.__class__.__name__
+
+		    # Add the configure method(s) (may be more than
+		    # one if this is configuring a component group)
+		    # and option/value to dictionary.
+		    for componentConfigFunc in componentConfigFuncs:
+			if not indirectOptions_has_key(componentConfigFunc):
+			    indirectOptions[componentConfigFunc] = {}
+			indirectOptions[componentConfigFunc][componentOption] \
+				= value
+		else:
+		    raise KeyError, 'Unknown option &quot;' + option + \
+			    '&quot; for ' + self.__class__.__name__
+
+	# Call the configure methods for any components.
+	map(apply, indirectOptions.keys(),
+		((),) * len(indirectOptions), indirectOptions.values())
+
+	# Call the configuration callback function for each option.
+	for option in directOptions:
+	    info = optionInfo[option]
+	    func = info[_OPT_FUNCTION]
+	    if func is not None:
+	      func()
+
+    def __setitem__(self, key, value):
+        apply(self.configure, (), {key: value})
+
+    #======================================================================
+    # Methods used to query the megawidget.
+
+    def component(self, name):
+	# Return a component widget of the megawidget given the
+	# component's name
+	# This allows the user of a megawidget to access and configure
+	# widget components directly.
+
+	# Find the main component and any subcomponents
+	index = string.find(name, '_')
+	if index &lt; 0:
+	    component = name
+	    remainingComponents = None
+	else:
+	    component = name[:index]
+	    remainingComponents = name[(index + 1):]
+
+	# Expand component alias
+	if self.__componentAliases.has_key(component):
+	    component, subComponent = self.__componentAliases[component]
+	    if subComponent is not None:
+		if remainingComponents is None:
+		    remainingComponents = subComponent
+		else:
+		    remainingComponents = subComponent + '_' \
+			    + remainingComponents
+
+	widget = self.__componentInfo[component][0]
+	if remainingComponents is None:
+	    return widget
+	else:
+	    return widget.component(remainingComponents)
+
+    def interior(self):
+	return self._hull
+
+    def hulldestroyed(self):
+	return not _hullToMegaWidget.has_key(self._hull)
+
+    def __str__(self):
+	return str(self._hull)
+
+    def cget(self, option):
+	# Get current configuration setting.
+
+	# Return the value of an option, for example myWidget['font']. 
+
+	if self._optionInfo.has_key(option):
+	    return self._optionInfo[option][_OPT_VALUE]
+	else:
+	    index = string.find(option, '_')
+	    if index &gt;= 0:
+		component = option[:index]
+		componentOption = option[(index + 1):]
+
+		# Expand component alias
+		if self.__componentAliases.has_key(component):
+		    component, subComponent = self.__componentAliases[component]
+		    if subComponent is not None:
+			componentOption = subComponent + '_' + componentOption
+
+		    # Expand option string to write on error
+		    option = component + '_' + componentOption
+
+		if self.__componentInfo.has_key(component):
+		    # Call cget on the component.
+		    componentCget = self.__componentInfo[component][3]
+		    return componentCget(componentOption)
+		else:
+		    # If this is a group name, call cget for one of
+		    # the components in the group.
+		    for info in self.__componentInfo.values():
+			if info[4] == component:
+			    componentCget = info[3]
+			    return componentCget(componentOption)
+
+	raise KeyError, 'Unknown option &quot;' + option + \
+		'&quot; for ' + self.__class__.__name__
+
+    __getitem__ = cget
+
+    def isinitoption(self, option):
+	return self._optionInfo[option][_OPT_FUNCTION] is INITOPT
+
+    def options(self):
+	options = []
+	if hasattr(self, '_optionInfo'):
+	    for option, info in self._optionInfo.items():
+		isinit = info[_OPT_FUNCTION] is INITOPT
+		default = info[_OPT_DEFAULT]
+		options.append((option, default, isinit))
+	    options.sort()
+	return options
+
+    def components(self):
+	# Return a list of all components.
+
+	# This list includes the 'hull' component and all widget subcomponents
+
+	names = self.__componentInfo.keys()
+	names.sort()
+	return names
+
+    def componentaliases(self):
+	# Return a list of all component aliases.
+
+	componentAliases = self.__componentAliases
+
+	names = componentAliases.keys()
+	names.sort()
+	rtn = []
+	for alias in names:
+	    (mainComponent, subComponent) = componentAliases[alias]
+	    if subComponent is None:
+		rtn.append((alias, mainComponent))
+	    else:
+		rtn.append((alias, mainComponent + '_' + subComponent))
+	    
+	return rtn
+
+    def componentgroup(self, name):
+	return self.__componentInfo[name][4]
+
+#=============================================================================
+
+# The grab functions are mainly called by the activate() and
+# deactivate() methods.
+#
+# Use pushgrab() to add a new window to the grab stack.  This
+# releases the grab by the window currently on top of the stack (if
+# there is one) and gives the grab and focus to the new widget.
+#
+# To remove the grab from the window on top of the grab stack, call
+# popgrab().
+#
+# Use releasegrabs() to release the grab and clear the grab stack.
+
+def pushgrab(grabWindow, globalMode, deactivateFunction):
+    prevFocus = grabWindow.tk.call('focus')
+    grabInfo = {
+        'grabWindow' : grabWindow,
+        'globalMode' : globalMode,
+        'previousFocus' : prevFocus,
+        'deactivateFunction' : deactivateFunction,
+    }
+    _grabStack.append(grabInfo)
+    _grabtop()
+    grabWindow.focus_set()
+
+def popgrab(window):
+    # Return the grab to the next window in the grab stack, if any.
+
+    # If this window is not at the top of the grab stack, then it has
+    # just been deleted by the window manager or deactivated by a
+    # timer.  Call the deactivate method for the modal dialog above
+    # this one on the stack. 
+    if _grabStack[-1]['grabWindow'] != window:
+        for index in range(len(_grabStack)):
+            if _grabStack[index]['grabWindow'] == window:
+                _grabStack[index + 1]['deactivateFunction']()
+                break
+
+    grabInfo = _grabStack[-1]
+    del _grabStack[-1]
+
+    topWidget = grabInfo['grabWindow']
+    prevFocus = grabInfo['previousFocus']
+    globalMode = grabInfo['globalMode']
+
+    if globalMode != 'nograb':
+        topWidget.grab_release()
+
+    if len(_grabStack) &gt; 0:
+        _grabtop()
+    if prevFocus != '':
+        try:
+            topWidget.tk.call('focus', prevFocus)
+        except Tkinter.TclError:
+            # Previous focus widget has been deleted. Set focus
+            # to root window.
+            Tkinter._default_root.focus_set()
+    else:
+        # Make sure that focus does not remain on the released widget.
+        if len(_grabStack) &gt; 0:
+            topWidget = _grabStack[-1]['grabWindow']
+            topWidget.focus_set()
+        else:
+            Tkinter._default_root.focus_set()
+
+def grabstacktopwindow():
+    if len(_grabStack) == 0:
+        return None
+    else:
+        return _grabStack[-1]['grabWindow']
+
+def releasegrabs():
+    # Release grab and clear the grab stack.
+
+    current = Tkinter._default_root.grab_current()
+    if current is not None:
+        current.grab_release()
+    _grabStack[:] = []
+
+def _grabtop():
+    grabInfo = _grabStack[-1]
+    topWidget = grabInfo['grabWindow']
+    globalMode = grabInfo['globalMode']
+
+    if globalMode == 'nograb':
+        return
+
+    while 1:
+        try:
+            if globalMode:
+                topWidget.grab_set_global()
+            else:
+                topWidget.grab_set()
+            break
+        except Tkinter.TclError:
+            # Another application has grab.  Keep trying until
+            # grab can succeed.
+            topWidget.after(100)
+
+#=============================================================================
+
+class MegaToplevel(MegaArchetype):
+
+    def __init__(self, parent = None, **kw):
+	# Define the options for this megawidget.
+	optiondefs = (
+            ('activatecommand',   None,                     None),
+            ('deactivatecommand', None,                     None),
+            ('master',            None,                     None),
+            ('title',             None,                     self._settitle),
+            ('hull_class',        self.__class__.__name__,  None),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaArchetype.__init__(self, parent, Tkinter.Toplevel)
+
+	# Initialise instance.
+
+        # Set WM_DELETE_WINDOW protocol, deleting any old callback, so
+        # memory does not leak.
+        if hasattr(self._hull, '_Pmw_WM_DELETE_name'):
+            self._hull.tk.deletecommand(self._hull._Pmw_WM_DELETE_name)
+        self._hull._Pmw_WM_DELETE_name = \
+                self.register(self._userDeleteWindow, needcleanup = 0)
+	self.protocol('WM_DELETE_WINDOW', self._hull._Pmw_WM_DELETE_name)
+
+	# Initialise instance variables.
+
+	self._firstShowing = 1
+	# Used by show() to ensure window retains previous position on screen.
+
+	# The IntVar() variable to wait on during a modal dialog.
+	self._wait = None
+
+	self._active = 0
+	self._userDeleteFunc = self.destroy
+	self._userModalDeleteFunc = self.deactivate
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def _settitle(self):
+	title = self['title']
+	if title is not None:
+	    self.title(title)
+
+    def userdeletefunc(self, func=None):
+        if func:
+	    self._userDeleteFunc = func
+	else:
+	    return self._userDeleteFunc
+
+    def usermodaldeletefunc(self, func=None):
+        if func:
+	    self._userModalDeleteFunc = func
+	else:
+	    return self._userModalDeleteFunc
+
+    def _userDeleteWindow(self):
+	if self.active():
+	    self._userModalDeleteFunc()
+	else:
+	    self._userDeleteFunc()
+
+    def destroy(self):
+	# Allow this to be called more than once.
+	if _hullToMegaWidget.has_key(self._hull):
+	    self.deactivate()
+
+            # Remove circular references, so that object can get cleaned up.
+            del self._userDeleteFunc
+            del self._userModalDeleteFunc
+
+            MegaArchetype.destroy(self)
+
+    def show(self, master = None):
+	if self.state() != 'normal':
+	    if self._firstShowing:
+		# Just let the window manager determine the window
+		# position for the first time.
+		geom = None
+	    else:
+		# Position the window at the same place it was last time.
+		geom = self._sameposition()
+            setgeometryanddeiconify(self, geom)
+
+        if self._firstShowing:
+            self._firstShowing = 0
+        else:
+            if self.transient() == '':
+                self.tkraise()
+
+        # Do this last, otherwise get flashing on NT:
+        if master is not None:
+            if master == 'parent':
+                parent = self.winfo_parent()
+                # winfo_parent() should return the parent widget, but the
+                # the current version of Tkinter returns a string.
+                if type(parent) == types.StringType:
+                    parent = self._hull._nametowidget(parent)
+                master = parent.winfo_toplevel()
+            self.transient(master)
+
+        self.focus()
+
+    def _centreonscreen(self):
+	# Centre the window on the screen.  (Actually halfway across
+	# and one third down.)
+
+        parent = self.winfo_parent()
+        if type(parent) == types.StringType:
+            parent = self._hull._nametowidget(parent)
+
+        # Find size of window.
+	self.update_idletasks()
+        width = self.winfo_width()
+        height = self.winfo_height()
+        if width == 1 and height == 1:
+            # If the window has not yet been displayed, its size is
+            # reported as 1x1, so use requested size.
+            width = self.winfo_reqwidth()
+            height = self.winfo_reqheight()
+
+        # Place in centre of screen:
+	x = (self.winfo_screenwidth() - width) / 2 - parent.winfo_vrootx()
+	y = (self.winfo_screenheight() - height) / 3 - parent.winfo_vrooty()
+	if x &lt; 0:
+	    x = 0
+	if y &lt; 0:
+	    y = 0
+        return '+%d+%d' % (x, y)
+
+    def _sameposition(self):
+	# Position the window at the same place it was last time.
+
+	geometry = self.geometry()
+	index = string.find(geometry, '+')
+	if index &gt;= 0:
+	    return geometry[index:]
+        else:
+	    return None
+
+    def activate(self, globalMode = 0, geometry = 'centerscreenfirst'):
+	if self._active:
+	    raise ValueError, 'Window is already active'
+	if self.state() == 'normal':
+	    self.withdraw()
+
+	self._active = 1
+
+	showbusycursor()
+
+	if self._wait is None:
+	    self._wait = Tkinter.IntVar()
+	self._wait.set(0)
+
+	if geometry == 'centerscreenalways':
+	    geom = self._centreonscreen()
+	elif geometry == 'centerscreenfirst':
+	    if self._firstShowing:
+		# Centre the window the first time it is displayed.
+		geom = self._centreonscreen()
+	    else:
+		# Position the window at the same place it was last time.
+		geom = self._sameposition()
+	elif geometry[:5] == 'first':
+	    if self._firstShowing:
+                geom = geometry[5:]
+	    else:
+		# Position the window at the same place it was last time.
+		geom = self._sameposition()
+        else:
+            geom = geometry
+
+	self._firstShowing = 0
+
+        setgeometryanddeiconify(self, geom)
+
+        # Do this last, otherwise get flashing on NT:
+        master = self['master']
+        if master is not None:
+            if master == 'parent':
+                parent = self.winfo_parent()
+                # winfo_parent() should return the parent widget, but the
+                # the current version of Tkinter returns a string.
+                if type(parent) == types.StringType:
+                    parent = self._hull._nametowidget(parent)
+                master = parent.winfo_toplevel()
+            self.transient(master)
+
+        pushgrab(self._hull, globalMode, self.deactivate)
+	command = self['activatecommand']
+	if callable(command):
+	    command()
+	self.wait_variable(self._wait)
+
+	return self._result
+
+    def deactivate(self, result=None):
+	if not self._active:
+	    return
+	self._active = 0
+
+        # Restore the focus before withdrawing the window, since
+        # otherwise the window manager may take the focus away so we
+        # can't redirect it.  Also, return the grab to the next active
+        # window in the stack, if any.
+        popgrab(self._hull)
+
+        command = self['deactivatecommand']
+        if callable(command):
+            command()
+
+        self.withdraw()
+        hidebusycursor(forceFocusRestore = 1)
+
+        self._result = result
+        self._wait.set(1)
+
+    def active(self):
+	return self._active
+
+forwardmethods(MegaToplevel, Tkinter.Toplevel, '_hull')
+
+#=============================================================================
+
+class MegaWidget(MegaArchetype):
+    def __init__(self, parent = None, **kw):
+	# Define the options for this megawidget.
+	optiondefs = (
+	    ('hull_class',       self.__class__.__name__,  None),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaArchetype.__init__(self, parent, Tkinter.Frame)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+forwardmethods(MegaWidget, Tkinter.Frame, '_hull')
+
+#=============================================================================
+
+# Public functions
+#-----------------
+
+_traceTk = 0
+def tracetk(root = None, on = 1, withStackTrace = 0, file=None):
+    global _withStackTrace
+    global _traceTkFile
+    global _traceTk
+
+    if root is None:
+        root = Tkinter._default_root
+
+    _withStackTrace = withStackTrace
+    _traceTk = on
+    if on:
+	if hasattr(root.tk, '__class__'):
+	    # Tracing already on
+	    return
+	if file is None:
+	    _traceTkFile = sys.stderr
+	else:
+	    _traceTkFile = file
+	tk = _TraceTk(root.tk)
+    else:
+	if not hasattr(root.tk, '__class__'):
+	    # Tracing already off
+	    return
+	tk = root.tk.getTclInterp()
+    _setTkInterps(root, tk)
+
+def showbusycursor():
+
+    _addRootToToplevelBusyInfo()
+    root = Tkinter._default_root
+
+    busyInfo = {
+        'newBusyWindows' : [],
+        'previousFocus' : None,
+        'busyFocus' : None,
+    }
+    _busyStack.append(busyInfo)
+
+    if _disableKeyboardWhileBusy:
+        # Remember the focus as it is now, before it is changed.
+        busyInfo['previousFocus'] = root.tk.call('focus')
+
+    if not _havebltbusy(root):
+        # No busy command, so don't call busy hold on any windows.
+        return
+
+    for (window, winInfo) in _toplevelBusyInfo.items():
+	if (window.state() != 'withdrawn' and not winInfo['isBusy']
+                and not winInfo['excludeFromBusy']):
+            busyInfo['newBusyWindows'].append(window)
+            winInfo['isBusy'] = 1
+            _busy_hold(window, winInfo['busyCursorName'])
+
+            # Make sure that no events for the busy window get
+            # through to Tkinter, otherwise it will crash in
+            # _nametowidget with a 'KeyError: _Busy' if there is
+            # a binding on the toplevel window.
+            window.tk.call('bindtags', winInfo['busyWindow'], 'Pmw_Dummy_Tag')
+
+            if _disableKeyboardWhileBusy:
+                # Remember previous focus widget for this toplevel window
+                # and set focus to the busy window, which will ignore all
+                # keyboard events.
+                winInfo['windowFocus'] = \
+                        window.tk.call('focus', '-lastfor', window._w)
+                window.tk.call('focus', winInfo['busyWindow'])
+                busyInfo['busyFocus'] = winInfo['busyWindow']
+
+    if len(busyInfo['newBusyWindows']) &gt; 0:
+        if os.name == 'nt':
+            # NT needs an &quot;update&quot; before it will change the cursor.
+            window.update()
+        else:
+            window.update_idletasks()
+
+def hidebusycursor(forceFocusRestore = 0):
+
+    # Remember the focus as it is now, before it is changed.
+    root = Tkinter._default_root
+    if _disableKeyboardWhileBusy:
+        currentFocus = root.tk.call('focus')
+
+    # Pop the busy info off the stack.
+    busyInfo = _busyStack[-1]
+    del _busyStack[-1]
+
+    for window in busyInfo['newBusyWindows']:
+        # If this window has not been deleted, release the busy cursor.
+        if _toplevelBusyInfo.has_key(window):
+            winInfo = _toplevelBusyInfo[window]
+            winInfo['isBusy'] = 0
+            _busy_release(window)
+
+            if _disableKeyboardWhileBusy:
+                # Restore previous focus window for this toplevel window,
+                # but only if is still set to the busy window (it may have
+                # been changed).
+                windowFocusNow = window.tk.call('focus', '-lastfor', window._w)
+                if windowFocusNow == winInfo['busyWindow']:
+                    try:
+                        window.tk.call('focus', winInfo['windowFocus'])
+                    except Tkinter.TclError:
+                        # Previous focus widget has been deleted. Set focus
+                        # to toplevel window instead (can't leave focus on
+                        # busy window).
+                        window.focus_set()
+
+    if _disableKeyboardWhileBusy:
+        # Restore the focus, depending on whether the focus had changed
+        # between the calls to showbusycursor and hidebusycursor.
+        if forceFocusRestore or busyInfo['busyFocus'] == currentFocus:
+            # The focus had not changed, so restore it to as it was before
+            # the call to showbusycursor,
+            previousFocus = busyInfo['previousFocus']
+            if previousFocus is not None:
+                try:
+                    root.tk.call('focus', previousFocus)
+                except Tkinter.TclError:
+                    # Previous focus widget has been deleted; forget it.
+                    pass
+        else:
+            # The focus had changed, so restore it to what it had been
+            # changed to before the call to hidebusycursor.
+            root.tk.call('focus', currentFocus)
+
+def clearbusycursor():
+    while len(_busyStack) &gt; 0:
+        hidebusycursor()
+
+def setbusycursorattributes(window, **kw):
+    _addRootToToplevelBusyInfo()
+    for name, value in kw.items():
+        if name == 'exclude':
+            _toplevelBusyInfo[window]['excludeFromBusy'] = value
+        elif name == 'cursorName':
+            _toplevelBusyInfo[window]['busyCursorName'] = value
+        else:
+            raise KeyError, 'Unknown busycursor attribute &quot;' + name + '&quot;'
+
+def _addRootToToplevelBusyInfo():
+    # Include the Tk root window in the list of toplevels.  This must
+    # not be called before Tkinter has had a chance to be initialised by
+    # the application.
+
+    root = Tkinter._default_root
+    if root == None:
+        root = Tkinter.Tk()
+    if not _toplevelBusyInfo.has_key(root):
+        _addToplevelBusyInfo(root)
+
+def busycallback(command, updateFunction = None):
+    if not callable(command):
+	raise ValueError, \
+	    'cannot register non-command busy callback %s %s' % \
+	        (repr(command), type(command))
+    wrapper = _BusyWrapper(command, updateFunction)
+    return wrapper.callback
+
+_errorReportFile = None
+_errorWindow = None
+
+def reporterrorstofile(file = None):
+    global _errorReportFile
+    _errorReportFile = file
+
+def displayerror(text):
+    global _errorWindow
+
+    if _errorReportFile is not None:
+	_errorReportFile.write(text + '\n')
+    else:
+        # Print error on standard error as well as to error window. 
+        # Useful if error window fails to be displayed, for example
+        # when exception is triggered in a &lt;Destroy&gt; binding for root
+        # window.
+        sys.stderr.write(text + '\n')
+
+	if _errorWindow is None:
+	    # The error window has not yet been created.
+	    _errorWindow = _ErrorWindow()
+
+	_errorWindow.showerror(text)
+
+_root = None
+_disableKeyboardWhileBusy = 1
+
+def initialise(
+        root = None,
+        size = None,
+        fontScheme = None,
+        useTkOptionDb = 0,
+        noBltBusy = 0,
+        disableKeyboardWhileBusy = None,
+):
+    # Remember if show/hidebusycursor should ignore keyboard events.
+    global _disableKeyboardWhileBusy
+    if disableKeyboardWhileBusy is not None:
+        _disableKeyboardWhileBusy = disableKeyboardWhileBusy
+
+    # Do not use blt busy command if noBltBusy is set.  Otherwise,
+    # use blt busy if it is available.
+    global _haveBltBusy
+    if noBltBusy:
+        _haveBltBusy = 0
+
+    # Save flag specifying whether the Tk option database should be
+    # queried when setting megawidget option default values.
+    global _useTkOptionDb
+    _useTkOptionDb = useTkOptionDb
+
+    # If we haven't been given a root window, use the default or
+    # create one.
+    if root is None:
+	if Tkinter._default_root is None:
+	    root = Tkinter.Tk()
+	else:
+	    root = Tkinter._default_root
+
+    # If this call is initialising a different Tk interpreter than the
+    # last call, then re-initialise all global variables.  Assume the
+    # last interpreter has been destroyed - ie:  Pmw does not (yet)
+    # support multiple simultaneous interpreters.
+    global _root
+    if _root is not None and _root != root:
+        global _busyStack
+        global _errorWindow
+        global _grabStack
+        global _hullToMegaWidget
+        global _toplevelBusyInfo
+        _busyStack = []
+        _errorWindow = None
+        _grabStack = []
+        _hullToMegaWidget = {}
+        _toplevelBusyInfo = {}
+    _root = root
+
+    # Trap Tkinter Toplevel constructors so that a list of Toplevels
+    # can be maintained.
+    Tkinter.Toplevel.title = __TkinterToplevelTitle
+
+    # Trap Tkinter widget destruction so that megawidgets can be
+    # destroyed when their hull widget is destoyed and the list of
+    # Toplevels can be pruned.
+    Tkinter.Toplevel.destroy = __TkinterToplevelDestroy
+    Tkinter.Widget.destroy = __TkinterWidgetDestroy
+
+    # Modify Tkinter's CallWrapper class to improve the display of
+    # errors which occur in callbacks.
+    Tkinter.CallWrapper = __TkinterCallWrapper
+
+    # Make sure we get to know when the window manager deletes the
+    # root window.  Only do this if the protocol has not yet been set. 
+    # This is required if there is a modal dialog displayed and the
+    # window manager deletes the root window.  Otherwise the
+    # application will not exit, even though there are no windows.
+    if root.protocol('WM_DELETE_WINDOW') == '':
+	root.protocol('WM_DELETE_WINDOW', root.destroy)
+
+    # Set the base font size for the application and set the
+    # Tk option database font resources.
+    
+    _font_initialise(root, size, fontScheme)
+
+    return root
+
+def alignlabels(widgets, sticky = None):
+    if len(widgets) == 0:
+    	return
+
+    widgets[0].update_idletasks()
+
+    # Determine the size of the maximum length label string.
+    maxLabelWidth = 0
+    for iwid in widgets:
+	labelWidth = iwid.grid_bbox(0, 1)[2]
+	if labelWidth &gt; maxLabelWidth:
+	    maxLabelWidth = labelWidth
+
+    # Adjust the margins for the labels such that the child sites and
+    # labels line up.
+    for iwid in widgets:
+	if sticky is not None:
+	    iwid.component('label').grid(sticky=sticky)
+	iwid.grid_columnconfigure(0, minsize = maxLabelWidth)
+#=============================================================================
+
+# Private routines
+#-----------------
+_callToTkReturned = 1
+_recursionCounter = 1
+
+class _TraceTk:
+    def __init__(self, tclInterp):
+        self.tclInterp = tclInterp
+
+    def getTclInterp(self):
+        return self.tclInterp
+
+    # Calling from python into Tk.
+    def call(self, *args, **kw):
+        global _callToTkReturned
+        global _recursionCounter
+
+        _callToTkReturned = 0
+        if len(args) == 1 and type(args[0]) == types.TupleType:
+            argStr = str(args[0])
+        else:
+            argStr = str(args)
+	_traceTkFile.write('CALL  TK&gt; %d:%s%s' %
+                (_recursionCounter, '  ' * _recursionCounter, argStr))
+	_recursionCounter = _recursionCounter + 1
+        try:
+            result = apply(self.tclInterp.call, args, kw)
+	except Tkinter.TclError, errorString:
+            _callToTkReturned = 1
+            _recursionCounter = _recursionCounter - 1
+            _traceTkFile.write('\nTK ERROR&gt; %d:%s-&gt; %s\n' %
+                    (_recursionCounter, '  ' * _recursionCounter,
+                            repr(errorString)))
+            if _withStackTrace:
+                _traceTkFile.write('CALL  TK&gt; stack:\n')
+                traceback.print_stack()
+            raise Tkinter.TclError, errorString
+
+        _recursionCounter = _recursionCounter - 1
+        if _callToTkReturned:
+            _traceTkFile.write('CALL RTN&gt; %d:%s-&gt; %s' %
+                    (_recursionCounter, '  ' * _recursionCounter, repr(result)))
+        else:
+            _callToTkReturned = 1
+            if result:
+                _traceTkFile.write(' -&gt; %s' % repr(result))
+        _traceTkFile.write('\n')
+        if _withStackTrace:
+            _traceTkFile.write('CALL  TK&gt; stack:\n')
+            traceback.print_stack()
+
+        _traceTkFile.flush()
+        return result
+
+    def __getattr__(self, key):
+        return getattr(self.tclInterp, key)
+
+def _setTkInterps(window, tk):
+    window.tk = tk
+    for child in window.children.values():
+      _setTkInterps(child, tk)
+
+#=============================================================================
+
+# Functions to display a busy cursor.  Keep a list of all toplevels
+# and display the busy cursor over them.  The list will contain the Tk
+# root toplevel window as well as all other toplevel windows.
+# Also keep a list of the widget which last had focus for each
+# toplevel.
+
+# Map from toplevel windows to
+#     {'isBusy', 'windowFocus', 'busyWindow',
+#         'excludeFromBusy', 'busyCursorName'}
+_toplevelBusyInfo = {}
+
+# Pmw needs to know all toplevel windows, so that it can call blt busy
+# on them.  This is a hack so we get notified when a Tk topevel is
+# created.  Ideally, the __init__ 'method' should be overridden, but
+# it is a 'read-only special attribute'.  Luckily, title() is always
+# called from the Tkinter Toplevel constructor.
+
+def _addToplevelBusyInfo(window):
+    if window._w == '.':
+        busyWindow = '._Busy'
+    else:
+        busyWindow = window._w + '._Busy'
+
+    _toplevelBusyInfo[window] = {
+        'isBusy' : 0,
+        'windowFocus' : None,
+        'busyWindow' : busyWindow,
+        'excludeFromBusy' : 0,
+        'busyCursorName' : None,
+    }
+
+def __TkinterToplevelTitle(self, *args):
+    # If this is being called from the constructor, include this
+    # Toplevel in the list of toplevels and set the initial
+    # WM_DELETE_WINDOW protocol to destroy() so that we get to know
+    # about it.
+    if not _toplevelBusyInfo.has_key(self):
+        _addToplevelBusyInfo(self)
+        self._Pmw_WM_DELETE_name = self.register(self.destroy, None, 0)
+	self.protocol('WM_DELETE_WINDOW', self._Pmw_WM_DELETE_name)
+
+    return apply(Tkinter.Wm.title, (self,) + args)
+
+_haveBltBusy = None
+def _havebltbusy(window):
+    global _busy_hold, _busy_release, _haveBltBusy
+    if _haveBltBusy is None:
+        import PmwBlt
+        _haveBltBusy = PmwBlt.havebltbusy(window)
+        _busy_hold = PmwBlt.busy_hold
+        if os.name == 'nt':
+            # There is a bug in Blt 2.4i on NT where the busy window
+            # does not follow changes in the children of a window.
+            # Using forget works around the problem.
+            _busy_release = PmwBlt.busy_forget
+        else:
+            _busy_release = PmwBlt.busy_release
+    return _haveBltBusy
+
+class _BusyWrapper:
+    def __init__(self, command, updateFunction):
+	self._command = command
+	self._updateFunction = updateFunction
+
+    def callback(self, *args):
+	showbusycursor()
+	rtn = apply(self._command, args)
+
+	# Call update before hiding the busy windows to clear any
+	# events that may have occurred over the busy windows.
+	if callable(self._updateFunction):
+	    self._updateFunction()
+
+	hidebusycursor()
+	return rtn
+
+#=============================================================================
+
+def drawarrow(canvas, color, direction, tag, baseOffset = 0.25, edgeOffset = 0.15):
+    canvas.delete(tag)
+
+    bw = (string.atoi(canvas['borderwidth']) + 
+            string.atoi(canvas['highlightthickness']))
+    width = string.atoi(canvas['width'])
+    height = string.atoi(canvas['height'])
+
+    if direction in ('up', 'down'):
+        majorDimension = height
+        minorDimension = width
+    else:
+        majorDimension = width
+        minorDimension = height
+
+    offset = round(baseOffset * majorDimension)
+    if direction in ('down', 'right'):
+        base = bw + offset
+        apex = bw + majorDimension - offset
+    else:
+        base = bw + majorDimension - offset
+        apex = bw + offset
+
+    if minorDimension &gt; 3 and minorDimension % 2 == 0:
+        minorDimension = minorDimension - 1
+    half = int(minorDimension * (1 - 2 * edgeOffset)) / 2
+    low = round(bw + edgeOffset * minorDimension)
+    middle = low + half
+    high = low + 2 * half
+
+    if direction in ('up', 'down'):
+        coords = (low, base, high, base, middle, apex)
+    else:
+        coords = (base, low, base, high, apex, middle)
+    kw = {'fill' : color, 'outline' : color, 'tag' : tag}
+    apply(canvas.create_polygon, coords, kw)
+
+#=============================================================================
+
+# Modify the Tkinter destroy methods so that it notifies us when a Tk
+# toplevel or frame is destroyed.
+
+# A map from the 'hull' component of a megawidget to the megawidget. 
+# This is used to clean up a megawidget when its hull is destroyed.
+_hullToMegaWidget = {}
+
+def __TkinterToplevelDestroy(tkWidget):
+    if _hullToMegaWidget.has_key(tkWidget):
+        mega = _hullToMegaWidget[tkWidget]
+        try:
+	    mega.destroy()
+        except:
+	    _reporterror(mega.destroy, ())
+    else:
+        # Delete the busy info structure for this toplevel (if the
+        # window was created before initialise() was called, it
+        # will not have any.
+        if _toplevelBusyInfo.has_key(tkWidget):
+            del _toplevelBusyInfo[tkWidget]
+        if hasattr(tkWidget, '_Pmw_WM_DELETE_name'):
+            tkWidget.tk.deletecommand(tkWidget._Pmw_WM_DELETE_name)
+            del tkWidget._Pmw_WM_DELETE_name
+        Tkinter.BaseWidget.destroy(tkWidget)
+
+def __TkinterWidgetDestroy(tkWidget):
+    if _hullToMegaWidget.has_key(tkWidget):
+        mega = _hullToMegaWidget[tkWidget]
+        try:
+	    mega.destroy()
+        except:
+	    _reporterror(mega.destroy, ())
+    else:
+        Tkinter.BaseWidget.destroy(tkWidget)
+
+#=============================================================================
+
+# Add code to Tkinter to improve the display of errors which occur in
+# callbacks.
+
+class __TkinterCallWrapper:
+    def __init__(self, func, subst, widget):
+	self.func = func
+	self.subst = subst
+	self.widget = widget
+
+    # Calling back from Tk into python.
+    def __call__(self, *args):
+	try:
+	    if self.subst:
+		args = apply(self.subst, args)
+            if _traceTk:
+                if not _callToTkReturned:
+                    _traceTkFile.write('\n')
+                if hasattr(self.func, 'im_class'):
+                    name = self.func.im_class.__name__ + '.' + \
+                        self.func.__name__
+                else:
+                    name = self.func.__name__
+                if len(args) == 1 and hasattr(args[0], 'type'):
+                    # The argument to the callback is an event.
+                    eventName = _eventTypeToName[string.atoi(args[0].type)]
+                    if eventName in ('KeyPress', 'KeyRelease',):
+                        argStr = '(%s %s Event: %s)' % \
+                            (eventName, args[0].keysym, args[0].widget)
+                    else:
+                        argStr = '(%s Event, %s)' % (eventName, args[0].widget)
+                else:
+                    argStr = str(args)
+                _traceTkFile.write('CALLBACK&gt; %d:%s%s%s\n' %
+                    (_recursionCounter, '  ' * _recursionCounter, name, argStr))
+                _traceTkFile.flush()
+	    return apply(self.func, args)
+	except SystemExit, msg:
+	    raise SystemExit, msg
+	except:
+	    _reporterror(self.func, args)
+
+_eventTypeToName = {
+    2 : 'KeyPress',         15 : 'VisibilityNotify',   28 : 'PropertyNotify',
+    3 : 'KeyRelease',       16 : 'CreateNotify',       29 : 'SelectionClear',
+    4 : 'ButtonPress',      17 : 'DestroyNotify',      30 : 'SelectionRequest',
+    5 : 'ButtonRelease',    18 : 'UnmapNotify',        31 : 'SelectionNotify',
+    6 : 'MotionNotify',     19 : 'MapNotify',          32 : 'ColormapNotify',
+    7 : 'EnterNotify',      20 : 'MapRequest',         33 : 'ClientMessage',
+    8 : 'LeaveNotify',      21 : 'ReparentNotify',     34 : 'MappingNotify',
+    9 : 'FocusIn',          22 : 'ConfigureNotify',    35 : 'VirtualEvents',
+    10 : 'FocusOut',        23 : 'ConfigureRequest',   36 : 'ActivateNotify',
+    11 : 'KeymapNotify',    24 : 'GravityNotify',      37 : 'DeactivateNotify',
+    12 : 'Expose',          25 : 'ResizeRequest',      38 : 'MouseWheelEvent',
+    13 : 'GraphicsExpose',  26 : 'CirculateNotify',
+    14 : 'NoExpose',        27 : 'CirculateRequest',
+}
+
+def _reporterror(func, args):
+    # Fetch current exception values.
+    exc_type, exc_value, exc_traceback = sys.exc_info()
+
+    # Give basic information about the callback exception.
+    if type(exc_type) == types.ClassType:
+	# Handle python 1.5 class exceptions.
+	exc_type = exc_type.__name__
+    msg = exc_type + ' Exception in Tk callback\n'
+    msg = msg + '  Function: %s (type: %s)\n' % (repr(func), type(func))
+    msg = msg + '  Args: %s\n' % str(args)
+
+    if type(args) == types.TupleType and len(args) &gt; 0 and \
+	    hasattr(args[0], 'type'):
+        eventArg = 1
+    else:
+        eventArg = 0
+
+    # If the argument to the callback is an event, add the event type.
+    if eventArg:
+	eventNum = string.atoi(args[0].type)
+        if eventNum in _eventTypeToName.keys():
+            msg = msg + '  Event type: %s (type num: %d)\n' % \
+                    (_eventTypeToName[eventNum], eventNum)
+        else:
+            msg = msg + '  Unknown event type (type num: %d)\n' % eventNum
+
+    # Add the traceback.
+    msg = msg + 'Traceback (innermost last):\n'
+    for tr in traceback.extract_tb(exc_traceback):
+	msg = msg + '  File &quot;%s&quot;, line %s, in %s\n' % (tr[0], tr[1], tr[2])
+	msg = msg + '    %s\n' % tr[3]
+    msg = msg + '%s: %s\n' % (exc_type, exc_value)
+
+    # If the argument to the callback is an event, add the event contents.
+    if eventArg:
+	msg = msg + '\n================================================\n'
+	msg = msg + '  Event contents:\n'
+	keys = args[0].__dict__.keys()
+	keys.sort()
+	for key in keys:
+	    msg = msg + '    %s: %s\n' % (key, args[0].__dict__[key])
+
+    clearbusycursor()
+    try:
+	displayerror(msg)
+    except:
+        pass
+
+class _ErrorWindow:
+    def __init__(self):
+
+	self._errorQueue = []
+	self._errorCount = 0
+	self._open = 0
+        self._firstShowing = 1
+
+	# Create the toplevel window
+	self._top = Tkinter.Toplevel()
+	self._top.protocol('WM_DELETE_WINDOW', self._hide)
+	self._top.title('Error in background function')
+	self._top.iconname('Background error')
+
+	# Create the text widget and scrollbar in a frame
+	upperframe = Tkinter.Frame(self._top)
+
+	scrollbar = Tkinter.Scrollbar(upperframe, orient='vertical')
+	scrollbar.pack(side = 'right', fill = 'y')
+
+	self._text = Tkinter.Text(upperframe, yscrollcommand=scrollbar.set)
+	self._text.pack(fill = 'both', expand = 1)
+	scrollbar.configure(command=self._text.yview)
+
+	# Create the buttons and label in a frame
+	lowerframe = Tkinter.Frame(self._top)
+
+	ignore = Tkinter.Button(lowerframe,
+	        text = 'Ignore remaining errors', command = self._hide)
+	ignore.pack(side='left')
+
+	self._nextError = Tkinter.Button(lowerframe,
+	        text = 'Show next error', command = self._next)
+	self._nextError.pack(side='left')
+
+	self._label = Tkinter.Label(lowerframe, relief='ridge')
+	self._label.pack(side='left', fill='x', expand=1)
+
+	# Pack the lower frame first so that it does not disappear
+	# when the window is resized.
+	lowerframe.pack(side = 'bottom', fill = 'x')
+	upperframe.pack(side = 'bottom', fill = 'both', expand = 1)
+
+    def showerror(self, text):
+	if self._open:
+	    self._errorQueue.append(text)
+	else:
+	    self._display(text)
+	    self._open = 1
+
+	# Display the error window in the same place it was before.
+	if self._top.state() == 'normal':
+	    # If update_idletasks is not called here, the window may
+	    # be placed partially off the screen.  Also, if it is not
+	    # called and many errors are generated quickly in
+	    # succession, the error window may not display errors
+	    # until the last one is generated and the interpreter
+	    # becomes idle.
+	    # XXX: remove this, since it causes omppython to go into an
+	    # infinite loop if an error occurs in an omp callback.
+	    # self._top.update_idletasks()
+
+            pass
+	else:
+	    if self._firstShowing:
+		geom = None
+	    else:
+                geometry = self._top.geometry()
+                index = string.find(geometry, '+')
+                if index &gt;= 0:
+                    geom = geometry[index:]
+                else:
+                    geom = None
+            setgeometryanddeiconify(self._top, geom)
+
+        if self._firstShowing:
+            self._firstShowing = 0
+        else:
+            self._top.tkraise()
+
+        self._top.focus()
+
+	self._updateButtons()
+
+	# Release any grab, so that buttons in the error window work.
+        releasegrabs()
+
+    def _hide(self):
+	self._errorCount = self._errorCount + len(self._errorQueue)
+	self._errorQueue = []
+	self._top.withdraw()
+	self._open = 0
+
+    def _next(self):
+	# Display the next error in the queue. 
+
+	text = self._errorQueue[0]
+	del self._errorQueue[0]
+
+	self._display(text)
+	self._updateButtons()
+
+    def _display(self, text):
+	self._errorCount = self._errorCount + 1
+	text = 'Error: %d\n%s' % (self._errorCount, text)
+	self._text.delete('1.0', 'end')
+	self._text.insert('end', text)
+
+    def _updateButtons(self):
+	numQueued = len(self._errorQueue)
+	if numQueued &gt; 0:
+	    self._label.configure(text='%d more errors' % numQueued)
+	    self._nextError.configure(state='normal')
+	else:
+	    self._label.configure(text='No more errors')
+	    self._nextError.configure(state='disabled')
+
+######################################################################
+### File: PmwDialog.py
+# Based on iwidgets2.2.0/dialog.itk and iwidgets2.2.0/dialogshell.itk code.
+
+# Convention:
+#   Each dialog window should have one of these as the rightmost button:
+#     Close         Close a window which only displays information.
+#     Cancel        Close a window which may be used to change the state of
+#                   the application.
+
+import sys
+import types
+import Tkinter
+
+
+# A Toplevel with a ButtonBox and child site.
+
+class Dialog(MegaToplevel):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('buttonbox_hull_borderwidth',   1,         None),
+	    ('buttonbox_hull_relief',        'raised',  None),
+	    ('buttonboxpos',                 's',       INITOPT),
+	    ('buttons',                      ('OK',),   self._buttons),
+	    ('command',                      None,      None),
+	    ('dialogchildsite_borderwidth',  1,         None),
+	    ('dialogchildsite_relief',       'raised',  None),
+	    ('defaultbutton',                None,      self._defaultButton),
+            ('master',                       'parent',  None),
+	    ('separatorwidth',               0,         INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaToplevel.__init__(self, parent)
+
+	# Create the components.
+
+	oldInterior = MegaToplevel.interior(self)
+
+	# Set up pack options according to the position of the button box.
+        pos = self['buttonboxpos']
+	if pos not in 'nsew':
+	    raise ValueError, \
+	        'bad buttonboxpos option &quot;%s&quot;:  should be n, s, e, or w' \
+		    % pos
+
+	if pos in 'ns':
+	    orient = 'horizontal'
+	    fill = 'x'
+	    if pos == 'n':
+	        side = 'top'
+	    else:
+	        side = 'bottom'
+	else:
+	    orient = 'vertical'
+	    fill = 'y'
+	    if pos == 'w':
+	        side = 'left'
+	    else:
+	        side = 'right'
+
+	# Create the button box.
+	self._buttonBox = self.createcomponent('buttonbox',
+		(), None,
+		ButtonBox, (oldInterior,), orient = orient)
+	self._buttonBox.pack(side = side, fill = fill)
+
+	# Create the separating line.
+	width = self['separatorwidth']
+	if width &gt; 0:
+	    self._separator = self.createcomponent('separator',
+		    (), None,
+		    Tkinter.Frame, (oldInterior,), relief = 'sunken',
+		    height = width, width = width, borderwidth = width / 2)
+	    self._separator.pack(side = side, fill = fill)
+	
+	# Create the child site.
+	self.__dialogChildSite = self.createcomponent('dialogchildsite',
+		(), None,
+		Tkinter.Frame, (oldInterior,))
+	self.__dialogChildSite.pack(side=side, fill='both', expand=1)
+
+	self.oldButtons = ()
+	self.oldDefault = None
+
+	self.bind('&lt;Return&gt;', self._invokeDefault)
+        self.userdeletefunc(self._doCommand)
+        self.usermodaldeletefunc(self._doCommand)
+	
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def interior(self):
+	return self.__dialogChildSite
+
+    def invoke(self, index = DEFAULT):
+	return self._buttonBox.invoke(index)
+
+    def _invokeDefault(self, event):
+	try:
+	    self._buttonBox.index(DEFAULT)
+	except ValueError:
+	    return
+	self._buttonBox.invoke()
+
+    def _doCommand(self, name = None):
+        if name is not None and self.active() and \
+                grabstacktopwindow() != self.component('hull'):
+            # This is a modal dialog but is not on the top of the grab
+            # stack (ie:  should not have the grab), so ignore this
+            # event.  This seems to be a bug in Tk and may occur in
+            # nested modal dialogs.
+            #
+            # An example is the PromptDialog demonstration.  To
+            # trigger the problem, start the demo, then move the mouse
+            # to the main window, hit &lt;TAB&gt; and then &lt;TAB&gt; again.  The
+            # highlight border of the &quot;Show prompt dialog&quot; button
+            # should now be displayed.  Now hit &lt;SPACE&gt;, &lt;RETURN&gt;,
+            # &lt;RETURN&gt; rapidly several times.  Eventually, hitting the
+            # return key invokes the password dialog &quot;OK&quot; button even
+            # though the confirm dialog is active (and therefore
+            # should have the keyboard focus).  Observed under Solaris
+            # 2.5.1, python 1.5.2 and Tk8.0.
+
+            # TODO:  Give focus to the window on top of the grabstack.
+            return
+
+	command = self['command']
+	if callable(command):
+	    return command(name)
+	else:
+	    if self.active():
+	        self.deactivate(name)
+	    else:
+	        self.withdraw()
+
+    def _buttons(self):
+	buttons = self['buttons']
+	if type(buttons) != types.TupleType and type(buttons) != types.ListType:
+	    raise ValueError, \
+	        'bad buttons option &quot;%s&quot;: should be a tuple' % str(buttons)
+	if self.oldButtons == buttons:
+	  return
+
+	self.oldButtons = buttons
+
+	for index in range(self._buttonBox.numbuttons()):
+	    self._buttonBox.delete(0)
+	for name in buttons:
+	    self._buttonBox.add(name,
+		command=lambda self=self, name=name: self._doCommand(name))
+
+	if len(buttons) &gt; 0:
+	    defaultbutton = self['defaultbutton']
+	    if defaultbutton is None:
+		self._buttonBox.setdefault(None)
+	    else:
+		try:
+		    self._buttonBox.index(defaultbutton)
+		except ValueError:
+		    pass
+		else:
+		    self._buttonBox.setdefault(defaultbutton)
+	self._buttonBox.alignbuttons()
+
+    def _defaultButton(self):
+	defaultbutton = self['defaultbutton']
+	if self.oldDefault == defaultbutton:
+	  return
+
+	self.oldDefault = defaultbutton
+
+	if len(self['buttons']) &gt; 0:
+	    if defaultbutton is None:
+		self._buttonBox.setdefault(None)
+	    else:
+		try:
+		    self._buttonBox.index(defaultbutton)
+		except ValueError:
+		    pass
+		else:
+		    self._buttonBox.setdefault(defaultbutton)
+
+######################################################################
+### File: PmwTimeFuncs.py
+# Functions for dealing with dates and times.
+
+import re
+import string
+
+def timestringtoseconds(text, separator = ':'):
+  inputList = string.split(string.strip(text), separator)
+  if len(inputList) != 3:
+    raise ValueError, 'invalid value: ' + text
+
+  sign = 1
+  if len(inputList[0]) &gt; 0 and inputList[0][0] in ('+', '-'):
+    if inputList[0][0] == '-':
+      sign = -1
+    inputList[0] = inputList[0][1:]
+
+  if re.search('[^0-9]', string.join(inputList, '')) is not None:
+    raise ValueError, 'invalid value: ' + text
+
+  hour = string.atoi(inputList[0])
+  minute = string.atoi(inputList[1])
+  second = string.atoi(inputList[2])
+
+  if minute &gt;= 60 or second &gt;= 60:
+    raise ValueError, 'invalid value: ' + text
+  return sign * (hour * 60 * 60 + minute * 60 + second)
+
+_year_pivot = 50
+_century = 2000
+
+def setyearpivot(pivot, century = None):
+    global _year_pivot
+    global _century
+    oldvalues = (_year_pivot, _century)
+    _year_pivot = pivot
+    if century is not None:
+	_century = century
+    return oldvalues
+
+def datestringtojdn(text, format = 'ymd', separator = '/'):
+  inputList = string.split(string.strip(text), separator)
+  if len(inputList) != 3:
+    raise ValueError, 'invalid value: ' + text
+
+  if re.search('[^0-9]', string.join(inputList, '')) is not None:
+    raise ValueError, 'invalid value: ' + text
+  formatList = list(format)
+  day = string.atoi(inputList[formatList.index('d')])
+  month = string.atoi(inputList[formatList.index('m')])
+  year = string.atoi(inputList[formatList.index('y')])
+
+  if _year_pivot is not None:
+    if year &gt;= 0 and year &lt; 100:
+      if year &lt;= _year_pivot:
+	year = year + _century
+      else:
+	year = year + _century - 100
+
+  jdn = ymdtojdn(year, month, day)
+  if jdntoymd(jdn) != (year, month, day):
+    raise ValueError, 'invalid value: ' + text
+  return jdn
+
+def _cdiv(a, b):
+    # Return a / b as calculated by most C language implementations,
+    # assuming both a and b are integers.
+
+    if a * b &gt; 0:
+	return a / b
+    else:
+	return -(abs(a) / abs(b))
+
+def ymdtojdn(year, month, day, julian = -1, papal = 1):
+
+    # set Julian flag if auto set
+    if julian &lt; 0:
+	if papal:                          # Pope Gregory XIII's decree
+	    lastJulianDate = 15821004L     # last day to use Julian calendar
+	else:                              # British-American usage
+	    lastJulianDate = 17520902L     # last day to use Julian calendar
+
+	julian = ((year * 100L) + month) * 100 + day  &lt;=  lastJulianDate
+
+    if year &lt; 0:
+	# Adjust BC year
+	year = year + 1
+
+    if julian:
+	return 367L * year - _cdiv(7 * (year + 5001L + _cdiv((month - 9), 7)), 4) + \
+	    _cdiv(275 * month, 9) + day + 1729777L
+    else:
+	return (day - 32076L) + \
+	    _cdiv(1461L * (year + 4800L + _cdiv((month - 14), 12)), 4) + \
+	    _cdiv(367 * (month - 2 - _cdiv((month - 14), 12) * 12), 12) - \
+	    _cdiv((3 * _cdiv((year + 4900L + _cdiv((month - 14), 12)), 100)), 4) + \
+	    1            # correction by rdg
+
+def jdntoymd(jdn, julian = -1, papal = 1):
+
+    # set Julian flag if auto set
+    if julian &lt; 0:
+	if papal:                          # Pope Gregory XIII's decree
+	    lastJulianJdn = 2299160L       # last jdn to use Julian calendar
+	else:                              # British-American usage
+	    lastJulianJdn = 2361221L       # last jdn to use Julian calendar
+
+	julian = (jdn &lt;= lastJulianJdn);
+
+    x = jdn + 68569L
+    if julian:
+	x = x + 38
+	daysPer400Years = 146100L
+	fudgedDaysPer4000Years = 1461000L + 1
+    else:
+	daysPer400Years = 146097L
+	fudgedDaysPer4000Years = 1460970L + 31
+
+    z = _cdiv(4 * x, daysPer400Years)
+    x = x - _cdiv((daysPer400Years * z + 3), 4)
+    y = _cdiv(4000 * (x + 1), fudgedDaysPer4000Years)
+    x = x - _cdiv(1461 * y, 4) + 31
+    m = _cdiv(80 * x, 2447)
+    d = x - _cdiv(2447 * m, 80)
+    x = _cdiv(m, 11)
+    m = m + 2 - 12 * x
+    y = 100 * (z - 49) + y + x
+
+    # Convert from longs to integers.
+    yy = int(y)
+    mm = int(m)
+    dd = int(d)
+
+    if yy &lt;= 0:
+	# Adjust BC years.
+	    yy = yy - 1
+
+    return (yy, mm, dd)
+
+def stringtoreal(text, separator = '.'):
+    if separator != '.':
+	if string.find(text, '.') &gt;= 0:
+	    raise ValueError, 'invalid value: ' + text
+	index = string.find(text, separator)
+	if index &gt;= 0:
+	    text = text[:index] + '.' + text[index + 1:]
+    return string.atof(text)
+
+######################################################################
+### File: PmwBalloon.py
+import os
+import string
+import Tkinter
+
+
+class Balloon(MegaToplevel):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	optiondefs = (
+            ('initwait',                 500,            None), # milliseconds
+            ('label_background',         'lightyellow',  None),
+            ('label_foreground',         'black',        None),
+            ('label_justify',            'left',         None),
+            ('master',                   'parent',       None),
+            ('relmouse',                 'none',         self._relmouse),
+            ('state',                    'both',         self._state),
+            ('statuscommand',            None,           None),
+            ('xoffset',                  20,             None), # pixels
+            ('yoffset',                  1,              None), # pixels
+	    ('hull_highlightthickness',  1,              None),
+	    ('hull_highlightbackground', 'black',        None),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaToplevel.__init__(self, parent)
+
+	self.withdraw()
+	self.overrideredirect(1)
+
+	# Create the components.
+	interior = self.interior()
+	self._label = self.createcomponent('label',
+		(), None,
+		Tkinter.Label, (interior,))
+	self._label.pack()
+
+        # The default hull configuration options give a black border
+        # around the balloon, but avoids a black 'flash' when the
+        # balloon is deiconified, before the text appears.
+        if not kw.has_key('hull_background'):
+            self.configure(hull_background = \
+                    str(self._label.cget('background')))
+
+	# Initialise instance variables.
+	self._timer = None
+
+        # The widget or item that is currently triggering the balloon. 
+        # It is None if the balloon is not being displayed.  It is a
+        # one-tuple if the balloon is being displayed in response to a
+        # widget binding (value is the widget).  It is a two-tuple if
+        # the balloon is being displayed in response to a canvas or
+        # text item binding (value is the widget and the item).
+        self._currentTrigger = None
+	
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def destroy(self):
+	if self._timer is not None:
+	    self.after_cancel(self._timer)
+	    self._timer = None
+	MegaToplevel.destroy(self)
+
+    def bind(self, widget, balloonHelp, statusHelp = None):
+
+        # If a previous bind for this widget exists, remove it.
+        self.unbind(widget)
+
+	if balloonHelp is None and statusHelp is None:
+	    return
+
+	if statusHelp is None:
+	    statusHelp = balloonHelp
+	enterId = widget.bind('&lt;Enter&gt;', 
+		lambda event, self = self, w = widget,
+			sHelp = statusHelp, bHelp = balloonHelp:
+				self._enter(event, w, sHelp, bHelp, 0))
+
+        # Set Motion binding so that if the pointer remains at rest
+        # within the widget until the status line removes the help and
+        # then the pointer moves again, then redisplay the help in the
+        # status line.
+	# Note:  The Motion binding only works for basic widgets, and
+        # the hull of megawidgets but not for other megawidget components.
+	motionId = widget.bind('&lt;Motion&gt;', 
+		lambda event = None, self = self, statusHelp = statusHelp:
+			self.showstatus(statusHelp))
+
+	leaveId = widget.bind('&lt;Leave&gt;', self._leave)
+	buttonId = widget.bind('&lt;ButtonPress&gt;', self._buttonpress)
+
+        # Set Destroy binding so that the balloon can be withdrawn and
+        # the timer can be cancelled if the widget is destroyed.
+	destroyId = widget.bind('&lt;Destroy&gt;', self._destroy)
+
+        # Use the None item in the widget's private Pmw dictionary to
+        # store the widget's bind callbacks, for later clean up.
+        if not hasattr(widget, '_Pmw_BalloonBindIds'):
+            widget._Pmw_BalloonBindIds = {}
+        widget._Pmw_BalloonBindIds[None] = \
+                (enterId, motionId, leaveId, buttonId, destroyId)
+
+    def unbind(self, widget):
+        if hasattr(widget, '_Pmw_BalloonBindIds'):
+            if widget._Pmw_BalloonBindIds.has_key(None):
+                (enterId, motionId, leaveId, buttonId, destroyId) = \
+                        widget._Pmw_BalloonBindIds[None]
+                # Need to pass in old bindings, so that Tkinter can
+                # delete the commands.  Otherwise, memory is leaked.
+                widget.unbind('&lt;Enter&gt;', enterId)
+                widget.unbind('&lt;Motion&gt;', motionId)
+                widget.unbind('&lt;Leave&gt;', leaveId)
+                widget.unbind('&lt;ButtonPress&gt;', buttonId)
+                widget.unbind('&lt;Destroy&gt;', destroyId)
+                del widget._Pmw_BalloonBindIds[None]
+
+        if self._currentTrigger is not None and len(self._currentTrigger) == 1:
+            # The balloon is currently being displayed and the current
+            # trigger is a widget.
+            triggerWidget = self._currentTrigger[0]
+            if triggerWidget == widget:
+                if self._timer is not None:
+                    self.after_cancel(self._timer)
+                    self._timer = None
+                self.withdraw()
+                self.clearstatus()
+                self._currentTrigger = None
+
+    def tagbind(self, widget, tagOrItem, balloonHelp, statusHelp = None):
+
+        # If a previous bind for this widget's tagOrItem exists, remove it.
+        self.tagunbind(widget, tagOrItem)
+
+	if balloonHelp is None and statusHelp is None:
+	    return
+
+	if statusHelp is None:
+	    statusHelp = balloonHelp
+	enterId = widget.tag_bind(tagOrItem, '&lt;Enter&gt;', 
+		lambda event, self = self, w = widget,
+			sHelp = statusHelp, bHelp = balloonHelp:
+				self._enter(event, w, sHelp, bHelp, 1))
+	motionId = widget.tag_bind(tagOrItem, '&lt;Motion&gt;', 
+		lambda event = None, self = self, statusHelp = statusHelp:
+			self.showstatus(statusHelp))
+	leaveId = widget.tag_bind(tagOrItem, '&lt;Leave&gt;', self._leave)
+	buttonId = widget.tag_bind(tagOrItem, '&lt;ButtonPress&gt;', self._buttonpress)
+
+        # Use the tagOrItem item in the widget's private Pmw dictionary to
+        # store the tagOrItem's bind callbacks, for later clean up.
+        if not hasattr(widget, '_Pmw_BalloonBindIds'):
+            widget._Pmw_BalloonBindIds = {}
+        widget._Pmw_BalloonBindIds[tagOrItem] = \
+                (enterId, motionId, leaveId, buttonId)
+
+    def tagunbind(self, widget, tagOrItem):
+        if hasattr(widget, '_Pmw_BalloonBindIds'):
+            if widget._Pmw_BalloonBindIds.has_key(tagOrItem):
+                (enterId, motionId, leaveId, buttonId) = \
+                        widget._Pmw_BalloonBindIds[tagOrItem]
+                widget.tag_unbind(tagOrItem, '&lt;Enter&gt;', enterId)
+                widget.tag_unbind(tagOrItem, '&lt;Motion&gt;', motionId)
+                widget.tag_unbind(tagOrItem, '&lt;Leave&gt;', leaveId)
+                widget.tag_unbind(tagOrItem, '&lt;ButtonPress&gt;', buttonId)
+                del widget._Pmw_BalloonBindIds[tagOrItem]
+
+        if self._currentTrigger is None:
+            # The balloon is not currently being displayed.
+            return
+
+        if len(self._currentTrigger) == 1:
+            # The current trigger is a widget.
+            return
+
+        if len(self._currentTrigger) == 2:
+            # The current trigger is a canvas item.
+            (triggerWidget, triggerItem) = self._currentTrigger
+            if triggerWidget == widget and triggerItem == tagOrItem:
+                if self._timer is not None:
+                    self.after_cancel(self._timer)
+                    self._timer = None
+                self.withdraw()
+                self.clearstatus()
+                self._currentTrigger = None
+        else: # The current trigger is a text item.
+            (triggerWidget, x, y) = self._currentTrigger
+            if triggerWidget == widget:
+                currentPos = widget.index('@%d,%d' % (x, y))
+                currentTags = widget.tag_names(currentPos)
+                if tagOrItem in currentTags:
+                    if self._timer is not None:
+                        self.after_cancel(self._timer)
+                        self._timer = None
+                    self.withdraw()
+                    self.clearstatus()
+                    self._currentTrigger = None
+
+    def showstatus(self, statusHelp):
+	if self['state'] in ('status', 'both'):
+	    cmd = self['statuscommand']
+	    if callable(cmd):
+		cmd(statusHelp)
+
+    def clearstatus(self):
+        self.showstatus(None)
+
+    def _state(self):
+	if self['state'] not in ('both', 'balloon', 'status', 'none'):
+	    raise ValueError, 'bad state option ' + repr(self['state']) + \
+		': should be one of \'both\', \'balloon\', ' + \
+		'\'status\' or \'none\''
+
+    def _relmouse(self):
+	if self['relmouse'] not in ('both', 'x', 'y', 'none'):
+	    raise ValueError, 'bad relmouse option ' + repr(self['relmouse'])+ \
+		': should be one of \'both\', \'x\', ' + '\'y\' or \'none\''
+
+    def _enter(self, event, widget, statusHelp, balloonHelp, isItem):
+
+        # Do not display balloon if mouse button is pressed.  This
+        # will only occur if the button was pressed inside a widget,
+        # then the mouse moved out of and then back into the widget,
+        # with the button still held down.  The number 0x1f00 is the
+        # button mask for the 5 possible buttons in X.
+        buttonPressed = (event.state &amp; 0x1f00) != 0
+
+	if not buttonPressed and balloonHelp is not None and \
+                self['state'] in ('balloon', 'both'):
+	    if self._timer is not None:
+		self.after_cancel(self._timer)
+		self._timer = None
+
+	    self._timer = self.after(self['initwait'], 
+		    lambda self = self, widget = widget, help = balloonHelp,
+			    isItem = isItem:
+			    self._showBalloon(widget, help, isItem))
+
+        if isItem:
+            if hasattr(widget, 'canvasx'):
+		# The widget is a canvas.
+                item = widget.find_withtag('current')
+                if len(item) &gt; 0:
+                    item = item[0]
+                else:
+                    item = None
+                self._currentTrigger = (widget, item)
+            else:
+		# The widget is a text widget.
+                self._currentTrigger = (widget, event.x, event.y)
+        else:
+            self._currentTrigger = (widget,)
+
+	self.showstatus(statusHelp)
+
+    def _leave(self, event):
+	if self._timer is not None:
+	    self.after_cancel(self._timer)
+	    self._timer = None
+	self.withdraw()
+	self.clearstatus()
+        self._currentTrigger = None
+
+    def _destroy(self, event):
+
+        # Only withdraw the balloon and cancel the timer if the widget
+        # being destroyed is the widget that triggered the balloon. 
+        # Note that in a Tkinter Destroy event, the widget field is a
+        # string and not a widget as usual.
+
+        if self._currentTrigger is None:
+            # The balloon is not currently being displayed
+            return
+
+        if len(self._currentTrigger) == 1:
+            # The current trigger is a widget (not an item)
+            triggerWidget = self._currentTrigger[0]
+            if str(triggerWidget) == event.widget:
+                if self._timer is not None:
+                    self.after_cancel(self._timer)
+                    self._timer = None
+                self.withdraw()
+                self.clearstatus()
+                self._currentTrigger = None
+
+    def _buttonpress(self, event):
+	if self._timer is not None:
+	    self.after_cancel(self._timer)
+	    self._timer = None
+	self.withdraw()
+        self._currentTrigger = None
+
+    def _showBalloon(self, widget, balloonHelp, isItem):
+
+	self._label.configure(text = balloonHelp)
+
+        # First, display the balloon offscreen to get dimensions.
+        screenWidth = self.winfo_screenwidth()
+        screenHeight = self.winfo_screenheight()
+        self.geometry('+%d+0' % (screenWidth + 1))
+        self.update_idletasks()
+
+	if isItem:
+            # Get the bounding box of the current item.
+            bbox = widget.bbox('current')
+            if bbox is None:
+                # The item that triggered the balloon has disappeared,
+                # perhaps by a user's timer event that occured between
+                # the &lt;Enter&gt; event and the 'initwait' timer calling
+                # this method.
+                return
+
+	    # The widget is either a text or canvas.  The meaning of
+	    # the values returned by the bbox method is different for
+	    # each, so use the existence of the 'canvasx' method to
+	    # distinguish between them.
+	    if hasattr(widget, 'canvasx'):
+		# The widget is a canvas.  Place balloon under canvas
+                # item.  The positions returned by bbox are relative
+                # to the entire canvas, not just the visible part, so
+                # need to convert to window coordinates.
+                leftrel = bbox[0] - widget.canvasx(0)
+                toprel = bbox[1] - widget.canvasy(0)
+                bottomrel = bbox[3] - widget.canvasy(0)
+	    else:
+		# The widget is a text widget.  Place balloon under
+                # the character closest to the mouse.  The positions
+                # returned by bbox are relative to the text widget
+                # window (ie the visible part of the text only).
+		leftrel = bbox[0]
+                toprel = bbox[1]
+		bottomrel = bbox[1] + bbox[3]
+	else:
+	    leftrel = 0
+            toprel = 0
+	    bottomrel = widget.winfo_height()
+
+        xpointer, ypointer = widget.winfo_pointerxy()   # -1 if off screen
+
+        if xpointer &gt;= 0 and self['relmouse'] in ('both', 'x'):
+            x = xpointer
+        else:
+            x = leftrel + widget.winfo_rootx()
+        x = x + self['xoffset']
+
+        if ypointer &gt;= 0 and self['relmouse'] in ('both', 'y'):
+            y = ypointer
+        else:
+            y = bottomrel + widget.winfo_rooty()
+        y = y + self['yoffset']
+
+        edges = (string.atoi(str(self.cget('hull_highlightthickness'))) +
+            string.atoi(str(self.cget('hull_borderwidth')))) * 2
+        if x + self._label.winfo_reqwidth() + edges &gt; screenWidth:
+            x = screenWidth - self._label.winfo_reqwidth() - edges
+
+        if y + self._label.winfo_reqheight() + edges &gt; screenHeight:
+            if ypointer &gt;= 0 and self['relmouse'] in ('both', 'y'):
+                y = ypointer
+            else:
+                y = toprel + widget.winfo_rooty()
+            y = y - self._label.winfo_reqheight() - self['yoffset'] - edges
+
+        setgeometryanddeiconify(self, '+%d+%d' % (x, y))
+
+######################################################################
+### File: PmwButtonBox.py
+# Based on iwidgets2.2.0/buttonbox.itk code.
+
+import types
+import Tkinter
+
+
+class ButtonBox(MegaWidget):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('labelmargin',       0,              INITOPT),
+	    ('labelpos',          None,           INITOPT),
+	    ('orient',            'horizontal',   INITOPT),
+	    ('padx',              3,              INITOPT),
+	    ('pady',              3,              INITOPT),
+	)
+	self.defineoptions(kw, optiondefs, dynamicGroups = ('Button',))
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+	if self['labelpos'] is None:
+	    self._buttonBoxFrame = self._hull
+	    columnOrRow = 0
+	else:
+	    self._buttonBoxFrame = self.createcomponent('frame',
+		    (), None,
+		    Tkinter.Frame, (interior,))
+	    self._buttonBoxFrame.grid(column=2, row=2, sticky='nsew')
+	    columnOrRow = 2
+
+	    self.createlabel(interior)
+
+	orient = self['orient']
+	if orient == 'horizontal':
+	    interior.grid_columnconfigure(columnOrRow, weight = 1)
+	elif orient == 'vertical':
+	    interior.grid_rowconfigure(columnOrRow, weight = 1)
+	else:
+	    raise ValueError, 'bad orient option ' + repr(orient) + \
+		': must be either \'horizontal\' or \'vertical\''
+
+	# Initialise instance variables.
+
+	# List of tuples describing the buttons:
+	#   - name
+	#   - button widget
+	self._buttonList = []
+
+	# The index of the default button.
+	self._defaultButton = None
+
+	self._timerId = None
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def destroy(self):
+	if self._timerId:
+	    self.after_cancel(self._timerId)
+	    self._timerId = None
+	MegaWidget.destroy(self)
+
+    def numbuttons(self):
+        return len(self._buttonList)
+
+    def index(self, index, forInsert = 0):
+	listLength = len(self._buttonList)
+	if type(index) == types.IntType:
+	    if forInsert and index &lt;= listLength:
+		return index
+	    elif not forInsert and index &lt; listLength:
+		return index
+	    else:
+		raise ValueError, 'index &quot;%s&quot; is out of range' % index
+	elif index is END:
+	    if forInsert:
+		return listLength
+	    elif listLength &gt; 0:
+		return listLength - 1
+	    else:
+		raise ValueError, 'ButtonBox has no buttons'
+	elif index is DEFAULT:
+	    if self._defaultButton is not None:
+		return self._defaultButton
+	    raise ValueError, 'ButtonBox has no default'
+	else:
+            names = map(lambda t: t[0], self._buttonList)
+            if index in names:
+                return names.index(index)
+	    validValues = 'a name, a number, END or DEFAULT'
+	    raise ValueError, \
+		'bad index &quot;%s&quot;: must be %s' % (index, validValues)
+
+    def insert(self, componentName, beforeComponent = 0, **kw):
+	if componentName in self.components():
+	    raise ValueError, 'button &quot;%s&quot; already exists' % componentName
+	if not kw.has_key('text'):
+	    kw['text'] = componentName
+        kw['default'] = 'normal'
+	button = apply(self.createcomponent, (componentName,
+		(), 'Button',
+		Tkinter.Button, (self._buttonBoxFrame,)), kw)
+
+	index = self.index(beforeComponent, 1)
+	horizontal = self['orient'] == 'horizontal'
+	numButtons = len(self._buttonList)
+
+	# Shift buttons up one position.
+	for i in range(numButtons - 1, index - 1, -1):
+	    widget = self._buttonList[i][1]
+	    pos = i * 2 + 3
+	    if horizontal:
+		widget.grid(column = pos, row = 0)
+	    else:
+		widget.grid(column = 0, row = pos)
+
+	# Display the new button.
+	if horizontal:
+	    button.grid(column = index * 2 + 1, row = 0, sticky = 'ew',
+		    padx = self['padx'], pady = self['pady'])
+	    self._buttonBoxFrame.grid_columnconfigure(
+		    numButtons * 2 + 2, weight = 1)
+	else:
+	    button.grid(column = 0, row = index * 2 + 1, sticky = 'ew',
+		    padx = self['padx'], pady = self['pady'])
+	    self._buttonBoxFrame.grid_rowconfigure(
+		    numButtons * 2 + 2, weight = 1)
+	self._buttonList.insert(index, (componentName, button))
+
+	return button
+
+    def add(self, componentName, **kw):
+        return apply(self.insert, (componentName, len(self._buttonList)), kw)
+
+    def delete(self, index):
+        index = self.index(index)
+	(name, widget) = self._buttonList[index]
+	widget.grid_forget()
+	self.destroycomponent(name)
+
+	numButtons = len(self._buttonList)
+
+	# Shift buttons down one position.
+	horizontal = self['orient'] == 'horizontal'
+	for i in range(index + 1, numButtons):
+	    widget = self._buttonList[i][1]
+	    pos = i * 2 - 1
+	    if horizontal:
+		widget.grid(column = pos, row = 0)
+	    else:
+		widget.grid(column = 0, row = pos)
+
+	if horizontal:
+	    self._buttonBoxFrame.grid_columnconfigure(numButtons * 2 - 1,
+		    minsize = 0)
+	    self._buttonBoxFrame.grid_columnconfigure(numButtons * 2, weight = 0)
+	else:
+	    self._buttonBoxFrame.grid_rowconfigure(numButtons * 2, weight = 0)
+	del self._buttonList[index]
+
+    def setdefault(self, index):
+	# Turn off the default ring around the current default button.
+	if self._defaultButton is not None:
+	    button = self._buttonList[self._defaultButton][1]
+	    button.configure(default = 'normal')
+	    self._defaultButton = None
+
+	# Turn on the default ring around the new default button.
+	if index is not None:
+	    index = self.index(index)
+	    self._defaultButton = index
+	    button = self._buttonList[index][1]
+	    button.configure(default = 'active')
+
+    def invoke(self, index = DEFAULT, noFlash = 0):
+	# Invoke the callback associated with the *index* button.  If
+	# *noFlash* is not set, flash the button to indicate to the
+	# user that something happened.
+
+	button = self._buttonList[self.index(index)][1]
+	if not noFlash:
+	    state = button.cget('state')
+	    relief = button.cget('relief')
+	    button.configure(state = 'active', relief = 'sunken')
+	    self.update_idletasks()
+	    self.after(100)
+	    button.configure(state = state, relief = relief)
+	return button.invoke()
+
+    def button(self, buttonIndex):
+	return self._buttonList[self.index(buttonIndex)][1]
+
+    def alignbuttons(self, when = 'later'):
+	if when == 'later':
+	    if not self._timerId:
+		self._timerId = self.after_idle(self.alignbuttons, 'now')
+	    return
+	self.update_idletasks()
+	self._timerId = None
+
+        # Determine the width of the maximum length button.
+        max = 0
+        horizontal = (self['orient'] == 'horizontal')
+        for index in range(len(self._buttonList)):
+            gridIndex = index * 2 + 1
+            if horizontal:
+                width = self._buttonBoxFrame.grid_bbox(gridIndex, 0)[2]
+            else:
+                width = self._buttonBoxFrame.grid_bbox(0, gridIndex)[2]
+            if width &gt; max:
+                max = width
+
+        # Set the width of all the buttons to be the same.
+	if horizontal:
+	    for index in range(len(self._buttonList)):
+		self._buttonBoxFrame.grid_columnconfigure(index * 2 + 1,
+			minsize = max)
+	else:
+	    self._buttonBoxFrame.grid_columnconfigure(0, minsize = max)
+
+######################################################################
+### File: PmwEntryField.py
+# Based on iwidgets2.2.0/entryfield.itk code.
+
+import re
+import string
+import types
+import Tkinter
+
+
+# Possible return values of validation functions.
+OK = 1
+ERROR = 0
+PARTIAL = -1
+
+class EntryField(MegaWidget):
+    _classBindingsDefinedFor = 0
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('command',           None,        None),
+	    ('errorbackground',   'pink',      None),
+	    ('invalidcommand',    self.bell,   None),
+	    ('labelmargin',       0,           INITOPT),
+	    ('labelpos',          None,        INITOPT),
+	    ('modifiedcommand',   None,        None),
+	    ('sticky',            'ew',        INITOPT),
+	    ('validate',          None,        self._validate),
+	    ('extravalidators',   {},          None),
+	    ('value',             '',          INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+	self._entryFieldEntry = self.createcomponent('entry',
+		(), None,
+		Tkinter.Entry, (interior,))
+	self._entryFieldEntry.grid(column=2, row=2, sticky=self['sticky'])
+	if self['value'] != '':
+	    self.__setEntry(self['value'])
+	interior.grid_columnconfigure(2, weight=1)
+	interior.grid_rowconfigure(2, weight=1)
+
+	self.createlabel(interior)
+
+	# Initialise instance variables.
+
+	self.normalBackground = None
+        self._previousText = None
+
+	# Initialise instance.
+
+	_registerEntryField(self._entryFieldEntry, self)
+
+        # Establish the special class bindings if not already done.
+        # Also create bindings if the Tkinter default interpreter has
+        # changed.  Use Tkinter._default_root to create class
+        # bindings, so that a reference to root is created by
+        # bind_class rather than a reference to self, which would
+        # prevent object cleanup.
+        if EntryField._classBindingsDefinedFor != Tkinter._default_root:
+	    tagList = self._entryFieldEntry.bindtags()
+            root  = Tkinter._default_root
+	    	    
+	    allSequences = {}
+	    for tag in tagList:
+
+                sequences = root.bind_class(tag)
+                if type(sequences) is types.StringType:
+                    # In old versions of Tkinter, bind_class returns a string
+                    sequences = root.tk.splitlist(sequences)
+
+		for sequence in sequences:
+		    allSequences[sequence] = None
+	    for sequence in allSequences.keys():
+		root.bind_class('EntryFieldPre', sequence, _preProcess)
+		root.bind_class('EntryFieldPost', sequence, _postProcess)
+
+	    EntryField._classBindingsDefinedFor = root
+
+	self._entryFieldEntry.bindtags(('EntryFieldPre',) +
+		self._entryFieldEntry.bindtags() + ('EntryFieldPost',))
+	self._entryFieldEntry.bind('&lt;Return&gt;', self._executeCommand)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def destroy(self):
+	_deregisterEntryField(self._entryFieldEntry)
+        MegaWidget.destroy(self)
+
+    def _getValidatorFunc(self, validator, index):
+	# Search the extra and standard validator lists for the
+	# given 'validator'.  If 'validator' is an alias, then
+	# continue the search using the alias.  Make sure that
+	# self-referencial aliases do not cause infinite loops.
+
+	extraValidators = self['extravalidators']
+	traversedValidators = []
+
+	while 1:
+	    traversedValidators.append(validator)
+	    if extraValidators.has_key(validator):
+		validator = extraValidators[validator][index]
+	    elif _standardValidators.has_key(validator):
+		validator = _standardValidators[validator][index]
+	    else:
+		return validator
+	    if validator in traversedValidators:
+		return validator
+
+    def _validate(self):
+	dict = {
+	    'validator' : None,
+	    'min' : None,
+	    'max' : None,
+	    'minstrict' : 1,
+	    'maxstrict' : 1,
+	}
+	opt = self['validate']
+	if type(opt) is types.DictionaryType:
+	    dict.update(opt)
+	else:
+	    dict['validator'] = opt
+
+	# Look up validator maps and replace 'validator' field with
+	# the corresponding function.
+	validator = dict['validator']
+	valFunction = self._getValidatorFunc(validator, 0)
+	self._checkValidateFunction(valFunction, 'validate', validator)
+	dict['validator'] = valFunction
+
+	# Look up validator maps and replace 'stringtovalue' field
+	# with the corresponding function.
+	if dict.has_key('stringtovalue'):
+	    stringtovalue = dict['stringtovalue'] 
+	    strFunction = self._getValidatorFunc(stringtovalue, 1)
+	    self._checkValidateFunction(
+		    strFunction, 'stringtovalue', stringtovalue)
+	else:
+	    strFunction = self._getValidatorFunc(validator, 1)
+	    if strFunction == validator:
+		strFunction = len
+	dict['stringtovalue'] = strFunction
+
+	self._validationInfo = dict
+	args = dict.copy()
+	del args['validator']
+	del args['min']
+	del args['max']
+	del args['minstrict']
+	del args['maxstrict']
+	del args['stringtovalue']
+	self._validationArgs = args
+        self._previousText = None
+
+	if type(dict['min']) == types.StringType and strFunction is not None:
+	    dict['min'] = apply(strFunction, (dict['min'],), args)
+	if type(dict['max']) == types.StringType and strFunction is not None:
+	    dict['max'] = apply(strFunction, (dict['max'],), args)
+
+	self._checkValidity()
+
+    def _checkValidateFunction(self, function, option, validator):
+	# Raise an error if 'function' is not a function or None.
+
+	if function is not None and not callable(function):
+	    extraValidators = self['extravalidators']
+	    extra = extraValidators.keys()
+	    extra.sort()
+	    extra = tuple(extra)
+	    standard = _standardValidators.keys()
+	    standard.sort()
+	    standard = tuple(standard)
+	    msg = 'bad %s value &quot;%s&quot;:  must be a function or one of ' \
+		'the standard validators %s or extra validators %s'
+	    raise ValueError, msg % (option, validator, standard, extra)
+
+    def _executeCommand(self, event = None):
+	cmd = self['command']
+	if callable(cmd):
+            if event is None:
+                # Return result of command for invoke() method.
+                return cmd()
+            else:
+                cmd()
+	    
+    def _preProcess(self):
+
+        self._previousText = self._entryFieldEntry.get()
+        self._previousICursor = self._entryFieldEntry.index('insert')
+        self._previousXview = self._entryFieldEntry.index('@0')
+	if self._entryFieldEntry.selection_present():
+	    self._previousSel= (self._entryFieldEntry.index('sel.first'),
+		self._entryFieldEntry.index('sel.last'))
+	else:
+	    self._previousSel = None
+
+    def _postProcess(self):
+
+	# No need to check if text has not changed.
+	previousText = self._previousText
+	if previousText == self._entryFieldEntry.get():
+	    return self.valid()
+
+	valid = self._checkValidity()
+        if self.hulldestroyed():
+            # The invalidcommand called by _checkValidity() destroyed us.
+            return valid
+
+	cmd = self['modifiedcommand']
+	if callable(cmd) and previousText != self._entryFieldEntry.get():
+	    cmd()
+	return valid
+	    
+    def checkentry(self):
+	# If there is a variable specified by the entry_textvariable
+	# option, checkentry() should be called after the set() method
+	# of the variable is called.
+
+	self._previousText = None
+	return self._postProcess()
+
+    def _getValidity(self):
+	text = self._entryFieldEntry.get()
+	dict = self._validationInfo
+	args = self._validationArgs
+
+	if dict['validator'] is not None:
+	    status = apply(dict['validator'], (text,), args)
+	    if status != OK:
+		return status
+
+	# Check for out of (min, max) range.
+	if dict['stringtovalue'] is not None:
+	    min = dict['min']
+	    max = dict['max']
+	    if min is None and max is None:
+		return OK
+	    val = apply(dict['stringtovalue'], (text,), args)
+	    if min is not None and val &lt; min:
+		if dict['minstrict']:
+		    return ERROR
+		else:
+		    return PARTIAL
+	    if max is not None and val &gt; max:
+		if dict['maxstrict']:
+		    return ERROR
+		else:
+		    return PARTIAL
+	return OK
+
+    def _checkValidity(self):
+	valid = self._getValidity()
+	oldValidity = valid
+
+	if valid == ERROR:
+	    # The entry is invalid.
+	    cmd = self['invalidcommand']
+	    if callable(cmd):
+		cmd()
+            if self.hulldestroyed():
+                # The invalidcommand destroyed us.
+                return oldValidity
+
+	    # Restore the entry to its previous value.
+	    if self._previousText is not None:
+		self.__setEntry(self._previousText)
+		self._entryFieldEntry.icursor(self._previousICursor)
+		self._entryFieldEntry.xview(self._previousXview)
+		if self._previousSel is not None:
+		    self._entryFieldEntry.selection_range(self._previousSel[0],
+			self._previousSel[1])
+
+		# Check if the saved text is valid as well.
+		valid = self._getValidity()
+
+	self._valid = valid
+
+        if self.hulldestroyed():
+            # The validator or stringtovalue commands called by
+            # _checkValidity() destroyed us.
+            return oldValidity
+
+	if valid == OK:
+	    if self.normalBackground is not None:
+		self._entryFieldEntry.configure(
+			background = self.normalBackground)
+		self.normalBackground = None
+	else:
+	    if self.normalBackground is None:
+		self.normalBackground = self._entryFieldEntry.cget('background')
+		self._entryFieldEntry.configure(
+			background = self['errorbackground'])
+
+        return oldValidity
+
+    def invoke(self):
+	return self._executeCommand()
+
+    def valid(self):
+        return self._valid == OK
+
+    def clear(self):
+        self.setentry('')
+
+    def __setEntry(self, text):
+	oldState = str(self._entryFieldEntry.cget('state'))
+	if oldState != 'normal':
+	    self._entryFieldEntry.configure(state='normal')
+	self._entryFieldEntry.delete(0, 'end')
+	self._entryFieldEntry.insert(0, text)
+	if oldState != 'normal':
+	    self._entryFieldEntry.configure(state=oldState)
+
+    def setentry(self, text):
+	self._preProcess()
+        self.__setEntry(text)
+	return self._postProcess()
+
+    def getvalue(self):
+        return self._entryFieldEntry.get()
+
+    def setvalue(self, text):
+        return self.setentry(text)
+
+forwardmethods(EntryField, Tkinter.Entry, '_entryFieldEntry')
+
+# ======================================================================
+
+
+# Entry field validation functions
+
+_numericregex = re.compile('^[0-9]*$')
+_alphabeticregex = re.compile('^[a-z]*$', re.IGNORECASE)
+_alphanumericregex = re.compile('^[0-9a-z]*$', re.IGNORECASE)
+
+def numericvalidator(text):
+    if text == '':
+        return PARTIAL
+    else:
+	if _numericregex.match(text) is None:
+	    return ERROR
+	else:
+	    return OK
+    
+def integervalidator(text):
+    if text in ('', '-', '+'):
+        return PARTIAL
+    try:
+	string.atol(text)
+	return OK
+    except ValueError:
+	return ERROR
+    
+def alphabeticvalidator(text):
+    if _alphabeticregex.match(text) is None:
+	return ERROR
+    else:
+	return OK
+    
+def alphanumericvalidator(text):
+    if _alphanumericregex.match(text) is None:
+	return ERROR
+    else:
+	return OK
+    
+def hexadecimalvalidator(text):
+    if text in ('', '0x', '0X', '+', '+0x', '+0X', '-', '-0x', '-0X'):
+        return PARTIAL
+    try:
+	string.atol(text, 16)
+	return OK
+    except ValueError:
+	return ERROR
+    
+def realvalidator(text, separator = '.'):
+    if separator != '.':
+	if string.find(text, '.') &gt;= 0:
+	    return ERROR
+	index = string.find(text, separator)
+	if index &gt;= 0:
+	    text = text[:index] + '.' + text[index + 1:]
+    try:
+	string.atof(text)
+	return OK
+    except ValueError:
+	# Check if the string could be made valid by appending a digit
+	# eg ('-', '+', '.', '-.', '+.', '1.23e', '1E-').
+	if len(text) == 0:
+	    return PARTIAL
+	if text[-1] in string.digits:
+	    return ERROR
+	try:
+	    string.atof(text + '0')
+	    return PARTIAL
+	except ValueError:
+	    return ERROR
+    
+def timevalidator(text, separator = ':'):
+    try:
+	timestringtoseconds(text, separator)
+	return OK
+    except ValueError:
+	if len(text) &gt; 0 and text[0] in ('+', '-'):
+	    text = text[1:]
+	if re.search('[^0-9' + separator + ']', text) is not None:
+	    return ERROR
+	return PARTIAL
+
+def datevalidator(text, format = 'ymd', separator = '/'):
+    try:
+	datestringtojdn(text, format, separator)
+	return OK
+    except ValueError:
+	if re.search('[^0-9' + separator + ']', text) is not None:
+	    return ERROR
+	return PARTIAL
+
+_standardValidators = {
+    'numeric'      : (numericvalidator,      string.atol),
+    'integer'      : (integervalidator,      string.atol),
+    'hexadecimal'  : (hexadecimalvalidator,  lambda s: string.atol(s, 16)),
+    'real'         : (realvalidator,         stringtoreal),
+    'alphabetic'   : (alphabeticvalidator,   len),
+    'alphanumeric' : (alphanumericvalidator, len),
+    'time'         : (timevalidator,         timestringtoseconds),
+    'date'         : (datevalidator,         datestringtojdn),
+}
+
+_entryCache = {}
+
+def _registerEntryField(entry, entryField):
+    # Register an EntryField widget for an Entry widget
+
+    _entryCache[entry] = entryField
+
+def _deregisterEntryField(entry):
+    # Deregister an Entry widget
+    del _entryCache[entry]
+
+def _preProcess(event):
+    # Forward preprocess events for an Entry to it's EntryField
+
+    _entryCache[event.widget]._preProcess()
+
+def _postProcess(event):
+    # Forward postprocess events for an Entry to it's EntryField
+
+    # The function specified by the 'command' option may have destroyed
+    # the megawidget in a binding earlier in bindtags, so need to check.
+    if _entryCache.has_key(event.widget):
+        _entryCache[event.widget]._postProcess()
+
+######################################################################
+### File: PmwGroup.py
+import string
+import Tkinter
+
+
+def aligngrouptags(groups):
+    # Adjust the y position of the tags in /groups/ so that they all
+    # have the height of the highest tag.
+
+    maxTagHeight = 0
+    for group in groups:
+	if group._tag is None:
+	    height = (string.atoi(str(group._ring.cget('borderwidth'))) +
+		    string.atoi(str(group._ring.cget('highlightthickness'))))
+	else:
+	    height = group._tag.winfo_reqheight()
+	if maxTagHeight &lt; height:
+	    maxTagHeight = height
+
+    for group in groups:
+	ringBorder = (string.atoi(str(group._ring.cget('borderwidth'))) +
+		string.atoi(str(group._ring.cget('highlightthickness'))))
+	topBorder = maxTagHeight / 2 - ringBorder / 2
+	group._hull.grid_rowconfigure(0, minsize = topBorder)
+	group._ring.grid_rowconfigure(0,
+		minsize = maxTagHeight - topBorder - ringBorder)
+	if group._tag is not None:
+	    group._tag.place(y = maxTagHeight / 2)
+
+class Group( MegaWidget ):
+    def __init__(self, parent = None, **kw):
+
+        # Define the megawidget options.
+	
+        optiondefs = (
+	    ('collapsedsize',    6,         INITOPT),
+	    ('ring_borderwidth', 2,         None),
+	    ('ring_relief',      'groove',  None),
+	    ('tagindent',        10,        INITOPT),
+        )
+        self.defineoptions(kw, optiondefs)
+
+        # Initialise the base class (after defining the options).
+        MegaWidget.__init__(self, parent)
+
+        # Create the components.
+        interior = MegaWidget.interior(self)
+
+	self._ring = self.createcomponent(
+	    'ring', 
+	    (), None,
+	    Tkinter.Frame, (interior,), 
+	    )
+
+	self._groupChildSite = self.createcomponent(
+	    'groupchildsite',
+	    (), None,
+	    Tkinter.Frame, (self._ring,)
+	    )
+
+        self._tag = self.createcomponent(
+	    'tag',
+	    (), None,
+	    Tkinter.Label, (interior,),
+	    )
+
+	ringBorder = (string.atoi(str(self._ring.cget('borderwidth'))) +
+		string.atoi(str(self._ring.cget('highlightthickness'))))
+	if self._tag is None:
+	    tagHeight = ringBorder
+	else:
+	    tagHeight = self._tag.winfo_reqheight()
+	    self._tag.place(
+		    x = ringBorder + self['tagindent'],
+		    y = tagHeight / 2,
+		    anchor = 'w')
+
+	topBorder = tagHeight / 2 - ringBorder / 2
+	self._ring.grid(column = 0, row = 1, sticky = 'nsew')
+	interior.grid_columnconfigure(0, weight = 1)
+	interior.grid_rowconfigure(1, weight = 1)
+	interior.grid_rowconfigure(0, minsize = topBorder)
+
+	self._groupChildSite.grid(column = 0, row = 1, sticky = 'nsew')
+	self._ring.grid_columnconfigure(0, weight = 1)
+	self._ring.grid_rowconfigure(1, weight = 1)
+	self._ring.grid_rowconfigure(0,
+		minsize = tagHeight - topBorder - ringBorder)
+
+        self.showing = 1
+
+        # Check keywords and initialise options.
+        self.initialiseoptions()
+
+    def toggle(self):
+        if self.showing:
+            self.collapse()
+        else:
+            self.expand()
+        self.showing = not self.showing
+
+    def expand(self):
+        self._groupChildSite.grid(column = 0, row = 1, sticky = 'nsew')
+
+    def collapse(self):
+        self._groupChildSite.grid_forget()
+	if self._tag is None:
+	    tagHeight = 0
+	else:
+            tagHeight = self._tag.winfo_reqheight()
+        self._ring.configure(height=(tagHeight / 2) + self['collapsedsize'])
+
+    def interior(self):
+        return self._groupChildSite
+
+######################################################################
+### File: PmwLabeledWidget.py
+import Tkinter
+
+
+class LabeledWidget(MegaWidget):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('labelmargin',            0,      INITOPT),
+	    ('labelpos',               None,   INITOPT),
+	    ('sticky',                 'nsew', INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = MegaWidget.interior(self)
+	self._labelChildSite = self.createcomponent('labelchildsite',
+		(), None,
+		Tkinter.Frame, (interior,))
+	self._labelChildSite.grid(column=2, row=2, sticky=self['sticky'])
+	interior.grid_columnconfigure(2, weight=1)
+	interior.grid_rowconfigure(2, weight=1)
+
+	self.createlabel(interior)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def interior(self):
+	return self._labelChildSite
+
+######################################################################
+### File: PmwMainMenuBar.py
+# Main menubar
+
+import string
+import types
+import Tkinter
+
+
+class MainMenuBar(MegaArchetype):
+
+    def __init__(self, parent = None, **kw):
+
+        # Define the megawidget options.
+        
+        optiondefs = (
+            ('balloon',      None,       None),
+            ('hotkeys',      1,          INITOPT),
+            ('hull_tearoff', 0,          None),
+        )
+        self.defineoptions(kw, optiondefs, dynamicGroups = ('Menu',))
+
+        # Initialise the base class (after defining the options).
+        MegaArchetype.__init__(self, parent, Tkinter.Menu)
+
+        self._menuInfo = {}
+        self._menuInfo[None] = (None, [])
+        # Map from a menu name to a tuple of information about the menu.
+        # The first item in the tuple is the name of the parent menu (for
+        # toplevel menus this is None). The second item in the tuple is
+        # a list of status help messages for each item in the menu.
+        # The key for the information for the main menubar is None.
+
+        self._menu = self.interior()
+        self._menu.bind('&lt;Leave&gt;', self._resetHelpmessage)
+        self._menu.bind('&lt;Motion&gt;',
+            lambda event=None, self=self: self._menuHelp(event, None))
+
+        # Check keywords and initialise options.
+        self.initialiseoptions()
+
+    def deletemenuitems(self, menuName, start, end = None):
+        self.component(menuName).delete(start, end)
+        if end is None:
+            del self._menuInfo[menuName][1][start]
+        else:
+            self._menuInfo[menuName][1][start:end+1] = []
+
+    def deletemenu(self, menuName):
+        &quot;&quot;&quot;Delete should be called for cascaded menus before main menus.
+        &quot;&quot;&quot;
+
+        parentName = self._menuInfo[menuName][0]
+        del self._menuInfo[menuName]
+        if parentName is None:
+            parentMenu = self._menu
+        else:
+            parentMenu = self.component(parentName)
+
+        menu = self.component(menuName)
+        menuId = str(menu)
+        for item in range(parentMenu.index('end') + 1):
+            if parentMenu.type(item) == 'cascade':
+                itemMenu = str(parentMenu.entrycget(item, 'menu'))
+                if itemMenu == menuId:
+                    parentMenu.delete(item)
+                    del self._menuInfo[parentName][1][item]
+                    break
+
+        self.destroycomponent(menuName)
+
+    def disableall(self):
+        for index in range(len(self._menuInfo[None][1])):
+            self.entryconfigure(index, state = 'disabled')
+
+    def enableall(self):
+        for index in range(len(self._menuInfo[None][1])):
+            self.entryconfigure(index, state = 'normal')
+
+    def addmenu(self, menuName, balloonHelp, statusHelp = None,
+            traverseSpec = None, **kw):
+        if statusHelp is None:
+            statusHelp = balloonHelp
+        self._addmenu(None, menuName, balloonHelp, statusHelp,
+            traverseSpec, kw)
+
+    def addcascademenu(self, parentMenuName, menuName, statusHelp='',
+            traverseSpec = None, **kw):
+        self._addmenu(parentMenuName, menuName, None, statusHelp,
+            traverseSpec, kw)
+
+    def _addmenu(self, parentMenuName, menuName, balloonHelp, statusHelp,
+            traverseSpec, kw):
+
+        if (menuName) in self.components():
+            raise ValueError, 'menu &quot;%s&quot; already exists' % menuName
+
+        menukw = {}
+        if kw.has_key('tearoff'):
+            menukw['tearoff'] = kw['tearoff']
+            del kw['tearoff']
+        else:
+            menukw['tearoff'] = 0
+        if kw.has_key('name'):
+            menukw['name'] = kw['name']
+            del kw['name']
+
+        if not kw.has_key('label'):
+            kw['label'] = menuName
+
+        self._addHotkeyToOptions(parentMenuName, kw, traverseSpec)
+
+        if parentMenuName is None:
+            parentMenu = self._menu
+            balloon = self['balloon']
+            # Bug in Tk: balloon help not implemented
+            # if balloon is not None:
+            #     balloon.mainmenubind(parentMenu, balloonHelp, statusHelp)
+        else:
+            parentMenu = self.component(parentMenuName)
+
+        apply(parentMenu.add_cascade, (), kw)
+
+        menu = apply(self.createcomponent, (menuName,
+                (), 'Menu',
+                Tkinter.Menu, (parentMenu,)), menukw)
+        parentMenu.entryconfigure('end', menu = menu)
+
+        self._menuInfo[parentMenuName][1].append(statusHelp)
+        self._menuInfo[menuName] = (parentMenuName, [])
+
+        menu.bind('&lt;Leave&gt;', self._resetHelpmessage)
+        menu.bind('&lt;Motion&gt;', 
+            lambda event=None, self=self, menuName=menuName:
+                    self._menuHelp(event, menuName))
+
+    def addmenuitem(self, menuName, itemType, statusHelp = '',
+            traverseSpec = None, **kw):
+
+        menu = self.component(menuName)
+        if itemType != 'separator':
+            self._addHotkeyToOptions(menuName, kw, traverseSpec)
+
+        if itemType == 'command':
+            command = menu.add_command
+        elif itemType == 'separator':
+            command = menu.add_separator
+        elif itemType == 'checkbutton':
+            command = menu.add_checkbutton
+        elif itemType == 'radiobutton':
+            command = menu.add_radiobutton
+        elif itemType == 'cascade':
+            command = menu.add_cascade
+        else:
+            raise ValueError, 'unknown menuitem type &quot;%s&quot;' % itemType
+
+        self._menuInfo[menuName][1].append(statusHelp)
+        apply(command, (), kw)
+
+    def _addHotkeyToOptions(self, menuName, kw, traverseSpec):
+
+        if (not self['hotkeys'] or kw.has_key('underline') or
+                not kw.has_key('label')):
+            return
+
+        if type(traverseSpec) == types.IntType:
+            kw['underline'] = traverseSpec
+            return
+
+        if menuName is None:
+            menu = self._menu
+        else:
+            menu = self.component(menuName)
+        hotkeyList = []
+        end = menu.index('end')
+        if end is not None:
+            for item in range(end + 1):
+                if menu.type(item) not in ('separator', 'tearoff'):
+                    underline = \
+                            string.atoi(str(menu.entrycget(item, 'underline')))
+                    if underline != -1:
+                        label = str(menu.entrycget(item, 'label'))
+                        if underline &lt; len(label):
+                            hotkey = string.lower(label[underline])
+                            if hotkey not in hotkeyList:
+                                hotkeyList.append(hotkey)
+
+        name = kw['label']
+
+        if type(traverseSpec) == types.StringType:
+            lowerLetter = string.lower(traverseSpec)
+            if traverseSpec in name and lowerLetter not in hotkeyList:
+                kw['underline'] = string.index(name, traverseSpec)
+        else:
+            targets = string.digits + string.letters
+            lowerName = string.lower(name)
+            for letter_index in range(len(name)):
+                letter = lowerName[letter_index]
+                if letter in targets and letter not in hotkeyList:
+                    kw['underline'] = letter_index
+                    break
+
+    def _menuHelp(self, event, menuName):
+        if menuName is None:
+            menu = self._menu
+            index = menu.index('@%d'% event.x)
+        else:
+            menu = self.component(menuName)
+            index = menu.index('@%d'% event.y)
+
+        balloon = self['balloon']
+        if balloon is not None:
+            if index is None:
+                balloon.showstatus('')
+            else:
+                if str(menu.cget('tearoff')) == '1':
+                    index = index - 1
+                if index &gt;= 0:
+                    help = self._menuInfo[menuName][1][index]
+                    balloon.showstatus(help)
+
+    def _resetHelpmessage(self, event=None):
+        balloon = self['balloon']
+        if balloon is not None:
+            balloon.clearstatus()
+
+forwardmethods(MainMenuBar, Tkinter.Menu, '_hull')
+
+######################################################################
+### File: PmwMenuBar.py
+# Manager widget for menus.
+
+import string
+import types
+import Tkinter
+
+
+class MenuBar(MegaWidget):
+
+    def __init__(self, parent = None, **kw):
+
+        # Define the megawidget options.
+        
+        optiondefs = (
+            ('balloon',      None,       None),
+            ('hotkeys',      1,          INITOPT),
+            ('padx',         0,          INITOPT),
+        )
+        self.defineoptions(kw, optiondefs, dynamicGroups = ('Menu', 'Button'))
+
+        # Initialise the base class (after defining the options).
+        MegaWidget.__init__(self, parent)
+
+        self._menuInfo = {}
+        # Map from a menu name to a tuple of information about the menu.
+        # The first item in the tuple is the name of the parent menu (for
+        # toplevel menus this is None). The second item in the tuple is
+        # a list of status help messages for each item in the menu.
+        # The third item in the tuple is the id of the binding used
+        # to detect mouse motion to display status help.
+        # Information for the toplevel menubuttons is not stored here.
+
+        self._mydeletecommand = self.component('hull').tk.deletecommand
+        # Cache this method for use later.
+
+        # Check keywords and initialise options.
+        self.initialiseoptions()
+
+    def deletemenuitems(self, menuName, start, end = None):
+        self.component(menuName + '-menu').delete(start, end)
+        if end is None:
+            del self._menuInfo[menuName][1][start]
+        else:
+            self._menuInfo[menuName][1][start:end+1] = []
+
+    def deletemenu(self, menuName):
+        &quot;&quot;&quot;Delete should be called for cascaded menus before main menus.
+        &quot;&quot;&quot;
+
+        # Clean up binding for this menu.
+        parentName = self._menuInfo[menuName][0]
+        bindId = self._menuInfo[menuName][2]
+        _bindtag = 'PmwMenuBar' + str(self) + menuName
+        self.unbind_class(_bindtag, '&lt;Motion&gt;')
+        self._mydeletecommand(bindId) # unbind_class does not clean up
+        del self._menuInfo[menuName]
+
+        if parentName is None:
+            self.destroycomponent(menuName + '-button')
+        else:
+            parentMenu = self.component(parentName + '-menu')
+
+            menu = self.component(menuName + '-menu')
+            menuId = str(menu)
+            for item in range(parentMenu.index('end') + 1):
+                if parentMenu.type(item) == 'cascade':
+                    itemMenu = str(parentMenu.entrycget(item, 'menu'))
+                    if itemMenu == menuId:
+                        parentMenu.delete(item)
+                        del self._menuInfo[parentName][1][item]
+                        break
+
+        self.destroycomponent(menuName + '-menu')
+
+    def disableall(self):
+        for menuName in self._menuInfo.keys():
+            if self._menuInfo[menuName][0] is None:
+                menubutton = self.component(menuName + '-button')
+                menubutton.configure(state = 'disabled')
+
+    def enableall(self):
+        for menuName in self._menuInfo.keys():
+            if self._menuInfo[menuName][0] is None:
+                menubutton = self.component(menuName + '-button')
+                menubutton.configure(state = 'normal')
+
+    def addmenu(self, menuName, balloonHelp, statusHelp = None,
+            side = 'left', traverseSpec = None, **kw):
+
+        self._addmenu(None, menuName, balloonHelp, statusHelp,
+            traverseSpec, side, 'text', kw)
+
+    def addcascademenu(self, parentMenuName, menuName, statusHelp = '',
+            traverseSpec = None, **kw):
+
+        self._addmenu(parentMenuName, menuName, None, statusHelp,
+            traverseSpec, None, 'label', kw)
+
+    def _addmenu(self, parentMenuName, menuName, balloonHelp, statusHelp,
+            traverseSpec, side, textKey, kw):
+
+        if (menuName + '-menu') in self.components():
+            raise ValueError, 'menu &quot;%s&quot; already exists' % menuName
+
+        menukw = {}
+        if kw.has_key('tearoff'):
+            menukw['tearoff'] = kw['tearoff']
+            del kw['tearoff']
+        else:
+            menukw['tearoff'] = 0
+
+        if not kw.has_key(textKey):
+            kw[textKey] = menuName
+
+        self._addHotkeyToOptions(parentMenuName, kw, textKey, traverseSpec)
+
+        if parentMenuName is None:
+            button = apply(self.createcomponent, (menuName + '-button',
+                    (), 'Button',
+                    Tkinter.Menubutton, (self.interior(),)), kw)
+            button.pack(side=side, padx = self['padx'])
+            balloon = self['balloon']
+            if balloon is not None:
+                balloon.bind(button, balloonHelp, statusHelp)
+            parentMenu = button
+        else:
+            parentMenu = self.component(parentMenuName + '-menu')
+            apply(parentMenu.add_cascade, (), kw)
+            self._menuInfo[parentMenuName][1].append(statusHelp)
+
+        menu = apply(self.createcomponent, (menuName + '-menu',
+                (), 'Menu',
+                Tkinter.Menu, (parentMenu,)), menukw)
+        if parentMenuName is None:
+            button.configure(menu = menu)
+        else:
+            parentMenu.entryconfigure('end', menu = menu)
+
+        # Need to put this binding after the class bindings so that
+        # menu.index() does not lag behind.
+        _bindtag = 'PmwMenuBar' + str(self) + menuName
+        bindId = self.bind_class(_bindtag, '&lt;Motion&gt;',
+            lambda event=None, self=self, menuName=menuName:
+                    self._menuHelp(menuName))
+        menu.bindtags(menu.bindtags() + (_bindtag,))
+        menu.bind('&lt;Leave&gt;', self._resetHelpmessage)
+
+        self._menuInfo[menuName] = (parentMenuName, [], bindId)
+
+    def addmenuitem(self, menuName, itemType, statusHelp = '',
+            traverseSpec = None, **kw):
+
+        menu = self.component(menuName + '-menu')
+        if itemType != 'separator':
+            self._addHotkeyToOptions(menuName, kw, 'label', traverseSpec)
+
+        if itemType == 'command':
+            command = menu.add_command
+        elif itemType == 'separator':
+            command = menu.add_separator
+        elif itemType == 'checkbutton':
+            command = menu.add_checkbutton
+        elif itemType == 'radiobutton':
+            command = menu.add_radiobutton
+        elif itemType == 'cascade':
+            command = menu.add_cascade
+        else:
+            raise ValueError, 'unknown menuitem type &quot;%s&quot;' % itemType
+
+        self._menuInfo[menuName][1].append(statusHelp)
+        apply(command, (), kw)
+
+    def _addHotkeyToOptions(self, menuName, kw, textKey, traverseSpec):
+
+        if (not self['hotkeys'] or kw.has_key('underline') or
+                not kw.has_key(textKey)):
+            return
+
+        if type(traverseSpec) == types.IntType:
+            kw['underline'] = traverseSpec
+            return
+
+        hotkeyList = []
+        if menuName is None:
+            for menuName in self._menuInfo.keys():
+                if self._menuInfo[menuName][0] is None:
+                    menubutton = self.component(menuName + '-button')
+                    underline = string.atoi(str(menubutton.cget('underline')))
+                    if underline != -1:
+                        label = str(menubutton.cget(textKey))
+                        if underline &lt; len(label):
+                            hotkey = string.lower(label[underline])
+                            if hotkey not in hotkeyList:
+                                hotkeyList.append(hotkey)
+        else:
+            menu = self.component(menuName + '-menu')
+            end = menu.index('end')
+            if end is not None:
+                for item in range(end + 1):
+                    if menu.type(item) not in ('separator', 'tearoff'):
+                        underline = string.atoi(
+                            str(menu.entrycget(item, 'underline')))
+                        if underline != -1:
+                            label = str(menu.entrycget(item, textKey))
+                            if underline &lt; len(label):
+                                hotkey = string.lower(label[underline])
+                                if hotkey not in hotkeyList:
+                                    hotkeyList.append(hotkey)
+
+        name = kw[textKey]
+
+        if type(traverseSpec) == types.StringType:
+            lowerLetter = string.lower(traverseSpec)
+            if traverseSpec in name and lowerLetter not in hotkeyList:
+                kw['underline'] = string.index(name, traverseSpec)
+        else:
+            targets = string.digits + string.letters
+            lowerName = string.lower(name)
+            for letter_index in range(len(name)):
+                letter = lowerName[letter_index]
+                if letter in targets and letter not in hotkeyList:
+                    kw['underline'] = letter_index
+                    break
+
+    def _menuHelp(self, menuName):
+        menu = self.component(menuName + '-menu')
+        index = menu.index('active')
+
+        balloon = self['balloon']
+        if balloon is not None:
+            if index is None:
+                balloon.showstatus('')
+            else:
+                if str(menu.cget('tearoff')) == '1':
+                    index = index - 1
+                if index &gt;= 0:
+                    help = self._menuInfo[menuName][1][index]
+                    balloon.showstatus(help)
+
+    def _resetHelpmessage(self, event=None):
+        balloon = self['balloon']
+        if balloon is not None:
+            balloon.clearstatus()
+
+######################################################################
+### File: PmwMessageBar.py
+# Class to display messages in an information line.
+
+import string
+import Tkinter
+
+
+class MessageBar(MegaWidget):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	defaultMessageTypes = {
+			   # (priority, showtime, bells, logmessage)
+	    'systemerror'  : (5, 10, 2, 1),
+	    'usererror'    : (4, 5, 1, 0),
+	    'busy'         : (3, 0, 0, 0),
+	    'systemevent'  : (2, 5, 0, 0),
+	    'userevent'    : (2, 5, 0, 0),
+	    'help'         : (1, 5, 0, 0),
+	    'state'        : (0, 0, 0, 0),
+	}
+	optiondefs = (
+	    ('labelmargin',    0,                     INITOPT),
+	    ('labelpos',       None,                  INITOPT),
+	    ('messagetypes',   defaultMessageTypes,   INITOPT),
+	    ('silent',         0,                     None),
+	    ('sticky',         'ew',                  INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+	self._messageBarEntry = self.createcomponent('entry',
+		(), None,
+		Tkinter.Entry, (interior,))
+
+        # Can't always use 'disabled', since this greys out text in Tk 8.4.2
+        try:
+            self._messageBarEntry.configure(state = 'readonly')
+        except Tkinter.TclError:
+            self._messageBarEntry.configure(state = 'disabled')
+
+	self._messageBarEntry.grid(column=2, row=2, sticky=self['sticky'])
+	interior.grid_columnconfigure(2, weight=1)
+	interior.grid_rowconfigure(2, weight=1)
+
+	self.createlabel(interior)
+
+	# Initialise instance variables.
+	self._numPriorities = 0
+	for info in self['messagetypes'].values():
+	    if self._numPriorities &lt; info[0]:
+		self._numPriorities = info[0]
+
+	self._numPriorities = self._numPriorities + 1
+	self._timer = [None] * self._numPriorities
+	self._messagetext = [''] * self._numPriorities
+	self._activemessage = [0] * self._numPriorities
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def destroy(self):
+	for timerId in self._timer:
+	    if timerId is not None:
+		self.after_cancel(timerId)
+	self._timer = [None] * self._numPriorities
+	MegaWidget.destroy(self)
+
+    def message(self, type, text):
+        # Display a message in the message bar.
+
+	(priority, showtime, bells, logmessage) = self['messagetypes'][type]
+
+	if not self['silent']:
+	    for i in range(bells):
+		if i != 0:
+		    self.after(100)
+		self.bell()
+
+	self._activemessage[priority] = 1
+	if text is None:
+	    text = ''
+	self._messagetext[priority] = string.replace(text, '\n', ' ')
+	self._redisplayInfoMessage()
+
+	if logmessage:
+	    # Should log this text to a text widget.
+	    pass
+
+	if showtime &gt; 0:
+	    if self._timer[priority] is not None:
+		self.after_cancel(self._timer[priority])
+
+	    # Define a callback to clear this message after a time.
+	    def _clearmessage(self=self, priority=priority):
+		self._clearActivemessage(priority)
+
+	    mseconds = int(showtime * 1000)
+	    self._timer[priority] = self.after(mseconds, _clearmessage)
+
+    def helpmessage(self, text):
+        if text is None:
+            self.resetmessages('help')
+        else:
+            self.message('help', text)
+
+    def resetmessages(self, type):
+	priority = self['messagetypes'][type][0]
+	self._clearActivemessage(priority)
+	for messagetype, info in self['messagetypes'].items():
+	    thisPriority = info[0]
+	    showtime = info[1]
+	    if thisPriority &lt; priority and showtime != 0:
+		self._clearActivemessage(thisPriority)
+
+    def _clearActivemessage(self, priority):
+	self._activemessage[priority] = 0
+	if self._timer[priority] is not None:
+	    self.after_cancel(self._timer[priority])
+	    self._timer[priority] = None
+	self._redisplayInfoMessage()
+
+    def _redisplayInfoMessage(self):
+	text = ''
+        for priority in range(self._numPriorities - 1, -1, -1):
+	    if self._activemessage[priority]:
+		text = self._messagetext[priority]
+	        break
+	self._messageBarEntry.configure(state = 'normal')
+	self._messageBarEntry.delete(0, 'end')
+	self._messageBarEntry.insert('end', text)
+
+        # Can't always use 'disabled', since this greys out text in Tk 8.4.2
+        try:
+            self._messageBarEntry.configure(state = 'readonly')
+        except Tkinter.TclError:
+            self._messageBarEntry.configure(state = 'disabled')
+
+forwardmethods(MessageBar, Tkinter.Entry, '_messageBarEntry')
+
+######################################################################
+### File: PmwMessageDialog.py
+# Based on iwidgets2.2.0/messagedialog.itk code.
+
+import Tkinter
+
+
+class MessageDialog(Dialog):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('borderx',       20,    INITOPT),
+	    ('bordery',       20,    INITOPT),
+	    ('iconmargin',    20,    INITOPT),
+	    ('iconpos',       None,  INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	Dialog.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+
+	self._message = self.createcomponent('message',
+		(), None,
+		Tkinter.Label, (interior,))
+
+        iconpos = self['iconpos']
+	iconmargin = self['iconmargin']
+	borderx = self['borderx']
+	bordery = self['bordery']
+	border_right = 2
+	border_bottom = 2
+	if iconpos is None:
+	    self._message.grid(column = 1, row = 1)
+	else:
+	    self._icon = self.createcomponent('icon',
+		    (), None,
+		    Tkinter.Label, (interior,))
+	    if iconpos not in 'nsew':
+		raise ValueError, \
+		    'bad iconpos option &quot;%s&quot;:  should be n, s, e, or w' \
+			% iconpos
+
+	    if iconpos in 'nw':
+		icon = 1
+		message = 3
+	    else:
+		icon = 3
+		message = 1
+
+	    if iconpos in 'ns':
+		# vertical layout
+		self._icon.grid(column = 1, row = icon)
+		self._message.grid(column = 1, row = message)
+		interior.grid_rowconfigure(2, minsize = iconmargin)
+		border_bottom = 4
+	    else:
+		# horizontal layout
+		self._icon.grid(column = icon, row = 1)
+		self._message.grid(column = message, row = 1)
+		interior.grid_columnconfigure(2, minsize = iconmargin)
+		border_right = 4
+
+	interior.grid_columnconfigure(0, minsize = borderx)
+	interior.grid_rowconfigure(0, minsize = bordery)
+	interior.grid_columnconfigure(border_right, minsize = borderx)
+	interior.grid_rowconfigure(border_bottom, minsize = bordery)
+
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+######################################################################
+### File: PmwNoteBook.py
+import string
+import types
+import Tkinter
+
+
+class NoteBook(MegaArchetype):
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+        optiondefs = (
+	    ('hull_highlightthickness',  0,           None),
+	    ('hull_borderwidth',         0,           None),
+            ('arrownavigation',          1,           INITOPT),
+            ('borderwidth',              2,           INITOPT),
+            ('createcommand',            None,        None),
+            ('lowercommand',             None,        None),
+            ('pagemargin',               4,           INITOPT),
+            ('raisecommand',             None,        None),
+	    ('tabpos',                   'n',         INITOPT),
+        )
+	self.defineoptions(kw, optiondefs, dynamicGroups = ('Page', 'Tab'))
+
+	# Initialise the base class (after defining the options).
+	MegaArchetype.__init__(self, parent, Tkinter.Canvas)
+
+        self.bind('&lt;Map&gt;', self._handleMap)
+        self.bind('&lt;Configure&gt;', self._handleConfigure)
+
+        tabpos = self['tabpos']
+	if tabpos is not None and tabpos != 'n':
+            raise ValueError, \
+                'bad tabpos option %s:  should be n or None' % repr(tabpos)
+        self._withTabs = (tabpos is not None)
+        self._pageMargin = self['pagemargin']
+        self._borderWidth = self['borderwidth']
+
+        # Use a dictionary as a set of bits indicating what needs to
+        # be redisplayed the next time _layout() is called.  If
+        # dictionary contains 'topPage' key, the value is the new top
+        # page to be displayed.  None indicates that all pages have
+        # been deleted and that _layout() should draw a border under where
+        # the tabs should be.
+        self._pending = {}
+        self._pending['size'] = 1
+        self._pending['borderColor'] = 1
+        self._pending['topPage'] = None
+        if self._withTabs:
+            self._pending['tabs'] = 1
+
+        self._canvasSize = None       # This gets set by &lt;Configure&gt; events
+
+        # Set initial height of space for tabs
+        if self._withTabs:
+            self.tabBottom = 35
+        else:
+            self.tabBottom = 0
+
+        self._lightBorderColor, self._darkBorderColor = \
+                Color.bordercolors(self, self['hull_background'])
+
+	self._pageNames   = []        # List of page names
+
+        # Map from page name to page info.  Each item is itself a
+        # dictionary containing the following items:
+        #   page           the Tkinter.Frame widget for the page
+        #   created        set to true the first time the page is raised
+        #   tabbutton      the Tkinter.Button widget for the button (if any)
+        #   tabreqwidth    requested width of the tab
+        #   tabreqheight   requested height of the tab
+        #   tabitems       the canvas items for the button: the button
+        #                  window item, the lightshadow and the darkshadow
+        #   left           the left and right canvas coordinates of the tab
+        #   right
+	self._pageAttrs   = {}
+
+        # Name of page currently on top (actually displayed, using
+        # create_window, not pending).  Ignored if current top page
+        # has been deleted or new top page is pending.  None indicates
+        # no pages in notebook.
+	self._topPageName = None
+
+        # Canvas items used:
+        #   Per tab: 
+        #       top and left shadow
+        #       right shadow
+        #       button
+        #   Per notebook: 
+        #       page
+        #       top page
+        #       left shadow
+        #       bottom and right shadow
+        #       top (one or two items)
+
+        # Canvas tags used:
+        #   lighttag      - top and left shadows of tabs and page
+        #   darktag       - bottom and right shadows of tabs and page
+        #                   (if no tabs then these are reversed)
+        #                   (used to color the borders by recolorborders)
+
+        # Create page border shadows.
+        if self._withTabs:
+            self._pageLeftBorder = self.create_polygon(0, 0, 0, 0, 0, 0,
+                fill = self._lightBorderColor, tags = 'lighttag')
+            self._pageBottomRightBorder = self.create_polygon(0, 0, 0, 0, 0, 0,
+                fill = self._darkBorderColor, tags = 'darktag')
+            self._pageTop1Border = self.create_polygon(0, 0, 0, 0, 0, 0,
+                fill = self._darkBorderColor, tags = 'lighttag')
+            self._pageTop2Border = self.create_polygon(0, 0, 0, 0, 0, 0,
+                fill = self._darkBorderColor, tags = 'lighttag')
+        else:
+            self._pageLeftBorder = self.create_polygon(0, 0, 0, 0, 0, 0,
+                fill = self._darkBorderColor, tags = 'darktag')
+            self._pageBottomRightBorder = self.create_polygon(0, 0, 0, 0, 0, 0,
+                fill = self._lightBorderColor, tags = 'lighttag')
+            self._pageTopBorder = self.create_polygon(0, 0, 0, 0, 0, 0,
+                fill = self._darkBorderColor, tags = 'darktag')
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def insert(self, pageName, before = 0, **kw):
+	if self._pageAttrs.has_key(pageName):
+	    msg = 'Page &quot;%s&quot; already exists.' % pageName
+	    raise ValueError, msg
+
+        # Do this early to catch bad &lt;before&gt; spec before creating any items.
+	beforeIndex = self.index(before, 1)
+
+        pageOptions = {}
+        if self._withTabs:
+            # Default tab button options.
+            tabOptions = {
+                'text' : pageName,
+                'borderwidth' : 0,
+            }
+
+        # Divide the keyword options into the 'page_' and 'tab_' options.
+        for key in kw.keys():
+            if key[:5] == 'page_':
+                pageOptions[key[5:]] = kw[key]
+                del kw[key]
+            elif self._withTabs and key[:4] == 'tab_':
+                tabOptions[key[4:]] = kw[key]
+                del kw[key]
+            else:
+		raise KeyError, 'Unknown option &quot;' + key + '&quot;'
+
+        # Create the frame to contain the page.
+	page = apply(self.createcomponent, (pageName,
+		(), 'Page',
+		Tkinter.Frame, self._hull), pageOptions)
+
+        attributes = {}
+        attributes['page'] = page
+        attributes['created'] = 0
+
+        if self._withTabs:
+            # Create the button for the tab.
+            def raiseThisPage(self = self, pageName = pageName):
+                self.selectpage(pageName)
+            tabOptions['command'] = raiseThisPage
+            tab = apply(self.createcomponent, (pageName + '-tab',
+                    (), 'Tab',
+                    Tkinter.Button, self._hull), tabOptions)
+
+            if self['arrownavigation']:
+                # Allow the use of the arrow keys for Tab navigation:
+                def next(event, self = self, pageName = pageName):
+                    self.nextpage(pageName)
+                def prev(event, self = self, pageName = pageName):
+                    self.previouspage(pageName)
+                tab.bind('&lt;Left&gt;', prev)
+                tab.bind('&lt;Right&gt;', next)
+
+            attributes['tabbutton'] = tab
+            attributes['tabreqwidth'] = tab.winfo_reqwidth()
+            attributes['tabreqheight'] = tab.winfo_reqheight()
+
+            # Create the canvas item to manage the tab's button and the items
+            # for the tab's shadow.
+            windowitem = self.create_window(0, 0, window = tab, anchor = 'nw')
+            lightshadow = self.create_polygon(0, 0, 0, 0, 0, 0,
+                tags = 'lighttag', fill = self._lightBorderColor)
+            darkshadow = self.create_polygon(0, 0, 0, 0, 0, 0,
+                tags = 'darktag', fill = self._darkBorderColor)
+            attributes['tabitems'] = (windowitem, lightshadow, darkshadow)
+            self._pending['tabs'] = 1
+
+        self._pageAttrs[pageName] = attributes
+	self._pageNames.insert(beforeIndex, pageName)
+
+        # If this is the first page added, make it the new top page
+        # and call the create and raise callbacks.
+        if self.getcurselection() is None:
+            self._pending['topPage'] = pageName
+            self._raiseNewTop(pageName)
+
+        self._layout()
+        return page
+  		
+    def add(self, pageName, **kw):
+        return apply(self.insert, (pageName, len(self._pageNames)), kw)
+
+    def delete(self, *pageNames):
+        newTopPage = 0
+        for page in pageNames:
+            pageIndex = self.index(page)
+            pageName = self._pageNames[pageIndex]
+            pageInfo = self._pageAttrs[pageName]
+
+            if self.getcurselection() == pageName:
+                if len(self._pageNames) == 1:
+                    newTopPage = 0
+                    self._pending['topPage'] = None
+                elif pageIndex == len(self._pageNames) - 1:
+                    newTopPage = 1
+                    self._pending['topPage'] = self._pageNames[pageIndex - 1]
+                else:
+                    newTopPage = 1
+                    self._pending['topPage'] = self._pageNames[pageIndex + 1]
+
+            if self._topPageName == pageName:
+                self._hull.delete(self._topPageItem)
+                self._topPageName = None
+                                
+            if self._withTabs:
+                self.destroycomponent(pageName + '-tab')
+                apply(self._hull.delete, pageInfo['tabitems'])
+            self.destroycomponent(pageName)
+            del self._pageAttrs[pageName]
+            del self._pageNames[pageIndex]
+
+        # If the old top page was deleted and there are still pages
+        # left in the notebook, call the create and raise callbacks.
+        if newTopPage:
+            pageName = self._pending['topPage']
+            self._raiseNewTop(pageName)
+
+        if self._withTabs:
+            self._pending['tabs'] = 1
+        self._layout()
+
+    def page(self, pageIndex):
+        pageName = self._pageNames[self.index(pageIndex)]
+	return self._pageAttrs[pageName]['page']
+
+    def pagenames(self):
+	return list(self._pageNames)
+
+    def getcurselection(self):
+        if self._pending.has_key('topPage'):
+            return self._pending['topPage']
+        else:
+            return self._topPageName
+
+    def tab(self, pageIndex):
+        if self._withTabs:
+            pageName = self._pageNames[self.index(pageIndex)]
+            return self._pageAttrs[pageName]['tabbutton']
+        else:
+            return None
+
+    def index(self, index, forInsert = 0):
+	listLength = len(self._pageNames)
+	if type(index) == types.IntType:
+	    if forInsert and index &lt;= listLength:
+		return index
+	    elif not forInsert and index &lt; listLength:
+		return index
+	    else:
+		raise ValueError, 'index &quot;%s&quot; is out of range' % index
+	elif index is END:
+	    if forInsert:
+		return listLength
+	    elif listLength &gt; 0:
+		return listLength - 1
+	    else:
+		raise ValueError, 'NoteBook has no pages'
+	elif index is SELECT:
+	    if listLength == 0:
+		raise ValueError, 'NoteBook has no pages'
+            return self._pageNames.index(self.getcurselection())
+	else:
+            if index in self._pageNames:
+                return self._pageNames.index(index)
+	    validValues = 'a name, a number, END or SELECT'
+	    raise ValueError, \
+                'bad index &quot;%s&quot;: must be %s' % (index, validValues)
+
+    def selectpage(self, page):
+        pageName = self._pageNames[self.index(page)]
+        oldTopPage = self.getcurselection()
+        if pageName != oldTopPage:
+            self._pending['topPage'] = pageName
+            if oldTopPage == self._topPageName:
+                self._hull.delete(self._topPageItem)
+            cmd = self['lowercommand']
+            if cmd is not None:
+                cmd(oldTopPage)
+            self._raiseNewTop(pageName)
+
+            self._layout()
+
+        # Set focus to the tab of new top page:
+        if self._withTabs and self['arrownavigation']:
+            self._pageAttrs[pageName]['tabbutton'].focus_set()
+
+    def previouspage(self, pageIndex = None):
+        if pageIndex is None:
+            curpage = self.index(SELECT)
+        else:
+            curpage = self.index(pageIndex)
+	if curpage &gt; 0:
+	    self.selectpage(curpage - 1)
+
+    def nextpage(self, pageIndex = None):
+        if pageIndex is None:
+            curpage = self.index(SELECT)
+        else:
+            curpage = self.index(pageIndex)
+	if curpage &lt; len(self._pageNames) - 1:
+	    self.selectpage(curpage + 1)
+
+    def setnaturalsize(self, pageNames = None):
+        self.update_idletasks()
+        maxPageWidth = 1
+        maxPageHeight = 1
+        if pageNames is None:
+            pageNames = self.pagenames()
+        for pageName in pageNames:
+            pageInfo = self._pageAttrs[pageName]
+            page = pageInfo['page']
+            w = page.winfo_reqwidth()
+            h = page.winfo_reqheight()
+            if maxPageWidth &lt; w:
+                maxPageWidth = w
+            if maxPageHeight &lt; h:
+                maxPageHeight = h
+        pageBorder = self._borderWidth + self._pageMargin
+        width = maxPageWidth + pageBorder * 2
+        height = maxPageHeight + pageBorder * 2
+
+        if self._withTabs:
+            maxTabHeight = 0
+            for pageInfo in self._pageAttrs.values():
+                if maxTabHeight &lt; pageInfo['tabreqheight']:
+                    maxTabHeight = pageInfo['tabreqheight']
+            height = height + maxTabHeight + self._borderWidth * 1.5
+
+        # Note that, since the hull is a canvas, the width and height
+        # options specify the geometry *inside* the borderwidth and
+        # highlightthickness.
+        self.configure(hull_width = width, hull_height = height)
+
+    def recolorborders(self):
+        self._pending['borderColor'] = 1
+        self._layout()
+
+    def _handleMap(self, event):
+        self._layout()
+
+    def _handleConfigure(self, event):
+        self._canvasSize = (event.width, event.height)
+        self._pending['size'] = 1
+        self._layout()
+
+    def _raiseNewTop(self, pageName):
+        if not self._pageAttrs[pageName]['created']:
+            self._pageAttrs[pageName]['created'] = 1
+            cmd = self['createcommand']
+            if cmd is not None:
+                cmd(pageName)
+        cmd = self['raisecommand']
+        if cmd is not None:
+            cmd(pageName)
+
+    # This is the vertical layout of the notebook, from top (assuming
+    # tabpos is 'n'):
+    #     hull highlightthickness (top)
+    #     hull borderwidth (top)
+    #     borderwidth (top border of tabs)
+    #     borderwidth * 0.5 (space for bevel)
+    #     tab button (maximum of requested height of all tab buttons)
+    #     borderwidth (border between tabs and page)
+    #     pagemargin (top)
+    #     the page itself
+    #     pagemargin (bottom)
+    #     borderwidth (border below page)
+    #     hull borderwidth (bottom)
+    #     hull highlightthickness (bottom)
+    #
+    # canvasBorder is sum of top two elements.
+    # tabBottom is sum of top five elements.
+    #
+    # Horizontal layout (and also vertical layout when tabpos is None):
+    #     hull highlightthickness
+    #     hull borderwidth
+    #     borderwidth
+    #     pagemargin
+    #     the page itself
+    #     pagemargin
+    #     borderwidth
+    #     hull borderwidth
+    #     hull highlightthickness
+    #
+    def _layout(self):
+        if not self.winfo_ismapped() or self._canvasSize is None:
+            # Don't layout if the window is not displayed, or we
+            # haven't yet received a &lt;Configure&gt; event.
+            return
+
+        hullWidth, hullHeight = self._canvasSize
+        borderWidth = self._borderWidth
+        canvasBorder = string.atoi(self._hull['borderwidth']) + \
+            string.atoi(self._hull['highlightthickness'])
+        if not self._withTabs:
+            self.tabBottom = canvasBorder
+        oldTabBottom = self.tabBottom
+
+        if self._pending.has_key('borderColor'):
+            self._lightBorderColor, self._darkBorderColor = \
+                    Color.bordercolors(self, self['hull_background'])
+
+        # Draw all the tabs.
+        if self._withTabs and (self._pending.has_key('tabs') or
+                self._pending.has_key('size')):
+            # Find total requested width and maximum requested height
+            # of tabs.
+            sumTabReqWidth = 0
+            maxTabHeight = 0
+            for pageInfo in self._pageAttrs.values():
+                sumTabReqWidth = sumTabReqWidth + pageInfo['tabreqwidth']
+                if maxTabHeight &lt; pageInfo['tabreqheight']:
+                    maxTabHeight = pageInfo['tabreqheight']
+            if maxTabHeight != 0:
+                # Add the top tab border plus a bit for the angled corners
+                self.tabBottom = canvasBorder + maxTabHeight + borderWidth * 1.5
+
+            # Prepare for drawing the border around each tab button.
+            tabTop = canvasBorder
+            tabTop2 = tabTop + borderWidth
+            tabTop3 = tabTop + borderWidth * 1.5
+            tabBottom2 = self.tabBottom
+            tabBottom = self.tabBottom + borderWidth
+
+            numTabs = len(self._pageNames)
+            availableWidth = hullWidth - 2 * canvasBorder - \
+                numTabs * 2 * borderWidth
+            x = canvasBorder
+            cumTabReqWidth = 0
+            cumTabWidth = 0
+
+            # Position all the tabs.
+            for pageName in self._pageNames:
+                pageInfo = self._pageAttrs[pageName]
+                (windowitem, lightshadow, darkshadow) = pageInfo['tabitems']
+                if sumTabReqWidth &lt;= availableWidth:
+                    tabwidth = pageInfo['tabreqwidth']
+                else:
+                    # This ugly calculation ensures that, when the
+                    # notebook is not wide enough for the requested
+                    # widths of the tabs, the total width given to
+                    # the tabs exactly equals the available width,
+                    # without rounding errors.
+                    cumTabReqWidth = cumTabReqWidth + pageInfo['tabreqwidth']
+                    tmp = (2*cumTabReqWidth*availableWidth + sumTabReqWidth) \
+                            / (2 * sumTabReqWidth)
+                    tabwidth = tmp - cumTabWidth
+                    cumTabWidth = tmp
+
+                # Position the tab's button canvas item.
+                self.coords(windowitem, x + borderWidth, tabTop3)
+                self.itemconfigure(windowitem,
+                    width = tabwidth, height = maxTabHeight)
+
+                # Make a beautiful border around the tab.
+                left = x
+                left2 = left + borderWidth
+                left3 = left + borderWidth * 1.5
+                right = left + tabwidth + 2 * borderWidth
+                right2 = left + tabwidth + borderWidth
+                right3 = left + tabwidth + borderWidth * 0.5
+
+                self.coords(lightshadow, 
+                    left, tabBottom2, left, tabTop2, left2, tabTop,
+                    right2, tabTop, right3, tabTop2, left3, tabTop2,
+                    left2, tabTop3, left2, tabBottom,
+                    )
+                self.coords(darkshadow, 
+                    right2, tabTop, right, tabTop2, right, tabBottom2,
+                    right2, tabBottom, right2, tabTop3, right3, tabTop2,
+                    )
+                pageInfo['left'] = left
+                pageInfo['right'] = right
+
+                x = x + tabwidth + 2 * borderWidth
+
+        # Redraw shadow under tabs so that it appears that tab for old
+        # top page is lowered and that tab for new top page is raised.
+        if self._withTabs and (self._pending.has_key('topPage') or
+                self._pending.has_key('tabs') or self._pending.has_key('size')):
+
+            if self.getcurselection() is None:
+                # No pages, so draw line across top of page area.
+                self.coords(self._pageTop1Border,
+                    canvasBorder, self.tabBottom,
+                    hullWidth - canvasBorder, self.tabBottom,
+                    hullWidth - canvasBorder - borderWidth,
+                        self.tabBottom + borderWidth,
+                    borderWidth + canvasBorder, self.tabBottom + borderWidth,
+                    )
+
+                # Ignore second top border.
+                self.coords(self._pageTop2Border, 0, 0, 0, 0, 0, 0)
+            else:
+                # Draw two lines, one on each side of the tab for the
+                # top page, so that the tab appears to be raised.
+                pageInfo = self._pageAttrs[self.getcurselection()]
+                left = pageInfo['left']
+                right = pageInfo['right']
+                self.coords(self._pageTop1Border,
+                    canvasBorder, self.tabBottom,
+                    left, self.tabBottom,
+                    left + borderWidth, self.tabBottom + borderWidth,
+                    canvasBorder + borderWidth, self.tabBottom + borderWidth,
+                    )
+
+                self.coords(self._pageTop2Border,
+                    right, self.tabBottom,
+                    hullWidth - canvasBorder, self.tabBottom,
+                    hullWidth - canvasBorder - borderWidth,
+                        self.tabBottom + borderWidth,
+                    right - borderWidth, self.tabBottom + borderWidth,
+                    )
+
+            # Prevent bottom of dark border of tabs appearing over
+            # page top border.
+            self.tag_raise(self._pageTop1Border)
+            self.tag_raise(self._pageTop2Border)
+
+        # Position the page border shadows.
+        if self._pending.has_key('size') or oldTabBottom != self.tabBottom:
+
+            self.coords(self._pageLeftBorder,
+                canvasBorder, self.tabBottom,
+                borderWidth + canvasBorder,
+                    self.tabBottom + borderWidth,
+                borderWidth + canvasBorder,
+                    hullHeight - canvasBorder - borderWidth,
+                canvasBorder, hullHeight - canvasBorder,
+                )
+
+            self.coords(self._pageBottomRightBorder,
+                hullWidth - canvasBorder, self.tabBottom,
+                hullWidth - canvasBorder, hullHeight - canvasBorder,
+                canvasBorder, hullHeight - canvasBorder,
+                borderWidth + canvasBorder,
+                    hullHeight - canvasBorder - borderWidth,
+                hullWidth - canvasBorder - borderWidth,
+                    hullHeight - canvasBorder - borderWidth,
+                hullWidth - canvasBorder - borderWidth,
+                    self.tabBottom + borderWidth,
+                )
+
+            if not self._withTabs:
+                self.coords(self._pageTopBorder,
+                    canvasBorder, self.tabBottom,
+                    hullWidth - canvasBorder, self.tabBottom,
+                    hullWidth - canvasBorder - borderWidth,
+                        self.tabBottom + borderWidth,
+                    borderWidth + canvasBorder, self.tabBottom + borderWidth,
+                    )
+
+        # Color borders.
+        if self._pending.has_key('borderColor'):
+            self.itemconfigure('lighttag', fill = self._lightBorderColor)
+            self.itemconfigure('darktag', fill = self._darkBorderColor)
+
+        newTopPage = self._pending.get('topPage')
+        pageBorder = borderWidth + self._pageMargin
+
+        # Raise new top page.
+        if newTopPage is not None:
+            self._topPageName = newTopPage
+            self._topPageItem = self.create_window(
+                pageBorder + canvasBorder, self.tabBottom + pageBorder,
+                window = self._pageAttrs[newTopPage]['page'],
+                anchor = 'nw',
+                )
+
+        # Change position of top page if tab height has changed.
+        if self._topPageName is not None and oldTabBottom != self.tabBottom:
+            self.coords(self._topPageItem,
+                    pageBorder + canvasBorder, self.tabBottom + pageBorder)
+
+        # Change size of top page if,
+        #   1) there is a new top page.
+        #   2) canvas size has changed, but not if there is no top
+        #      page (eg:  initially or when all pages deleted).
+        #   3) tab height has changed, due to difference in the height of a tab
+        if (newTopPage is not None or \
+                self._pending.has_key('size') and self._topPageName is not None
+                or oldTabBottom != self.tabBottom):
+            self.itemconfigure(self._topPageItem,
+                width = hullWidth - 2 * canvasBorder - pageBorder * 2,
+                height = hullHeight - 2 * canvasBorder - pageBorder * 2 -
+                    (self.tabBottom - canvasBorder),
+                )
+
+        self._pending = {}
+
+# Need to do forwarding to get the pack, grid, etc methods. 
+# Unfortunately this means that all the other canvas methods are also
+# forwarded.
+forwardmethods(NoteBook, Tkinter.Canvas, '_hull')
+
+######################################################################
+### File: PmwOptionMenu.py
+import types
+import Tkinter
+
+
+class OptionMenu(MegaWidget):
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('command',        None,       None),
+            ('items',          (),         INITOPT),
+            ('initialitem',    None,       INITOPT),
+	    ('labelmargin',    0,          INITOPT),
+	    ('labelpos',       None,       INITOPT),
+	    ('sticky',         'ew',       INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+
+	self._menubutton = self.createcomponent('menubutton',
+		(), None,
+		Tkinter.Menubutton, (interior,),
+		borderwidth = 2,
+		indicatoron = 1,
+		relief = 'raised',
+		anchor = 'c',
+		highlightthickness = 2,
+		direction = 'flush',
+                takefocus = 1,
+	)
+	self._menubutton.grid(column = 2, row = 2, sticky = self['sticky'])
+
+	self._menu = self.createcomponent('menu',
+		(), None,
+		Tkinter.Menu, (self._menubutton,),
+		tearoff=0
+	)
+	self._menubutton.configure(menu = self._menu)
+
+	interior.grid_columnconfigure(2, weight = 1)
+	interior.grid_rowconfigure(2, weight = 1)
+
+        # Create the label.
+        self.createlabel(interior)
+
+        # Add the items specified by the initialisation option.
+	self._itemList = []
+        self.setitems(self['items'], self['initialitem'])
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def setitems(self, items, index = None):
+
+        # Clean up old items and callback commands.
+        for oldIndex in range(len(self._itemList)):
+            tclCommandName = str(self._menu.entrycget(oldIndex, 'command'))
+            if tclCommandName != '':   
+                self._menu.deletecommand(tclCommandName)
+        self._menu.delete(0, 'end')
+	self._itemList = list(items)
+
+	# Set the items in the menu component.
+        for item in items:
+            self._menu.add_command(label = item,
+		command = lambda self = self, item = item: self._invoke(item))
+
+	# Set the currently selected value.
+	if index is None:
+            var = str(self._menubutton.cget('textvariable'))
+	    if var != '':
+		# None means do not change text variable.
+		return
+	    if len(items) == 0:
+		text = ''
+	    elif str(self._menubutton.cget('text')) in items:
+                # Do not change selection if it is still valid
+		return
+	    else:
+		text = items[0]
+	else:
+	    index = self.index(index)
+	    text = self._itemList[index]
+
+        self.setvalue(text)
+
+    def getcurselection(self):
+	var = str(self._menubutton.cget('textvariable'))
+	if var == '':
+	    return str(self._menubutton.cget('text'))
+	else:
+	    return self._menu.tk.globalgetvar(var)
+
+    def getvalue(self):
+        return self.getcurselection()
+
+    def setvalue(self, text):
+	var = str(self._menubutton.cget('textvariable'))
+	if var == '':
+	    self._menubutton.configure(text = text)
+	else:
+	    self._menu.tk.globalsetvar(var, text)
+
+    def index(self, index):
+	listLength = len(self._itemList)
+	if type(index) == types.IntType:
+	    if index &lt; listLength:
+		return index
+	    else:
+		raise ValueError, 'index &quot;%s&quot; is out of range' % index
+	elif index is END:
+	    if listLength &gt; 0:
+		return listLength - 1
+	    else:
+		raise ValueError, 'OptionMenu has no items'
+	else:
+	    if index is SELECT:
+		if listLength &gt; 0:
+		    index = self.getcurselection()
+		else:
+		    raise ValueError, 'OptionMenu has no items'
+            if index in self._itemList:
+                return self._itemList.index(index)
+	    raise ValueError, \
+		    'bad index &quot;%s&quot;: must be a ' \
+                    'name, a number, END or SELECT' % (index,)
+
+    def invoke(self, index = SELECT):
+	index = self.index(index)
+	text = self._itemList[index]
+
+        return self._invoke(text)
+
+    def _invoke(self, text):
+        self.setvalue(text)
+
+	command = self['command']
+	if callable(command):
+	    return command(text)
+
+######################################################################
+### File: PmwPanedWidget.py
+# PanedWidget
+# a frame which may contain several resizable sub-frames
+
+import string
+import sys
+import types
+import Tkinter
+
+
+class PanedWidget(MegaWidget):
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+            ('command',            None,         None),
+            ('orient',             'vertical',   INITOPT),
+            ('separatorrelief',    'sunken',     INITOPT),
+            ('separatorthickness', 2,            INITOPT),
+            ('handlesize',         8,            INITOPT),
+            ('hull_width',         400,          None),
+            ('hull_height',        400,          None),
+	)
+	self.defineoptions(kw, optiondefs,
+                dynamicGroups = ('Frame', 'Separator', 'Handle'))
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	self.bind('&lt;Configure&gt;', self._handleConfigure)
+
+	if self['orient'] not in ('horizontal', 'vertical'):
+	    raise ValueError, 'bad orient option ' + repr(self['orient']) + \
+		': must be either \'horizontal\' or \'vertical\''
+
+        self._separatorThickness = self['separatorthickness']
+        self._handleSize = self['handlesize']
+	self._paneNames = []            # List of pane names
+	self._paneAttrs = {}            # Map from pane name to pane info
+
+	self._timerId = None
+	self._frame = {}
+	self._separator = []
+	self._button = []
+	self._totalSize = 0
+	self._movePending = 0
+	self._relsize = {}
+	self._relmin = {}
+	self._relmax = {}
+	self._size = {}
+	self._min = {}
+	self._max = {}
+	self._rootp = None
+	self._curSize = None
+	self._beforeLimit = None
+	self._afterLimit = None
+	self._buttonIsDown = 0
+	self._majorSize = 100
+	self._minorSize = 100
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def insert(self, name, before = 0, **kw):
+	# Parse &lt;kw&gt; for options.
+        self._initPaneOptions(name)
+	self._parsePaneOptions(name, kw)
+
+	insertPos = self._nameToIndex(before)
+	atEnd = (insertPos == len(self._paneNames))
+
+	# Add the frame.
+	self._paneNames[insertPos:insertPos] = [name]
+	self._frame[name] = self.createcomponent(name,
+		(), 'Frame',
+		Tkinter.Frame, (self.interior(),))
+
+	# Add separator, if necessary.
+	if len(self._paneNames) &gt; 1:
+	    self._addSeparator()
+	else:
+	    self._separator.append(None)
+	    self._button.append(None)
+
+	# Add the new frame and adjust the PanedWidget
+	if atEnd:
+	    size = self._size[name]
+	    if size &gt; 0 or self._relsize[name] is not None:
+		if self['orient'] == 'vertical':
+		    self._frame[name].place(x=0, relwidth=1,
+					    height=size, y=self._totalSize)
+		else:
+		    self._frame[name].place(y=0, relheight=1,
+					    width=size, x=self._totalSize)
+	    else:
+		if self['orient'] == 'vertical':
+		    self._frame[name].place(x=0, relwidth=1,
+					    y=self._totalSize)
+		else:
+		    self._frame[name].place(y=0, relheight=1,
+					    x=self._totalSize)
+	else:
+	    self._updateSizes()
+
+	self._totalSize = self._totalSize + self._size[name]
+	return self._frame[name]
+
+    def add(self, name, **kw):
+        return apply(self.insert, (name, len(self._paneNames)), kw)
+
+    def delete(self, name):
+	deletePos = self._nameToIndex(name)
+	name = self._paneNames[deletePos]
+	self.destroycomponent(name)
+	del self._paneNames[deletePos]
+	del self._frame[name]
+	del self._size[name]
+	del self._min[name]
+	del self._max[name]
+	del self._relsize[name]
+	del self._relmin[name]
+	del self._relmax[name]
+
+	last = len(self._paneNames)
+	del self._separator[last]
+	del self._button[last]
+        if last &gt; 0:
+            self.destroycomponent(self._sepName(last))
+            self.destroycomponent(self._buttonName(last))
+
+	self._plotHandles()
+
+    def setnaturalsize(self):
+        self.update_idletasks()
+        totalWidth = 0
+        totalHeight = 0
+        maxWidth = 0
+        maxHeight = 0
+	for name in self._paneNames:
+            frame = self._frame[name]
+            w = frame.winfo_reqwidth()
+            h = frame.winfo_reqheight()
+            totalWidth = totalWidth + w
+            totalHeight = totalHeight + h
+            if maxWidth &lt; w:
+                maxWidth = w
+            if maxHeight &lt; h:
+                maxHeight = h
+
+        # Note that, since the hull is a frame, the width and height
+        # options specify the geometry *outside* the borderwidth and
+        # highlightthickness.
+        bw = string.atoi(str(self.cget('hull_borderwidth')))
+        hl = string.atoi(str(self.cget('hull_highlightthickness')))
+        extra = (bw + hl) * 2
+        if str(self.cget('orient')) == 'horizontal':
+            totalWidth = totalWidth + extra
+            maxHeight = maxHeight + extra
+            self.configure(hull_width = totalWidth, hull_height = maxHeight)
+        else:
+            totalHeight = (totalHeight + extra +
+                    (len(self._paneNames) - 1) * self._separatorThickness)
+            maxWidth = maxWidth + extra
+            self.configure(hull_width = maxWidth, hull_height = totalHeight)
+
+    def move(self, name, newPos, newPosOffset = 0):
+
+        # see if we can spare ourselves some work
+        numPanes = len(self._paneNames)
+        if numPanes &lt; 2:
+            return
+
+        newPos = self._nameToIndex(newPos) + newPosOffset
+        if newPos &lt; 0 or newPos &gt;=numPanes:
+            return
+
+        deletePos = self._nameToIndex(name)
+
+        if deletePos == newPos:
+            # inserting over ourself is a no-op
+            return
+
+        # delete name from old position in list
+        name = self._paneNames[deletePos]
+        del self._paneNames[deletePos]
+
+        # place in new position
+        self._paneNames[newPos:newPos] = [name]
+
+        # force everything to redraw
+        self._plotHandles()
+        self._updateSizes()
+
+    def _nameToIndex(self, nameOrIndex):
+	try:
+	    pos = self._paneNames.index(nameOrIndex)
+	except ValueError:
+	    pos = nameOrIndex
+
+	return pos
+
+    def _initPaneOptions(self, name):
+	# Set defaults.
+	self._size[name] = 0
+	self._relsize[name] = None
+	self._min[name] = 0
+	self._relmin[name] = None
+	self._max[name] = 100000
+	self._relmax[name] = None
+
+    def _parsePaneOptions(self, name, args):
+	# Parse &lt;args&gt; for options.
+	for arg, value in args.items():
+	    if type(value) == types.FloatType:
+		relvalue = value
+		value = self._absSize(relvalue)
+	    else:
+		relvalue = None
+
+	    if arg == 'size':
+		self._size[name], self._relsize[name] = value, relvalue
+	    elif arg == 'min':
+		self._min[name], self._relmin[name] = value, relvalue
+	    elif arg == 'max':
+		self._max[name], self._relmax[name] = value, relvalue
+	    else:
+		raise ValueError, 'keyword must be &quot;size&quot;, &quot;min&quot;, or &quot;max&quot;'
+
+    def _absSize(self, relvalue):
+	return int(round(relvalue * self._majorSize))
+
+    def _sepName(self, n):
+	return 'separator-%d' % n
+
+    def _buttonName(self, n):
+	return 'handle-%d' % n
+
+    def _addSeparator(self):
+	n = len(self._paneNames) - 1
+
+	downFunc = lambda event, s = self, num=n: s._btnDown(event, num)
+	upFunc = lambda event, s = self, num=n: s._btnUp(event, num)
+	moveFunc = lambda event, s = self, num=n: s._btnMove(event, num)
+
+	# Create the line dividing the panes.
+	sep = self.createcomponent(self._sepName(n),
+		(), 'Separator',
+		Tkinter.Frame, (self.interior(),),
+		borderwidth = 1,
+		relief = self['separatorrelief'])
+	self._separator.append(sep)
+
+	sep.bind('&lt;ButtonPress-1&gt;', downFunc)
+	sep.bind('&lt;Any-ButtonRelease-1&gt;', upFunc)
+	sep.bind('&lt;B1-Motion&gt;', moveFunc)
+
+	if self['orient'] == 'vertical':
+	    cursor = 'sb_v_double_arrow'
+	    sep.configure(height = self._separatorThickness,
+                    width = 10000, cursor = cursor)
+	else:
+	    cursor = 'sb_h_double_arrow'
+	    sep.configure(width = self._separatorThickness,
+                    height = 10000, cursor = cursor)
+
+	self._totalSize = self._totalSize + self._separatorThickness
+
+	# Create the handle on the dividing line.
+	handle = self.createcomponent(self._buttonName(n),
+		(), 'Handle',
+		Tkinter.Frame, (self.interior(),),
+		    relief = 'raised',
+		    borderwidth = 1,
+		    width = self._handleSize,
+		    height = self._handleSize,
+		    cursor = cursor,
+		)
+	self._button.append(handle)
+
+	handle.bind('&lt;ButtonPress-1&gt;', downFunc)
+	handle.bind('&lt;Any-ButtonRelease-1&gt;', upFunc)
+	handle.bind('&lt;B1-Motion&gt;', moveFunc)
+
+	self._plotHandles()
+
+	for i in range(1, len(self._paneNames)):
+	    self._separator[i].tkraise()
+	for i in range(1, len(self._paneNames)):
+	    self._button[i].tkraise()
+
+    def _btnUp(self, event, item):
+	self._buttonIsDown = 0
+	self._updateSizes()
+	try:
+	    self._button[item].configure(relief='raised')
+	except:
+	    pass
+
+    def _btnDown(self, event, item):
+	self._button[item].configure(relief='sunken')
+	self._getMotionLimit(item)
+	self._buttonIsDown = 1
+	self._movePending = 0
+
+    def _handleConfigure(self, event = None):
+	self._getNaturalSizes()
+	if self._totalSize == 0:
+	    return
+
+	iterRange = list(self._paneNames)
+	iterRange.reverse()
+	if self._majorSize &gt; self._totalSize:
+	    n = self._majorSize - self._totalSize
+	    self._iterate(iterRange, self._grow, n)
+	elif self._majorSize &lt; self._totalSize:
+	    n = self._totalSize - self._majorSize
+	    self._iterate(iterRange, self._shrink, n)
+
+	self._plotHandles()
+	self._updateSizes()
+
+    def _getNaturalSizes(self):
+	# Must call this in order to get correct winfo_width, winfo_height
+	self.update_idletasks()
+
+	self._totalSize = 0
+
+	if self['orient'] == 'vertical':
+	    self._majorSize = self.winfo_height()
+	    self._minorSize = self.winfo_width()
+	    majorspec = Tkinter.Frame.winfo_reqheight
+	else:
+	    self._majorSize = self.winfo_width()
+	    self._minorSize = self.winfo_height()
+	    majorspec = Tkinter.Frame.winfo_reqwidth
+
+        bw = string.atoi(str(self.cget('hull_borderwidth')))
+        hl = string.atoi(str(self.cget('hull_highlightthickness')))
+        extra = (bw + hl) * 2
+        self._majorSize = self._majorSize - extra
+        self._minorSize = self._minorSize - extra
+
+	if self._majorSize &lt; 0:
+	    self._majorSize = 0
+	if self._minorSize &lt; 0:
+	    self._minorSize = 0
+
+	for name in self._paneNames:
+	    # adjust the absolute sizes first...
+	    if self._relsize[name] is None:
+		#special case
+		if self._size[name] == 0:
+		    self._size[name] = apply(majorspec, (self._frame[name],))
+		    self._setrel(name)
+	    else:
+		self._size[name] = self._absSize(self._relsize[name])
+
+	    if self._relmin[name] is not None:
+		self._min[name] = self._absSize(self._relmin[name])
+	    if self._relmax[name] is not None:
+		self._max[name] = self._absSize(self._relmax[name])
+
+	    # now adjust sizes
+	    if self._size[name] &lt; self._min[name]:
+		self._size[name] = self._min[name]
+		self._setrel(name)
+
+	    if self._size[name] &gt; self._max[name]:
+		self._size[name] = self._max[name]
+		self._setrel(name)
+
+	    self._totalSize = self._totalSize + self._size[name]
+
+	# adjust for separators
+	self._totalSize = (self._totalSize +
+                (len(self._paneNames) - 1) * self._separatorThickness)
+
+    def _setrel(self, name):
+	if self._relsize[name] is not None:
+	    if self._majorSize != 0:
+		self._relsize[name] = round(self._size[name]) / self._majorSize
+
+    def _iterate(self, names, proc, n):
+	for i in names:
+	    n = apply(proc, (i, n))
+	    if n == 0:
+		break
+
+    def _grow(self, name, n):
+	canGrow = self._max[name] - self._size[name]
+
+	if canGrow &gt; n:
+	    self._size[name] = self._size[name] + n
+	    self._setrel(name)
+	    return 0
+	elif canGrow &gt; 0:
+	    self._size[name] = self._max[name]
+	    self._setrel(name)
+	    n = n - canGrow
+
+	return n
+
+    def _shrink(self, name, n):
+	canShrink = self._size[name] - self._min[name]
+
+	if canShrink &gt; n:
+	    self._size[name] = self._size[name] - n
+	    self._setrel(name)
+	    return 0
+	elif canShrink &gt; 0:
+	    self._size[name] = self._min[name]
+	    self._setrel(name)
+	    n = n - canShrink
+
+	return n
+
+    def _updateSizes(self):
+	totalSize = 0
+
+	for name in self._paneNames:
+	    size = self._size[name]
+	    if self['orient'] == 'vertical':
+		self._frame[name].place(x = 0, relwidth = 1,
+					y = totalSize,
+					height = size)
+	    else:
+		self._frame[name].place(y = 0, relheight = 1,
+					x = totalSize,
+					width = size)
+
+	    totalSize = totalSize + size + self._separatorThickness
+
+	# Invoke the callback command
+	cmd = self['command']
+	if callable(cmd):
+	    cmd(map(lambda x, s = self: s._size[x], self._paneNames))
+
+    def _plotHandles(self):
+	if len(self._paneNames) == 0:
+	    return
+
+	if self['orient'] == 'vertical':
+	    btnp = self._minorSize - 13
+	else:
+	    h = self._minorSize
+
+	    if h &gt; 18:
+		btnp = 9
+	    else:
+		btnp = h - 9
+
+	firstPane = self._paneNames[0]
+	totalSize = self._size[firstPane]
+
+	first = 1
+	last = len(self._paneNames) - 1
+
+	# loop from first to last, inclusive
+	for i in range(1, last + 1):
+
+	    handlepos = totalSize - 3
+	    prevSize = self._size[self._paneNames[i - 1]]
+	    nextSize = self._size[self._paneNames[i]]
+
+	    offset1 = 0
+
+	    if i == first:
+		if prevSize &lt; 4:
+		    offset1 = 4 - prevSize
+	    else:
+		if prevSize &lt; 8:
+		    offset1 = (8 - prevSize) / 2
+
+	    offset2 = 0
+
+	    if i == last:
+		if nextSize &lt; 4:
+		    offset2 = nextSize - 4
+	    else:
+		if nextSize &lt; 8:
+		    offset2 = (nextSize - 8) / 2
+
+	    handlepos = handlepos + offset1
+
+	    if self['orient'] == 'vertical':
+		height = 8 - offset1 + offset2
+
+		if height &gt; 1:
+		    self._button[i].configure(height = height)
+		    self._button[i].place(x = btnp, y = handlepos)
+		else:
+		    self._button[i].place_forget()
+
+		self._separator[i].place(x = 0, y = totalSize,
+					 relwidth = 1)
+	    else:
+		width = 8 - offset1 + offset2
+
+		if width &gt; 1:
+		    self._button[i].configure(width = width)
+		    self._button[i].place(y = btnp, x = handlepos)
+		else:
+		    self._button[i].place_forget()
+
+		self._separator[i].place(y = 0, x = totalSize,
+					 relheight = 1)
+
+	    totalSize = totalSize + nextSize + self._separatorThickness
+
+    def pane(self, name):
+	return self._frame[self._paneNames[self._nameToIndex(name)]]
+
+    # Return the name of all panes
+    def panes(self):
+	return list(self._paneNames)
+
+    def configurepane(self, name, **kw):
+	name = self._paneNames[self._nameToIndex(name)]
+	self._parsePaneOptions(name, kw)
+	self._handleConfigure()
+
+    def updatelayout(self):
+	self._handleConfigure()
+
+    def _getMotionLimit(self, item):
+	curBefore = (item - 1) * self._separatorThickness
+	minBefore, maxBefore = curBefore, curBefore
+
+	for name in self._paneNames[:item]:
+	    curBefore = curBefore + self._size[name]
+	    minBefore = minBefore + self._min[name]
+	    maxBefore = maxBefore + self._max[name]
+
+	curAfter = (len(self._paneNames) - item) * self._separatorThickness
+	minAfter, maxAfter = curAfter, curAfter
+	for name in self._paneNames[item:]:
+	    curAfter = curAfter + self._size[name]
+	    minAfter = minAfter + self._min[name]
+	    maxAfter = maxAfter + self._max[name]
+
+	beforeToGo = min(curBefore - minBefore, maxAfter - curAfter)
+	afterToGo = min(curAfter - minAfter, maxBefore - curBefore)
+
+	self._beforeLimit = curBefore - beforeToGo
+	self._afterLimit = curBefore + afterToGo
+	self._curSize = curBefore
+
+	self._plotHandles()
+
+    # Compress the motion so that update is quick even on slow machines
+    #
+    # theRootp = root position (either rootx or rooty)
+    def _btnMove(self, event, item):
+	self._rootp = event
+
+	if self._movePending == 0:
+	    self._timerId = self.after_idle(
+		    lambda s = self, i = item: s._btnMoveCompressed(i))
+	    self._movePending = 1
+
+    def destroy(self):
+        if self._timerId is not None:
+          self.after_cancel(self._timerId)
+	  self._timerId = None
+        MegaWidget.destroy(self)
+
+    def _btnMoveCompressed(self, item):
+	if not self._buttonIsDown:
+	    return
+
+	if self['orient'] == 'vertical':
+	    p = self._rootp.y_root - self.winfo_rooty()
+	else:
+	    p = self._rootp.x_root - self.winfo_rootx()
+
+	if p == self._curSize:
+	    self._movePending = 0
+	    return
+
+	if p &lt; self._beforeLimit:
+	    p = self._beforeLimit
+
+	if p &gt;= self._afterLimit:
+	    p = self._afterLimit
+
+	self._calculateChange(item, p)
+	self.update_idletasks()
+	self._movePending = 0
+
+    # Calculate the change in response to mouse motions
+    def _calculateChange(self, item, p):
+
+	if p &lt; self._curSize:
+	    self._moveBefore(item, p)
+	elif p &gt; self._curSize:
+	    self._moveAfter(item, p)
+
+	self._plotHandles()
+
+    def _moveBefore(self, item, p):
+	n = self._curSize - p
+
+	# Shrink the frames before
+	iterRange = list(self._paneNames[:item])
+	iterRange.reverse()
+	self._iterate(iterRange, self._shrink, n)
+
+	# Adjust the frames after
+	iterRange = self._paneNames[item:]
+	self._iterate(iterRange, self._grow, n)
+
+	self._curSize = p
+
+    def _moveAfter(self, item, p):
+	n = p - self._curSize
+
+	# Shrink the frames after
+	iterRange = self._paneNames[item:]
+	self._iterate(iterRange, self._shrink, n)
+
+	# Adjust the frames before
+	iterRange = list(self._paneNames[:item])
+	iterRange.reverse()
+	self._iterate(iterRange, self._grow, n)
+
+	self._curSize = p
+
+######################################################################
+### File: PmwPromptDialog.py
+# Based on iwidgets2.2.0/promptdialog.itk code.
+
+
+
+# A Dialog with an entryfield
+
+class PromptDialog(Dialog):
+    def __init__(self, parent = None, **kw):
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('borderx',     20,    INITOPT),
+	    ('bordery',     20,    INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	Dialog.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+	aliases = (
+	    ('entry', 'entryfield_entry'),
+	    ('label', 'entryfield_label'),
+	)
+	self._promptDialogEntry = self.createcomponent('entryfield',
+		aliases, None,
+		EntryField, (interior,))
+	self._promptDialogEntry.pack(fill='x', expand=1,
+		padx = self['borderx'], pady = self['bordery'])
+	
+        if not kw.has_key('activatecommand'):
+            # Whenever this dialog is activated, set the focus to the
+            # EntryField's entry widget.
+            tkentry = self.component('entry')
+            self.configure(activatecommand = tkentry.focus_set)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    # Supply aliases to some of the entry component methods.
+    def insertentry(self, index, text):
+	self._promptDialogEntry.insert(index, text)
+
+    def deleteentry(self, first, last=None):
+	self._promptDialogEntry.delete(first, last)
+
+    def indexentry(self, index):
+	return self._promptDialogEntry.index(index)
+
+forwardmethods(PromptDialog, EntryField, '_promptDialogEntry')
+
+######################################################################
+### File: PmwRadioSelect.py
+import types
+import Tkinter
+
+
+class RadioSelect(MegaWidget):
+    # A collection of several buttons.  In single mode, only one
+    # button may be selected.  In multiple mode, any number of buttons
+    # may be selected.
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('buttontype',    'button',      INITOPT),
+	    ('command',       None,          None),
+	    ('labelmargin',   0,             INITOPT),
+	    ('labelpos',      None,          INITOPT),
+	    ('orient',       'horizontal',   INITOPT),
+	    ('padx',          5,             INITOPT),
+	    ('pady',          5,             INITOPT),
+	    ('selectmode',    'single',      INITOPT),
+	)
+	self.defineoptions(kw, optiondefs, dynamicGroups = ('Button',))
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+	if self['labelpos'] is None:
+	    self._radioSelectFrame = self._hull
+	else:
+	    self._radioSelectFrame = self.createcomponent('frame',
+		    (), None,
+		    Tkinter.Frame, (interior,))
+	    self._radioSelectFrame.grid(column=2, row=2, sticky='nsew')
+	    interior.grid_columnconfigure(2, weight=1)
+	    interior.grid_rowconfigure(2, weight=1)
+
+	    self.createlabel(interior)
+
+	# Initialise instance variables.
+	self._buttonList = []
+	if self['selectmode'] == 'single':
+	    self._singleSelect = 1
+	elif self['selectmode'] == 'multiple':
+	    self._singleSelect = 0
+	else: 
+	    raise ValueError, 'bad selectmode option &quot;' + \
+		    self['selectmode'] + '&quot;: should be single or multiple'
+
+	if self['buttontype'] == 'button':
+	    self.buttonClass = Tkinter.Button
+	elif self['buttontype'] == 'radiobutton':
+	    self._singleSelect = 1
+	    self.var = Tkinter.StringVar()
+	    self.buttonClass = Tkinter.Radiobutton
+	elif self['buttontype'] == 'checkbutton':
+	    self._singleSelect = 0
+	    self.buttonClass = Tkinter.Checkbutton
+	else:
+	    raise ValueError, 'bad buttontype option &quot;' + \
+		    self['buttontype'] + \
+		    '&quot;: should be button, radiobutton or checkbutton'
+
+	if self._singleSelect:
+	    self.selection = None
+	else:
+	    self.selection = []
+
+	if self['orient'] not in ('horizontal', 'vertical'):
+	    raise ValueError, 'bad orient option ' + repr(self['orient']) + \
+		': must be either \'horizontal\' or \'vertical\''
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def getcurselection(self):
+	if self._singleSelect:
+            return self.selection
+        else:
+            return tuple(self.selection)
+
+    def getvalue(self):
+        return self.getcurselection()
+
+    def setvalue(self, textOrList):
+	if self._singleSelect:
+            self.__setSingleValue(textOrList)
+        else:
+	    # Multiple selections
+            oldselection = self.selection
+            self.selection = textOrList
+            for button in self._buttonList:
+                if button in oldselection:
+                    if button not in self.selection:
+                        # button is currently selected but should not be
+                        widget = self.component(button)
+                        if self['buttontype'] == 'checkbutton':
+                            widget.deselect()
+                        else:  # Button
+                            widget.configure(relief='raised')
+                else:
+                    if button in self.selection:
+                        # button is not currently selected but should be
+                        widget = self.component(button)
+                        if self['buttontype'] == 'checkbutton':
+                            widget.select()
+                        else:  # Button
+                            widget.configure(relief='sunken')
+
+    def numbuttons(self):
+        return len(self._buttonList)
+
+    def index(self, index):
+	# Return the integer index of the button with the given index.
+
+	listLength = len(self._buttonList)
+	if type(index) == types.IntType:
+	    if index &lt; listLength:
+		return index
+	    else:
+		raise ValueError, 'index &quot;%s&quot; is out of range' % index
+	elif index is END:
+	    if listLength &gt; 0:
+		return listLength - 1
+	    else:
+		raise ValueError, 'RadioSelect has no buttons'
+	else:
+	    for count in range(listLength):
+		name = self._buttonList[count]
+		if index == name:
+		    return count
+	    validValues = 'a name, a number or END'
+	    raise ValueError, \
+		    'bad index &quot;%s&quot;: must be %s' % (index, validValues)
+
+    def button(self, buttonIndex):
+	name = self._buttonList[self.index(buttonIndex)]
+        return self.component(name)
+
+    def add(self, componentName, **kw):
+	if componentName in self._buttonList:
+	    raise ValueError, 'button &quot;%s&quot; already exists' % componentName
+
+	kw['command'] = \
+                lambda self=self, name=componentName: self.invoke(name)
+	if not kw.has_key('text'):
+	    kw['text'] = componentName
+
+	if self['buttontype'] == 'radiobutton':
+	    if not kw.has_key('anchor'):
+		kw['anchor'] = 'w'
+	    if not kw.has_key('variable'):
+		kw['variable'] = self.var
+	    if not kw.has_key('value'):
+		kw['value'] = kw['text']
+	elif self['buttontype'] == 'checkbutton':
+	    if not kw.has_key('anchor'):
+		kw['anchor'] = 'w'
+
+	button = apply(self.createcomponent, (componentName,
+		(), 'Button',
+		self.buttonClass, (self._radioSelectFrame,)), kw)
+
+	if self['orient'] == 'horizontal':
+	    self._radioSelectFrame.grid_rowconfigure(0, weight=1)
+	    col = len(self._buttonList)
+	    button.grid(column=col, row=0, padx = self['padx'],
+		    pady = self['pady'], sticky='nsew')
+	    self._radioSelectFrame.grid_columnconfigure(col, weight=1)
+	else:
+	    self._radioSelectFrame.grid_columnconfigure(0, weight=1)
+	    row = len(self._buttonList)
+	    button.grid(column=0, row=row, padx = self['padx'],
+		    pady = self['pady'], sticky='ew')
+	    self._radioSelectFrame.grid_rowconfigure(row, weight=1)
+
+	self._buttonList.append(componentName)
+	return button
+
+    def deleteall(self):
+	for name in self._buttonList:
+	    self.destroycomponent(name)
+	self._buttonList = []
+	if self._singleSelect:
+	    self.selection = None
+	else: 
+	    self.selection = []
+
+    def __setSingleValue(self, value):
+            self.selection = value
+            if self['buttontype'] == 'radiobutton':
+                widget = self.component(value)
+                widget.select()
+            else:  # Button
+                for button in self._buttonList:
+                    widget = self.component(button)
+                    if button == value:
+                        widget.configure(relief='sunken')
+                    else:
+                        widget.configure(relief='raised')
+
+    def invoke(self, index):
+	index = self.index(index)
+	name = self._buttonList[index]
+
+	if self._singleSelect:
+            self.__setSingleValue(name)
+	    command = self['command']
+	    if callable(command):
+		return command(name)
+        else:
+	    # Multiple selections
+	    widget = self.component(name)
+	    if name in self.selection:
+		if self['buttontype'] == 'checkbutton':
+		    widget.deselect()
+		else:
+		    widget.configure(relief='raised')
+		self.selection.remove(name)
+		state = 0
+	    else:
+		if self['buttontype'] == 'checkbutton':
+		    widget.select()
+		else:
+		    widget.configure(relief='sunken')
+		self.selection.append(name)
+		state = 1
+
+	    command = self['command']
+	    if callable(command):
+	      return command(name, state)
+
+######################################################################
+### File: PmwScrolledCanvas.py
+import Tkinter
+
+
+class ScrolledCanvas(MegaWidget):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('borderframe',    0,            INITOPT),
+	    ('canvasmargin',   0,            INITOPT),
+	    ('hscrollmode',    'dynamic',    self._hscrollMode),
+	    ('labelmargin',    0,            INITOPT),
+	    ('labelpos',       None,         INITOPT),
+	    ('scrollmargin',   2,            INITOPT),
+	    ('usehullsize',    0,            INITOPT),
+	    ('vscrollmode',    'dynamic',    self._vscrollMode),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	self.origInterior = MegaWidget.interior(self)
+
+	if self['usehullsize']:
+	    self.origInterior.grid_propagate(0)
+
+	if self['borderframe']:
+	    # Create a frame widget to act as the border of the canvas. 
+	    self._borderframe = self.createcomponent('borderframe',
+		    (), None,
+		    Tkinter.Frame, (self.origInterior,),
+		    relief = 'sunken',
+		    borderwidth = 2,
+	    )
+	    self._borderframe.grid(row = 2, column = 2, sticky = 'news')
+
+	    # Create the canvas widget.
+	    self._canvas = self.createcomponent('canvas',
+		    (), None,
+		    Tkinter.Canvas, (self._borderframe,),
+		    highlightthickness = 0,
+		    borderwidth = 0,
+	    )
+	    self._canvas.pack(fill = 'both', expand = 1)
+	else:
+	    # Create the canvas widget.
+	    self._canvas = self.createcomponent('canvas',
+		    (), None,
+		    Tkinter.Canvas, (self.origInterior,),
+		    relief = 'sunken',
+		    borderwidth = 2,
+	    )
+	    self._canvas.grid(row = 2, column = 2, sticky = 'news')
+
+	self.origInterior.grid_rowconfigure(2, weight = 1, minsize = 0)
+	self.origInterior.grid_columnconfigure(2, weight = 1, minsize = 0)
+	
+	# Create the horizontal scrollbar
+	self._horizScrollbar = self.createcomponent('horizscrollbar',
+		(), 'Scrollbar',
+		Tkinter.Scrollbar, (self.origInterior,),
+	        orient='horizontal',
+		command=self._canvas.xview
+	)
+
+	# Create the vertical scrollbar
+	self._vertScrollbar = self.createcomponent('vertscrollbar',
+		(), 'Scrollbar',
+		Tkinter.Scrollbar, (self.origInterior,),
+		orient='vertical',
+		command=self._canvas.yview
+	)
+
+	self.createlabel(self.origInterior, childCols = 3, childRows = 3)
+
+	# Initialise instance variables.
+	self._horizScrollbarOn = 0
+	self._vertScrollbarOn = 0
+	self.scrollTimer = None
+        self._scrollRecurse = 0
+	self._horizScrollbarNeeded = 0
+	self._vertScrollbarNeeded = 0
+	self.setregionTimer = None
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def destroy(self):
+	if self.scrollTimer is not None:
+	    self.after_cancel(self.scrollTimer)
+	    self.scrollTimer = None
+	if self.setregionTimer is not None:
+	    self.after_cancel(self.setregionTimer)
+	    self.setregionTimer = None
+	MegaWidget.destroy(self)
+
+    # ======================================================================
+
+    # Public methods.
+
+    def interior(self):
+	return self._canvas
+
+    def resizescrollregion(self):
+	if self.setregionTimer is None:
+	    self.setregionTimer = self.after_idle(self._setRegion)
+
+    # ======================================================================
+
+    # Configuration methods.
+
+    def _hscrollMode(self):
+	# The horizontal scroll mode has been configured.
+
+	mode = self['hscrollmode']
+
+	if mode == 'static':
+	    if not self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	elif mode == 'dynamic':
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	elif mode == 'none':
+	    if self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	else:
+	    message = 'bad hscrollmode option &quot;%s&quot;: should be static, dynamic, or none' % mode
+	    raise ValueError, message
+
+        self._configureScrollCommands()
+
+    def _vscrollMode(self):
+	# The vertical scroll mode has been configured.
+
+	mode = self['vscrollmode']
+
+	if mode == 'static':
+	    if not self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	elif mode == 'dynamic':
+	    if self._vertScrollbarNeeded != self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	elif mode == 'none':
+	    if self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	else:
+	    message = 'bad vscrollmode option &quot;%s&quot;: should be static, dynamic, or none' % mode
+	    raise ValueError, message
+
+        self._configureScrollCommands()
+
+    # ======================================================================
+
+    # Private methods.
+
+    def _configureScrollCommands(self):
+        # If both scrollmodes are not dynamic we can save a lot of
+        # time by not having to create an idle job to handle the
+        # scroll commands.
+
+        # Clean up previous scroll commands to prevent memory leak.
+        tclCommandName = str(self._canvas.cget('xscrollcommand'))
+        if tclCommandName != '':   
+            self._canvas.deletecommand(tclCommandName)
+        tclCommandName = str(self._canvas.cget('yscrollcommand'))
+        if tclCommandName != '':   
+            self._canvas.deletecommand(tclCommandName)
+
+	if self['hscrollmode'] == self['vscrollmode'] == 'dynamic':
+            self._canvas.configure(
+                    xscrollcommand=self._scrollBothLater,
+                    yscrollcommand=self._scrollBothLater
+            )
+        else:
+            self._canvas.configure(
+                    xscrollcommand=self._scrollXNow,
+                    yscrollcommand=self._scrollYNow
+            )
+
+    def _scrollXNow(self, first, last):
+        self._horizScrollbar.set(first, last)
+        self._horizScrollbarNeeded = ((first, last) != ('0', '1'))
+
+	if self['hscrollmode'] == 'dynamic':
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+
+    def _scrollYNow(self, first, last):
+        self._vertScrollbar.set(first, last)
+        self._vertScrollbarNeeded = ((first, last) != ('0', '1'))
+
+        if self['vscrollmode'] == 'dynamic':
+            if self._vertScrollbarNeeded != self._vertScrollbarOn:
+                self._toggleVertScrollbar()
+
+    def _scrollBothLater(self, first, last):
+	# Called by the canvas to set the horizontal or vertical
+	# scrollbar when it has scrolled or changed scrollregion.
+
+	if self.scrollTimer is None:
+	    self.scrollTimer = self.after_idle(self._scrollBothNow)
+
+    def _scrollBothNow(self):
+        # This performs the function of _scrollXNow and _scrollYNow.
+        # If one is changed, the other should be updated to match.
+	self.scrollTimer = None
+
+        # Call update_idletasks to make sure that the containing frame
+        # has been resized before we attempt to set the scrollbars. 
+        # Otherwise the scrollbars may be mapped/unmapped continuously.
+        self._scrollRecurse = self._scrollRecurse + 1
+        self.update_idletasks()
+        self._scrollRecurse = self._scrollRecurse - 1
+        if self._scrollRecurse != 0:
+            return
+
+	xview = self._canvas.xview()
+	yview = self._canvas.yview()
+	self._horizScrollbar.set(xview[0], xview[1])
+	self._vertScrollbar.set(yview[0], yview[1])
+
+	self._horizScrollbarNeeded = (xview != (0.0, 1.0))
+	self._vertScrollbarNeeded = (yview != (0.0, 1.0))
+
+	# If both horizontal and vertical scrollmodes are dynamic and
+	# currently only one scrollbar is mapped and both should be
+	# toggled, then unmap the mapped scrollbar.  This prevents a
+	# continuous mapping and unmapping of the scrollbars. 
+	if (self['hscrollmode'] == self['vscrollmode'] == 'dynamic' and
+		self._horizScrollbarNeeded != self._horizScrollbarOn and
+		self._vertScrollbarNeeded != self._vertScrollbarOn and
+		self._vertScrollbarOn != self._horizScrollbarOn):
+	    if self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	    else:
+		self._toggleVertScrollbar()
+	    return
+
+	if self['hscrollmode'] == 'dynamic':
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+
+	if self['vscrollmode'] == 'dynamic':
+	    if self._vertScrollbarNeeded != self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+
+    def _toggleHorizScrollbar(self):
+
+	self._horizScrollbarOn = not self._horizScrollbarOn
+
+	interior = self.origInterior
+	if self._horizScrollbarOn:
+	    self._horizScrollbar.grid(row = 4, column = 2, sticky = 'news')
+	    interior.grid_rowconfigure(3, minsize = self['scrollmargin'])
+	else:
+	    self._horizScrollbar.grid_forget()
+	    interior.grid_rowconfigure(3, minsize = 0)
+
+    def _toggleVertScrollbar(self):
+
+	self._vertScrollbarOn = not self._vertScrollbarOn
+
+	interior = self.origInterior
+	if self._vertScrollbarOn:
+	    self._vertScrollbar.grid(row = 2, column = 4, sticky = 'news')
+	    interior.grid_columnconfigure(3, minsize = self['scrollmargin'])
+	else:
+	    self._vertScrollbar.grid_forget()
+	    interior.grid_columnconfigure(3, minsize = 0)
+
+    def _setRegion(self):
+	self.setregionTimer = None
+
+	region = self._canvas.bbox('all')
+        if region is not None:
+	    canvasmargin = self['canvasmargin']
+	    region = (region[0] - canvasmargin, region[1] - canvasmargin,
+		region[2] + canvasmargin, region[3] + canvasmargin)
+	    self._canvas.configure(scrollregion = region)
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)bbox method inherited from Tkinter.Frame.Grid.
+    def bbox(self, *args):
+	return apply(self._canvas.bbox, args)
+
+forwardmethods(ScrolledCanvas, Tkinter.Canvas, '_canvas')
+
+######################################################################
+### File: PmwScrolledField.py
+import Tkinter
+
+
+class ScrolledField(MegaWidget):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('labelmargin',   0,      INITOPT),
+	    ('labelpos',      None,   INITOPT),
+	    ('sticky',        'ew',   INITOPT),
+	    ('text',          '',     self._text),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+	self._scrolledFieldEntry = self.createcomponent('entry',
+		(), None,
+		Tkinter.Entry, (interior,))
+
+        # Can't always use 'disabled', since this greys out text in Tk 8.4.2
+        try:
+            self._scrolledFieldEntry.configure(state = 'readonly')
+        except Tkinter.TclError:
+            self._scrolledFieldEntry.configure(state = 'disabled')
+
+	self._scrolledFieldEntry.grid(column=2, row=2, sticky=self['sticky'])
+	interior.grid_columnconfigure(2, weight=1)
+	interior.grid_rowconfigure(2, weight=1)
+
+	self.createlabel(interior)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def _text(self):
+        text = self['text']
+        self._scrolledFieldEntry.configure(state = 'normal')
+        self._scrolledFieldEntry.delete(0, 'end')
+        self._scrolledFieldEntry.insert('end', text)
+
+        # Can't always use 'disabled', since this greys out text in Tk 8.4.2
+        try:
+            self._scrolledFieldEntry.configure(state = 'readonly')
+        except Tkinter.TclError:
+            self._scrolledFieldEntry.configure(state = 'disabled')
+
+forwardmethods(ScrolledField, Tkinter.Entry, '_scrolledFieldEntry')
+
+######################################################################
+### File: PmwScrolledFrame.py
+import string
+import types
+import Tkinter
+
+
+class ScrolledFrame(MegaWidget):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('borderframe',    1,            INITOPT),
+	    ('horizflex',      'fixed',      self._horizflex),
+	    ('horizfraction',  0.05,         INITOPT),
+	    ('hscrollmode',    'dynamic',    self._hscrollMode),
+	    ('labelmargin',    0,            INITOPT),
+	    ('labelpos',       None,         INITOPT),
+	    ('scrollmargin',   2,            INITOPT),
+	    ('usehullsize',    0,            INITOPT),
+	    ('vertflex',       'fixed',      self._vertflex),
+	    ('vertfraction',   0.05,         INITOPT),
+	    ('vscrollmode',    'dynamic',    self._vscrollMode),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	self.origInterior = MegaWidget.interior(self)
+
+	if self['usehullsize']:
+	    self.origInterior.grid_propagate(0)
+
+	if self['borderframe']:
+	    # Create a frame widget to act as the border of the clipper. 
+	    self._borderframe = self.createcomponent('borderframe',
+		    (), None,
+		    Tkinter.Frame, (self.origInterior,),
+		    relief = 'sunken',
+		    borderwidth = 2,
+	    )
+	    self._borderframe.grid(row = 2, column = 2, sticky = 'news')
+
+	    # Create the clipping window.
+	    self._clipper = self.createcomponent('clipper',
+		    (), None,
+		    Tkinter.Frame, (self._borderframe,),
+		    width = 400,
+		    height = 300,
+		    highlightthickness = 0,
+		    borderwidth = 0,
+	    )
+	    self._clipper.pack(fill = 'both', expand = 1)
+	else:
+	    # Create the clipping window.
+	    self._clipper = self.createcomponent('clipper',
+		    (), None,
+		    Tkinter.Frame, (self.origInterior,),
+		    width = 400,
+		    height = 300,
+		    relief = 'sunken',
+		    borderwidth = 2,
+	    )
+	    self._clipper.grid(row = 2, column = 2, sticky = 'news')
+
+	self.origInterior.grid_rowconfigure(2, weight = 1, minsize = 0)
+	self.origInterior.grid_columnconfigure(2, weight = 1, minsize = 0)
+	
+	# Create the horizontal scrollbar
+	self._horizScrollbar = self.createcomponent('horizscrollbar',
+		(), 'Scrollbar',
+		Tkinter.Scrollbar, (self.origInterior,),
+	        orient='horizontal',
+		command=self.xview
+	)
+
+	# Create the vertical scrollbar
+	self._vertScrollbar = self.createcomponent('vertscrollbar',
+		(), 'Scrollbar',
+		Tkinter.Scrollbar, (self.origInterior,),
+		orient='vertical',
+		command=self.yview
+	)
+
+	self.createlabel(self.origInterior, childCols = 3, childRows = 3)
+
+	# Initialise instance variables.
+	self._horizScrollbarOn = 0
+	self._vertScrollbarOn = 0
+	self.scrollTimer = None
+	self._scrollRecurse = 0
+	self._horizScrollbarNeeded = 0
+	self._vertScrollbarNeeded = 0
+	self.startX = 0
+	self.startY = 0
+	self._flexoptions = ('fixed', 'expand', 'shrink', 'elastic')
+
+	# Create a frame in the clipper to contain the widgets to be
+	# scrolled.
+	self._frame = self.createcomponent('frame',
+		(), None,
+		Tkinter.Frame, (self._clipper,)
+	)
+
+	# Whenever the clipping window or scrolled frame change size,
+	# update the scrollbars.
+	self._frame.bind('&lt;Configure&gt;', self._reposition)
+	self._clipper.bind('&lt;Configure&gt;', self._reposition)
+
+        # Work around a bug in Tk where the value returned by the
+        # scrollbar get() method is (0.0, 0.0, 0.0, 0.0) rather than
+        # the expected 2-tuple.  This occurs if xview() is called soon
+        # after the ScrolledFrame has been created.
+        self._horizScrollbar.set(0.0, 1.0)
+        self._vertScrollbar.set(0.0, 1.0)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def destroy(self):
+	if self.scrollTimer is not None:
+	    self.after_cancel(self.scrollTimer)
+	    self.scrollTimer = None
+	MegaWidget.destroy(self)
+
+    # ======================================================================
+
+    # Public methods.
+
+    def interior(self):
+	return self._frame
+
+    # Set timer to call real reposition method, so that it is not
+    # called multiple times when many things are reconfigured at the
+    # same time.
+    def reposition(self):
+	if self.scrollTimer is None:
+	    self.scrollTimer = self.after_idle(self._scrollBothNow)
+
+    # Called when the user clicks in the horizontal scrollbar. 
+    # Calculates new position of frame then calls reposition() to
+    # update the frame and the scrollbar.
+    def xview(self, mode = None, value = None, units = None):
+
+        if type(value) == types.StringType:
+            value = string.atof(value)
+        if mode is None:
+            return self._horizScrollbar.get()
+	elif mode == 'moveto':
+	    frameWidth = self._frame.winfo_reqwidth()
+	    self.startX = value * float(frameWidth)
+	else: # mode == 'scroll'
+	    clipperWidth = self._clipper.winfo_width()
+	    if units == 'units':
+		jump = int(clipperWidth * self['horizfraction'])
+	    else:
+		jump = clipperWidth
+            self.startX = self.startX + value * jump
+
+	self.reposition()
+
+    # Called when the user clicks in the vertical scrollbar. 
+    # Calculates new position of frame then calls reposition() to
+    # update the frame and the scrollbar.
+    def yview(self, mode = None, value = None, units = None):
+
+        if type(value) == types.StringType:
+            value = string.atof(value)
+        if mode is None:
+            return self._vertScrollbar.get()
+	elif mode == 'moveto':
+	    frameHeight = self._frame.winfo_reqheight()
+	    self.startY = value * float(frameHeight)
+	else: # mode == 'scroll'
+	    clipperHeight = self._clipper.winfo_height()
+	    if units == 'units':
+		jump = int(clipperHeight * self['vertfraction'])
+	    else:
+		jump = clipperHeight
+            self.startY = self.startY + value * jump
+
+	self.reposition()
+
+    # ======================================================================
+
+    # Configuration methods.
+
+    def _hscrollMode(self):
+	# The horizontal scroll mode has been configured.
+
+	mode = self['hscrollmode']
+
+	if mode == 'static':
+	    if not self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	elif mode == 'dynamic':
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	elif mode == 'none':
+	    if self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	else:
+	    message = 'bad hscrollmode option &quot;%s&quot;: should be static, dynamic, or none' % mode
+	    raise ValueError, message
+
+    def _vscrollMode(self):
+	# The vertical scroll mode has been configured.
+
+	mode = self['vscrollmode']
+
+	if mode == 'static':
+	    if not self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	elif mode == 'dynamic':
+	    if self._vertScrollbarNeeded != self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	elif mode == 'none':
+	    if self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	else:
+	    message = 'bad vscrollmode option &quot;%s&quot;: should be static, dynamic, or none' % mode
+	    raise ValueError, message
+
+    def _horizflex(self):
+	# The horizontal flex mode has been configured.
+
+	flex = self['horizflex']
+
+	if flex not in self._flexoptions:
+	    message = 'bad horizflex option &quot;%s&quot;: should be one of %s' % \
+		    (flex, str(self._flexoptions))
+	    raise ValueError, message
+
+	self.reposition()
+
+    def _vertflex(self):
+	# The vertical flex mode has been configured.
+
+	flex = self['vertflex']
+
+	if flex not in self._flexoptions:
+	    message = 'bad vertflex option &quot;%s&quot;: should be one of %s' % \
+		    (flex, str(self._flexoptions))
+	    raise ValueError, message
+
+	self.reposition()
+
+    # ======================================================================
+
+    # Private methods.
+
+    def _reposition(self, event):
+	self.reposition()
+
+    def _getxview(self):
+
+	# Horizontal dimension.
+	clipperWidth = self._clipper.winfo_width()
+	frameWidth = self._frame.winfo_reqwidth()
+	if frameWidth &lt;= clipperWidth:
+	    # The scrolled frame is smaller than the clipping window.
+
+	    self.startX = 0
+	    endScrollX = 1.0
+
+	    if self['horizflex'] in ('expand', 'elastic'):
+		relwidth = 1
+	    else:
+		relwidth = ''
+	else:
+	    # The scrolled frame is larger than the clipping window.
+
+	    if self['horizflex'] in ('shrink', 'elastic'):
+		self.startX = 0
+		endScrollX = 1.0
+		relwidth = 1
+	    else:
+		if self.startX + clipperWidth &gt; frameWidth:
+		    self.startX = frameWidth - clipperWidth
+		    endScrollX = 1.0
+		else:
+		    if self.startX &lt; 0:
+			self.startX = 0
+		    endScrollX = (self.startX + clipperWidth) / float(frameWidth)
+		relwidth = ''
+
+	# Position frame relative to clipper.
+	self._frame.place(x = -self.startX, relwidth = relwidth)
+	return (self.startX / float(frameWidth), endScrollX)
+
+    def _getyview(self):
+
+	# Vertical dimension.
+	clipperHeight = self._clipper.winfo_height()
+	frameHeight = self._frame.winfo_reqheight()
+	if frameHeight &lt;= clipperHeight:
+	    # The scrolled frame is smaller than the clipping window.
+
+	    self.startY = 0
+	    endScrollY = 1.0
+
+	    if self['vertflex'] in ('expand', 'elastic'):
+		relheight = 1
+	    else:
+		relheight = ''
+	else:
+	    # The scrolled frame is larger than the clipping window.
+
+	    if self['vertflex'] in ('shrink', 'elastic'):
+		self.startY = 0
+		endScrollY = 1.0
+		relheight = 1
+	    else:
+		if self.startY + clipperHeight &gt; frameHeight:
+		    self.startY = frameHeight - clipperHeight
+		    endScrollY = 1.0
+		else:
+		    if self.startY &lt; 0:
+			self.startY = 0
+		    endScrollY = (self.startY + clipperHeight) / float(frameHeight)
+		relheight = ''
+
+	# Position frame relative to clipper.
+	self._frame.place(y = -self.startY, relheight = relheight)
+	return (self.startY / float(frameHeight), endScrollY)
+
+    # According to the relative geometries of the frame and the
+    # clipper, reposition the frame within the clipper and reset the
+    # scrollbars.
+    def _scrollBothNow(self):
+	self.scrollTimer = None
+
+        # Call update_idletasks to make sure that the containing frame
+        # has been resized before we attempt to set the scrollbars. 
+        # Otherwise the scrollbars may be mapped/unmapped continuously.
+        self._scrollRecurse = self._scrollRecurse + 1
+        self.update_idletasks()
+        self._scrollRecurse = self._scrollRecurse - 1
+        if self._scrollRecurse != 0:
+            return
+
+	xview = self._getxview()
+	yview = self._getyview()
+	self._horizScrollbar.set(xview[0], xview[1])
+	self._vertScrollbar.set(yview[0], yview[1])
+
+	self._horizScrollbarNeeded = (xview != (0.0, 1.0))
+	self._vertScrollbarNeeded = (yview != (0.0, 1.0))
+
+	# If both horizontal and vertical scrollmodes are dynamic and
+	# currently only one scrollbar is mapped and both should be
+	# toggled, then unmap the mapped scrollbar.  This prevents a
+	# continuous mapping and unmapping of the scrollbars. 
+	if (self['hscrollmode'] == self['vscrollmode'] == 'dynamic' and
+		self._horizScrollbarNeeded != self._horizScrollbarOn and
+		self._vertScrollbarNeeded != self._vertScrollbarOn and
+		self._vertScrollbarOn != self._horizScrollbarOn):
+	    if self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	    else:
+		self._toggleVertScrollbar()
+	    return
+
+	if self['hscrollmode'] == 'dynamic':
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+
+	if self['vscrollmode'] == 'dynamic':
+	    if self._vertScrollbarNeeded != self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+
+    def _toggleHorizScrollbar(self):
+
+	self._horizScrollbarOn = not self._horizScrollbarOn
+
+	interior = self.origInterior
+	if self._horizScrollbarOn:
+	    self._horizScrollbar.grid(row = 4, column = 2, sticky = 'news')
+	    interior.grid_rowconfigure(3, minsize = self['scrollmargin'])
+	else:
+	    self._horizScrollbar.grid_forget()
+	    interior.grid_rowconfigure(3, minsize = 0)
+
+    def _toggleVertScrollbar(self):
+
+	self._vertScrollbarOn = not self._vertScrollbarOn
+
+	interior = self.origInterior
+	if self._vertScrollbarOn:
+	    self._vertScrollbar.grid(row = 2, column = 4, sticky = 'news')
+	    interior.grid_columnconfigure(3, minsize = self['scrollmargin'])
+	else:
+	    self._vertScrollbar.grid_forget()
+	    interior.grid_columnconfigure(3, minsize = 0)
+
+######################################################################
+### File: PmwScrolledListBox.py
+# Based on iwidgets2.2.0/scrolledlistbox.itk code.
+
+import types
+import Tkinter
+
+
+class ScrolledListBox(MegaWidget):
+    _classBindingsDefinedFor = 0
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('dblclickcommand',    None,            None),
+	    ('hscrollmode',        'dynamic',       self._hscrollMode),
+	    ('items',              (),              INITOPT),
+	    ('labelmargin',        0,               INITOPT),
+	    ('labelpos',           None,            INITOPT),
+	    ('scrollmargin',       2,               INITOPT),
+	    ('selectioncommand',   None,            None),
+	    ('usehullsize',        0,               INITOPT),
+	    ('vscrollmode',        'dynamic',       self._vscrollMode),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+
+	if self['usehullsize']:
+	    interior.grid_propagate(0)
+
+	# Create the listbox widget.
+	self._listbox = self.createcomponent('listbox',
+		(), None,
+		Tkinter.Listbox, (interior,))
+	self._listbox.grid(row = 2, column = 2, sticky = 'news')
+	interior.grid_rowconfigure(2, weight = 1, minsize = 0)
+	interior.grid_columnconfigure(2, weight = 1, minsize = 0)
+
+	# Create the horizontal scrollbar
+	self._horizScrollbar = self.createcomponent('horizscrollbar',
+		(), 'Scrollbar',
+		Tkinter.Scrollbar, (interior,),
+	        orient='horizontal',
+		command=self._listbox.xview
+	)
+
+	# Create the vertical scrollbar
+	self._vertScrollbar = self.createcomponent('vertscrollbar',
+		(), 'Scrollbar',
+		Tkinter.Scrollbar, (interior,),
+		orient='vertical',
+		command=self._listbox.yview
+	)
+
+	self.createlabel(interior, childCols = 3, childRows = 3)
+
+	# Add the items specified by the initialisation option.
+	items = self['items']
+	if type(items) != types.TupleType:
+	    items = tuple(items)
+	if len(items) &gt; 0:
+	    apply(self._listbox.insert, ('end',) + items)
+
+	_registerScrolledList(self._listbox, self)
+
+        # Establish the special class bindings if not already done.
+        # Also create bindings if the Tkinter default interpreter has
+        # changed.  Use Tkinter._default_root to create class
+        # bindings, so that a reference to root is created by
+        # bind_class rather than a reference to self, which would
+        # prevent object cleanup.
+        theTag = 'ScrolledListBoxTag'
+        if ScrolledListBox._classBindingsDefinedFor != Tkinter._default_root:
+            root  = Tkinter._default_root
+	    	    
+            def doubleEvent(event):
+                _handleEvent(event, 'double')
+            def keyEvent(event):
+                _handleEvent(event, 'key')
+            def releaseEvent(event):
+                _handleEvent(event, 'release')
+
+            # Bind space and return keys and button 1 to the selectioncommand.
+            root.bind_class(theTag, '&lt;Key-space&gt;', keyEvent)
+            root.bind_class(theTag, '&lt;Key-Return&gt;', keyEvent)
+            root.bind_class(theTag, '&lt;ButtonRelease-1&gt;', releaseEvent)
+
+            # Bind double button 1 click to the dblclickcommand.
+            root.bind_class(theTag, '&lt;Double-ButtonRelease-1&gt;', doubleEvent)
+
+	    ScrolledListBox._classBindingsDefinedFor = root
+
+	bindtags = self._listbox.bindtags()
+	self._listbox.bindtags(bindtags + (theTag,))
+
+	# Initialise instance variables.
+	self._horizScrollbarOn = 0
+	self._vertScrollbarOn = 0
+	self.scrollTimer = None
+        self._scrollRecurse = 0
+	self._horizScrollbarNeeded = 0
+	self._vertScrollbarNeeded = 0
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def destroy(self):
+	if self.scrollTimer is not None:
+	    self.after_cancel(self.scrollTimer)
+	    self.scrollTimer = None
+	_deregisterScrolledList(self._listbox)
+	MegaWidget.destroy(self)
+
+    # ======================================================================
+
+    # Public methods.
+
+    def clear(self):
+	self.setlist(())
+
+    def getcurselection(self):
+	rtn = []
+	for sel in self.curselection():
+	    rtn.append(self._listbox.get(sel))
+	return tuple(rtn)
+
+    def getvalue(self):
+        return self.getcurselection()
+
+    def setvalue(self, textOrList):
+        self._listbox.selection_clear(0, 'end')
+        listitems = list(self._listbox.get(0, 'end'))
+        if type(textOrList) == types.StringType:
+            if textOrList in listitems:
+                self._listbox.selection_set(listitems.index(textOrList))
+            else:
+                raise ValueError, 'no such item &quot;%s&quot;' % textOrList
+        else:
+            for item in textOrList:
+                if item in listitems:
+                    self._listbox.selection_set(listitems.index(item))
+                else:
+                    raise ValueError, 'no such item &quot;%s&quot;' % item
+
+    def setlist(self, items):
+        self._listbox.delete(0, 'end')
+	if len(items) &gt; 0:
+	    if type(items) != types.TupleType:
+		items = tuple(items)
+	    apply(self._listbox.insert, (0,) + items)
+
+    # Override Tkinter.Listbox get method, so that if it is called with
+    # no arguments, return all list elements (consistent with other widgets).
+    def get(self, first=None, last=None):
+	if first is None:
+	    return self._listbox.get(0, 'end')
+	else:
+	    return self._listbox.get(first, last)
+
+    # ======================================================================
+
+    # Configuration methods.
+
+    def _hscrollMode(self):
+	# The horizontal scroll mode has been configured.
+
+	mode = self['hscrollmode']
+
+	if mode == 'static':
+	    if not self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	elif mode == 'dynamic':
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	elif mode == 'none':
+	    if self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	else:
+	    message = 'bad hscrollmode option &quot;%s&quot;: should be static, dynamic, or none' % mode
+	    raise ValueError, message
+
+        self._configureScrollCommands()
+
+    def _vscrollMode(self):
+	# The vertical scroll mode has been configured.
+
+	mode = self['vscrollmode']
+
+	if mode == 'static':
+	    if not self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	elif mode == 'dynamic':
+	    if self._vertScrollbarNeeded != self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	elif mode == 'none':
+	    if self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	else:
+	    message = 'bad vscrollmode option &quot;%s&quot;: should be static, dynamic, or none' % mode
+	    raise ValueError, message
+
+        self._configureScrollCommands()
+
+    # ======================================================================
+
+    # Private methods.
+
+    def _configureScrollCommands(self):
+        # If both scrollmodes are not dynamic we can save a lot of
+        # time by not having to create an idle job to handle the
+        # scroll commands.
+
+        # Clean up previous scroll commands to prevent memory leak.
+        tclCommandName = str(self._listbox.cget('xscrollcommand'))
+        if tclCommandName != '':   
+            self._listbox.deletecommand(tclCommandName)
+        tclCommandName = str(self._listbox.cget('yscrollcommand'))
+        if tclCommandName != '':   
+            self._listbox.deletecommand(tclCommandName)
+
+	if self['hscrollmode'] == self['vscrollmode'] == 'dynamic':
+            self._listbox.configure(
+                    xscrollcommand=self._scrollBothLater,
+                    yscrollcommand=self._scrollBothLater
+            )
+        else:
+            self._listbox.configure(
+                    xscrollcommand=self._scrollXNow,
+                    yscrollcommand=self._scrollYNow
+            )
+
+    def _scrollXNow(self, first, last):
+        self._horizScrollbar.set(first, last)
+        self._horizScrollbarNeeded = ((first, last) != ('0', '1'))
+
+	if self['hscrollmode'] == 'dynamic':
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+
+    def _scrollYNow(self, first, last):
+        self._vertScrollbar.set(first, last)
+        self._vertScrollbarNeeded = ((first, last) != ('0', '1'))
+
+        if self['vscrollmode'] == 'dynamic':
+            if self._vertScrollbarNeeded != self._vertScrollbarOn:
+                self._toggleVertScrollbar()
+
+    def _scrollBothLater(self, first, last):
+	# Called by the listbox to set the horizontal or vertical
+	# scrollbar when it has scrolled or changed size or contents.
+
+	if self.scrollTimer is None:
+	    self.scrollTimer = self.after_idle(self._scrollBothNow)
+
+    def _scrollBothNow(self):
+        # This performs the function of _scrollXNow and _scrollYNow.
+        # If one is changed, the other should be updated to match.
+	self.scrollTimer = None
+
+        # Call update_idletasks to make sure that the containing frame
+        # has been resized before we attempt to set the scrollbars. 
+        # Otherwise the scrollbars may be mapped/unmapped continuously.
+        self._scrollRecurse = self._scrollRecurse + 1
+        self.update_idletasks()
+        self._scrollRecurse = self._scrollRecurse - 1
+        if self._scrollRecurse != 0:
+            return
+
+	xview = self._listbox.xview()
+	yview = self._listbox.yview()
+	self._horizScrollbar.set(xview[0], xview[1])
+	self._vertScrollbar.set(yview[0], yview[1])
+
+	self._horizScrollbarNeeded = (xview != (0.0, 1.0))
+	self._vertScrollbarNeeded = (yview != (0.0, 1.0))
+
+	# If both horizontal and vertical scrollmodes are dynamic and
+	# currently only one scrollbar is mapped and both should be
+	# toggled, then unmap the mapped scrollbar.  This prevents a
+	# continuous mapping and unmapping of the scrollbars. 
+	if (self['hscrollmode'] == self['vscrollmode'] == 'dynamic' and
+		self._horizScrollbarNeeded != self._horizScrollbarOn and
+		self._vertScrollbarNeeded != self._vertScrollbarOn and
+		self._vertScrollbarOn != self._horizScrollbarOn):
+	    if self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	    else:
+		self._toggleVertScrollbar()
+	    return
+
+	if self['hscrollmode'] == 'dynamic':
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+
+	if self['vscrollmode'] == 'dynamic':
+	    if self._vertScrollbarNeeded != self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+
+    def _toggleHorizScrollbar(self):
+
+	self._horizScrollbarOn = not self._horizScrollbarOn
+
+	interior = self.interior()
+	if self._horizScrollbarOn:
+	    self._horizScrollbar.grid(row = 4, column = 2, sticky = 'news')
+	    interior.grid_rowconfigure(3, minsize = self['scrollmargin'])
+	else:
+	    self._horizScrollbar.grid_forget()
+	    interior.grid_rowconfigure(3, minsize = 0)
+
+    def _toggleVertScrollbar(self):
+
+	self._vertScrollbarOn = not self._vertScrollbarOn
+
+	interior = self.interior()
+	if self._vertScrollbarOn:
+	    self._vertScrollbar.grid(row = 2, column = 4, sticky = 'news')
+	    interior.grid_columnconfigure(3, minsize = self['scrollmargin'])
+	else:
+	    self._vertScrollbar.grid_forget()
+	    interior.grid_columnconfigure(3, minsize = 0)
+
+    def _handleEvent(self, event, eventType):
+        if eventType == 'double':
+            command = self['dblclickcommand']
+        elif eventType == 'key':
+            command = self['selectioncommand']
+        else: #eventType == 'release'
+            # Do not execute the command if the mouse was released
+            # outside the listbox.
+            if (event.x &lt; 0 or self._listbox.winfo_width() &lt;= event.x or
+                    event.y &lt; 0 or self._listbox.winfo_height() &lt;= event.y):
+                return
+
+            command = self['selectioncommand']
+
+        if callable(command):
+            command()
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)size method inherited from Tkinter.Frame.Grid.
+    def size(self):
+	return self._listbox.size()
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)bbox method inherited from Tkinter.Frame.Grid.
+    def bbox(self, index):
+	return self._listbox.bbox(index)
+
+forwardmethods(ScrolledListBox, Tkinter.Listbox, '_listbox')
+
+# ======================================================================
+
+_listboxCache = {}
+
+def _registerScrolledList(listbox, scrolledList):
+    # Register an ScrolledList widget for a Listbox widget
+
+    _listboxCache[listbox] = scrolledList
+
+def _deregisterScrolledList(listbox):
+    # Deregister a Listbox widget
+    del _listboxCache[listbox]
+
+def _handleEvent(event, eventType):
+    # Forward events for a Listbox to it's ScrolledListBox
+
+    # A binding earlier in the bindtags list may have destroyed the
+    # megawidget, so need to check.
+    if _listboxCache.has_key(event.widget):
+        _listboxCache[event.widget]._handleEvent(event, eventType)
+
+######################################################################
+### File: PmwScrolledText.py
+# Based on iwidgets2.2.0/scrolledtext.itk code.   
+
+import Tkinter
+
+
+class ScrolledText(MegaWidget):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('borderframe',    0,            INITOPT),
+	    ('columnheader',   0,            INITOPT),
+	    ('hscrollmode',    'dynamic',    self._hscrollMode),
+	    ('labelmargin',    0,            INITOPT),
+	    ('labelpos',       None,         INITOPT),
+	    ('rowcolumnheader',0,            INITOPT),
+	    ('rowheader',      0,            INITOPT),
+	    ('scrollmargin',   2,            INITOPT),
+	    ('usehullsize',    0,            INITOPT),
+	    ('vscrollmode',    'dynamic',    self._vscrollMode),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+
+	if self['usehullsize']:
+	    interior.grid_propagate(0)
+
+	if self['borderframe']:
+	    # Create a frame widget to act as the border of the text 
+	    # widget.  Later, pack the text widget so that it fills
+	    # the frame.  This avoids a problem in Tk, where window
+	    # items in a text widget may overlap the border of the
+	    # text widget.
+	    self._borderframe = self.createcomponent('borderframe',
+		    (), None,
+		    Tkinter.Frame, (interior,),
+		    relief = 'sunken',
+		    borderwidth = 2,
+	    )
+	    self._borderframe.grid(row = 4, column = 4, sticky = 'news')
+
+	    # Create the text widget.
+	    self._textbox = self.createcomponent('text',
+		    (), None,
+		    Tkinter.Text, (self._borderframe,),
+		    highlightthickness = 0,
+		    borderwidth = 0,
+	    )
+	    self._textbox.pack(fill = 'both', expand = 1)
+
+            bw = self._borderframe.cget('borderwidth'),
+            ht = self._borderframe.cget('highlightthickness'),
+	else:
+	    # Create the text widget.
+	    self._textbox = self.createcomponent('text',
+		    (), None,
+		    Tkinter.Text, (interior,),
+	    )
+	    self._textbox.grid(row = 4, column = 4, sticky = 'news')
+
+            bw = self._textbox.cget('borderwidth'),
+            ht = self._textbox.cget('highlightthickness'),
+
+        # Create the header text widgets
+        if self['columnheader']:
+            self._columnheader = self.createcomponent('columnheader',
+                    (), 'Header',
+                    Tkinter.Text, (interior,),
+                    height=1,
+                    wrap='none',
+                    borderwidth = bw,
+                    highlightthickness = ht,
+            )
+            self._columnheader.grid(row = 2, column = 4, sticky = 'ew')
+            self._columnheader.configure(
+                    xscrollcommand = self._columnheaderscrolled)
+
+        if self['rowheader']:
+            self._rowheader = self.createcomponent('rowheader',
+                    (), 'Header',
+                    Tkinter.Text, (interior,),
+                    wrap='none',
+                    borderwidth = bw,
+                    highlightthickness = ht,
+            )
+            self._rowheader.grid(row = 4, column = 2, sticky = 'ns')
+            self._rowheader.configure(
+                    yscrollcommand = self._rowheaderscrolled)
+
+        if self['rowcolumnheader']:
+            self._rowcolumnheader = self.createcomponent('rowcolumnheader',
+                    (), 'Header',
+                    Tkinter.Text, (interior,),
+                    height=1,
+                    wrap='none',
+                    borderwidth = bw,
+                    highlightthickness = ht,
+            )
+            self._rowcolumnheader.grid(row = 2, column = 2, sticky = 'nsew')
+
+	interior.grid_rowconfigure(4, weight = 1, minsize = 0)
+	interior.grid_columnconfigure(4, weight = 1, minsize = 0)
+
+	# Create the horizontal scrollbar
+	self._horizScrollbar = self.createcomponent('horizscrollbar',
+		(), 'Scrollbar',
+		Tkinter.Scrollbar, (interior,),
+	        orient='horizontal',
+		command=self._textbox.xview
+	)
+
+	# Create the vertical scrollbar
+	self._vertScrollbar = self.createcomponent('vertscrollbar',
+		(), 'Scrollbar',
+		Tkinter.Scrollbar, (interior,),
+		orient='vertical',
+		command=self._textbox.yview
+	)
+
+	self.createlabel(interior, childCols = 5, childRows = 5)
+
+	# Initialise instance variables.
+	self._horizScrollbarOn = 0
+	self._vertScrollbarOn = 0
+	self.scrollTimer = None
+        self._scrollRecurse = 0
+	self._horizScrollbarNeeded = 0
+	self._vertScrollbarNeeded = 0
+	self._textWidth = None
+
+        # These four variables avoid an infinite loop caused by the
+        # row or column header's scrollcommand causing the main text
+        # widget's scrollcommand to be called and vice versa.
+	self._textboxLastX = None
+	self._textboxLastY = None
+	self._columnheaderLastX = None
+	self._rowheaderLastY = None
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def destroy(self):
+	if self.scrollTimer is not None:
+	    self.after_cancel(self.scrollTimer)
+	    self.scrollTimer = None
+	MegaWidget.destroy(self)
+
+    # ======================================================================
+
+    # Public methods.
+
+    def clear(self):
+	self.settext('')
+
+    def importfile(self, fileName, where = 'end'):
+	file = open(fileName, 'r')
+	self._textbox.insert(where, file.read())
+	file.close()
+
+    def exportfile(self, fileName):
+	file = open(fileName, 'w')
+	file.write(self._textbox.get('1.0', 'end'))
+	file.close()
+
+    def settext(self, text):
+	disabled = (str(self._textbox.cget('state')) == 'disabled')
+	if disabled:
+	    self._textbox.configure(state='normal')
+	self._textbox.delete('0.0', 'end')
+	self._textbox.insert('end', text)
+	if disabled:
+	    self._textbox.configure(state='disabled')
+
+    # Override Tkinter.Text get method, so that if it is called with
+    # no arguments, return all text (consistent with other widgets).
+    def get(self, first=None, last=None):
+	if first is None:
+	    return self._textbox.get('1.0', 'end')
+	else:
+	    return self._textbox.get(first, last)
+
+    def getvalue(self):
+        return self.get()
+
+    def setvalue(self, text):
+        return self.settext(text)
+
+    def appendtext(self, text):
+        oldTop, oldBottom = self._textbox.yview()
+     
+        disabled = (str(self._textbox.cget('state')) == 'disabled')
+        if disabled:
+            self._textbox.configure(state='normal')
+        self._textbox.insert('end', text)
+        if disabled:
+            self._textbox.configure(state='disabled')
+     
+        if oldBottom == 1.0:
+            self._textbox.yview('moveto', 1.0)
+
+    # ======================================================================
+
+    # Configuration methods.
+
+    def _hscrollMode(self):
+	# The horizontal scroll mode has been configured.
+
+	mode = self['hscrollmode']
+
+	if mode == 'static':
+	    if not self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	elif mode == 'dynamic':
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	elif mode == 'none':
+	    if self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	else:
+	    message = 'bad hscrollmode option &quot;%s&quot;: should be static, dynamic, or none' % mode
+	    raise ValueError, message
+
+        self._configureScrollCommands()
+
+    def _vscrollMode(self):
+	# The vertical scroll mode has been configured.
+
+	mode = self['vscrollmode']
+
+	if mode == 'static':
+	    if not self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	elif mode == 'dynamic':
+	    if self._vertScrollbarNeeded != self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	elif mode == 'none':
+	    if self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+	else:
+	    message = 'bad vscrollmode option &quot;%s&quot;: should be static, dynamic, or none' % mode
+	    raise ValueError, message
+
+        self._configureScrollCommands()
+
+    # ======================================================================
+
+    # Private methods.
+
+    def _configureScrollCommands(self):
+        # If both scrollmodes are not dynamic we can save a lot of
+        # time by not having to create an idle job to handle the
+        # scroll commands.
+
+        # Clean up previous scroll commands to prevent memory leak.
+        tclCommandName = str(self._textbox.cget('xscrollcommand'))
+        if tclCommandName != '':   
+            self._textbox.deletecommand(tclCommandName)
+        tclCommandName = str(self._textbox.cget('yscrollcommand'))
+        if tclCommandName != '':   
+            self._textbox.deletecommand(tclCommandName)
+
+	if self['hscrollmode'] == self['vscrollmode'] == 'dynamic':
+            self._textbox.configure(
+                    xscrollcommand=self._scrollBothLater,
+                    yscrollcommand=self._scrollBothLater
+            )
+        else:
+            self._textbox.configure(
+                    xscrollcommand=self._scrollXNow,
+                    yscrollcommand=self._scrollYNow
+            )
+
+    def _scrollXNow(self, first, last):
+        self._horizScrollbar.set(first, last)
+        self._horizScrollbarNeeded = ((first, last) != ('0', '1'))
+
+        # This code is the same as in _scrollBothNow.  Keep it that way.
+        if self['hscrollmode'] == 'dynamic':
+            currentWidth = self._textbox.winfo_width()
+            if self._horizScrollbarNeeded != self._horizScrollbarOn:
+                if self._horizScrollbarNeeded or \
+                        self._textWidth != currentWidth:
+                    self._toggleHorizScrollbar()
+            self._textWidth = currentWidth
+
+        if self['columnheader']:
+	    if self._columnheaderLastX != first:
+		self._columnheaderLastX = first
+		self._columnheader.xview('moveto', first)
+
+    def _scrollYNow(self, first, last):
+        if first == '0' and last == '0':
+            return
+        self._vertScrollbar.set(first, last)
+        self._vertScrollbarNeeded = ((first, last) != ('0', '1'))
+
+        if self['vscrollmode'] == 'dynamic':
+            if self._vertScrollbarNeeded != self._vertScrollbarOn:
+                self._toggleVertScrollbar()
+
+        if self['rowheader']:
+	    if self._rowheaderLastY != first:
+		self._rowheaderLastY = first
+		self._rowheader.yview('moveto', first)
+
+    def _scrollBothLater(self, first, last):
+	# Called by the text widget to set the horizontal or vertical
+	# scrollbar when it has scrolled or changed size or contents.
+
+	if self.scrollTimer is None:
+	    self.scrollTimer = self.after_idle(self._scrollBothNow)
+
+    def _scrollBothNow(self):
+        # This performs the function of _scrollXNow and _scrollYNow.
+        # If one is changed, the other should be updated to match.
+	self.scrollTimer = None
+
+        # Call update_idletasks to make sure that the containing frame
+        # has been resized before we attempt to set the scrollbars. 
+        # Otherwise the scrollbars may be mapped/unmapped continuously.
+        self._scrollRecurse = self._scrollRecurse + 1
+        self.update_idletasks()
+        self._scrollRecurse = self._scrollRecurse - 1
+        if self._scrollRecurse != 0:
+            return
+
+	xview = self._textbox.xview()
+	yview = self._textbox.yview()
+
+	# The text widget returns a yview of (0.0, 0.0) just after it
+	# has been created. Ignore this.
+	if yview == (0.0, 0.0):
+	    return
+
+        if self['columnheader']:
+	    if self._columnheaderLastX != xview[0]:
+		self._columnheaderLastX = xview[0]
+		self._columnheader.xview('moveto', xview[0])
+        if self['rowheader']:
+	    if self._rowheaderLastY != yview[0]:
+		self._rowheaderLastY = yview[0]
+		self._rowheader.yview('moveto', yview[0])
+
+	self._horizScrollbar.set(xview[0], xview[1])
+	self._vertScrollbar.set(yview[0], yview[1])
+
+	self._horizScrollbarNeeded = (xview != (0.0, 1.0))
+	self._vertScrollbarNeeded = (yview != (0.0, 1.0))
+
+	# If both horizontal and vertical scrollmodes are dynamic and
+	# currently only one scrollbar is mapped and both should be
+	# toggled, then unmap the mapped scrollbar.  This prevents a
+	# continuous mapping and unmapping of the scrollbars. 
+	if (self['hscrollmode'] == self['vscrollmode'] == 'dynamic' and
+		self._horizScrollbarNeeded != self._horizScrollbarOn and
+		self._vertScrollbarNeeded != self._vertScrollbarOn and
+		self._vertScrollbarOn != self._horizScrollbarOn):
+	    if self._horizScrollbarOn:
+		self._toggleHorizScrollbar()
+	    else:
+		self._toggleVertScrollbar()
+	    return
+
+	if self['hscrollmode'] == 'dynamic':
+
+	    # The following test is done to prevent continuous
+	    # mapping and unmapping of the horizontal scrollbar. 
+	    # This may occur when some event (scrolling, resizing
+	    # or text changes) modifies the displayed text such
+	    # that the bottom line in the window is the longest
+	    # line displayed.  If this causes the horizontal
+	    # scrollbar to be mapped, the scrollbar may &quot;cover up&quot;
+	    # the bottom line, which would mean that the scrollbar
+	    # is no longer required.  If the scrollbar is then
+	    # unmapped, the bottom line will then become visible
+	    # again, which would cause the scrollbar to be mapped
+	    # again, and so on...
+	    #
+	    # The idea is that, if the width of the text widget
+	    # has not changed and the scrollbar is currently
+	    # mapped, then do not unmap the scrollbar even if it
+	    # is no longer required.  This means that, during
+	    # normal scrolling of the text, once the horizontal
+	    # scrollbar has been mapped it will not be unmapped
+	    # (until the width of the text widget changes).
+
+	    currentWidth = self._textbox.winfo_width()
+	    if self._horizScrollbarNeeded != self._horizScrollbarOn:
+		if self._horizScrollbarNeeded or \
+			self._textWidth != currentWidth:
+		    self._toggleHorizScrollbar()
+	    self._textWidth = currentWidth
+
+	if self['vscrollmode'] == 'dynamic':
+	    if self._vertScrollbarNeeded != self._vertScrollbarOn:
+		self._toggleVertScrollbar()
+
+    def _columnheaderscrolled(self, first, last):
+	if self._textboxLastX != first:
+	    self._textboxLastX = first
+	    self._textbox.xview('moveto', first)
+
+    def _rowheaderscrolled(self, first, last):
+	if self._textboxLastY != first:
+	    self._textboxLastY = first
+	    self._textbox.yview('moveto', first)
+
+    def _toggleHorizScrollbar(self):
+
+	self._horizScrollbarOn = not self._horizScrollbarOn
+
+	interior = self.interior()
+	if self._horizScrollbarOn:
+	    self._horizScrollbar.grid(row = 6, column = 4, sticky = 'news')
+	    interior.grid_rowconfigure(5, minsize = self['scrollmargin'])
+	else:
+	    self._horizScrollbar.grid_forget()
+	    interior.grid_rowconfigure(5, minsize = 0)
+
+    def _toggleVertScrollbar(self):
+
+	self._vertScrollbarOn = not self._vertScrollbarOn
+
+	interior = self.interior()
+	if self._vertScrollbarOn:
+	    self._vertScrollbar.grid(row = 4, column = 6, sticky = 'news')
+	    interior.grid_columnconfigure(5, minsize = self['scrollmargin'])
+	else:
+	    self._vertScrollbar.grid_forget()
+	    interior.grid_columnconfigure(5, minsize = 0)
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)bbox method inherited from Tkinter.Frame.Grid.
+    def bbox(self, index):
+	return self._textbox.bbox(index)
+
+forwardmethods(ScrolledText, Tkinter.Text, '_textbox')
+
+######################################################################
+### File: PmwHistoryText.py
+
+
+_ORIGINAL = 0
+_MODIFIED = 1
+_DISPLAY = 2
+
+class HistoryText(ScrolledText):
+
+    def __init__(self, parent = None, **kw):
+
+        # Define the megawidget options.
+        optiondefs = (
+	    ('compressany',         1,          None),
+	    ('compresstail',        1,          None),
+            ('historycommand',      None,       None),
+        )
+        self.defineoptions(kw, optiondefs)
+
+        # Initialise the base class (after defining the options).
+        ScrolledText.__init__(self, parent)
+
+        # Initialise instance variables.
+	self._list = []
+	self._currIndex = 0
+	self._pastIndex = None
+	self._lastIndex = 0          # pointer to end of history list
+
+        # Check keywords and initialise options.
+        self.initialiseoptions()
+
+    def addhistory(self):
+	text = self.get()
+	if text[-1] == '\n':
+	    text = text[:-1]
+
+	if len(self._list) == 0:
+            # This is the first history entry.  Add it.
+	    self._list.append([text, text, _MODIFIED])
+            return
+
+        currentEntry =  self._list[self._currIndex]
+        if text == currentEntry[_ORIGINAL]:
+            # The current history entry has not been modified. Check if
+            # we need to add it again.
+
+            if self['compresstail'] and self._currIndex == self._lastIndex:
+                return
+
+            if self['compressany']:
+                return
+
+        # Undo any changes for the current history entry, since they
+        # will now be available in the new entry.
+        currentEntry[_MODIFIED] = currentEntry[_ORIGINAL]
+
+        historycommand = self['historycommand']
+        if self._currIndex == self._lastIndex:
+            # The last history entry is currently being displayed,
+            # so disable the special meaning of the 'Next' button.
+            self._pastIndex = None
+            nextState = 'disabled'
+        else:
+            # A previous history entry is currently being displayed,
+            # so allow the 'Next' button to go to the entry after this one.
+            self._pastIndex = self._currIndex
+            nextState = 'normal'
+        if callable(historycommand):
+            historycommand('normal', nextState)
+
+        # Create the new history entry.
+        self._list.append([text, text, _MODIFIED])
+
+        # Move the pointer into the history entry list to the end.
+        self._lastIndex = self._lastIndex + 1
+        self._currIndex = self._lastIndex
+
+    def next(self):
+	if self._currIndex == self._lastIndex and self._pastIndex is None:
+	    self.bell()
+        else:
+            self._modifyDisplay('next')
+
+    def prev(self):
+        self._pastIndex = None
+	if self._currIndex == 0:
+	    self.bell()
+        else:
+            self._modifyDisplay('prev')
+
+    def undo(self):
+	if len(self._list) != 0:
+            self._modifyDisplay('undo')
+
+    def redo(self):
+	if len(self._list) != 0:
+            self._modifyDisplay('redo')
+
+    def gethistory(self):
+        return self._list
+
+    def _modifyDisplay(self, command):
+        # Modify the display to show either the next or previous
+        # history entry (next, prev) or the original or modified
+        # version of the current history entry (undo, redo).
+
+        # Save the currently displayed text.
+        currentText = self.get()
+        if currentText[-1] == '\n':
+            currentText = currentText[:-1]
+
+        currentEntry =  self._list[self._currIndex]
+        if currentEntry[_DISPLAY] == _MODIFIED:
+            currentEntry[_MODIFIED] = currentText
+        elif currentEntry[_ORIGINAL] != currentText:
+            currentEntry[_MODIFIED] = currentText
+            if command in ('next', 'prev'):
+                currentEntry[_DISPLAY] = _MODIFIED
+
+        if command in ('next', 'prev'):
+            prevstate = 'normal'
+            nextstate = 'normal'
+            if command == 'next':
+                if self._pastIndex is not None:
+                    self._currIndex = self._pastIndex
+                    self._pastIndex = None
+                self._currIndex = self._currIndex + 1
+                if self._currIndex == self._lastIndex:
+                    nextstate = 'disabled'
+            elif command == 'prev':
+                self._currIndex = self._currIndex - 1
+                if self._currIndex == 0:
+                    prevstate = 'disabled'
+            historycommand = self['historycommand']
+            if callable(historycommand):
+                historycommand(prevstate, nextstate)
+            currentEntry =  self._list[self._currIndex]
+        else:
+            if command == 'undo':
+                currentEntry[_DISPLAY] = _ORIGINAL
+            elif command == 'redo':
+                currentEntry[_DISPLAY] = _MODIFIED
+
+        # Display the new text.
+        self.delete('1.0', 'end')
+        self.insert('end', currentEntry[currentEntry[_DISPLAY]])
+
+######################################################################
+### File: PmwSelectionDialog.py
+# Not Based on iwidgets version.
+
+
+
+class SelectionDialog(Dialog):
+    # Dialog window with selection list.
+    
+    # Dialog window displaying a list and requesting the user to
+    # select one.
+
+    def __init__(self, parent = None, **kw):
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('borderx',     10,    INITOPT),
+	    ('bordery',     10,    INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	Dialog.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+	aliases = (
+	    ('listbox', 'scrolledlist_listbox'),
+	    ('label', 'scrolledlist_label'),
+	)
+	self._list = self.createcomponent('scrolledlist',
+		aliases, None,
+		ScrolledListBox, (interior,),
+		dblclickcommand = self.invoke)
+	self._list.pack(side='top', expand='true', fill='both',
+		padx = self['borderx'], pady = self['bordery'])
+
+        if not kw.has_key('activatecommand'):
+            # Whenever this dialog is activated, set the focus to the
+            # ScrolledListBox's listbox widget.
+            listbox = self.component('listbox')
+            self.configure(activatecommand = listbox.focus_set)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)size method inherited from Tkinter.Toplevel.Grid.
+    def size(self):
+	return self.component('listbox').size()
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)bbox method inherited from Tkinter.Toplevel.Grid.
+    def bbox(self, index):
+	return self.component('listbox').size(index)
+
+forwardmethods(SelectionDialog, ScrolledListBox, '_list')
+
+######################################################################
+### File: PmwTextDialog.py
+# A Dialog with a ScrolledText widget.
+
+
+
+class TextDialog(Dialog):
+    def __init__(self, parent = None, **kw):
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('borderx',     10,    INITOPT),
+	    ('bordery',     10,    INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	Dialog.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+	aliases = (
+	    ('text', 'scrolledtext_text'),
+	    ('label', 'scrolledtext_label'),
+	)
+	self._text = self.createcomponent('scrolledtext',
+		aliases, None,
+		ScrolledText, (interior,))
+	self._text.pack(side='top', expand=1, fill='both',
+		padx = self['borderx'], pady = self['bordery'])
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)bbox method inherited from Tkinter.Toplevel.Grid.
+    def bbox(self, index):
+	return self._text.bbox(index)
+
+forwardmethods(TextDialog, ScrolledText, '_text')
+
+######################################################################
+### File: PmwTimeCounter.py
+# Authors: Joe VanAndel and Greg McFarlane
+
+import string
+import sys
+import time
+import Tkinter
+
+
+class TimeCounter(MegaWidget):
+    &quot;&quot;&quot;Up-down counter
+
+    A TimeCounter is a single-line entry widget with Up and Down arrows
+    which increment and decrement the Time value in the entry.  
+    &quot;&quot;&quot;
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('autorepeat',    1,    None),
+	    ('buttonaspect',  1.0,  INITOPT),
+	    ('command',       None, None),
+	    ('initwait',      300,  None),
+	    ('labelmargin',   0,    INITOPT),
+	    ('labelpos',      None, INITOPT),
+	    ('max',           None, self._max),
+	    ('min',           None, self._min),
+	    ('padx',          0,    INITOPT),
+	    ('pady',          0,    INITOPT),
+	    ('repeatrate',    50,   None),
+	    ('value',         None, INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+    	self.arrowDirection = {}
+	self._flag = 'stopped'
+	self._timerId = None
+
+	self._createComponents(kw)
+
+	value = self['value']
+	if value is None:
+	    now = time.time()
+	    value = time.strftime('%H:%M:%S', time.localtime(now))
+    	self.setvalue(value)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def _createComponents(self, kw):
+
+	# Create the components.
+	interior = self.interior()
+
+	# If there is no label, put the arrows and the entry directly
+	# into the interior, otherwise create a frame for them.  In
+	# either case the border around the arrows and the entry will
+	# be raised (but not around the label).
+	if self['labelpos'] is None:
+	    frame = interior
+            if not kw.has_key('hull_relief'):
+                frame.configure(relief = 'raised')
+            if not kw.has_key('hull_borderwidth'):
+                frame.configure(borderwidth = 1)
+	else:
+	    frame = self.createcomponent('frame',
+		    (), None,
+		    Tkinter.Frame, (interior,),
+                    relief = 'raised', borderwidth = 1)
+	    frame.grid(column=2, row=2, sticky='nsew')
+	    interior.grid_columnconfigure(2, weight=1)
+	    interior.grid_rowconfigure(2, weight=1)
+
+	# Create the down arrow buttons.
+
+	# Create the hour down arrow.
+	self._downHourArrowBtn = self.createcomponent('downhourarrow',
+		(), 'Arrow',
+		Tkinter.Canvas, (frame,),
+		width = 16, height = 16, relief = 'raised', borderwidth = 2)
+    	self.arrowDirection[self._downHourArrowBtn] = 'down'
+	self._downHourArrowBtn.grid(column = 0, row = 2)
+
+	# Create the minute down arrow.
+	self._downMinuteArrowBtn = self.createcomponent('downminutearrow',
+		(), 'Arrow',
+		Tkinter.Canvas, (frame,),
+		width = 16, height = 16, relief = 'raised', borderwidth = 2)
+    	self.arrowDirection[self._downMinuteArrowBtn] = 'down'
+	self._downMinuteArrowBtn.grid(column = 1, row = 2)
+
+	# Create the second down arrow.
+	self._downSecondArrowBtn = self.createcomponent('downsecondarrow',
+		(), 'Arrow',
+		Tkinter.Canvas, (frame,),
+		width = 16, height = 16, relief = 'raised', borderwidth = 2)
+    	self.arrowDirection[self._downSecondArrowBtn] = 'down'
+	self._downSecondArrowBtn.grid(column = 2, row = 2)
+
+	# Create the entry fields.
+
+	# Create the hour entry field.
+	self._hourCounterEntry = self.createcomponent('hourentryfield',
+		(('hourentry', 'hourentryfield_entry'),), None,
+		EntryField, (frame,), validate='integer', entry_width = 2)
+	self._hourCounterEntry.grid(column = 0, row = 1, sticky = 'news')
+
+	# Create the minute entry field.
+	self._minuteCounterEntry = self.createcomponent('minuteentryfield',
+		(('minuteentry', 'minuteentryfield_entry'),), None,
+		EntryField, (frame,), validate='integer', entry_width = 2)
+	self._minuteCounterEntry.grid(column = 1, row = 1, sticky = 'news')
+
+	# Create the second entry field.
+	self._secondCounterEntry = self.createcomponent('secondentryfield',
+		(('secondentry', 'secondentryfield_entry'),), None,
+		EntryField, (frame,), validate='integer', entry_width = 2)
+	self._secondCounterEntry.grid(column = 2, row = 1, sticky = 'news')
+
+	# Create the up arrow buttons.
+
+	# Create the hour up arrow.
+	self._upHourArrowBtn = self.createcomponent('uphourarrow',
+		(), 'Arrow',
+		Tkinter.Canvas, (frame,),
+		width = 16, height = 16, relief = 'raised', borderwidth = 2)
+    	self.arrowDirection[self._upHourArrowBtn] = 'up'
+	self._upHourArrowBtn.grid(column = 0, row = 0)
+
+	# Create the minute up arrow.
+	self._upMinuteArrowBtn = self.createcomponent('upminutearrow',
+		(), 'Arrow',
+		Tkinter.Canvas, (frame,),
+		width = 16, height = 16, relief = 'raised', borderwidth = 2)
+    	self.arrowDirection[self._upMinuteArrowBtn] = 'up'
+	self._upMinuteArrowBtn.grid(column = 1, row = 0)
+
+	# Create the second up arrow.
+	self._upSecondArrowBtn = self.createcomponent('upsecondarrow',
+		(), 'Arrow',
+		Tkinter.Canvas, (frame,),
+		width = 16, height = 16, relief = 'raised', borderwidth = 2)
+    	self.arrowDirection[self._upSecondArrowBtn] = 'up'
+	self._upSecondArrowBtn.grid(column = 2, row = 0)
+
+	# Make it resize nicely.
+	padx = self['padx']
+	pady = self['pady']
+	for col in range(3):
+	    frame.grid_columnconfigure(col, weight = 1, pad = padx)
+	frame.grid_rowconfigure(0, pad = pady)
+	frame.grid_rowconfigure(2, pad = pady)
+
+	frame.grid_rowconfigure(1, weight = 1)
+
+	# Create the label.
+	self.createlabel(interior)
+
+	# Set bindings.
+
+	# Up hour
+	self._upHourArrowBtn.bind('&lt;Configure&gt;', 
+		lambda  event, s=self,button=self._upHourArrowBtn: 
+		s._drawArrow(button, 'up'))
+
+	self._upHourArrowBtn.bind('&lt;1&gt;', 
+    	    	lambda event, s=self,button=self._upHourArrowBtn: 
+		s._countUp(button, 3600))
+
+	self._upHourArrowBtn.bind('&lt;Any-ButtonRelease-1&gt;', 
+		lambda event, s=self, button=self._upHourArrowBtn:
+		s._stopUpDown(button))
+
+	# Up minute
+	self._upMinuteArrowBtn.bind('&lt;Configure&gt;', 
+		lambda  event, s=self,button=self._upMinuteArrowBtn: 
+		s._drawArrow(button, 'up'))
+	    
+
+	self._upMinuteArrowBtn.bind('&lt;1&gt;', 
+    	    	lambda event, s=self,button=self._upMinuteArrowBtn: 
+		s._countUp(button, 60))
+
+	self._upMinuteArrowBtn.bind('&lt;Any-ButtonRelease-1&gt;', 
+		lambda event, s=self, button=self._upMinuteArrowBtn:
+		s._stopUpDown(button))
+
+	# Up second
+	self._upSecondArrowBtn.bind('&lt;Configure&gt;', 
+		lambda  event, s=self,button=self._upSecondArrowBtn: 
+		s._drawArrow(button, 'up'))
+	    
+
+	self._upSecondArrowBtn.bind('&lt;1&gt;', 
+    	    	lambda event, s=self,button=self._upSecondArrowBtn: 
+		s._countUp(button, 1))
+
+	self._upSecondArrowBtn.bind('&lt;Any-ButtonRelease-1&gt;', 
+		lambda event, s=self, button=self._upSecondArrowBtn:
+		s._stopUpDown(button))
+
+	# Down hour
+	self._downHourArrowBtn.bind('&lt;Configure&gt;', 
+		lambda  event, s=self,button=self._downHourArrowBtn: 
+		s._drawArrow(button, 'down'))
+
+	self._downHourArrowBtn.bind('&lt;1&gt;', 
+    	    	lambda event, s=self,button=self._downHourArrowBtn: 
+		s._countDown(button, 3600))
+	self._downHourArrowBtn.bind('&lt;Any-ButtonRelease-1&gt;', 
+		lambda event, s=self, button=self._downHourArrowBtn:
+		s._stopUpDown(button))
+
+
+	# Down minute
+	self._downMinuteArrowBtn.bind('&lt;Configure&gt;', 
+		lambda  event, s=self,button=self._downMinuteArrowBtn: 
+		s._drawArrow(button, 'down'))
+
+	self._downMinuteArrowBtn.bind('&lt;1&gt;', 
+    	    	lambda event, s=self,button=self._downMinuteArrowBtn:
+                s._countDown(button, 60))
+	self._downMinuteArrowBtn.bind('&lt;Any-ButtonRelease-1&gt;', 
+		lambda event, s=self, button=self._downMinuteArrowBtn:
+		s._stopUpDown(button))
+
+	# Down second
+	self._downSecondArrowBtn.bind('&lt;Configure&gt;', 
+		lambda  event, s=self,button=self._downSecondArrowBtn: 
+		s._drawArrow(button, 'down'))
+
+	self._downSecondArrowBtn.bind('&lt;1&gt;', 
+    	    	lambda event, s=self, button=self._downSecondArrowBtn: 
+		s._countDown(button,1))
+	self._downSecondArrowBtn.bind('&lt;Any-ButtonRelease-1&gt;', 
+		lambda event, s=self, button=self._downSecondArrowBtn:
+		s._stopUpDown(button))
+
+	self._hourCounterEntry.component('entry').bind(
+                '&lt;Return&gt;', self._invoke)
+	self._minuteCounterEntry.component('entry').bind(
+        	'&lt;Return&gt;', self._invoke)
+	self._secondCounterEntry.component('entry').bind(
+        	'&lt;Return&gt;', self._invoke)
+
+	self._hourCounterEntry.bind('&lt;Configure&gt;', self._resizeArrow)
+	self._minuteCounterEntry.bind('&lt;Configure&gt;', self._resizeArrow)
+	self._secondCounterEntry.bind('&lt;Configure&gt;', self._resizeArrow)
+
+    def _drawArrow(self, arrow, direction):
+        drawarrow(arrow, self['hourentry_foreground'], direction, 'arrow')
+
+    def _resizeArrow(self, event = None):
+	for btn in (self._upHourArrowBtn, self._upMinuteArrowBtn,
+		self._upSecondArrowBtn,
+		self._downHourArrowBtn,
+		self._downMinuteArrowBtn, self._downSecondArrowBtn):
+	    bw = (string.atoi(btn['borderwidth']) +
+		    string.atoi(btn['highlightthickness']))
+	    newHeight = self._hourCounterEntry.winfo_reqheight() - 2 * bw
+	    newWidth = int(newHeight * self['buttonaspect'])
+	    btn.configure(width=newWidth, height=newHeight)
+	    self._drawArrow(btn, self.arrowDirection[btn])
+
+    def _min(self):
+	min = self['min']
+        if min is None:
+	    self._minVal = 0
+	else:
+	    self._minVal = timestringtoseconds(min)
+
+    def _max(self):
+	max = self['max']
+	if max is None:
+	    self._maxVal = None
+	else:
+	    self._maxVal = timestringtoseconds(max)
+
+    def getvalue(self):
+        return self.getstring()
+
+    def setvalue(self, text):
+        list = string.split(text, ':')
+	if len(list) != 3:
+	    raise ValueError, 'invalid value: ' + text
+
+	self._hour = string.atoi(list[0])
+	self._minute = string.atoi(list[1])
+	self._second = string.atoi(list[2]) 
+
+    	self._setHMS()
+
+    def getstring(self):
+    	return '%02d:%02d:%02d' % (self._hour, self._minute, self._second)
+
+    def getint(self):
+    	return self._hour * 3600 + self._minute * 60 + self._second
+
+    def _countUp(self, button, increment):
+	self._relief = self._upHourArrowBtn.cget('relief')
+	button.configure(relief='sunken')
+	self._count(1, 'start', increment)
+
+    def _countDown(self, button, increment):
+
+	self._relief = self._downHourArrowBtn.cget('relief')
+	button.configure(relief='sunken')
+	self._count(-1, 'start', increment)
+
+    def increment(self, seconds = 1):
+	self._count(1, 'force', seconds)
+
+    def decrement(self, seconds = 1):
+	self._count(-1, 'force', seconds)
+
+    def _count(self, factor, newFlag = None, increment = 1):
+	if newFlag != 'force':
+	  if newFlag is not None:
+	    self._flag = newFlag
+
+	  if self._flag == 'stopped':
+	    return
+
+	value = (string.atoi(self._hourCounterEntry.get()) *3600) + \
+	      (string.atoi(self._minuteCounterEntry.get()) *60) + \
+	      string.atoi(self._secondCounterEntry.get()) + \
+	      factor * increment
+	min = self._minVal
+	max = self._maxVal
+	if value &lt; min:
+	  value = min
+	if max is not None and value &gt; max:
+	  value = max
+
+	self._hour = value /3600
+	self._minute = (value - (self._hour*3600)) / 60
+	self._second = value - (self._hour*3600) - (self._minute*60)
+	self._setHMS()
+
+	if newFlag != 'force':
+	  if self['autorepeat']:
+	    if self._flag == 'start':
+	      delay = self['initwait']
+	      self._flag = 'running'
+	    else:
+	      delay = self['repeatrate']
+	    self._timerId = self.after(
+		delay, lambda self=self, factor=factor,increment=increment: 
+		  self._count(factor,'running', increment))
+
+    def _setHMS(self):
+        self._hourCounterEntry.setentry('%02d' % self._hour)
+        self._minuteCounterEntry.setentry('%02d' % self._minute)
+        self._secondCounterEntry.setentry('%02d' % self._second)
+
+    def _stopUpDown(self, button):
+        if self._timerId is not None:
+            self.after_cancel(self._timerId)
+	    self._timerId = None
+        button.configure(relief=self._relief)
+        self._flag = 'stopped'
+
+    def _invoke(self, event):
+        cmd = self['command']
+        if callable(cmd):
+	    cmd()
+
+    def invoke(self):
+        cmd = self['command']
+        if callable(cmd):
+	    return cmd()
+
+    def destroy(self):
+        if self._timerId is not None:
+            self.after_cancel(self._timerId)
+	    self._timerId = None
+        MegaWidget.destroy(self)
+
+######################################################################
+### File: PmwAboutDialog.py
+
+
+class AboutDialog(MessageDialog):
+    # Window to display version and contact information.
+
+    # Class members containing resettable 'default' values:
+    _version = ''
+    _copyright = ''
+    _contact = ''
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('applicationname',   '',          INITOPT),
+	    ('iconpos',           'w',         None),
+	    ('icon_bitmap',       'info',      None),
+	    ('buttons',           ('Close',),  None),
+	    ('defaultbutton',     0,           None),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MessageDialog.__init__(self, parent)
+
+	applicationname = self['applicationname']
+        if not kw.has_key('title'):
+            self.configure(title = 'About ' + applicationname)
+
+        if not kw.has_key('message_text'):
+            text = applicationname + '\n\n'
+            if AboutDialog._version != '':
+              text = text + 'Version ' + AboutDialog._version + '\n'
+            if AboutDialog._copyright != '':
+              text = text + AboutDialog._copyright + '\n\n'
+            if AboutDialog._contact != '':
+              text = text + AboutDialog._contact
+
+            self.configure(message_text=text)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+def aboutversion(value):
+    AboutDialog._version = value
+
+def aboutcopyright(value):
+    AboutDialog._copyright = value
+
+def aboutcontact(value):
+    AboutDialog._contact = value
+
+######################################################################
+### File: PmwComboBox.py
+# Based on iwidgets2.2.0/combobox.itk code.
+
+import os
+import string
+import types
+import Tkinter
+
+
+class ComboBox(MegaWidget):
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('autoclear',          0,          INITOPT),
+	    ('buttonaspect',       1.0,        INITOPT),
+	    ('dropdown',           1,          INITOPT),
+	    ('fliparrow',          0,          INITOPT),
+	    ('history',            1,          INITOPT),
+	    ('labelmargin',        0,          INITOPT),
+	    ('labelpos',           None,       INITOPT),
+	    ('listheight',         200,        INITOPT),
+	    ('selectioncommand',   None,       None),
+	    ('sticky',            'ew',        INITOPT),
+	    ('unique',             1,          INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+
+	self._entryfield = self.createcomponent('entryfield',
+		(('entry', 'entryfield_entry'),), None,
+		EntryField, (interior,))
+	self._entryfield.grid(column=2, row=2, sticky=self['sticky'])
+	interior.grid_columnconfigure(2, weight = 1)
+	self._entryWidget = self._entryfield.component('entry')
+
+	if self['dropdown']:
+	    self._isPosted = 0
+            interior.grid_rowconfigure(2, weight = 1)
+
+	    # Create the arrow button.
+	    self._arrowBtn = self.createcomponent('arrowbutton',
+		    (), None,
+		    Tkinter.Canvas, (interior,), borderwidth = 2,
+		    relief = 'raised',
+		    width = 16, height = 16)
+            if 'n' in self['sticky']:
+                sticky = 'n'
+            else:
+                sticky = ''
+            if 's' in self['sticky']:
+                sticky = sticky + 's'
+	    self._arrowBtn.grid(column=3, row=2, sticky = sticky)
+	    self._arrowRelief = self._arrowBtn.cget('relief')
+
+	    # Create the label.
+	    self.createlabel(interior, childCols=2)
+
+	    # Create the dropdown window.
+	    self._popup = self.createcomponent('popup',
+		    (), None,
+		    Tkinter.Toplevel, (interior,))
+	    self._popup.withdraw()
+	    self._popup.overrideredirect(1)
+
+	    # Create the scrolled listbox inside the dropdown window.
+	    self._list = self.createcomponent('scrolledlist',
+		    (('listbox', 'scrolledlist_listbox'),), None,
+		    ScrolledListBox, (self._popup,),
+		    hull_borderwidth = 2,
+		    hull_relief = 'raised',
+		    hull_height = self['listheight'],
+		    usehullsize = 1,
+		    listbox_exportselection = 0)
+	    self._list.pack(expand=1, fill='both')
+	    self.__listbox = self._list.component('listbox')
+
+	    # Bind events to the arrow button.
+	    self._arrowBtn.bind('&lt;1&gt;', self._postList)
+	    self._arrowBtn.bind('&lt;Configure&gt;', self._drawArrow)
+	    self._arrowBtn.bind('&lt;3&gt;', self._next)
+	    self._arrowBtn.bind('&lt;Shift-3&gt;', self._previous)
+	    self._arrowBtn.bind('&lt;Down&gt;', self._next)
+	    self._arrowBtn.bind('&lt;Up&gt;', self._previous)
+	    self._arrowBtn.bind('&lt;Control-n&gt;', self._next)
+	    self._arrowBtn.bind('&lt;Control-p&gt;', self._previous)
+	    self._arrowBtn.bind('&lt;Shift-Down&gt;', self._postList)
+	    self._arrowBtn.bind('&lt;Shift-Up&gt;', self._postList)
+	    self._arrowBtn.bind('&lt;F34&gt;', self._postList)
+	    self._arrowBtn.bind('&lt;F28&gt;', self._postList)
+	    self._arrowBtn.bind('&lt;space&gt;', self._postList)
+
+	    # Bind events to the dropdown window.
+	    self._popup.bind('&lt;Escape&gt;', self._unpostList)
+	    self._popup.bind('&lt;space&gt;', self._selectUnpost)
+	    self._popup.bind('&lt;Return&gt;', self._selectUnpost)
+	    self._popup.bind('&lt;ButtonRelease-1&gt;', self._dropdownBtnRelease)
+	    self._popup.bind('&lt;ButtonPress-1&gt;', self._unpostOnNextRelease)
+
+	    # Bind events to the Tk listbox.
+	    self.__listbox.bind('&lt;Enter&gt;', self._unpostOnNextRelease)
+
+	    # Bind events to the Tk entry widget.
+	    self._entryWidget.bind('&lt;Configure&gt;', self._resizeArrow)
+	    self._entryWidget.bind('&lt;Shift-Down&gt;', self._postList)
+	    self._entryWidget.bind('&lt;Shift-Up&gt;', self._postList)
+	    self._entryWidget.bind('&lt;F34&gt;', self._postList)
+	    self._entryWidget.bind('&lt;F28&gt;', self._postList)
+
+            # Need to unpost the popup if the entryfield is unmapped (eg: 
+            # its toplevel window is withdrawn) while the popup list is
+            # displayed.
+            self._entryWidget.bind('&lt;Unmap&gt;', self._unpostList)
+
+	else:
+	    # Create the scrolled listbox below the entry field.
+	    self._list = self.createcomponent('scrolledlist',
+		    (('listbox', 'scrolledlist_listbox'),), None,
+		    ScrolledListBox, (interior,),
+                    selectioncommand = self._selectCmd)
+	    self._list.grid(column=2, row=3, sticky='nsew')
+	    self.__listbox = self._list.component('listbox')
+
+	    # The scrolled listbox should expand vertically.
+	    interior.grid_rowconfigure(3, weight = 1)
+
+	    # Create the label.
+	    self.createlabel(interior, childRows=2)
+
+	self._entryWidget.bind('&lt;Down&gt;', self._next)
+	self._entryWidget.bind('&lt;Up&gt;', self._previous)
+	self._entryWidget.bind('&lt;Control-n&gt;', self._next)
+	self._entryWidget.bind('&lt;Control-p&gt;', self._previous)
+	self.__listbox.bind('&lt;Control-n&gt;', self._next)
+	self.__listbox.bind('&lt;Control-p&gt;', self._previous)
+
+	if self['history']:
+	    self._entryfield.configure(command=self._addHistory)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def destroy(self):
+	if self['dropdown'] and self._isPosted:
+            popgrab(self._popup)
+        MegaWidget.destroy(self)
+
+    #======================================================================
+
+    # Public methods
+
+    def get(self, first = None, last=None):
+	if first is None:
+	    return self._entryWidget.get()
+	else:
+	    return self._list.get(first, last)
+
+    def invoke(self):
+	if self['dropdown']:
+	    self._postList()
+	else:
+	    return self._selectCmd()
+
+    def selectitem(self, index, setentry=1):
+	if type(index) == types.StringType:
+	    text = index
+	    items = self._list.get(0, 'end')
+	    if text in items:
+		index = list(items).index(text)
+	    else:
+	    	raise IndexError, 'index &quot;%s&quot; not found' % text
+	elif setentry:
+	    text = self._list.get(0, 'end')[index]
+
+	self._list.select_clear(0, 'end')
+	self._list.select_set(index, index)
+	self._list.activate(index)
+	self.see(index)
+	if setentry:
+	    self._entryfield.setentry(text)
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)size method inherited from Tkinter.Frame.Grid.
+    def size(self):
+	return self._list.size()
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)bbox method inherited from Tkinter.Frame.Grid.
+    def bbox(self, index):
+	return self._list.bbox(index)
+
+    def clear(self):
+	self._entryfield.clear()
+	self._list.clear()
+
+    #======================================================================
+
+    # Private methods for both dropdown and simple comboboxes.
+
+    def _addHistory(self):
+	input = self._entryWidget.get()
+
+	if input != '':
+	    index = None
+	    if self['unique']:
+		# If item is already in list, select it and return.
+		items = self._list.get(0, 'end')
+		if input in items:
+		    index = list(items).index(input)
+
+	    if index is None:
+		index = self._list.index('end')
+		self._list.insert('end', input)
+
+	    self.selectitem(index)
+	    if self['autoclear']:
+		self._entryWidget.delete(0, 'end')
+
+	    # Execute the selectioncommand on the new entry.
+	    self._selectCmd()
+
+    def _next(self, event):
+	size = self.size()
+	if size &lt;= 1:
+	    return
+
+	cursels = self.curselection()
+
+	if len(cursels) == 0:
+	    index = 0
+	else:
+	    index = string.atoi(cursels[0])
+	    if index == size - 1:
+		index = 0
+	    else:
+		index = index + 1
+
+	self.selectitem(index)
+
+    def _previous(self, event):
+	size = self.size()
+	if size &lt;= 1:
+	    return
+
+	cursels = self.curselection()
+
+	if len(cursels) == 0:
+	    index = size - 1
+	else:
+	    index = string.atoi(cursels[0])
+	    if index == 0:
+		index = size - 1
+	    else:
+		index = index - 1
+
+	self.selectitem(index)
+
+    def _selectCmd(self, event=None):
+
+	sels = self.getcurselection()
+	if len(sels) == 0:
+	    item = None
+	else:
+	    item = sels[0]
+	    self._entryfield.setentry(item)
+
+	cmd = self['selectioncommand']
+	if callable(cmd):
+            if event is None:
+                # Return result of selectioncommand for invoke() method.
+                return cmd(item)
+            else:
+                cmd(item)
+
+    #======================================================================
+
+    # Private methods for dropdown combobox.
+
+    def _drawArrow(self, event=None, sunken=0):
+        arrow = self._arrowBtn
+	if sunken:
+	    self._arrowRelief = arrow.cget('relief')
+	    arrow.configure(relief = 'sunken')
+	else:
+	    arrow.configure(relief = self._arrowRelief)
+
+	if self._isPosted and self['fliparrow']:
+            direction = 'up'
+        else:
+            direction = 'down'
+        drawarrow(arrow, self['entry_foreground'], direction, 'arrow')
+
+    def _postList(self, event = None):
+        self._isPosted = 1
+        self._drawArrow(sunken=1)
+
+        # Make sure that the arrow is displayed sunken.
+        self.update_idletasks()
+
+        x = self._entryfield.winfo_rootx()
+        y = self._entryfield.winfo_rooty() + \
+            self._entryfield.winfo_height()
+        w = self._entryfield.winfo_width() + self._arrowBtn.winfo_width()
+        h =  self.__listbox.winfo_height()
+        sh = self.winfo_screenheight()
+
+        if y + h &gt; sh and y &gt; sh / 2:
+            y = self._entryfield.winfo_rooty() - h
+
+        self._list.configure(hull_width=w)
+
+        setgeometryanddeiconify(self._popup, '+%d+%d' % (x, y))
+
+        # Grab the popup, so that all events are delivered to it, and
+        # set focus to the listbox, to make keyboard navigation
+        # easier.
+        pushgrab(self._popup, 1, self._unpostList)
+        self.__listbox.focus_set()
+
+        self._drawArrow()
+
+        # Ignore the first release of the mouse button after posting the
+        # dropdown list, unless the mouse enters the dropdown list.
+        self._ignoreRelease = 1
+
+    def _dropdownBtnRelease(self, event):
+	if (event.widget == self._list.component('vertscrollbar') or
+		event.widget == self._list.component('horizscrollbar')):
+	    return
+
+	if self._ignoreRelease:
+	    self._unpostOnNextRelease()
+	    return
+
+        self._unpostList()
+
+	if (event.x &gt;= 0 and event.x &lt; self.__listbox.winfo_width() and
+		event.y &gt;= 0 and event.y &lt; self.__listbox.winfo_height()):
+	    self._selectCmd()
+
+    def _unpostOnNextRelease(self, event = None):
+	self._ignoreRelease = 0
+
+    def _resizeArrow(self, event):
+	bw = (string.atoi(self._arrowBtn['borderwidth']) + 
+		string.atoi(self._arrowBtn['highlightthickness']))
+	newHeight = self._entryfield.winfo_reqheight() - 2 * bw
+	newWidth = int(newHeight * self['buttonaspect'])
+	self._arrowBtn.configure(width=newWidth, height=newHeight)
+	self._drawArrow()
+
+    def _unpostList(self, event=None):
+	if not self._isPosted:
+            # It is possible to get events on an unposted popup.  For
+            # example, by repeatedly pressing the space key to post
+            # and unpost the popup.  The &lt;space&gt; event may be
+            # delivered to the popup window even though
+            # popgrab() has set the focus away from the
+            # popup window.  (Bug in Tk?)
+            return
+
+        # Restore the focus before withdrawing the window, since
+        # otherwise the window manager may take the focus away so we
+        # can't redirect it.  Also, return the grab to the next active
+        # window in the stack, if any.
+        popgrab(self._popup)
+	self._popup.withdraw()
+
+	self._isPosted = 0
+	self._drawArrow()
+
+    def _selectUnpost(self, event):
+        self._unpostList()
+	self._selectCmd()
+
+forwardmethods(ComboBox, ScrolledListBox, '_list')
+forwardmethods(ComboBox, EntryField, '_entryfield')
+
+######################################################################
+### File: PmwComboBoxDialog.py
+# Not Based on iwidgets version.
+
+
+
+class ComboBoxDialog(Dialog):
+    # Dialog window with simple combobox.
+    
+    # Dialog window displaying a list and entry field and requesting
+    # the user to make a selection or enter a value
+
+    def __init__(self, parent = None, **kw):
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('borderx',    10,              INITOPT),
+	    ('bordery',    10,              INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	Dialog.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+
+	aliases = (
+	    ('listbox', 'combobox_listbox'),
+	    ('scrolledlist', 'combobox_scrolledlist'),
+	    ('entry', 'combobox_entry'),
+	    ('label', 'combobox_label'),
+	)
+	self._combobox = self.createcomponent('combobox',
+		aliases, None,
+		ComboBox, (interior,),
+		scrolledlist_dblclickcommand = self.invoke,
+		dropdown = 0,
+	)
+	self._combobox.pack(side='top', expand='true', fill='both',
+		padx = self['borderx'], pady = self['bordery'])
+
+        if not kw.has_key('activatecommand'):
+            # Whenever this dialog is activated, set the focus to the
+            # ComboBox's listbox widget.
+            listbox = self.component('listbox')
+            self.configure(activatecommand = listbox.focus_set)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)size method inherited from Tkinter.Toplevel.Grid.
+    def size(self):
+	return self._combobox.size()
+
+    # Need to explicitly forward this to override the stupid
+    # (grid_)bbox method inherited from Tkinter.Toplevel.Grid.
+    def bbox(self, index):
+	return self._combobox.bbox(index)
+
+forwardmethods(ComboBoxDialog, ComboBox, '_combobox')
+
+######################################################################
+### File: PmwCounter.py
+import string
+import sys
+import types
+import Tkinter
+
+
+class Counter(MegaWidget):
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('autorepeat',     1,             None),
+	    ('buttonaspect',   1.0,           INITOPT),
+	    ('datatype',       'numeric',     self._datatype),
+	    ('increment',      1,             None),
+	    ('initwait',       300,           None),
+	    ('labelmargin',    0,             INITOPT),
+	    ('labelpos',       None,          INITOPT),
+	    ('orient',         'horizontal',  INITOPT),
+	    ('padx',           0,             INITOPT),
+	    ('pady',           0,             INITOPT),
+	    ('repeatrate',     50,            None),
+	    ('sticky',         'ew',          INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	MegaWidget.__init__(self, parent)
+
+	# Initialise instance variables.
+	self._timerId = None
+	self._normalRelief = None
+
+	# Create the components.
+	interior = self.interior()
+
+	# If there is no label, put the arrows and the entry directly
+	# into the interior, otherwise create a frame for them.  In
+	# either case the border around the arrows and the entry will
+	# be raised (but not around the label).
+	if self['labelpos'] is None:
+	    frame = interior
+            if not kw.has_key('hull_relief'):
+                frame.configure(relief = 'raised')
+            if not kw.has_key('hull_borderwidth'):
+                frame.configure(borderwidth = 1)
+	else:
+	    frame = self.createcomponent('frame',
+		    (), None,
+		    Tkinter.Frame, (interior,),
+                    relief = 'raised', borderwidth = 1)
+	    frame.grid(column=2, row=2, sticky=self['sticky'])
+	    interior.grid_columnconfigure(2, weight=1)
+	    interior.grid_rowconfigure(2, weight=1)
+
+	# Create the down arrow.
+	self._downArrowBtn = self.createcomponent('downarrow',
+		(), 'Arrow',
+		Tkinter.Canvas, (frame,),
+		width = 16, height = 16, relief = 'raised', borderwidth = 2)
+
+	# Create the entry field.
+	self._counterEntry = self.createcomponent('entryfield',
+		(('entry', 'entryfield_entry'),), None,
+		EntryField, (frame,))
+
+	# Create the up arrow.
+	self._upArrowBtn = self.createcomponent('uparrow',
+		(), 'Arrow',
+		Tkinter.Canvas, (frame,),
+		width = 16, height = 16, relief = 'raised', borderwidth = 2)
+
+	padx = self['padx']
+	pady = self['pady']
+	orient = self['orient']
+	if orient == 'horizontal':
+	    self._downArrowBtn.grid(column = 0, row = 0)
+	    self._counterEntry.grid(column = 1, row = 0,
+                    sticky = self['sticky'])
+	    self._upArrowBtn.grid(column = 2, row = 0)
+	    frame.grid_columnconfigure(1, weight = 1)
+	    frame.grid_rowconfigure(0, weight = 1)
+	    if Tkinter.TkVersion &gt;= 4.2:
+		frame.grid_columnconfigure(0, pad = padx)
+		frame.grid_columnconfigure(2, pad = padx)
+		frame.grid_rowconfigure(0, pad = pady)
+	elif orient == 'vertical':
+	    self._upArrowBtn.grid(column = 0, row = 0, sticky = 's')
+	    self._counterEntry.grid(column = 0, row = 1,
+                    sticky = self['sticky'])
+	    self._downArrowBtn.grid(column = 0, row = 2, sticky = 'n')
+	    frame.grid_columnconfigure(0, weight = 1)
+	    frame.grid_rowconfigure(0, weight = 1)
+	    frame.grid_rowconfigure(2, weight = 1)
+	    if Tkinter.TkVersion &gt;= 4.2:
+		frame.grid_rowconfigure(0, pad = pady)
+		frame.grid_rowconfigure(2, pad = pady)
+		frame.grid_columnconfigure(0, pad = padx)
+	else:
+	    raise ValueError, 'bad orient option ' + repr(orient) + \
+		': must be either \'horizontal\' or \'vertical\''
+
+	self.createlabel(interior)
+
+	self._upArrowBtn.bind('&lt;Configure&gt;', self._drawUpArrow)
+	self._upArrowBtn.bind('&lt;1&gt;', self._countUp)
+	self._upArrowBtn.bind('&lt;Any-ButtonRelease-1&gt;', self._stopCounting)
+	self._downArrowBtn.bind('&lt;Configure&gt;', self._drawDownArrow)
+	self._downArrowBtn.bind('&lt;1&gt;', self._countDown)
+	self._downArrowBtn.bind('&lt;Any-ButtonRelease-1&gt;', self._stopCounting)
+	self._counterEntry.bind('&lt;Configure&gt;', self._resizeArrow)
+	entry = self._counterEntry.component('entry')
+	entry.bind('&lt;Down&gt;', lambda event, s = self: s._key_decrement(event))
+	entry.bind('&lt;Up&gt;', lambda event, s = self: s._key_increment(event))
+
+	# Need to cancel the timer if an arrow button is unmapped (eg: 
+	# its toplevel window is withdrawn) while the mouse button is
+	# held down.  The canvas will not get the ButtonRelease event
+	# if it is not mapped, since the implicit grab is cancelled.
+	self._upArrowBtn.bind('&lt;Unmap&gt;', self._stopCounting)
+	self._downArrowBtn.bind('&lt;Unmap&gt;', self._stopCounting)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    def _resizeArrow(self, event):
+	for btn in (self._upArrowBtn, self._downArrowBtn):
+	    bw = (string.atoi(btn['borderwidth']) +
+		    string.atoi(btn['highlightthickness']))
+	    newHeight = self._counterEntry.winfo_reqheight() - 2 * bw
+	    newWidth = int(newHeight * self['buttonaspect'])
+	    btn.configure(width=newWidth, height=newHeight)
+	    self._drawArrow(btn)
+
+    def _drawUpArrow(self, event):
+	self._drawArrow(self._upArrowBtn)
+
+    def _drawDownArrow(self, event):
+	self._drawArrow(self._downArrowBtn)
+
+    def _drawArrow(self, arrow):
+        if self['orient'] == 'vertical':
+            if arrow == self._upArrowBtn:
+                direction = 'up'
+            else:
+                direction = 'down'
+        else:
+            if arrow == self._upArrowBtn:
+                direction = 'right'
+            else:
+                direction = 'left'
+        drawarrow(arrow, self['entry_foreground'], direction, 'arrow')
+
+    def _stopCounting(self, event = None):
+        if self._timerId is not None:
+            self.after_cancel(self._timerId)
+	    self._timerId = None
+	if self._normalRelief is not None:
+	    button, relief = self._normalRelief
+	    button.configure(relief=relief)
+	    self._normalRelief = None
+
+    def _countUp(self, event):
+	self._normalRelief = (self._upArrowBtn, self._upArrowBtn.cget('relief'))
+	self._upArrowBtn.configure(relief='sunken')
+	# Force arrow down (it may come up immediately, if increment fails).
+	self._upArrowBtn.update_idletasks()
+	self._count(1, 1)
+
+    def _countDown(self, event):
+	self._normalRelief = (self._downArrowBtn, self._downArrowBtn.cget('relief'))
+	self._downArrowBtn.configure(relief='sunken')
+	# Force arrow down (it may come up immediately, if increment fails).
+	self._downArrowBtn.update_idletasks()
+	self._count(-1, 1)
+
+    def increment(self):
+	self._forceCount(1)
+
+    def decrement(self):
+	self._forceCount(-1)
+
+    def _key_increment(self, event):
+	self._forceCount(1)
+	self.update_idletasks()
+
+    def _key_decrement(self, event):
+	self._forceCount(-1)
+	self.update_idletasks()
+
+    def _datatype(self):
+	datatype = self['datatype']
+
+	if type(datatype) is types.DictionaryType:
+	    self._counterArgs = datatype.copy()
+	    if self._counterArgs.has_key('counter'):
+		datatype = self._counterArgs['counter']
+		del self._counterArgs['counter']
+	    else:
+		datatype = 'numeric'
+	else:
+	    self._counterArgs = {}
+
+	if _counterCommands.has_key(datatype):
+	    self._counterCommand = _counterCommands[datatype]
+	elif callable(datatype):
+	    self._counterCommand = datatype
+	else:
+	    validValues = _counterCommands.keys()
+	    validValues.sort()
+	    raise ValueError, ('bad datatype value &quot;%s&quot;:  must be a' +
+		    ' function or one of %s') % (datatype, validValues)
+
+    def _forceCount(self, factor):
+	if not self.valid():
+	    self.bell()
+	    return
+
+	text = self._counterEntry.get()
+	try:
+	    value = apply(self._counterCommand,
+		    (text, factor, self['increment']), self._counterArgs)
+	except ValueError:
+	    self.bell()
+	    return
+
+        previousICursor = self._counterEntry.index('insert')
+	if self._counterEntry.setentry(value) == OK:
+	    self._counterEntry.xview('end')
+	    self._counterEntry.icursor(previousICursor)
+
+    def _count(self, factor, first):
+	if not self.valid():
+	    self.bell()
+	    return
+
+	self._timerId = None
+	origtext = self._counterEntry.get()
+	try:
+	    value = apply(self._counterCommand,
+		    (origtext, factor, self['increment']), self._counterArgs)
+	except ValueError:
+	    # If text is invalid, stop counting.
+	    self._stopCounting()
+	    self.bell()
+	    return
+
+	# If incrementing produces an invalid value, restore previous
+	# text and stop counting.
+        previousICursor = self._counterEntry.index('insert')
+	valid = self._counterEntry.setentry(value)
+	if valid != OK:
+	    self._stopCounting()
+	    self._counterEntry.setentry(origtext)
+	    if valid == PARTIAL:
+		self.bell()
+	    return
+	self._counterEntry.xview('end')
+	self._counterEntry.icursor(previousICursor)
+
+	if self['autorepeat']:
+	    if first:
+		delay = self['initwait']
+	    else:
+		delay = self['repeatrate']
+	    self._timerId = self.after(delay,
+		    lambda self=self, factor=factor: self._count(factor, 0))
+
+    def destroy(self):
+	self._stopCounting()
+        MegaWidget.destroy(self)
+
+forwardmethods(Counter, EntryField, '_counterEntry')
+
+def _changeNumber(text, factor, increment):
+  value = string.atol(text)
+  if factor &gt; 0:
+    value = (value / increment) * increment + increment
+  else:
+    value = ((value - 1) / increment) * increment
+
+  # Get rid of the 'L' at the end of longs (in python up to 1.5.2).
+  rtn = str(value)
+  if rtn[-1] == 'L':
+      return rtn[:-1]
+  else:
+      return rtn
+
+def _changeReal(text, factor, increment, separator = '.'):
+  value = stringtoreal(text, separator)
+  div = value / increment
+
+  # Compare reals using str() to avoid problems caused by binary
+  # numbers being only approximations to decimal numbers.
+  # For example, if value is -0.3 and increment is 0.1, then
+  # int(value/increment) = -2, not -3 as one would expect.
+  if str(div)[-2:] == '.0':
+    # value is an even multiple of increment.
+    div = round(div) + factor
+  else:
+    # value is not an even multiple of increment.
+    div = int(div) * 1.0
+    if value &lt; 0:
+      div = div - 1
+    if factor &gt; 0:
+      div = (div + 1)
+
+  value = div * increment
+
+  text = str(value)
+  if separator != '.':
+      index = string.find(text, '.')
+      if index &gt;= 0:
+	text = text[:index] + separator + text[index + 1:]
+  return text
+
+def _changeDate(value, factor, increment, format = 'ymd',
+	separator = '/', yyyy = 0):
+
+  jdn = datestringtojdn(value, format, separator) + factor * increment
+
+  y, m, d = jdntoymd(jdn)
+  result = ''
+  for index in range(3):
+    if index &gt; 0:
+      result = result + separator
+    f = format[index]
+    if f == 'y':
+      if yyyy:
+        result = result + '%02d' % y
+      else:
+        result = result + '%02d' % (y % 100)
+    elif f == 'm':
+      result = result + '%02d' % m
+    elif f == 'd':
+      result = result + '%02d' % d
+
+  return result
+
+_SECSPERDAY = 24 * 60 * 60
+def _changeTime(value, factor, increment, separator = ':', time24 = 0):
+  unixTime = timestringtoseconds(value, separator)
+  if factor &gt; 0:
+    chunks = unixTime / increment + 1
+  else:
+    chunks = (unixTime - 1) / increment
+  unixTime = chunks * increment
+  if time24:
+      while unixTime &lt; 0:
+	  unixTime = unixTime + _SECSPERDAY
+      while unixTime &gt;= _SECSPERDAY:
+	  unixTime = unixTime - _SECSPERDAY
+  if unixTime &lt; 0:
+    unixTime = -unixTime
+    sign = '-'
+  else:
+    sign = ''
+  secs = unixTime % 60
+  unixTime = unixTime / 60
+  mins = unixTime % 60
+  hours = unixTime / 60
+  return '%s%02d%s%02d%s%02d' % (sign, hours, separator, mins, separator, secs)
+
+# hexadecimal, alphabetic, alphanumeric not implemented
+_counterCommands = {
+    'numeric'   : _changeNumber,      # } integer
+    'integer'   : _changeNumber,      # } these two use the same function
+    'real'      : _changeReal,        # real number
+    'time'      : _changeTime,
+    'date'      : _changeDate,
+}
+
+######################################################################
+### File: PmwCounterDialog.py
+
+
+# A Dialog with a counter
+
+class CounterDialog(Dialog):
+
+    def __init__(self, parent = None, **kw):
+
+	# Define the megawidget options.
+	
+	optiondefs = (
+	    ('borderx',    20,  INITOPT),
+	    ('bordery',    20,  INITOPT),
+	)
+	self.defineoptions(kw, optiondefs)
+
+	# Initialise the base class (after defining the options).
+	Dialog.__init__(self, parent)
+
+	# Create the components.
+	interior = self.interior()
+
+	# Create the counter.
+	aliases = (
+	    ('entryfield', 'counter_entryfield'),
+	    ('entry', 'counter_entryfield_entry'),
+	    ('label', 'counter_label')
+	)
+	self._cdCounter = self.createcomponent('counter',
+		aliases, None,
+		Counter, (interior,))
+	self._cdCounter.pack(fill='x', expand=1,
+		padx = self['borderx'], pady = self['bordery'])
+	
+        if not kw.has_key('activatecommand'):
+            # Whenever this dialog is activated, set the focus to the
+            # Counter's entry widget.
+            tkentry = self.component('entry')
+            self.configure(activatecommand = tkentry.focus_set)
+
+	# Check keywords and initialise options.
+	self.initialiseoptions()
+
+    # Supply aliases to some of the entry component methods.
+    def insertentry(self, index, text):
+	self._cdCounter.insert(index, text)
+
+    def deleteentry(self, first, last=None):
+	self._cdCounter.delete(first, last)
+
+    def indexentry(self, index):
+	return self._cdCounter.index(index)
+
+forwardmethods(CounterDialog, Counter, '_cdCounter')
+
+######################################################################
+### File: PmwLogicalFont.py
+import os
+import string
+
+def _font_initialise(root, size=None, fontScheme = None):
+    global _fontSize
+    if size is not None:
+        _fontSize = size
+
+    if fontScheme in ('pmw1', 'pmw2'):
+        if os.name == 'posix':
+            defaultFont = logicalfont('Helvetica')
+            menuFont = logicalfont('Helvetica', weight='bold', slant='italic')
+            scaleFont = logicalfont('Helvetica', slant='italic')
+            root.option_add('*Font',            defaultFont,  'userDefault')
+            root.option_add('*Menu*Font',       menuFont,     'userDefault')
+            root.option_add('*Menubutton*Font', menuFont,     'userDefault')
+            root.option_add('*Scale.*Font',     scaleFont,    'userDefault')
+
+            if fontScheme == 'pmw1':
+                balloonFont = logicalfont('Helvetica', -6, pixel = '12')
+            else: # fontScheme == 'pmw2'
+                balloonFont = logicalfont('Helvetica', -2)
+            root.option_add('*Balloon.*Font', balloonFont, 'userDefault')
+        else:
+            defaultFont = logicalfont('Helvetica')
+            root.option_add('*Font', defaultFont,  'userDefault')
+    elif fontScheme == 'default':
+        defaultFont = ('Helvetica', '-%d' % (_fontSize,), 'bold')
+        entryFont = ('Helvetica', '-%d' % (_fontSize,))
+        textFont = ('Courier', '-%d' % (_fontSize,))
+        root.option_add('*Font',            defaultFont,  'userDefault')
+        root.option_add('*Entry*Font',      entryFont,    'userDefault')
+        root.option_add('*Text*Font',       textFont,     'userDefault')
+
+def logicalfont(name='Helvetica', sizeIncr = 0, **kw):
+  if not _fontInfo.has_key(name):
+    raise ValueError, 'font %s does not exist' % name
+
+  rtn = []
+  for field in _fontFields:
+    if kw.has_key(field):
+      logicalValue = kw[field]
+    elif _fontInfo[name].has_key(field):
+      logicalValue = _fontInfo[name][field]
+    else:
+      logicalValue = '*'
+
+    if _propertyAliases[name].has_key((field, logicalValue)):
+      realValue = _propertyAliases[name][(field, logicalValue)]
+    elif _propertyAliases[name].has_key((field, None)):
+      realValue = _propertyAliases[name][(field, None)]
+    elif _propertyAliases[None].has_key((field, logicalValue)):
+      realValue = _propertyAliases[None][(field, logicalValue)]
+    elif _propertyAliases[None].has_key((field, None)):
+      realValue = _propertyAliases[None][(field, None)]
+    else:
+      realValue = logicalValue
+
+    if field == 'size':
+      if realValue == '*':
+	  realValue = _fontSize
+      realValue = str((realValue + sizeIncr) * 10)
+
+    rtn.append(realValue)
+
+  return string.join(rtn, '-')
+
+def logicalfontnames():
+  return _fontInfo.keys()
+
+if os.name == 'nt':
+    _fontSize = 16
+else:
+    _fontSize = 14
+
+_fontFields = (
+  'registry', 'foundry', 'family', 'weight', 'slant', 'width', 'style',
+  'pixel', 'size', 'xres', 'yres', 'spacing', 'avgwidth', 'charset', 'encoding')
+
+# &lt;_propertyAliases&gt; defines other names for which property values may
+# be known by.  This is required because italics in adobe-helvetica
+# are specified by 'o', while other fonts use 'i'.
+
+_propertyAliases = {}
+
+_propertyAliases[None] = {
+  ('slant', 'italic') : 'i',
+  ('slant', 'normal') : 'r',
+  ('weight', 'light') : 'normal',
+  ('width', 'wide') : 'normal',
+  ('width', 'condensed') : 'normal',
+}
+
+# &lt;_fontInfo&gt; describes a 'logical' font, giving the default values of
+# some of its properties.
+
+_fontInfo = {}
+
+_fontInfo['Helvetica'] = {
+  'foundry' : 'adobe',
+  'family' : 'helvetica',
+  'registry' : '',
+  'charset' : 'iso8859',
+  'encoding' : '1',
+  'spacing' : 'p',
+  'slant' : 'normal',
+  'width' : 'normal',
+  'weight' : 'normal',
+}
+
+_propertyAliases['Helvetica'] = {
+  ('slant', 'italic') : 'o',
+  ('weight', 'normal') : 'medium',
+  ('weight', 'light') : 'medium',
+}
+
+_fontInfo['Times'] = {
+  'foundry' : 'adobe',
+  'family' : 'times',
+  'registry' : '',
+  'charset' : 'iso8859',
+  'encoding' : '1',
+  'spacing' : 'p',
+  'slant' : 'normal',
+  'width' : 'normal',
+  'weight' : 'normal',
+}
+
+_propertyAliases['Times'] = {
+  ('weight', 'normal') : 'medium',
+  ('weight', 'light') : 'medium',
+}
+
+_fontInfo['Fixed'] = {
+  'foundry' : 'misc',
+  'family' : 'fixed',
+  'registry' : '',
+  'charset' : 'iso8859',
+  'encoding' : '1',
+  'spacing' : 'c',
+  'slant' : 'normal',
+  'width' : 'normal',
+  'weight' : 'normal',
+}
+
+_propertyAliases['Fixed'] = {
+  ('weight', 'normal') : 'medium',
+  ('weight', 'light') : 'medium',
+  ('style', None) : '',
+  ('width', 'condensed') : 'semicondensed',
+}
+
+_fontInfo['Courier'] = {
+  'foundry' : 'adobe',
+  'family' : 'courier',
+  'registry' : '',
+  'charset' : 'iso8859',
+  'encoding' : '1',
+  'spacing' : 'm',
+  'slant' : 'normal',
+  'width' : 'normal',
+  'weight' : 'normal',
+}
+
+_propertyAliases['Courier'] = {
+  ('weight', 'normal') : 'medium',
+  ('weight', 'light') : 'medium',
+  ('style', None) : '',
+}
+
+_fontInfo['Typewriter'] = {
+  'foundry' : 'b&amp;h',
+  'family' : 'lucidatypewriter',
+  'registry' : '',
+  'charset' : 'iso8859',
+  'encoding' : '1',
+  'spacing' : 'm',
+  'slant' : 'normal',
+  'width' : 'normal',
+  'weight' : 'normal',
+}
+
+_propertyAliases['Typewriter'] = {
+  ('weight', 'normal') : 'medium',
+  ('weight', 'light') : 'medium',
+}
+
+if os.name == 'nt':
+    # For some reason 'fixed' fonts on NT aren't.
+    _fontInfo['Fixed'] = _fontInfo['Courier']
+    _propertyAliases['Fixed'] = _propertyAliases['Courier']

Added: branches/wspr/PmwBlt.py
===================================================================
--- branches/wspr/PmwBlt.py	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/PmwBlt.py	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,643 @@
+# Python interface to some of the commands of the 2.4 version of the
+# BLT extension to tcl.
+
+import string
+import types
+import Tkinter
+
+# Supported commands:
+_busyCommand = '::blt::busy'
+_vectorCommand = '::blt::vector'
+_graphCommand = '::blt::graph'
+_testCommand = '::blt::*'
+_chartCommand = '::blt::stripchart'
+_tabsetCommand = '::blt::tabset'
+
+_haveBlt = None
+_haveBltBusy = None
+
+def _checkForBlt(window):
+    global _haveBlt
+    global _haveBltBusy
+
+    # Blt may be a package which has not yet been loaded. Try to load it.
+    try:
+	window.tk.call('package', 'require', 'BLT')
+    except Tkinter.TclError:
+	# Another way to try to dynamically load blt:
+	try:
+	    window.tk.call('load', '', 'Blt')
+	except Tkinter.TclError:
+	    pass
+
+    _haveBlt= (window.tk.call('info', 'commands', _testCommand) != '')
+    _haveBltBusy = (window.tk.call('info', 'commands', _busyCommand) != '')
+
+def haveblt(window):
+    if _haveBlt is None:
+	_checkForBlt(window)
+    return _haveBlt
+
+def havebltbusy(window):
+    if _haveBlt is None:
+	_checkForBlt(window)
+    return _haveBltBusy
+
+def _loadBlt(window):
+    if _haveBlt is None:
+	if window is None:
+	    window = Tkinter._default_root
+	    if window is None:
+	    	window = Tkinter.Tk()
+	_checkForBlt(window)
+
+def busy_hold(window, cursor = None):
+    _loadBlt(window)
+    if cursor is None:
+        window.tk.call(_busyCommand, 'hold', window._w)
+    else:
+        window.tk.call(_busyCommand, 'hold', window._w, '-cursor', cursor)
+
+def busy_release(window):
+    _loadBlt(window)
+    window.tk.call(_busyCommand, 'release', window._w)
+
+def busy_forget(window):
+    _loadBlt(window)
+    window.tk.call(_busyCommand, 'forget', window._w)
+
+#=============================================================================
+# Interface to the blt vector command which makes it look like the
+# builtin python list type.
+# The -variable, -command, -watchunset creation options are not supported.
+# The dup, merge, notify, offset, populate, seq and variable methods
+# and the +, -, * and / operations are not supported.
+
+# Blt vector functions:
+def vector_expr(expression):
+    tk = Tkinter._default_root.tk
+    strList = tk.splitlist(tk.call(_vectorCommand, 'expr', expression))
+    return tuple(map(string.atof, strList))
+
+def vector_names(pattern = None):
+    tk = Tkinter._default_root.tk
+    return tk.splitlist(tk.call(_vectorCommand, 'names', pattern))
+
+class Vector:
+    _varnum = 0
+    def __init__(self, size=None, master=None):
+        # &lt;size&gt; can be either an integer size, or a string &quot;first:last&quot;.
+	_loadBlt(master)
+	if master:
+	    self._master = master
+	else:
+	    self._master = Tkinter._default_root
+	self.tk = self._master.tk
+	self._name = 'PY_VEC' + str(Vector._varnum)
+	Vector._varnum = Vector._varnum + 1
+	if size is None:
+	    self.tk.call(_vectorCommand, 'create', self._name)
+	else:
+	  self.tk.call(_vectorCommand, 'create', '%s(%s)' % (self._name, size))
+    def __del__(self):
+	self.tk.call(_vectorCommand, 'destroy', self._name)
+    def __str__(self):
+	return self._name
+
+    def __repr__(self):
+	return '[' + string.join(map(str, self), ', ') + ']'
+    def __cmp__(self, list):
+	return cmp(self[:], list)
+
+    def __len__(self): 
+	return self.tk.getint(self.tk.call(self._name, 'length'))
+    def __getitem__(self, key): 
+	oldkey = key
+	if key &lt; 0:
+	    key = key + len(self)
+	try:
+	    return self.tk.getdouble(self.tk.globalgetvar(self._name, str(key)))
+        except Tkinter.TclError:
+	    raise IndexError, oldkey
+    def __setitem__(self, key, value): 
+	if key &lt; 0:
+	    key = key + len(self)
+	return self.tk.globalsetvar(self._name, str(key), float(value))
+
+    def __delitem__(self, key):
+	if key &lt; 0:
+	    key = key + len(self)
+	return self.tk.globalunsetvar(self._name, str(key))
+
+    def __getslice__(self, start, end):
+	length = len(self)
+	if start &lt; 0:
+	    start = 0
+	if end &gt; length:
+	    end = length
+	if start &gt;= end:
+	    return []
+	end = end - 1  # Blt vector slices include end point.
+	text = self.tk.globalgetvar(self._name, str(start) + ':' + str(end))
+	return map(self.tk.getdouble, self.tk.splitlist(text))
+
+    def __setslice__(self, start, end, list):
+	if start &gt; end:
+	    end = start
+	self.set(self[:start] + list + self[end:])
+
+    def __delslice__(self, start, end):
+	if start &lt; end:
+	    self.set(self[:start] + self[end:])
+
+    def __add__(self, list):
+	return self[:] + list
+    def __radd__(self, list):
+	return list + self[:]
+    def __mul__(self, n):
+	return self[:] * n
+    __rmul__ = __mul__
+
+    # Python builtin list methods:
+    def append(self, *args):
+	self.tk.call(self._name, 'append', args)
+    def count(self, obj):
+	return self[:].count(obj)
+    def index(self, value):
+	return self[:].index(value)
+    def insert(self, index, value):
+	self[index:index] = [value]
+    def remove(self, value):
+	del self[self.index(value)]
+    def reverse(self):
+	s = self[:]
+	s.reverse()
+	self.set(s)
+    def sort(self, *args):
+	s = self[:]
+	s.sort()
+	self.set(s)
+
+    # Blt vector instance methods:
+    # append - same as list method above
+    def clear(self):
+	self.tk.call(self._name, 'clear')
+    def delete(self, *args):
+	self.tk.call((self._name, 'delete') + args)
+    def expr(self, expression):
+	self.tk.call(self._name, 'expr', expression)
+    def length(self, newSize=None): 
+	return self.tk.getint(self.tk.call(self._name, 'length', newSize))
+    def range(self, first, last=None):
+	# Note that, unlike self[first:last], this includes the last
+	# item in the returned range.
+	text = self.tk.call(self._name, 'range', first, last)
+	return map(self.tk.getdouble, self.tk.splitlist(text))
+    def search(self, start, end=None):
+	return self._master._getints(self.tk.call(
+		self._name, 'search', start, end))
+    def set(self, list):
+	if type(list) != types.TupleType:
+	    list = tuple(list)
+	self.tk.call(self._name, 'set', list)
+
+    # The blt vector sort method has different semantics to the python
+    # list sort method.  Call these blt_sort:
+    def blt_sort(self, *args):
+	self.tk.call((self._name, 'sort') + args)
+    def blt_sort_reverse(self, *args):
+	self.tk.call((self._name, 'sort', '-reverse') + args)
+
+    # Special blt vector indexes:
+    def min(self):
+	return self.tk.getdouble(self.tk.globalgetvar(self._name, 'min'))
+    def max(self):
+	return self.tk.getdouble(self.tk.globalgetvar(self._name, 'max'))
+
+    # Method borrowed from Tkinter.Var class:
+    def get(self):
+	return self[:]
+
+#=============================================================================
+
+# This is a general purpose configure routine which can handle the
+# configuration of widgets, items within widgets, etc.  Supports the
+# forms configure() and configure('font') for querying and
+# configure(font = 'fixed', text = 'hello') for setting.
+
+def _doConfigure(widget, subcommand, option, kw):
+
+    if not option and not kw:
+        # Return a description of all options.
+        ret = {}
+        options = widget.tk.splitlist(widget.tk.call(subcommand))
+        for optionString in options:
+            optionInfo = widget.tk.splitlist(optionString)
+            option = optionInfo[0][1:]
+            ret[option] = (option,) + optionInfo[1:]
+        return ret
+
+    if option:
+        # Return a description of the option given by &lt;option&gt;.
+        if kw:
+            # Having keywords implies setting configuration options.
+            # Can't set and get in one command!
+            raise ValueError, 'cannot have option argument with keywords'
+        option = '-' + option
+        optionInfo = widget.tk.splitlist(widget.tk.call(subcommand + (option,)))
+        return (optionInfo[0][1:],) + optionInfo[1:]
+
+    # Otherwise, set the given configuration options.
+    widget.tk.call(subcommand + widget._options(kw))
+
+#=============================================================================
+
+class Graph(Tkinter.Widget):
+    # Wrapper for the blt graph widget, version 2.4.
+
+    def __init__(self, master=None, cnf={}, **kw):
+	_loadBlt(master)
+	Tkinter.Widget.__init__(self, master, _graphCommand, cnf, kw)
+
+    def bar_create(self, name, **kw):
+	self.tk.call((self._w, 'bar', 'create', name) + self._options(kw))
+
+    def line_create(self, name, **kw):
+	self.tk.call((self._w, 'line', 'create', name) + self._options(kw))
+
+    def extents(self, item):
+	return self.tk.getint(self.tk.call(self._w, 'extents', item))
+
+    def invtransform(self, winX, winY):
+	return self._getdoubles(
+		self.tk.call(self._w, 'invtransform', winX, winY))
+
+    def inside(self, x, y):
+	return self.tk.getint(self.tk.call(self._w, 'inside', x, y))
+
+    def snap(self, photoName):
+	self.tk.call(self._w, 'snap', photoName)
+
+    def transform(self, x, y):
+	return self._getdoubles(self.tk.call(self._w, 'transform', x, y))
+
+    def axis_cget(self, axisName, key):
+	return self.tk.call(self._w, 'axis', 'cget', axisName, '-' + key)
+    def axis_configure(self, axes, option=None, **kw):
+        # &lt;axes&gt; may be a list of axisNames.
+	if type(axes) == types.StringType:
+            axes = [axes]
+	subcommand = (self._w, 'axis', 'configure') + tuple(axes)
+	return _doConfigure(self, subcommand, option, kw)
+    def axis_create(self, axisName, **kw):
+	self.tk.call((self._w, 'axis', 'create', axisName) + self._options(kw))
+    def axis_delete(self, *args):
+	self.tk.call((self._w, 'axis', 'delete') + args)
+    def axis_invtransform(self, axisName, value):
+	return self.tk.getdouble(self.tk.call(
+		self._w, 'axis', 'invtransform', axisName, value))
+    def axis_limits(self, axisName):
+	return self._getdoubles(self.tk.call(
+		self._w, 'axis', 'limits', axisName))
+    def axis_names(self, *args):
+        return self.tk.splitlist(
+                self.tk.call((self._w, 'axis', 'names') + args))
+    def axis_transform(self, axisName, value):
+	return self.tk.getint(self.tk.call(
+		self._w, 'axis', 'transform', axisName, value))
+
+    def xaxis_cget(self, key):
+	return self.tk.call(self._w, 'xaxis', 'cget', '-' + key)
+    def xaxis_configure(self, option=None, **kw):
+	subcommand = (self._w, 'xaxis', 'configure')
+	return _doConfigure(self, subcommand, option, kw)
+    def xaxis_invtransform(self, value):
+	return self.tk.getdouble(self.tk.call(
+		self._w, 'xaxis', 'invtransform', value))
+    def xaxis_limits(self):
+	return self._getdoubles(self.tk.call(self._w, 'xaxis', 'limits'))
+    def xaxis_transform(self, value):
+	return self.tk.getint(self.tk.call(
+		self._w, 'xaxis', 'transform', value))
+    def xaxis_use(self, axisName = None):
+	return self.tk.call(self._w, 'xaxis', 'use', axisName)
+
+    def x2axis_cget(self, key):
+	return self.tk.call(self._w, 'x2axis', 'cget', '-' + key)
+    def x2axis_configure(self, option=None, **kw):
+	subcommand = (self._w, 'x2axis', 'configure')
+	return _doConfigure(self, subcommand, option, kw)
+    def x2axis_invtransform(self, value):
+	return self.tk.getdouble(self.tk.call(
+		self._w, 'x2axis', 'invtransform', value))
+    def x2axis_limits(self):
+	return self._getdoubles(self.tk.call(self._w, 'x2axis', 'limits'))
+    def x2axis_transform(self, value):
+	return self.tk.getint(self.tk.call(
+		self._w, 'x2axis', 'transform', value))
+    def x2axis_use(self, axisName = None):
+	return self.tk.call(self._w, 'x2axis', 'use', axisName)
+
+    def yaxis_cget(self, key):
+	return self.tk.call(self._w, 'yaxis', 'cget', '-' + key)
+    def yaxis_configure(self, option=None, **kw):
+	subcommand = (self._w, 'yaxis', 'configure')
+	return _doConfigure(self, subcommand, option, kw)
+    def yaxis_invtransform(self, value):
+	return self.tk.getdouble(self.tk.call(
+		self._w, 'yaxis', 'invtransform', value))
+    def yaxis_limits(self):
+	return self._getdoubles(self.tk.call(self._w, 'yaxis', 'limits'))
+    def yaxis_transform(self, value):
+	return self.tk.getint(self.tk.call(
+		self._w, 'yaxis', 'transform', value))
+    def yaxis_use(self, axisName = None):
+	return self.tk.call(self._w, 'yaxis', 'use', axisName)
+
+    def y2axis_cget(self, key):
+	return self.tk.call(self._w, 'y2axis', 'cget', '-' + key)
+    def y2axis_configure(self, option=None, **kw):
+	subcommand = (self._w, 'y2axis', 'configure')
+	return _doConfigure(self, subcommand, option, kw)
+    def y2axis_invtransform(self, value):
+	return self.tk.getdouble(self.tk.call(
+		self._w, 'y2axis', 'invtransform', value))
+    def y2axis_limits(self):
+	return self._getdoubles(self.tk.call(self._w, 'y2axis', 'limits'))
+    def y2axis_transform(self, value):
+	return self.tk.getint(self.tk.call(
+		self._w, 'y2axis', 'transform', value))
+    def y2axis_use(self, axisName = None):
+	return self.tk.call(self._w, 'y2axis', 'use', axisName)
+
+    def crosshairs_cget(self, key):
+	return self.tk.call(self._w, 'crosshairs', 'cget', '-' + key)
+    def crosshairs_configure(self, option=None, **kw):
+	subcommand = (self._w, 'crosshairs', 'configure')
+	return _doConfigure(self, subcommand, option, kw)
+    def crosshairs_off(self):
+	self.tk.call(self._w, 'crosshairs', 'off')
+    def crosshairs_on(self):
+	self.tk.call(self._w, 'crosshairs', 'on')
+    def crosshairs_toggle(self):
+	self.tk.call(self._w, 'crosshairs', 'toggle')
+
+    def element_activate(self, name, *args):
+	self.tk.call((self._w, 'element', 'activate', name) + args)
+    def element_bind(self, tagName, sequence=None, func=None, add=None):
+        return self._bind((self._w, 'element', 'bind', tagName),
+                sequence, func, add)
+    def element_unbind(self, tagName, sequence, funcid=None):
+        self.tk.call(self._w, 'element', 'bind', tagName, sequence, '')
+        if funcid:
+            self.deletecommand(funcid)
+
+    def element_cget(self, name, key):
+	return self.tk.call(self._w, 'element', 'cget', name, '-' + key)
+
+    def element_closest(self, x, y, *args, **kw):
+        var = 'python_private_1'
+	success = self.tk.getint(self.tk.call(
+                (self._w, 'element', 'closest', x, y, var) +
+                        self._options(kw) + args))
+	if success:
+	    rtn = {}
+	    rtn['dist'] = self.tk.getdouble(self.tk.globalgetvar(var, 'dist'))
+	    rtn['x'] = self.tk.getdouble(self.tk.globalgetvar(var, 'x'))
+	    rtn['y'] = self.tk.getdouble(self.tk.globalgetvar(var, 'y'))
+	    rtn['index'] = self.tk.getint(self.tk.globalgetvar(var, 'index'))
+	    rtn['name'] = self.tk.globalgetvar(var, 'name')
+	    return rtn
+	else:
+	    return None
+
+    def element_configure(self, names, option=None, **kw):
+        # &lt;names&gt; may be a list of elemNames.
+	if type(names) == types.StringType:
+            names = [names]
+	subcommand = (self._w, 'element', 'configure') + tuple(names)
+	return _doConfigure(self, subcommand, option, kw)
+
+    def element_deactivate(self, *args):
+	self.tk.call((self._w, 'element', 'deactivate') + args)
+
+    def element_delete(self, *args):
+	self.tk.call((self._w, 'element', 'delete') + args)
+    def element_exists(self, name):
+	return self.tk.getboolean(
+		self.tk.call(self._w, 'element', 'exists', name))
+
+    def element_names(self, *args):
+        return self.tk.splitlist(
+                self.tk.call((self._w, 'element', 'names') + args))
+    def element_show(self, nameList=None):
+	if nameList is not None:
+	    nameList = tuple(nameList)
+	return self.tk.splitlist(
+		self.tk.call(self._w, 'element', 'show', nameList))
+    def element_type(self, name):
+	return self.tk.call(self._w, 'element', 'type', name)
+
+    def grid_cget(self, key):
+	return self.tk.call(self._w, 'grid', 'cget', '-' + key)
+    def grid_configure(self, option=None, **kw):
+	subcommand = (self._w, 'grid', 'configure')
+	return _doConfigure(self, subcommand, option, kw)
+
+    def grid_off(self):
+	self.tk.call(self._w, 'grid', 'off')
+    def grid_on(self):
+	self.tk.call(self._w, 'grid', 'on')
+    def grid_toggle(self):
+	self.tk.call(self._w, 'grid', 'toggle')
+
+    def legend_activate(self, *args):
+	self.tk.call((self._w, 'legend', 'activate') + args)
+    def legend_bind(self, tagName, sequence=None, func=None, add=None):
+        return self._bind((self._w, 'legend', 'bind', tagName),
+                sequence, func, add)
+    def legend_unbind(self, tagName, sequence, funcid=None):
+        self.tk.call(self._w, 'legend', 'bind', tagName, sequence, '')
+        if funcid:
+            self.deletecommand(funcid)
+
+    def legend_cget(self, key):
+	return self.tk.call(self._w, 'legend', 'cget', '-' + key)
+    def legend_configure(self, option=None, **kw):
+	subcommand = (self._w, 'legend', 'configure')
+	return _doConfigure(self, subcommand, option, kw)
+    def legend_deactivate(self, *args):
+	self.tk.call((self._w, 'legend', 'deactivate') + args)
+    def legend_get(self, pos):
+	return self.tk.call(self._w, 'legend', 'get', pos)
+
+    def pen_cget(self, name, key):
+	return self.tk.call(self._w, 'pen', 'cget', name, '-' + key)
+    def pen_configure(self, names, option=None, **kw):
+        # &lt;names&gt; may be a list of penNames.
+	if type(names) == types.StringType:
+            names = [names]
+	subcommand = (self._w, 'pen', 'configure') + tuple(names)
+	return _doConfigure(self, subcommand, option, kw)
+    def pen_create(self, name, **kw):
+	self.tk.call((self._w, 'pen', 'create', name) + self._options(kw))
+    def pen_delete(self, *args):
+	self.tk.call((self._w, 'pen', 'delete') + args)
+    def pen_names(self, *args):
+        return self.tk.splitlist(self.tk.call((self._w, 'pen', 'names') + args))
+
+    def postscript_cget(self, key):
+	return self.tk.call(self._w, 'postscript', 'cget', '-' + key)
+    def postscript_configure(self, option=None, **kw):
+	subcommand = (self._w, 'postscript', 'configure')
+	return _doConfigure(self, subcommand, option, kw)
+    def postscript_output(self, fileName=None, **kw):
+	prefix = (self._w, 'postscript', 'output')
+	if fileName is None:
+	    return self.tk.call(prefix + self._options(kw))
+	else:
+	    self.tk.call(prefix + (fileName,) + self._options(kw))
+
+    def marker_after(self, first, second=None):
+	self.tk.call(self._w, 'marker', 'after', first, second)
+    def marker_before(self, first, second=None):
+	self.tk.call(self._w, 'marker', 'before', first, second)
+    def marker_bind(self, tagName, sequence=None, func=None, add=None):
+        return self._bind((self._w, 'marker', 'bind', tagName),
+                sequence, func, add)
+    def marker_unbind(self, tagName, sequence, funcid=None):
+        self.tk.call(self._w, 'marker', 'bind', tagName, sequence, '')
+        if funcid:
+            self.deletecommand(funcid)
+
+    def marker_cget(self, name, key):
+	return self.tk.call(self._w, 'marker', 'cget', name, '-' + key)
+    def marker_configure(self, names, option=None, **kw):
+        # &lt;names&gt; may be a list of markerIds.
+	if type(names) == types.StringType:
+            names = [names]
+	subcommand = (self._w, 'marker', 'configure') + tuple(names)
+	return _doConfigure(self, subcommand, option, kw)
+    def marker_create(self, type, **kw):
+	return self.tk.call(
+                (self._w, 'marker', 'create', type) + self._options(kw))
+
+    def marker_delete(self, *args):
+	self.tk.call((self._w, 'marker', 'delete') + args)
+    def marker_exists(self, name):
+	return self.tk.getboolean(
+		self.tk.call(self._w, 'marker', 'exists', name))
+    def marker_names(self, *args):
+        return self.tk.splitlist(
+                self.tk.call((self._w, 'marker', 'names') + args))
+    def marker_type(self, name):
+	type = self.tk.call(self._w, 'marker', 'type', name)
+	if type == '':
+	    type = None
+	return type
+
+#=============================================================================
+class Stripchart(Graph):
+    # Wrapper for the blt stripchart widget, version 2.4.
+
+    def __init__(self, master=None, cnf={}, **kw):
+	_loadBlt(master)
+	Tkinter.Widget.__init__(self, master, _chartCommand, cnf, kw)
+
+#=============================================================================
+class Tabset(Tkinter.Widget): 
+
+    # Wrapper for the blt TabSet widget, version 2.4.
+
+    def __init__(self, master=None, cnf={}, **kw):
+	_loadBlt(master)
+	Tkinter.Widget.__init__(self, master, _tabsetCommand, cnf, kw)
+
+    def activate(self, tabIndex):
+        self.tk.call(self._w, 'activate', tabIndex)
+
+    # This is the 'bind' sub-command:
+    def tag_bind(self, tagName, sequence=None, func=None, add=None):
+        return self._bind((self._w, 'bind', tagName), sequence, func, add)
+
+    def tag_unbind(self, tagName, sequence, funcid=None):
+        self.tk.call(self._w, 'bind', tagName, sequence, '')
+        if funcid:
+            self.deletecommand(funcid)
+
+    def delete(self, first, last = None):
+    	self.tk.call(self._w, 'delete', first, last)
+
+    # This is the 'focus' sub-command:
+    def tab_focus(self, tabIndex):
+    	self.tk.call(self._w, 'focus', tabIndex)
+    	
+    def get(self, tabIndex):
+	return self.tk.call(self._w, 'get', tabIndex)
+
+    def index(self, tabIndex):
+	index = self.tk.call(self._w, 'index', tabIndex)
+        if index == '':
+            return None
+        else:
+            return self.tk.getint(self.tk.call(self._w, 'index', tabIndex))
+
+    def insert(self, position, name1, *names, **kw):
+	self.tk.call(
+            (self._w, 'insert', position, name1) + names + self._options(kw))
+
+    def invoke(self, tabIndex):
+    	return self.tk.call(self._w, 'invoke', tabIndex)
+
+    def move(self, tabIndex1, beforeOrAfter, tabIndex2):
+    	self.tk.call(self._w, 'move', tabIndex1, beforeOrAfter, tabIndex2)
+    	
+    def nearest(self, x, y):
+    	return self.tk.call(self._w, 'nearest', x, y)
+
+    def scan_mark(self, x, y):
+        self.tk.call(self._w, 'scan', 'mark', x, y)
+
+    def scan_dragto(self, x, y):
+        self.tk.call(self._w, 'scan', 'dragto', x, y)
+
+    def see(self, index):
+        self.tk.call(self._w, 'see', index)
+    	
+    def see(self, tabIndex):
+    	self.tk.call(self._w,'see',tabIndex)
+    	
+    def size(self):
+	return self.tk.getint(self.tk.call(self._w, 'size'))
+
+    def tab_cget(self, tabIndex, option):
+        if option[:1] != '-':
+            option = '-' + option
+        if option[-1:] == '_':
+            option = option[:-1]
+        return self.tk.call(self._w, 'tab', 'cget', tabIndex, option)
+
+    def tab_configure(self, tabIndexes, option=None, **kw):
+        # &lt;tabIndexes&gt; may be a list of tabs.
+	if type(tabIndexes) in (types.StringType, types.IntType):
+            tabIndexes = [tabIndexes]
+	subcommand = (self._w, 'tab', 'configure') + tuple(tabIndexes)
+	return _doConfigure(self, subcommand, option, kw)
+
+    def tab_names(self, *args):
+        return self.tk.splitlist(self.tk.call((self._w, 'tab', 'names') + args))
+
+    def tab_tearoff(self, tabIndex, newName = None):
+        if newName is None:
+            name = self.tk.call(self._w, 'tab', 'tearoff', tabIndex)
+            return self.nametowidget(name)
+        else:
+            self.tk.call(self._w, 'tab', 'tearoff', tabIndex, newName)
+
+    def view(self):
+        s = self.tk.call(self._w, 'view')
+        return tuple(map(self.tk.getint, self.tk.splitlist(s)))
+    def view_moveto(self, fraction):
+        self.tk.call(self._w, 'view', 'moveto', fraction)
+    def view_scroll(self, number, what):
+        self.tk.call(self._w, 'view', 'scroll', number, what)

Added: branches/wspr/PmwColor.py
===================================================================
--- branches/wspr/PmwColor.py	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/PmwColor.py	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,361 @@
+# Functions for converting colors and modifying the color scheme of
+# an application.
+
+import math
+import string
+import sys
+import Tkinter
+
+_PI = math.pi
+_TWO_PI = _PI * 2
+_THIRD_PI = _PI / 3
+_SIXTH_PI = _PI / 6
+_MAX_RGB = float(256 * 256 - 1) # max size of rgb values returned from Tk
+
+def setscheme(root, background=None, **kw):
+    root = root._root()
+    palette = apply(_calcPalette, (root, background,), kw)
+    for option, value in palette.items():
+	root.option_add('*' + option, value, 'widgetDefault')
+
+def getdefaultpalette(root):
+    # Return the default values of all options, using the defaults
+    # from a few widgets.
+
+    ckbtn = Tkinter.Checkbutton(root)
+    entry = Tkinter.Entry(root)
+    scbar = Tkinter.Scrollbar(root)
+
+    orig = {}
+    orig['activeBackground'] = str(ckbtn.configure('activebackground')[4])
+    orig['activeForeground'] = str(ckbtn.configure('activeforeground')[4])
+    orig['background'] = str(ckbtn.configure('background')[4])
+    orig['disabledForeground'] = str(ckbtn.configure('disabledforeground')[4])
+    orig['foreground'] = str(ckbtn.configure('foreground')[4])
+    orig['highlightBackground'] = str(ckbtn.configure('highlightbackground')[4])
+    orig['highlightColor'] = str(ckbtn.configure('highlightcolor')[4])
+    orig['insertBackground'] = str(entry.configure('insertbackground')[4])
+    orig['selectColor'] = str(ckbtn.configure('selectcolor')[4])
+    orig['selectBackground'] = str(entry.configure('selectbackground')[4])
+    orig['selectForeground'] = str(entry.configure('selectforeground')[4])
+    orig['troughColor'] = str(scbar.configure('troughcolor')[4])
+
+    ckbtn.destroy()
+    entry.destroy()
+    scbar.destroy()
+
+    return orig
+
+#======================================================================
+
+# Functions dealing with brightness, hue, saturation and intensity of colors.
+
+def changebrightness(root, colorName, brightness):
+    # Convert the color name into its hue and back into a color of the
+    # required brightness.
+
+    rgb = name2rgb(root, colorName)
+    hue, saturation, intensity = rgb2hsi(rgb)
+    if saturation == 0.0:
+        hue = None
+    return hue2name(hue, brightness)
+
+def hue2name(hue, brightness = None):
+    # Convert the requested hue and brightness into a color name.  If
+    # hue is None, return a grey of the requested brightness.
+
+    if hue is None:
+	rgb = hsi2rgb(0.0, 0.0, brightness)
+    else:
+	while hue &lt; 0:
+	    hue = hue + _TWO_PI
+	while hue &gt;= _TWO_PI:
+	    hue = hue - _TWO_PI
+
+	rgb = hsi2rgb(hue, 1.0, 1.0)
+	if brightness is not None:
+	    b = rgb2brightness(rgb)
+	    i = 1.0 - (1.0 - brightness) * b
+	    s = bhi2saturation(brightness, hue, i)
+	    rgb = hsi2rgb(hue, s, i)
+
+    return rgb2name(rgb)
+
+def bhi2saturation(brightness, hue, intensity):
+    while hue &lt; 0:
+        hue = hue + _TWO_PI
+    while hue &gt;= _TWO_PI:
+        hue = hue - _TWO_PI
+    hue = hue / _THIRD_PI
+    f = hue - math.floor(hue)
+
+    pp = intensity
+    pq = intensity * f
+    pt = intensity - intensity * f
+    pv = 0
+
+    hue = int(hue)
+    if   hue == 0: rgb = (pv, pt, pp)
+    elif hue == 1: rgb = (pq, pv, pp)
+    elif hue == 2: rgb = (pp, pv, pt)
+    elif hue == 3: rgb = (pp, pq, pv)
+    elif hue == 4: rgb = (pt, pp, pv)
+    elif hue == 5: rgb = (pv, pp, pq)
+
+    return (intensity - brightness) / rgb2brightness(rgb)
+
+def hsi2rgb(hue, saturation, intensity):
+    i = intensity
+    if saturation == 0:
+	rgb = [i, i, i]
+    else:
+	while hue &lt; 0:
+	    hue = hue + _TWO_PI
+	while hue &gt;= _TWO_PI:
+	    hue = hue - _TWO_PI
+	hue = hue / _THIRD_PI
+	f = hue - math.floor(hue)
+	p = i * (1.0 - saturation)
+	q = i * (1.0 - saturation * f)
+	t = i * (1.0 - saturation * (1.0 - f))
+
+	hue = int(hue)
+	if   hue == 0: rgb = [i, t, p]
+	elif hue == 1: rgb = [q, i, p]
+	elif hue == 2: rgb = [p, i, t]
+	elif hue == 3: rgb = [p, q, i]
+	elif hue == 4: rgb = [t, p, i]
+	elif hue == 5: rgb = [i, p, q]
+
+    for index in range(3):
+	val = rgb[index]
+	if val &lt; 0.0:
+	    val = 0.0
+	if val &gt; 1.0:
+	    val = 1.0
+	rgb[index] = val
+
+    return rgb
+
+def average(rgb1, rgb2, fraction):
+    return (
+	rgb2[0] * fraction + rgb1[0] * (1.0 - fraction),
+	rgb2[1] * fraction + rgb1[1] * (1.0 - fraction),
+	rgb2[2] * fraction + rgb1[2] * (1.0 - fraction)
+    )
+
+def rgb2name(rgb):
+    return '#%02x%02x%02x' % \
+        (int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255))
+
+def rgb2brightness(rgb):
+    # Return the perceived grey level of the color
+    # (0.0 == black, 1.0 == white).
+
+    rf = 0.299
+    gf = 0.587
+    bf = 0.114
+    return rf * rgb[0] + gf * rgb[1] + bf * rgb[2]
+
+def rgb2hsi(rgb):
+    maxc = max(rgb[0], rgb[1], rgb[2])
+    minc = min(rgb[0], rgb[1], rgb[2])
+
+    intensity = maxc
+    if maxc != 0:
+      saturation  = (maxc - minc) / maxc
+    else:
+      saturation = 0.0
+
+    hue = 0.0
+    if saturation != 0.0:
+	c = []
+	for index in range(3):
+	    c.append((maxc - rgb[index]) / (maxc - minc))
+
+	if rgb[0] == maxc:
+	    hue = c[2] - c[1]
+	elif rgb[1] == maxc:
+	    hue = 2 + c[0] - c[2]
+	elif rgb[2] == maxc:
+	    hue = 4 + c[1] - c[0]
+
+	hue = hue * _THIRD_PI
+	if hue &lt; 0.0:
+	    hue = hue + _TWO_PI
+
+    return (hue, saturation, intensity)
+
+def name2rgb(root, colorName, asInt = 0):
+    if colorName[0] == '#':
+	# Extract rgb information from the color name itself, assuming
+	# it is either #rgb, #rrggbb, #rrrgggbbb, or #rrrrggggbbbb
+	# This is useful, since tk may return incorrect rgb values if
+	# the colormap is full - it will return the rbg values of the
+	# closest color available.
+        colorName = colorName[1:]
+        digits = len(colorName) / 3
+        factor = 16 ** (4 - digits)
+        rgb = (
+            string.atoi(colorName[0:digits], 16) * factor,
+            string.atoi(colorName[digits:digits * 2], 16) * factor,
+            string.atoi(colorName[digits * 2:digits * 3], 16) * factor,
+        )
+    else:
+	# We have no choice but to ask Tk what the rgb values are.
+	rgb = root.winfo_rgb(colorName)
+
+    if not asInt:
+        rgb = (rgb[0] / _MAX_RGB, rgb[1] / _MAX_RGB, rgb[2] / _MAX_RGB)
+    return rgb
+
+def _calcPalette(root, background=None, **kw):
+    # Create a map that has the complete new palette.  If some colors
+    # aren't specified, compute them from other colors that are specified.
+    new = {}
+    for key, value in kw.items():
+	new[key] = value
+    if background is not None:
+	new['background'] = background
+    if not new.has_key('background'):
+	raise ValueError, 'must specify a background color'
+
+    if not new.has_key('foreground'):
+	new['foreground'] = 'black'
+
+    bg = name2rgb(root, new['background'])
+    fg = name2rgb(root, new['foreground'])
+
+    for i in ('activeForeground', 'insertBackground', 'selectForeground',
+	    'highlightColor'):
+	if not new.has_key(i):
+	    new[i] = new['foreground']
+
+    if not new.has_key('disabledForeground'):
+	newCol = average(bg, fg, 0.3)
+	new['disabledForeground'] = rgb2name(newCol)
+
+    if not new.has_key('highlightBackground'):
+	new['highlightBackground'] = new['background']
+
+    # Set &lt;lighterBg&gt; to a color that is a little lighter that the
+    # normal background.  To do this, round each color component up by
+    # 9% or 1/3 of the way to full white, whichever is greater.
+    lighterBg = []
+    for i in range(3):
+	lighterBg.append(bg[i])
+	inc1 = lighterBg[i] * 0.09
+	inc2 = (1.0 - lighterBg[i]) / 3
+	if inc1 &gt; inc2:
+	    lighterBg[i] = lighterBg[i] + inc1
+	else:
+	    lighterBg[i] = lighterBg[i] + inc2
+	if lighterBg[i] &gt; 1.0:
+	    lighterBg[i] = 1.0
+
+    # Set &lt;darkerBg&gt; to a color that is a little darker that the
+    # normal background.
+    darkerBg = (bg[0] * 0.9, bg[1] * 0.9, bg[2] * 0.9)
+
+    if not new.has_key('activeBackground'):
+	# If the foreground is dark, pick a light active background.
+	# If the foreground is light, pick a dark active background.
+	# XXX This has been disabled, since it does not look very
+	# good with dark backgrounds. If this is ever fixed, the
+	# selectBackground and troughColor options should also be fixed.
+
+	if rgb2brightness(fg) &lt; 0.5:
+	    new['activeBackground'] = rgb2name(lighterBg)
+	else:
+	    new['activeBackground'] = rgb2name(lighterBg)
+
+    if not new.has_key('selectBackground'):
+	new['selectBackground'] = rgb2name(darkerBg)
+    if not new.has_key('troughColor'):
+	new['troughColor'] = rgb2name(darkerBg)
+    if not new.has_key('selectColor'):
+	new['selectColor'] = 'yellow'
+
+    return new
+
+def spectrum(numColors, correction = 1.0, saturation = 1.0, intensity = 1.0,
+	extraOrange = 1, returnHues = 0):
+    colorList = []
+    division = numColors / 7.0
+    for index in range(numColors):
+	if extraOrange:
+	    if index &lt; 2 * division:
+		hue = index / division
+	    else:
+		hue = 2 + 2 * (index - 2 * division) / division
+	    hue = hue * _SIXTH_PI
+	else:
+	    hue = index * _TWO_PI / numColors
+	if returnHues:
+	    colorList.append(hue)
+	else:
+	    rgb = hsi2rgb(hue, saturation, intensity)
+	    if correction != 1.0:
+		rgb = correct(rgb, correction)
+	    name = rgb2name(rgb)
+	    colorList.append(name)
+    return colorList
+
+def correct(rgb, correction):
+    correction = float(correction)
+    rtn = []
+    for index in range(3):
+	rtn.append((1 - (1 - rgb[index]) ** correction) ** (1 / correction))
+    return rtn
+
+#==============================================================================
+
+def _recolorTree(widget, oldpalette, newcolors):
+    # Change the colors in a widget and its descendants.
+
+    # Change the colors in &lt;widget&gt; and all of its descendants,
+    # according to the &lt;newcolors&gt; dictionary.  It only modifies
+    # colors that have their default values as specified by the
+    # &lt;oldpalette&gt; variable.  The keys of the &lt;newcolors&gt; dictionary
+    # are named after widget configuration options and the values are
+    # the new value for that option.
+
+    for dbOption in newcolors.keys():
+        option = string.lower(dbOption)
+        try:
+            value = str(widget.cget(option))
+        except:
+            continue
+        if oldpalette is None or value == oldpalette[dbOption]:
+            apply(widget.configure, (), {option : newcolors[dbOption]})
+
+    for child in widget.winfo_children():
+       _recolorTree(child, oldpalette, newcolors)
+
+def changecolor(widget, background=None, **kw):
+     root = widget._root()
+     if not hasattr(widget, '_Pmw_oldpalette'):
+	 widget._Pmw_oldpalette = getdefaultpalette(root)
+     newpalette = apply(_calcPalette, (root, background,), kw)
+     _recolorTree(widget, widget._Pmw_oldpalette, newpalette)
+     widget._Pmw_oldpalette = newpalette
+
+def bordercolors(root, colorName):
+    # This is the same method that Tk uses for shadows, in TkpGetShadows.
+
+    lightRGB = []
+    darkRGB = []
+    for value in name2rgb(root, colorName, 1):
+        value40pc = (14 * value) / 10
+        if value40pc &gt; _MAX_RGB:
+            value40pc = _MAX_RGB
+        valueHalfWhite = (_MAX_RGB + value) / 2;
+        lightRGB.append(max(value40pc, valueHalfWhite))
+
+        darkValue = (60 * value) / 100
+        darkRGB.append(darkValue)
+
+    return (
+        '#%04x%04x%04x' % (lightRGB[0], lightRGB[1], lightRGB[2]),
+        '#%04x%04x%04x' % (darkRGB[0], darkRGB[1], darkRGB[2])
+    )

Added: branches/wspr/WSPR.INI
===================================================================
--- branches/wspr/WSPR.INI	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/WSPR.INI	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,12 @@
+WSPRGeometry +166+357
+MyCall K1JT
+MyGrid FN20
+dBm 25
+IDinterval 10
+PttPort 0
+AudioIn 0
+AudioOut 0
+Nsave 0
+PctTx 35
+Sync 1
+MRUDir C:\k1jt\wspr

Added: branches/wspr/WSPR_Announcement.TXT
===================================================================
--- branches/wspr/WSPR_Announcement.TXT	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/WSPR_Announcement.TXT	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,87 @@
+To:      QRSS Knights and Friends
+From:    Joe Taylor, K1JT
+Subject: New software for MEPT
+Date:    March 10, 2008
+
+About two weeks ago Murray Greenman, ZL1BPU, wrote to me suggesting
+that I consider adding a mode optimized for MEPT to my software
+package WSJT.  I expressed interest in the idea, and we exchanged a
+few emails about possible specifications.  Then I sat down and wrote
+out some detailed specs, and finally got busy to write a bare-bones
+program implementing the new mode.
+
+I write now to let you know that an early release of the program is
+ready for testing.  The program's name is WSPR (pronounced &quot;whisper&quot;,
+which seems appropriate for estremely weak signals).  The name of the
+digital protocol implemented in WSPR is MEPT_JT, where the letters
+stand for &quot;Manned Experimental Propagation Tests, by K1JT&quot;.
+
+At present WSPR is a stand-alone executable, independent of WSJT.  It
+is functional for both transmitting and receiving, but it has no
+frills -- no graphics, no GUI, etc.  It is executed from a Windows
+command prompt.  Like WSJT, WSPR uses a computer sound card to
+generate audio tones to modulate an SSB transceiver operating on upper
+sideband.  In receive mode the sound card digitizes audio from the
+transceiver.  The program scans a 200 Hz passband (the &quot;QRSS window&quot;)
+looking for MEPT_JT signals, and decodes them.  Basic operating
+instructions for the initial release can be found in the file
+WSPR_Instructions.TXT at
+<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSPR_Instructions.TXT">http://physics.princeton.edu/pulsar/K1JT/WSPR_Instructions.TXT</A> , and
+the program itself can be downloaded from
+<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE">http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE</A> .
+
+
+Basic specifications of the MEPT_JT mode are as follows:
+
+1.  Transmitted message: callsign + 4-character-locator + dBm 
+    Example: &quot;K1JT FN20 30&quot;
+
+2.  Message length after lossless compression: 28 bits for callsign,
+    15 for locator, 7 for power level ==&gt; 50 bits total.
+
+3.  Forward error correction (FEC): long-constraint convolutional 
+    code, K=32, r=1/2.
+
+4.  Number of channel symbols: nsym = (50+K-1)*2 = 162.
+
+5.  Keying rate: 12000/8192 = 1.46 baud.  
+
+6.  Modulation: continuous phase 4-FSK.  Tone separation 1.46 Hz.
+
+7.  Synchronization: 162-bit pseudo-random sync vector.
+
+8.  Data structure: each channel symbol conveys one sync bit and one
+    data bit.
+
+9.  Duration of transmission: 162*8192/12000 = 110.6 s.  
+
+10. Transmissions start two seconds into an even UTC minute: i.e., at
+    hh:00:02, hh:02:02, ...
+
+10. Occupied bandwidth: about 6 Hz
+
+11. Minimum S/N for reception: around -27 dB on the WSJT scale (2500
+    Hz reference bandwidth).  
+
+You can run Argo, Spectran, or WSJT at the same time as WSPR, in
+order to provide a waterfall spectral display.
+
+In normal operation WSPR displays information every two minutes and
+is silent otherwise.  In transmit mode in prints a single line when a
+new transmission starts.  In receive mode the program looks for all
+detectable MEPT_JT signals in a 200 Hz passband, decodes them, and
+displays the results.  If nothing is decoded, nothing will be printed.
+In T/R mode the program alternates in a randomized way between
+transmit and receive sequences.
+
+Like JT65, MEPT_JT includes very efficient data compression and strong
+forward error correction.  Received messages are nearly always exactly
+the same as the transmitted message, or else they are left blank.
+
+Version 0.3 of MEPT_JT is functional -- and extremely sensitive -- but
+the user interface is rather spartan.  Suggestions for improvements
+will be most welcome!
+
+Please email all suggestions to k1jt at arrl dot net.
+
+	    -- 73, Joe, K1JT

Added: branches/wspr/WSPR_Instructions.TXT
===================================================================
--- branches/wspr/WSPR_Instructions.TXT	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/WSPR_Instructions.TXT	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,380 @@
+                        Instructions for WSPR
+                        ---------------------
+
+WSPR is the name of a computer program.  It is pronounced &quot;whisper&quot;,
+and stands for &quot;Weak Signal Propagation Reporter&quot;; it implements
+transmitting and receiving functions for a digital soundcard mode
+called &quot;MEPT_JT&quot;, which stands for &quot;Manned Experimental Propagation
+Tests, by K1JT&quot;.
+
+WSPR generates and receives signals using structured messages, strong
+forward error correction, and narrow-band 4-FSK modulation.  Its
+principal design goal is reliable copy at very low signal levels.  In
+practice it works well at signal-to-noise ratios down to -27 dB in a
+reference bandwidth of 2500 Hz.  The present program, version 0.3, has
+no frills, no graphics and no GUI.  It is executed from the command
+line.
+
+QUICK START
+-----------
+
+Download WSPR from the URL
+<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE">http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE</A> and copy the
+executable file into a suitable directory such as C:\wspr.  WSPR is
+invoked by typing its name followed by zero or more arguments.  Open a
+command-prompt window, CD into to that directory, and type &quot;wspr&quot;
+(with no accompanying arguments) to see the following summary and
+examples of program usage:
+
+-----------------------------------------------------------------------
+C:\WPSR&gt; wspr
+
+ WSPR Version 0.3 r90
+
+ Usage: wspr Tx  f0 ftx nport call grid dBm [snr] [outfile | nfiles]
+        wspr T/R f0 ftx nport call grid dBm pctx
+        wspr Rx  f0 [infile ...]
+
+        f0 is the transceiver dial frequency (MHz)
+        ftx is the signal frequency (MHz)
+        nport is the COM port number for PTT control
+        snr is the S/N in 2500 Hz bandwidth (for test files)
+        pctx is the percentage of 2-minute periods to Tx
+
+ Examples:
+        wspr Tx  10.1386 10.140100 1 K1JT FN20 30
+        wspr Tx  10.1386 10.140100 0 K1JT FN20 30 -22 test.wav
+        wspr T/R 10.1386 10.140100 0 K1JT FN20 30 25
+        wspr Rx  10.1386
+        wspr Rx  10.1386 00001.wav 00002.wav 00003.wav
+
+ For more information see:
+        physics.princeton.edu/pulsar/K1JT/WSPR_Instructions.TXT
+-----------------------------------------------------------------------
+
+In transmit mode there can be up to 9 command-line arguments after the
+program name.  The arguments have the following meanings:
+
+1. Tx    - signifies transmit mode
+2. f0    - suppressed carrier frequency or &quot;dial frequency&quot; (MHz)
+3. ftx   - center frequency of generated MEPT_JT signal (MHz)
+4. nport - COM port number for PTT control (0 to disable PTT control)
+5. call  - transmitted callsign
+6. grid  - transmitted 4-character locator
+7. dbm   - transmitter power (dBm)
+8. snr   - generated S/N (for off-line testing only)
+9. file  - output file name, or number of files to generate
+
+On-the-air transmissions use only arguments 1 through 7; arguments 8
+and 9 are used for generating wave files for local tests.
+
+In receive mode the first two command-line arguments must be &quot;Rx&quot; and
+the dial frequency f0, in MHz.  Additional arguments are treated as
+file names, for local testing purposes.
+
+A third operating mode, the &quot;T/R&quot; mode, allows one to specify the
+percentage of 2-minute time slots to devote to transmitting.  All
+remaining time slots will be used for receiving.  The percentage is
+defined in a statistical manner; specific choices of Tx and Rx
+intervals are randomized.  In this way you can put a signal on the air
+for others to copy, and at the same time monitor the band to keep
+track of who else is on.  In T/R mode the first 7 command-line
+arguments have the same meanings as in Tx mode; the 8th argument
+specifies the percent of 2-minute sequences you want devoted to
+transmission.  In the example given above, 25% of 2-minute sequences
+will be transmissions, while the remaining 75% will be used for
+reception.
+
+
+NORMAL OPERATION
+----------------
+
+Set your transceiver to USB mode and the dial frequency 1500 Hz below
+the center of the desired 200 Hz band for reception.  For example, on
+30 m the QRSS band is 10.140000 to 10.140200, so the dial frequency
+should be f0 = 10.140100 - 0.001500 = 10.1386 MHz.  Be sure that your
+computer clock is accurate to within a second or so.  In case your
+computer has more than one sound card, please note that the program
+will use the default Windows sound system.  (Support for selecting
+which sound card to use will probably be added in a future program
+release.)
+
+TRANSMIT: To transmit, type in a command similar to the first example
+above.  The third argument is your desired signal frequency.  I use
+serial port COM 5 for PTT control.  Therefore, to transmit on
+10.140150 with power 100 mW (20 dBm) I would enter the command
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140150 5 K1JT FN20 20
+
+Transmission will start at the top on the next even minute, and will
+be repeated on even minutes until you stop it manually.  You can type
+CTRL+C (hold down the CTRL key while striking C) to terminate program
+execution.
+
+
+RECEIVE: To receive, type in a command like the fourth example above.
+The second argument is the dial frequency, 1500 Hz below the center of
+the 200 Hz received passband.
+
+C:\WSPR&gt; wspr Rx 10.1386
+
+Reception will begin at the top of the next even minute, and will
+continue until you terminate it manually by typing CTRL+C.
+
+
+T/R MODE: Type in a command line like the third example above:
+
+C:\WSPR&gt; wspr T/R 10.1386 10.140150 1 K1JT FN20 30 25
+
+At the start of the next even minute the program will start a series
+of transmission or reception intervals.  A random number generator
+is used to determine whether a particular interval will be Tx or Rx;
+on average, however, the percentage of transmission intervals will be
+approach the number specified by argument #8.
+
+
+LOCAL TESTS WITH TWO COMPUTERS
+------------------------------
+
+Be sure that both computer clocks are accurate to within a second or
+so.
+
+On the &quot;transmit&quot; computer, to send MEPT_JT data at S/N -26 dB, type
+something like this:
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140080 0 K1JT FN20 20 -26
+
+The frequencies are arbitrary, but the frequency difference will
+determine the audio tone generated.  Transmission will start at the
+top on the next even minute, and will be repeated on even minutes
+until you stop it manually.  (You can type CTRL+C to terminate program
+execution.)
+
+On the &quot;receive&quot; computer, type in a command like
+
+C:\WSPR&gt; wspr Rx 10.1386
+
+The frequency is arbitrary.  Reception will begin at the top of the
+next even minute, and will continue until terminated manually.
+
+You can also do this test with a single computer.  Just open two
+command windows, one for Tx and one for Rx.  Use an audio cable to
+patch soundcard output into soundcard input, or simply use the speaker
+to &quot;transmit&quot; and the computer mike to &quot;receive&quot;.
+
+LOCAL TESTS WITH ONE COMPUTER
+-----------------------------
+
+You can generate a set of three test files at S/N -26 dB by entering a
+command like this:
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140100 0 K1JT FN20 30 -26 3
+
+These files may then be &quot;received&quot; by entering this command:
+
+C:\WSPR&gt; wspr Rx 10.1386 00001.wav 00002.wav 00003.wav
+
+
+GENERATING A MULTI-SIGNAL TEST FILE
+-----------------------------------
+
+If you set snr = 10 on the command line, WSPR will generate a file
+containing ten distinct signals at 20 Hz intervals, with progressive
+time offsets of 0.1 s relative to the first one, and with S/N -21,
+-22, ... -30 dB.  This feature was designed for testing the
+multi-signal decoder.  Here is a complete example of its use:
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140100 0 K1JT FN20 30 10 test.wav
+  10.138600  10.140100  10.0  K1JT FN20 30            test.wav
+
+C:\WSPR&gt; wspr Rx 10.1386 test.wav
+ UTC   Sync dB    DT     Freq    Message                  Noise
+---------------------------------------------------------------
+test    18 -21   0.0  10.140010  K1JT FN20 30              20.1
+test    14 -23   0.1  10.140030  K1JT FN20 30              20.1
+test     4 -23   0.2  10.140050  K1JT FN20 30              20.1
+test     7 -25   0.3  10.140070  K1JT FN20 30              20.1
+test    12 -25   0.4  10.140090  K1JT FN20 30              20.1
+test     2 -26   0.5  10.140110  K1JT FN20 30              20.1
+test     4 -28   0.6  10.140130  K1JT FN20 30              20.1
+test     1 -29   0.7  10.140150  K1JT FN20 30              20.1
+test     1 -29   0.7  10.140170  K1JT FN20 30              20.1
+
+
+GENERATING A LIST OF TX TONE FREQUENCIES
+---------------------------------------- 
+
+As an aid to those wishing to build a hardware-based or
+microprocessor-based transmitter for MEPT_JT signals, you can request
+the program to output the list of tone frequencies corresponding to
+the MEPT_JT signal carrying a particular message.  To do this, simply
+set snr to 11 on the command line.  Shown below is a complete example
+of this usage.  The table has one line for each of the 162 symbols in
+an MEPT_JT transmission.  Column 2 gives the tone number (0-3) for
+each 4-FSK symbol; column 3 gives the tone frequency in Hz.  Each tone
+should last for 8192/12000 = 0.6827 seconds, and transitions between
+tones should be done in a phase-continuous manner.
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140100 0 K1JT FN20 30 11
+  1  3  1502.197
+  2  3  1502.197
+  3  2  1500.732
+  4  0  1497.803
+  5  2  1500.732
+  6  0  1497.803
+  7  2  1500.732
+  8  2  1500.732
+  9  1  1499.268
+ 10  2  1500.732
+ 11  2  1500.732
+ 12  2  1500.732
+ 13  3  1502.197
+ 14  3  1502.197
+ 15  1  1499.268
+ 16  0  1497.803
+ 17  2  1500.732
+ 18  2  1500.732
+ 19  3  1502.197
+ 20  2  1500.732
+ 21  0  1497.803
+ 22  3  1502.197
+ 23  0  1497.803
+ 24  1  1499.268
+ 25  1  1499.268
+ 26  3  1502.197
+ 27  1  1499.268
+ 28  2  1500.732
+ 29  0  1497.803
+ 30  2  1500.732
+ 31  2  1500.732
+ 32  0  1497.803
+ 33  0  1497.803
+ 34  2  1500.732
+ 35  1  1499.268
+ 36  2  1500.732
+ 37  0  1497.803
+ 38  1  1499.268
+ 39  2  1500.732
+ 40  3  1502.197
+ 41  2  1500.732
+ 42  2  1500.732
+ 43  2  1500.732
+ 44  0  1497.803
+ 45  0  1497.803
+ 46  0  1497.803
+ 47  3  1502.197
+ 48  2  1500.732
+ 49  1  1499.268
+ 50  3  1502.197
+ 51  2  1500.732
+ 52  0  1497.803
+ 53  3  1502.197
+ 54  3  1502.197
+ 55  0  1497.803
+ 56  3  1502.197
+ 57  0  1497.803
+ 58  0  1497.803
+ 59  0  1497.803
+ 60  1  1499.268
+ 61  1  1499.268
+ 62  0  1497.803
+ 63  3  1502.197
+ 64  0  1497.803
+ 65  2  1500.732
+ 66  0  1497.803
+ 67  0  1497.803
+ 68  3  1502.197
+ 69  3  1502.197
+ 70  0  1497.803
+ 71  3  1502.197
+ 72  2  1500.732
+ 73  3  1502.197
+ 74  0  1497.803
+ 75  1  1499.268
+ 76  0  1497.803
+ 77  1  1499.268
+ 78  0  1497.803
+ 79  0  1497.803
+ 80  3  1502.197
+ 81  2  1500.732
+ 82  2  1500.732
+ 83  1  1499.268
+ 84  0  1497.803
+ 85  1  1499.268
+ 86  1  1499.268
+ 87  0  1497.803
+ 88  2  1500.732
+ 89  0  1497.803
+ 90  1  1499.268
+ 91  1  1499.268
+ 92  2  1500.732
+ 93  3  1502.197
+ 94  0  1497.803
+ 95  3  1502.197
+ 96  2  1500.732
+ 97  2  1500.732
+ 98  2  1500.732
+ 99  3  1502.197
+100  2  1500.732
+101  2  1500.732
+102  2  1500.732
+103  2  1500.732
+104  2  1500.732
+105  1  1499.268
+106  0  1497.803
+107  0  1497.803
+108  1  1499.268
+109  2  1500.732
+110  0  1497.803
+111  3  1502.197
+112  1  1499.268
+113  1  1499.268
+114  2  1500.732
+115  1  1499.268
+116  3  1502.197
+117  2  1500.732
+118  0  1497.803
+119  1  1499.268
+120  1  1499.268
+121  2  1500.732
+122  1  1499.268
+123  2  1500.732
+124  0  1497.803
+125  2  1500.732
+126  1  1499.268
+127  1  1499.268
+128  1  1499.268
+129  2  1500.732
+130  0  1497.803
+131  2  1500.732
+132  2  1500.732
+133  0  1497.803
+134  3  1502.197
+135  2  1500.732
+136  3  1502.197
+137  2  1500.732
+138  0  1497.803
+139  3  1502.197
+140  1  1499.268
+141  0  1497.803
+142  0  1497.803
+143  2  1500.732
+144  2  1500.732
+145  2  1500.732
+146  2  1500.732
+147  0  1497.803
+148  3  1502.197
+149  3  1502.197
+150  2  1500.732
+151  1  1499.268
+152  2  1500.732
+153  3  1502.197
+154  1  1499.268
+155  0  1497.803
+156  2  1500.732
+157  2  1500.732
+158  1  1499.268
+159  3  1502.197
+160  2  1500.732
+161  2  1500.732
+162  2  1500.732

Added: branches/wspr/conv232.f
===================================================================
--- branches/wspr/conv232.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/conv232.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,38 @@
+C  Layland-Lushbaugh polynomials for a K=32, r=1/2 convolutional code,
+C  and 8-bit parity lookup table.
+
+      data npoly1/Z'f2d05351'/,npoly2/Z'e4613c47'/
+      integer*1 partab(0:255)
+      data partab/
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   0, 1, 1, 0, 1, 0, 0, 1,
+     +   1, 0, 0, 1, 0, 1, 1, 0/

Added: branches/wspr/db.f
===================================================================
--- branches/wspr/db.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/db.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,5 @@
+	real function db(x)
+	db=-99.0
+	if(x.gt.1.259e-10) db=10.0*log10(x)
+	return
+	end

Added: branches/wspr/decode162.f
===================================================================
--- branches/wspr/decode162.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/decode162.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,177 @@
+      subroutine decode162(c2,npts,dtx,dfx,message,ncycles,metric,nerr)
+
+C  Decode MEPT_JT data, assuming that DT and DF have already been determined.
+
+      complex c2(npts)                        !Downsampled baseband data
+      real s2(77,126)
+      real s3(64,63)
+      character*22 message
+      character*12 callsign
+      character*4 grid
+      character*3 cdbm
+      real*8 dt,df,phi,f0,dphi,twopi,phi1,dphi1
+      complex*16 cz,cz1,c0,c1
+      integer*1 i1,symbol(162)
+      integer*1 data1(11)                   !Decoded data (8-bit bytes)
+      integer   data4a(7)                   !Decoded data (8-bit bytes)
+      integer   data4(12)                   !Decoded data (6-bit bytes)
+      integer amp
+      integer mettab(0:255,0:1)             !Metric table
+      logical first
+      integer*1 sym0
+      common/tst99/ sym0(162)
+      equivalence (i1,i4)
+      data first/.true./
+      integer npr3(162)
+      data npr3/
+     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     + 0,0/
+      data mettab/
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
+     +   2,   2,   2,   2,   1,   1,   1,   1,   0,   0,
+     +  -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,
+     +  -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,
+     + -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,
+     + -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,
+     + -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,
+     + -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,
+     + -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,
+     + -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,
+     + -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,
+     + -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,
+     + -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,
+     + -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,
+     + -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,
+     + -84, -87, -86, -87, -88,-105, -94,-105, -88, -87,
+     + -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,
+     + -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,
+     + -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,
+     + -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,
+     + -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,
+     + -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,
+     + -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,
+     + -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,
+     + -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,
+     + -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,
+     + -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,
+     + -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,
+     +  -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,
+     +  -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,
+     +   2,   2,   2,   2,   3,   3,   3,   3,   3,   3,
+     +   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5/
+      save
+
+      rewind 41
+
+      if(first) then
+         twopi=8*atan(1.d0)
+         dt=1.d0/375.d0                        !Sample interval
+         df=375.d0/256.d0
+         nsym=162
+         amp=32                                !### ??? ###
+         first=.false.
+      endif
+
+      istart=nint((dtx+2.0)/dt)              !Start index for synced FFTs
+      if(istart.lt.0) istart=0
+
+C  Should amp be adjusted according to signal strength?
+
+C  Compute soft symbols using differential BPSK demodulation
+      c0=0.                                !### C0=amp ???
+      k=istart
+      fac=1.e-4
+      phi=0.d0
+      phi1=0.d0
+      nspchip=256
+      nchips=1
+      fac2=0.001
+      do j=1,nsym
+         f0=dfx + (npr3(j)-1.5)*df
+         f1=dfx + (2+npr3(j)-1.5)*df
+         dphi=twopi*dt*f0
+         dphi1=twopi*dt*f1
+         sq0=0.
+         sq1=0.
+         do nc=1,nchips
+            phi=0.d0
+            phi1=0.d0
+            c0=0.
+            c1=0.
+            do i=1,nspchip
+               k=k+1
+               phi=phi+dphi
+               phi1=phi1+dphi1
+               cz=dcmplx(cos(phi),-sin(phi))
+               cz1=dcmplx(cos(phi1),-sin(phi1))
+               if(k.le.npts) then
+                  c0=c0 + c2(k)*cz                      !c2 was dat
+                  c1=c1 + c2(k)*cz1                     !c2 was dat
+               endif
+            enddo
+            sq0=sq0 + real(c0)**2 + aimag(c0)**2
+            sq1=sq1 + real(c1)**2 + aimag(c1)**2
+         enddo
+         sq0=fac2*sq0
+         sq1=fac2*sq1
+         rsym=amp*(sq1-sq0)
+         r=rsym+128.
+         if(r.gt.255.0) r=255.0
+         if(r.lt.0.0) r=0.0
+         i4=nint(r)
+         symbol(j)=i1
+         i4a=i4
+      enddo
+
+      ndelta=100
+      limit=100000
+      nbits=50+31
+      call inter_mept(symbol,-1)                      !Remove interleaving
+      call fano232(symbol,nbits,mettab,ndelta,limit,
+     +     data1,ncycles,metric,nerr)
+      message='                      '
+      cdbm='   '
+      if(nerr.ge.0) then
+         call unpack50(data1,n1,n2)
+         call unpackcall(n1,callsign)
+         call unpackgrid(n2/128,grid)
+         ndbm=iand(n2,127) - 64
+         i1=index(callsign,' ')
+         write(cdbm,'(i3)'),ndbm
+         if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+         if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+         message=callsign(1:i1)//grid//' '//cdbm
+      endif
+!      print*,nerr,ncycles,metric,callsign,grid,ndbm
+
+C  Save symbol spectra for possible decoding of average.
+
+      return
+      end

Added: branches/wspr/deg2grid.f
===================================================================
--- branches/wspr/deg2grid.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/deg2grid.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,30 @@
+      subroutine deg2grid(dlong0,dlat,grid)
+
+      real dlong                        !West longitude (deg)
+      real dlat                         !Latitude (deg)
+      character grid*6
+
+      dlong=dlong0
+      if(dlong.lt.-180.0) dlong=dlong+360.0
+      if(dlong.gt.180.0) dlong=dlong-360.0
+
+C  Convert to units of 5 min of longitude, working east from 180 deg.
+      nlong=60.0*(180.0-dlong)/5.0
+      n1=nlong/240                      !20-degree field
+      n2=(nlong-240*n1)/24              !2 degree square
+      n3=nlong-240*n1-24*n2             !5 minute subsquare
+      grid(1:1)=char(ichar('A')+n1)
+      grid(3:3)=char(ichar('0')+n2)
+      grid(5:5)=char(ichar('a')+n3)
+
+C  Convert to units of 2.5 min of latitude, working north from -90 deg.
+      nlat=60.0*(dlat+90)/2.5
+      n1=nlat/240                       !10-degree field
+      n2=(nlat-240*n1)/24               !1 degree square
+      n3=nlat-240*n1-24*n2              !2.5 minuts subsquare
+      grid(2:2)=char(ichar('A')+n1)
+      grid(4:4)=char(ichar('0')+n2)
+      grid(6:6)=char(ichar('a')+n3)
+
+      return
+      end

Added: branches/wspr/encode232.f
===================================================================
--- branches/wspr/encode232.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/encode232.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,29 @@
+      subroutine encode232(dat,nbytes,symbol,maxsym)
+
+C  Convolutional encoder for a K=32, r=1/2 code.
+
+      integer*1 dat(nbytes)             !User data, packed 8 bits per byte
+      integer*1 symbol(maxsym)          !Channel symbols, one bit per byte
+      integer*1 i1
+      include 'conv232.f'
+      equivalence (i1,i4)
+
+      nstate=0
+      k=0
+      do j=1,nbytes
+         do i=7,0,-1
+            i1=dat(j)
+            nstate=ior(ishft(nstate,1),iand(ishft(i4,-i),1))
+            n=iand(nstate,npoly1)
+            n=ieor(n,ishft(n,-16))
+            k=k+1
+            symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
+            n=iand(nstate,npoly2)
+            n=ieor(n,ishft(n,-16))
+            k=k+1
+            symbol(k)=partab(iand(ieor(n,ishft(n,-8)),255))
+         enddo
+      enddo
+
+      return
+      end

Added: branches/wspr/fano232.f
===================================================================
--- branches/wspr/fano232.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/fano232.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,159 @@
+      subroutine fano232(symbol,nbits,mettab,ndelta,maxcycles,
+     +   dat,ncycles,metric,ierr)
+
+C  Sequential decoder for K=32, r=1/2 convolutional code using 
+C  the Fano algorithm.  Translated from C routine for same purpose
+C  written by Phil Karn, KA9Q.
+
+      parameter (MAXBITS=103)
+      parameter (MAXDAT=(MAXBITS+7)/8)
+      integer*1 symbol(0:2*MAXBITS-1)     !Soft channel symbols (erase=128)
+      integer*1 dat(MAXDAT)               !Decoded user data, 8 bits per byte
+      integer mettab(0:255,0:1)           !Metric table
+
+C  These were the &quot;node&quot; structure in Karn's C code:
+      integer nstate(0:MAXBITS-1)      !Encoder state of next node
+      integer gamma(0:MAXBITS-1)       !Cumulative metric to this node
+      integer metrics(0:3,0:MAXBITS-1) !Metrics indexed by all possible Tx syms
+      integer tm(0:1,0:MAXBITS-1)      !Sorted metrics for current hypotheses
+      integer ii(0:MAXBITS-1)          !Current branch being tested
+
+      integer*1 i1a,i1b
+      logical noback
+      equivalence (i1a,i4a),(i1b,i4b)
+      include 'conv232.f'
+
+      ntail=nbits-31
+
+C  Compute all possible branch metrics for each symbol pair.
+C  This is the only place we actually look at the raw input symbols
+      i4a=0
+      i4b=0
+      do np=0,nbits-1
+         j=2*np
+         i1a=symbol(j)
+         i1b=symbol(j+1)
+         metrics(0,np) = mettab(i4a,0) + mettab(i4b,0)
+         metrics(1,np) = mettab(i4a,0) + mettab(i4b,1)
+         metrics(2,np) = mettab(i4a,1) + mettab(i4b,0)
+         metrics(3,np) = mettab(i4a,1) + mettab(i4b,1)
+      enddo
+
+      np=0
+      nstate(np)=0
+
+C  Compute and sort branch metrics from the root node
+      n=iand(nstate(np),npoly1)
+      n=ieor(n,ishft(n,-16))
+      lsym=partab(iand(ieor(n,ishft(n,-8)),255))
+      n=iand(nstate(np),npoly2)
+      n=ieor(n,ishft(n,-16))
+      lsym=lsym+lsym+partab(iand(ieor(n,ishft(n,-8)),255))
+      m0=metrics(lsym,np)
+      m1=metrics(ieor(3,lsym),np)
+      if(m0.gt.m1) then
+         tm(0,np)=m0                      !0-branch has better metric
+         tm(1,np)=m1
+      else
+         tm(0,np)=m1                      !1-branch is better
+         tm(1,np)=m0
+         nstate(np)=nstate(np) + 1        !Set low bit
+      endif
+
+C  Start with best branch
+      ii(np)=0
+      gamma(np)=0
+      nt=0
+
+C  Start the Fano decoder
+      do i=1,nbits*maxcycles
+C  Look forward
+         ngamma=gamma(np) + tm(ii(np),np)
+         if(ngamma.ge.nt) then
+
+C  Node is acceptable.  If first time visiting this node, tighten threshold:
+            if(gamma(np).lt.(nt+ndelta)) nt=nt + 
+     +                            ndelta * ((ngamma-nt)/ndelta)
+
+C  Move forward
+            gamma(np+1)=ngamma
+            nstate(np+1)=ishft(nstate(np),1)
+            np=np+1
+            if(np.eq.nbits-1) go to 100     !We're done!
+
+            n=iand(nstate(np),npoly1)
+            n=ieor(n,ishft(n,-16))
+            lsym=partab(iand(ieor(n,ishft(n,-8)),255))
+            n=iand(nstate(np),npoly2)
+            n=ieor(n,ishft(n,-16))
+            lsym=lsym+lsym+partab(iand(ieor(n,ishft(n,-8)),255))
+            
+            if(np.ge.ntail) then
+               tm(0,np)=metrics(lsym,np)      !We're in the tail, all zeros
+            else
+               m0=metrics(lsym,np)
+               m1=metrics(ieor(3,lsym),np)
+               if(m0.gt.m1) then
+                  tm(0,np)=m0                 !0-branch has better metric
+                  tm(1,np)=m1
+               else
+                  tm(0,np)=m1                 !1-branch is better
+                  tm(1,np)=m0
+                  nstate(np)=nstate(np) + 1   !Set low bit
+               endif
+            endif
+
+            ii(np)=0                          !Start with best branch
+            go to 99
+         endif
+
+C  Threshold violated, can't go forward
+ 10      noback=.false.
+         if(np.eq.0) noback=.true.
+         if(np.gt.0) then
+            if(gamma(np-1).lt.nt) noback=.true.
+         endif
+
+         if(noback) then
+C  Can't back up, either.  Relax threshold and look forward again 
+C  to a better branch.
+            nt=nt-ndelta
+            if(ii(np).ne.0) then
+               ii(np)=0
+               nstate(np)=ieor(nstate(np),1)
+            endif
+            go to 99
+         endif
+
+C  Back up
+         np=np-1
+         if(np.lt.ntail .and. ii(np).ne.1) then
+C  Search the next best branch
+            ii(np)=ii(np)+1
+            nstate(np)=ieor(nstate(np),1)
+            go to 99
+         endif
+         go to 10
+ 99      continue
+!         print*,np,nt,gamma(np)
+      enddo
+      i=nbits*maxcycles
+
+ 100  metric=gamma(np)                       !Final path metric
+
+C  Copy decoded data to user's buffer
+      nbytes=(nbits+7)/8
+      np=7
+      do j=1,nbytes-1
+         i4a=nstate(np)
+         dat(j)=i1a
+         np=np+8
+      enddo
+      dat(nbytes)=0
+
+      ncycles=i+1
+      ierr=0
+      if(i.ge.maxcycles*nbits) ierr=-1
+
+      return
+      end

Added: branches/wspr/four1.f
===================================================================
--- branches/wspr/four1.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/four1.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,49 @@
+      SUBROUTINE FOUR1(DATA,NN,ISIGN)
+      REAL*8 WR,WI,WPR,WPI,WTEMP,THETA
+      DIMENSION DATA(*)
+      N=2*NN
+      J=1
+      DO 11 I=1,N,2
+        IF(J.GT.I)THEN
+          TEMPR=DATA(J)
+          TEMPI=DATA(J+1)
+          DATA(J)=DATA(I)
+          DATA(J+1)=DATA(I+1)
+          DATA(I)=TEMPR
+          DATA(I+1)=TEMPI
+        ENDIF
+        M=N/2
+1       IF ((M.GE.2).AND.(J.GT.M)) THEN
+          J=J-M
+          M=M/2
+        GO TO 1
+        ENDIF
+        J=J+M
+11    CONTINUE
+      MMAX=2
+2     IF (N.GT.MMAX) THEN
+        ISTEP=2*MMAX
+        THETA=6.28318530717959D0/(ISIGN*MMAX)
+        WPR=-2.D0*DSIN(0.5D0*THETA)**2
+        WPI=DSIN(THETA)
+        WR=1.D0
+        WI=0.D0
+        DO 13 M=1,MMAX,2
+          DO 12 I=M,N,ISTEP
+            J=I+MMAX
+            TEMPR=(WR)*DATA(J)-(WI)*DATA(J+1)
+            TEMPI=(WR)*DATA(J+1)+(WI)*DATA(J)
+            DATA(J)=DATA(I)-TEMPR
+            DATA(J+1)=DATA(I+1)-TEMPI
+            DATA(I)=DATA(I)+TEMPR
+            DATA(I+1)=DATA(I+1)+TEMPI
+12        CONTINUE
+          WTEMP=WR
+          WR=WR*WPR-WI*WPI+WR
+          WI=WI*WPR+WTEMP*WPI+WI
+13      CONTINUE
+        MMAX=ISTEP
+      GO TO 2
+      ENDIF
+      RETURN
+      END

Added: branches/wspr/four2.f
===================================================================
--- branches/wspr/four2.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/four2.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,350 @@
+      SUBROUTINE FOUR2a (DATA,N,NDIM,ISIGN,IFORM)
+
+C     Cooley-Tukey fast Fourier transform in USASI basic Fortran.
+C     multi-dimensional transform, each dimension a power of two,
+C     complex or real data.
+
+C     TRANSFORM(K1,K2,...) = SUM(DATA(J1,J2,...)*EXP(ISIGN*2*PI*SQRT(-1)
+C     *((J1-1)*(K1-1)/N(1)+(J2-1)*(K2-1)/N(2)+...))), summed for all
+C     J1 and K1 from 1 to N(1), J2 and K2 from 1 TO N(2),
+C     etc, for all NDIM subscripts.  NDIM must be positive and
+C     each N(IDIM) must be a power of two.  ISIGN is +1 or -1.
+C     Let NTOT = N(1)*N(2)*...*N(NDIM).  Then a -1 transform
+C     followed by a +1 one (or vice versa) returns NTOT
+C     times the original data.  
+
+C     IFORM = 1, 0 or -1, as data is
+C     complex, real, or the first half of a complex array.  Transform
+C     values are returned in array DATA.  They are complex, real, or
+C     the first half of a complex array, as IFORM = 1, -1 or 0.
+
+C     The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
+C     by ... will be returned in the same array, now considered to
+C     be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
+C     IFORM = 0 or -1, N(1) must be even, and enough room must be
+C     reserved.  The missing values may be obtained by complex conjuga-
+C     tion.  
+
+C     The reverse transformation of a half complex array dimensioned
+C     N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
+C     to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
+C     The transform will be real and returned to the input array.
+
+C     Running time is proportional to NTOT*LOG2(NTOT), rather than
+C     the naive NTOT**2.  Furthermore, less error is built up.
+
+C     Written by Norman Brenner of MIT Lincoln Laboratory, January 1969.
+C     See IEEE Audio Transactions (June 1967), Special issue on FFT.
+
+      parameter(NMAX=2048*1024)
+      DIMENSION DATA(NMAX), N(1)
+      NTOT=1
+      DO 10 IDIM=1,NDIM
+ 10   NTOT=NTOT*N(IDIM)
+      IF (IFORM) 70,20,20
+ 20   NREM=NTOT
+      DO 60 IDIM=1,NDIM
+      NREM=NREM/N(IDIM)
+      NPREV=NTOT/(N(IDIM)*NREM)
+      NCURR=N(IDIM)
+      IF (IDIM-1+IFORM) 30,30,40
+ 30   NCURR=NCURR/2
+ 40   CALL BITRV (DATA,NPREV,NCURR,NREM)
+      CALL COOL2 (DATA,NPREV,NCURR,NREM,ISIGN)
+      IF (IDIM-1+IFORM) 50,50,60
+ 50   CALL FIXRL (DATA,N(1),NREM,ISIGN,IFORM)
+      NTOT=(NTOT/N(1))*(N(1)/2+1)
+ 60   CONTINUE
+      RETURN
+ 70   NTOT=(NTOT/N(1))*(N(1)/2+1)
+      NREM=1
+      DO 100 JDIM=1,NDIM
+      IDIM=NDIM+1-JDIM
+      NCURR=N(IDIM)
+      IF (IDIM-1) 80,80,90
+ 80   NCURR=NCURR/2
+      CALL FIXRL (DATA,N(1),NREM,ISIGN,IFORM)
+      NTOT=NTOT/(N(1)/2+1)*N(1)
+ 90   NPREV=NTOT/(N(IDIM)*NREM)
+      CALL BITRV (DATA,NPREV,NCURR,NREM)
+      CALL COOL2 (DATA,NPREV,NCURR,NREM,ISIGN)
+ 100  NREM=NREM*N(IDIM)
+      RETURN
+      END
+      SUBROUTINE BITRV (DATA,NPREV,N,NREM)
+C     SHUFFLE THE DATA BY BIT REVERSAL.
+C     DIMENSION DATA(NPREV,N,NREM)
+C     COMPLEX DATA
+C     EXCHANGE DATA(J1,J4REV,J5) WITH DATA(J1,J4,J5) FOR ALL J1 FROM 1
+C     TO NPREV, ALL J4 FROM 1 TO N (WHICH MUST BE A POWER OF TWO), AND
+C     ALL J5 FROM 1 TO NREM.  J4REV-1 IS THE BIT REVERSAL OF J4-1.  E.G.
+C     SUPPOSE N = 32.  THEN FOR J4-1 = 10011, J4REV-1 = 11001, ETC.
+      parameter(NMAX=2048*1024)
+      DIMENSION DATA(NMAX)
+      IP0=2
+      IP1=IP0*NPREV
+      IP4=IP1*N
+      IP5=IP4*NREM
+      I4REV=1
+C     I4REV = 1+(J4REV-1)*IP1
+      DO 60 I4=1,IP4,IP1
+C     I4 = 1+(J4-1)*IP1
+      IF (I4-I4REV) 10,30,30
+ 10   I1MAX=I4+IP1-IP0
+      DO 20 I1=I4,I1MAX,IP0
+C     I1 = 1+(J1-1)*IP0+(J4-1)*IP1
+      DO 20 I5=I1,IP5,IP4
+C     I5 = 1+(J1-1)*IP0+(J4-1)*IP1+(J5-1)*IP4
+      I5REV=I4REV+I5-I4
+C     I5REV = 1+(J1-1)*IP0+(J4REV-1)*IP1+(J5-1)*IP4
+      TEMPR=DATA(I5)
+      TEMPI=DATA(I5+1)
+      DATA(I5)=DATA(I5REV)
+      DATA(I5+1)=DATA(I5REV+1)
+      DATA(I5REV)=TEMPR
+ 20   DATA(I5REV+1)=TEMPI
+C     ADD ONE WITH DOWNWARD CARRY TO THE HIGH ORDER BIT OF J4REV-1.
+ 30   IP2=IP4/2
+ 40   IF (I4REV-IP2) 60,60,50
+ 50   I4REV=I4REV-IP2
+      IP2=IP2/2
+      IF (IP2-IP1) 60,40,40
+ 60   I4REV=I4REV+IP2
+      RETURN
+      END
+      SUBROUTINE COOL2 (DATA,NPREV,N,NREM,ISIGN)
+C     DISCRETE FOURIER TRANSFORM OF LENGTH N.  IN-PLACE COOLEY-TUKEY
+C     ALGORITHM, BIT-REVERSED TO NORMAL ORDER, SANDE-TUKEY PHASE SHIFTS.
+C     DIMENSION DATA(NPREV,N,NREM)
+C     COMPLEX DATA
+C     DATA(J1,K4,J5) = SUM(DATA(J1,J4,J5)*EXP(ISIGN*2*PI*I*(J4-1)*
+C     (K4-1)/N)), SUMMED OVER J4 = 1 TO N FOR ALL J1 FROM 1 TO NPREV,
+C     K4 FROM 1 TO N AND J5 FROM 1 TO NREM.  N MUST BE A POWER OF TWO.
+C     METHOD--LET IPREV TAKE THE VALUES 1, 2 OR 4, 4 OR 8, ..., N/16,
+C     N/4, N.  THE CHOICE BETWEEN 2 OR 4, ETC., DEPENDS ON WHETHER N IS
+C     A POWER OF FOUR.  DEFINE IFACT = 2 OR 4, THE NEXT FACTOR THAT
+C     IPREV MUST TAKE, AND IREM = N/(IFACT*IPREV).  THEN--
+C     DIMENSION DATA(NPREV,IPREV,IFACT,IREM,NREM)
+C     COMPLEX DATA
+C     DATA(J1,J2,K3,J4,J5) = SUM(DATA(J1,J2,J3,J4,J5)*EXP(ISIGN*2*PI*I*
+C     (K3-1)*((J3-1)/IFACT+(J2-1)/(IFACT*IPREV)))), SUMMED OVER J3 = 1
+C     TO IFACT FOR ALL J1 FROM 1 TO NPREV, J2 FROM 1 TO IPREV, K3 FROM
+C     1 TO IFACT, J4 FROM 1 TO IREM AND J5 FROM 1 TO NREM.  THIS IS
+C     A PHASE-SHIFTED DISCRETE FOURIER TRANSFORM OF LENGTH IFACT.
+C     FACTORING N BY FOURS SAVES ABOUT TWENTY FIVE PERCENT OVER FACTOR-
+C     ING BY TWOS.  DATA MUST BE BIT-REVERSED INITIALLY.
+C     IT IS NOT NECESSARY TO REWRITE THIS SUBROUTINE INTO COMPLEX
+C     NOTATION SO LONG AS THE FORTRAN COMPILER USED STORES REAL AND
+C     IMAGINARY PARTS IN ADJACENT STORAGE LOCATIONS.  IT MUST ALSO
+C     STORE ARRAYS WITH THE FIRST SUBSCRIPT INCREASING FASTEST.
+      parameter(NMAX=2048*1024)
+      DIMENSION DATA(NMAX)
+
+      real*8 twopi,wstpr,wstpi,wr,wi,w2r,w2i,w3r,w3i,wtempr
+
+      TWOPI=6.2831853072*FLOAT(ISIGN)
+      IP0=2
+      IP1=IP0*NPREV
+      IP4=IP1*N
+      IP5=IP4*NREM
+      IP2=IP1
+C     IP2=IP1*IPROD
+      NPART=N
+ 10   IF (NPART-2) 60,30,20
+ 20   NPART=NPART/4
+      GO TO 10
+C     DO A FOURIER TRANSFORM OF LENGTH TWO
+ 30   IF (IP2-IP4) 40,160,160
+ 40   IP3=IP2*2
+C     IP3=IP2*IFACT
+      DO 50 I1=1,IP1,IP0
+C     I1 = 1+(J1-1)*IP0
+      DO 50 I5=I1,IP5,IP3
+C     I5 = 1+(J1-1)*IP0+(J4-1)*IP3+(J5-1)*IP4
+      I3A=I5
+      I3B=I3A+IP2
+C     I3 = 1+(J1-1)*IP0+(J2-1)*IP1+(J3-1)*IP2+(J4-1)*IP3+(J5-1)*IP4
+      TEMPR=DATA(I3B)
+      TEMPI=DATA(I3B+1)
+      DATA(I3B)=DATA(I3A)-TEMPR
+      DATA(I3B+1)=DATA(I3A+1)-TEMPI
+      DATA(I3A)=DATA(I3A)+TEMPR
+ 50   DATA(I3A+1)=DATA(I3A+1)+TEMPI
+      IP2=IP3
+C     DO A FOURIER TRANSFORM OF LENGTH FOUR (FROM BIT REVERSED ORDER)
+ 60   IF (IP2-IP4) 70,160,160
+ 70   IP3=IP2*4
+C     IP3=IP2*IFACT
+C     COMPUTE TWOPI THRU WR AND WI IN DOUBLE PRECISION, IF AVAILABLE.
+      THETA=TWOPI/FLOAT(IP3/IP1)
+      SINTH=SIN(THETA/2)
+      WSTPR=-2*SINTH*SINTH
+      WSTPI=SIN(THETA)
+      WR=1.
+      WI=0.
+      DO 150 I2=1,IP2,IP1
+C     I2 = 1+(J2-1)*IP1
+      IF (I2-1) 90,90,80
+ 80   W2R=WR*WR-WI*WI
+      W2I=2*WR*WI
+      W3R=W2R*WR-W2I*WI
+      W3I=W2R*WI+W2I*WR
+ 90   I1MAX=I2+IP1-IP0
+      DO 140 I1=I2,I1MAX,IP0
+C     I1 = 1+(J1-1)*IP0+(J2-1)*IP1
+      DO 140 I5=I1,IP5,IP3
+C     I5 = 1+(J1-1)*IP0+(J2-1)*IP1+(J4-1)*IP3+(J5-1)*IP4
+      I3A=I5
+      I3B=I3A+IP2
+      I3C=I3B+IP2
+      I3D=I3C+IP2
+C     I3 = 1+(J1-1)*IP0+(J2-1)*IP1+(J3-1)*IP2+(J4-1)*IP3+(J5-1)*IP4
+      IF (I2-1) 110,110,100
+C     APPLY THE PHASE SHIFT FACTORS
+ 100  TEMPR=DATA(I3B)
+      DATA(I3B)=W2R*DATA(I3B)-W2I*DATA(I3B+1)
+      DATA(I3B+1)=W2R*DATA(I3B+1)+W2I*TEMPR
+      TEMPR=DATA(I3C)
+      DATA(I3C)=WR*DATA(I3C)-WI*DATA(I3C+1)
+      DATA(I3C+1)=WR*DATA(I3C+1)+WI*TEMPR
+      TEMPR=DATA(I3D)
+      DATA(I3D)=W3R*DATA(I3D)-W3I*DATA(I3D+1)
+      DATA(I3D+1)=W3R*DATA(I3D+1)+W3I*TEMPR
+ 110  T0R=DATA(I3A)+DATA(I3B)
+      T0I=DATA(I3A+1)+DATA(I3B+1)
+      T1R=DATA(I3A)-DATA(I3B)
+      T1I=DATA(I3A+1)-DATA(I3B+1)
+      T2R=DATA(I3C)+DATA(I3D)
+      T2I=DATA(I3C+1)+DATA(I3D+1)
+      T3R=DATA(I3C)-DATA(I3D)
+      T3I=DATA(I3C+1)-DATA(I3D+1)
+      DATA(I3A)=T0R+T2R
+      DATA(I3A+1)=T0I+T2I
+      DATA(I3C)=T0R-T2R
+      DATA(I3C+1)=T0I-T2I
+      IF (ISIGN) 120,120,130
+ 120  T3R=-T3R
+      T3I=-T3I
+ 130  DATA(I3B)=T1R-T3I
+      DATA(I3B+1)=T1I+T3R
+      DATA(I3D)=T1R+T3I
+ 140  DATA(I3D+1)=T1I-T3R
+      WTEMPR=WR
+      WR=WSTPR*WTEMPR-WSTPI*WI+WTEMPR
+ 150  WI=WSTPR*WI+WSTPI*WTEMPR+WI
+      IP2=IP3
+      GO TO 60
+ 160  RETURN
+      END
+      SUBROUTINE FIXRL (DATA,N,NREM,ISIGN,IFORM)
+C     FOR IFORM = 0, CONVERT THE TRANSFORM OF A DOUBLED-UP REAL ARRAY,
+C     CONSIDERED COMPLEX, INTO ITS TRUE TRANSFORM.  SUPPLY ONLY THE
+C     FIRST HALF OF THE COMPLEX TRANSFORM, AS THE SECOND HALF HAS
+C     CONJUGATE SYMMETRY.  FOR IFORM = -1, CONVERT THE FIRST HALF
+C     OF THE TRUE TRANSFORM INTO THE TRANSFORM OF A DOUBLED-UP REAL
+C     ARRAY.  N MUST BE EVEN.
+C     USING COMPLEX NOTATION AND SUBSCRIPTS STARTING AT ZERO, THE
+C     TRANSFORMATION IS--
+C     DIMENSION DATA(N,NREM)
+C     ZSTP = EXP(ISIGN*2*PI*I/N)
+C     DO 10 I2=0,NREM-1
+C     DATA(0,I2) = CONJ(DATA(0,I2))*(1+I)
+C     DO 10 I1=1,N/4
+C     Z = (1+(2*IFORM+1)*I*ZSTP**I1)/2
+C     I1CNJ = N/2-I1
+C     DIF = DATA(I1,I2)-CONJ(DATA(I1CNJ,I2))
+C     TEMP = Z*DIF
+C     DATA(I1,I2) = (DATA(I1,I2)-TEMP)*(1-IFORM)
+C 10  DATA(I1CNJ,I2) = (DATA(I1CNJ,I2)+CONJ(TEMP))*(1-IFORM)
+C     IF I1=I1CNJ, THE CALCULATION FOR THAT VALUE COLLAPSES INTO
+C     A SIMPLE CONJUGATION OF DATA(I1,I2).
+      parameter(NMAX=4048*1024)
+      DIMENSION DATA(NMAX)
+      TWOPI=6.283185307*FLOAT(ISIGN)
+      IP0=2
+      IP1=IP0*(N/2)
+      IP2=IP1*NREM
+      IF (IFORM) 10,70,70
+C     PACK THE REAL INPUT VALUES (TWO PER COLUMN)
+ 10   J1=IP1+1
+      DATA(2)=DATA(J1)
+      IF (NREM-1) 70,70,20
+ 20   J1=J1+IP0
+      I2MIN=IP1+1
+      DO 60 I2=I2MIN,IP2,IP1
+      DATA(I2)=DATA(J1)
+      J1=J1+IP0
+      IF (N-2) 50,50,30
+ 30   I1MIN=I2+IP0
+      I1MAX=I2+IP1-IP0
+      DO 40 I1=I1MIN,I1MAX,IP0
+      DATA(I1)=DATA(J1)
+      DATA(I1+1)=DATA(J1+1)
+ 40   J1=J1+IP0
+ 50   DATA(I2+1)=DATA(J1)
+ 60   J1=J1+IP0
+ 70   DO 80 I2=1,IP2,IP1
+      TEMPR=DATA(I2)
+      DATA(I2)=DATA(I2)+DATA(I2+1)
+ 80   DATA(I2+1)=TEMPR-DATA(I2+1)
+      IF (N-2) 200,200,90
+ 90   THETA=TWOPI/FLOAT(N)
+      SINTH=SIN(THETA/2.)
+      ZSTPR=-2.*SINTH*SINTH
+      ZSTPI=SIN(THETA)
+      ZR=(1.-ZSTPI)/2.
+      ZI=(1.+ZSTPR)/2.
+      IF (IFORM) 100,110,110
+ 100  ZR=1.-ZR
+      ZI=-ZI
+ 110  I1MIN=IP0+1
+      I1MAX=IP0*(N/4)+1
+      DO 190 I1=I1MIN,I1MAX,IP0
+      DO 180 I2=I1,IP2,IP1
+      I2CNJ=IP0*(N/2+1)-2*I1+I2
+      IF (I2-I2CNJ) 150,120,120
+ 120  IF (ISIGN*(2*IFORM+1)) 130,140,140
+ 130  DATA(I2+1)=-DATA(I2+1)
+ 140  IF (IFORM) 170,180,180
+ 150  DIFR=DATA(I2)-DATA(I2CNJ)
+      DIFI=DATA(I2+1)+DATA(I2CNJ+1)
+      TEMPR=DIFR*ZR-DIFI*ZI
+      TEMPI=DIFR*ZI+DIFI*ZR
+      DATA(I2)=DATA(I2)-TEMPR
+      DATA(I2+1)=DATA(I2+1)-TEMPI
+      DATA(I2CNJ)=DATA(I2CNJ)+TEMPR
+      DATA(I2CNJ+1)=DATA(I2CNJ+1)-TEMPI
+      IF (IFORM) 160,180,180
+ 160  DATA(I2CNJ)=DATA(I2CNJ)+DATA(I2CNJ)
+      DATA(I2CNJ+1)=DATA(I2CNJ+1)+DATA(I2CNJ+1)
+ 170  DATA(I2)=DATA(I2)+DATA(I2)
+      DATA(I2+1)=DATA(I2+1)+DATA(I2+1)
+ 180  CONTINUE
+      TEMPR=ZR-.5
+      ZR=ZSTPR*TEMPR-ZSTPI*ZI+ZR
+ 190  ZI=ZSTPR*ZI+ZSTPI*TEMPR+ZI
+C     RECURSION SAVES TIME, AT A SLIGHT LOSS IN ACCURACY.  IF AVAILABLE,
+C     USE DOUBLE PRECISION TO COMPUTE ZR AND ZI.
+ 200  IF (IFORM) 270,210,210
+C     UNPACK THE REAL TRANSFORM VALUES (TWO PER COLUMN)
+ 210  I2=IP2+1
+      I1=I2
+      J1=IP0*(N/2+1)*NREM+1
+      GO TO 250
+ 220  DATA(J1)=DATA(I1)
+      DATA(J1+1)=DATA(I1+1)
+      I1=I1-IP0
+      J1=J1-IP0
+ 230  IF (I2-I1) 220,240,240
+ 240  DATA(J1)=DATA(I1)
+      DATA(J1+1)=0.
+ 250  I2=I2-IP1
+      J1=J1-IP0
+      DATA(J1)=DATA(I2+1)
+      DATA(J1+1)=0.
+      I1=I1-IP0
+      J1=J1-IP0
+      IF (I2-1) 260,260,230
+ 260  DATA(2)=0.
+ 270  RETURN
+      END

Added: branches/wspr/g.py
===================================================================
--- branches/wspr/g.py	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/g.py	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,32 @@
+DFreq=0.0
+Freq=0.0
+PingTime=0.0
+PingFile=&quot;current&quot;
+report=&quot;26&quot;
+rms=1.0
+mode_change=0
+showspecjt=0
+g2font='courier 16 bold'
+
+#------------------------------------------------------ ftnstr
+def ftnstr(x):
+    y=&quot;&quot;
+    xs=x.tostring()
+    for i in range(len(xs)):
+        y=y+xs[i]
+    return y
+
+#------------------------------------------------------ filetime
+def filetime(t):
+#    i=t.rfind(&quot;.&quot;)
+    i=rfnd(t,&quot;.&quot;)
+    t=t[:i][-6:]
+    t=t[0:2]+&quot;:&quot;+t[2:4]+&quot;:&quot;+t[4:6]
+    return t
+
+#------------------------------------------------------ rfnd
+#Temporary workaround to replace t.rfind(c)
+def rfnd(t,c):
+    for i in range(len(t)-1,0,-1):
+        if t[i:i+1]==c: return i
+    return -1

Added: branches/wspr/genmept.f
===================================================================
--- branches/wspr/genmept.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/genmept.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,117 @@
+      subroutine genmept(call1,grid,ndbm,ntxdf,snrdb,iwave)
+
+C  Encode an MEPT_JT message and generate the corresponding wavefile.
+
+      character*12 call1,call2
+      character*4 grid,grid2
+      parameter (NMAX=120*12000)     !Max length of wave file
+      character*22 message           !Message to be generated
+      integer*2 iwave(NMAX)          !Generated wave file
+
+      parameter (MAXSYM=176)
+      integer*1 symbol(MAXSYM)
+      integer*1 data0(11),data1(11),i1
+      integer npr3(162)
+      real pr3(162)
+      logical first,lbad1,lbad2
+      real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,tsymbol
+      character*22 msgsent           !Message sent
+      equivalence(i1,i4)
+      data npr3/
+     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     + 0,0/
+
+      data first/.true./,idum/0/
+      save
+
+      nsym=162                               !Symbols per transmission
+      if(first) then
+         do i=1,nsym
+            pr3(i)=2*npr3(i)-1
+         enddo
+         pi=4.d0*atan(1.d0)
+         twopi=2.d0*pi
+         first=.false.
+      endif
+
+      call packcall(call1,n1,lbad1)
+      call packgrid(grid,ng,lbad2)
+      n2=128*ng + (ndbm+64)
+      call pack50(n1,n2,data0)             !Pack 8 bits per byte, add tail
+      nbytes=(50+31+7)/8
+      call encode232(data0,nbytes,symbol,MAXSYM)  !Convolutional encoding
+      call inter_mept(symbol,1)                   !Apply interleaving
+      do i=1,162
+         i4=0
+         i1=symbol(i)
+      enddo
+
+      call unpackcall(n1,call2)
+      call unpackgrid(n2/128,grid2)
+      ndbm2=iand(n2,127) - 64
+      if(lbad1 .or. lbad2 .or. (call1.ne.call2) .or. 
+     +   (grid.ne.grid2) .or. (ndbm.ne.ndbm2)) then
+         print*,'Error in structure of Tx message'
+         stop
+      endif
+
+C  Set up necessary constants
+      tsymbol=8192.d0/12000.d0
+      dt=1.d0/12000.d0
+      f0=1500 + ntxdf
+      dfgen=12000.d0/8192.d0                     !1.4649 Hz
+      nsigs=1
+      if(snrdb.eq.10.0) nsigs=10
+      do isig=1,nsigs
+         if(nsigs.eq.1) snr=10.0**(0.05*(snrdb-1))   !Bandwidth correction?
+         fac=3000.0
+         if(snr.gt.1.0) fac=3000.0/snr
+         if(nsigs.eq.10) then
+            snr=10.0**(0.05*(-20-isig-1))
+            f0=1390 + 20*isig
+         endif
+         t=-2.d0 - 0.1*(isig-1)
+         phi=0.d0
+         j0=0
+
+         do i=1,NMAX
+            t=t+dt
+            j=int(t/tsymbol) + 1                          !Symbol number
+            sig=0.
+            if(j.ge.1 .and. j.le.162) then
+               if(j.ne.j0) then
+                  f=f0 + dfgen*(npr3(j)+2*symbol(j)-1.5)
+                  j0=j
+                  dphi=twopi*dt*f
+               endif
+               sig=0.9999
+            endif
+            phi=phi+dphi
+            if(snrdb.gt.50.0) then
+               n=32767.0*sin(phi)           !Normal transmission, signal only
+            else
+               if(isig.eq.1) then
+                  n=fac*(gran(idum) + sig*snr*sin(phi))
+               else
+                  n=iwave(i) + fac*sig*snr*sin(phi)
+               endif
+               if(n.gt.32767) n=32767
+               if(n.lt.-32767) n=-32767
+            endif
+            iwave(i)=n
+ 10         continue
+         enddo
+      enddo
+
+ 100  continue
+
+      return
+      end
+

Added: branches/wspr/getrms.f
===================================================================
--- branches/wspr/getrms.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/getrms.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,32 @@
+      subroutine getrms(iwave,npts,ave,rms)
+
+      parameter (NMAX=120*12000)
+      integer*2 iwave(NMAX)
+      real*8 sq
+
+      s=0.
+      do i=1,npts
+         s=s + iwave(i)
+      enddo
+      ave=s/npts
+      sq=0.
+      do i=1,npts
+         sq=sq + (iwave(i)-ave)**2
+      enddo
+      rms=sqrt(sq/npts)
+      fac=3000.0/rms
+      do i=1,npts
+         n=nint(fac*(iwave(i)-ave))
+         if(n.gt.32767) n=32767
+         if(n.lt.-32767) n=-32767
+         iwave(i)=n
+      enddo
+
+      if(npts.lt.NMAX) then
+         do i=npts+1,NMAX
+            iwave(i)=0
+         enddo
+      endif
+
+      return
+      end

Added: branches/wspr/getsound.c
===================================================================
--- branches/wspr/getsound.c	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/getsound.c	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,174 @@
+/** @file patest_record.c
+	@brief Record input into an array; Save array to a file; Playback recorded data.
+	@author Phil Burk  <A HREF="http://www.softsynth.com">http://www.softsynth.com</A>
+*/
+/*
+ * $Id: patest_record.c 249 2006-08-09 20:08:01Z va3db $
+ *
+ * This program uses the PortAudio Portable Audio Library.
+ * For more information see: <A HREF="http://www.portaudio.com">http://www.portaudio.com</A>
+ * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the &quot;Software&quot;), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;portaudio.h&quot;
+
+#define SAMPLE_RATE  (12000)
+#define FRAMES_PER_BUFFER (1024)
+#define NUM_SECONDS     (114)
+#define NUM_CHANNELS    (1)
+/* #define DITHER_FLAG     (paDitherOff) */
+#define DITHER_FLAG     (0) /**/
+
+#define PA_SAMPLE_TYPE  paInt16
+typedef short SAMPLE;
+#define SAMPLE_SILENCE  (0)
+
+typedef struct
+{
+  int          frameIndex;  /* Index into sample array. */
+  int          maxFrameIndex;
+  SAMPLE      *recordedSamples;
+} paTestData;
+
+/* This routine will be called by the PortAudio engine when audio is needed.
+** It may be called at interrupt level on some machines so don't do anything
+** that could mess up the system like calling malloc() or free().
+*/
+static int recordCallback( const void *inputBuffer, void *outputBuffer,
+                           unsigned long framesPerBuffer,
+                           const PaStreamCallbackTimeInfo* timeInfo,
+                           PaStreamCallbackFlags statusFlags,
+                           void *userData )
+{
+  paTestData *data = (paTestData*)userData;
+  const SAMPLE *rptr = (const SAMPLE*)inputBuffer;
+  SAMPLE *wptr = &amp;data-&gt;recordedSamples[data-&gt;frameIndex * NUM_CHANNELS];
+  long framesToCalc;
+  long i;
+  int finished;
+  unsigned long framesLeft = data-&gt;maxFrameIndex - data-&gt;frameIndex;
+
+  (void) outputBuffer; /* Prevent unused variable warnings. */
+  (void) timeInfo;
+  (void) statusFlags;
+  (void) userData;
+
+  if( framesLeft &lt; framesPerBuffer ) {
+    framesToCalc = framesLeft;
+    finished = paComplete;
+  }
+   else {
+     framesToCalc = framesPerBuffer;
+     finished = paContinue;
+   }
+
+  if( inputBuffer == NULL ) {
+    for( i=0; i&lt;framesToCalc; i++ ) {
+      *wptr++ = SAMPLE_SILENCE;                          /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = SAMPLE_SILENCE;  /* right */
+    }
+  }
+  else {
+    for( i=0; i&lt;framesToCalc; i++ ) {
+      *wptr++ = *rptr++;  /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = *rptr++;  /* right */
+    }
+  }
+  data-&gt;frameIndex += framesToCalc;
+  return finished;
+}
+
+/*******************************************************************/
+#ifdef CVF
+extern int __stdcall GETSOUND(short int iwave[])
+#else
+extern int getsound_(short int iwave[])
+#endif
+{
+  PaStreamParameters  inputParameters,
+                      outputParameters;
+  PaStream*           stream;
+  PaError             err = paNoError;
+  paTestData          data;
+  int                 i;
+  int                 totalFrames;
+  int                 numSamples;
+  int                 numBytes;
+  SAMPLE              max, val;
+  double              average;
+
+  data.maxFrameIndex = totalFrames = NUM_SECONDS * SAMPLE_RATE;
+  data.frameIndex = 0;
+  numSamples = totalFrames * NUM_CHANNELS;
+  numBytes = numSamples * sizeof(SAMPLE);
+  data.recordedSamples = iwave;
+  for( i=0; i&lt;numSamples; i++ ) 
+    data.recordedSamples[i] = 0;
+
+  err = Pa_Initialize();
+  if( err != paNoError ) goto done;
+
+  inputParameters.device = Pa_GetDefaultInputDevice();
+  inputParameters.channelCount = 1;
+  inputParameters.sampleFormat = PA_SAMPLE_TYPE;
+  inputParameters.suggestedLatency = Pa_GetDeviceInfo( inputParameters.device )-&gt;defaultLowInputLatency;
+  inputParameters.hostApiSpecificStreamInfo = NULL;
+
+  err = Pa_OpenStream(
+              &amp;stream,
+              &amp;inputParameters,
+              NULL,                  /* &amp;outputParameters, */
+              SAMPLE_RATE,
+              FRAMES_PER_BUFFER,
+              paClipOff,
+              recordCallback,
+              &amp;data );
+  if( err != paNoError ) goto done;
+
+  err = Pa_StartStream( stream );
+  if( err != paNoError ) goto done;
+
+  while( ( err = Pa_IsStreamActive( stream ) ) == 1 ) {
+    Pa_Sleep(100);
+  }
+  if( err &lt; 0 ) goto done;
+
+  err = Pa_CloseStream( stream );    
+
+done:
+  Pa_Terminate();
+  if( err != paNoError ) {
+    fprintf( stderr, &quot;An error occured while using the portaudio stream\n&quot; );
+    fprintf( stderr, &quot;Error number: %d\n&quot;, err );
+    fprintf( stderr, &quot;Error message: %s\n&quot;, Pa_GetErrorText( err ) );
+    err = 1;          /* Always return 0 or 1, but no other return codes. */
+  }
+  return err;
+}
+

Added: branches/wspr/gran.f90
===================================================================
--- branches/wspr/gran.f90	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/gran.f90	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,12 @@
+real function gran(idum)
+
+  real r(12)
+  if(idum.lt.0) then
+     call random_seed
+     idum=0
+  endif
+  call random_number(r)
+  gran=sum(r)-6.0
+  return
+
+end function gran

Added: branches/wspr/grid2deg.f
===================================================================
--- branches/wspr/grid2deg.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/grid2deg.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,40 @@
+      subroutine grid2deg(grid0,dlong,dlat)
+
+C  Converts Maidenhead grid locator to degrees of West longitude
+C  and North latitude.
+
+      character*6 grid0,grid
+      character*1 g1,g2,g3,g4,g5,g6
+
+      grid=grid0
+      i=ichar(grid(5:5))
+      if(grid(5:5).eq.' ' .or. i.le.64 .or. i.ge.128) grid(5:6)='mm'
+
+      if(grid(1:1).ge.'a' .and. grid(1:1).le.'z') grid(1:1)= 
+     +   char(ichar(grid(1:1))+ichar('A')-ichar('a'))
+      if(grid(2:2).ge.'a' .and. grid(2:2).le.'z') grid(2:2)=
+     +   char(ichar(grid(2:2))+ichar('A')-ichar('a'))
+      if(grid(5:5).ge.'A' .and. grid(5:5).le.'Z') grid(5:5)=
+     +   char(ichar(grid(5:5))-ichar('A')+ichar('a'))
+      if(grid(6:6).ge.'A' .and. grid(6:6).le.'Z') grid(6:6)=
+     +   char(ichar(grid(6:6))-ichar('A')+ichar('a'))
+
+      g1=grid(1:1)
+      g2=grid(2:2)
+      g3=grid(3:3)
+      g4=grid(4:4)
+      g5=grid(5:5)
+      g6=grid(6:6)
+
+      nlong = 180 - 20*(ichar(g1)-ichar('A'))
+      n20d = 2*(ichar(g3)-ichar('0'))
+      xminlong = 5*(ichar(g5)-ichar('a')+0.5)
+      dlong = nlong - n20d - xminlong/60.0
+c      print*,nlong,n20d,xminlong,dlong
+      nlat = -90+10*(ichar(g2)-ichar('A')) + ichar(g4)-ichar('0')
+      xminlat = 2.5*(ichar(g6)-ichar('a')+0.5)
+      dlat = nlat + xminlat/60.0
+c      print*,nlat,xminlat,dlat
+
+      return
+      end

Added: branches/wspr/inter_mept.f
===================================================================
--- branches/wspr/inter_mept.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/inter_mept.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,43 @@
+      subroutine inter_mept(id,ndir)
+
+C  Interleave (ndir=1) or de-interleave (ndir=-1) the array id.
+
+      integer*1 id(0:161),itmp(0:161)
+      integer j0(0:161)
+      character*8 c0,c1
+      logical first
+      data first/.true./
+      save
+
+      if(first) then
+         k=-1
+         do i=0,255
+            write(c0,1001) i
+ 1001       format(b8.8)
+            c1=c0(8:8)//c0(7:7)//c0(6:6)//c0(5:5)//c0(4:4)//c0(3:3)//
+     +         c0(2:2)//c0(1:1)
+            read(c1,1001) n
+            if(n.le.161) then
+               k=k+1
+               j0(k)=n
+            endif
+         enddo
+         first=.false.
+      endif
+
+      if(ndir.eq.1) then
+         do i=0,161
+            itmp(j0(i))=id(i)
+         enddo
+      else
+         do i=0,161
+            itmp(i)=id(j0(i))
+         enddo
+      endif
+
+      do i=0,161
+         id(i)=itmp(i)
+      enddo
+
+      return
+      end

Added: branches/wspr/libportaudio.a
===================================================================
(Binary files differ)


Property changes on: branches/wspr/libportaudio.a
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/wspr/mept162.f
===================================================================
--- branches/wspr/mept162.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/mept162.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,49 @@
+      subroutine mept162(cfile6,f0,id,npts,rms,nsec)
+
+C  Orchestrates the process of decoding MEPT_JT messages.
+
+      integer*2 id(npts)
+
+      parameter (NFFT1=2*1024*1024)
+      character*22 message
+      character*6 cfile6
+      logical first
+      real*8 f0
+      real ps(-128:128)
+      real sstf(4,275)
+      complex c(0:NFFT1),c2(65536)
+      data first/.true./
+      save
+
+      end file 14
+      rewind 14
+
+C  Mix 1500 Hz +/- 100 Hz to baseband, and downsample by 1/32
+      call mix162(id,npts,c,c,c2,jz,df2,ps)
+
+C  Look for sync patterns, get DF and DT
+      call sync162(c2,jz,dtx,dfx,snrx,snrsync,sstf,kz)
+
+      siglev=20.0*log10(rms/300.0) 
+      do k=1,kz
+         snrsync=sstf(1,k)
+         snrx=sstf(2,k)
+         dtx=sstf(3,k)
+         dfx=sstf(4,k)
+         nsync=nint(snrsync)
+         if(nsync.lt.0) nsync=0
+         nsnrx=nint(snrx)
+         if(nsnrx.lt.-33) nsnrx=-33
+         freq=f0 + 1.d-6*(dfx+1500.0)
+         message='                      '
+         if(nsync.ge.1) then
+           call decode162(c2,jz,dtx,dfx,message,ncycles,metric,nerr)
+           write(13,1010) cfile6(1:4),nsync,nsnrx,dtx,freq,message
+           write(14,1010) cfile6(1:4),nsync,nsnrx,dtx,freq,message,
+     +          siglev,nsec/120,nint(dfx)
+ 1010      format(a4,i4,i4,f6.1,f11.6,2x,a15,f8.1,i9,i4)
+         endif
+      enddo
+
+      return
+      end

Added: branches/wspr/mept_jt.f90
===================================================================
--- branches/wspr/mept_jt.f90	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/mept_jt.f90	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,94 @@
+program mept_jt
+
+  use dfport
+  character*40 infile,outfile
+  character*12 arg
+  integer td(9)
+  real*8 f0
+  character*11 utcdate
+  character*3 month(12)
+  data month/'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'/
+
+  nargs=iargc()
+10 if(nargs.eq.0) then
+     print*,' '
+     print*,'MEPT_JT Version 0.3 r90'
+     print*,' '
+     print*,'Usage: mept_jt Tx  f0 ftx nport call grid dBm [snr] [outfile | nfiles]'
+     print*,'       mept_jt T/R f0 ftx nport call grid dBm pctx'
+     print*,'       mept_jt Rx  f0 [infile ...]'
+     print*,' '
+     print*,'       f0 is the transceiver dial frequency (MHz)'
+     print*,'       ftx is the signal frequency (MHz)'
+     print*,'       nport is the COM port number for PTT control'
+     print*,'       snr is the S/N in 2500 Hz bandwidth (for test files)'
+     print*,'       pctx is the percentage of 2-minute periods to Tx'
+     print*,' '
+     print*,'Examples:'
+     print*,'       mept_jt Tx  10.1386 10.140100 1 K1JT FN20 30'
+     print*,'       mept_jt Tx  10.1386 10.140100 0 K1JT FN20 30 -22 test.wav'
+     print*,'       mept_jt T/R 10.1386 10.140100 0 K1JT FN20 30 25'
+     print*,'       mept_jt Rx  10.1386'
+     print*,'       mept_jt Rx  10.1386 00001.wav 00002.wav 00003.wav'
+     print*,' '
+     print*,'For more information see:'
+     print*,'       physics.princeton.edu/pulsar/K1JT/MEPT_Instructions.TXT'
+     go to 999
+  endif
+
+  ntr=0
+  nsec0=999999
+  call getarg(1,arg)
+  if(arg(1:2).eq.'TX'.or. arg(1:2).eq.'Tx' .or. arg(1:2).eq.'tx') then
+! Transmit only
+     if(nargs.lt.7) then
+        nargs=0
+        go to 10
+     endif
+     call mept_tx(nargs,ntr)
+  else if(arg(1:2).eq.'RX'.or. arg(1:2).eq.'Rx' .or. arg(1:2).eq.'rx') then
+! Receive only
+     call mept_rx(nargs,ntr)
+  else if(arg(1:3).eq.'T/R'.or. arg(1:3).eq.'t/r') then
+! Transmit and receive, choosing sequences randomly
+     if(nargs.ne.8) then
+        nargs=0
+        go to 10
+     endif
+     call random_seed
+     ntr=1
+     call getarg(2,arg)
+     read(arg,*) f0
+     call getarg(8,arg)
+     read(arg,*) pctx
+     pctx=min(max(pctx,0.0),100.0)
+20   nsec=time()
+     call gmtime(nsec,td)
+     write(utcdate,1001) td(4),month(1+td(5)),td(6)+1900
+1001 format(i2,'-',a3,'-',i4)
+     nsec=mod(nsec,86400)
+     if(nsec.lt.nsec0) then
+        write(*,1028) utcdate,f0+1400.d-6,f0+1600.d-6
+        write(13,1028) utcdate,f0+1400.d-6,f0+1600.d-6
+1028    format(/' UTC Date: ',a11,'    Search range:',f11.6,' to',f11.6,' MHz'// &amp;
+             ' UTC Sync dB    DT     Freq    Message                  Noise'/    &amp;
+             '-------------------------------------------------------------')
+     endif
+     nsec0=nsec
+
+     call random_number(x)
+     if(pctx.eq.49.5) print*,pctx,100.0*x
+     if(100.0*x.lt.pctx) then
+        call mept_tx(nargs,ntr)
+     else
+        call mept_rx(nargs,ntr)
+     endif
+     call pa_sleep(100)
+     go to 20
+  else
+! Illegal set of command parameters
+     nargs=0
+     go to 10
+endif
+
+999 end program mept_jt

Added: branches/wspr/mept_rx.f90
===================================================================
--- branches/wspr/mept_rx.f90	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/mept_rx.f90	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,153 @@
+subroutine mept_rx(nargs,ntr)
+
+!  Read Rx command-line args and the decode MEPT_JT signals from disk
+!  or real-time data.
+
+#ifdef CVF
+  use dfport
+#endif
+
+  character*12 callsign
+  character*4 grid
+  parameter (NMAX=120*12000)                          !Max length of waveform
+  integer*2 iwave(NMAX)                               !Generated waveform
+  
+  parameter (MAXSYM=176)
+  integer*1 symbol(MAXSYM)
+  integer*1 data1(11),i1
+  integer*1 hdr(44)
+  integer mettab(0:255,0:1)                           !Metric table
+  integer npr3(162)
+  integer getsound
+  real pr3(162)
+  logical first
+  real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,tsymbol
+  character*20 arg
+  character*70 infile
+  character*6 cfile6
+  equivalence(i1,i4)
+  data npr3/                                          &amp;
+      1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,        &amp;
+      0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,        &amp;
+      0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,        &amp;
+      1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,        &amp;
+      0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,        &amp;
+      0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,        &amp;
+      0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,        &amp;
+      0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,        &amp;
+      0,0/
+
+  data mettab/                                             &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   4,   &amp;
+         4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   &amp;
+         4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   &amp;
+         3,   3,   3,   3,   3,   3,   3,   3,   3,   2,   &amp;
+         2,   2,   2,   2,   1,   1,   1,   1,   0,   0,   &amp;
+        -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,   &amp;
+        -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,   &amp;
+       -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,   &amp;
+       -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,   &amp;
+       -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,   &amp;
+       -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,   &amp;
+       -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,   &amp;
+       -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,   &amp;
+       -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,   &amp;
+       -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,   &amp;
+       -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,   &amp;
+       -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,   &amp;
+       -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,   &amp;
+       -84, -87, -86, -87, -88,-105, -94,-105, -88, -87,   &amp;
+       -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,   &amp;
+       -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,   &amp;
+       -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,   &amp;
+       -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,   &amp;
+       -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,   &amp;
+       -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,   &amp;
+       -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,   &amp;
+       -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,   &amp;
+       -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,   &amp;
+       -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,   &amp;
+       -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,   &amp;
+       -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,   &amp;
+        -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,   &amp;
+        -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,   &amp;
+         2,   2,   2,   2,   3,   3,   3,   3,   3,   3,   &amp;
+         3,   3,   3,   4,   4,   4,   4,   4,   4,   4,   &amp;
+         4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   &amp;
+         4,   4,   4,   4,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5/
+  data first/.true./,nsec0/999999/
+  save
+
+  call getarg(2,arg)
+  read(arg,*) f0
+  nfiles=0
+  if(ntr.eq.0) nfiles=nargs-2
+
+  nsym=162                  !Symbols per transmission
+  if(first) then
+     do i=1,nsym
+        pr3(i)=2*npr3(i)-1
+     enddo
+     pi=4.d0*atan(1.d0)
+     twopi=2.d0*pi
+     open(13,file='ALL_MEPT.TXT',status='unknown',access='append')
+     first=.false.
+  endif
+
+  if(nfiles.ge.1) then
+     do ifile=1,nfiles
+        call getarg(2+ifile,infile)
+#ifdef CVF
+        open(10,file=infile,form='binary',status='old')
+#else
+        open(10,file=infile,access='stream',status='old')
+#endif
+        read(10) hdr
+        read(10) iwave
+        cfile6=infile
+        i1=index(infile,'.')
+        if(i1.ge.2) then
+           i0=max(1,i1-6)
+           cfile6=infile(i0:i1-1)
+        endif
+        call getrms(iwave,NMAX,ave,rms)
+        call mept162(cfile6,f0,iwave,NMAX,rms)
+     enddo
+  else
+20   nsec=time()
+     isec=mod(nsec,86400)
+     ih=isec/3600
+     im=(isec-ih*3600)/60
+     is=mod(isec,60)
+     if(mod(im,2).ne.0) go to 30
+     if(is.eq.0) then
+        write(cfile6,1030) ih,im,is
+1030    format(3i2.2)
+        ierr=getsound(iwave)
+        npts=114*12000
+        call getrms(iwave,npts,ave,rms)
+        call mept162(cfile6,f0,iwave,NMAX,rms)
+        if(ntr.ne.0) go to 999
+     endif
+30   call pa_sleep(100)
+     go to 20
+  endif
+      
+999 return
+end subroutine mept_rx
+

Added: branches/wspr/mept_tx.f90
===================================================================
--- branches/wspr/mept_tx.f90	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/mept_tx.f90	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,92 @@
+subroutine mept_tx(nargs,ntr)
+
+!  Read command-line arguments and generate Tx data for the MEPT_JT mode.
+
+#ifdef CVF
+  use dfport
+#endif
+
+  parameter (NMAX=120*12000)
+  real*8 f0,ftx
+  character*70 arg
+  character*12 call1
+  character*4 grid
+  character*3 cdbm
+  character*22 message
+  character*70 outfile
+  integer*2 iwave(NMAX)
+  integer playsound,ptt
+
+  snrdb=99.
+  outfile=&quot;&quot;
+  nfiles=9999
+  call getarg(2,arg)
+  read(arg,*) f0
+  call getarg(3,arg)
+  read(arg,*) ftx
+  ntxdf=nint(1.d6*(ftx-f0))-1500
+  if(abs(ntxdf).gt.100) then
+     print*,'Error: ftx must be above f0 by 1400 to 1600 Hz'
+     stop
+  endif
+  call getarg(4,arg)
+  read(arg,*) nport
+  call getarg(5,call1)
+  call getarg(6,grid)
+  call getarg(7,arg)
+  read(arg,*) ndbm
+  if(nargs.lt.8 .or. ntr.ne.0) go to 10
+  call getarg(8,arg)
+  read(arg,*) snrdb
+  if(nargs.lt.9) go to 10
+  call getarg(9,outfile)
+  read(outfile,1008,err=1) nfiles
+1008  format(i4)
+  outfile=&quot;&quot;
+  go to 10
+1 nfiles=1
+
+10 i1=index(call1,' ')
+  write(cdbm,'(i3)'),ndbm
+  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+  message=call1(1:i1)//grid//' '//cdbm
+  do ifile=1,nfiles
+     if(nfiles.gt.1 .and. nfiles.lt.9999) write(outfile,1010) ifile
+1010 format(i5.5,'.wav')
+     call genmept(call1,grid,ndbm,ntxdf,snrdb,iwave)
+     if(snrdb.eq.11.0) go to 999
+     if(outfile.ne.&quot;&quot;) then
+        call wfile5(iwave,NMAX,12000,outfile)
+        write(*,1020) f0,ftx,snrdb,message,outfile(1:24)
+1020    format(2f11.6,f6.1,2x,a22,2x,a24)
+     else
+20      nsec=time()
+        isec=mod(nsec,86400)
+        ih=isec/3600
+        im=(isec-ih*3600)/60
+        is=mod(isec,60)
+        if(mod(im,2).ne.0) go to 30
+        if(is.eq.0) then
+           if(nport.gt.0) ierr=ptt(nport,junk,1,iptt)
+           if(ntr.eq.0) write(*,1030) ih,im,is,f0,ftx,message
+1030       format(i2.2,':',i2.2,':',i2.2,2f11.6,2x,a22)
+           do i=22,1,-1
+              if(message(i:i).ne.' ') go to 25
+           enddo
+25         iz=i
+           write(*,1031) ih,im,ftx,message(1:iz)
+           write(13,1031) ih,im,ftx,message(1:iz)
+1031       format(2i2.2,14x,f11.6,'  Transmitting &quot;',a,'&quot;')
+           ierr=playsound(iwave)
+           if(nport.gt.0) ierr=ptt(nport,junk,0,iptt)
+           if(ntr.ne.0) go to 999
+        endif
+30      call pa_sleep(100)
+        go to 20
+     endif
+     if(nfiles.eq.9999) go to 999
+enddo
+
+999 return
+end subroutine mept_tx

Added: branches/wspr/mix162.f
===================================================================
--- branches/wspr/mix162.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/mix162.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,59 @@
+      subroutine mix162(id,npts,c,x,c2,jz,df2,ps)
+
+C  Mix 1500 Hz +/- 100 Hz to baseband, and downsample by 1/32
+
+      parameter (NFFT1=2*1024*1024)
+      parameter (NFFT2=NFFT1/32)
+      parameter (NH2=NFFT2/2)
+      integer*2 id(npts)
+      real x(NFFT1)
+      real ps(-128:128)
+      real*8 df
+      complex c(0:NFFT1)
+      complex c2(0:65535)
+
+C  Load data into real array x; pad with zeros up to nfft.
+      fac=1.e-4
+      do i=1,npts
+         x(i)=fac*id(i)
+      enddo
+      call zero(x(npts+1),NFFT1-npts)
+
+C  Do the real-to-complex FFT
+      call xfft(x,NFFT1)
+
+      df=12000.d0/NFFT1
+      df2=256.0*df
+      i0=nint(1500.d0/df)
+      ia=i0-NH2 + 1
+      ib=i0+NH2
+
+      k=-129
+      do i=ia-128,ib,256
+         k=k+1
+         sq=0.
+         do n=0,255
+            f1=abs((i+n)*df - 1500.0)
+            if(f1.gt.100.0) c(i+n)=c(i+n)*((87.5-(f1-100.0))/87.5)**2
+            sq=sq + real(c(i+n))**2 + aimag(c(i+n))**2
+         enddo
+         ps(k)=1.e-6*sq
+      enddo
+
+      do i=0,NFFT2-1
+         j=i0 + i
+         if(i.gt.NH2) j=j-NFFT2
+         c2(i)=c(j)
+      enddo
+
+      call four1(c2,NFFT2,1)
+!      call four2a(c,nh,1,1,-1)        !Return to time domain
+
+      fac=1.e-5
+      jz=npts/32
+      do i=0,jz-1
+         c2(i)=fac*c2(i)
+      enddo
+
+      return
+      end

Added: branches/wspr/nchar.f
===================================================================
--- branches/wspr/nchar.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/nchar.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,22 @@
+      function nchar(c)
+
+C  Convert ascii number, letter, or space to 0-36 for callsign packing.
+
+      character c*1
+
+      if(c.ge.'0' .and. c.le.'9') then
+         n=ichar(c)-ichar('0')
+      else if(c.ge.'A' .and. c.le.'Z') then
+         n=ichar(c)-ichar('A') + 10
+      else if(c.ge.'a' .and. c.le.'z') then
+         n=ichar(c)-ichar('a') + 10
+      else if(c.ge.' ') then
+         n=36
+      else
+         Print*,'Invalid character in callsign ',c,' ',ichar(c)
+         stop
+      endif
+      nchar=n
+
+      return
+      end

Added: branches/wspr/options.py
===================================================================
--- branches/wspr/options.py	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/options.py	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,47 @@
+#------------------------------------------------------ options
+from Tkinter import *
+import Pmw
+import g
+
+def done():
+    root.withdraw()
+
+root=Toplevel()
+root.withdraw()
+root.protocol('WM_DELETE_WINDOW',done)
+if g.Win32: root.iconbitmap(&quot;wsjt.ico&quot;)
+root.title(&quot;Options&quot;)
+
+def options2(t):
+    root.geometry(t)
+    root.deiconify()
+    root.focus_set()
+
+#-------------------------------------------------------- Create GUI widgets
+g1=Pmw.Group(root,tag_text=&quot;Station parameters&quot;)
+IDinterval=IntVar()
+ComPort=IntVar()
+PttPort=StringVar()
+ndevin=IntVar()
+ndevout=IntVar()
+DevinName=StringVar()
+DevoutName=StringVar()
+
+idinterval=Pmw.EntryField(g1.interior(),labelpos=W,label_text='ID Interval (m):',
+        value=10,entry_textvariable=IDinterval,entry_width=12)
+comport=Pmw.EntryField(g1.interior(),labelpos=W,label_text='PTT Port:',
+        value='/dev/ttyS0',entry_textvariable=PttPort,entry_width=12)
+audioin=Pmw.EntryField(g1.interior(),labelpos=W,label_text='Audio In:',
+        value='0',entry_textvariable=DevinName,entry_width=12)
+audioout=Pmw.EntryField(g1.interior(),labelpos=W,label_text='Audio Out:',
+        value='0',entry_textvariable=DevoutName,entry_width=12)
+
+widgets = (idinterval,comport,audioin,audioout)
+for widget in widgets:
+    widget.pack(fill=X,expand=1,padx=10,pady=2)
+
+Pmw.alignlabels(widgets)
+f1=Frame(g1.interior(),width=100,height=20)
+f1.pack()
+
+g1.pack(side=LEFT,fill=BOTH,expand=1,padx=6,pady=6)

Added: branches/wspr/pa.lib
===================================================================
(Binary files differ)


Property changes on: branches/wspr/pa.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/wspr/pack50.f
===================================================================
--- branches/wspr/pack50.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/pack50.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,27 @@
+      subroutine pack50(n1,n2,dat)
+
+      integer*1 dat(11),i1
+      equivalence (i1,i4)
+
+      i4=iand(ishft(n1,-20),255)                !8 bits
+      dat(1)=i1
+      i4=iand(ishft(n1,-12),255)                 !8 bits
+      dat(2)=i1
+      i4=iand(ishft(n1, -4),255)                 !8 bits
+      dat(3)=i1
+      i4=16*iand(n1,15)+iand(ishft(n2,-18),15)   !4+4 bits
+      dat(4)=i1
+      i4=iand(ishft(n2,-10),255)                 !8 bits
+      dat(5)=i1
+      i4=iand(ishft(n2, -2),255)                 !8 bits
+      dat(6)=i1
+      i4=64*iand(n2,3)                           !2 bits
+      dat(7)=i1
+      dat(8)=0
+      dat(8)=0
+      dat(10)=0
+      dat(11)=0
+
+      return
+      end
+

Added: branches/wspr/packcall.f
===================================================================
--- branches/wspr/packcall.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/packcall.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,76 @@
+      subroutine packcall(callsign,ncall,text)
+
+C  Pack a valid callsign into a 28-bit integer.
+
+      parameter (NBASE=37*36*10*27*27*27)
+      character callsign*6,c*1,tmp*6
+      logical text
+
+      text=.false.
+
+C  Work-around for Swaziland prefix:
+      if(callsign(1:4).eq.'3DA0') callsign='3D0'//callsign(5:6)
+
+      if(callsign(1:3).eq.'CQ ') then
+         ncall=NBASE + 1
+         if(callsign(4:4).ge.'0' .and. callsign(4:4).le.'9' .and. 
+     +      callsign(5:5).ge.'0' .and. callsign(5:5).le.'9' .and. 
+     +      callsign(6:6).ge.'0' .and. callsign(6:6).le.'9') then
+            read(callsign(4:6),*) nfreq
+            ncall=NBASE + 3 + nfreq
+         endif
+         return
+      else if(callsign(1:4).eq.'QRZ ') then
+         ncall=NBASE + 2
+         return
+      endif
+
+      tmp='      '
+      if(callsign(3:3).ge.'0' .and. callsign(3:3).le.'9') then
+         tmp=callsign
+      else if(callsign(2:2).ge.'0' .and. callsign(2:2).le.'9') then
+         if(callsign(6:6).ne.' ') then
+            text=.true.
+            return
+         endif
+         tmp=' '//callsign
+      else
+         text=.true.
+         return
+      endif
+
+      do i=1,6
+         c=tmp(i:i)
+         if(c.ge.'a' .and. c.le.'z') 
+     +     tmp(i:i)=char(ichar(c)-ichar('a')+ichar('A'))
+      enddo
+
+      n1=0
+      if((tmp(1:1).ge.'A'.and.tmp(1:1).le.'Z').or.tmp(1:1).eq.' ') n1=1
+      if(tmp(1:1).ge.'0' .and. tmp(1:1).le.'9') n1=1
+      n2=0
+      if(tmp(2:2).ge.'A' .and. tmp(2:2).le.'Z') n2=1
+      if(tmp(2:2).ge.'0' .and. tmp(2:2).le.'9') n2=1
+      n3=0
+      if(tmp(3:3).ge.'0' .and. tmp(3:3).le.'9') n3=1
+      n4=0
+      if((tmp(4:4).ge.'A'.and.tmp(4:4).le.'Z').or.tmp(4:4).eq.' ') n4=1
+      n5=0
+      if((tmp(5:5).ge.'A'.and.tmp(5:5).le.'Z').or.tmp(5:5).eq.' ') n5=1
+      n6=0
+      if((tmp(6:6).ge.'A'.and.tmp(6:6).le.'Z').or.tmp(6:6).eq.' ') n6=1
+
+      if(n1+n2+n3+n4+n5+n6 .ne. 6) then
+         text=.true.
+         return 
+      endif
+
+      ncall=nchar(tmp(1:1))
+      ncall=36*ncall+nchar(tmp(2:2))
+      ncall=10*ncall+nchar(tmp(3:3))
+      ncall=27*ncall+nchar(tmp(4:4))-10
+      ncall=27*ncall+nchar(tmp(5:5))-10
+      ncall=27*ncall+nchar(tmp(6:6))-10
+
+      return
+      end

Added: branches/wspr/packgrid.f
===================================================================
--- branches/wspr/packgrid.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/packgrid.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,47 @@
+      subroutine packgrid(grid,ng,text)
+
+      parameter (NGBASE=180*180)
+      character*4 grid
+      logical text
+
+      text=.false.
+      if(grid.eq.'    ') go to 90                 !Blank grid is OK
+
+C  Test for numerical signal report, etc.
+      if(grid(1:1).eq.'-') then
+         read(grid(2:3),*,err=1,end=1) n
+ 1       ng=NGBASE+1+n
+         go to 100
+      else if(grid(1:2).eq.'R-') then
+         read(grid(3:4),*,err=2,end=2) n
+ 2       if(n.eq.0) go to 90
+         ng=NGBASE+31+n
+         go to 100
+      else if(grid(1:2).eq.'RO') then
+         ng=NGBASE+62
+         go to 100
+      else if(grid(1:3).eq.'RRR') then
+         ng=NGBASE+63
+         go to 100
+      else if(grid(1:2).eq.'73') then
+         ng=NGBASE+64
+         go to 100
+      endif
+
+      if(grid(1:1).lt.'A' .or. grid(1:1).gt.'Z') text=.true.
+      if(grid(2:2).lt.'A' .or. grid(2:2).gt.'Z') text=.true.
+      if(grid(3:3).lt.'0' .or. grid(3:3).gt.'9') text=.true.
+      if(grid(4:4).lt.'0' .or. grid(4:4).gt.'9') text=.true.
+      if(text) go to 100
+
+      call grid2deg(grid//'mm',dlong,dlat)
+      long=dlong
+      lat=dlat+ 90.0
+      ng=((long+180)/2)*180 + lat
+      go to 100
+
+ 90   ng=NGBASE + 1
+
+ 100  return
+      end
+

Added: branches/wspr/packmept.f
===================================================================
--- branches/wspr/packmept.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/packmept.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,61 @@
+      subroutine packmept(msg,dat)
+
+      character*22 msg
+      integer dat(12)
+      character*12 c1,c2
+      character*4 c3
+      character*6 grid6
+      logical text1,text2,text3
+
+C  Convert all letters to upper case
+      do i=1,22
+         if(msg(i:i).ge.'a' .and. msg(i:i).le.'z') 
+     +     msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
+      enddo
+
+      do i=1,22
+         if(msg(i:i).eq.' ') go to 1       !Get 1st blank
+      enddo 
+      go to 10                             !Bad message
+      
+ 1    ia=i
+      c1=msg(1:ia-1)
+      do i=ia+1,22
+         if(msg(i:i).eq.' ') go to 2       !Get 2nd blank
+      enddo
+      go to 10                             !Bad message
+
+ 2    ib=i
+      c2=msg(ia+1:ib-1)
+
+      do i=ib+1,22
+         if(msg(i:i).eq.' ') go to 3       !Get 3rd blank
+      enddo
+      go to 10                             !Bad message
+
+ 3    ic=i
+      c3='    '
+      if(ic.ge.ib+1) c3=msg(ib+1:ic)
+      call packcall(c1,nc1,text1)
+      call packgrid(c2,ng,text2)
+      read(c3,*,err=10) ndbm
+      if((.not.text1) .and. (.not.text2) .and.
+     +   (ndbm.ge.-64) .and. (ndbm.le.63)) go to 20
+
+ 10   print*,'Error: Badly structured MEPT_JT message.'
+      stop
+
+C  Encode data into 6-bit words
+ 20   n2=64*iand(ng,65534) + ndbm + 64
+      dat(1)=iand(ishft(nc1,-22),63)                !6 bits
+      dat(2)=iand(ishft(nc1,-16),63)                !6 bits
+      dat(3)=iand(ishft(nc1,-10),63)                !6 bits
+      dat(4)=iand(ishft(nc1, -4),63)                !6 bits
+      dat(5)=4*iand(nc1,15)+iand(ishft(n2,-20),3)   !4+2 bits
+      dat(6)=iand(ishft(n2,-14),63)                 !6 bits
+      dat(7)=iand(ishft(n2,-8),63)                  !6 bits
+      dat(8)=iand(ishft(n2,-2),63)                  !6 bits
+      dat(9)=16*iand(n2,3)                          !2 bits
+
+      return
+      end

Added: branches/wspr/palettes.py
===================================================================
--- branches/wspr/palettes.py	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/palettes.py	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,1566 @@
+import string
+import g
+
+# Several colormaps
+colormapblue =  &quot;&quot;&quot;
+    0.0       0.0       0.0
+    0.0902    0.0902    0.2558
+    0.1176    0.1176    0.2694
+    0.1412    0.1412    0.2820
+    0.1569    0.1569    0.2938
+    0.1725    0.1725    0.3049
+    0.1843    0.1843    0.3154
+    0.1961    0.1961    0.3254
+    0.2039    0.2039    0.3349
+    0.2157    0.2157    0.3440
+    0.2235    0.2235    0.3528
+    0.2314    0.2314    0.3612
+    0.2392    0.2392    0.3693
+    0.2471    0.2471    0.3772
+    0.2549    0.2549    0.3848
+    0.2588    0.2588    0.3921
+    0.2667    0.2667    0.3992
+    0.2706    0.2706    0.4061
+    0.2784    0.2784    0.4129
+    0.2824    0.2824    0.4194
+    0.2902    0.2902    0.4258
+    0.2941    0.2941    0.4319
+    0.2980    0.2980    0.4380
+    0.3059    0.3059    0.4439
+    0.3098    0.3098    0.4496
+    0.3137    0.3137    0.4553
+    0.3176    0.3176    0.4608
+    0.3216    0.3216    0.4661
+    0.3294    0.3294    0.4714
+    0.3333    0.3333    0.4765
+    0.3373    0.3373    0.4815
+    0.3412    0.3412    0.4865
+    0.3451    0.3451    0.4913
+    0.3490    0.3490    0.4960
+    0.3529    0.3529    0.5006
+    0.3569    0.3569    0.5052
+    0.3608    0.3608    0.5096
+    0.3647    0.3647    0.5140
+    0.3686    0.3686    0.5183
+    0.3725    0.3725    0.5225
+    0.3765    0.3765    0.5266
+    0.3804    0.3804    0.5306
+    0.3843    0.3843    0.5346
+    0.3843    0.3843    0.5385
+    0.3882    0.3882    0.5423
+    0.3922    0.3922    0.5460
+    0.3961    0.3961    0.5497
+    0.4000    0.4000    0.5533
+    0.4039    0.4039    0.5569
+    0.4078    0.4078    0.5603
+    0.4118    0.4118    0.5638
+    0.4118    0.4118    0.5671
+    0.4157    0.4157    0.5704
+    0.4196    0.4196    0.5736
+    0.4235    0.4235    0.5768
+    0.4275    0.4275    0.5799
+    0.4314    0.4314    0.5829
+    0.4314    0.4314    0.5859
+    0.4353    0.4353    0.5889
+    0.4392    0.4392    0.5917
+    0.4431    0.4431    0.5946
+    0.4471    0.4471    0.5973
+    0.4471    0.4471    0.6001
+    0.4510    0.4510    0.6027
+    0.4549    0.4549    0.6053
+    0.4588    0.4588    0.6079
+    0.4627    0.4627    0.6104
+    0.4627    0.4627    0.6129
+    0.4667    0.4667    0.6153
+    0.4706    0.4706    0.6176
+    0.4745    0.4745    0.6199
+    0.4745    0.4745    0.6222
+    0.4784    0.4784    0.6244
+    0.4824    0.4824    0.6266
+    0.4863    0.4863    0.6287
+    0.4863    0.4863    0.6308
+    0.4902    0.4902    0.6328
+    0.4941    0.4941    0.6348
+    0.4980    0.4980    0.6367
+    0.5020    0.5020    0.6386
+    0.5020    0.5020    0.6404
+    0.5059    0.5059    0.6422
+    0.5098    0.5098    0.6440
+    0.5098    0.5098    0.6457
+    0.5137    0.5137    0.6474
+    0.5176    0.5176    0.6490
+    0.5216    0.5216    0.6506
+    0.5216    0.5216    0.6521
+    0.5255    0.5255    0.6536
+    0.5294    0.5294    0.6551
+    0.5333    0.5333    0.6565
+    0.5333    0.5333    0.6578
+    0.5373    0.5373    0.6591
+    0.5412    0.5412    0.6604
+    0.5451    0.5451    0.6617
+    0.5451    0.5451    0.6629
+    0.5490    0.5490    0.6640
+    0.5529    0.5529    0.6651
+    0.5569    0.5569    0.6662
+    0.5569    0.5569    0.6672
+    0.5608    0.5608    0.6682
+    0.5647    0.5647    0.6692
+    0.5647    0.5647    0.6701
+    0.5686    0.5686    0.6710
+    0.5725    0.5725    0.6718
+    0.5765    0.5765    0.6726
+    0.5765    0.5765    0.6733
+    0.5804    0.5804    0.6740
+    0.5843    0.5843    0.6747
+    0.5843    0.5843    0.6753
+    0.5882    0.5882    0.6759
+    0.5922    0.5922    0.6765
+    0.5961    0.5961    0.6770
+    0.5961    0.5961    0.6774
+    0.6000    0.6000    0.6779
+    0.6039    0.6039    0.6783
+    0.6039    0.6039    0.6786
+    0.6078    0.6078    0.6789
+    0.6118    0.6118    0.6792
+    0.6157    0.6157    0.6794
+    0.6157    0.6157    0.6796
+    0.6196    0.6196    0.6798
+    0.6235    0.6235    0.6799
+    0.6235    0.6235    0.6800
+    0.6275    0.6275    0.6800
+    0.6314    0.6314    0.6800
+    0.6353    0.6353    0.6799
+    0.6353    0.6353    0.6799
+    0.6392    0.6392    0.6797
+    0.6431    0.6431    0.6796
+    0.6431    0.6431    0.6794
+    0.6471    0.6471    0.6791
+    0.6510    0.6510    0.6789
+    0.6549    0.6549    0.6785
+    0.6549    0.6549    0.6782
+    0.6588    0.6588    0.6778
+    0.6627    0.6627    0.6773
+    0.6627    0.6627    0.6769
+    0.6667    0.6667    0.6763
+    0.6706    0.6706    0.6758
+    0.6745    0.6745    0.6752
+    0.6745    0.6745    0.6746
+    0.6784    0.6784    0.6739
+    0.6824    0.6824    0.6732
+    0.6824    0.6824    0.6724
+    0.6863    0.6863    0.6716
+    0.6902    0.6902    0.6708
+    0.6941    0.6941    0.6699
+    0.6941    0.6941    0.6690
+    0.6980    0.6980    0.6680
+    0.7020    0.7020    0.6670
+    0.7020    0.7020    0.6660
+    0.7059    0.7059    0.6649
+    0.7098    0.7098    0.6638
+    0.7098    0.7098    0.6626
+    0.7137    0.7137    0.6614
+    0.7176    0.7176    0.6601
+    0.7216    0.7216    0.6589
+    0.7216    0.7216    0.6575
+    0.7255    0.7255    0.6561
+    0.7294    0.7294    0.6547
+    0.7294    0.7294    0.6533
+    0.7333    0.7333    0.6518
+    0.7373    0.7373    0.6502
+    0.7412    0.7412    0.6486
+    0.7412    0.7412    0.6470
+    0.7451    0.7451    0.6453
+    0.7490    0.7490    0.6436
+    0.7490    0.7490    0.6418
+    0.7529    0.7529    0.6400
+    0.7569    0.7569    0.6382
+    0.7608    0.7608    0.6363
+    0.7608    0.7608    0.6343
+    0.7647    0.7647    0.6324
+    0.7686    0.7686    0.6303
+    0.7686    0.7686    0.6282
+    0.7725    0.7725    0.6261
+    0.7765    0.7765    0.6239
+    0.7804    0.7804    0.6217
+    0.7804    0.7804    0.6194
+    0.7843    0.7843    0.6171
+    0.7882    0.7882    0.6147
+    0.7882    0.7882    0.6123
+    0.7922    0.7922    0.6098
+    0.7961    0.7961    0.6073
+    0.8000    0.8000    0.6047
+    0.8000    0.8000    0.6021
+    0.8039    0.8039    0.5994
+    0.8078    0.8078    0.5967
+    0.8078    0.8078    0.5939
+    0.8118    0.8118    0.5911
+    0.8157    0.8157    0.5882
+    0.8196    0.8196    0.5853
+    0.8196    0.8196    0.5823
+    0.8235    0.8235    0.5792
+    0.8275    0.8275    0.5761
+    0.8275    0.8275    0.5729
+    0.8314    0.8314    0.5697
+    0.8353    0.8353    0.5664
+    0.8392    0.8392    0.5630
+    0.8392    0.8392    0.5596
+    0.8431    0.8431    0.5561
+    0.8471    0.8471    0.5525
+    0.8471    0.8471    0.5489
+    0.8510    0.8510    0.5452
+    0.8549    0.8549    0.5414
+    0.8588    0.8588    0.5376
+    0.8588    0.8588    0.5337
+    0.8627    0.8627    0.5297
+    0.8667    0.8667    0.5257
+    0.8667    0.8667    0.5215
+    0.8706    0.8706    0.5173
+    0.8745    0.8745    0.5130
+    0.8784    0.8784    0.5086
+    0.8784    0.8784    0.5042
+    0.8824    0.8824    0.4996
+    0.8863    0.8863    0.4950
+    0.8863    0.8863    0.4902
+    0.8902    0.8902    0.4854
+    0.8941    0.8941    0.4804
+    0.8980    0.8980    0.4754
+    0.8980    0.8980    0.4702
+    0.9020    0.9020    0.4649
+    0.9059    0.9059    0.4595
+    0.9098    0.9098    0.4540
+    0.9098    0.9098    0.4484
+    0.9137    0.9137    0.4426
+    0.9176    0.9176    0.4366
+    0.9176    0.9176    0.4306
+    0.9216    0.9216    0.4243
+    0.9255    0.9255    0.4179
+    0.9294    0.9294    0.4114
+    0.9294    0.9294    0.4046
+    0.9333    0.9333    0.3977
+    0.9373    0.9373    0.3905
+    0.9373    0.9373    0.3831
+    0.9412    0.9412    0.3754
+    0.9451    0.9451    0.3675
+    0.9490    0.9490    0.3594
+    0.9490    0.9490    0.3509
+    0.9529    0.9529    0.3420
+    0.9569    0.9569    0.3328
+    0.9608    0.9608    0.3232
+    0.9608    0.9608    0.3131
+    0.9647    0.9647    0.3024
+    0.9686    0.9686    0.2912
+    0.9686    0.9686    0.2792
+    0.9725    0.9725    0.2664
+    0.9765    0.9765    0.2526
+    0.9804    0.9804    0.2375
+    0.9804    0.9804    0.2208
+    0.9843    0.9843    0.2020
+    0.9882    0.9882    0.1800
+    1.0       0.0       0.0
+    1.0       1.0       0.0
+    0.0       1.000     0.0
+&quot;&quot;&quot;
+colormapgray0 =  &quot;&quot;&quot;
+    0.0000    0.0000    0.0000
+    0.0039    0.0039    0.0039
+    0.0078    0.0078    0.0078
+    0.0118    0.0118    0.0118
+    0.0157    0.0157    0.0157
+    0.0196    0.0196    0.0196
+    0.0235    0.0235    0.0235
+    0.0275    0.0275    0.0275
+    0.0314    0.0314    0.0314
+    0.0353    0.0353    0.0353
+    0.0392    0.0392    0.0392
+    0.0431    0.0431    0.0431
+    0.0471    0.0471    0.0471
+    0.0510    0.0510    0.0510
+    0.0549    0.0549    0.0549
+    0.0588    0.0588    0.0588
+    0.0627    0.0627    0.0627
+    0.0667    0.0667    0.0667
+    0.0706    0.0706    0.0706
+    0.0745    0.0745    0.0745
+    0.0784    0.0784    0.0784
+    0.0824    0.0824    0.0824
+    0.0863    0.0863    0.0863
+    0.0902    0.0902    0.0902
+    0.0941    0.0941    0.0941
+    0.0980    0.0980    0.0980
+    0.1020    0.1020    0.1020
+    0.1059    0.1059    0.1059
+    0.1098    0.1098    0.1098
+    0.1137    0.1137    0.1137
+    0.1176    0.1176    0.1176
+    0.1216    0.1216    0.1216
+    0.1255    0.1255    0.1255
+    0.1294    0.1294    0.1294
+    0.1333    0.1333    0.1333
+    0.1373    0.1373    0.1373
+    0.1412    0.1412    0.1412
+    0.1451    0.1451    0.1451
+    0.1490    0.1490    0.1490
+    0.1529    0.1529    0.1529
+    0.1569    0.1569    0.1569
+    0.1608    0.1608    0.1608
+    0.1647    0.1647    0.1647
+    0.1686    0.1686    0.1686
+    0.1725    0.1725    0.1725
+    0.1765    0.1765    0.1765
+    0.1804    0.1804    0.1804
+    0.1843    0.1843    0.1843
+    0.1882    0.1882    0.1882
+    0.1922    0.1922    0.1922
+    0.1961    0.1961    0.1961
+    0.2000    0.2000    0.2000
+    0.2039    0.2039    0.2039
+    0.2078    0.2078    0.2078
+    0.2118    0.2118    0.2118
+    0.2157    0.2157    0.2157
+    0.2196    0.2196    0.2196
+    0.2235    0.2235    0.2235
+    0.2275    0.2275    0.2275
+    0.2314    0.2314    0.2314
+    0.2353    0.2353    0.2353
+    0.2392    0.2392    0.2392
+    0.2431    0.2431    0.2431
+    0.2471    0.2471    0.2471
+    0.2510    0.2510    0.2510
+    0.2549    0.2549    0.2549
+    0.2588    0.2588    0.2588
+    0.2627    0.2627    0.2627
+    0.2667    0.2667    0.2667
+    0.2706    0.2706    0.2706
+    0.2745    0.2745    0.2745
+    0.2784    0.2784    0.2784
+    0.2824    0.2824    0.2824
+    0.2863    0.2863    0.2863
+    0.2902    0.2902    0.2902
+    0.2941    0.2941    0.2941
+    0.2980    0.2980    0.2980
+    0.3020    0.3020    0.3020
+    0.3059    0.3059    0.3059
+    0.3098    0.3098    0.3098
+    0.3137    0.3137    0.3137
+    0.3176    0.3176    0.3176
+    0.3216    0.3216    0.3216
+    0.3255    0.3255    0.3255
+    0.3294    0.3294    0.3294
+    0.3333    0.3333    0.3333
+    0.3373    0.3373    0.3373
+    0.3412    0.3412    0.3412
+    0.3451    0.3451    0.3451
+    0.3490    0.3490    0.3490
+    0.3529    0.3529    0.3529
+    0.3569    0.3569    0.3569
+    0.3608    0.3608    0.3608
+    0.3647    0.3647    0.3647
+    0.3686    0.3686    0.3686
+    0.3725    0.3725    0.3725
+    0.3765    0.3765    0.3765
+    0.3804    0.3804    0.3804
+    0.3843    0.3843    0.3843
+    0.3882    0.3882    0.3882
+    0.3922    0.3922    0.3922
+    0.3961    0.3961    0.3961
+    0.4000    0.4000    0.4000
+    0.4039    0.4039    0.4039
+    0.4078    0.4078    0.4078
+    0.4118    0.4118    0.4118
+    0.4157    0.4157    0.4157
+    0.4196    0.4196    0.4196
+    0.4235    0.4235    0.4235
+    0.4275    0.4275    0.4275
+    0.4314    0.4314    0.4314
+    0.4353    0.4353    0.4353
+    0.4392    0.4392    0.4392
+    0.4431    0.4431    0.4431
+    0.4471    0.4471    0.4471
+    0.4510    0.4510    0.4510
+    0.4549    0.4549    0.4549
+    0.4588    0.4588    0.4588
+    0.4627    0.4627    0.4627
+    0.4667    0.4667    0.4667
+    0.4706    0.4706    0.4706
+    0.4745    0.4745    0.4745
+    0.4784    0.4784    0.4784
+    0.4824    0.4824    0.4824
+    0.4863    0.4863    0.4863
+    0.4902    0.4902    0.4902
+    0.4941    0.4941    0.4941
+    0.4980    0.4980    0.4980
+    0.5020    0.5020    0.5020
+    0.5059    0.5059    0.5059
+    0.5098    0.5098    0.5098
+    0.5137    0.5137    0.5137
+    0.5176    0.5176    0.5176
+    0.5216    0.5216    0.5216
+    0.5255    0.5255    0.5255
+    0.5294    0.5294    0.5294
+    0.5333    0.5333    0.5333
+    0.5373    0.5373    0.5373
+    0.5412    0.5412    0.5412
+    0.5451    0.5451    0.5451
+    0.5490    0.5490    0.5490
+    0.5529    0.5529    0.5529
+    0.5569    0.5569    0.5569
+    0.5608    0.5608    0.5608
+    0.5647    0.5647    0.5647
+    0.5686    0.5686    0.5686
+    0.5725    0.5725    0.5725
+    0.5765    0.5765    0.5765
+    0.5804    0.5804    0.5804
+    0.5843    0.5843    0.5843
+    0.5882    0.5882    0.5882
+    0.5922    0.5922    0.5922
+    0.5961    0.5961    0.5961
+    0.6000    0.6000    0.6000
+    0.6039    0.6039    0.6039
+    0.6078    0.6078    0.6078
+    0.6118    0.6118    0.6118
+    0.6157    0.6157    0.6157
+    0.6196    0.6196    0.6196
+    0.6235    0.6235    0.6235
+    0.6275    0.6275    0.6275
+    0.6314    0.6314    0.6314
+    0.6353    0.6353    0.6353
+    0.6392    0.6392    0.6392
+    0.6431    0.6431    0.6431
+    0.6471    0.6471    0.6471
+    0.6510    0.6510    0.6510
+    0.6549    0.6549    0.6549
+    0.6588    0.6588    0.6588
+    0.6627    0.6627    0.6627
+    0.6667    0.6667    0.6667
+    0.6706    0.6706    0.6706
+    0.6745    0.6745    0.6745
+    0.6784    0.6784    0.6784
+    0.6824    0.6824    0.6824
+    0.6863    0.6863    0.6863
+    0.6902    0.6902    0.6902
+    0.6941    0.6941    0.6941
+    0.6980    0.6980    0.6980
+    0.7020    0.7020    0.7020
+    0.7059    0.7059    0.7059
+    0.7098    0.7098    0.7098
+    0.7137    0.7137    0.7137
+    0.7176    0.7176    0.7176
+    0.7216    0.7216    0.7216
+    0.7255    0.7255    0.7255
+    0.7294    0.7294    0.7294
+    0.7333    0.7333    0.7333
+    0.7373    0.7373    0.7373
+    0.7412    0.7412    0.7412
+    0.7451    0.7451    0.7451
+    0.7490    0.7490    0.7490
+    0.7529    0.7529    0.7529
+    0.7569    0.7569    0.7569
+    0.7608    0.7608    0.7608
+    0.7647    0.7647    0.7647
+    0.7686    0.7686    0.7686
+    0.7725    0.7725    0.7725
+    0.7765    0.7765    0.7765
+    0.7804    0.7804    0.7804
+    0.7843    0.7843    0.7843
+    0.7882    0.7882    0.7882
+    0.7922    0.7922    0.7922
+    0.7961    0.7961    0.7961
+    0.8000    0.8000    0.8000
+    0.8039    0.8039    0.8039
+    0.8078    0.8078    0.8078
+    0.8118    0.8118    0.8118
+    0.8157    0.8157    0.8157
+    0.8196    0.8196    0.8196
+    0.8235    0.8235    0.8235
+    0.8275    0.8275    0.8275
+    0.8314    0.8314    0.8314
+    0.8353    0.8353    0.8353
+    0.8392    0.8392    0.8392
+    0.8431    0.8431    0.8431
+    0.8471    0.8471    0.8471
+    0.8510    0.8510    0.8510
+    0.8549    0.8549    0.8549
+    0.8588    0.8588    0.8588
+    0.8627    0.8627    0.8627
+    0.8667    0.8667    0.8667
+    0.8706    0.8706    0.8706
+    0.8745    0.8745    0.8745
+    0.8784    0.8784    0.8784
+    0.8824    0.8824    0.8824
+    0.8863    0.8863    0.8863
+    0.8902    0.8902    0.8902
+    0.8941    0.8941    0.8941
+    0.8980    0.8980    0.8980
+    0.9020    0.9020    0.9020
+    0.9059    0.9059    0.9059
+    0.9098    0.9098    0.9098
+    0.9137    0.9137    0.9137
+    0.9176    0.9176    0.9176
+    0.9216    0.9216    0.9216
+    0.9255    0.9255    0.9255
+    0.9294    0.9294    0.9294
+    0.9333    0.9333    0.9333
+    0.9373    0.9373    0.9373
+    0.9412    0.9412    0.9412
+    0.9451    0.9451    0.9451
+    0.9490    0.9490    0.9490
+    0.9529    0.9529    0.9529
+    0.9569    0.9569    0.9569
+    0.9608    0.9608    0.9608
+    0.9647    0.9647    0.9647
+    0.9686    0.9686    0.9686
+    0.9725    0.9725    0.9725
+    0.9765    0.9765    0.9765
+    0.9804    0.9804    0.9804
+    0.9843    0.9843    0.9843
+    0.9882    0.9882    0.9882
+    1.0       0.0       0.0
+    1.0       1.0       0.0
+    0.0       1.000    0.0
+&quot;&quot;&quot;
+
+colormapHot=&quot;&quot;&quot;
+    0.0000    0.0000    0.0000
+    0.0118    0.0000    0.0000
+    0.0235    0.0000    0.0000
+    0.0353    0.0000    0.0000
+    0.0471    0.0000    0.0000
+    0.0588    0.0000    0.0000
+    0.0706    0.0000    0.0000
+    0.0824    0.0000    0.0000
+    0.0941    0.0000    0.0000
+    0.1059    0.0000    0.0000
+    0.1176    0.0000    0.0000
+    0.1294    0.0000    0.0000
+    0.1412    0.0000    0.0000
+    0.1529    0.0000    0.0000
+    0.1647    0.0000    0.0000
+    0.1765    0.0000    0.0000
+    0.1882    0.0000    0.0000
+    0.2000    0.0000    0.0000
+    0.2118    0.0000    0.0000
+    0.2235    0.0000    0.0000
+    0.2353    0.0000    0.0000
+    0.2471    0.0000    0.0000
+    0.2588    0.0000    0.0000
+    0.2706    0.0000    0.0000
+    0.2824    0.0000    0.0000
+    0.2941    0.0000    0.0000
+    0.3059    0.0000    0.0000
+    0.3176    0.0000    0.0000
+    0.3294    0.0000    0.0000
+    0.3412    0.0000    0.0000
+    0.3529    0.0000    0.0000
+    0.3647    0.0000    0.0000
+    0.3765    0.0000    0.0000
+    0.3882    0.0000    0.0000
+    0.4000    0.0000    0.0000
+    0.4118    0.0000    0.0000
+    0.4235    0.0000    0.0000
+    0.4353    0.0000    0.0000
+    0.4471    0.0000    0.0000
+    0.4588    0.0000    0.0000
+    0.4706    0.0000    0.0000
+    0.4824    0.0000    0.0000
+    0.4941    0.0000    0.0000
+    0.5059    0.0000    0.0000
+    0.5176    0.0000    0.0000
+    0.5294    0.0000    0.0000
+    0.5412    0.0000    0.0000
+    0.5529    0.0000    0.0000
+    0.5647    0.0000    0.0000
+    0.5765    0.0000    0.0000
+    0.5882    0.0000    0.0000
+    0.6000    0.0000    0.0000
+    0.6118    0.0000    0.0000
+    0.6235    0.0000    0.0000
+    0.6353    0.0000    0.0000
+    0.6471    0.0000    0.0000
+    0.6588    0.0000    0.0000
+    0.6706    0.0000    0.0000
+    0.6824    0.0000    0.0000
+    0.6941    0.0000    0.0000
+    0.7059    0.0000    0.0000
+    0.7176    0.0000    0.0000
+    0.7294    0.0000    0.0000
+    0.7412    0.0000    0.0000
+    0.7529    0.0000    0.0000
+    0.7647    0.0000    0.0000
+    0.7765    0.0000    0.0000
+    0.7882    0.0000    0.0000
+    0.8000    0.0000    0.0000
+    0.8118    0.0000    0.0000
+    0.8235    0.0000    0.0000
+    0.8353    0.0000    0.0000
+    0.8471    0.0000    0.0000
+    0.8588    0.0000    0.0000
+    0.8706    0.0000    0.0000
+    0.8824    0.0000    0.0000
+    0.8941    0.0000    0.0000
+    0.9059    0.0000    0.0000
+    0.9176    0.0000    0.0000
+    0.9294    0.0000    0.0000
+    0.9412    0.0000    0.0000
+    0.9529    0.0000    0.0000
+    0.9647    0.0000    0.0000
+    0.9765    0.0000    0.0000
+    0.9882    0.0000    0.0000
+    1.0000    0.0000    0.0000
+    1.0000    0.0118    0.0000
+    1.0000    0.0235    0.0000
+    1.0000    0.0353    0.0000
+    1.0000    0.0471    0.0000
+    1.0000    0.0588    0.0000
+    1.0000    0.0706    0.0000
+    1.0000    0.0824    0.0000
+    1.0000    0.0941    0.0000
+    1.0000    0.1059    0.0000
+    1.0000    0.1176    0.0000
+    1.0000    0.1294    0.0000
+    1.0000    0.1412    0.0000
+    1.0000    0.1529    0.0000
+    1.0000    0.1647    0.0000
+    1.0000    0.1765    0.0000
+    1.0000    0.1882    0.0000
+    1.0000    0.2000    0.0000
+    1.0000    0.2118    0.0000
+    1.0000    0.2235    0.0000
+    1.0000    0.2353    0.0000
+    1.0000    0.2471    0.0000
+    1.0000    0.2588    0.0000
+    1.0000    0.2706    0.0000
+    1.0000    0.2824    0.0000
+    1.0000    0.2941    0.0000
+    1.0000    0.3059    0.0000
+    1.0000    0.3176    0.0000
+    1.0000    0.3294    0.0000
+    1.0000    0.3412    0.0000
+    1.0000    0.3529    0.0000
+    1.0000    0.3647    0.0000
+    1.0000    0.3765    0.0000
+    1.0000    0.3882    0.0000
+    1.0000    0.4000    0.0000
+    1.0000    0.4118    0.0000
+    1.0000    0.4235    0.0000
+    1.0000    0.4353    0.0000
+    1.0000    0.4471    0.0000
+    1.0000    0.4588    0.0000
+    1.0000    0.4706    0.0000
+    1.0000    0.4824    0.0000
+    1.0000    0.4941    0.0000
+    1.0000    0.5059    0.0000
+    1.0000    0.5176    0.0000
+    1.0000    0.5294    0.0000
+    1.0000    0.5412    0.0000
+    1.0000    0.5529    0.0000
+    1.0000    0.5647    0.0000
+    1.0000    0.5765    0.0000
+    1.0000    0.5882    0.0000
+    1.0000    0.6000    0.0000
+    1.0000    0.6118    0.0000
+    1.0000    0.6235    0.0000
+    1.0000    0.6353    0.0000
+    1.0000    0.6471    0.0000
+    1.0000    0.6588    0.0000
+    1.0000    0.6706    0.0000
+    1.0000    0.6824    0.0000
+    1.0000    0.6941    0.0000
+    1.0000    0.7059    0.0000
+    1.0000    0.7176    0.0000
+    1.0000    0.7294    0.0000
+    1.0000    0.7412    0.0000
+    1.0000    0.7529    0.0000
+    1.0000    0.7647    0.0000
+    1.0000    0.7765    0.0000
+    1.0000    0.7882    0.0000
+    1.0000    0.8000    0.0000
+    1.0000    0.8118    0.0000
+    1.0000    0.8235    0.0000
+    1.0000    0.8353    0.0000
+    1.0000    0.8471    0.0000
+    1.0000    0.8588    0.0000
+    1.0000    0.8706    0.0000
+    1.0000    0.8824    0.0000
+    1.0000    0.8941    0.0000
+    1.0000    0.9059    0.0000
+    1.0000    0.9176    0.0000
+    1.0000    0.9294    0.0000
+    1.0000    0.9412    0.0000
+    1.0000    0.9529    0.0000
+    1.0000    0.9647    0.0000
+    1.0000    0.9765    0.0000
+    1.0000    0.9882    0.0000
+    1.0000    1.0000    0.0000
+    1.0000    1.0000    0.0118
+    1.0000    1.0000    0.0235
+    1.0000    1.0000    0.0353
+    1.0000    1.0000    0.0471
+    1.0000    1.0000    0.0588
+    1.0000    1.0000    0.0706
+    1.0000    1.0000    0.0824
+    1.0000    1.0000    0.0941
+    1.0000    1.0000    0.1059
+    1.0000    1.0000    0.1176
+    1.0000    1.0000    0.1294
+    1.0000    1.0000    0.1412
+    1.0000    1.0000    0.1529
+    1.0000    1.0000    0.1647
+    1.0000    1.0000    0.1765
+    1.0000    1.0000    0.1882
+    1.0000    1.0000    0.2000
+    1.0000    1.0000    0.2118
+    1.0000    1.0000    0.2235
+    1.0000    1.0000    0.2353
+    1.0000    1.0000    0.2471
+    1.0000    1.0000    0.2588
+    1.0000    1.0000    0.2706
+    1.0000    1.0000    0.2824
+    1.0000    1.0000    0.2941
+    1.0000    1.0000    0.3059
+    1.0000    1.0000    0.3176
+    1.0000    1.0000    0.3294
+    1.0000    1.0000    0.3412
+    1.0000    1.0000    0.3529
+    1.0000    1.0000    0.3647
+    1.0000    1.0000    0.3765
+    1.0000    1.0000    0.3882
+    1.0000    1.0000    0.4000
+    1.0000    1.0000    0.4118
+    1.0000    1.0000    0.4235
+    1.0000    1.0000    0.4353
+    1.0000    1.0000    0.4471
+    1.0000    1.0000    0.4588
+    1.0000    1.0000    0.4706
+    1.0000    1.0000    0.4824
+    1.0000    1.0000    0.4941
+    1.0000    1.0000    0.5059
+    1.0000    1.0000    0.5176
+    1.0000    1.0000    0.5294
+    1.0000    1.0000    0.5412
+    1.0000    1.0000    0.5529
+    1.0000    1.0000    0.5647
+    1.0000    1.0000    0.5765
+    1.0000    1.0000    0.5882
+    1.0000    1.0000    0.6000
+    1.0000    1.0000    0.6118
+    1.0000    1.0000    0.6235
+    1.0000    1.0000    0.6353
+    1.0000    1.0000    0.6471
+    1.0000    1.0000    0.6588
+    1.0000    1.0000    0.6706
+    1.0000    1.0000    0.6824
+    1.0000    1.0000    0.6941
+    1.0000    1.0000    0.7059
+    1.0000    1.0000    0.7176
+    1.0000    1.0000    0.7294
+    1.0000    1.0000    0.7412
+    1.0000    1.0000    0.7529
+    1.0000    1.0000    0.7647
+    1.0000    1.0000    0.7765
+    1.0000    1.0000    0.7882
+    1.0000    1.0000    0.8000
+    1.0000    1.0000    0.8118
+    1.0000    1.0000    0.8235
+    1.0000    1.0000    0.8353
+    1.0000    1.0000    0.8471
+    1.0000    1.0000    0.8588
+    1.0000    1.0000    0.8706
+    1.0000    1.0000    0.8824
+    1.0000    1.0000    0.8941
+    1.0000    1.0000    0.9059
+    1.0000    1.0000    0.9176
+    1.0000    1.0000    0.9294
+    1.0000    1.0000    0.9412
+    1.0000    1.0000    0.9529
+    1.0000    1.0000    0.9647
+    1.0       0.0       0.0
+    1.0       1.0       0.0
+    0.0       1.000     0.0
+&quot;&quot;&quot;
+
+colormapAFMHot=&quot;&quot;&quot;
+    0.0000    0.0000    0.0000
+    0.0078    0.0000    0.0000
+    0.0157    0.0000    0.0000
+    0.0235    0.0000    0.0000
+    0.0314    0.0000    0.0000
+    0.0392    0.0000    0.0000
+    0.0471    0.0000    0.0000
+    0.0549    0.0000    0.0000
+    0.0627    0.0000    0.0000
+    0.0706    0.0000    0.0000
+    0.0784    0.0000    0.0000
+    0.0863    0.0000    0.0000
+    0.0941    0.0000    0.0000
+    0.1020    0.0000    0.0000
+    0.1098    0.0000    0.0000
+    0.1176    0.0000    0.0000
+    0.1255    0.0000    0.0000
+    0.1333    0.0000    0.0000
+    0.1412    0.0000    0.0000
+    0.1490    0.0000    0.0000
+    0.1569    0.0000    0.0000
+    0.1647    0.0000    0.0000
+    0.1725    0.0000    0.0000
+    0.1804    0.0000    0.0000
+    0.1882    0.0000    0.0000
+    0.1961    0.0000    0.0000
+    0.2039    0.0000    0.0000
+    0.2118    0.0000    0.0000
+    0.2196    0.0000    0.0000
+    0.2275    0.0000    0.0000
+    0.2353    0.0000    0.0000
+    0.2431    0.0000    0.0000
+    0.2510    0.0000    0.0000
+    0.2588    0.0000    0.0000
+    0.2667    0.0000    0.0000
+    0.2745    0.0000    0.0000
+    0.2824    0.0000    0.0000
+    0.2902    0.0000    0.0000
+    0.2980    0.0000    0.0000
+    0.3059    0.0000    0.0000
+    0.3137    0.0000    0.0000
+    0.3216    0.0000    0.0000
+    0.3294    0.0000    0.0000
+    0.3373    0.0000    0.0000
+    0.3451    0.0000    0.0000
+    0.3529    0.0000    0.0000
+    0.3608    0.0000    0.0000
+    0.3686    0.0000    0.0000
+    0.3765    0.0000    0.0000
+    0.3843    0.0000    0.0000
+    0.3922    0.0000    0.0000
+    0.4000    0.0000    0.0000
+    0.4078    0.0000    0.0000
+    0.4157    0.0000    0.0000
+    0.4235    0.0000    0.0000
+    0.4314    0.0000    0.0000
+    0.4392    0.0000    0.0000
+    0.4471    0.0000    0.0000
+    0.4549    0.0000    0.0000
+    0.4627    0.0000    0.0000
+    0.4706    0.0000    0.0000
+    0.4784    0.0000    0.0000
+    0.4863    0.0000    0.0000
+    0.4941    0.0000    0.0000
+    0.5020    0.0000    0.0000
+    0.5098    0.0098    0.0000
+    0.5176    0.0176    0.0000
+    0.5255    0.0255    0.0000
+    0.5333    0.0333    0.0000
+    0.5412    0.0412    0.0000
+    0.5490    0.0490    0.0000
+    0.5569    0.0569    0.0000
+    0.5647    0.0647    0.0000
+    0.5725    0.0725    0.0000
+    0.5804    0.0804    0.0000
+    0.5882    0.0882    0.0000
+    0.5961    0.0961    0.0000
+    0.6039    0.1039    0.0000
+    0.6118    0.1118    0.0000
+    0.6196    0.1196    0.0000
+    0.6275    0.1275    0.0000
+    0.6353    0.1353    0.0000
+    0.6431    0.1431    0.0000
+    0.6510    0.1510    0.0000
+    0.6588    0.1588    0.0000
+    0.6667    0.1667    0.0000
+    0.6745    0.1745    0.0000
+    0.6824    0.1824    0.0000
+    0.6902    0.1902    0.0000
+    0.6980    0.1980    0.0000
+    0.7059    0.2059    0.0000
+    0.7137    0.2137    0.0000
+    0.7216    0.2216    0.0000
+    0.7294    0.2294    0.0000
+    0.7373    0.2373    0.0000
+    0.7451    0.2451    0.0000
+    0.7529    0.2529    0.0000
+    0.7608    0.2608    0.0000
+    0.7686    0.2686    0.0000
+    0.7765    0.2765    0.0000
+    0.7843    0.2843    0.0000
+    0.7922    0.2922    0.0000
+    0.8000    0.3000    0.0000
+    0.8078    0.3078    0.0000
+    0.8157    0.3157    0.0000
+    0.8235    0.3235    0.0000
+    0.8314    0.3314    0.0000
+    0.8392    0.3392    0.0000
+    0.8471    0.3471    0.0000
+    0.8549    0.3549    0.0000
+    0.8627    0.3627    0.0000
+    0.8706    0.3706    0.0000
+    0.8784    0.3784    0.0000
+    0.8863    0.3863    0.0000
+    0.8941    0.3941    0.0000
+    0.9020    0.4020    0.0000
+    0.9098    0.4098    0.0000
+    0.9176    0.4176    0.0000
+    0.9255    0.4255    0.0000
+    0.9333    0.4333    0.0000
+    0.9412    0.4412    0.0000
+    0.9490    0.4490    0.0000
+    0.9569    0.4569    0.0000
+    0.9647    0.4647    0.0000
+    0.9725    0.4725    0.0000
+    0.9804    0.4804    0.0000
+    0.9882    0.4882    0.0000
+    0.9961    0.4961    0.0000
+    1.0000    0.5039    0.0000
+    1.0000    0.5118    0.0118
+    1.0000    0.5196    0.0196
+    1.0000    0.5275    0.0275
+    1.0000    0.5353    0.0353
+    1.0000    0.5431    0.0431
+    1.0000    0.5510    0.0510
+    1.0000    0.5588    0.0588
+    1.0000    0.5667    0.0667
+    1.0000    0.5745    0.0745
+    1.0000    0.5824    0.0824
+    1.0000    0.5902    0.0902
+    1.0000    0.5980    0.0980
+    1.0000    0.6059    0.1059
+    1.0000    0.6137    0.1137
+    1.0000    0.6216    0.1216
+    1.0000    0.6294    0.1294
+    1.0000    0.6373    0.1373
+    1.0000    0.6451    0.1451
+    1.0000    0.6529    0.1529
+    1.0000    0.6608    0.1608
+    1.0000    0.6686    0.1686
+    1.0000    0.6765    0.1765
+    1.0000    0.6843    0.1843
+    1.0000    0.6922    0.1922
+    1.0000    0.7000    0.2000
+    1.0000    0.7078    0.2078
+    1.0000    0.7157    0.2157
+    1.0000    0.7235    0.2235
+    1.0000    0.7314    0.2314
+    1.0000    0.7392    0.2392
+    1.0000    0.7471    0.2471
+    1.0000    0.7549    0.2549
+    1.0000    0.7627    0.2627
+    1.0000    0.7706    0.2706
+    1.0000    0.7784    0.2784
+    1.0000    0.7863    0.2863
+    1.0000    0.7941    0.2941
+    1.0000    0.8020    0.3020
+    1.0000    0.8098    0.3098
+    1.0000    0.8176    0.3176
+    1.0000    0.8255    0.3255
+    1.0000    0.8333    0.3333
+    1.0000    0.8412    0.3412
+    1.0000    0.8490    0.3490
+    1.0000    0.8569    0.3569
+    1.0000    0.8647    0.3647
+    1.0000    0.8725    0.3725
+    1.0000    0.8804    0.3804
+    1.0000    0.8882    0.3882
+    1.0000    0.8961    0.3961
+    1.0000    0.9039    0.4039
+    1.0000    0.9118    0.4118
+    1.0000    0.9196    0.4196
+    1.0000    0.9275    0.4275
+    1.0000    0.9353    0.4353
+    1.0000    0.9431    0.4431
+    1.0000    0.9510    0.4510
+    1.0000    0.9588    0.4588
+    1.0000    0.9667    0.4667
+    1.0000    0.9745    0.4745
+    1.0000    0.9824    0.4824
+    1.0000    0.9902    0.4902
+    1.0000    0.9980    0.4980
+    1.0000    1.0000    0.5059
+    1.0000    1.0000    0.5137
+    1.0000    1.0000    0.5216
+    1.0000    1.0000    0.5294
+    1.0000    1.0000    0.5373
+    1.0000    1.0000    0.5451
+    1.0000    1.0000    0.5529
+    1.0000    1.0000    0.5608
+    1.0000    1.0000    0.5686
+    1.0000    1.0000    0.5765
+    1.0000    1.0000    0.5843
+    1.0000    1.0000    0.5922
+    1.0000    1.0000    0.6000
+    1.0000    1.0000    0.6078
+    1.0000    1.0000    0.6157
+    1.0000    1.0000    0.6235
+    1.0000    1.0000    0.6314
+    1.0000    1.0000    0.6392
+    1.0000    1.0000    0.6471
+    1.0000    1.0000    0.6549
+    1.0000    1.0000    0.6627
+    1.0000    1.0000    0.6706
+    1.0000    1.0000    0.6784
+    1.0000    1.0000    0.6863
+    1.0000    1.0000    0.6941
+    1.0000    1.0000    0.7020
+    1.0000    1.0000    0.7098
+    1.0000    1.0000    0.7176
+    1.0000    1.0000    0.7255
+    1.0000    1.0000    0.7333
+    1.0000    1.0000    0.7412
+    1.0000    1.0000    0.7490
+    1.0000    1.0000    0.7569
+    1.0000    1.0000    0.7647
+    1.0000    1.0000    0.7725
+    1.0000    1.0000    0.7804
+    1.0000    1.0000    0.7882
+    1.0000    1.0000    0.7961
+    1.0000    1.0000    0.8039
+    1.0000    1.0000    0.8118
+    1.0000    1.0000    0.8196
+    1.0000    1.0000    0.8275
+    1.0000    1.0000    0.8353
+    1.0000    1.0000    0.8431
+    1.0000    1.0000    0.8510
+    1.0000    1.0000    0.8588
+    1.0000    1.0000    0.8667
+    1.0000    1.0000    0.8745
+    1.0000    1.0000    0.8824
+    1.0000    1.0000    0.8902
+    1.0000    1.0000    0.8980
+    1.0000    1.0000    0.9059
+    1.0000    1.0000    0.9137
+    1.0000    1.0000    0.9216
+    1.0000    1.0000    0.9294
+    1.0000    1.0000    0.9373
+    1.0000    1.0000    0.9451
+    1.0000    1.0000    0.9529
+    1.0000    1.0000    0.9608
+    1.0000    1.0000    0.9686
+    1.0000    1.0000    0.9765
+    1.0       0.0       0.0
+    1.0       1.0       0.0
+    0.0       1.000     0.0
+&quot;&quot;&quot;
+colormapgray1 =  &quot;&quot;&quot;
+    1.0000    1.0000    1.0000
+    0.9961    0.9961    0.9961
+    0.9922    0.9922    0.9922
+    0.9882    0.9882    0.9882
+    0.9843    0.9843    0.9843
+    0.9804    0.9804    0.9804
+    0.9765    0.9765    0.9765
+    0.9725    0.9725    0.9725
+    0.9686    0.9686    0.9686
+    0.9647    0.9647    0.9647
+    0.9608    0.9608    0.9608
+    0.9569    0.9569    0.9569
+    0.9529    0.9529    0.9529
+    0.9490    0.9490    0.9490
+    0.9451    0.9451    0.9451
+    0.9412    0.9412    0.9412
+    0.9373    0.9373    0.9373
+    0.9333    0.9333    0.9333
+    0.9294    0.9294    0.9294
+    0.9255    0.9255    0.9255
+    0.9216    0.9216    0.9216
+    0.9176    0.9176    0.9176
+    0.9137    0.9137    0.9137
+    0.9098    0.9098    0.9098
+    0.9059    0.9059    0.9059
+    0.9020    0.9020    0.9020
+    0.8980    0.8980    0.8980
+    0.8941    0.8941    0.8941
+    0.8902    0.8902    0.8902
+    0.8863    0.8863    0.8863
+    0.8824    0.8824    0.8824
+    0.8784    0.8784    0.8784
+    0.8745    0.8745    0.8745
+    0.8706    0.8706    0.8706
+    0.8667    0.8667    0.8667
+    0.8627    0.8627    0.8627
+    0.8588    0.8588    0.8588
+    0.8549    0.8549    0.8549
+    0.8510    0.8510    0.8510
+    0.8471    0.8471    0.8471
+    0.8431    0.8431    0.8431
+    0.8392    0.8392    0.8392
+    0.8353    0.8353    0.8353
+    0.8314    0.8314    0.8314
+    0.8275    0.8275    0.8275
+    0.8235    0.8235    0.8235
+    0.8196    0.8196    0.8196
+    0.8157    0.8157    0.8157
+    0.8118    0.8118    0.8118
+    0.8078    0.8078    0.8078
+    0.8039    0.8039    0.8039
+    0.8000    0.8000    0.8000
+    0.7961    0.7961    0.7961
+    0.7922    0.7922    0.7922
+    0.7882    0.7882    0.7882
+    0.7843    0.7843    0.7843
+    0.7804    0.7804    0.7804
+    0.7765    0.7765    0.7765
+    0.7725    0.7725    0.7725
+    0.7686    0.7686    0.7686
+    0.7647    0.7647    0.7647
+    0.7608    0.7608    0.7608
+    0.7569    0.7569    0.7569
+    0.7529    0.7529    0.7529
+    0.7490    0.7490    0.7490
+    0.7451    0.7451    0.7451
+    0.7412    0.7412    0.7412
+    0.7373    0.7373    0.7373
+    0.7333    0.7333    0.7333
+    0.7294    0.7294    0.7294
+    0.7255    0.7255    0.7255
+    0.7216    0.7216    0.7216
+    0.7176    0.7176    0.7176
+    0.7137    0.7137    0.7137
+    0.7098    0.7098    0.7098
+    0.7059    0.7059    0.7059
+    0.7020    0.7020    0.7020
+    0.6980    0.6980    0.6980
+    0.6941    0.6941    0.6941
+    0.6902    0.6902    0.6902
+    0.6863    0.6863    0.6863
+    0.6824    0.6824    0.6824
+    0.6784    0.6784    0.6784
+    0.6745    0.6745    0.6745
+    0.6706    0.6706    0.6706
+    0.6667    0.6667    0.6667
+    0.6627    0.6627    0.6627
+    0.6588    0.6588    0.6588
+    0.6549    0.6549    0.6549
+    0.6510    0.6510    0.6510
+    0.6471    0.6471    0.6471
+    0.6431    0.6431    0.6431
+    0.6392    0.6392    0.6392
+    0.6353    0.6353    0.6353
+    0.6314    0.6314    0.6314
+    0.6275    0.6275    0.6275
+    0.6235    0.6235    0.6235
+    0.6196    0.6196    0.6196
+    0.6157    0.6157    0.6157
+    0.6118    0.6118    0.6118
+    0.6078    0.6078    0.6078
+    0.6039    0.6039    0.6039
+    0.6000    0.6000    0.6000
+    0.5961    0.5961    0.5961
+    0.5922    0.5922    0.5922
+    0.5882    0.5882    0.5882
+    0.5843    0.5843    0.5843
+    0.5804    0.5804    0.5804
+    0.5765    0.5765    0.5765
+    0.5725    0.5725    0.5725
+    0.5686    0.5686    0.5686
+    0.5647    0.5647    0.5647
+    0.5608    0.5608    0.5608
+    0.5569    0.5569    0.5569
+    0.5529    0.5529    0.5529
+    0.5490    0.5490    0.5490
+    0.5451    0.5451    0.5451
+    0.5412    0.5412    0.5412
+    0.5373    0.5373    0.5373
+    0.5333    0.5333    0.5333
+    0.5294    0.5294    0.5294
+    0.5255    0.5255    0.5255
+    0.5216    0.5216    0.5216
+    0.5176    0.5176    0.5176
+    0.5137    0.5137    0.5137
+    0.5098    0.5098    0.5098
+    0.5059    0.5059    0.5059
+    0.5020    0.5020    0.5020
+    0.4980    0.4980    0.4980
+    0.4941    0.4941    0.4941
+    0.4902    0.4902    0.4902
+    0.4863    0.4863    0.4863
+    0.4824    0.4824    0.4824
+    0.4784    0.4784    0.4784
+    0.4745    0.4745    0.4745
+    0.4706    0.4706    0.4706
+    0.4667    0.4667    0.4667
+    0.4627    0.4627    0.4627
+    0.4588    0.4588    0.4588
+    0.4549    0.4549    0.4549
+    0.4510    0.4510    0.4510
+    0.4471    0.4471    0.4471
+    0.4431    0.4431    0.4431
+    0.4392    0.4392    0.4392
+    0.4353    0.4353    0.4353
+    0.4314    0.4314    0.4314
+    0.4275    0.4275    0.4275
+    0.4235    0.4235    0.4235
+    0.4196    0.4196    0.4196
+    0.4157    0.4157    0.4157
+    0.4118    0.4118    0.4118
+    0.4078    0.4078    0.4078
+    0.4039    0.4039    0.4039
+    0.4000    0.4000    0.4000
+    0.3961    0.3961    0.3961
+    0.3922    0.3922    0.3922
+    0.3882    0.3882    0.3882
+    0.3843    0.3843    0.3843
+    0.3804    0.3804    0.3804
+    0.3765    0.3765    0.3765
+    0.3725    0.3725    0.3725
+    0.3686    0.3686    0.3686
+    0.3647    0.3647    0.3647
+    0.3608    0.3608    0.3608
+    0.3569    0.3569    0.3569
+    0.3529    0.3529    0.3529
+    0.3490    0.3490    0.3490
+    0.3451    0.3451    0.3451
+    0.3412    0.3412    0.3412
+    0.3373    0.3373    0.3373
+    0.3333    0.3333    0.3333
+    0.3294    0.3294    0.3294
+    0.3255    0.3255    0.3255
+    0.3216    0.3216    0.3216
+    0.3176    0.3176    0.3176
+    0.3137    0.3137    0.3137
+    0.3098    0.3098    0.3098
+    0.3059    0.3059    0.3059
+    0.3020    0.3020    0.3020
+    0.2980    0.2980    0.2980
+    0.2941    0.2941    0.2941
+    0.2902    0.2902    0.2902
+    0.2863    0.2863    0.2863
+    0.2824    0.2824    0.2824
+    0.2784    0.2784    0.2784
+    0.2745    0.2745    0.2745
+    0.2706    0.2706    0.2706
+    0.2667    0.2667    0.2667
+    0.2627    0.2627    0.2627
+    0.2588    0.2588    0.2588
+    0.2549    0.2549    0.2549
+    0.2510    0.2510    0.2510
+    0.2471    0.2471    0.2471
+    0.2431    0.2431    0.2431
+    0.2392    0.2392    0.2392
+    0.2353    0.2353    0.2353
+    0.2314    0.2314    0.2314
+    0.2275    0.2275    0.2275
+    0.2235    0.2235    0.2235
+    0.2196    0.2196    0.2196
+    0.2157    0.2157    0.2157
+    0.2118    0.2118    0.2118
+    0.2078    0.2078    0.2078
+    0.2039    0.2039    0.2039
+    0.2000    0.2000    0.2000
+    0.1961    0.1961    0.1961
+    0.1922    0.1922    0.1922
+    0.1882    0.1882    0.1882
+    0.1843    0.1843    0.1843
+    0.1804    0.1804    0.1804
+    0.1765    0.1765    0.1765
+    0.1725    0.1725    0.1725
+    0.1686    0.1686    0.1686
+    0.1647    0.1647    0.1647
+    0.1608    0.1608    0.1608
+    0.1569    0.1569    0.1569
+    0.1529    0.1529    0.1529
+    0.1490    0.1490    0.1490
+    0.1451    0.1451    0.1451
+    0.1412    0.1412    0.1412
+    0.1373    0.1373    0.1373
+    0.1333    0.1333    0.1333
+    0.1294    0.1294    0.1294
+    0.1255    0.1255    0.1255
+    0.1216    0.1216    0.1216
+    0.1176    0.1176    0.1176
+    0.1137    0.1137    0.1137
+    0.1098    0.1098    0.1098
+    0.1059    0.1059    0.1059
+    0.1020    0.1020    0.1020
+    0.0980    0.0980    0.0980
+    0.0941    0.0941    0.0941
+    0.0902    0.0902    0.0902
+    0.0863    0.0863    0.0863
+    0.0824    0.0824    0.0824
+    0.0784    0.0784    0.0784
+    0.0745    0.0745    0.0745
+    0.0706    0.0706    0.0706
+    0.0667    0.0667    0.0667
+    0.0627    0.0627    0.0627
+    0.0588    0.0588    0.0588
+    0.0549    0.0549    0.0549
+    0.0510    0.0510    0.0510
+    0.0471    0.0471    0.0471
+    0.0431    0.0431    0.0431
+    0.0392    0.0392    0.0392
+    0.0353    0.0353    0.0353
+    0.0314    0.0314    0.0314
+    0.0275    0.0275    0.0275
+    0.0235    0.0235    0.0235
+    0.0196    0.0196    0.0196
+    0.0157    0.0157    0.0157
+    0.0118    0.0118    0.0118
+    1.0       0.0       0.0
+    1.0       1.0       0.0
+    0.0       1.000     0.0
+&quot;&quot;&quot;
+colormapLinrad =  &quot;&quot;&quot;
+    0.0000    0.0000    0.0000
+    0.0000    0.0000    0.0123
+    0.0000    0.0000    0.0246
+    0.0000    0.0000    0.0368
+    0.0000    0.0000    0.0490
+    0.0000    0.0000    0.0612
+    0.0000    0.0000    0.0734
+    0.0000    0.0000    0.0855
+    0.0000    0.0000    0.0975
+    0.0000    0.0000    0.1094
+    0.0000    0.0000    0.1213
+    0.0000    0.0000    0.1331
+    0.0000    0.0000    0.1448
+    0.0000    0.0000    0.1564
+    0.0000    0.0000    0.1678
+    0.0000    0.0000    0.1792
+    0.0000    0.0000    0.1904
+    0.0000    0.0000    0.2015
+    0.0000    0.0000    0.2124
+    0.0000    0.0000    0.2232
+    0.0000    0.0000    0.2338
+    0.0000    0.0000    0.2442
+    0.0000    0.0000    0.2545
+    0.0000    0.0000    0.2645
+    0.0000    0.0000    0.2744
+    0.0000    0.0000    0.2841
+    0.0000    0.0000    0.2935
+    0.0000    0.0000    0.3028
+    0.0000    0.0000    0.3118
+    0.0000    0.0000    0.3206
+    0.0000    0.0000    0.3292
+    0.0000    0.0000    0.3375
+    0.0000    0.0000    0.3456
+    0.0000    0.0000    0.3534
+    0.0000    0.0000    0.3609
+    0.0000    0.0036    0.3682
+    0.0000    0.0149    0.3752
+    0.0000    0.0262    0.3820
+    0.0000    0.0375    0.3885
+    0.0000    0.0487    0.3946
+    0.0000    0.0600    0.4005
+    0.0000    0.0712    0.4061
+    0.0000    0.0824    0.4114
+    0.0000    0.0936    0.4164
+    0.0000    0.1047    0.4211
+    0.0000    0.1158    0.4255
+    0.0000    0.1269    0.4295
+    0.0000    0.1379    0.4333
+    0.0000    0.1489    0.4367
+    0.0000    0.1599    0.4398
+    0.0000    0.1707    0.4426
+    0.0000    0.1816    0.4451
+    0.0000    0.1923    0.4472
+    0.0000    0.2030    0.4490
+    0.0000    0.2137    0.4505
+    0.0000    0.2243    0.4517
+    0.0000    0.2348    0.4525
+    0.0000    0.2452    0.4530
+    0.0000    0.2555    0.4531
+    0.0000    0.2658    0.4529
+    0.0000    0.2760    0.4524
+    0.0000    0.2860    0.4516
+    0.0000    0.2960    0.4504
+    0.0000    0.3059    0.4489
+    0.0000    0.3157    0.4471
+    0.0000    0.3254    0.4449
+    0.0000    0.3350    0.4424
+    0.0000    0.3445    0.4396
+    0.0000    0.3538    0.4364
+    0.0000    0.3631    0.4330
+    0.0000    0.3722    0.4292
+    0.0000    0.3812    0.4251
+    0.0000    0.3901    0.4207
+    0.0000    0.3988    0.4160
+    0.0000    0.4075    0.4109
+    0.0000    0.4160    0.4056
+    0.0000    0.4243    0.4000
+    0.0000    0.4325    0.3941
+    0.0000    0.4406    0.3879
+    0.0000    0.4486    0.3814
+    0.0000    0.4563    0.3746
+    0.0000    0.4640    0.3676
+    0.0000    0.4715    0.3603
+    0.0000    0.4788    0.3527
+    0.0000    0.4860    0.3448
+    0.0000    0.4930    0.3367
+    0.0000    0.4998    0.3284
+    0.0000    0.5065    0.3198
+    0.0000    0.5131    0.3110
+    0.0000    0.5194    0.3020
+    0.0000    0.5256    0.2927
+    0.0000    0.5316    0.2832
+    0.0000    0.5375    0.2735
+    0.0000    0.5432    0.2636
+    0.0000    0.5487    0.2535
+    0.0000    0.5540    0.2433
+    0.0000    0.5591    0.2328
+    0.0000    0.5641    0.2222
+    0.0000    0.5688    0.2114
+    0.0000    0.5734    0.2005
+    0.0000    0.5778    0.1894
+    0.0000    0.5820    0.1782
+    0.0000    0.5860    0.1668
+    0.0000    0.5899    0.1553
+    0.0000    0.5935    0.1437
+    0.0120    0.5969    0.1320
+    0.0289    0.6002    0.1202
+    0.0458    0.6032    0.1084
+    0.0628    0.6061    0.0964
+    0.0797    0.6088    0.0844
+    0.0966    0.6112    0.0723
+    0.1134    0.6135    0.0601
+    0.1302    0.6155    0.0479
+    0.1470    0.6174    0.0357
+    0.1638    0.6190    0.0234
+    0.1805    0.6205    0.0112
+    0.1971    0.6217   -0.0011
+    0.2137    0.6228    0.0000
+    0.2302    0.6236    0.0000
+    0.2467    0.6243    0.0000
+    0.2631    0.6247    0.0000
+    0.2794    0.6250    0.0000
+    0.2957    0.6250    0.0000
+    0.3118    0.6248    0.0000
+    0.3279    0.6244    0.0000
+    0.3438    0.6239    0.0000
+    0.3597    0.6231    0.0000
+    0.3755    0.6221    0.0000
+    0.3911    0.6209    0.0000
+    0.4067    0.6195    0.0000
+    0.4221    0.6179    0.0000
+    0.4374    0.6161    0.0000
+    0.4526    0.6141    0.0000
+    0.4676    0.6119    0.0000
+    0.4826    0.6095    0.0000
+    0.4973    0.6069    0.0000
+    0.5120    0.6041    0.0000
+    0.5265    0.6011    0.0000
+    0.5408    0.5980    0.0000
+    0.5550    0.5946    0.0000
+    0.5690    0.5910    0.0000
+    0.5829    0.5872    0.0000
+    0.5965    0.5833    0.0000
+    0.6101    0.5791    0.0000
+    0.6234    0.5748    0.0000
+    0.6366    0.5702    0.0000
+    0.6496    0.5655    0.0000
+    0.6623    0.5606    0.0000
+    0.6750    0.5556    0.0000
+    0.6874    0.5503    0.0000
+    0.6996    0.5449    0.0000
+    0.7116    0.5392    0.0000
+    0.7234    0.5334    0.0000
+    0.7350    0.5275    0.0000
+    0.7464    0.5213    0.0000
+    0.7576    0.5150    0.0000
+    0.7685    0.5085    0.0000
+    0.7793    0.5019    0.0000
+    0.7898    0.4951    0.0000
+    0.8000    0.4881    0.0000
+    0.8101    0.4810    0.0000
+    0.8199    0.4737    0.0000
+    0.8295    0.4663    0.0000
+    0.8389    0.4587    0.0000
+    0.8480    0.4509    0.0000
+    0.8568    0.4430    0.0000
+    0.8654    0.4350    0.0000
+    0.8738    0.4268    0.0000
+    0.8819    0.4185    0.0000
+    0.8898    0.4101    0.0000
+    0.8974    0.4015    0.0000
+    0.9048    0.3928    0.0000
+    0.9118    0.3839    0.0000
+    0.9187    0.3749    0.0000
+    0.9252    0.3658    0.0000
+    0.9315    0.3566    0.0000
+    0.9376    0.3473    0.0000
+    0.9433    0.3379    0.0000
+    0.9488    0.3283    0.0000
+    0.9540    0.3187    0.0000
+    0.9590    0.3089    0.0000
+    0.9636    0.2990    0.0000
+    0.9680    0.2891    0.0000
+    0.9721    0.2790    0.0000
+    0.9760    0.2689    0.0000
+    0.9795    0.2586    0.0000
+    0.9828    0.2483    0.0083
+    0.9858    0.2379    0.0219
+    0.9885    0.2274    0.0354
+    0.9909    0.2169    0.0489
+    0.9931    0.2063    0.0625
+    0.9949    0.1956    0.0760
+    0.9965    0.1848    0.0896
+    0.9978    0.1740    0.1031
+    0.9987    0.1632    0.1167
+    0.9995    0.1522    0.1303
+    0.9999    0.1413    0.1439
+    1.0000    0.1302    0.1575
+    1.0000    0.1712    0.1712
+    1.0000    0.1848    0.1848
+    1.0000    0.1986    0.1986
+    1.0000    0.2123    0.2123
+    1.0000    0.2261    0.2261
+    1.0000    0.2400    0.2400
+    1.0000    0.2539    0.2539
+    1.0000    0.2678    0.2678
+    1.0000    0.2819    0.2819
+    1.0000    0.2960    0.2960
+    1.0000    0.3102    0.3102
+    1.0000    0.3245    0.3245
+    1.0000    0.3389    0.3389
+    1.0000    0.3535    0.3535
+    1.0000    0.3681    0.3681
+    1.0000    0.3829    0.3829
+    1.0000    0.3978    0.3978
+    1.0000    0.4129    0.4129
+    1.0000    0.4282    0.4282
+    1.0000    0.4436    0.4436
+    1.0000    0.4592    0.4592
+    1.0000    0.4750    0.4750
+    1.0000    0.4910    0.4910
+    1.0000    0.5072    0.5072
+    1.0000    0.5237    0.5237
+    1.0000    0.5405    0.5405
+    1.0000    0.5574    0.5574
+    1.0000    0.5747    0.5747
+    1.0000    0.5923    0.5923
+    1.0000    0.6102    0.6102
+    1.0000    0.6284    0.6284
+    1.0000    0.6469    0.6469
+    1.0000    0.6658    0.6658
+    1.0000    0.6851    0.6851
+    1.0000    0.7047    0.7047
+    1.0000    0.7248    0.7248
+    1.0000    0.7453    0.7453
+    1.0000    0.7662    0.7662
+    1.0000    0.7876    0.7876
+    1.0000    0.8095    0.8095
+    1.0000    0.8319    0.8319
+    1.0000    0.8548    0.8548
+    1.0000    0.8782    0.8782
+    1.0000    0.9022    0.9022
+    1.0000    0.9268    0.9268
+    1.0000    0.9519    0.9519
+    1.0000    0.9777    0.9777
+    1.0000    1.0000    1.0000
+    1.0000    1.0000    1.0000
+    1.0000    1.0000    1.0000
+    1.0000    1.0000    1.0000
+    1.0000    1.0000    1.0000
+    1.0000    1.0000    1.0000
+    1.0000    1.0000    1.0000
+    1.0000    1.0000    1.0000
+    1.0       0.0       0.0
+    1.0       1.0       0.0
+    0.0       1.000     0.0
+&quot;&quot;&quot;
+
+#----------------------------------------------------- Colormap2Palette
+def Colormap2Palette(colormap=colormapLinrad):
+    &quot;&quot;&quot; convert a matlab type colormap to a PIL palette &quot;&quot;&quot;
+    x = map(lambda x,colormap=colormap: int(string.atof(x)*255), string.split(colormap))
+    palette = [(0,0,0)] * 256
+    for i in range(len(x)/3):
+	palette[i] = (x[i*3], x[i*3+1], x[i*3+2])
+    palette = map(lambda a: chr(a[0])+chr(a[1])+chr(a[2]), palette)
+    palette = string.join(palette, &quot;&quot;)
+    g.palette=palette
+    return palette

Added: branches/wspr/pctile.f
===================================================================
--- branches/wspr/pctile.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/pctile.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,13 @@
+	subroutine pctile(x,tmp,nmax,npct,xpct)
+	real x(nmax),tmp(nmax)
+
+	do i=1,nmax
+	  tmp(i)=x(i)
+	enddo
+	call sort(nmax,tmp)
+	j=nint(nmax*0.01*npct)
+	if(j.lt.1) j=1
+	xpct=tmp(j)
+
+	return
+	end

Added: branches/wspr/peakup.f
===================================================================
--- branches/wspr/peakup.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/peakup.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,8 @@
+      subroutine peakup(ym,y0,yp,dx)
+
+      b=(yp-ym)/2.0
+      c=(yp+ym-2.0*y0)/2.0
+      dx=-b/(2.0*c)
+
+      return
+      end

Added: branches/wspr/playsound.c
===================================================================
--- branches/wspr/playsound.c	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/playsound.c	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,186 @@
+/** @file patest_record.c
+	@brief Record input into an array; Save array to a file; Playback recorded data.
+	@author Phil Burk  <A HREF="http://www.softsynth.com">http://www.softsynth.com</A>
+*/
+/*
+ * $Id: patest_record.c 249 2006-08-09 20:08:01Z va3db $
+ *
+ * This program uses the PortAudio Portable Audio Library.
+ * For more information see: <A HREF="http://www.portaudio.com">http://www.portaudio.com</A>
+ * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the &quot;Software&quot;), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;portaudio.h&quot;
+
+/* #define SAMPLE_RATE  (17932) // Test failure to open with this value. */
+#define SAMPLE_RATE  (12000)
+#define FRAMES_PER_BUFFER (1024)
+#define NUM_SECONDS     (114)
+#define NUM_CHANNELS    (1)
+/* #define DITHER_FLAG     (paDitherOff) */
+#define DITHER_FLAG     (0) /**/
+
+/* Select sample format. */
+#define PA_SAMPLE_TYPE  paInt16
+typedef short SAMPLE;
+
+typedef struct
+{
+    int          frameIndex;  /* Index into sample array. */
+    int          maxFrameIndex;
+    SAMPLE      *recordedSamples;
+} paTestData;
+
+/* This routine will be called by the PortAudio engine when audio is needed.
+** It may be called at interrupt level on some machines so don't do anything
+** that could mess up the system like calling malloc() or free().
+*/
+static int playCallback( const void *inputBuffer, void *outputBuffer,
+                         unsigned long framesPerBuffer,
+                         const PaStreamCallbackTimeInfo* timeInfo,
+                         PaStreamCallbackFlags statusFlags,
+                         void *userData )
+{
+  paTestData *data = (paTestData*)userData;
+  SAMPLE *rptr = &amp;data-&gt;recordedSamples[data-&gt;frameIndex * NUM_CHANNELS];
+  SAMPLE *wptr = (SAMPLE*)outputBuffer;
+  unsigned int i;
+  int finished;
+  unsigned int framesLeft = data-&gt;maxFrameIndex - data-&gt;frameIndex;
+
+  (void) inputBuffer; /* Prevent unused variable warnings. */
+  (void) timeInfo;
+  (void) statusFlags;
+  (void) userData;
+
+  if( framesLeft &lt; framesPerBuffer )  {
+    /* final buffer... */
+    for( i=0; i&lt;framesLeft; i++ )  {
+      *wptr++ = *rptr++;  /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = *rptr++;  /* right */
+    }
+    for( ; i&lt;framesPerBuffer; i++ )  {
+      *wptr++ = 0;  /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = 0;  /* right */
+    }
+    data-&gt;frameIndex += framesLeft;
+    finished = paComplete;
+  }
+  else  {
+    for( i=0; i&lt;framesPerBuffer; i++ )  {
+      *wptr++ = *rptr++;  /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = *rptr++;  /* right */
+    }
+    data-&gt;frameIndex += framesPerBuffer;
+    finished = paContinue;
+  }
+  return finished;
+}
+
+/*******************************************************************/
+#ifdef CVF
+extern int __stdcall PLAYSOUND(short int iwave[])
+#else
+extern int playsound_(short int iwave[])
+#endif
+{
+  PaStreamParameters  inputParameters,
+                      outputParameters;
+  PaStream*           stream;
+  PaError             err = paNoError;
+  paTestData          data;
+  int                 i;
+  int                 totalFrames;
+  int                 numSamples;
+  int                 numBytes;
+  SAMPLE              max, val;
+  double              average;
+
+  data.maxFrameIndex = totalFrames = NUM_SECONDS * SAMPLE_RATE;
+  data.frameIndex = 0;
+  numSamples = totalFrames * NUM_CHANNELS;
+  numBytes = numSamples * sizeof(SAMPLE);
+  data.recordedSamples = iwave;
+
+  /* Play the wave file */
+  data.frameIndex = 0;
+  err = Pa_Initialize();
+  if( err != paNoError ) goto done;
+  outputParameters.device = Pa_GetDefaultOutputDevice();
+  outputParameters.channelCount = NUM_CHANNELS;
+  outputParameters.sampleFormat =  PA_SAMPLE_TYPE;
+  outputParameters.suggestedLatency = Pa_GetDeviceInfo( outputParameters.device )-&gt;defaultLowOutputLatency;
+  outputParameters.hostApiSpecificStreamInfo = NULL;
+
+  err = Pa_OpenStream(
+              &amp;stream,
+              NULL,                                /* no input */
+              &amp;outputParameters,
+              SAMPLE_RATE,
+              FRAMES_PER_BUFFER,
+              paClipOff,
+              playCallback,
+              &amp;data );
+  if( err != paNoError ) goto done;
+
+  if( stream ) {
+    err = Pa_StartStream( stream );
+    if( err != paNoError ) goto done;
+
+    while( ( err = Pa_IsStreamActive( stream ) ) == 1 ) 
+      Pa_Sleep(100);
+    if( err &lt; 0 ) goto done;
+        
+    err = Pa_CloseStream( stream );
+    if( err != paNoError ) goto done;    
+  }
+
+done:
+  Pa_Terminate();
+  //    if( data.recordedSamples )       /* Sure it is NULL or valid. */
+  //        free( data.recordedSamples );
+  if( err != paNoError ) {
+    fprintf( stderr, &quot;An error occured while using the portaudio stream\n&quot; );
+    fprintf( stderr, &quot;Error number: %d\n&quot;, err );
+    fprintf( stderr, &quot;Error message: %s\n&quot;, Pa_GetErrorText( err ) );
+    err = 1;          /* Always return 0 or 1, but no other return codes. */
+  }
+  return err;
+}
+
+#ifdef CVF
+extern void __stdcall PA_SLEEP(int *nsleep)
+#else
+extern void pa_sleep__(int *nsleep)
+#endif
+{
+  int n;
+  n=*nsleep;
+  Pa_Sleep(n);
+}

Added: branches/wspr/portaudio.h
===================================================================
--- branches/wspr/portaudio.h	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/portaudio.h	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,1123 @@
+
+#ifndef PORTAUDIO_H
+#define PORTAUDIO_H
+/*
+ * $Id: portaudio.h,v 1.1 2005/11/29 21:27:24 joe Exp $
+ * PortAudio Portable Real-Time Audio Library
+ * PortAudio API Header File
+ * Latest version available at: <A HREF="http://www.portaudio.com/">http://www.portaudio.com/</A>
+ *
+ * Copyright (c) 1999-2002 Ross Bencina and Phil Burk
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the &quot;Software&quot;), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/** @file
+ @brief The PortAudio API.
+*/
+
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif /* __cplusplus */
+
+ 
+/** Retrieve the release number of the currently running PortAudio build,
+ eg 1900.
+*/
+int Pa_GetVersion( void );
+
+
+/** Retrieve a textual description of the current PortAudio build,
+ eg &quot;PortAudio V19-devel 13 October 2002&quot;.
+*/
+const char* Pa_GetVersionText( void );
+
+
+/** Error codes returned by PortAudio functions.
+ Note that with the exception of paNoError, all PaErrorCodes are negative.
+*/
+
+typedef int PaError;
+typedef enum PaErrorCode
+{
+    paNoError = 0,
+
+    paNotInitialized = -10000,
+    paUnanticipatedHostError,
+    paInvalidChannelCount,
+    paInvalidSampleRate,
+    paInvalidDevice,
+    paInvalidFlag,
+    paSampleFormatNotSupported,
+    paBadIODeviceCombination,
+    paInsufficientMemory,
+    paBufferTooBig,
+    paBufferTooSmall,
+    paNullCallback,
+    paBadStreamPtr,
+    paTimedOut,
+    paInternalError,
+    paDeviceUnavailable,
+    paIncompatibleHostApiSpecificStreamInfo,
+    paStreamIsStopped,
+    paStreamIsNotStopped,
+    paInputOverflowed,
+    paOutputUnderflowed,
+    paHostApiNotFound,
+    paInvalidHostApi,
+    paCanNotReadFromACallbackStream,      /**&lt; @todo review error code name */
+    paCanNotWriteToACallbackStream,       /**&lt; @todo review error code name */
+    paCanNotReadFromAnOutputOnlyStream,   /**&lt; @todo review error code name */
+    paCanNotWriteToAnInputOnlyStream,     /**&lt; @todo review error code name */
+    paIncompatibleStreamHostApi
+} PaErrorCode;
+
+
+/** Translate the supplied PortAudio error code into a human readable
+ message.
+*/
+const char *Pa_GetErrorText( PaError errorCode );
+
+
+/** Library initialization function - call this before using PortAudio.
+ This function initialises internal data structures and prepares underlying
+ host APIs for use. This function MUST be called before using any other
+ PortAudio API functions.
+
+ If Pa_Initialize() is called multiple times, each successful 
+ call must be matched with a corresponding call to Pa_Terminate(). 
+ Pairs of calls to Pa_Initialize()/Pa_Terminate() may overlap, and are not 
+ required to be fully nested.
+
+ Note that if Pa_Initialize() returns an error code, Pa_Terminate() should
+ NOT be called.
+
+ @return paNoError if successful, otherwise an error code indicating the cause
+ of failure.
+
+ @see Pa_Terminate
+*/
+PaError Pa_Initialize( void );
+
+
+/** Library termination function - call this when finished using PortAudio.
+ This function deallocates all resources allocated by PortAudio since it was
+ initializied by a call to Pa_Initialize(). In cases where Pa_Initialise() has
+ been called multiple times, each call must be matched with a corresponding call
+ to Pa_Terminate(). The final matching call to Pa_Terminate() will automatically
+ close any PortAudio streams that are still open.
+
+ Pa_Terminate() MUST be called before exiting a program which uses PortAudio.
+ Failure to do so may result in serious resource leaks, such as audio devices
+ not being available until the next reboot.
+
+ @return paNoError if successful, otherwise an error code indicating the cause
+ of failure.
+ 
+ @see Pa_Initialize
+*/
+PaError Pa_Terminate( void );
+
+
+
+/** The type used to refer to audio devices. Values of this type usually
+ range from 0 to (Pa_DeviceCount-1), and may also take on the PaNoDevice
+ and paUseHostApiSpecificDeviceSpecification values.
+
+ @see Pa_DeviceCount, paNoDevice, paUseHostApiSpecificDeviceSpecification
+*/
+typedef int PaDeviceIndex;
+
+
+/** A special PaDeviceIndex value indicating that no device is available,
+ or should be used.
+
+ @see PaDeviceIndex
+*/
+#define paNoDevice ((PaDeviceIndex)-1)
+
+
+/** A special PaDeviceIndex value indicating that the device(s) to be used
+ are specified in the host api specific stream info structure.
+
+ @see PaDeviceIndex
+*/
+#define paUseHostApiSpecificDeviceSpecification ((PaDeviceIndex)-2)
+
+
+/* Host API enumeration mechanism */
+
+/** The type used to enumerate to host APIs at runtime. Values of this type
+ range from 0 to (Pa_GetHostApiCount()-1).
+
+ @see Pa_GetHostApiCount
+*/
+typedef int PaHostApiIndex;
+
+
+/** Retrieve the number of available host APIs. Even if a host API is
+ available it may have no devices available.
+
+ @return A non-negative value indicating the number of available host APIs
+ or, a PaErrorCode (which are always negative) if PortAudio is not initialized
+ or an error is encountered.
+
+ @see PaHostApiIndex
+*/
+PaHostApiIndex Pa_GetHostApiCount( void );
+
+
+/** Retrieve the index of the default host API. The default host API will be
+ the lowest common denominator host API on the current platform and is
+ unlikely to provide the best performance.
+
+ @return A non-negative value ranging from 0 to (Pa_GetHostApiCount()-1)
+ indicating the default host API index or, a PaErrorCode (which are always
+ negative) if PortAudio is not initialized or an error is encountered.
+*/
+PaHostApiIndex Pa_GetDefaultHostApi( void );
+
+
+/** Unchanging unique identifiers for each supported host API. This type
+ is used in the PaHostApiInfo structure. The values are guaranteed to be
+ unique and to never change, thus allowing code to be written that
+ conditionally uses host API specific extensions.
+
+ New type ids will be allocated when support for a host API reaches
+ &quot;public alpha&quot; status, prior to that developers should use the
+ paInDevelopment type id.
+
+ @see PaHostApiInfo
+*/
+typedef enum PaHostApiTypeId
+{
+    paInDevelopment=0, /* use while developing support for a new host API */
+    paDirectSound=1,
+    paMME=2,
+    paASIO=3,
+    paSoundManager=4,
+    paCoreAudio=5,
+    paOSS=7,
+    paALSA=8,
+    paAL=9,
+    paBeOS=10,
+    paWDMKS=11,
+    paJACK=12
+} PaHostApiTypeId;
+
+
+/** A structure containing information about a particular host API. */
+
+typedef struct PaHostApiInfo
+{
+    /** this is struct version 1 */
+    int structVersion;
+    /** The well known unique identifier of this host API @see PaHostApiTypeId */
+    PaHostApiTypeId type;
+    /** A textual description of the host API for display on user interfaces. */
+    const char *name;
+
+    /**  The number of devices belonging to this host API. This field may be
+     used in conjunction with Pa_HostApiDeviceIndexToDeviceIndex() to enumerate
+     all devices for this host API.
+     @see Pa_HostApiDeviceIndexToDeviceIndex
+    */
+    int deviceCount;
+
+    /** The the default input device for this host API. The value will be a
+     device index ranging from 0 to (Pa_GetDeviceCount()-1), or paNoDevice
+     if no default input device is available.
+    */
+    PaDeviceIndex defaultInputDevice;
+
+    /** The the default output device for this host API. The value will be a
+     device index ranging from 0 to (Pa_GetDeviceCount()-1), or paNoDevice
+     if no default output device is available.
+    */
+    PaDeviceIndex defaultOutputDevice;
+    
+} PaHostApiInfo;
+
+
+/** Retrieve a pointer to a structure containing information about a specific
+ host Api.
+
+ @param hostApi A valid host API index ranging from 0 to (Pa_GetHostApiCount()-1)
+
+ @return A pointer to an immutable PaHostApiInfo structure describing
+ a specific host API. If the hostApi parameter is out of range or an error
+ is encountered, the function returns NULL.
+
+ The returned structure is owned by the PortAudio implementation and must not
+ be manipulated or freed. The pointer is only guaranteed to be valid between
+ calls to Pa_Initialize() and Pa_Terminate().
+*/
+const PaHostApiInfo * Pa_GetHostApiInfo( PaHostApiIndex hostApi );
+
+
+/** Convert a static host API unique identifier, into a runtime
+ host API index.
+
+ @param type A unique host API identifier belonging to the PaHostApiTypeId
+ enumeration.
+
+ @return A valid PaHostApiIndex ranging from 0 to (Pa_GetHostApiCount()-1) or,
+ a PaErrorCode (which are always negative) if PortAudio is not initialized
+ or an error is encountered.
+ 
+ The paHostApiNotFound error code indicates that the host API specified by the
+ type parameter is not available.
+
+ @see PaHostApiTypeId
+*/
+PaHostApiIndex Pa_HostApiTypeIdToHostApiIndex( PaHostApiTypeId type );
+
+
+/** Convert a host-API-specific device index to standard PortAudio device index.
+ This function may be used in conjunction with the deviceCount field of
+ PaHostApiInfo to enumerate all devices for the specified host API.
+
+ @param hostApi A valid host API index ranging from 0 to (Pa_GetHostApiCount()-1)
+
+ @param hostApiDeviceIndex A valid per-host device index in the range
+ 0 to (Pa_GetHostApiInfo(hostApi)-&gt;deviceCount-1)
+
+ @return A non-negative PaDeviceIndex ranging from 0 to (Pa_GetDeviceCount()-1)
+ or, a PaErrorCode (which are always negative) if PortAudio is not initialized
+ or an error is encountered.
+
+ A paInvalidHostApi error code indicates that the host API index specified by
+ the hostApi parameter is out of range.
+
+ A paInvalidDevice error code indicates that the hostApiDeviceIndex parameter
+ is out of range.
+ 
+ @see PaHostApiInfo
+*/
+PaDeviceIndex Pa_HostApiDeviceIndexToDeviceIndex( PaHostApiIndex hostApi,
+        int hostApiDeviceIndex );
+
+
+
+/** Structure used to return information about a host error condition.
+*/
+typedef struct PaHostErrorInfo{
+    PaHostApiTypeId hostApiType;    /**&lt; the host API which returned the error code */
+    long errorCode;                 /**&lt; the error code returned */
+    const char *errorText;          /**&lt; a textual description of the error if available, otherwise a zero-length string */
+}PaHostErrorInfo;
+
+
+/** Return information about the last host error encountered. The error
+ information returned by Pa_GetLastHostErrorInfo() will never be modified
+ asyncronously by errors occurring in other PortAudio owned threads
+ (such as the thread that manages the stream callback.)
+
+ This function is provided as a last resort, primarily to enhance debugging
+ by providing clients with access to all available error information.
+
+ @return A pointer to an immutable structure constaining information about
+ the host error. The values in this structure will only be valid if a
+ PortAudio function has previously returned the paUnanticipatedHostError
+ error code.
+*/
+const PaHostErrorInfo* Pa_GetLastHostErrorInfo( void );
+
+
+
+/* Device enumeration and capabilities */
+
+/** Retrieve the number of available devices. The number of available devices
+ may be zero.
+
+ @return A non-negative value indicating the number of available devices or,
+ a PaErrorCode (which are always negative) if PortAudio is not initialized
+ or an error is encountered.
+*/
+PaDeviceIndex Pa_GetDeviceCount( void );
+
+
+/** Retrieve the index of the default input device. The result can be
+ used in the inputDevice parameter to Pa_OpenStream().
+
+ @return The default input device index for the default host API, or paNoDevice
+ if no default input device is available or an error was encountered.
+*/
+PaDeviceIndex Pa_GetDefaultInputDevice( void );
+
+
+/** Retrieve the index of the default output device. The result can be
+ used in the outputDevice parameter to Pa_OpenStream().
+
+ @return The default output device index for the defualt host API, or paNoDevice
+ if no default output device is available or an error was encountered.
+
+ @note
+ On the PC, the user can specify a default device by
+ setting an environment variable. For example, to use device #1.
+&lt;pre&gt;
+ set PA_RECOMMENDED_OUTPUT_DEVICE=1
+&lt;/pre&gt;
+ The user should first determine the available device ids by using
+ the supplied application &quot;pa_devs&quot;.
+*/
+PaDeviceIndex Pa_GetDefaultOutputDevice( void );
+
+
+/** The type used to represent monotonic time in seconds that can be used
+ for syncronisation. The type is used for the outTime argument to the
+ PaStreamCallback and as the result of Pa_GetStreamTime().
+     
+ @see PaStreamCallback, Pa_GetStreamTime
+*/
+typedef double PaTime;
+
+
+/** A type used to specify one or more sample formats. Each value indicates
+ a possible format for sound data passed to and from the stream callback,
+ Pa_ReadStream and Pa_WriteStream.
+
+ The standard formats paFloat32, paInt16, paInt32, paInt24, paInt8
+ and aUInt8 are usually implemented by all implementations.
+
+ The floating point representation (paFloat32) uses +1.0 and -1.0 as the
+ maximum and minimum respectively.
+
+ paUInt8 is an unsigned 8 bit format where 128 is considered &quot;ground&quot;
+
+ The paNonInterleaved flag indicates that a multichannel buffer is passed
+ as a set of non-interleaved pointers.
+
+ @see Pa_OpenStream, Pa_OpenDefaultStream, PaDeviceInfo
+ @see paFloat32, paInt16, paInt32, paInt24, paInt8
+ @see paUInt8, paCustomFormat, paNonInterleaved
+*/
+typedef unsigned long PaSampleFormat;
+
+
+#define paFloat32        ((PaSampleFormat) 0x00000001) /**&lt; @see PaSampleFormat */
+#define paInt32          ((PaSampleFormat) 0x00000002) /**&lt; @see PaSampleFormat */
+#define paInt24          ((PaSampleFormat) 0x00000004) /**&lt; Packed 24 bit format. @see PaSampleFormat */
+#define paInt16          ((PaSampleFormat) 0x00000008) /**&lt; @see PaSampleFormat */
+#define paInt8           ((PaSampleFormat) 0x00000010) /**&lt; @see PaSampleFormat */
+#define paUInt8          ((PaSampleFormat) 0x00000020) /**&lt; @see PaSampleFormat */
+#define paCustomFormat   ((PaSampleFormat) 0x00010000)/**&lt; @see PaSampleFormat */
+
+#define paNonInterleaved ((PaSampleFormat) 0x80000000)
+
+/** A structure providing information and capabilities of PortAudio devices.
+ Devices may support input, output or both input and output.
+*/
+typedef struct PaDeviceInfo
+{
+    int structVersion;  /* this is struct version 2 */
+    const char *name;
+    PaHostApiIndex hostApi; /* note this is a host API index, not a type id*/
+    
+    int maxInputChannels;
+    int maxOutputChannels;
+
+    /* Default latency values for interactive performance. */
+    PaTime defaultLowInputLatency;
+    PaTime defaultLowOutputLatency;
+    /* Default latency values for robust non-interactive applications (eg. playing sound files). */
+    PaTime defaultHighInputLatency;
+    PaTime defaultHighOutputLatency;
+
+    double defaultSampleRate;
+} PaDeviceInfo;
+
+
+/** Retrieve a pointer to a PaDeviceInfo structure containing information
+ about the specified device.
+ @return A pointer to an immutable PaDeviceInfo structure. If the device
+ parameter is out of range the function returns NULL.
+
+ @param device A valid device index in the range 0 to (Pa_GetDeviceCount()-1)
+
+ @note PortAudio manages the memory referenced by the returned pointer,
+ the client must not manipulate or free the memory. The pointer is only
+ guaranteed to be valid between calls to Pa_Initialize() and Pa_Terminate().
+
+ @see PaDeviceInfo, PaDeviceIndex
+*/
+const PaDeviceInfo* Pa_GetDeviceInfo( PaDeviceIndex device );
+
+
+/** Parameters for one direction (input or output) of a stream.
+*/
+typedef struct PaStreamParameters
+{
+    /** A valid device index in the range 0 to (Pa_GetDeviceCount()-1)
+     specifying the device to be used or the special constant
+     paUseHostApiSpecificDeviceSpecification which indicates that the actual
+     device(s) to use are specified in hostApiSpecificStreamInfo.
+     This field must not be set to paNoDevice.
+    */
+    PaDeviceIndex device;
+    
+    /** The number of channels of sound to be delivered to the
+     stream callback or accessed by Pa_ReadStream() or Pa_WriteStream().
+     It can range from 1 to the value of maxInputChannels in the
+     PaDeviceInfo record for the device specified by the device parameter.
+    */
+    int channelCount;
+
+    /** The sample format of the buffer provided to the stream callback,
+     a_ReadStream() or Pa_WriteStream(). It may be any of the formats described
+     by the PaSampleFormat enumeration.
+    */
+    PaSampleFormat sampleFormat;
+
+    /** The desired latency in seconds. Where practical, implementations should
+     configure their latency based on these parameters, otherwise they may
+     choose the closest viable latency instead. Unless the suggested latency
+     is greater than the absolute upper limit for the device implementations
+     shouldround the suggestedLatency up to the next practial value - ie to
+     provide an equal or higher latency than suggestedLatency whereever possibe.
+     Actual latency values for an open stream may be retrieved using the
+     inputLatency and outputLatency fields of the PaStreamInfo structure
+     returned by Pa_GetStreamInfo().
+     @see default*Latency in PaDeviceInfo, *Latency in PaStreamInfo
+    */
+    PaTime suggestedLatency;
+
+    /** An optional pointer to a host api specific data structure
+     containing additional information for device setup and/or stream processing.
+     hostApiSpecificStreamInfo is never required for correct operation,
+     if not used it should be set to NULL.
+    */
+    void *hostApiSpecificStreamInfo;
+
+} PaStreamParameters;
+
+
+/** Return code for Pa_IsFormatSupported indicating success. */
+#define paFormatIsSupported (0)
+
+/** Determine whether it would be possible to open a stream with the specified
+ parameters.
+
+ @param inputParameters A structure that describes the input parameters used to
+ open a stream. The suggestedLatency field is ignored. See PaStreamParameters
+ for a description of these parameters. inputParameters must be NULL for
+ output-only streams.
+
+ @param outputParameters A structure that describes the output parameters used
+ to open a stream. The suggestedLatency field is ignored. See PaStreamParameters
+ for a description of these parameters. outputParameters must be NULL for
+ input-only streams.
+
+ @param sampleRate The required sampleRate. For full-duplex streams it is the
+ sample rate for both input and output
+
+ @return Returns 0 if the format is supported, and an error code indicating why
+ the format is not supported otherwise. The constant paFormatIsSupported is
+ provided to compare with the return value for success.
+
+ @see paFormatIsSupported, PaStreamParameters
+*/
+PaError Pa_IsFormatSupported( const PaStreamParameters *inputParameters,
+                              const PaStreamParameters *outputParameters,
+                              double sampleRate );
+
+
+
+/* Streaming types and functions */
+
+
+/**
+ A single PaStream can provide multiple channels of real-time
+ streaming audio input and output to a client application. A stream
+ provides access to audio hardware represented by one or more
+ PaDevices. Depending on the underlying Host API, it may be possible 
+ to open multiple streams using the same device, however this behavior 
+ is implementation defined. Portable applications should assume that 
+ a PaDevice may be simultaneously used by at most one PaStream.
+
+ Pointers to PaStream objects are passed between PortAudio functions that
+ operate on streams.
+
+ @see Pa_OpenStream, Pa_OpenDefaultStream, Pa_OpenDefaultStream, Pa_CloseStream,
+ Pa_StartStream, Pa_StopStream, Pa_AbortStream, Pa_IsStreamActive,
+ Pa_GetStreamTime, Pa_GetStreamCpuLoad
+
+*/
+typedef void PaStream;
+
+
+/** Can be passed as the framesPerBuffer parameter to Pa_OpenStream()
+ or Pa_OpenDefaultStream() to indicate that the stream callback will
+ accept buffers of any size.
+*/
+#define paFramesPerBufferUnspecified  (0)
+
+
+/** Flags used to control the behavior of a stream. They are passed as
+ parameters to Pa_OpenStream or Pa_OpenDefaultStream. Multiple flags may be
+ ORed together.
+
+ @see Pa_OpenStream, Pa_OpenDefaultStream
+ @see paNoFlag, paClipOff, paDitherOff, paNeverDropInput,
+  paPrimeOutputBuffersUsingStreamCallback, paPlatformSpecificFlags
+*/
+typedef unsigned long PaStreamFlags;
+
+/** @see PaStreamFlags */
+#define   paNoFlag          ((PaStreamFlags) 0)
+
+/** Disable default clipping of out of range samples.
+ @see PaStreamFlags
+*/
+#define   paClipOff         ((PaStreamFlags) 0x00000001)
+
+/** Disable default dithering.
+ @see PaStreamFlags
+*/
+#define   paDitherOff       ((PaStreamFlags) 0x00000002)
+
+/** Flag requests that where possible a full duplex stream will not discard
+ overflowed input samples without calling the stream callback. This flag is
+ only valid for full duplex callback streams and only when used in combination
+ with the paFramesPerBufferUnspecified (0) framesPerBuffer parameter. Using
+ this flag incorrectly results in a paInvalidFlag error being returned from
+ Pa_OpenStream and Pa_OpenDefaultStream.
+
+ @see PaStreamFlags, paFramesPerBufferUnspecified
+*/
+#define   paNeverDropInput  ((PaStreamFlags) 0x00000004)
+
+/** Call the stream callback to fill initial output buffers, rather than the
+ default behavior of priming the buffers with zeros (silence). This flag has
+ no effect for input-only and blocking read/write streams.
+ 
+ @see PaStreamFlags
+*/
+#define   paPrimeOutputBuffersUsingStreamCallback ((PaStreamFlags) 0x00000008)
+
+/** A mask specifying the platform specific bits.
+ @see PaStreamFlags
+*/
+#define   paPlatformSpecificFlags ((PaStreamFlags)0xFFFF0000)
+
+/**
+ Timing information for the buffers passed to the stream callback.
+*/
+typedef struct PaStreamCallbackTimeInfo{
+    PaTime inputBufferAdcTime;
+    PaTime currentTime;
+    PaTime outputBufferDacTime;
+} PaStreamCallbackTimeInfo;
+
+
+/**
+ Flag bit constants for the statusFlags to PaStreamCallback.
+
+ @see paInputUnderflow, paInputOverflow, paOutputUnderflow, paOutputOverflow,
+ paPrimingOutput
+*/
+typedef unsigned long PaStreamCallbackFlags;
+
+/** In a stream opened with paFramesPerBufferUnspecified, indicates that
+ input data is all silence (zeros) because no real data is available. In a
+ stream opened without paFramesPerBufferUnspecified, it indicates that one or
+ more zero samples have been inserted into the input buffer to compensate
+ for an input underflow.
+ @see PaStreamCallbackFlags
+*/
+#define paInputUnderflow   ((PaStreamCallbackFlags) 0x00000001)
+
+/** In a stream opened with paFramesPerBufferUnspecified, indicates that data
+ prior to the first sample of the input buffer was discarded due to an
+ overflow, possibly because the stream callback is using too much CPU time.
+ Otherwise indicates that data prior to one or more samples in the
+ input buffer was discarded.
+ @see PaStreamCallbackFlags
+*/
+#define paInputOverflow    ((PaStreamCallbackFlags) 0x00000002)
+
+/** Indicates that output data (or a gap) was inserted, possibly because the
+ stream callback is using too much CPU time.
+ @see PaStreamCallbackFlags
+*/
+#define paOutputUnderflow  ((PaStreamCallbackFlags) 0x00000004)
+
+/** Indicates that output data will be discarded because no room is available.
+ @see PaStreamCallbackFlags
+*/
+#define paOutputOverflow   ((PaStreamCallbackFlags) 0x00000008)
+
+/** Some of all of the output data will be used to prime the stream, input
+ data may be zero.
+ @see PaStreamCallbackFlags
+*/
+#define paPrimingOutput    ((PaStreamCallbackFlags) 0x00000010)
+
+/**
+ Allowable return values for the PaStreamCallback.
+ @see PaStreamCallback
+*/
+typedef enum PaStreamCallbackResult
+{
+    paContinue=0,
+    paComplete=1,
+    paAbort=2
+} PaStreamCallbackResult;
+
+
+/**
+ Functions of type PaStreamCallback are implemented by PortAudio clients.
+ They consume, process or generate audio in response to requests from an
+ active PortAudio stream.
+     
+ @param input and @param output are arrays of interleaved samples,
+ the format, packing and number of channels used by the buffers are
+ determined by parameters to Pa_OpenStream().
+     
+ @param frameCount The number of sample frames to be processed by
+ the stream callback.
+
+ @param timeInfo The time in seconds when the first sample of the input
+ buffer was received at the audio input, the time in seconds when the first
+ sample of the output buffer will begin being played at the audio output, and
+ the time in seconds when the stream callback was called.
+ See also Pa_GetStreamTime()
+
+ @param statusFlags Flags indicating whether input and/or output buffers
+ have been inserted or will be dropped to overcome underflow or overflow
+ conditions.
+
+ @param userData The value of a user supplied pointer passed to
+ Pa_OpenStream() intended for storing synthesis data etc.
+
+ @return
+ The stream callback should return one of the values in the
+ PaStreamCallbackResult enumeration. To ensure that the callback continues
+ to be called, it should return paContinue (0). Either paComplete or paAbort
+ can be returned to finish stream processing, after either of these values is
+ returned the callback will not be called again. If paAbort is returned the
+ stream will finish as soon as possible. If paComplete is returned, the stream
+ will continue until all buffers generated by the callback have been played.
+ This may be useful in applications such as soundfile players where a specific
+ duration of output is required. However, it is not necessary to utilise this
+ mechanism as Pa_StopStream(), Pa_AbortStream() or Pa_CloseStream() can also
+ be used to stop the stream. The callback must always fill the entire output
+ buffer irrespective of its return value.
+
+ @see Pa_OpenStream, Pa_OpenDefaultStream
+
+ @note With the exception of Pa_GetStreamCpuLoad() it is not permissable to call
+ PortAudio API functions from within the stream callback.
+*/
+typedef int PaStreamCallback(
+    const void *input, void *output,
+    unsigned long frameCount,
+    const PaStreamCallbackTimeInfo* timeInfo,
+    PaStreamCallbackFlags statusFlags,
+    void *userData );
+
+
+/** Opens a stream for either input, output or both.
+     
+ @param stream The address of a PaStream pointer which will receive
+ a pointer to the newly opened stream.
+     
+ @param inputParameters A structure that describes the input parameters used by
+ the opened stream. See PaStreamParameters for a description of these parameters.
+ inputParameters must be NULL for output-only streams.
+
+ @param outputParameters A structure that describes the output parameters used by
+ the opened stream. See PaStreamParameters for a description of these parameters.
+ outputParameters must be NULL for input-only streams.
+ 
+ @param sampleRate The desired sampleRate. For full-duplex streams it is the
+ sample rate for both input and output
+     
+ @param framesPerBuffer The number of frames passed to the stream callback
+ function, or the preferred block granularity for a blocking read/write stream.
+ The special value paFramesPerBufferUnspecified (0) may be used to request that
+ the stream callback will recieve an optimal (and possibly varying) number of
+ frames based on host requirements and the requested latency settings.
+ Note: With some host APIs, the use of non-zero framesPerBuffer for a callback
+ stream may introduce an additional layer of buffering which could introduce
+ additional latency. PortAudio guarantees that the additional latency
+ will be kept to the theoretical minimum however, it is strongly recommended
+ that a non-zero framesPerBuffer value only be used when your algorithm
+ requires a fixed number of frames per stream callback.
+ 
+ @param streamFlags Flags which modify the behaviour of the streaming process.
+ This parameter may contain a combination of flags ORed together. Some flags may
+ only be relevant to certain buffer formats.
+     
+ @param streamCallback A pointer to a client supplied function that is responsible
+ for processing and filling input and output buffers. If this parameter is NULL
+ the stream will be opened in 'blocking read/write' mode. In blocking mode,
+ the client can receive sample data using Pa_ReadStream and write sample data
+ using Pa_WriteStream, the number of samples that may be read or written
+ without blocking is returned by Pa_GetStreamReadAvailable and
+ Pa_GetStreamWriteAvailable respectively.
+
+ @param userData A client supplied pointer which is passed to the stream callback
+ function. It could for example, contain a pointer to instance data necessary
+ for processing the audio buffers. This parameter is ignored if streamCallback
+ is NULL.
+     
+ @return
+ Upon success Pa_OpenStream() returns paNoError and places a pointer to a
+ valid PaStream in the stream argument. The stream is inactive (stopped).
+ If a call to Pa_OpenStream() fails, a non-zero error code is returned (see
+ PaError for possible error codes) and the value of stream is invalid.
+
+ @see PaStreamParameters, PaStreamCallback, Pa_ReadStream, Pa_WriteStream,
+ Pa_GetStreamReadAvailable, Pa_GetStreamWriteAvailable
+*/
+PaError Pa_OpenStream( PaStream** stream,
+                       const PaStreamParameters *inputParameters,
+                       const PaStreamParameters *outputParameters,
+                       double sampleRate,
+                       unsigned long framesPerBuffer,
+                       PaStreamFlags streamFlags,
+                       PaStreamCallback *streamCallback,
+                       void *userData );
+
+
+/** A simplified version of Pa_OpenStream() that opens the default input
+ and/or output devices.
+
+ @param stream The address of a PaStream pointer which will receive
+ a pointer to the newly opened stream.
+ 
+ @param numInputChannels  The number of channels of sound that will be supplied
+ to the stream callback or returned by Pa_ReadStream. It can range from 1 to
+ the value of maxInputChannels in the PaDeviceInfo record for the default input
+ device. If 0 the stream is opened as an output-only stream.
+
+ @param numOutputChannels The number of channels of sound to be delivered to the
+ stream callback or passed to Pa_WriteStream. It can range from 1 to the value
+ of maxOutputChannels in the PaDeviceInfo record for the default output dvice.
+ If 0 the stream is opened as an output-only stream.
+
+ @param sampleFormat The sample format of both the input and output buffers
+ provided to the callback or passed to and from Pa_ReadStream and Pa_WriteStream.
+ sampleFormat may be any of the formats described by the PaSampleFormat
+ enumeration.
+ 
+ @param sampleRate Same as Pa_OpenStream parameter of the same name.
+ @param framesPerBuffer Same as Pa_OpenStream parameter of the same name.
+ @param streamCallback Same as Pa_OpenStream parameter of the same name.
+ @param userData Same as Pa_OpenStream parameter of the same name.
+
+ @return As for Pa_OpenStream
+
+ @see Pa_OpenStream, PaStreamCallback
+*/
+PaError Pa_OpenDefaultStream( PaStream** stream,
+                              int numInputChannels,
+                              int numOutputChannels,
+                              PaSampleFormat sampleFormat,
+                              double sampleRate,
+                              unsigned long framesPerBuffer,
+                              PaStreamCallback *streamCallback,
+                              void *userData );
+
+
+/** Closes an audio stream. If the audio stream is active it
+ discards any pending buffers as if Pa_AbortStream() had been called.
+*/
+PaError Pa_CloseStream( PaStream *stream );
+
+
+/** Functions of type PaStreamFinishedCallback are implemented by PortAudio 
+ clients. They can be registered with a stream using the Pa_SetStreamFinishedCallback
+ function. Once registered they are called when the stream becomes inactive
+ (ie once a call to Pa_StopStream() will not block).
+ A stream will become inactive after the stream callback returns non-zero,
+ or when Pa_StopStream or Pa_AbortStream is called. For a stream providing audio
+ output, if the stream callback returns paComplete, or Pa_StopStream is called,
+ the stream finished callback will not be called until all generated sample data
+ has been played.
+ 
+ @param userData The userData parameter supplied to Pa_OpenStream()
+
+ @see Pa_SetStreamFinishedCallback
+*/
+typedef void PaStreamFinishedCallback( void *userData );
+
+
+/** Register a stream finished callback function which will be called when the 
+ stream becomes inactive. See the description of PaStreamFinishedCallback for 
+ further details about when the callback will be called.
+
+ @param stream a pointer to a PaStream that is in the stopped state - if the
+ stream is not stopped, the stream's finished callback will remain unchanged 
+ and an error code will be returned.
+
+ @param streamFinishedCallback a pointer to a function with the same signature
+ as PaStreamFinishedCallback, that will be called when the stream becomes
+ inactive. Passing NULL for this parameter will un-register a previously
+ registered stream finished callback function.
+
+ @return on success returns paNoError, otherwise an error code indicating the cause
+ of the error.
+
+ @see PaStreamFinishedCallback
+*/
+PaError Pa_SetStreamFinishedCallback( PaStream *stream, PaStreamFinishedCallback* streamFinishedCallback ); 
+
+
+/** Commences audio processing.
+*/
+PaError Pa_StartStream( PaStream *stream );
+
+
+/** Terminates audio processing. It waits until all pending
+ audio buffers have been played before it returns.
+*/
+PaError Pa_StopStream( PaStream *stream );
+
+
+/** Terminates audio processing immediately without waiting for pending
+ buffers to complete.
+*/
+PaError Pa_AbortStream( PaStream *stream );
+
+
+/** Determine whether the stream is stopped.
+ A stream is considered to be stopped prior to a successful call to
+ Pa_StartStream and after a successful call to Pa_StopStream or Pa_AbortStream.
+ If a stream callback returns a value other than paContinue the stream is NOT
+ considered to be stopped.
+
+ @return Returns one (1) when the stream is stopped, zero (0) when
+ the stream is running or, a PaErrorCode (which are always negative) if
+ PortAudio is not initialized or an error is encountered.
+
+ @see Pa_StopStream, Pa_AbortStream, Pa_IsStreamActive
+*/
+PaError Pa_IsStreamStopped( PaStream *stream );
+
+
+/** Determine whether the stream is active.
+ A stream is active after a successful call to Pa_StartStream(), until it
+ becomes inactive either as a result of a call to Pa_StopStream() or
+ Pa_AbortStream(), or as a result of a return value other than paContinue from
+ the stream callback. In the latter case, the stream is considered inactive
+ after the last buffer has finished playing.
+
+ @return Returns one (1) when the stream is active (ie playing or recording
+ audio), zero (0) when not playing or, a PaErrorCode (which are always negative)
+ if PortAudio is not initialized or an error is encountered.
+
+ @see Pa_StopStream, Pa_AbortStream, Pa_IsStreamStopped
+*/
+PaError Pa_IsStreamActive( PaStream *stream );
+
+
+
+/** A structure containing unchanging information about an open stream.
+ @see Pa_GetStreamInfo
+*/
+
+typedef struct PaStreamInfo
+{
+    /** this is struct version 1 */
+    int structVersion;
+
+    /** The input latency of the stream in seconds. This value provides the most
+     accurate estimate of input latency available to the implementation. It may
+     differ significantly from the suggestedLatency value passed to Pa_OpenStream().
+     The value of this field will be zero (0.) for output-only streams.
+     @see PaTime
+    */
+    PaTime inputLatency;
+
+    /** The output latency of the stream in seconds. This value provides the most
+     accurate estimate of output latency available to the implementation. It may
+     differ significantly from the suggestedLatency value passed to Pa_OpenStream().
+     The value of this field will be zero (0.) for input-only streams.
+     @see PaTime
+    */
+    PaTime outputLatency;
+
+    /** The sample rate of the stream in Hertz (samples per second). In cases
+     where the hardware sample rate is inaccurate and PortAudio is aware of it,
+     the value of this field may be different from the sampleRate parameter
+     passed to Pa_OpenStream(). If information about the actual hardware sample
+     rate is not available, this field will have the same value as the sampleRate
+     parameter passed to Pa_OpenStream().
+    */
+    double sampleRate;
+    
+} PaStreamInfo;
+
+
+/** Retrieve a pointer to a PaStreamInfo structure containing information
+ about the specified stream.
+ @return A pointer to an immutable PaStreamInfo structure. If the stream
+ parameter invalid, or an error is encountered, the function returns NULL.
+
+ @param stream A pointer to an open stream previously created with Pa_OpenStream.
+
+ @note PortAudio manages the memory referenced by the returned pointer,
+ the client must not manipulate or free the memory. The pointer is only
+ guaranteed to be valid until the specified stream is closed.
+
+ @see PaStreamInfo
+*/
+const PaStreamInfo* Pa_GetStreamInfo( PaStream *stream );
+
+
+/** Determine the current time for the stream according to the same clock used
+ to generate buffer timestamps. This time may be used for syncronising other
+ events to the audio stream, for example synchronizing audio to MIDI.
+                                        
+ @return The stream's current time in seconds, or 0 if an error occurred.
+
+ @see PaTime, PaStreamCallback
+*/
+PaTime Pa_GetStreamTime( PaStream *stream );
+
+
+/** Retrieve CPU usage information for the specified stream.
+ The &quot;CPU Load&quot; is a fraction of total CPU time consumed by a callback stream's
+ audio processing routines including, but not limited to the client supplied
+ stream callback. This function does not work with blocking read/write streams.
+
+ This function may be called from the stream callback function or the
+ application.
+     
+ @return
+ A floating point value, typically between 0.0 and 1.0, where 1.0 indicates
+ that the stream callback is consuming the maximum number of CPU cycles possible
+ to maintain real-time operation. A value of 0.5 would imply that PortAudio and
+ the stream callback was consuming roughly 50% of the available CPU time. The
+ return value may exceed 1.0. A value of 0.0 will always be returned for a
+ blocking read/write stream, or if an error occurrs.
+*/
+double Pa_GetStreamCpuLoad( PaStream* stream );
+
+
+/** Read samples from an input stream. The function doesn't return until
+ the entire buffer has been filled - this may involve waiting for the operating
+ system to supply the data.
+
+ @param stream A pointer to an open stream previously created with Pa_OpenStream.
+ 
+ @param buffer A pointer to a buffer of sample frames. The buffer contains
+ samples in the format specified by the inputParameters-&gt;sampleFormat field
+ used to open the stream, and the number of channels specified by
+ inputParameters-&gt;numChannels. If non-interleaved samples were requested,
+ buffer is a pointer to the first element of an array of non-interleaved
+ buffer pointers, one for each channel.
+
+ @param frames The number of frames to be read into buffer. This parameter
+ is not constrained to a specific range, however high performance applications
+ will want to match this parameter to the framesPerBuffer parameter used
+ when opening the stream.
+
+ @return On success PaNoError will be returned, or PaInputOverflowed if input
+ data was discarded by PortAudio after the previous call and before this call.
+*/
+PaError Pa_ReadStream( PaStream* stream,
+                       void *buffer,
+                       unsigned long frames );
+
+
+/** Write samples to an output stream. This function doesn't return until the
+ entire buffer has been consumed - this may involve waiting for the operating
+ system to consume the data.
+
+ @param stream A pointer to an open stream previously created with Pa_OpenStream.
+
+ @param buffer A pointer to a buffer of sample frames. The buffer contains
+ samples in the format specified by the outputParameters-&gt;sampleFormat field
+ used to open the stream, and the number of channels specified by
+ outputParameters-&gt;numChannels. If non-interleaved samples were requested,
+ buffer is a pointer to the first element of an array of non-interleaved
+ buffer pointers, one for each channel.
+
+ @param frames The number of frames to be written from buffer. This parameter
+ is not constrained to a specific range, however high performance applications
+ will want to match this parameter to the framesPerBuffer parameter used
+ when opening the stream.
+
+ @return On success PaNoError will be returned, or paOutputUnderflowed if
+ additional output data was inserted after the previous call and before this
+ call.
+*/
+PaError Pa_WriteStream( PaStream* stream,
+                        const void *buffer,
+                        unsigned long frames );
+
+
+/** Retrieve the number of frames that can be read from the stream without
+ waiting.
+
+ @return Returns a non-negative value representing the maximum number of frames
+ that can be read from the stream without blocking or busy waiting or, a
+ PaErrorCode (which are always negative) if PortAudio is not initialized or an
+ error is encountered.
+*/
+signed long Pa_GetStreamReadAvailable( PaStream* stream );
+
+
+/** Retrieve the number of frames that can be written to the stream without
+ waiting.
+
+ @return Returns a non-negative value representing the maximum number of frames
+ that can be written to the stream without blocking or busy waiting or, a
+ PaErrorCode (which are always negative) if PortAudio is not initialized or an
+ error is encountered.
+*/
+signed long Pa_GetStreamWriteAvailable( PaStream* stream );
+
+
+/* Miscellaneous utilities */
+
+
+/** Retrieve the size of a given sample format in bytes.
+
+ @return The size in bytes of a single sample in the specified format,
+ or paSampleFormatNotSupported if the format is not supported.
+*/
+PaError Pa_GetSampleSize( PaSampleFormat format );
+
+
+/** Put the caller to sleep for at least 'msec' milliseconds. This function is
+ provided only as a convenience for authors of portable code (such as the tests
+ and examples in the PortAudio distribution.)
+
+ The function may sleep longer than requested so don't rely on this for accurate
+ musical timing.
+*/
+void Pa_Sleep( long msec );
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* PORTAUDIO_H */

Added: branches/wspr/ps162.f
===================================================================
--- branches/wspr/ps162.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/ps162.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,28 @@
+      subroutine ps162(c2,s)
+
+      parameter (NFFT=512,NH=256)
+      complex c2(0:NFFT)
+      real s(-NH:NH)
+!      real work(2*NMAX)
+      complex c(0:NFFT)
+
+      do i=0,NH-1
+         c(i)=c2(i)
+      enddo
+      do i=nh,nfft-1
+         c(i)=0.
+      enddo
+
+      call four1(c,nfft,-1)
+!      call fourt(c,nfft,1,-1,0,work)
+
+      fac=1.0/nfft
+      do i=0,NFFT-1
+         j=i
+         if(j.gt.NH) j=j-NFFT
+         s(j)=fac*(real(c(i))**2 + aimag(c(i))**2)
+      enddo
+      s(-NH)=s(-NH+1)
+
+      return
+      end

Added: branches/wspr/ptt.c
===================================================================
--- branches/wspr/ptt.c	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/ptt.c	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,47 @@
+#include &lt;windows.h&gt;
+#include &lt;stdio.h&gt;
+
+#ifdef CVF
+extern int __stdcall PTT(int *nport, char *unused, int *ntx, int *iptt)
+#else
+int ptt_(int *nport, char *unused, int *ntx, int *iptt)
+#endif
+
+{
+  static HANDLE hFile;
+  static int open=0;
+  char s[10];
+  int i3,i4,i5,i6,i9,i00;
+
+  if(*nport==0) {
+    *iptt=*ntx;
+    return(0);
+  }
+
+  if(*ntx &amp;&amp; (!open)) {
+    sprintf(s,&quot;COM%d&quot;,*nport);
+    hFile=CreateFile(TEXT(s),GENERIC_WRITE,0,NULL,OPEN_EXISTING,
+		     FILE_ATTRIBUTE_NORMAL,NULL);
+    if(hFile==INVALID_HANDLE_VALUE) {
+      printf(&quot;PTT: Cannot open COM port %d.\n&quot;,*nport);
+      return(1);
+    }
+    open=1;
+  }
+
+  if(*ntx &amp;&amp; open) {
+    EscapeCommFunction(hFile,3);
+    EscapeCommFunction(hFile,5);
+    *iptt=1;
+  }
+
+  else {
+    EscapeCommFunction(hFile,4);
+    EscapeCommFunction(hFile,6);
+    EscapeCommFunction(hFile,9);
+    i00=CloseHandle(hFile);
+    *iptt=0;
+    open=0;
+  }
+  return(0);
+}

Added: branches/wspr/save/1222.wav
===================================================================
(Binary files differ)


Property changes on: branches/wspr/save/1222.wav
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/wspr/set.f
===================================================================
--- branches/wspr/set.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/set.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,31 @@
+      subroutine set(a,y,n)
+      real y(n)
+      do i=1,n
+         y(i)=a
+      enddo
+      return
+      end
+
+      subroutine move(x,y,n)
+      real x(n),y(n)
+      do i=1,n
+         y(i)=x(i)
+      enddo
+      return
+      end
+
+      subroutine zero(x,n)
+      real x(n)
+      do i=1,n
+         x(i)=0.0
+      enddo
+      return
+      end
+
+      subroutine add(a,b,c,n)
+      real a(n),b(n),c(n)
+      do i=1,n
+         c(i)=a(i)+b(i)
+      enddo
+      return
+      end

Added: branches/wspr/slope.f
===================================================================
--- branches/wspr/slope.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/slope.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,41 @@
+      subroutine slope(y,npts,xpk)
+
+C  Remove best-fit slope from data in y(i).  When fitting the straight line,
+C  ignore the peak around xpk +/- 2.
+
+      real y(npts)
+      real x(100)
+
+      do i=1,npts
+         x(i)=i
+      enddo
+
+      sumw=0.
+      sumx=0.
+      sumy=0.
+      sumx2=0.
+      sumxy=0.
+      sumy2=0.
+
+      do i=1,npts
+         if(abs(i-xpk).gt.2.0) then
+            sumw=sumw + 1.0
+            sumx=sumx + x(i)
+            sumy=sumy + y(i)
+            sumx2=sumx2 + x(i)**2
+            sumxy=sumxy + x(i)*y(i)
+            sumy2=sumy2 + y(i)**2
+         endif
+      enddo
+
+      delta=sumw*sumx2 - sumx**2
+      a=(sumx2*sumy - sumx*sumxy) / delta
+      b=(sumw*sumxy - sumx*sumy) / delta
+
+      do i=1,npts
+         y(i)=y(i)-(a + b*x(i))
+      enddo
+
+      return
+      end
+

Added: branches/wspr/sort.f
===================================================================
--- branches/wspr/sort.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/sort.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,4 @@
+      subroutine sort(n,arr)
+      call ssort(arr,tmp,n,1)
+      return
+      end

Added: branches/wspr/ssort.f
===================================================================
--- branches/wspr/ssort.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/ssort.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,285 @@
+      subroutine ssort (x,y,n,kflag)
+c***purpose  sort an array and optionally make the same interchanges in
+c            an auxiliary array.  the array may be sorted in increasing
+c            or decreasing order.  a slightly modified quicksort
+c            algorithm is used.
+c
+c   ssort sorts array x and optionally makes the same interchanges in
+c   array y.  the array x may be sorted in increasing order or
+c   decreasing order.  a slightly modified quicksort algorithm is used.
+c
+c   description of parameters
+c      x - array of values to be sorted
+c      y - array to be (optionally) carried along
+c      n - number of values in array x to be sorted
+c      kflag - control parameter
+c            =  2  means sort x in increasing order and carry y along.
+c            =  1  means sort x in increasing order (ignoring y)
+c            = -1  means sort x in decreasing order (ignoring y)
+c            = -2  means sort x in decreasing order and carry y along.
+
+      integer kflag, n
+      real x(n), y(n)
+      real r, t, tt, tty, ty
+      integer i, ij, j, k, kk, l, m, nn
+      integer il(21), iu(21)
+
+      nn = n
+      if (nn .lt. 1) then
+         print*,'ssort: The number of sort elements is not positive.'
+         print*,'ssort: n = ',nn,'   kflag = ',kflag
+         return
+      endif
+c
+      kk = abs(kflag)
+      if (kk.ne.1 .and. kk.ne.2) then
+         print *,
+     +      'the sort control parameter, k, is not 2, 1, -1, or -2.'
+         return
+      endif
+c
+c     alter array x to get decreasing order if needed
+c
+      if (kflag .le. -1) then
+         do 10 i=1,nn
+            x(i) = -x(i)
+   10    continue
+      endif
+c
+      if (kk .eq. 2) go to 100
+c
+c     sort x only
+c
+      m = 1
+      i = 1
+      j = nn
+      r = 0.375e0
+c
+   20 if (i .eq. j) go to 60
+      if (r .le. 0.5898437e0) then
+         r = r+3.90625e-2
+      else
+         r = r-0.21875e0
+      endif
+c
+   30 k = i
+c
+c     select a central element of the array and save it in location t
+c
+      ij = i + int((j-i)*r)
+      t = x(ij)
+c
+c     if first element of array is greater than t, interchange with t
+c
+      if (x(i) .gt. t) then
+         x(ij) = x(i)
+         x(i) = t
+         t = x(ij)
+      endif
+      l = j
+c
+c     if last element of array is less than than t, interchange with t
+c
+      if (x(j) .lt. t) then
+         x(ij) = x(j)
+         x(j) = t
+         t = x(ij)
+c
+c        if first element of array is greater than t, interchange with t
+c
+         if (x(i) .gt. t) then
+            x(ij) = x(i)
+            x(i) = t
+            t = x(ij)
+         endif
+      endif
+c
+c     find an element in the second half of the array which is smaller
+c     than t
+c
+   40 l = l-1
+      if (x(l) .gt. t) go to 40
+c
+c     find an element in the first half of the array which is greater
+c     than t
+c
+   50 k = k+1
+      if (x(k) .lt. t) go to 50
+c
+c     interchange these elements
+c
+      if (k .le. l) then
+         tt = x(l)
+         x(l) = x(k)
+         x(k) = tt
+         go to 40
+      endif
+c
+c     save upper and lower subscripts of the array yet to be sorted
+c
+      if (l-i .gt. j-k) then
+         il(m) = i
+         iu(m) = l
+         i = k
+         m = m+1
+      else
+         il(m) = k
+         iu(m) = j
+         j = l
+         m = m+1
+      endif
+      go to 70
+c
+c     begin again on another portion of the unsorted array
+c
+   60 m = m-1
+      if (m .eq. 0) go to 190
+      i = il(m)
+      j = iu(m)
+c
+   70 if (j-i .ge. 1) go to 30
+      if (i .eq. 1) go to 20
+      i = i-1
+c
+   80 i = i+1
+      if (i .eq. j) go to 60
+      t = x(i+1)
+      if (x(i) .le. t) go to 80
+      k = i
+c
+   90 x(k+1) = x(k)
+      k = k-1
+      if (t .lt. x(k)) go to 90
+      x(k+1) = t
+      go to 80
+c
+c     sort x and carry y along
+c
+  100 m = 1
+      i = 1
+      j = nn
+      r = 0.375e0
+c
+  110 if (i .eq. j) go to 150
+      if (r .le. 0.5898437e0) then
+         r = r+3.90625e-2
+      else
+         r = r-0.21875e0
+      endif
+c
+  120 k = i
+c
+c     select a central element of the array and save it in location t
+c
+      ij = i + int((j-i)*r)
+      t = x(ij)
+      ty = y(ij)
+c
+c     if first element of array is greater than t, interchange with t
+c
+      if (x(i) .gt. t) then
+         x(ij) = x(i)
+         x(i) = t
+         t = x(ij)
+         y(ij) = y(i)
+         y(i) = ty
+         ty = y(ij)
+      endif
+      l = j
+c
+c     if last element of array is less than t, interchange with t
+c
+      if (x(j) .lt. t) then
+         x(ij) = x(j)
+         x(j) = t
+         t = x(ij)
+         y(ij) = y(j)
+         y(j) = ty
+         ty = y(ij)
+c
+c        if first element of array is greater than t, interchange with t
+c
+         if (x(i) .gt. t) then
+            x(ij) = x(i)
+            x(i) = t
+            t = x(ij)
+            y(ij) = y(i)
+            y(i) = ty
+            ty = y(ij)
+         endif
+      endif
+c
+c     find an element in the second half of the array which is smaller
+c     than t
+c
+  130 l = l-1
+      if (x(l) .gt. t) go to 130
+c
+c     find an element in the first half of the array which is greater
+c     than t
+c
+  140 k = k+1
+      if (x(k) .lt. t) go to 140
+c
+c     interchange these elements
+c
+      if (k .le. l) then
+         tt = x(l)
+         x(l) = x(k)
+         x(k) = tt
+         tty = y(l)
+         y(l) = y(k)
+         y(k) = tty
+         go to 130
+      endif
+c
+c     save upper and lower subscripts of the array yet to be sorted
+c
+      if (l-i .gt. j-k) then
+         il(m) = i
+         iu(m) = l
+         i = k
+         m = m+1
+      else
+         il(m) = k
+         iu(m) = j
+         j = l
+         m = m+1
+      endif
+      go to 160
+c
+c     begin again on another portion of the unsorted array
+c
+  150 m = m-1
+      if (m .eq. 0) go to 190
+      i = il(m)
+      j = iu(m)
+c
+  160 if (j-i .ge. 1) go to 120
+      if (i .eq. 1) go to 110
+      i = i-1
+c
+  170 i = i+1
+      if (i .eq. j) go to 150
+      t = x(i+1)
+      ty = y(i+1)
+      if (x(i) .le. t) go to 170
+      k = i
+c
+  180 x(k+1) = x(k)
+      y(k+1) = y(k)
+      k = k-1
+      if (t .lt. x(k)) go to 180
+      x(k+1) = t
+      y(k+1) = ty
+      go to 170
+c
+c     clean up
+c
+  190 if (kflag .le. -1) then
+         do 200 i=1,nn
+            x(i) = -x(i)
+  200    continue
+      endif
+      return
+      end

Added: branches/wspr/sync162.f
===================================================================
--- branches/wspr/sync162.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/sync162.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,118 @@
+      subroutine sync162(c2,jz,dtx,dfx,snrx,snrsync,sstf,kz)
+
+C  Find MEPT_JT sync signals, with best-fit DT and DF.  
+
+      complex c2(jz)
+      parameter (NFFT=512)             !Length of FFTs
+      parameter (NH=NFFT/2)            !Length of power spectra
+      parameter (NSMAX=351)            !Number of half-symbol steps
+      real psavg(-NH:NH)               !Average spectrum of whole record
+      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
+      real ccfred(-NH:NH)              !Peak of ccfblue, as function of freq
+      real ccfblue(-5:540)             !CCF with pseudorandom sequence
+      real tmp(513)
+      real sstf(4,275)
+
+      save
+
+C  Do FFTs of twice symbol length, stepped by half symbols.  Note that 
+C  we have already downsampled the data by factor of 2.
+
+      nsym=162
+      nq=NFFT/4
+      nsteps=jz/nq - 1
+      df=375.0/nfft
+      call zero(psavg,NFFT+1)
+
+C  Compute power spectrum for each step, and get average
+      do j=1,nsteps
+         k=(j-1)*nq + 1
+         call ps162(c2(k),s2(-NH,j))
+         call add(psavg,s2(-NH,j),psavg,NFFT)
+      enddo
+      call pctile(psavg(-136),tmp,273,45,base)
+
+      ia=nint(-100.0/df)
+      ib=-ia
+      i0=0
+      lag1=-5
+      lag2=20
+      syncbest=-1.e30
+
+      call zero(ccfred,745)
+      do i=ia,ib
+         call xcor162(s2,i,nsteps,nsym,lag1,lag2,ccfblue,ccf0,lagpk0)
+         ccfred(i+3)=ccf0
+         sync=ccfblue(lagpk0)
+         k=i-ia+1
+         sstf(1,k)=sync/base
+         sstf(3,k)=i
+         sstf(4,k)=lagpk0
+      enddo
+
+      kz=k
+      do k=1,kz
+         if(sstf(1,k).lt.1.0) then
+            sstf(1,k)=0.
+         else
+            i1=max(1,k-5)
+            i2=min(kz,k+6)
+            do i=i1,i2
+               if(sstf(1,i).gt.sstf(1,k)) sstf(1,k)=0.
+            enddo
+         endif
+      enddo
+
+      k=0
+      do i=1,kz
+         if(sstf(1,i).gt.0.0) then
+            k=k+1
+            sstf(1,k)=sstf(1,i)
+            sstf(3,k)=sstf(3,i)
+            sstf(4,k)=sstf(4,i)
+         endif
+      enddo
+      kz=k
+
+      do k=1,kz
+         ipk=nint(sstf(3,k))
+         dfx=(ipk-i0+3)*df
+
+C  Peak up in time, at best whole-channel frequency
+         call xcor162(s2,ipk,nsteps,nsym,lag1,lag2,ccfblue,ccfmax,lagpk)
+         xlag=lagpk
+         if(lagpk.gt.lag1 .and. lagpk.lt.lag2) then
+            call peakup(ccfblue(lagpk-1),ccfmax,ccfblue(lagpk+1),dx2)
+            xlag=lagpk+dx2
+         endif
+
+C  Find rms of the CCF, without the main peak
+         sq=0.
+         nsq=0
+         do lag=lag1,lag2
+            if(abs(lag-xlag).gt.2.0) then
+               sq=sq+ccfblue(lag)**2
+               nsq=nsq+1
+            endif
+         enddo
+         rms=sqrt(sq/nsq)
+         snrsync=ccfblue(lagpk)/rms - 8.0           !Empirical
+
+         dt=1.0/375.0
+         istart=xlag*nq
+         dtx=istart*dt - 2.0
+         ppmax=0.
+         do i=-4,4
+            ppmax=ppmax + psavg(ipk+i)
+         enddo
+         ppmax=(ppmax/(9.0*base)) - 1.0
+         snrx=db(max(ppmax,0.0001)) -23.55          !Empirical
+         sstf(1,k)=snrsync
+         sstf(2,k)=snrx
+         sstf(3,k)=dtx
+         sstf(4,k)=dfx
+      enddo
+
+      return
+      end
+

Added: branches/wspr/unpack50.f
===================================================================
--- branches/wspr/unpack50.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/unpack50.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,26 @@
+      subroutine unpack50(dat,n1,n2)
+
+      integer*1 dat(11),i1
+      equivalence (i1,i4)
+
+      i4=0
+      i1=dat(1)
+      n1=ishft(i4,20)
+      i1=dat(2)
+      n1=n1 + ishft(i4,12)
+      i1=dat(3)
+      n1=n1 + ishft(i4,4)
+      i1=dat(4)
+      n1=n1 + iand(ishft(i4,-4),15)
+
+      n2=ishft(iand(i4,15),18)
+      i1=dat(5)
+      n2=n2 + ishft(i4,10)
+      i1=dat(6)
+      n2=n2 + ishft(i4,2)
+      i1=dat(7)
+      n2=n2 + iand(ishft(i4,-6),3)
+
+      return
+      end
+

Added: branches/wspr/unpackcall.f
===================================================================
--- branches/wspr/unpackcall.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/unpackcall.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,35 @@
+      subroutine unpackcall(ncall,word)
+
+      character word*12,c*37
+
+      data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ '/
+
+      n=ncall
+      word='......'
+      if(n.ge.262177560) go to 999            !Plain text message ...
+      i=mod(n,27)+11
+      word(6:6)=c(i:i)
+      n=n/27
+      i=mod(n,27)+11
+      word(5:5)=c(i:i)
+      n=n/27
+      i=mod(n,27)+11
+      word(4:4)=c(i:i)
+      n=n/27
+      i=mod(n,10)+1
+      word(3:3)=c(i:i)
+      n=n/10
+      i=mod(n,36)+1
+      word(2:2)=c(i:i)
+      n=n/36
+      i=n+1
+      word(1:1)=c(i:i)
+      do i=1,4
+         if(word(i:i).ne.' ') go to 10
+      enddo
+      go to 999
+ 10   word=word(i:)
+
+ 999  if(word(1:3).eq.'3D0') word='3DA0'//word(4:)
+      return
+      end

Added: branches/wspr/unpackgrid.f
===================================================================
--- branches/wspr/unpackgrid.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/unpackgrid.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,32 @@
+      subroutine unpackgrid(ng,grid)
+
+      parameter (NGBASE=180*180)
+      character grid*4,grid6*6
+
+      grid='    '
+      if(ng.ge.32400) go to 10
+      dlat=mod(ng,180)-90
+      dlong=(ng/180)*2 - 180 + 2
+      call deg2grid(dlong,dlat,grid6)
+      grid=grid6
+      go to 100
+
+ 10   n=ng-NGBASE-1
+      if(n.ge.1 .and.n.le.30) then
+         write(grid,1012) -n
+ 1012    format(i3.2)
+      else if(n.ge.31 .and.n.le.60) then
+         n=n-30
+         write(grid,1022) -n
+ 1022    format('R',i3.2)
+      else if(n.eq.61) then
+         grid='RO'
+      else if(n.eq.62) then
+         grid='RRR'
+      else if(n.eq.63) then
+         grid='73'
+      endif
+
+ 100  return
+      end
+

Added: branches/wspr/unpackmept.f
===================================================================
--- branches/wspr/unpackmept.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/unpackmept.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,57 @@
+      subroutine unpackmept(dat,msg)
+
+C  Unpack 50 bits to retrieve an MEPT_JT message.
+
+      parameter (NBASE=37*36*10*27*27*27)
+      integer dat(12)
+      character c1*12,grid*4,msg*22,grid6*6
+
+      nc1=ishft(dat(1),22) + ishft(dat(2),16) + ishft(dat(3),10)+
+     +  ishft(dat(4),4) + iand(ishft(dat(5),-2),15)
+
+      n2=ishft(iand(dat(5),3),26) + ishft(dat(6),20) + 
+     +  ishft(dat(7),14) + ishft(dat(8),8) + ishft(dat(9),2) + 
+     +  iand(ishft(dat(10),-4),3)
+
+      ng=n2/128
+      ndbm=iand(n2,127) - 64
+
+      if(nc1.lt.NBASE) then
+         call unpackcall(nc1,c1)
+      else
+         print*,'Error in unpackmept: bad callsign?'
+         stop
+      endif
+
+      call unpackgrid(ng,grid)
+      grid6=grid//'ma'
+      call grid2k(grid6,k)
+      if(k.ge.1 .and. k.le.900)  then
+         print*,'Error in unpackmept: k=',k
+         stop
+      endif
+
+      i=index(c1,char(0))
+      if(i.ge.3) c1=c1(1:i-1)//'            '
+
+      msg='                      '
+      j=0
+      do i=1,12
+         j=j+1
+         msg(j:j)=c1(i:i)
+         if(c1(i:i).eq.' ') go to 10
+      enddo
+      j=j+1
+      msg(j:j)=' '
+
+ 10   if(k.eq.0) then
+         do i=1,4
+            if(j.le.21) j=j+1
+            msg(j:j)=grid(i:i)
+         enddo
+         j=j+1
+         msg(j:j)=' '
+      endif
+
+ 100  return
+      end

Added: branches/wspr/wfile5.f
===================================================================
--- branches/wspr/wfile5.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/wfile5.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,43 @@
+      subroutine wfile5(iwave,nmax,nfsample,outfile)
+
+C  Write a wavefile to disk.
+
+      integer*2 iwave(nmax)
+      character*70 outfile
+
+      integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+      character*4 ariff,awave,afmt,adata
+      integer*1 hdr(44)
+      common/hdr/ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,
+     +     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata
+      equivalence (hdr,ariff)
+
+C  Generate the header
+      ariff='RIFF'
+      awave='WAVE'
+      afmt='fmt '
+      adata='data'
+      lenfmt=16                       !Rest of this sub-chunk is 16 bytes long
+      nfmt2=1                               !PCM = 1
+      nchan2=1                              !1=mono, 2=stereo
+      nbitsam2=16                           !Bits per sample
+      nsamrate=nfsample
+      nbytesec=nfsample*nchan2*nbitsam2/8   !Bytes per second
+      nbytesam2=nchan2*nbitsam2/8           !Block-align               
+      ndata=nmax*nchan2*nbitsam2/8
+      nbytes=ndata+44
+      nchunk=nbytes-8
+
+#ifdef CVF
+      open(12,file=outfile,form='binary',status='unknown')
+#else
+      open(12,file=outfile,access='stream',status='unknown')
+#endif
+
+      write(12) hdr
+      write(12) iwave
+      close(12)
+
+      return
+      end
+

Added: branches/wspr/wsjt.ico
===================================================================
(Binary files differ)


Property changes on: branches/wspr/wsjt.ico
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/wspr/wspr.f90
===================================================================
--- branches/wspr/wspr.f90	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/wspr.f90	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,98 @@
+program wspr
+
+#ifdef CVF
+  use dfport
+#endif
+
+  character*40 infile,outfile
+  character*12 arg
+  integer td(9)
+  real*8 f0
+  character*11 utcdate
+  character*3 month(12)
+  data month/'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'/
+
+  nargs=iargc()
+10 if(nargs.eq.0) then
+     print*,' '
+     print*,'WSPR Version 0.3 r90'
+     print*,' '
+     print*,'Usage: wspr Tx  f0 ftx nport call grid dBm [snr] [outfile | nfiles]'
+     print*,'       wspr T/R f0 ftx nport call grid dBm pctx'
+     print*,'       wspr Rx  f0 [infile ...]'
+     print*,' '
+     print*,'       f0 is the transceiver dial frequency (MHz)'
+     print*,'       ftx is the signal frequency (MHz)'
+     print*,'       nport is the COM port number for PTT control'
+     print*,'       snr is the S/N in 2500 Hz bandwidth (for test files)'
+     print*,'       pctx is the percentage of 2-minute periods to Tx'
+     print*,' '
+     print*,'Examples:'
+     print*,'       wspr Tx  10.1386 10.140100 1 K1JT FN20 30'
+     print*,'       wspr Tx  10.1386 10.140100 0 K1JT FN20 30 -22 test.wav'
+     print*,'       wspr T/R 10.1386 10.140100 0 K1JT FN20 30 25'
+     print*,'       wspr Rx  10.1386'
+     print*,'       wspr Rx  10.1386 00001.wav 00002.wav 00003.wav'
+     print*,' '
+     print*,'For more information see:'
+     print*,'       physics.princeton.edu/pulsar/K1JT/MEPT_Instructions.TXT'
+     go to 999
+  endif
+
+  ntr=0
+  nsec0=999999
+  call getarg(1,arg)
+  if(arg(1:2).eq.'TX'.or. arg(1:2).eq.'Tx' .or. arg(1:2).eq.'tx') then
+! Transmit only
+     if(nargs.lt.7) then
+        nargs=0
+        go to 10
+     endif
+     call mept_tx(nargs,ntr)
+  else if(arg(1:2).eq.'RX'.or. arg(1:2).eq.'Rx' .or. arg(1:2).eq.'rx') then
+! Receive only
+     call mept_rx(nargs,ntr)
+  else if(arg(1:3).eq.'T/R'.or. arg(1:3).eq.'t/r') then
+! Transmit and receive, choosing sequences randomly
+     if(nargs.ne.8) then
+        nargs=0
+        go to 10
+     endif
+     call random_seed
+     ntr=1
+     call getarg(2,arg)
+     read(arg,*) f0
+     call getarg(8,arg)
+     read(arg,*) pctx
+     pctx=min(max(pctx,0.0),100.0)
+20   nsec=time()
+!### Use DATE_AND_TIME !!! ###
+!     call gmtime(nsec,td)
+!     write(utcdate,1001) td(4),month(1+td(5)),td(6)+1900
+!1001 format(i2,'-',a3,'-',i4)
+     nsec=mod(nsec,86400)
+     if(nsec.lt.nsec0) then
+        write(*,1028) utcdate,f0+1400.d-6,f0+1600.d-6
+        write(13,1028) utcdate,f0+1400.d-6,f0+1600.d-6
+1028    format(/' UTC Date: ',a11,'    Search range:',f11.6,' to',f11.6,' MHz'// &amp;
+             ' UTC Sync dB    DT     Freq    Message                  Noise'/    &amp;
+             '-------------------------------------------------------------')
+     endif
+     nsec0=nsec
+
+     call random_number(x)
+     if(pctx.eq.49.5) print*,pctx,100.0*x
+     if(100.0*x.lt.pctx) then
+        call mept_tx(nargs,ntr)
+     else
+        call mept_rx(nargs,ntr)
+     endif
+     call pa_sleep(100)
+     go to 20
+  else
+! Illegal set of command parameters
+     nargs=0
+     go to 10
+endif
+
+999 end program wspr

Added: branches/wspr/wspr.py
===================================================================
--- branches/wspr/wspr.py	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/wspr.py	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,608 @@
+#------------------------------------------------------------------------ WSPR
+# $Date: 2008-03-17 08:29:04 -0400 (Mon, 17 Mar 2008) $ $Revision: 638 $
+#
+from Tkinter import *
+from tkFileDialog import *
+import g,Pmw
+from tkMessageBox import showwarning
+import os,time,sys
+import pyaudio
+from math import log10
+from numpy.oldnumeric import zeros
+import dircache
+import Image,ImageTk  #, ImageDraw
+from palettes import colormapblue, colormapgray0, colormapHot, \
+     colormapAFMHot, colormapgray1, colormapLinrad, Colormap2Palette
+from types import *
+import array
+import thread
+import random
+
+root = Tk()
+#Version=&quot;0.4 r&quot; + &quot;$Rev: 638 $&quot;[6:-1]
+Version=&quot;0.4&quot;
+print &quot;******************************************************************&quot;
+print &quot;WSPR Version &quot; + Version + &quot;, by K1JT&quot;
+print &quot;Revision date: &quot; + \
+      &quot;$Date: 2008-03-17 08:29:04 -0400 (Mon, 17 Mar 2008) $&quot;[7:-1]
+print &quot;Run date:   &quot; + time.asctime(time.gmtime()) + &quot; UTC&quot;
+
+#See if we are running in Windows
+g.Win32=0
+if sys.platform==&quot;win32&quot;:
+    g.Win32=1
+    try:
+        root.option_readfile('wsprrc.win')
+    except:
+        pass
+else:
+    try:
+        root.option_readfile('wsprrc')
+    except:
+        pass
+root_geom=&quot;&quot;
+
+
+#------------------------------------------------------ Global variables
+appdir=os.getcwd()
+bandmap=[]
+bandmap2=[]
+font1='Helvetica'
+g.appdir=appdir
+idsec=0
+isec0=0
+isync=1
+cmap0=&quot;Linrad&quot;
+dBm=IntVar()
+mrudir=os.getcwd()
+nsave=IntVar()
+nsec0=0
+nspeed0=IntVar()
+NX=500
+NY=120
+im=Image.new('P',(NX,NY))
+im.putpalette(Colormap2Palette(colormapLinrad),&quot;RGB&quot;)
+pim=ImageTk.PhotoImage(im)
+pctx=25
+receiving=0
+slabel=&quot;Sync   &quot;
+transmitting=0
+
+g.ndevin=IntVar()
+g.ndevout=IntVar()
+g.DevinName=StringVar()
+g.DevoutName=StringVar()
+
+#------------------------------------------------------ quit
+def quit():
+    root.destroy()
+
+#------------------------------------------------------ all_hdr
+def all_hdr():
+    lines=&quot;\n &quot; + time.asctime(time.gmtime()) + &quot; UTC\n&quot; + \
+        &quot; UTC Sync dB    DT     Freq    Message          \n&quot; + \
+        &quot;------------------------------------------------\n&quot;
+    try:
+        f=open(appdir+'/ALL_MEPT.TXT',mode='a')
+        f.writelines(lines)
+        f.close()
+    except:
+        print 'Write to ALL_MEPT.TXT failed.'
+        pass
+
+#------------------------------------------------------ openfile
+def openfile(event=NONE):
+    global mrudir,fileopened,nopen
+    nopen=1                         #Work-around for &quot;click feedthrough&quot; bug
+    try:
+        os.chdir(mrudir)
+    except:
+        pass
+    fname=askopenfilename(filetypes=[(&quot;Wave files&quot;,&quot;*.wav *.WAV&quot;)])
+    if fname:
+        mrudir=os.path.dirname(fname)
+        fileopened=os.path.basename(fname)
+    os.chdir(appdir)
+
+#------------------------------------------------------ options1
+def options1(event=NONE):
+    options.options2(root_geom[root_geom.index(&quot;+&quot;):])
+
+#------------------------------------------------------ stub
+def stub(event=NONE):
+    MsgBox(&quot;Sorry, this function is not yet implemented.&quot;)
+
+#------------------------------------------------------ MsgBox
+def MsgBox(t):
+    msg=Pmw.MessageDialog(root,buttons=('OK',),message_text=t)
+    result=msg.activate()
+    msg.focus_set()
+
+#------------------------------------------------------ msgpos
+def msgpos():
+    g=root_geom[root_geom.index(&quot;+&quot;):]
+    t=g[1:]
+    x=int(t[:t.index(&quot;+&quot;)])          # + 70
+    y=int(t[t.index(&quot;+&quot;)+1:])        # + 70
+    return &quot;+%d+%d&quot; % (x,y)    
+
+#------------------------------------------------------ about
+def about(event=NONE):
+    global Version
+    about=Toplevel(root)
+    about.geometry(msgpos())
+    if g.Win32: about.iconbitmap(&quot;wsjt.ico&quot;)
+    t=&quot;WSPR Version &quot; + Version + &quot;, by K1JT&quot;
+    Label(about,text=t,font=(font1,16)).pack(padx=20,pady=5)
+    t=&quot;&quot;&quot;
+WSPR is pronounced &quot;whisper&quot; and stands for &quot;Weak Signal
+Propagation Reporter&quot;.  The program transmits and receives
+the digital soundcard mode &quot;MEPT_JT&quot;, which stands for
+&quot;Manned Experimental Propagation Tests, by K1JT&quot;.
+
+Copyright (c) 2008 by Joseph H. Taylor, Jr., K1JT.
+&quot;&quot;&quot;
+    Label(about,text=t,justify=LEFT).pack(padx=20)
+    t=&quot;Revision date: &quot; + \
+      &quot;$Date: 2008-03-17 08:29:04 -0400 (Mon, 17 Mar 2008) $&quot;[7:-1]
+    Label(about,text=t,justify=LEFT).pack(padx=20)
+    about.focus_set()
+
+#------------------------------------------------------ incsync
+def incsync(event):
+    global isync
+    if isync&lt;10:
+        isync=isync+1
+        lsync.configure(text=slabel+str(isync))
+
+#------------------------------------------------------ decsync
+def decsync(event):
+    global isync
+    if isync&gt;-30:
+        isync=isync-1
+        lsync.configure(text=slabel+str(isync))
+
+#------------------------------------------------------ incdsec
+def incdsec(event):
+    global idsec
+    idsec=idsec+5
+    bg='red'
+    if idsec==0: bg='white'
+    ldsec.configure(text='Dsec  '+str(0.1*idsec),bg=bg)
+
+#------------------------------------------------------ decdsec
+def decdsec(event):
+    global idsec
+    idsec=idsec-5
+    bg='red'
+    if idsec==0: bg='white'
+    ldsec.configure(text='Dsec  '+str(0.1*idsec),bg=bg)
+
+#------------------------------------------------------ erase
+def erase(event=NONE):
+    text.configure(state=NORMAL)
+    text.delete('1.0',END)
+    text.configure(state=DISABLED)
+    text1.configure(state=NORMAL)
+    text1.delete('1.0',END)
+    text1.configure(state=DISABLED)
+#    graph1.delete(ALL)
+
+#-------------------------------------------------------- draw_axis
+def draw_axis():
+    xmid=10.1386 + 0.001500
+    c.delete(ALL)
+    df=12000.0/4096.0
+# Draw tick marks
+    for iy in range(0,350,20):
+        j=iy/df
+        i1=10
+        if (iy%100)==0 :
+            i1=15
+        y=8
+#        c.create_text(x,y,text=str(iy))
+        c.create_line(0,j,i1,j,fill='black')
+
+#------------------------------------------------------ delwav
+def delwav():
+    t=&quot;Are you sure you want to delete\nall *.WAV files in the RxWav directory?&quot;
+    msg=Pmw.MessageDialog(root,buttons=('Yes','No'),message_text=t)
+    msg.geometry(msgpos())
+    if g.Win32: msg.iconbitmap(&quot;wsjt.ico&quot;)
+    msg.focus_set()
+    result=msg.activate()
+    if result == 'Yes':
+# Make a list of *.wav files in RxWav
+        la=dircache.listdir(appdir+'/RxWav')
+        lb=[]
+        for i in range(len(la)):
+            j=la[i].find(&quot;.wav&quot;) + la[i].find(&quot;.WAV&quot;)
+            if j&gt;0: lb.append(la[i])
+# Now delete them all.
+        for i in range(len(lb)):
+            fname=appdir+'/RxWav/'+lb[i]
+            os.remove(fname)
+
+#------------------------------------------------------ toggleauto
+def toggleauto(event=NONE):
+    global lauto
+    lauto=1-lauto
+    if lauto==0: auto.configure(bg='gray85',relief=RAISED)
+    if lauto==1:
+        auto.configure(bg='green',relief=SOLID)
+
+#------------------------------------------------------ start_rx
+def start_rx(f0,nsec):
+    global receiving,transmitting,bandmap,bandmap2
+    cmd=&quot;wspr_rx.exe&quot;
+    args=str(f0) + &quot; &quot; + str(nsec)
+    receiving=1
+    try:
+        os.spawnv(os.P_WAIT,cmd,(cmd,) + (args,))
+    except:
+        print cmd + ' ' + args + ' failed.'
+    receiving=0
+
+# Get lines from decoded.txt
+    try:
+        f=open(appdir+'/decoded.txt',mode='r')
+        lines=f.readlines()
+        f.close()
+    except:
+        lines=&quot;&quot;
+#  Write data to text box and insert freqs and calls into bandmap.
+    text.configure(state=NORMAL)
+    nseq=0
+    for i in range(len(lines)):
+        text.insert(END,lines[i][:46]+&quot;\n&quot;)
+        callsign=lines[i][31:38]
+        if callsign[:1] != ' ':
+            i1=callsign.find(' ')
+            callsign=callsign[:i1]
+            nseq=int(lines[i][55:64])
+            ndf=int(lines[i][64:68])
+            bandmap.append((ndf,callsign,nseq))
+    text.configure(state=DISABLED)
+    text.see(END)
+
+#  Remove information that's too old from bandmap.
+    iz=len(bandmap)
+    for i in range(iz-1,0,-1):
+        if (nseq - bandmap[i][2]) &gt; 15:           # 15 sequences = 30 minutes
+            bandmap=bandmap[i+1:]
+            break
+    
+#  Sort bandmap in reverse frequency order
+    bandmap2=bandmap
+    bandmap2.sort()
+    bandmap2.reverse()
+    iz=len(bandmap2)
+    call0=&quot;&quot;
+    text1.configure(state=NORMAL)
+    text1.delete('1.0',END)
+    for i in range(iz):
+#        print i,bandmap2[i][0],bandmap2[i][1],call0
+        if i==0:
+            t=&quot;%4d&quot; % (bandmap2[i][0],) + &quot; &quot; + bandmap2[i][1]
+            text1.insert(END,t+&quot;\n&quot;)
+        else:
+            if bandmap2[i][1]!=call0:
+                t=&quot;%4d&quot; % (bandmap2[i][0],) + &quot; &quot; + bandmap2[i][1]
+                text1.insert(END,t+&quot;\n&quot;)
+        call0=bandmap2[i][1]
+    text1.configure(state=DISABLED)
+    text1.see(END)
+
+#------------------------------------------------------ start_tx
+def start_tx(mycall,mygrid,ndbm,ntxdf):
+    global receiving,transmitting
+    cmd=&quot;wspr_tx.exe&quot;
+    args=mycall + &quot; &quot; + mygrid + &quot; &quot; + str(ndbm) + &quot; 5 &quot; + str(ntxdf)
+    transmitting=1
+    try:
+        os.spawnv(os.P_WAIT,cmd,(cmd,) + (args,))
+    except:
+        print cmd + ' ' + args + ' failed.'
+    transmitting=0
+
+#------------------------------------------------------ update
+def update():
+    global root_geom,isec0,im,pim,cmap0,lauto,nsec0,pctx, \
+        receiving,transmitting
+    tsec=time.time()
+    nsec=int(tsec)
+    if nsec&lt;nsec0:
+        all_hdr()
+    nsec0=nsec
+    ns120=nsec%120
+    if ns120==0 and (not transmitting) and (not receiving):
+        x=random.uniform(0.,100.)
+        if x&lt;pctx and lauto:
+            ntxdf=int(1.e6*(ftx.get()-f0.get()))-1500
+            thread.start_new_thread(start_tx,
+                (MyCall.get(),MyGrid.get(),dBm.get(),ntxdf))
+        else:
+            thread.start_new_thread(start_rx,
+                (f0.get(),nsec))
+
+    utc=time.gmtime(tsec+0.1*idsec)
+    isec=utc[5]
+    if isec != isec0:                           #Do once per second
+        isec0=isec
+        t=time.strftime('%Y %b %d\n%H:%M:%S',utc)
+        ldate.configure(text=t)
+        root_geom=root.geometry()
+        utchours=utc[3]+utc[4]/60.0 + utc[5]/3600.0
+    pctx=sc1.get()
+
+    bgcolor='gray85'
+    t=''
+    if transmitting:
+        t='Txing: '+MyCall.get().strip() + ' ' + MyGrid.get().strip() + \
+           ' ' + str(dBm.get())
+        bgcolor='yellow'
+    if receiving:
+        bgcolor='green'
+        t='Receiving'
+    msg6.configure(text=t,bg=bgcolor)
+    
+    ldate.after(100,update)
+    
+#------------------------------------------------------ Top level frame
+frame = Frame(root)
+
+#------------------------------------------------------ Menu Bar
+mbar = Frame(frame)
+mbar.pack(fill = X)
+
+#------------------------------------------------------ File Menu
+filebutton = Menubutton(mbar, text = 'File')
+filebutton.pack(side = LEFT)
+filemenu = Menu(filebutton, tearoff=0)
+filebutton['menu'] = filemenu
+filemenu.add('command', label = 'Open', command = openfile, \
+             accelerator='Ctrl+O')
+filemenu.add_separator()
+filemenu.add('command', label = 'Delete all *.WAV files in RxWav', \
+             command = delwav)
+filemenu.add_separator()
+filemenu.add('command', label = 'Erase ALL.TXT', command = stub)
+filemenu.add_separator()
+filemenu.add('command', label = 'Exit', command = quit)
+
+#------------------------------------------------------ Setup menu
+setupbutton = Menubutton(mbar, text = 'Setup')
+setupbutton.pack(side = LEFT)
+setupmenu = Menu(setupbutton, tearoff=0)
+setupbutton['menu'] = setupmenu
+setupmenu.add('command', label = 'Options', command = options1)
+
+#------------------------------------------------------  Help menu
+helpbutton = Menubutton(mbar, text = 'Help')
+helpbutton.pack(side = LEFT)
+helpmenu = Menu(helpbutton, tearoff=0)
+helpbutton['menu'] = helpmenu
+helpmenu.add('command', label = 'About WSPR', command = about)
+
+#------------------------------------------------- Speed selection buttons
+for i in (5, 4, 3, 2, 1):
+    t=str(i)
+    Radiobutton(mbar,text=t,value=i,variable=nspeed0).pack(side=RIGHT)
+nspeed0.set(2)
+lab1=Label(mbar,text='Speed: ',bd=0)
+lab1.pack(side=RIGHT)
+
+#------------------------------------------------------ Graphics area
+iframe1 = Frame(frame, bd=1, relief=SUNKEN)
+graph1=Canvas(iframe1, bg='black', width=NX, height=NY,cursor='crosshair')
+graph1.pack(side=LEFT)
+c=Canvas(iframe1, bg='white', width=50, height=NY,bd=0)
+c.pack(side=LEFT)
+
+#-------------------------------------------------------- Band map
+text1=Text(iframe1, height=8, width=12)
+text1.pack(side=LEFT, padx=1)
+text1.insert(END,'132 ZL1BPU')
+sb = Scrollbar(iframe1, orient=VERTICAL, command=text1.yview)
+sb.pack(side=RIGHT, fill=Y)
+text1.configure(yscrollcommand=sb.set)
+iframe1.pack(expand=1, fill=X, padx=4)
+
+#------------------------------------------------------ Labels under graphics
+iframe2a = Frame(frame, bd=1, relief=FLAT, height=10)
+g1=Pmw.Group(iframe2a,tag_text=&quot;Frequency setup&quot;)
+f0=DoubleVar()
+ftx=DoubleVar()
+lf0=Pmw.EntryField(g1.interior(),labelpos=W,label_text='Carrier freq:',
+        value=10.1386,entry_textvariable=f0,entry_width=12)
+lftx=Pmw.EntryField(g1.interior(),labelpos=W,label_text='Tx freq:',
+        value=10.140150,entry_textvariable=ftx,entry_width=12)
+widgets = (lf0, lftx)
+for widget in widgets:
+    widget.pack(side=LEFT,padx=5,pady=2)
+f1=Frame(g1.interior())
+f1.pack()
+g1.pack(side=LEFT,fill=BOTH,expand=1,padx=6,pady=6)
+
+#------------------------------------------------------ Tx params and msgs
+g2=Pmw.Group(iframe2a,tag_text=&quot;Tx message&quot;)
+MyCall=StringVar()
+MyGrid=StringVar()
+lcall=Pmw.EntryField(g2.interior(),labelpos=W,label_text='MyCall:',
+        value='K1JT',entry_textvariable=MyCall,entry_width=8)
+lgrid=Pmw.EntryField(g2.interior(),labelpos=W,label_text='MyGrid:',
+        value='FN20',entry_textvariable=MyGrid,entry_width=5)
+ldBm=Pmw.EntryField(g2.interior(),labelpos=W,label_text='Power (dBm):',
+        value=30,entry_textvariable=dBm,entry_width=4)
+widgets = (lcall, lgrid, ldBm)
+for widget in widgets:
+    widget.pack(side=LEFT,padx=5,pady=2)
+f2=Frame(g1.interior())
+f2.pack()
+g2.pack(side=LEFT,fill=BOTH,expand=1,padx=6,pady=6)
+
+iframe2a.pack(expand=1, fill=X, padx=1)
+iframe2 = Frame(frame, bd=1, relief=FLAT,height=15)
+lab2=Label(iframe2, text='UTC      Sync   dB        DT           Freq')
+lab2.place(x=3,y=6, anchor='w')
+iframe2.pack(expand=1, fill=X, padx=4)
+
+#-------------------------------------------------------- Decoded text
+iframe4 = Frame(frame, bd=1, relief=SUNKEN)
+text=Text(iframe4, height=10, width=80)
+text.pack(side=LEFT, fill=X, padx=1)
+text.insert(END,'1054   4 -25   1.1  10.140140  K1JT FN20 25')
+sb = Scrollbar(iframe4, orient=VERTICAL, command=text.yview)
+sb.pack(side=RIGHT, fill=Y)
+text.configure(yscrollcommand=sb.set)
+iframe4.pack(expand=1, fill=X, padx=4)
+
+#-----------------------------------------------------General control area
+iframe5 = Frame(frame, bd=1, relief=FLAT,height=180)
+f5a=Frame(iframe5,height=170,bd=2,relief=FLAT)
+
+#------------------------------------------------------ Date and Time
+ldate=Label(f5a, bg='black', fg='yellow', width=11, bd=4,
+        text='2005 Apr 22\n01:23:45', relief=RIDGE,
+        justify=CENTER, font=(font1,16))
+ldate.pack(side=LEFT,padx=2,pady=2)
+ldsec=Label(f5a, bg='white', fg='black', text='Dsec  0.0', width=8, relief=RIDGE)
+ldsec.pack(side=LEFT,ipadx=3,padx=2,pady=5)
+Widget.bind(ldsec,'&lt;Button-1&gt;',incdsec)
+Widget.bind(ldsec,'&lt;Button-3&gt;',decdsec)
+f5a.pack(side=LEFT,expand=0,fill=Y)
+
+#------------------------------------------------------ Receiving parameters
+f5b=Frame(iframe5,bd=2,relief=FLAT)
+lsync=Label(f5b, bg='white', fg='black', text='Sync   1', width=8, relief=RIDGE)
+lsync.grid(column=0,row=0,padx=2,pady=1,sticky='EW')
+Widget.bind(lsync,'&lt;Button-1&gt;',incsync)
+Widget.bind(lsync,'&lt;Button-3&gt;',decsync)
+f5b.pack(side=LEFT,expand=0,fill=BOTH,padx=40)
+lab3=Label(iframe5,text='Rx',bd=0)
+lab3.pack(side=LEFT,padx=8)
+sc1=Scale(iframe5,from_=0,to_=100,orient='horizontal',
+          label='          % Transmitting',showvalue=1,sliderlength=5,
+          length=150,resolution=5,tickinterval=20.0)
+sc1.pack(side=LEFT)
+lab4=Label(iframe5,text='Tx',bd=0)
+lab4.pack(side=LEFT,padx=8)
+
+#------------------------------------------------------- Button Bar
+f5c = Frame(iframe5, bd=2, relief=SUNKEN)
+berase=Button(f5c, text='Erase',underline=0,command=erase,
+                padx=1,pady=1)
+auto=Button(f5c,text='Enable Tx',underline=0,command=toggleauto,
+            padx=1,pady=1)
+berase.pack(side=TOP,expand=1,fill=BOTH)
+auto.pack(side=TOP,expand=1,fill=BOTH)
+f5c.pack(expand=1, fill=X, padx=4,pady=4)
+
+iframe5.pack(expand=1, fill=X, padx=4)
+
+#------------------------------------------------------------ Status Bar
+iframe6 = Frame(frame, bd=1, relief=SUNKEN)
+msg1=Message(iframe6, text='      ', width=300,relief=SUNKEN)
+msg1.pack(side=LEFT, fill=X, padx=1)
+msg2=Message(iframe6, text='      ', width=300,relief=SUNKEN)
+msg2.pack(side=LEFT, fill=X, padx=1)
+msg3=Message(iframe6, text='      ',width=300,relief=SUNKEN)
+msg3.pack(side=LEFT, fill=X, padx=1)
+msg4=Message(iframe6, text='      ', width=300,relief=SUNKEN)
+msg4.pack(side=LEFT, fill=X, padx=1)
+msg5=Message(iframe6, text='      ', width=300,relief=SUNKEN)
+msg5.pack(side=LEFT, fill=X, padx=1)
+msg6=Message(iframe6, text='      ', width=400,relief=SUNKEN)
+msg6.pack(side=RIGHT, fill=X, padx=1)
+iframe6.pack(expand=1, fill=X, padx=4)
+frame.pack()
+
+ldate.after(100,update)
+
+lauto=0
+isync=1
+import options
+
+#---------------------------------------------------------- Process INI file
+try:
+    f=open(appdir+'/WSPR.INI',mode='r')
+    params=f.readlines()
+except:
+    params=&quot;&quot;
+    if g.Win32:
+        options.PttPort.set(&quot;0&quot;)
+        pass
+    else:
+        options.PttPort.set(&quot;/dev/ttyS0&quot;)
+        pass
+
+try:
+    for i in range(len(params)):
+        key,value=params[i].split()
+        if   key == 'WSPRGeometry': root.geometry(value)
+        elif key == 'MyCall': MyCall.set(value)
+        elif key == 'MyGrid': MyGrid.set(value)
+        elif key == 'dBm': dBm.set(value)
+        elif key == 'PctTx': sc1.set(value)
+        elif key == 'IDinterval': options.IDinterval.set(value)
+        elif key == 'PttPort':
+            try:
+                options.PttPort.set(value)
+            except:
+                if g.Win32:
+                    options.PttPort.set(&quot;0&quot;)
+                else:
+                    options.PttPort.set(&quot;/dev/ttyS0&quot;)
+                pass
+            pass
+        elif key == 'AudioIn':
+            try:
+                g.ndevin.set(value)
+            except:
+                g.ndevin.set(0)
+            g.DevinName.set(value)
+            options.DevinName.set(value)
+        elif key == 'AudioOut':
+            try:
+                g.ndevout.set(value)
+            except:
+                g.ndevout.set(0)
+            g.DevoutName.set(value)
+            options.DevoutName.set(value)
+        elif key == 'Nsave': nsave.set(value)
+        elif key == 'Sync': isync=int(value)
+        elif key == 'Debug': ndebug.set(value)
+        elif key == 'MRUDir': mrudir=value.replace(&quot;#&quot;,&quot; &quot;)
+except:
+    print 'Error reading WSPR.INI, continuing with defaults.'
+    print key,value
+
+lsync.configure(text=slabel+str(isync))
+draw_axis()
+erase()
+if g.Win32: root.iconbitmap(&quot;wsjt.ico&quot;)
+root.title('  WSPR      by K1JT')
+all_hdr()
+graph1.focus_set()
+root.mainloop()
+
+# Clean up and save user options before terminating
+f=open(appdir+'/WSPR.INI',mode='w')
+root_geom=root_geom[root_geom.index(&quot;+&quot;):]
+f.write(&quot;WSPRGeometry &quot; + root_geom + &quot;\n&quot;)
+f.write(&quot;MyCall &quot; + MyCall.get() + &quot;\n&quot;)
+f.write(&quot;MyGrid &quot; + MyGrid.get() + &quot;\n&quot;)
+f.write(&quot;dBm &quot; + str(dBm.get()) + &quot;\n&quot;)
+f.write(&quot;IDinterval &quot; + str(options.IDinterval.get()) + &quot;\n&quot;)
+f.write(&quot;PttPort &quot; + str(options.PttPort.get()) + &quot;\n&quot;)
+f.write(&quot;AudioIn &quot; + options.DevinName.get() + &quot;\n&quot;)
+f.write(&quot;AudioOut &quot; + options.DevoutName.get() + &quot;\n&quot;)
+f.write(&quot;Nsave &quot; + str(nsave.get()) + &quot;\n&quot;)
+f.write(&quot;PctTx &quot; + str(pctx) + &quot;\n&quot;)
+f.write(&quot;Sync &quot; + str(isync) + &quot;\n&quot;)
+mrudir2=mrudir.replace(&quot; &quot;,&quot;#&quot;)
+f.write(&quot;MRUDir &quot; + mrudir2 + &quot;\n&quot;)
+f.close()
+
+#Terminate audio streams
+#time.sleep(0.5)

Added: branches/wspr/wspr_rx.f90
===================================================================
--- branches/wspr/wspr_rx.f90	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/wspr_rx.f90	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,125 @@
+program wspr_rx
+
+!  Receive and decode MEPT_JT signals for one 2-minute sequence.
+
+#ifdef CVF
+  use dfport
+#endif
+
+  character*12 callsign
+  character*4 grid
+  parameter (NMAX=120*12000)                          !Max length of waveform
+  integer*2 iwave(NMAX)                               !Generated waveform
+  integer time
+  parameter (MAXSYM=176)
+  integer*1 symbol(MAXSYM)
+  integer*1 data1(11),i1
+  integer mettab(0:255,0:1)                           !Metric table
+  integer npr3(162)
+  integer getsound
+  real pr3(162)
+  real*8 f0
+  character*12 arg
+  character*6 cfile6
+  character*70 outfile
+  equivalence(i1,i4)
+  data npr3/                                          &amp;
+      1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,        &amp;
+      0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,        &amp;
+      0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,        &amp;
+      1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,        &amp;
+      0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,        &amp;
+      0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,        &amp;
+      0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,        &amp;
+      0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,        &amp;
+      0,0/
+
+  data mettab/                                             &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   4,   &amp;
+         4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   &amp;
+         4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   &amp;
+         3,   3,   3,   3,   3,   3,   3,   3,   3,   2,   &amp;
+         2,   2,   2,   2,   1,   1,   1,   1,   0,   0,   &amp;
+        -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,   &amp;
+        -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,   &amp;
+       -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,   &amp;
+       -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,   &amp;
+       -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,   &amp;
+       -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,   &amp;
+       -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,   &amp;
+       -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,   &amp;
+       -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,   &amp;
+       -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,   &amp;
+       -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,   &amp;
+       -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,   &amp;
+       -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,   &amp;
+       -84, -87, -86, -87, -88,-105, -94,-105, -88, -87,   &amp;
+       -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,   &amp;
+       -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,   &amp;
+       -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,   &amp;
+       -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,   &amp;
+       -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,   &amp;
+       -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,   &amp;
+       -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,   &amp;
+       -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,   &amp;
+       -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,   &amp;
+       -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,   &amp;
+       -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,   &amp;
+       -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,   &amp;
+        -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,   &amp;
+        -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,   &amp;
+         2,   2,   2,   2,   3,   3,   3,   3,   3,   3,   &amp;
+         3,   3,   3,   4,   4,   4,   4,   4,   4,   4,   &amp;
+         4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   &amp;
+         4,   4,   4,   4,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   &amp;
+         5,   5/
+  save
+
+  nargs=iargc()
+  if(nargs.ne.2) then
+     print*,'Usage: wspr_rx f0 nsec'
+     go to 999
+  endif
+
+  call getarg(1,arg)
+  read(arg,*) f0
+  call getarg(2,arg)
+  read(arg,*) nsec
+  nsym=162                  !Symbols per transmission
+  do i=1,nsym
+     pr3(i)=2*npr3(i)-1
+  enddo
+  isec=mod(nsec,86400)
+  ih=isec/3600
+  im=(isec-ih*3600)/60
+  is=mod(isec,60)
+  write(cfile6,1030) ih,im,is
+1030 format(3i2.2)
+
+  open(13,file='ALL_MEPT.TXT',status='unknown',access='append')
+  open(14,file='decoded.txt',status='unknown')
+
+  ierr=getsound(iwave)
+  npts=114*12000
+  call getrms(iwave,npts,ave,rms)
+  outfile='save/'//cfile6(1:4)//'.wav'
+  call wfile5(iwave,npts,12000,outfile)
+  call mept162(cfile6,f0,iwave,NMAX,rms,nsec)
+
+999 continue
+end program wspr_rx
+

Added: branches/wspr/wspr_tx.f90
===================================================================
--- branches/wspr/wspr_tx.f90	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/wspr_tx.f90	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,44 @@
+program wspr_tx
+
+!  Generate one transmission in the MEPT_JT mode.
+
+#ifdef CVF
+  use dfport
+#endif
+
+  parameter (NMAX=120*12000)
+  real*8 f0,ftx
+  character*12 arg
+  character*12 call1
+  character*4 grid
+  character*3 cdbm
+  character*22 message
+  integer*2 iwave(NMAX)
+  integer playsound,ptt
+
+  nargs=iargc()
+  if(nargs.ne.5) then
+     print*,'Usage: wspr_tx call grid dBm nport ntxdf'
+     go to 999
+  endif
+
+  call getarg(1,call1)
+  call getarg(2,grid)
+  call getarg(3,arg)
+  read(arg,*) ndbm
+  call getarg(4,arg)
+  read(arg,*) nport
+  call getarg(5,arg)
+  read(arg,*) ntxdf
+
+  write(cdbm,'(i3)'),ndbm
+  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+  if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+  message=call1(1:i1)//grid//' '//cdbm
+  call genmept(call1,grid,ndbm,ntxdf,99.0,iwave)
+  if(nport.gt.0) ierr=ptt(nport,junk,1,iptt)
+  ierr=playsound(iwave)
+  if(nport.gt.0) ierr=ptt(nport,junk,0,iptt)
+
+999 continue
+end program wspr_tx

Added: branches/wspr/wsprrc.win
===================================================================
--- branches/wspr/wsprrc.win	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/wsprrc.win	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,9 @@
+*font:			Arial 8
+*Label*font:		Arial 8
+*Text*font:		&quot;Courier New&quot; 9
+*Canvas*font:           &quot;Lucida Console&quot; 16
+*background:		gray85
+*Text*background:	white
+*Entry*background:	white
+*foreground:		black
+*Listbox*foreground:	RoyalBlue

Added: branches/wspr/xcor162.f
===================================================================
--- branches/wspr/xcor162.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/xcor162.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,67 @@
+      subroutine xcor162(s2,ipk,nsteps,nsym,lag1,lag2,ccf,ccf0,lagpk)
+
+C  Computes ccf of a row of s2 and the pseudo-random array pr3.  Returns
+C  peak of the CCF and the lag at which peak occurs.  
+
+      parameter (NFFT=512)             !Length of FFTs
+      parameter (NH=NFFT/2)            !Length of power spectra
+      parameter (NSMAX=352)            !Number of half-symbol steps
+      real psavg(-NH:NH)               !Average spectrum of whole record
+      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
+      real a(NSMAX)
+      real ccf(-5:540)
+      logical first
+      data first/.true./
+      integer npr3(162)
+      real pr3(162)
+      data npr3/
+     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     + 0,0/
+      save
+
+      if(first) then
+         nsym=162
+         do i=1,nsym
+            pr3(i)=2*npr3(i)-1
+         enddo
+         first=.false.
+      endif
+
+      df=375.0/NFFT
+      n=2
+      method=2
+      do j=1,nsteps
+        if(method.eq.1) then
+           a(j)=0.5*(s2(ipk+n,j) + s2(ipk+3*n,j) - 
+     +       s2(ipk  ,j) - s2(ipk+2*n,j))
+        else
+           a(j)=max(s2(ipk+n,j),s2(ipk+3*n,j)) - 
+     +          max(s2(ipk  ,j),s2(ipk+2*n,j))
+        endif
+      enddo
+
+      ccfmax=0.
+      do lag=lag1,lag2
+         x=0.
+         do i=1,nsym
+            j=2*i-1+lag
+            if(j.ge.1 .and. j.le.nsteps) x=x+a(j)*pr3(i)
+         enddo
+         ccf(lag)=2*x                        !The 2 is for plotting scale
+         if(ccf(lag).gt.ccfmax) then
+            ccfmax=ccf(lag)
+            lagpk=lag
+         endif
+      enddo
+
+      ccf0=ccfmax
+
+      return
+      end

Added: branches/wspr/xfft.f
===================================================================
--- branches/wspr/xfft.f	2008-03-18 12:13:45 UTC (rev 639)
+++ branches/wspr/xfft.f	2008-03-20 12:27:22 UTC (rev 640)
@@ -0,0 +1,12 @@
+      subroutine xfft(x,nfft)
+
+C  Real-to-complex FFT.
+
+      real x(nfft)
+
+!      call four2(x,nfft,1,-1,0)
+      call four2a(x,nfft,1,-1,0)
+
+      return
+      end
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000326.html">[WSJT-SVN] r639 - trunk
</A></li>
	<LI>Next message: <A HREF="000327.html">[WSJT-SVN] r641 - branches/wspr/save
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#328">[ date ]</a>
              <a href="thread.html#328">[ thread ]</a>
              <a href="subject.html#328">[ subject ]</a>
              <a href="author.html#328">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
