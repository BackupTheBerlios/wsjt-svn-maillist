<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r664 - branches/wspr
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r664%20-%20branches/wspr&In-Reply-To=%3C200803221908.m2MJ8B2A008952%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000350.html">
   <LINK REL="Next"  HREF="000351.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r664 - branches/wspr</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r664%20-%20branches/wspr&In-Reply-To=%3C200803221908.m2MJ8B2A008952%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r664 - branches/wspr">k1jt at mail.berlios.de
       </A><BR>
    <I>Sat Mar 22 20:08:11 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000350.html">[WSJT-SVN] r663 - branches/wspr
</A></li>
        <LI>Next message: <A HREF="000351.html">[WSJT-SVN] r665 - branches/wspr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#352">[ date ]</a>
              <a href="thread.html#352">[ thread ]</a>
              <a href="subject.html#352">[ subject ]</a>
              <a href="author.html#352">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2008-03-22 20:07:47 +0100 (Sat, 22 Mar 2008)
New Revision: 664

Modified:
   branches/wspr/Makefile
   branches/wspr/WSPR_Announcement.TXT
   branches/wspr/WSPR_Instructions.TXT
   branches/wspr/conv232.f
   branches/wspr/db.f
   branches/wspr/decode162.f
   branches/wspr/deg2grid.f
   branches/wspr/encode232.f
   branches/wspr/fano232.f
   branches/wspr/flat3.f
   branches/wspr/four1.f
   branches/wspr/four2.f
   branches/wspr/genmept.f
   branches/wspr/getrms.f
   branches/wspr/getsound.c
   branches/wspr/gran.f90
   branches/wspr/grid2deg.f
   branches/wspr/inter_mept.f
   branches/wspr/mept162.f
   branches/wspr/mept_jt.f90
   branches/wspr/mept_rx.f90
   branches/wspr/mept_tx.f90
   branches/wspr/mix162.f
   branches/wspr/nchar.f
   branches/wspr/pack50.f
   branches/wspr/packcall.f
   branches/wspr/packgrid.f
   branches/wspr/packmept.f
   branches/wspr/pctile.f
   branches/wspr/peakup.f
   branches/wspr/playsound.c
   branches/wspr/ps162.f
   branches/wspr/ptt.c
   branches/wspr/set.f
   branches/wspr/slope.f
   branches/wspr/sort.f
   branches/wspr/spec162.f
   branches/wspr/ssort.f
   branches/wspr/sync162.f
   branches/wspr/unpack50.f
   branches/wspr/unpackcall.f
   branches/wspr/unpackgrid.f
   branches/wspr/unpackmept.f
   branches/wspr/wfile5.f
   branches/wspr/wspr.f90
   branches/wspr/wspr.py
   branches/wspr/wspr_rx.f90
   branches/wspr/wspr_tx.f90
   branches/wspr/xcor162.f
   branches/wspr/xfft.f
Log:
Set file properties: copyright, eol-style, keywords &quot;Date&quot; and &quot;Rev&quot;.


Modified: branches/wspr/Makefile
===================================================================
--- branches/wspr/Makefile	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/Makefile	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,56 +1,48 @@
-#Makefile for Windows and MinGW
-CC = gcc
-FC = g95
+#Makefile for Windows
+!include &lt;dfinc.mak&gt;   #Some definitions for Compaq Visual Fortran
+CC = cl
+FC = df
+FFLAGS = /traceback /fast /nologo /check:all /fpp /DCVF
+#FFLAGS = /traceback /fast /nologo /fpp /DCVF
+CFLAGS = /DWin32 /DCVF /I. 
 
-FFLAGS = -cpp
-CFLAGS = -I. -fbounds-check
+OBJS2 = wspr_tx.obj genmept.obj inter_mept.obj nchar.obj grid2deg.obj \
+	packcall.obj packgrid.obj pack50.obj unpack50.obj unpackcall.obj \
+	unpackgrid.obj deg2grid.obj ptt.obj set.obj gran.obj encode232.obj \
+	playsound.obj 
 
-OBJS2 = wspr_tx.o genmept.o inter_mept.o nchar.o grid2deg.o \
-	packcall.o packgrid.o pack50.o unpack50.o unpackcall.o \
-	unpackgrid.o deg2grid.o ptt.o set.o gran.o encode232.o \
-	playsound.o 
+OBJS3 = wspr_rx.obj inter_mept.obj \
+	mix162.obj xfft.obj four1.obj four2.obj sync162.obj ps162.obj \
+	mept162.obj nchar.obj grid2deg.obj unpack50.obj unpackcall.obj \
+	unpackgrid.obj deg2grid.obj getrms.obj \
+	set.obj encode232.obj fano232.obj wfile5.obj \
+	xcor162.obj slope.obj peakup.obj pctile.obj db.obj sort.obj \
+	ssort.obj decode162.obj getsound.obj spec162.obj flat3.obj
 
-OBJS3 = wspr_rx.o inter_mept.o \
-	mix162.o xfft.o four1.o four2.o sync162.o ps162.o \
-	mept162.o nchar.o grid2deg.o unpack50.o unpackcall.o \
-	unpackgrid.o deg2grid.o getrms.o \
-	set.o encode232.o fano232.o wfile5.o \
-	xcor162.o slope.o peakup.o pctile.o db.o sort.o \
-	ssort.o decode162.o getsound.o spec162.o flat3.o
+all:    WSPR.EXE wspr_tx.exe wspr_rx.exe
 
+WSPR.EXE: wspr.spec
+	c:\python25\python c:\pyinstaller-1.3\Build.py wspr.spec
 
-all:    wspr.exe wspr_tx.exe wspr_rx.exe
-
-wspr.exe: wspr.spec
-	c:/python25/python c:/python25/pyinstaller-1.3/Build.py wspr.spec
-
-wspr.spec: wspr.py g.py options.py palettes.py
-	c:/python25/python c:/python25/pyinstaller-1.3/makespec.py --icon \
-	   wsjt.ico --tk --onefile wspr.py
-
 wspr_tx.exe: $(OBJS2)
-	$(FC) -o wspr_tx.exe $(FFLAGS) $(OBJS2) libportaudio.a -lwinmm
+	$(FC) /exe:wspr_tx.exe $(FFLAGS) $(OBJS2) pa.lib
 
 wspr_rx.exe: $(OBJS3)
-	$(FC) -o wspr_rx.exe $(FFLAGS) $(OBJS3) libportaudio.a -lwinmm
+	$(FC) /exe:wspr_rx.exe $(FFLAGS) $(OBJS3) pa.lib
 
-gran.o: gran.f90
-	$(FC) -c $(FFLAGS) gran.f90
-mept_rx.o: mept_rx.f90
-	$(FC) -c $(FFLAGS) mept_rx.f90
-mept_tx.o: mept_tx.f90
-	$(FC) -c $(FFLAGS) mept_tx.f90
-wspr.o: wspr.f90
-	$(FC) -c $(FFLAGS) wspr.f90
-wspr_rx.o: wspr_rx.f90
-	$(FC) -c $(FFLAGS) wspr_rx.f90
-wspr_tx.o: wspr_tx.f90
-	$(FC) -c $(FFLAGS) wspr_tx.f90
+wspr.spec: wspr.py g.py options.py palettes.py 
+	c:\python25\python c:\pyinstaller-1.3\makespec.py --icon wsjt.ico \
+	--tk --onefile wspr.py
 
+wspr_rx.obj: wspr_rx.f90
+	$(FC) /compile_only $(FFLAGS) wspr_rx.f90
+wspr_tx.obj: wspr_tx.f90
+	$(FC) /compile_only $(FFLAGS) wspr_tx.f90
+
 .PHONY : clean
 
 clean:
-	rm *.o wspr.exe wspr_tx.exe wspr_rx.exe
+	-del *.obj wspr.exe wspr_rx.exe wspr_tx.exe
 
 
 

Modified: branches/wspr/WSPR_Announcement.TXT
===================================================================
--- branches/wspr/WSPR_Announcement.TXT	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/WSPR_Announcement.TXT	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,87 +1,87 @@
-To:      QRSS Knights and Friends
-From:    Joe Taylor, K1JT
-Subject: New software for MEPT
-Date:    March 10, 2008
-
-About two weeks ago Murray Greenman, ZL1BPU, wrote to me suggesting
-that I consider adding a mode optimized for MEPT to my software
-package WSJT.  I expressed interest in the idea, and we exchanged a
-few emails about possible specifications.  Then I sat down and wrote
-out some detailed specs, and finally got busy to write a bare-bones
-program implementing the new mode.
-
-I write now to let you know that an early release of the program is
-ready for testing.  The program's name is WSPR (pronounced &quot;whisper&quot;,
-which seems appropriate for estremely weak signals).  The name of the
-digital protocol implemented in WSPR is MEPT_JT, where the letters
-stand for &quot;Manned Experimental Propagation Tests, by K1JT&quot;.
-
-At present WSPR is a stand-alone executable, independent of WSJT.  It
-is functional for both transmitting and receiving, but it has no
-frills -- no graphics, no GUI, etc.  It is executed from a Windows
-command prompt.  Like WSJT, WSPR uses a computer sound card to
-generate audio tones to modulate an SSB transceiver operating on upper
-sideband.  In receive mode the sound card digitizes audio from the
-transceiver.  The program scans a 200 Hz passband (the &quot;QRSS window&quot;)
-looking for MEPT_JT signals, and decodes them.  Basic operating
-instructions for the initial release can be found in the file
-WSPR_Instructions.TXT at
-<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSPR_Instructions.TXT">http://physics.princeton.edu/pulsar/K1JT/WSPR_Instructions.TXT</A> , and
-the program itself can be downloaded from
-<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE">http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE</A> .
-
-
-Basic specifications of the MEPT_JT mode are as follows:
-
-1.  Transmitted message: callsign + 4-character-locator + dBm 
-    Example: &quot;K1JT FN20 30&quot;
-
-2.  Message length after lossless compression: 28 bits for callsign,
-    15 for locator, 7 for power level ==&gt; 50 bits total.
-
-3.  Forward error correction (FEC): long-constraint convolutional 
-    code, K=32, r=1/2.
-
-4.  Number of channel symbols: nsym = (50+K-1)*2 = 162.
-
-5.  Keying rate: 12000/8192 = 1.46 baud.  
-
-6.  Modulation: continuous phase 4-FSK.  Tone separation 1.46 Hz.
-
-7.  Synchronization: 162-bit pseudo-random sync vector.
-
-8.  Data structure: each channel symbol conveys one sync bit and one
-    data bit.
-
-9.  Duration of transmission: 162*8192/12000 = 110.6 s.  
-
-10. Transmissions start two seconds into an even UTC minute: i.e., at
-    hh:00:02, hh:02:02, ...
-
-10. Occupied bandwidth: about 6 Hz
-
-11. Minimum S/N for reception: around -27 dB on the WSJT scale (2500
-    Hz reference bandwidth).  
-
-You can run Argo, Spectran, or WSJT at the same time as WSPR, in
-order to provide a waterfall spectral display.
-
-In normal operation WSPR displays information every two minutes and
-is silent otherwise.  In transmit mode in prints a single line when a
-new transmission starts.  In receive mode the program looks for all
-detectable MEPT_JT signals in a 200 Hz passband, decodes them, and
-displays the results.  If nothing is decoded, nothing will be printed.
-In T/R mode the program alternates in a randomized way between
-transmit and receive sequences.
-
-Like JT65, MEPT_JT includes very efficient data compression and strong
-forward error correction.  Received messages are nearly always exactly
-the same as the transmitted message, or else they are left blank.
-
-Version 0.3 of MEPT_JT is functional -- and extremely sensitive -- but
-the user interface is rather spartan.  Suggestions for improvements
-will be most welcome!
-
-Please email all suggestions to k1jt at arrl dot net.
-
-	    -- 73, Joe, K1JT
+To:      QRSS Knights and Friends
+From:    Joe Taylor, K1JT
+Subject: New software for MEPT
+Date:    March 10, 2008
+
+About two weeks ago Murray Greenman, ZL1BPU, wrote to me suggesting
+that I consider adding a mode optimized for MEPT to my software
+package WSJT.  I expressed interest in the idea, and we exchanged a
+few emails about possible specifications.  Then I sat down and wrote
+out some detailed specs, and finally got busy to write a bare-bones
+program implementing the new mode.
+
+I write now to let you know that an early release of the program is
+ready for testing.  The program's name is WSPR (pronounced &quot;whisper&quot;,
+which seems appropriate for estremely weak signals).  The name of the
+digital protocol implemented in WSPR is MEPT_JT, where the letters
+stand for &quot;Manned Experimental Propagation Tests, by K1JT&quot;.
+
+At present WSPR is a stand-alone executable, independent of WSJT.  It
+is functional for both transmitting and receiving, but it has no
+frills -- no graphics, no GUI, etc.  It is executed from a Windows
+command prompt.  Like WSJT, WSPR uses a computer sound card to
+generate audio tones to modulate an SSB transceiver operating on upper
+sideband.  In receive mode the sound card digitizes audio from the
+transceiver.  The program scans a 200 Hz passband (the &quot;QRSS window&quot;)
+looking for MEPT_JT signals, and decodes them.  Basic operating
+instructions for the initial release can be found in the file
+WSPR_Instructions.TXT at
+<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSPR_Instructions.TXT">http://physics.princeton.edu/pulsar/K1JT/WSPR_Instructions.TXT</A> , and
+the program itself can be downloaded from
+<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE">http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE</A> .
+
+
+Basic specifications of the MEPT_JT mode are as follows:
+
+1.  Transmitted message: callsign + 4-character-locator + dBm 
+    Example: &quot;K1JT FN20 30&quot;
+
+2.  Message length after lossless compression: 28 bits for callsign,
+    15 for locator, 7 for power level ==&gt; 50 bits total.
+
+3.  Forward error correction (FEC): long-constraint convolutional 
+    code, K=32, r=1/2.
+
+4.  Number of channel symbols: nsym = (50+K-1)*2 = 162.
+
+5.  Keying rate: 12000/8192 = 1.46 baud.  
+
+6.  Modulation: continuous phase 4-FSK.  Tone separation 1.46 Hz.
+
+7.  Synchronization: 162-bit pseudo-random sync vector.
+
+8.  Data structure: each channel symbol conveys one sync bit and one
+    data bit.
+
+9.  Duration of transmission: 162*8192/12000 = 110.6 s.  
+
+10. Transmissions start two seconds into an even UTC minute: i.e., at
+    hh:00:02, hh:02:02, ...
+
+10. Occupied bandwidth: about 6 Hz
+
+11. Minimum S/N for reception: around -27 dB on the WSJT scale (2500
+    Hz reference bandwidth).  
+
+You can run Argo, Spectran, or WSJT at the same time as WSPR, in
+order to provide a waterfall spectral display.
+
+In normal operation WSPR displays information every two minutes and
+is silent otherwise.  In transmit mode in prints a single line when a
+new transmission starts.  In receive mode the program looks for all
+detectable MEPT_JT signals in a 200 Hz passband, decodes them, and
+displays the results.  If nothing is decoded, nothing will be printed.
+In T/R mode the program alternates in a randomized way between
+transmit and receive sequences.
+
+Like JT65, MEPT_JT includes very efficient data compression and strong
+forward error correction.  Received messages are nearly always exactly
+the same as the transmitted message, or else they are left blank.
+
+Version 0.3 of MEPT_JT is functional -- and extremely sensitive -- but
+the user interface is rather spartan.  Suggestions for improvements
+will be most welcome!
+
+Please email all suggestions to k1jt at arrl dot net.
+
+	    -- 73, Joe, K1JT


Property changes on: branches/wspr/WSPR_Announcement.TXT
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/wspr/WSPR_Instructions.TXT
===================================================================
--- branches/wspr/WSPR_Instructions.TXT	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/WSPR_Instructions.TXT	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,380 +1,380 @@
-                        Instructions for WSPR
-                        ---------------------
-
-WSPR is the name of a computer program.  It is pronounced &quot;whisper&quot;,
-and stands for &quot;Weak Signal Propagation Reporter&quot;; it implements
-transmitting and receiving functions for a digital soundcard mode
-called &quot;MEPT_JT&quot;, which stands for &quot;Manned Experimental Propagation
-Tests, by K1JT&quot;.
-
-WSPR generates and receives signals using structured messages, strong
-forward error correction, and narrow-band 4-FSK modulation.  Its
-principal design goal is reliable copy at very low signal levels.  In
-practice it works well at signal-to-noise ratios down to -27 dB in a
-reference bandwidth of 2500 Hz.  The present program, version 0.3, has
-no frills, no graphics and no GUI.  It is executed from the command
-line.
-
-QUICK START
------------
-
-Download WSPR from the URL
-<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE">http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE</A> and copy the
-executable file into a suitable directory such as C:\wspr.  WSPR is
-invoked by typing its name followed by zero or more arguments.  Open a
-command-prompt window, CD into to that directory, and type &quot;wspr&quot;
-(with no accompanying arguments) to see the following summary and
-examples of program usage:
-
------------------------------------------------------------------------
-C:\WPSR&gt; wspr
-
- WSPR Version 0.3 r90
-
- Usage: wspr Tx  f0 ftx nport call grid dBm [snr] [outfile | nfiles]
-        wspr T/R f0 ftx nport call grid dBm pctx
-        wspr Rx  f0 [infile ...]
-
-        f0 is the transceiver dial frequency (MHz)
-        ftx is the signal frequency (MHz)
-        nport is the COM port number for PTT control
-        snr is the S/N in 2500 Hz bandwidth (for test files)
-        pctx is the percentage of 2-minute periods to Tx
-
- Examples:
-        wspr Tx  10.1386 10.140100 1 K1JT FN20 30
-        wspr Tx  10.1386 10.140100 0 K1JT FN20 30 -22 test.wav
-        wspr T/R 10.1386 10.140100 0 K1JT FN20 30 25
-        wspr Rx  10.1386
-        wspr Rx  10.1386 00001.wav 00002.wav 00003.wav
-
- For more information see:
-        physics.princeton.edu/pulsar/K1JT/WSPR_Instructions.TXT
------------------------------------------------------------------------
-
-In transmit mode there can be up to 9 command-line arguments after the
-program name.  The arguments have the following meanings:
-
-1. Tx    - signifies transmit mode
-2. f0    - suppressed carrier frequency or &quot;dial frequency&quot; (MHz)
-3. ftx   - center frequency of generated MEPT_JT signal (MHz)
-4. nport - COM port number for PTT control (0 to disable PTT control)
-5. call  - transmitted callsign
-6. grid  - transmitted 4-character locator
-7. dbm   - transmitter power (dBm)
-8. snr   - generated S/N (for off-line testing only)
-9. file  - output file name, or number of files to generate
-
-On-the-air transmissions use only arguments 1 through 7; arguments 8
-and 9 are used for generating wave files for local tests.
-
-In receive mode the first two command-line arguments must be &quot;Rx&quot; and
-the dial frequency f0, in MHz.  Additional arguments are treated as
-file names, for local testing purposes.
-
-A third operating mode, the &quot;T/R&quot; mode, allows one to specify the
-percentage of 2-minute time slots to devote to transmitting.  All
-remaining time slots will be used for receiving.  The percentage is
-defined in a statistical manner; specific choices of Tx and Rx
-intervals are randomized.  In this way you can put a signal on the air
-for others to copy, and at the same time monitor the band to keep
-track of who else is on.  In T/R mode the first 7 command-line
-arguments have the same meanings as in Tx mode; the 8th argument
-specifies the percent of 2-minute sequences you want devoted to
-transmission.  In the example given above, 25% of 2-minute sequences
-will be transmissions, while the remaining 75% will be used for
-reception.
-
-
-NORMAL OPERATION
-----------------
-
-Set your transceiver to USB mode and the dial frequency 1500 Hz below
-the center of the desired 200 Hz band for reception.  For example, on
-30 m the QRSS band is 10.140000 to 10.140200, so the dial frequency
-should be f0 = 10.140100 - 0.001500 = 10.1386 MHz.  Be sure that your
-computer clock is accurate to within a second or so.  In case your
-computer has more than one sound card, please note that the program
-will use the default Windows sound system.  (Support for selecting
-which sound card to use will probably be added in a future program
-release.)
-
-TRANSMIT: To transmit, type in a command similar to the first example
-above.  The third argument is your desired signal frequency.  I use
-serial port COM 5 for PTT control.  Therefore, to transmit on
-10.140150 with power 100 mW (20 dBm) I would enter the command
-
-C:\WSPR&gt; wspr Tx 10.1386 10.140150 5 K1JT FN20 20
-
-Transmission will start at the top on the next even minute, and will
-be repeated on even minutes until you stop it manually.  You can type
-CTRL+C (hold down the CTRL key while striking C) to terminate program
-execution.
-
-
-RECEIVE: To receive, type in a command like the fourth example above.
-The second argument is the dial frequency, 1500 Hz below the center of
-the 200 Hz received passband.
-
-C:\WSPR&gt; wspr Rx 10.1386
-
-Reception will begin at the top of the next even minute, and will
-continue until you terminate it manually by typing CTRL+C.
-
-
-T/R MODE: Type in a command line like the third example above:
-
-C:\WSPR&gt; wspr T/R 10.1386 10.140150 1 K1JT FN20 30 25
-
-At the start of the next even minute the program will start a series
-of transmission or reception intervals.  A random number generator
-is used to determine whether a particular interval will be Tx or Rx;
-on average, however, the percentage of transmission intervals will be
-approach the number specified by argument #8.
-
-
-LOCAL TESTS WITH TWO COMPUTERS
-------------------------------
-
-Be sure that both computer clocks are accurate to within a second or
-so.
-
-On the &quot;transmit&quot; computer, to send MEPT_JT data at S/N -26 dB, type
-something like this:
-
-C:\WSPR&gt; wspr Tx 10.1386 10.140080 0 K1JT FN20 20 -26
-
-The frequencies are arbitrary, but the frequency difference will
-determine the audio tone generated.  Transmission will start at the
-top on the next even minute, and will be repeated on even minutes
-until you stop it manually.  (You can type CTRL+C to terminate program
-execution.)
-
-On the &quot;receive&quot; computer, type in a command like
-
-C:\WSPR&gt; wspr Rx 10.1386
-
-The frequency is arbitrary.  Reception will begin at the top of the
-next even minute, and will continue until terminated manually.
-
-You can also do this test with a single computer.  Just open two
-command windows, one for Tx and one for Rx.  Use an audio cable to
-patch soundcard output into soundcard input, or simply use the speaker
-to &quot;transmit&quot; and the computer mike to &quot;receive&quot;.
-
-LOCAL TESTS WITH ONE COMPUTER
------------------------------
-
-You can generate a set of three test files at S/N -26 dB by entering a
-command like this:
-
-C:\WSPR&gt; wspr Tx 10.1386 10.140100 0 K1JT FN20 30 -26 3
-
-These files may then be &quot;received&quot; by entering this command:
-
-C:\WSPR&gt; wspr Rx 10.1386 00001.wav 00002.wav 00003.wav
-
-
-GENERATING A MULTI-SIGNAL TEST FILE
------------------------------------
-
-If you set snr = 10 on the command line, WSPR will generate a file
-containing ten distinct signals at 20 Hz intervals, with progressive
-time offsets of 0.1 s relative to the first one, and with S/N -21,
--22, ... -30 dB.  This feature was designed for testing the
-multi-signal decoder.  Here is a complete example of its use:
-
-C:\WSPR&gt; wspr Tx 10.1386 10.140100 0 K1JT FN20 30 10 test.wav
-  10.138600  10.140100  10.0  K1JT FN20 30            test.wav
-
-C:\WSPR&gt; wspr Rx 10.1386 test.wav
- UTC   Sync dB    DT     Freq    Message                  Noise
----------------------------------------------------------------
-test    18 -21   0.0  10.140010  K1JT FN20 30              20.1
-test    14 -23   0.1  10.140030  K1JT FN20 30              20.1
-test     4 -23   0.2  10.140050  K1JT FN20 30              20.1
-test     7 -25   0.3  10.140070  K1JT FN20 30              20.1
-test    12 -25   0.4  10.140090  K1JT FN20 30              20.1
-test     2 -26   0.5  10.140110  K1JT FN20 30              20.1
-test     4 -28   0.6  10.140130  K1JT FN20 30              20.1
-test     1 -29   0.7  10.140150  K1JT FN20 30              20.1
-test     1 -29   0.7  10.140170  K1JT FN20 30              20.1
-
-
-GENERATING A LIST OF TX TONE FREQUENCIES
----------------------------------------- 
-
-As an aid to those wishing to build a hardware-based or
-microprocessor-based transmitter for MEPT_JT signals, you can request
-the program to output the list of tone frequencies corresponding to
-the MEPT_JT signal carrying a particular message.  To do this, simply
-set snr to 11 on the command line.  Shown below is a complete example
-of this usage.  The table has one line for each of the 162 symbols in
-an MEPT_JT transmission.  Column 2 gives the tone number (0-3) for
-each 4-FSK symbol; column 3 gives the tone frequency in Hz.  Each tone
-should last for 8192/12000 = 0.6827 seconds, and transitions between
-tones should be done in a phase-continuous manner.
-
-C:\WSPR&gt; wspr Tx 10.1386 10.140100 0 K1JT FN20 30 11
-  1  3  1502.197
-  2  3  1502.197
-  3  2  1500.732
-  4  0  1497.803
-  5  2  1500.732
-  6  0  1497.803
-  7  2  1500.732
-  8  2  1500.732
-  9  1  1499.268
- 10  2  1500.732
- 11  2  1500.732
- 12  2  1500.732
- 13  3  1502.197
- 14  3  1502.197
- 15  1  1499.268
- 16  0  1497.803
- 17  2  1500.732
- 18  2  1500.732
- 19  3  1502.197
- 20  2  1500.732
- 21  0  1497.803
- 22  3  1502.197
- 23  0  1497.803
- 24  1  1499.268
- 25  1  1499.268
- 26  3  1502.197
- 27  1  1499.268
- 28  2  1500.732
- 29  0  1497.803
- 30  2  1500.732
- 31  2  1500.732
- 32  0  1497.803
- 33  0  1497.803
- 34  2  1500.732
- 35  1  1499.268
- 36  2  1500.732
- 37  0  1497.803
- 38  1  1499.268
- 39  2  1500.732
- 40  3  1502.197
- 41  2  1500.732
- 42  2  1500.732
- 43  2  1500.732
- 44  0  1497.803
- 45  0  1497.803
- 46  0  1497.803
- 47  3  1502.197
- 48  2  1500.732
- 49  1  1499.268
- 50  3  1502.197
- 51  2  1500.732
- 52  0  1497.803
- 53  3  1502.197
- 54  3  1502.197
- 55  0  1497.803
- 56  3  1502.197
- 57  0  1497.803
- 58  0  1497.803
- 59  0  1497.803
- 60  1  1499.268
- 61  1  1499.268
- 62  0  1497.803
- 63  3  1502.197
- 64  0  1497.803
- 65  2  1500.732
- 66  0  1497.803
- 67  0  1497.803
- 68  3  1502.197
- 69  3  1502.197
- 70  0  1497.803
- 71  3  1502.197
- 72  2  1500.732
- 73  3  1502.197
- 74  0  1497.803
- 75  1  1499.268
- 76  0  1497.803
- 77  1  1499.268
- 78  0  1497.803
- 79  0  1497.803
- 80  3  1502.197
- 81  2  1500.732
- 82  2  1500.732
- 83  1  1499.268
- 84  0  1497.803
- 85  1  1499.268
- 86  1  1499.268
- 87  0  1497.803
- 88  2  1500.732
- 89  0  1497.803
- 90  1  1499.268
- 91  1  1499.268
- 92  2  1500.732
- 93  3  1502.197
- 94  0  1497.803
- 95  3  1502.197
- 96  2  1500.732
- 97  2  1500.732
- 98  2  1500.732
- 99  3  1502.197
-100  2  1500.732
-101  2  1500.732
-102  2  1500.732
-103  2  1500.732
-104  2  1500.732
-105  1  1499.268
-106  0  1497.803
-107  0  1497.803
-108  1  1499.268
-109  2  1500.732
-110  0  1497.803
-111  3  1502.197
-112  1  1499.268
-113  1  1499.268
-114  2  1500.732
-115  1  1499.268
-116  3  1502.197
-117  2  1500.732
-118  0  1497.803
-119  1  1499.268
-120  1  1499.268
-121  2  1500.732
-122  1  1499.268
-123  2  1500.732
-124  0  1497.803
-125  2  1500.732
-126  1  1499.268
-127  1  1499.268
-128  1  1499.268
-129  2  1500.732
-130  0  1497.803
-131  2  1500.732
-132  2  1500.732
-133  0  1497.803
-134  3  1502.197
-135  2  1500.732
-136  3  1502.197
-137  2  1500.732
-138  0  1497.803
-139  3  1502.197
-140  1  1499.268
-141  0  1497.803
-142  0  1497.803
-143  2  1500.732
-144  2  1500.732
-145  2  1500.732
-146  2  1500.732
-147  0  1497.803
-148  3  1502.197
-149  3  1502.197
-150  2  1500.732
-151  1  1499.268
-152  2  1500.732
-153  3  1502.197
-154  1  1499.268
-155  0  1497.803
-156  2  1500.732
-157  2  1500.732
-158  1  1499.268
-159  3  1502.197
-160  2  1500.732
-161  2  1500.732
-162  2  1500.732
+                        Instructions for WSPR
+                        ---------------------
+
+WSPR is the name of a computer program.  It is pronounced &quot;whisper&quot;,
+and stands for &quot;Weak Signal Propagation Reporter&quot;; it implements
+transmitting and receiving functions for a digital soundcard mode
+called &quot;MEPT_JT&quot;, which stands for &quot;Manned Experimental Propagation
+Tests, by K1JT&quot;.
+
+WSPR generates and receives signals using structured messages, strong
+forward error correction, and narrow-band 4-FSK modulation.  Its
+principal design goal is reliable copy at very low signal levels.  In
+practice it works well at signal-to-noise ratios down to -27 dB in a
+reference bandwidth of 2500 Hz.  The present program, version 0.3, has
+no frills, no graphics and no GUI.  It is executed from the command
+line.
+
+QUICK START
+-----------
+
+Download WSPR from the URL
+<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE">http://physics.princeton.edu/pulsar/K1JT/WSPR.EXE</A> and copy the
+executable file into a suitable directory such as C:\wspr.  WSPR is
+invoked by typing its name followed by zero or more arguments.  Open a
+command-prompt window, CD into to that directory, and type &quot;wspr&quot;
+(with no accompanying arguments) to see the following summary and
+examples of program usage:
+
+-----------------------------------------------------------------------
+C:\WPSR&gt; wspr
+
+ WSPR Version 0.3 r90
+
+ Usage: wspr Tx  f0 ftx nport call grid dBm [snr] [outfile | nfiles]
+        wspr T/R f0 ftx nport call grid dBm pctx
+        wspr Rx  f0 [infile ...]
+
+        f0 is the transceiver dial frequency (MHz)
+        ftx is the signal frequency (MHz)
+        nport is the COM port number for PTT control
+        snr is the S/N in 2500 Hz bandwidth (for test files)
+        pctx is the percentage of 2-minute periods to Tx
+
+ Examples:
+        wspr Tx  10.1386 10.140100 1 K1JT FN20 30
+        wspr Tx  10.1386 10.140100 0 K1JT FN20 30 -22 test.wav
+        wspr T/R 10.1386 10.140100 0 K1JT FN20 30 25
+        wspr Rx  10.1386
+        wspr Rx  10.1386 00001.wav 00002.wav 00003.wav
+
+ For more information see:
+        physics.princeton.edu/pulsar/K1JT/WSPR_Instructions.TXT
+-----------------------------------------------------------------------
+
+In transmit mode there can be up to 9 command-line arguments after the
+program name.  The arguments have the following meanings:
+
+1. Tx    - signifies transmit mode
+2. f0    - suppressed carrier frequency or &quot;dial frequency&quot; (MHz)
+3. ftx   - center frequency of generated MEPT_JT signal (MHz)
+4. nport - COM port number for PTT control (0 to disable PTT control)
+5. call  - transmitted callsign
+6. grid  - transmitted 4-character locator
+7. dbm   - transmitter power (dBm)
+8. snr   - generated S/N (for off-line testing only)
+9. file  - output file name, or number of files to generate
+
+On-the-air transmissions use only arguments 1 through 7; arguments 8
+and 9 are used for generating wave files for local tests.
+
+In receive mode the first two command-line arguments must be &quot;Rx&quot; and
+the dial frequency f0, in MHz.  Additional arguments are treated as
+file names, for local testing purposes.
+
+A third operating mode, the &quot;T/R&quot; mode, allows one to specify the
+percentage of 2-minute time slots to devote to transmitting.  All
+remaining time slots will be used for receiving.  The percentage is
+defined in a statistical manner; specific choices of Tx and Rx
+intervals are randomized.  In this way you can put a signal on the air
+for others to copy, and at the same time monitor the band to keep
+track of who else is on.  In T/R mode the first 7 command-line
+arguments have the same meanings as in Tx mode; the 8th argument
+specifies the percent of 2-minute sequences you want devoted to
+transmission.  In the example given above, 25% of 2-minute sequences
+will be transmissions, while the remaining 75% will be used for
+reception.
+
+
+NORMAL OPERATION
+----------------
+
+Set your transceiver to USB mode and the dial frequency 1500 Hz below
+the center of the desired 200 Hz band for reception.  For example, on
+30 m the QRSS band is 10.140000 to 10.140200, so the dial frequency
+should be f0 = 10.140100 - 0.001500 = 10.1386 MHz.  Be sure that your
+computer clock is accurate to within a second or so.  In case your
+computer has more than one sound card, please note that the program
+will use the default Windows sound system.  (Support for selecting
+which sound card to use will probably be added in a future program
+release.)
+
+TRANSMIT: To transmit, type in a command similar to the first example
+above.  The third argument is your desired signal frequency.  I use
+serial port COM 5 for PTT control.  Therefore, to transmit on
+10.140150 with power 100 mW (20 dBm) I would enter the command
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140150 5 K1JT FN20 20
+
+Transmission will start at the top on the next even minute, and will
+be repeated on even minutes until you stop it manually.  You can type
+CTRL+C (hold down the CTRL key while striking C) to terminate program
+execution.
+
+
+RECEIVE: To receive, type in a command like the fourth example above.
+The second argument is the dial frequency, 1500 Hz below the center of
+the 200 Hz received passband.
+
+C:\WSPR&gt; wspr Rx 10.1386
+
+Reception will begin at the top of the next even minute, and will
+continue until you terminate it manually by typing CTRL+C.
+
+
+T/R MODE: Type in a command line like the third example above:
+
+C:\WSPR&gt; wspr T/R 10.1386 10.140150 1 K1JT FN20 30 25
+
+At the start of the next even minute the program will start a series
+of transmission or reception intervals.  A random number generator
+is used to determine whether a particular interval will be Tx or Rx;
+on average, however, the percentage of transmission intervals will be
+approach the number specified by argument #8.
+
+
+LOCAL TESTS WITH TWO COMPUTERS
+------------------------------
+
+Be sure that both computer clocks are accurate to within a second or
+so.
+
+On the &quot;transmit&quot; computer, to send MEPT_JT data at S/N -26 dB, type
+something like this:
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140080 0 K1JT FN20 20 -26
+
+The frequencies are arbitrary, but the frequency difference will
+determine the audio tone generated.  Transmission will start at the
+top on the next even minute, and will be repeated on even minutes
+until you stop it manually.  (You can type CTRL+C to terminate program
+execution.)
+
+On the &quot;receive&quot; computer, type in a command like
+
+C:\WSPR&gt; wspr Rx 10.1386
+
+The frequency is arbitrary.  Reception will begin at the top of the
+next even minute, and will continue until terminated manually.
+
+You can also do this test with a single computer.  Just open two
+command windows, one for Tx and one for Rx.  Use an audio cable to
+patch soundcard output into soundcard input, or simply use the speaker
+to &quot;transmit&quot; and the computer mike to &quot;receive&quot;.
+
+LOCAL TESTS WITH ONE COMPUTER
+-----------------------------
+
+You can generate a set of three test files at S/N -26 dB by entering a
+command like this:
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140100 0 K1JT FN20 30 -26 3
+
+These files may then be &quot;received&quot; by entering this command:
+
+C:\WSPR&gt; wspr Rx 10.1386 00001.wav 00002.wav 00003.wav
+
+
+GENERATING A MULTI-SIGNAL TEST FILE
+-----------------------------------
+
+If you set snr = 10 on the command line, WSPR will generate a file
+containing ten distinct signals at 20 Hz intervals, with progressive
+time offsets of 0.1 s relative to the first one, and with S/N -21,
+-22, ... -30 dB.  This feature was designed for testing the
+multi-signal decoder.  Here is a complete example of its use:
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140100 0 K1JT FN20 30 10 test.wav
+  10.138600  10.140100  10.0  K1JT FN20 30            test.wav
+
+C:\WSPR&gt; wspr Rx 10.1386 test.wav
+ UTC   Sync dB    DT     Freq    Message                  Noise
+---------------------------------------------------------------
+test    18 -21   0.0  10.140010  K1JT FN20 30              20.1
+test    14 -23   0.1  10.140030  K1JT FN20 30              20.1
+test     4 -23   0.2  10.140050  K1JT FN20 30              20.1
+test     7 -25   0.3  10.140070  K1JT FN20 30              20.1
+test    12 -25   0.4  10.140090  K1JT FN20 30              20.1
+test     2 -26   0.5  10.140110  K1JT FN20 30              20.1
+test     4 -28   0.6  10.140130  K1JT FN20 30              20.1
+test     1 -29   0.7  10.140150  K1JT FN20 30              20.1
+test     1 -29   0.7  10.140170  K1JT FN20 30              20.1
+
+
+GENERATING A LIST OF TX TONE FREQUENCIES
+---------------------------------------- 
+
+As an aid to those wishing to build a hardware-based or
+microprocessor-based transmitter for MEPT_JT signals, you can request
+the program to output the list of tone frequencies corresponding to
+the MEPT_JT signal carrying a particular message.  To do this, simply
+set snr to 11 on the command line.  Shown below is a complete example
+of this usage.  The table has one line for each of the 162 symbols in
+an MEPT_JT transmission.  Column 2 gives the tone number (0-3) for
+each 4-FSK symbol; column 3 gives the tone frequency in Hz.  Each tone
+should last for 8192/12000 = 0.6827 seconds, and transitions between
+tones should be done in a phase-continuous manner.
+
+C:\WSPR&gt; wspr Tx 10.1386 10.140100 0 K1JT FN20 30 11
+  1  3  1502.197
+  2  3  1502.197
+  3  2  1500.732
+  4  0  1497.803
+  5  2  1500.732
+  6  0  1497.803
+  7  2  1500.732
+  8  2  1500.732
+  9  1  1499.268
+ 10  2  1500.732
+ 11  2  1500.732
+ 12  2  1500.732
+ 13  3  1502.197
+ 14  3  1502.197
+ 15  1  1499.268
+ 16  0  1497.803
+ 17  2  1500.732
+ 18  2  1500.732
+ 19  3  1502.197
+ 20  2  1500.732
+ 21  0  1497.803
+ 22  3  1502.197
+ 23  0  1497.803
+ 24  1  1499.268
+ 25  1  1499.268
+ 26  3  1502.197
+ 27  1  1499.268
+ 28  2  1500.732
+ 29  0  1497.803
+ 30  2  1500.732
+ 31  2  1500.732
+ 32  0  1497.803
+ 33  0  1497.803
+ 34  2  1500.732
+ 35  1  1499.268
+ 36  2  1500.732
+ 37  0  1497.803
+ 38  1  1499.268
+ 39  2  1500.732
+ 40  3  1502.197
+ 41  2  1500.732
+ 42  2  1500.732
+ 43  2  1500.732
+ 44  0  1497.803
+ 45  0  1497.803
+ 46  0  1497.803
+ 47  3  1502.197
+ 48  2  1500.732
+ 49  1  1499.268
+ 50  3  1502.197
+ 51  2  1500.732
+ 52  0  1497.803
+ 53  3  1502.197
+ 54  3  1502.197
+ 55  0  1497.803
+ 56  3  1502.197
+ 57  0  1497.803
+ 58  0  1497.803
+ 59  0  1497.803
+ 60  1  1499.268
+ 61  1  1499.268
+ 62  0  1497.803
+ 63  3  1502.197
+ 64  0  1497.803
+ 65  2  1500.732
+ 66  0  1497.803
+ 67  0  1497.803
+ 68  3  1502.197
+ 69  3  1502.197
+ 70  0  1497.803
+ 71  3  1502.197
+ 72  2  1500.732
+ 73  3  1502.197
+ 74  0  1497.803
+ 75  1  1499.268
+ 76  0  1497.803
+ 77  1  1499.268
+ 78  0  1497.803
+ 79  0  1497.803
+ 80  3  1502.197
+ 81  2  1500.732
+ 82  2  1500.732
+ 83  1  1499.268
+ 84  0  1497.803
+ 85  1  1499.268
+ 86  1  1499.268
+ 87  0  1497.803
+ 88  2  1500.732
+ 89  0  1497.803
+ 90  1  1499.268
+ 91  1  1499.268
+ 92  2  1500.732
+ 93  3  1502.197
+ 94  0  1497.803
+ 95  3  1502.197
+ 96  2  1500.732
+ 97  2  1500.732
+ 98  2  1500.732
+ 99  3  1502.197
+100  2  1500.732
+101  2  1500.732
+102  2  1500.732
+103  2  1500.732
+104  2  1500.732
+105  1  1499.268
+106  0  1497.803
+107  0  1497.803
+108  1  1499.268
+109  2  1500.732
+110  0  1497.803
+111  3  1502.197
+112  1  1499.268
+113  1  1499.268
+114  2  1500.732
+115  1  1499.268
+116  3  1502.197
+117  2  1500.732
+118  0  1497.803
+119  1  1499.268
+120  1  1499.268
+121  2  1500.732
+122  1  1499.268
+123  2  1500.732
+124  0  1497.803
+125  2  1500.732
+126  1  1499.268
+127  1  1499.268
+128  1  1499.268
+129  2  1500.732
+130  0  1497.803
+131  2  1500.732
+132  2  1500.732
+133  0  1497.803
+134  3  1502.197
+135  2  1500.732
+136  3  1502.197
+137  2  1500.732
+138  0  1497.803
+139  3  1502.197
+140  1  1499.268
+141  0  1497.803
+142  0  1497.803
+143  2  1500.732
+144  2  1500.732
+145  2  1500.732
+146  2  1500.732
+147  0  1497.803
+148  3  1502.197
+149  3  1502.197
+150  2  1500.732
+151  1  1499.268
+152  2  1500.732
+153  3  1502.197
+154  1  1499.268
+155  0  1497.803
+156  2  1500.732
+157  2  1500.732
+158  1  1499.268
+159  3  1502.197
+160  2  1500.732
+161  2  1500.732
+162  2  1500.732


Property changes on: branches/wspr/WSPR_Instructions.TXT
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/wspr/conv232.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/db.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/decode162.f
===================================================================
--- branches/wspr/decode162.f	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/decode162.f	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,177 +1,177 @@
-      subroutine decode162(c2,npts,dtx,dfx,message,ncycles,metric,nerr)
-
-C  Decode MEPT_JT data, assuming that DT and DF have already been determined.
-
-      complex c2(npts)                        !Downsampled baseband data
-      real s2(77,126)
-      real s3(64,63)
-      character*22 message
-      character*12 callsign
-      character*4 grid
-      character*3 cdbm
-      real*8 dt,df,phi,f0,dphi,twopi,phi1,dphi1
-      complex*16 cz,cz1,c0,c1
-      integer*1 i1,symbol(162)
-      integer*1 data1(11)                   !Decoded data (8-bit bytes)
-      integer   data4a(7)                   !Decoded data (8-bit bytes)
-      integer   data4(12)                   !Decoded data (6-bit bytes)
-      integer amp
-      integer mettab(0:255,0:1)             !Metric table
-      logical first
-      integer*1 sym0
-      common/tst99/ sym0(162)
-      equivalence (i1,i4)
-      data first/.true./
-      integer npr3(162)
-      data npr3/
-     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     + 0,0/
-      data mettab/
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
-     +   2,   2,   2,   2,   1,   1,   1,   1,   0,   0,
-     +  -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,
-     +  -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,
-     + -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,
-     + -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,
-     + -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,
-     + -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,
-     + -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,
-     + -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,
-     + -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,
-     + -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,
-     + -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,
-     + -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,
-     + -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,
-     + -84, -87, -86, -87, -88,-105, -94,-105, -88, -87,
-     + -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,
-     + -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,
-     + -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,
-     + -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,
-     + -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,
-     + -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,
-     + -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,
-     + -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,
-     + -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,
-     + -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,
-     + -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,
-     + -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,
-     +  -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,
-     +  -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,
-     +   2,   2,   2,   2,   3,   3,   3,   3,   3,   3,
-     +   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5/
-      save
-
-      rewind 41
-
-      if(first) then
-         twopi=8*atan(1.d0)
-         dt=1.d0/375.d0                        !Sample interval
-         df=375.d0/256.d0
-         nsym=162
-         amp=32                                !### ??? ###
-         first=.false.
-      endif
-
-      istart=nint((dtx+2.0)/dt)              !Start index for synced FFTs
-      if(istart.lt.0) istart=0
-
-C  Should amp be adjusted according to signal strength?
-
-C  Compute soft symbols using differential BPSK demodulation
-      c0=0.                                !### C0=amp ???
-      k=istart
-      fac=1.e-4
-      phi=0.d0
-      phi1=0.d0
-      nspchip=256
-      nchips=1
-      fac2=0.001
-      do j=1,nsym
-         f0=dfx + (npr3(j)-1.5)*df
-         f1=dfx + (2+npr3(j)-1.5)*df
-         dphi=twopi*dt*f0
-         dphi1=twopi*dt*f1
-         sq0=0.
-         sq1=0.
-         do nc=1,nchips
-            phi=0.d0
-            phi1=0.d0
-            c0=0.
-            c1=0.
-            do i=1,nspchip
-               k=k+1
-               phi=phi+dphi
-               phi1=phi1+dphi1
-               cz=dcmplx(cos(phi),-sin(phi))
-               cz1=dcmplx(cos(phi1),-sin(phi1))
-               if(k.le.npts) then
-                  c0=c0 + c2(k)*cz                      !c2 was dat
-                  c1=c1 + c2(k)*cz1                     !c2 was dat
-               endif
-            enddo
-            sq0=sq0 + real(c0)**2 + aimag(c0)**2
-            sq1=sq1 + real(c1)**2 + aimag(c1)**2
-         enddo
-         sq0=fac2*sq0
-         sq1=fac2*sq1
-         rsym=amp*(sq1-sq0)
-         r=rsym+128.
-         if(r.gt.255.0) r=255.0
-         if(r.lt.0.0) r=0.0
-         i4=nint(r)
-         symbol(j)=i1
-         i4a=i4
-      enddo
-
-      ndelta=100
-      limit=100000
-      nbits=50+31
-      call inter_mept(symbol,-1)                      !Remove interleaving
-      call fano232(symbol,nbits,mettab,ndelta,limit,
-     +     data1,ncycles,metric,nerr)
-      message='                      '
-      cdbm='   '
-      if(nerr.ge.0) then
-         call unpack50(data1,n1,n2)
-         call unpackcall(n1,callsign)
-         call unpackgrid(n2/128,grid)
-         ndbm=iand(n2,127) - 64
-         i1=index(callsign,' ')
-         write(cdbm,'(i3)'),ndbm
-         if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-         if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-         message=callsign(1:i1)//grid//' '//cdbm
-      endif
-!      print*,nerr,ncycles,metric,callsign,grid,ndbm
-
-C  Save symbol spectra for possible decoding of average.
-
-      return
-      end
+      subroutine decode162(c2,npts,dtx,dfx,message,ncycles,metric,nerr)
+
+C  Decode MEPT_JT data, assuming that DT and DF have already been determined.
+
+      complex c2(npts)                        !Downsampled baseband data
+      real s2(77,126)
+      real s3(64,63)
+      character*22 message
+      character*12 callsign
+      character*4 grid
+      character*3 cdbm
+      real*8 dt,df,phi,f0,dphi,twopi,phi1,dphi1
+      complex*16 cz,cz1,c0,c1
+      integer*1 i1,symbol(162)
+      integer*1 data1(11)                   !Decoded data (8-bit bytes)
+      integer   data4a(7)                   !Decoded data (8-bit bytes)
+      integer   data4(12)                   !Decoded data (6-bit bytes)
+      integer amp
+      integer mettab(0:255,0:1)             !Metric table
+      logical first
+      integer*1 sym0
+      common/tst99/ sym0(162)
+      equivalence (i1,i4)
+      data first/.true./
+      integer npr3(162)
+      data npr3/
+     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     + 0,0/
+      data mettab/
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
+     +   2,   2,   2,   2,   1,   1,   1,   1,   0,   0,
+     +  -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,
+     +  -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,
+     + -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,
+     + -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,
+     + -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,
+     + -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,
+     + -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,
+     + -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,
+     + -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,
+     + -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,
+     + -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,
+     + -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,
+     + -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,
+     + -84, -87, -86, -87, -88,-105, -94,-105, -88, -87,
+     + -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,
+     + -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,
+     + -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,
+     + -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,
+     + -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,
+     + -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,
+     + -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,
+     + -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,
+     + -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,
+     + -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,
+     + -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,
+     + -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,
+     +  -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,
+     +  -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,
+     +   2,   2,   2,   2,   3,   3,   3,   3,   3,   3,
+     +   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5/
+      save
+
+      rewind 41
+
+      if(first) then
+         twopi=8*atan(1.d0)
+         dt=1.d0/375.d0                        !Sample interval
+         df=375.d0/256.d0
+         nsym=162
+         amp=32                                !### ??? ###
+         first=.false.
+      endif
+
+      istart=nint((dtx+2.0)/dt)              !Start index for synced FFTs
+      if(istart.lt.0) istart=0
+
+C  Should amp be adjusted according to signal strength?
+
+C  Compute soft symbols using differential BPSK demodulation
+      c0=0.                                !### C0=amp ???
+      k=istart
+      fac=1.e-4
+      phi=0.d0
+      phi1=0.d0
+      nspchip=256
+      nchips=1
+      fac2=0.001
+      do j=1,nsym
+         f0=dfx + (npr3(j)-1.5)*df
+         f1=dfx + (2+npr3(j)-1.5)*df
+         dphi=twopi*dt*f0
+         dphi1=twopi*dt*f1
+         sq0=0.
+         sq1=0.
+         do nc=1,nchips
+            phi=0.d0
+            phi1=0.d0
+            c0=0.
+            c1=0.
+            do i=1,nspchip
+               k=k+1
+               phi=phi+dphi
+               phi1=phi1+dphi1
+               cz=dcmplx(cos(phi),-sin(phi))
+               cz1=dcmplx(cos(phi1),-sin(phi1))
+               if(k.le.npts) then
+                  c0=c0 + c2(k)*cz                      !c2 was dat
+                  c1=c1 + c2(k)*cz1                     !c2 was dat
+               endif
+            enddo
+            sq0=sq0 + real(c0)**2 + aimag(c0)**2
+            sq1=sq1 + real(c1)**2 + aimag(c1)**2
+         enddo
+         sq0=fac2*sq0
+         sq1=fac2*sq1
+         rsym=amp*(sq1-sq0)
+         r=rsym+128.
+         if(r.gt.255.0) r=255.0
+         if(r.lt.0.0) r=0.0
+         i4=nint(r)
+         symbol(j)=i1
+         i4a=i4
+      enddo
+
+      ndelta=100
+      limit=100000
+      nbits=50+31
+      call inter_mept(symbol,-1)                      !Remove interleaving
+      call fano232(symbol,nbits,mettab,ndelta,limit,
+     +     data1,ncycles,metric,nerr)
+      message='                      '
+      cdbm='   '
+      if(nerr.ge.0) then
+         call unpack50(data1,n1,n2)
+         call unpackcall(n1,callsign)
+         call unpackgrid(n2/128,grid)
+         ndbm=iand(n2,127) - 64
+         i1=index(callsign,' ')
+         write(cdbm,'(i3)'),ndbm
+         if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+         if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+         message=callsign(1:i1)//grid//' '//cdbm
+      endif
+!      print*,nerr,ncycles,metric,callsign,grid,ndbm
+
+C  Save symbol spectra for possible decoding of average.
+
+      return
+      end


Property changes on: branches/wspr/decode162.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/deg2grid.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/encode232.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/fano232.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/flat3.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/four1.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/four2.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/genmept.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/getrms.f
===================================================================
--- branches/wspr/getrms.f	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/getrms.f	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,32 +1,32 @@
-      subroutine getrms(iwave,npts,ave,rms)
-
-      parameter (NMAX=120*12000)
-      integer*2 iwave(NMAX)
-      real*8 sq
-
-      s=0.
-      do i=1,npts
-         s=s + iwave(i)
-      enddo
-      ave=s/npts
-      sq=0.
-      do i=1,npts
-         sq=sq + (iwave(i)-ave)**2
-      enddo
-      rms=sqrt(sq/npts)
-      fac=3000.0/rms
-      do i=1,npts
-         n=nint(fac*(iwave(i)-ave))
-         if(n.gt.32767) n=32767
-         if(n.lt.-32767) n=-32767
-         iwave(i)=n
-      enddo
-
-      if(npts.lt.NMAX) then
-         do i=npts+1,NMAX
-            iwave(i)=0
-         enddo
-      endif
-
-      return
-      end
+      subroutine getrms(iwave,npts,ave,rms)
+
+      parameter (NMAX=120*12000)
+      integer*2 iwave(NMAX)
+      real*8 sq
+
+      s=0.
+      do i=1,npts
+         s=s + iwave(i)
+      enddo
+      ave=s/npts
+      sq=0.
+      do i=1,npts
+         sq=sq + (iwave(i)-ave)**2
+      enddo
+      rms=sqrt(sq/npts)
+      fac=3000.0/rms
+      do i=1,npts
+         n=nint(fac*(iwave(i)-ave))
+         if(n.gt.32767) n=32767
+         if(n.lt.-32767) n=-32767
+         iwave(i)=n
+      enddo
+
+      if(npts.lt.NMAX) then
+         do i=npts+1,NMAX
+            iwave(i)=0
+         enddo
+      endif
+
+      return
+      end


Property changes on: branches/wspr/getrms.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/getsound.c
===================================================================
--- branches/wspr/getsound.c	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/getsound.c	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,185 +1,185 @@
-/** @file patest_record.c
-	@brief Record input into an array; Save array to a file; Playback recorded data.
-	@author Phil Burk  <A HREF="http://www.softsynth.com">http://www.softsynth.com</A>
-*/
-/*
- * $Id: patest_record.c 249 2006-08-09 20:08:01Z va3db $
- *
- * This program uses the PortAudio Portable Audio Library.
- * For more information see: <A HREF="http://www.portaudio.com">http://www.portaudio.com</A>
- * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files
- * (the &quot;Software&quot;), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * Any person wishing to distribute modifications to the Software is
- * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &quot;portaudio.h&quot;
-
-#define SAMPLE_RATE  (12000)
-#define FRAMES_PER_BUFFER (1024)
-#define NUM_SECONDS     (114)
-#define NUM_CHANNELS    (1)
-/* #define DITHER_FLAG     (paDitherOff) */
-#define DITHER_FLAG     (0) /**/
-
-#define PA_SAMPLE_TYPE  paInt16
-typedef short SAMPLE;
-#define SAMPLE_SILENCE  (0)
-
-typedef struct
-{
-  int          frameIndex;  /* Index into sample array. */
-  int          maxFrameIndex;
-  SAMPLE      *recordedSamples;
-} paTestData;
-
-/* This routine will be called by the PortAudio engine when audio is needed.
-** It may be called at interrupt level on some machines so don't do anything
-** that could mess up the system like calling malloc() or free().
-*/
-static int recordCallback( const void *inputBuffer, void *outputBuffer,
-                           unsigned long framesPerBuffer,
-                           const PaStreamCallbackTimeInfo* timeInfo,
-                           PaStreamCallbackFlags statusFlags,
-                           void *userData )
-{
-  paTestData *data = (paTestData*)userData;
-  const SAMPLE *rptr = (const SAMPLE*)inputBuffer;
-  SAMPLE *wptr = &amp;data-&gt;recordedSamples[data-&gt;frameIndex * NUM_CHANNELS];
-  long framesToCalc;
-  long i;
-  int finished;
-  unsigned long framesLeft = data-&gt;maxFrameIndex - data-&gt;frameIndex;
-
-  (void) outputBuffer; /* Prevent unused variable warnings. */
-  (void) timeInfo;
-  (void) statusFlags;
-  (void) userData;
-
-  if( framesLeft &lt; framesPerBuffer ) {
-    framesToCalc = framesLeft;
-    finished = paComplete;
-  }
-   else {
-     framesToCalc = framesPerBuffer;
-     finished = paContinue;
-   }
-
-  if( inputBuffer == NULL ) {
-    for( i=0; i&lt;framesToCalc; i++ ) {
-      *wptr++ = SAMPLE_SILENCE;                          /* left */
-      if( NUM_CHANNELS == 2 ) *wptr++ = SAMPLE_SILENCE;  /* right */
-    }
-  }
-  else {
-    for( i=0; i&lt;framesToCalc; i++ ) {
-      *wptr++ = *rptr++;  /* left */
-      if( NUM_CHANNELS == 2 ) *wptr++ = *rptr++;  /* right */
-    }
-  }
-  data-&gt;frameIndex += framesToCalc;
-  return finished;
-}
-
-/*******************************************************************/
-#ifdef CVF
-extern int __stdcall GETSOUND(int *ndevin, short int iwave[])
-#else
-extern int getsound_(int *ndevin, short int iwave[])
-#endif
-{
-  PaStreamParameters  inputParameters,
-                      outputParameters;
-  PaStream*           stream;
-  PaError             err = paNoError;
-  paTestData          data;
-  int                 i;
-  int                 totalFrames;
-  int                 numSamples;
-  int                 numBytes;
-  SAMPLE              max, val;
-  double              average;
-  struct stat         stbuf;
-
-  data.maxFrameIndex = totalFrames = NUM_SECONDS * SAMPLE_RATE;
-  data.frameIndex = 0;
-  numSamples = totalFrames * NUM_CHANNELS;
-  numBytes = numSamples * sizeof(SAMPLE);
-  data.recordedSamples = iwave;
-  for( i=0; i&lt;numSamples; i++ ) 
-    data.recordedSamples[i] = 0;
-
-  err = Pa_Initialize();
-  if( err != paNoError ) goto done;
-
-  if(*ndevin == 0)
-    inputParameters.device = Pa_GetDefaultInputDevice();
-  else
-    inputParameters.device = *ndevin;
-
-  inputParameters.channelCount = 1;
-  inputParameters.sampleFormat = PA_SAMPLE_TYPE;
-  inputParameters.suggestedLatency = Pa_GetDeviceInfo( inputParameters.device )-&gt;defaultLowInputLatency;
-  inputParameters.hostApiSpecificStreamInfo = NULL;
-
-  err = Pa_OpenStream(
-              &amp;stream,
-              &amp;inputParameters,
-              NULL,                  /* &amp;outputParameters, */
-              SAMPLE_RATE,
-              FRAMES_PER_BUFFER,
-              paClipOff,
-              recordCallback,
-              &amp;data );
-  if( err != paNoError ) goto done;
-
-  err = Pa_StartStream( stream );
-  if( err != paNoError ) goto done;
-
-  while( ( err = Pa_IsStreamActive( stream ) ) == 1 ) {
-    err=stat(&quot;abort&quot;, &amp;stbuf);
-    if(err == 0) {
-      Pa_Sleep(1000);
-      exit(0);
-    }
-    Pa_Sleep(200);
-  }
-  if( err &lt; 0 ) goto done;
-
-  err = Pa_CloseStream( stream );    
-
-done:
-  Pa_Terminate();
-  if( err != paNoError ) {
-    fprintf( stderr, &quot;An error occured while using the portaudio stream\n&quot; );
-    fprintf( stderr, &quot;Error number: %d\n&quot;, err );
-    fprintf( stderr, &quot;Error message: %s\n&quot;, Pa_GetErrorText( err ) );
-    err = 1;          /* Always return 0 or 1, but no other return codes. */
-  }
-  return err;
-}
-
+/** @file patest_record.c
+	@brief Record input into an array; Save array to a file; Playback recorded data.
+	@author Phil Burk  <A HREF="http://www.softsynth.com">http://www.softsynth.com</A>
+*/
+/*
+ * $Id: patest_record.c 249 2006-08-09 20:08:01Z va3db $
+ *
+ * This program uses the PortAudio Portable Audio Library.
+ * For more information see: <A HREF="http://www.portaudio.com">http://www.portaudio.com</A>
+ * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the &quot;Software&quot;), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &quot;portaudio.h&quot;
+
+#define SAMPLE_RATE  (12000)
+#define FRAMES_PER_BUFFER (1024)
+#define NUM_SECONDS     (114)
+#define NUM_CHANNELS    (1)
+/* #define DITHER_FLAG     (paDitherOff) */
+#define DITHER_FLAG     (0) /**/
+
+#define PA_SAMPLE_TYPE  paInt16
+typedef short SAMPLE;
+#define SAMPLE_SILENCE  (0)
+
+typedef struct
+{
+  int          frameIndex;  /* Index into sample array. */
+  int          maxFrameIndex;
+  SAMPLE      *recordedSamples;
+} paTestData;
+
+/* This routine will be called by the PortAudio engine when audio is needed.
+** It may be called at interrupt level on some machines so don't do anything
+** that could mess up the system like calling malloc() or free().
+*/
+static int recordCallback( const void *inputBuffer, void *outputBuffer,
+                           unsigned long framesPerBuffer,
+                           const PaStreamCallbackTimeInfo* timeInfo,
+                           PaStreamCallbackFlags statusFlags,
+                           void *userData )
+{
+  paTestData *data = (paTestData*)userData;
+  const SAMPLE *rptr = (const SAMPLE*)inputBuffer;
+  SAMPLE *wptr = &amp;data-&gt;recordedSamples[data-&gt;frameIndex * NUM_CHANNELS];
+  long framesToCalc;
+  long i;
+  int finished;
+  unsigned long framesLeft = data-&gt;maxFrameIndex - data-&gt;frameIndex;
+
+  (void) outputBuffer; /* Prevent unused variable warnings. */
+  (void) timeInfo;
+  (void) statusFlags;
+  (void) userData;
+
+  if( framesLeft &lt; framesPerBuffer ) {
+    framesToCalc = framesLeft;
+    finished = paComplete;
+  }
+   else {
+     framesToCalc = framesPerBuffer;
+     finished = paContinue;
+   }
+
+  if( inputBuffer == NULL ) {
+    for( i=0; i&lt;framesToCalc; i++ ) {
+      *wptr++ = SAMPLE_SILENCE;                          /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = SAMPLE_SILENCE;  /* right */
+    }
+  }
+  else {
+    for( i=0; i&lt;framesToCalc; i++ ) {
+      *wptr++ = *rptr++;  /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = *rptr++;  /* right */
+    }
+  }
+  data-&gt;frameIndex += framesToCalc;
+  return finished;
+}
+
+/*******************************************************************/
+#ifdef CVF
+extern int __stdcall GETSOUND(int *ndevin, short int iwave[])
+#else
+extern int getsound_(int *ndevin, short int iwave[])
+#endif
+{
+  PaStreamParameters  inputParameters,
+                      outputParameters;
+  PaStream*           stream;
+  PaError             err = paNoError;
+  paTestData          data;
+  int                 i;
+  int                 totalFrames;
+  int                 numSamples;
+  int                 numBytes;
+  SAMPLE              max, val;
+  double              average;
+  struct stat         stbuf;
+
+  data.maxFrameIndex = totalFrames = NUM_SECONDS * SAMPLE_RATE;
+  data.frameIndex = 0;
+  numSamples = totalFrames * NUM_CHANNELS;
+  numBytes = numSamples * sizeof(SAMPLE);
+  data.recordedSamples = iwave;
+  for( i=0; i&lt;numSamples; i++ ) 
+    data.recordedSamples[i] = 0;
+
+  err = Pa_Initialize();
+  if( err != paNoError ) goto done;
+
+  if(*ndevin == 0)
+    inputParameters.device = Pa_GetDefaultInputDevice();
+  else
+    inputParameters.device = *ndevin;
+
+  inputParameters.channelCount = 1;
+  inputParameters.sampleFormat = PA_SAMPLE_TYPE;
+  inputParameters.suggestedLatency = Pa_GetDeviceInfo( inputParameters.device )-&gt;defaultLowInputLatency;
+  inputParameters.hostApiSpecificStreamInfo = NULL;
+
+  err = Pa_OpenStream(
+              &amp;stream,
+              &amp;inputParameters,
+              NULL,                  /* &amp;outputParameters, */
+              SAMPLE_RATE,
+              FRAMES_PER_BUFFER,
+              paClipOff,
+              recordCallback,
+              &amp;data );
+  if( err != paNoError ) goto done;
+
+  err = Pa_StartStream( stream );
+  if( err != paNoError ) goto done;
+
+  while( ( err = Pa_IsStreamActive( stream ) ) == 1 ) {
+    err=stat(&quot;abort&quot;, &amp;stbuf);
+    if(err == 0) {
+      Pa_Sleep(1000);
+      exit(0);
+    }
+    Pa_Sleep(200);
+  }
+  if( err &lt; 0 ) goto done;
+
+  err = Pa_CloseStream( stream );    
+
+done:
+  Pa_Terminate();
+  if( err != paNoError ) {
+    fprintf( stderr, &quot;An error occured while using the portaudio stream\n&quot; );
+    fprintf( stderr, &quot;Error number: %d\n&quot;, err );
+    fprintf( stderr, &quot;Error message: %s\n&quot;, Pa_GetErrorText( err ) );
+    err = 1;          /* Always return 0 or 1, but no other return codes. */
+  }
+  return err;
+}
+


Property changes on: branches/wspr/getsound.c
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/wspr/gran.f90
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/grid2deg.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/inter_mept.f
===================================================================
--- branches/wspr/inter_mept.f	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/inter_mept.f	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,43 +1,43 @@
-      subroutine inter_mept(id,ndir)
-
-C  Interleave (ndir=1) or de-interleave (ndir=-1) the array id.
-
-      integer*1 id(0:161),itmp(0:161)
-      integer j0(0:161)
-      character*8 c0,c1
-      logical first
-      data first/.true./
-      save
-
-      if(first) then
-         k=-1
-         do i=0,255
-            write(c0,1001) i
- 1001       format(b8.8)
-            c1=c0(8:8)//c0(7:7)//c0(6:6)//c0(5:5)//c0(4:4)//c0(3:3)//
-     +         c0(2:2)//c0(1:1)
-            read(c1,1001) n
-            if(n.le.161) then
-               k=k+1
-               j0(k)=n
-            endif
-         enddo
-         first=.false.
-      endif
-
-      if(ndir.eq.1) then
-         do i=0,161
-            itmp(j0(i))=id(i)
-         enddo
-      else
-         do i=0,161
-            itmp(i)=id(j0(i))
-         enddo
-      endif
-
-      do i=0,161
-         id(i)=itmp(i)
-      enddo
-
-      return
-      end
+      subroutine inter_mept(id,ndir)
+
+C  Interleave (ndir=1) or de-interleave (ndir=-1) the array id.
+
+      integer*1 id(0:161),itmp(0:161)
+      integer j0(0:161)
+      character*8 c0,c1
+      logical first
+      data first/.true./
+      save
+
+      if(first) then
+         k=-1
+         do i=0,255
+            write(c0,1001) i
+ 1001       format(b8.8)
+            c1=c0(8:8)//c0(7:7)//c0(6:6)//c0(5:5)//c0(4:4)//c0(3:3)//
+     +         c0(2:2)//c0(1:1)
+            read(c1,1001) n
+            if(n.le.161) then
+               k=k+1
+               j0(k)=n
+            endif
+         enddo
+         first=.false.
+      endif
+
+      if(ndir.eq.1) then
+         do i=0,161
+            itmp(j0(i))=id(i)
+         enddo
+      else
+         do i=0,161
+            itmp(i)=id(j0(i))
+         enddo
+      endif
+
+      do i=0,161
+         id(i)=itmp(i)
+      enddo
+
+      return
+      end


Property changes on: branches/wspr/inter_mept.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/mept162.f
===================================================================
--- branches/wspr/mept162.f	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/mept162.f	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,54 +1,54 @@
-      subroutine mept162(outfile,f0,minsync,id,npts,rms,nsec)
-
-C  Orchestrates the process of decoding MEPT_JT messages.
-
-      integer*2 id(npts)
-
-      parameter (NFFT1=2*1024*1024)
-      character*22 message
-      character*70 outfile
-      character*11 datetime
-      logical first
-      real*8 f0
-      real ps(-128:128)
-      real sstf(4,275)
-      complex c(0:NFFT1),c2(65536)
-      data first/.true./
-      save
-
-      end file 14
-      rewind 14
-
-C  Mix 1500 Hz +/- 100 Hz to baseband, and downsample by 1/32
-      call mix162(id,npts,c,c,c2,jz,df2,ps)
-
-C  Look for sync patterns, get DF and DT
-      call sync162(c2,jz,dtx,dfx,snrx,snrsync,sstf,kz)
-      call spec162(c2,jz)
-
-      siglev=20.0*log10(rms/300.0) 
-      do k=1,kz
-         snrsync=sstf(1,k)
-         snrx=sstf(2,k)
-         dtx=sstf(3,k)
-         dfx=sstf(4,k)
-         nsync=nint(snrsync)
-         if(nsync.lt.0) nsync=0
-         nsnrx=nint(snrx)
-         if(nsnrx.lt.-33) nsnrx=-33
-         freq=f0 + 1.d-6*(dfx+1500.0)
-         message='                      '
-         if(nsync.ge.minsync) then
-           call decode162(c2,jz,dtx,dfx,message,ncycles,metric,nerr)
-           i2=index(outfile,'.')-1
-           datetime=outfile(i2-10:i2)
-           datetime(7:7)=' '
-           write(13,1010) datetime,nsync,nsnrx,dtx,freq,message
-           write(14,1010) datetime,nsync,nsnrx,dtx,freq,message,
-     +          siglev,nsec/120,nint(dfx)
- 1010      format(a11,i4,i4,f6.1,f11.6,2x,a15,f8.1,i9,i4)
-         endif
-      enddo
-
-      return
-      end
+      subroutine mept162(outfile,f0,minsync,id,npts,rms,nsec)
+
+C  Orchestrates the process of decoding MEPT_JT messages.
+
+      integer*2 id(npts)
+
+      parameter (NFFT1=2*1024*1024)
+      character*22 message
+      character*70 outfile
+      character*11 datetime
+      logical first
+      real*8 f0
+      real ps(-128:128)
+      real sstf(4,275)
+      complex c(0:NFFT1),c2(65536)
+      data first/.true./
+      save
+
+      end file 14
+      rewind 14
+
+C  Mix 1500 Hz +/- 100 Hz to baseband, and downsample by 1/32
+      call mix162(id,npts,c,c,c2,jz,df2,ps)
+
+C  Look for sync patterns, get DF and DT
+      call sync162(c2,jz,dtx,dfx,snrx,snrsync,sstf,kz)
+      call spec162(c2,jz)
+
+      siglev=20.0*log10(rms/300.0) 
+      do k=1,kz
+         snrsync=sstf(1,k)
+         snrx=sstf(2,k)
+         dtx=sstf(3,k)
+         dfx=sstf(4,k)
+         nsync=nint(snrsync)
+         if(nsync.lt.0) nsync=0
+         nsnrx=nint(snrx)
+         if(nsnrx.lt.-33) nsnrx=-33
+         freq=f0 + 1.d-6*(dfx+1500.0)
+         message='                      '
+         if(nsync.ge.minsync) then
+           call decode162(c2,jz,dtx,dfx,message,ncycles,metric,nerr)
+           i2=index(outfile,'.')-1
+           datetime=outfile(i2-10:i2)
+           datetime(7:7)=' '
+           write(13,1010) datetime,nsync,nsnrx,dtx,freq,message
+           write(14,1010) datetime,nsync,nsnrx,dtx,freq,message,
+     +          siglev,nsec/120,nint(dfx)
+ 1010      format(a11,i4,i4,f6.1,f11.6,2x,a15,f8.1,i9,i4)
+         endif
+      enddo
+
+      return
+      end


Property changes on: branches/wspr/mept162.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/mept_jt.f90
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/mept_rx.f90
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/mept_tx.f90
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/mix162.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/nchar.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/pack50.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/packcall.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/packgrid.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/packmept.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/pctile.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/peakup.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/playsound.c
===================================================================
--- branches/wspr/playsound.c	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/playsound.c	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,199 +1,199 @@
-/** @file patest_record.c
-	@brief Record input into an array; Save array to a file; Playback recorded data.
-	@author Phil Burk  <A HREF="http://www.softsynth.com">http://www.softsynth.com</A>
-*/
-/*
- * $Id: patest_record.c 249 2006-08-09 20:08:01Z va3db $
- *
- * This program uses the PortAudio Portable Audio Library.
- * For more information see: <A HREF="http://www.portaudio.com">http://www.portaudio.com</A>
- * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files
- * (the &quot;Software&quot;), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * Any person wishing to distribute modifications to the Software is
- * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &quot;portaudio.h&quot;
-
-/* #define SAMPLE_RATE  (17932) // Test failure to open with this value. */
-#define SAMPLE_RATE  (12000)
-#define FRAMES_PER_BUFFER (1024)
-#define NUM_SECONDS     (114)
-#define NUM_CHANNELS    (1)
-/* #define DITHER_FLAG     (paDitherOff) */
-#define DITHER_FLAG     (0) /**/
-
-/* Select sample format. */
-#define PA_SAMPLE_TYPE  paInt16
-typedef short SAMPLE;
-
-typedef struct
-{
-    int          frameIndex;  /* Index into sample array. */
-    int          maxFrameIndex;
-    SAMPLE      *recordedSamples;
-} paTestData;
-
-/* This routine will be called by the PortAudio engine when audio is needed.
-** It may be called at interrupt level on some machines so don't do anything
-** that could mess up the system like calling malloc() or free().
-*/
-static int playCallback( const void *inputBuffer, void *outputBuffer,
-                         unsigned long framesPerBuffer,
-                         const PaStreamCallbackTimeInfo* timeInfo,
-                         PaStreamCallbackFlags statusFlags,
-                         void *userData )
-{
-  paTestData *data = (paTestData*)userData;
-  SAMPLE *rptr = &amp;data-&gt;recordedSamples[data-&gt;frameIndex * NUM_CHANNELS];
-  SAMPLE *wptr = (SAMPLE*)outputBuffer;
-  unsigned int i;
-  int finished;
-  unsigned int framesLeft = data-&gt;maxFrameIndex - data-&gt;frameIndex;
-
-  (void) inputBuffer; /* Prevent unused variable warnings. */
-  (void) timeInfo;
-  (void) statusFlags;
-  (void) userData;
-
-  if( framesLeft &lt; framesPerBuffer )  {
-    /* final buffer... */
-    for( i=0; i&lt;framesLeft; i++ )  {
-      *wptr++ = *rptr++;  /* left */
-      if( NUM_CHANNELS == 2 ) *wptr++ = *rptr++;  /* right */
-    }
-    for( ; i&lt;framesPerBuffer; i++ )  {
-      *wptr++ = 0;  /* left */
-      if( NUM_CHANNELS == 2 ) *wptr++ = 0;  /* right */
-    }
-    data-&gt;frameIndex += framesLeft;
-    finished = paComplete;
-  }
-  else  {
-    for( i=0; i&lt;framesPerBuffer; i++ )  {
-      *wptr++ = *rptr++;  /* left */
-      if( NUM_CHANNELS == 2 ) *wptr++ = *rptr++;  /* right */
-    }
-    data-&gt;frameIndex += framesPerBuffer;
-    finished = paContinue;
-  }
-  return finished;
-}
-
-/*******************************************************************/
-#ifdef CVF
-extern int __stdcall PLAYSOUND(int *ndevout, short int iwave[])
-#else
-extern int playsound_(int *ndevout, short int iwave[])
-#endif
-{
-  PaStreamParameters  inputParameters,
-                      outputParameters;
-  PaStream*           stream;
-  PaError             err = paNoError;
-  paTestData          data;
-  int                 i;
-  int                 totalFrames;
-  int                 numSamples;
-  int                 numBytes;
-  SAMPLE              max, val;
-  double              average;
-  struct stat         stbuf;
-
-  data.maxFrameIndex = totalFrames = NUM_SECONDS * SAMPLE_RATE;
-  data.frameIndex = 0;
-  numSamples = totalFrames * NUM_CHANNELS;
-  numBytes = numSamples * sizeof(SAMPLE);
-  data.recordedSamples = iwave;
-
-  /* Play the wave file */
-  data.frameIndex = 0;
-  err = Pa_Initialize();
-  if( err != paNoError ) goto done;
-
-  if( *ndevout == 0) 
-    outputParameters.device = Pa_GetDefaultOutputDevice();
-  else
-    outputParameters.device = *ndevout;
-
-  outputParameters.channelCount = NUM_CHANNELS;
-  outputParameters.sampleFormat =  PA_SAMPLE_TYPE;
-  outputParameters.suggestedLatency = Pa_GetDeviceInfo( outputParameters.device )-&gt;defaultLowOutputLatency;
-  outputParameters.hostApiSpecificStreamInfo = NULL;
-
-  err = Pa_OpenStream(
-              &amp;stream,
-              NULL,                                /* no input */
-              &amp;outputParameters,
-              SAMPLE_RATE,
-              FRAMES_PER_BUFFER,
-              paClipOff,
-              playCallback,
-              &amp;data );
-  if( err != paNoError ) goto done;
-
-  if( stream ) {
-    err = Pa_StartStream( stream );
-    if( err != paNoError ) goto done;
-
-    while( ( err = Pa_IsStreamActive( stream ) ) == 1 ) {
-      err=stat(&quot;abort&quot;, &amp;stbuf);
-      if(err == 0) {
-	Pa_Sleep(1000);
-	exit(0);
-      }
-      Pa_Sleep(200);
-    }
-    if( err &lt; 0 ) goto done;
-        
-    err = Pa_CloseStream( stream );
-    if( err != paNoError ) goto done;    
-  }
-
-done:
-  Pa_Terminate();
-  //    if( data.recordedSamples )       /* Sure it is NULL or valid. */
-  //        free( data.recordedSamples );
-  if( err != paNoError ) {
-    fprintf( stderr, &quot;An error occured while using the portaudio stream\n&quot; );
-    fprintf( stderr, &quot;Error number: %d\n&quot;, err );
-    fprintf( stderr, &quot;Error message: %s\n&quot;, Pa_GetErrorText( err ) );
-    err = 1;          /* Always return 0 or 1, but no other return codes. */
-  }
-  return err;
-}
-
-#ifdef CVF
-extern void __stdcall PA_SLEEP(int *nsleep)
-#else
-extern void pa_sleep__(int *nsleep)
-#endif
-{
-  int n;
-  n=*nsleep;
-  Pa_Sleep(n);
-}
+/** @file patest_record.c
+	@brief Record input into an array; Save array to a file; Playback recorded data.
+	@author Phil Burk  <A HREF="http://www.softsynth.com">http://www.softsynth.com</A>
+*/
+/*
+ * $Id: patest_record.c 249 2006-08-09 20:08:01Z va3db $
+ *
+ * This program uses the PortAudio Portable Audio Library.
+ * For more information see: <A HREF="http://www.portaudio.com">http://www.portaudio.com</A>
+ * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the &quot;Software&quot;), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &quot;portaudio.h&quot;
+
+/* #define SAMPLE_RATE  (17932) // Test failure to open with this value. */
+#define SAMPLE_RATE  (12000)
+#define FRAMES_PER_BUFFER (1024)
+#define NUM_SECONDS     (114)
+#define NUM_CHANNELS    (1)
+/* #define DITHER_FLAG     (paDitherOff) */
+#define DITHER_FLAG     (0) /**/
+
+/* Select sample format. */
+#define PA_SAMPLE_TYPE  paInt16
+typedef short SAMPLE;
+
+typedef struct
+{
+    int          frameIndex;  /* Index into sample array. */
+    int          maxFrameIndex;
+    SAMPLE      *recordedSamples;
+} paTestData;
+
+/* This routine will be called by the PortAudio engine when audio is needed.
+** It may be called at interrupt level on some machines so don't do anything
+** that could mess up the system like calling malloc() or free().
+*/
+static int playCallback( const void *inputBuffer, void *outputBuffer,
+                         unsigned long framesPerBuffer,
+                         const PaStreamCallbackTimeInfo* timeInfo,
+                         PaStreamCallbackFlags statusFlags,
+                         void *userData )
+{
+  paTestData *data = (paTestData*)userData;
+  SAMPLE *rptr = &amp;data-&gt;recordedSamples[data-&gt;frameIndex * NUM_CHANNELS];
+  SAMPLE *wptr = (SAMPLE*)outputBuffer;
+  unsigned int i;
+  int finished;
+  unsigned int framesLeft = data-&gt;maxFrameIndex - data-&gt;frameIndex;
+
+  (void) inputBuffer; /* Prevent unused variable warnings. */
+  (void) timeInfo;
+  (void) statusFlags;
+  (void) userData;
+
+  if( framesLeft &lt; framesPerBuffer )  {
+    /* final buffer... */
+    for( i=0; i&lt;framesLeft; i++ )  {
+      *wptr++ = *rptr++;  /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = *rptr++;  /* right */
+    }
+    for( ; i&lt;framesPerBuffer; i++ )  {
+      *wptr++ = 0;  /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = 0;  /* right */
+    }
+    data-&gt;frameIndex += framesLeft;
+    finished = paComplete;
+  }
+  else  {
+    for( i=0; i&lt;framesPerBuffer; i++ )  {
+      *wptr++ = *rptr++;  /* left */
+      if( NUM_CHANNELS == 2 ) *wptr++ = *rptr++;  /* right */
+    }
+    data-&gt;frameIndex += framesPerBuffer;
+    finished = paContinue;
+  }
+  return finished;
+}
+
+/*******************************************************************/
+#ifdef CVF
+extern int __stdcall PLAYSOUND(int *ndevout, short int iwave[])
+#else
+extern int playsound_(int *ndevout, short int iwave[])
+#endif
+{
+  PaStreamParameters  inputParameters,
+                      outputParameters;
+  PaStream*           stream;
+  PaError             err = paNoError;
+  paTestData          data;
+  int                 i;
+  int                 totalFrames;
+  int                 numSamples;
+  int                 numBytes;
+  SAMPLE              max, val;
+  double              average;
+  struct stat         stbuf;
+
+  data.maxFrameIndex = totalFrames = NUM_SECONDS * SAMPLE_RATE;
+  data.frameIndex = 0;
+  numSamples = totalFrames * NUM_CHANNELS;
+  numBytes = numSamples * sizeof(SAMPLE);
+  data.recordedSamples = iwave;
+
+  /* Play the wave file */
+  data.frameIndex = 0;
+  err = Pa_Initialize();
+  if( err != paNoError ) goto done;
+
+  if( *ndevout == 0) 
+    outputParameters.device = Pa_GetDefaultOutputDevice();
+  else
+    outputParameters.device = *ndevout;
+
+  outputParameters.channelCount = NUM_CHANNELS;
+  outputParameters.sampleFormat =  PA_SAMPLE_TYPE;
+  outputParameters.suggestedLatency = Pa_GetDeviceInfo( outputParameters.device )-&gt;defaultLowOutputLatency;
+  outputParameters.hostApiSpecificStreamInfo = NULL;
+
+  err = Pa_OpenStream(
+              &amp;stream,
+              NULL,                                /* no input */
+              &amp;outputParameters,
+              SAMPLE_RATE,
+              FRAMES_PER_BUFFER,
+              paClipOff,
+              playCallback,
+              &amp;data );
+  if( err != paNoError ) goto done;
+
+  if( stream ) {
+    err = Pa_StartStream( stream );
+    if( err != paNoError ) goto done;
+
+    while( ( err = Pa_IsStreamActive( stream ) ) == 1 ) {
+      err=stat(&quot;abort&quot;, &amp;stbuf);
+      if(err == 0) {
+	Pa_Sleep(1000);
+	exit(0);
+      }
+      Pa_Sleep(200);
+    }
+    if( err &lt; 0 ) goto done;
+        
+    err = Pa_CloseStream( stream );
+    if( err != paNoError ) goto done;    
+  }
+
+done:
+  Pa_Terminate();
+  //    if( data.recordedSamples )       /* Sure it is NULL or valid. */
+  //        free( data.recordedSamples );
+  if( err != paNoError ) {
+    fprintf( stderr, &quot;An error occured while using the portaudio stream\n&quot; );
+    fprintf( stderr, &quot;Error number: %d\n&quot;, err );
+    fprintf( stderr, &quot;Error message: %s\n&quot;, Pa_GetErrorText( err ) );
+    err = 1;          /* Always return 0 or 1, but no other return codes. */
+  }
+  return err;
+}
+
+#ifdef CVF
+extern void __stdcall PA_SLEEP(int *nsleep)
+#else
+extern void pa_sleep__(int *nsleep)
+#endif
+{
+  int n;
+  n=*nsleep;
+  Pa_Sleep(n);
+}


Property changes on: branches/wspr/playsound.c
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/wspr/ps162.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/ptt.c
===================================================================
--- branches/wspr/ptt.c	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/ptt.c	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,47 +1,47 @@
-#include &lt;windows.h&gt;
-#include &lt;stdio.h&gt;
-
-#ifdef CVF
-extern int __stdcall PTT(int *nport, char *unused, int *ntx, int *iptt)
-#else
-int ptt_(int *nport, char *unused, int *ntx, int *iptt)
-#endif
-
-{
-  static HANDLE hFile;
-  static int open=0;
-  char s[10];
-  int i3,i4,i5,i6,i9,i00;
-
-  if(*nport==0) {
-    *iptt=*ntx;
-    return(0);
-  }
-
-  if(*ntx &amp;&amp; (!open)) {
-    sprintf(s,&quot;COM%d&quot;,*nport);
-    hFile=CreateFile(TEXT(s),GENERIC_WRITE,0,NULL,OPEN_EXISTING,
-		     FILE_ATTRIBUTE_NORMAL,NULL);
-    if(hFile==INVALID_HANDLE_VALUE) {
-      printf(&quot;PTT: Cannot open COM port %d.\n&quot;,*nport);
-      return(1);
-    }
-    open=1;
-  }
-
-  if(*ntx &amp;&amp; open) {
-    EscapeCommFunction(hFile,3);
-    EscapeCommFunction(hFile,5);
-    *iptt=1;
-  }
-
-  else {
-    EscapeCommFunction(hFile,4);
-    EscapeCommFunction(hFile,6);
-    EscapeCommFunction(hFile,9);
-    i00=CloseHandle(hFile);
-    *iptt=0;
-    open=0;
-  }
-  return(0);
-}
+#include &lt;windows.h&gt;
+#include &lt;stdio.h&gt;
+
+#ifdef CVF
+extern int __stdcall PTT(int *nport, char *unused, int *ntx, int *iptt)
+#else
+int ptt_(int *nport, char *unused, int *ntx, int *iptt)
+#endif
+
+{
+  static HANDLE hFile;
+  static int open=0;
+  char s[10];
+  int i3,i4,i5,i6,i9,i00;
+
+  if(*nport==0) {
+    *iptt=*ntx;
+    return(0);
+  }
+
+  if(*ntx &amp;&amp; (!open)) {
+    sprintf(s,&quot;COM%d&quot;,*nport);
+    hFile=CreateFile(TEXT(s),GENERIC_WRITE,0,NULL,OPEN_EXISTING,
+		     FILE_ATTRIBUTE_NORMAL,NULL);
+    if(hFile==INVALID_HANDLE_VALUE) {
+      printf(&quot;PTT: Cannot open COM port %d.\n&quot;,*nport);
+      return(1);
+    }
+    open=1;
+  }
+
+  if(*ntx &amp;&amp; open) {
+    EscapeCommFunction(hFile,3);
+    EscapeCommFunction(hFile,5);
+    *iptt=1;
+  }
+
+  else {
+    EscapeCommFunction(hFile,4);
+    EscapeCommFunction(hFile,6);
+    EscapeCommFunction(hFile,9);
+    i00=CloseHandle(hFile);
+    *iptt=0;
+    open=0;
+  }
+  return(0);
+}


Property changes on: branches/wspr/ptt.c
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/wspr/set.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/slope.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/sort.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/spec162.f
===================================================================
--- branches/wspr/spec162.f	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/spec162.f	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,96 +1,96 @@
-      subroutine spec162(c2,jz)
-
-      parameter(NX=500,NY=160)
-      complex c2(65536)
-      complex c(0:255)
-      real s(120,0:255)
-      real ss(0:255)
-      real w(0:255)
-      real savg(0:255),tmp(256)
-      integer*2 a(NX,NY)
-      common/acom/base,base2
-
-      nfft=256
-      df=375.0/nfft
-      twopi=6.2831853
-      pi=0.5*twopi
-      do i=0,nfft-1
-         w(i)=sin(i*pi/nfft)
-      enddo
-
-      nadd=9
-      call zero(s,120*256)
-      call zero(savg,256)
-      istep=nfft/2
-      nsteps=(jz-nfft)/(nadd*istep)
-
-#ifdef CVF
-      open(16,file='pixmap.dat',form='binary',status='unknown',err=1)
-#else
-      open(16,file='pixmap.dat',access='stream',status='unknown',err=1)
-#endif
-      read(16,end=1) a
-      go to 2
- 1    call zero(a,NX*NY/2)
-
- 2    nmove=nsteps+1
-      do j=1,NY                 !Move waterfall left
-         do i=1,NX-nmove
-            a(i,j)=a(i+nmove,j)
-         enddo
-!         a(NX-nmove+1,j)=255
-         a(NX-nmove+1,j)=0
-      enddo
-
-      i0=-istep+1
-      k=0
-      do n=1,nsteps
-         k=k+1
-         call zero(ss,256)
-         do m=1,nadd
-            i0=i0+istep
-            do i=0,nfft-1
-               c(i)=w(i)*c2(i0+i)
-            enddo
-            call four2a(c,nfft,1,-1,1)
-            do i=0,nfft-1
-               sq=real(c(i))**2 + imag(c(i))**2
-               ss(i)=ss(i) + sq
-               savg(i)=savg(i) + sq
-            enddo
-         enddo
-         call flat3(ss,256,nadd)
-         do i=0,nfft-1
-            s(k,i)=ss(i)
-         enddo
-      enddo
-      kz=k
-
-      gain=40
-      offset=-90.
-      fac=20.0/nadd
-
-      do k=1,kz
-         j=k-kz+NX
-         do i=-80,-1
-            x=fac*s(k,i+nfft)
-            n=0
-            if(x.gt.0.0) n=gain*log10(x) + offset
-            n=min(252,max(0,n))
-            a(j,NY-i-80)=n
-         enddo
-         do i=0,79
-            x=fac*s(k,i)
-            n=0
-            if(x.gt.0.0) n=gain*log10(x) + offset
-            n=min(252,max(0,n))
-            a(j,NY-i-80)=n
-         enddo
-      enddo
-
-      rewind 16
-      write(16) a
-      close(16)
-
-      return
-      end
+      subroutine spec162(c2,jz)
+
+      parameter(NX=500,NY=160)
+      complex c2(65536)
+      complex c(0:255)
+      real s(120,0:255)
+      real ss(0:255)
+      real w(0:255)
+      real savg(0:255),tmp(256)
+      integer*2 a(NX,NY)
+      common/acom/base,base2
+
+      nfft=256
+      df=375.0/nfft
+      twopi=6.2831853
+      pi=0.5*twopi
+      do i=0,nfft-1
+         w(i)=sin(i*pi/nfft)
+      enddo
+
+      nadd=9
+      call zero(s,120*256)
+      call zero(savg,256)
+      istep=nfft/2
+      nsteps=(jz-nfft)/(nadd*istep)
+
+#ifdef CVF
+      open(16,file='pixmap.dat',form='binary',status='unknown',err=1)
+#else
+      open(16,file='pixmap.dat',access='stream',status='unknown',err=1)
+#endif
+      read(16,end=1) a
+      go to 2
+ 1    call zero(a,NX*NY/2)
+
+ 2    nmove=nsteps+1
+      do j=1,NY                 !Move waterfall left
+         do i=1,NX-nmove
+            a(i,j)=a(i+nmove,j)
+         enddo
+!         a(NX-nmove+1,j)=255
+         a(NX-nmove+1,j)=0
+      enddo
+
+      i0=-istep+1
+      k=0
+      do n=1,nsteps
+         k=k+1
+         call zero(ss,256)
+         do m=1,nadd
+            i0=i0+istep
+            do i=0,nfft-1
+               c(i)=w(i)*c2(i0+i)
+            enddo
+            call four2a(c,nfft,1,-1,1)
+            do i=0,nfft-1
+               sq=real(c(i))**2 + imag(c(i))**2
+               ss(i)=ss(i) + sq
+               savg(i)=savg(i) + sq
+            enddo
+         enddo
+         call flat3(ss,256,nadd)
+         do i=0,nfft-1
+            s(k,i)=ss(i)
+         enddo
+      enddo
+      kz=k
+
+      gain=40
+      offset=-90.
+      fac=20.0/nadd
+
+      do k=1,kz
+         j=k-kz+NX
+         do i=-80,-1
+            x=fac*s(k,i+nfft)
+            n=0
+            if(x.gt.0.0) n=gain*log10(x) + offset
+            n=min(252,max(0,n))
+            a(j,NY-i-80)=n
+         enddo
+         do i=0,79
+            x=fac*s(k,i)
+            n=0
+            if(x.gt.0.0) n=gain*log10(x) + offset
+            n=min(252,max(0,n))
+            a(j,NY-i-80)=n
+         enddo
+      enddo
+
+      rewind 16
+      write(16) a
+      close(16)
+
+      return
+      end


Property changes on: branches/wspr/spec162.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/ssort.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/sync162.f
===================================================================
--- branches/wspr/sync162.f	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/sync162.f	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,117 +1,117 @@
-      subroutine sync162(c2,jz,dtx,dfx,snrx,snrsync,sstf,kz)
-
-C  Find MEPT_JT sync signals, with best-fit DT and DF.  
-
-      complex c2(jz)
-      parameter (NFFT=512)             !Length of FFTs
-      parameter (NH=NFFT/2)            !Length of power spectra
-      parameter (NSMAX=351)            !Number of half-symbol steps
-      real psavg(-NH:NH)               !Average spectrum of whole record
-      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
-      real ccfred(-NH:NH)              !Peak of ccfblue, as function of freq
-      real ccfblue(-5:540)             !CCF with pseudorandom sequence
-      real tmp(513)
-      real sstf(4,275)
-      save
-
-C  Do FFTs of twice symbol length, stepped by half symbols.  Note that 
-C  we have already downsampled the data by factor of 2.
-
-      nsym=162
-      nq=NFFT/4
-      nsteps=jz/nq - 1
-      df=375.0/nfft
-      call zero(psavg,NFFT+1)
-
-C  Compute power spectrum for each step, and get average
-      do j=1,nsteps
-         k=(j-1)*nq + 1
-         call ps162(c2(k),s2(-NH,j))
-         call add(psavg,s2(-NH,j),psavg,NFFT)
-      enddo
-      call pctile(psavg(-136),tmp,273,45,base)
-
-      ia=nint(-100.0/df)
-      ib=-ia
-      i0=0
-      lag1=-5
-      lag2=20
-      syncbest=-1.e30
-
-      call zero(ccfred,745)
-      do i=ia,ib
-         call xcor162(s2,i,nsteps,nsym,lag1,lag2,ccfblue,ccf0,lagpk0)
-         ccfred(i+3)=ccf0
-         sync=ccfblue(lagpk0)
-         k=i-ia+1
-         sstf(1,k)=sync/base
-         sstf(3,k)=i
-         sstf(4,k)=lagpk0
-      enddo
-
-      kz=k
-      do k=1,kz
-         if(sstf(1,k).lt.1.0) then
-            sstf(1,k)=0.
-         else
-            i1=max(1,k-5)
-            i2=min(kz,k+6)
-            do i=i1,i2
-               if(sstf(1,i).gt.sstf(1,k)) sstf(1,k)=0.
-            enddo
-         endif
-      enddo
-
-      k=0
-      do i=1,kz
-         if(sstf(1,i).gt.0.0) then
-            k=k+1
-            sstf(1,k)=sstf(1,i)
-            sstf(3,k)=sstf(3,i)
-            sstf(4,k)=sstf(4,i)
-         endif
-      enddo
-      kz=k
-
-      do k=1,kz
-         ipk=nint(sstf(3,k))
-         dfx=(ipk-i0+3)*df
-
-C  Peak up in time, at best whole-channel frequency
-         call xcor162(s2,ipk,nsteps,nsym,lag1,lag2,ccfblue,ccfmax,lagpk)
-         xlag=lagpk
-         if(lagpk.gt.lag1 .and. lagpk.lt.lag2) then
-            call peakup(ccfblue(lagpk-1),ccfmax,ccfblue(lagpk+1),dx2)
-            xlag=lagpk+dx2
-         endif
-
-C  Find rms of the CCF, without the main peak
-         sq=0.
-         nsq=0
-         do lag=lag1,lag2
-            if(abs(lag-xlag).gt.2.0) then
-               sq=sq+ccfblue(lag)**2
-               nsq=nsq+1
-            endif
-         enddo
-         rms=sqrt(sq/nsq)
-         snrsync=ccfblue(lagpk)/rms - 8.0           !Empirical
-
-         dt=1.0/375.0
-         istart=xlag*nq
-         dtx=istart*dt - 2.0
-         ppmax=0.
-         do i=-4,4
-            ppmax=ppmax + psavg(ipk+i)
-         enddo
-         ppmax=(ppmax/(9.0*base)) - 1.0
-         snrx=db(max(ppmax,0.0001)) -23.55          !Empirical
-         sstf(1,k)=snrsync
-         sstf(2,k)=snrx
-         sstf(3,k)=dtx
-         sstf(4,k)=dfx
-      enddo
-
-      return
-      end
-
+      subroutine sync162(c2,jz,dtx,dfx,snrx,snrsync,sstf,kz)
+
+C  Find MEPT_JT sync signals, with best-fit DT and DF.  
+
+      complex c2(jz)
+      parameter (NFFT=512)             !Length of FFTs
+      parameter (NH=NFFT/2)            !Length of power spectra
+      parameter (NSMAX=351)            !Number of half-symbol steps
+      real psavg(-NH:NH)               !Average spectrum of whole record
+      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
+      real ccfred(-NH:NH)              !Peak of ccfblue, as function of freq
+      real ccfblue(-5:540)             !CCF with pseudorandom sequence
+      real tmp(513)
+      real sstf(4,275)
+      save
+
+C  Do FFTs of twice symbol length, stepped by half symbols.  Note that 
+C  we have already downsampled the data by factor of 2.
+
+      nsym=162
+      nq=NFFT/4
+      nsteps=jz/nq - 1
+      df=375.0/nfft
+      call zero(psavg,NFFT+1)
+
+C  Compute power spectrum for each step, and get average
+      do j=1,nsteps
+         k=(j-1)*nq + 1
+         call ps162(c2(k),s2(-NH,j))
+         call add(psavg,s2(-NH,j),psavg,NFFT)
+      enddo
+      call pctile(psavg(-136),tmp,273,45,base)
+
+      ia=nint(-100.0/df)
+      ib=-ia
+      i0=0
+      lag1=-5
+      lag2=20
+      syncbest=-1.e30
+
+      call zero(ccfred,745)
+      do i=ia,ib
+         call xcor162(s2,i,nsteps,nsym,lag1,lag2,ccfblue,ccf0,lagpk0)
+         ccfred(i+3)=ccf0
+         sync=ccfblue(lagpk0)
+         k=i-ia+1
+         sstf(1,k)=sync/base
+         sstf(3,k)=i
+         sstf(4,k)=lagpk0
+      enddo
+
+      kz=k
+      do k=1,kz
+         if(sstf(1,k).lt.1.0) then
+            sstf(1,k)=0.
+         else
+            i1=max(1,k-5)
+            i2=min(kz,k+6)
+            do i=i1,i2
+               if(sstf(1,i).gt.sstf(1,k)) sstf(1,k)=0.
+            enddo
+         endif
+      enddo
+
+      k=0
+      do i=1,kz
+         if(sstf(1,i).gt.0.0) then
+            k=k+1
+            sstf(1,k)=sstf(1,i)
+            sstf(3,k)=sstf(3,i)
+            sstf(4,k)=sstf(4,i)
+         endif
+      enddo
+      kz=k
+
+      do k=1,kz
+         ipk=nint(sstf(3,k))
+         dfx=(ipk-i0+3)*df
+
+C  Peak up in time, at best whole-channel frequency
+         call xcor162(s2,ipk,nsteps,nsym,lag1,lag2,ccfblue,ccfmax,lagpk)
+         xlag=lagpk
+         if(lagpk.gt.lag1 .and. lagpk.lt.lag2) then
+            call peakup(ccfblue(lagpk-1),ccfmax,ccfblue(lagpk+1),dx2)
+            xlag=lagpk+dx2
+         endif
+
+C  Find rms of the CCF, without the main peak
+         sq=0.
+         nsq=0
+         do lag=lag1,lag2
+            if(abs(lag-xlag).gt.2.0) then
+               sq=sq+ccfblue(lag)**2
+               nsq=nsq+1
+            endif
+         enddo
+         rms=sqrt(sq/nsq)
+         snrsync=ccfblue(lagpk)/rms - 8.0           !Empirical
+
+         dt=1.0/375.0
+         istart=xlag*nq
+         dtx=istart*dt - 2.0
+         ppmax=0.
+         do i=-4,4
+            ppmax=ppmax + psavg(ipk+i)
+         enddo
+         ppmax=(ppmax/(9.0*base)) - 1.0
+         snrx=db(max(ppmax,0.0001)) -23.55          !Empirical
+         sstf(1,k)=snrsync
+         sstf(2,k)=snrx
+         sstf(3,k)=dtx
+         sstf(4,k)=dfx
+      enddo
+
+      return
+      end
+


Property changes on: branches/wspr/sync162.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/unpack50.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/unpackcall.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/unpackgrid.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/unpackmept.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/wfile5.f
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: branches/wspr/wspr.f90
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native

Modified: branches/wspr/wspr.py
===================================================================
--- branches/wspr/wspr.py	2008-03-22 16:00:31 UTC (rev 663)
+++ branches/wspr/wspr.py	2008-03-22 19:07:47 UTC (rev 664)
@@ -1,5 +1,5 @@
 #------------------------------------------------------------------------ WSPR
-# $Date: 2008-03-17 08:29:04 -0400 (Mon, 17 Mar 2008) $ $Revision: 638 $
+# $Date: 2008-03-17 08:29:04 -0400 (Mon, 17 Mar 2008) $ $Revision$
 #
 from Tkinter import *
 from tkFileDialog import *
@@ -21,7 +21,7 @@
 import math
 
 root = Tk()
-#Version=&quot;0.4 r&quot; + &quot;$Rev: 638 $&quot;[6:-1]
+#Version=&quot;0.4 r&quot; + &quot;$Rev$&quot;[6:-1]
 Version=&quot;0.4&quot;
 print &quot;******************************************************************&quot;
 print &quot;WSPR Version &quot; + Version + &quot;, by K1JT&quot;


Property changes on: branches/wspr/wspr.py
___________________________________________________________________
Name: svn:keywords
   + Rev


Property changes on: branches/wspr/wspr_rx.f90
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/wspr_tx.f90
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/xcor162.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


Property changes on: branches/wspr/xfft.f
___________________________________________________________________
Name: copyright
   + '(c)
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000350.html">[WSJT-SVN] r663 - branches/wspr
</A></li>
	<LI>Next message: <A HREF="000351.html">[WSJT-SVN] r665 - branches/wspr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#352">[ date ]</a>
              <a href="thread.html#352">[ thread ]</a>
              <a href="subject.html#352">[ subject ]</a>
              <a href="author.html#352">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
