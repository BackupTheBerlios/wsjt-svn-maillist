<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r879 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r879%20-%20trunk&In-Reply-To=%3C200807041444.m64EisQ5018395%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000566.html">
   <LINK REL="Next"  HREF="000567.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r879 - trunk</H1>
    <B>va3db at BerliOS</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r879%20-%20trunk&In-Reply-To=%3C200807041444.m64EisQ5018395%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r879 - trunk">va3db at mail.berlios.de
       </A><BR>
    <I>Fri Jul  4 16:44:54 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000566.html">[WSJT-SVN] r878 - trunk
</A></li>
        <LI>Next message: <A HREF="000567.html">[WSJT-SVN] r880 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#568">[ date ]</a>
              <a href="thread.html#568">[ thread ]</a>
              <a href="subject.html#568">[ subject ]</a>
              <a href="author.html#568">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: va3db
Date: 2008-07-04 16:44:52 +0200 (Fri, 04 Jul 2008)
New Revision: 879

Modified:
   trunk/avemsg6m.f
   trunk/bzap.f
   trunk/coord.f
   trunk/dcoord.f
   trunk/decode162.f
   trunk/decode24.f
   trunk/decode6m.f
   trunk/decodecw.f
   trunk/demod64a.f
   trunk/fivehz.F90
   trunk/four2.f
   trunk/ftpeak65.f
   trunk/gencw.f
   trunk/genwspr.f90
   trunk/getfile.F90
   trunk/getsnr.f
   trunk/mept162a.f
   trunk/pack50.f
   trunk/ping.f
   trunk/stdecode.f
   trunk/sync162.f
   trunk/sync64.f
   trunk/syncf1.f
   trunk/wqencode.f90
   trunk/wsjt64.f
   trunk/xfft2.f
Log:
- Numerous cleanups, removal of unused variables
- John spotted the dat(8)=0 twice in pack50.f fixed.
- Files spotted with \r\n cleaned up and propset



Modified: trunk/avemsg6m.f
===================================================================
--- trunk/avemsg6m.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/avemsg6m.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -79,6 +79,7 @@
          wgt(k)=wgt(k)+1.0
       enddo
 
+      ipk=0 !Shut up compiler warnings. -db
       do j=1,msglen                            !Hard-decode the avg msg,
          smax=-1.e9                            !picking max bin for each char
          do i=1,43

Modified: trunk/bzap.f
===================================================================
--- trunk/bzap.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/bzap.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -31,6 +31,7 @@
          ia=(fzap(izap)-tol)/df 
          ib=(fzap(izap)+tol)/df
          smax=0.
+         ipk=0 !Shut up compiler warnings. -db
          do i=ia+1,ib+1
             s=real(c(i))**2 + aimag(c(i))**2
             if(s.gt.smax) then

Modified: trunk/coord.f
===================================================================
--- trunk/coord.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/coord.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -29,6 +29,7 @@
       SBB=sin(AP-A0)*CB0
       SA2=SAA*CBB-CAA*SBB
       CA2=CAA*CBB+SAA*SBB
+      TA2O2=0.0 !Shut up compiler warnings. -db
       IF(CA2.LE.0.e0) TA2O2=(1.e0-CA2)/SA2 
       IF(CA2.GT.0.e0) TA2O2=SA2/(1.e0+CA2)
       A2=2.e0*atan(TA2O2)

Modified: trunk/dcoord.f
===================================================================
--- trunk/dcoord.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/dcoord.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -30,6 +30,7 @@
       SBB=sin(AP-A0)*CB0
       SA2=SAA*CBB-CAA*SBB
       CA2=CAA*CBB+SAA*SBB
+      TA2O2=0.0 !Shut up compiler warnings. -db
       IF(CA2.LE.0.D0) TA2O2=(1.D0-CA2)/SA2 
       IF(CA2.GT.0.D0) TA2O2=SA2/(1.D0+CA2)
       A2=2.D0*atan(TA2O2)

Modified: trunk/decode162.f
===================================================================
--- trunk/decode162.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/decode162.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -1,142 +1,142 @@
-      subroutine decode162(c4,npts,message,ncycles,metric,nerr)
-
-C  Decode MEPT_JT data, assuming that DT and DF have already been determined.
-
-      complex c4(npts)
-      character*22 message
-      real*8 dt,df,twopi,f0,f1,dphi0,dphi1
-      complex*16 cz,cz1,c0,c1
-      complex*16 w0,w1,ws0,ws1
-      integer*1 i1,symbol(162)
-      integer*1 data1(11)
-      integer amp
-      integer mettab(0:255,0:1)
-      logical first
-      equivalence (i1,i4)
-      data first/.true./
-      integer npr3(162)
-      common/ccom/rr(162)
-      data npr3/
-     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     + 0,0/
-      data mettab/
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
-     +   2,   2,   2,   2,   1,   1,   1,   1,   0,   0,
-     +  -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,
-     +  -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,
-     + -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,
-     + -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,
-     + -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,
-     + -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,
-     + -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,
-     + -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,
-     + -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,
-     + -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,
-     + -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,
-     + -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,
-     + -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,
-     + -84, -87, -86, -87, -88, -89, -89, -89, -88, -87,
-     + -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,
-     + -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,
-     + -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,
-     + -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,
-     + -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,
-     + -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,
-     + -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,
-     + -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,
-     + -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,
-     + -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,
-     + -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,
-     + -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,
-     +  -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,
-     +  -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,
-     +   2,   2,   2,   2,   3,   3,   3,   3,   3,   3,
-     +   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5/
-      save
-
-      if(first) then
-         twopi=8*atan(1.d0)
-         dt=1.d0/375.d0                        !Sample interval
-         df=375.d0/256.d0
-         nsym=162
-         nbits=50+31
-         amp=20                                !### 32 ??? ###
-         ndelta=50
-         limit=20000
-         first=.false.
-      endif
-
-C  Should amp be adjusted according to signal strength?
-C  Compute soft symbols
-      k=0
-      nsps=256
-      fac2=0.001
-      w0=1.0
-      w1=1.0
-
-      do j=1,nsym
-         f0=(npr3(j)-1.5)*df
-         f1=(2+npr3(j)-1.5)*df
-         dphi0=twopi*dt*f0
-         dphi1=twopi*dt*f1
-         ws0=dcmplx(cos(dphi0),-sin(dphi0))
-         ws1=dcmplx(cos(dphi1),-sin(dphi1))
-         c0=0.
-         c1=0.
-         do i=1,nsps
-            k=k+1
-            w0=w0*ws0
-            w1=w1*ws1
-            c0=c0 + w0*c4(k)
-            c1=c1 + w1*c4(k)
-         enddo
-
-         sq0=fac2*(real(c0)**2 + aimag(c0)**2)
-         sq1=fac2*(real(c1)**2 + aimag(c1)**2)
-         rsym=amp*(sq1-sq0)
-!         write(55,3003) j,rsym,rr(j)
-! 3003    format(i5,3f10.3)
-!         rsym=rr(j)
-
-         r=rsym+128.
-         if(r.gt.255.0) r=255.0
-         if(r.lt.0.0) r=0.0
-         i4=nint(r)
-         symbol(j)=i1
-      enddo
-
-      call inter_mept(symbol,-1)                      !Remove interleaving
-      call fano232(symbol,nbits,mettab,ndelta,limit,
-     +     data1,ncycles,metric,nerr)
-      message='                      '
-      if(nerr.ge.0) call wqdecode(data1,message,ntype2)
-
-      return
-      end
+      subroutine decode162(c4,npts,message,ncycles,metric,nerr)
+
+C  Decode MEPT_JT data, assuming that DT and DF have already been determined.
+
+      complex c4(npts)
+      character*22 message
+      real*8 dt,df,twopi,f0,f1,dphi0,dphi1
+      complex*16 c0,c1
+      complex*16 w0,w1,ws0,ws1
+      integer*1 i1,symbol(162)
+      integer*1 data1(11)
+      integer amp
+      integer mettab(0:255,0:1)
+      logical first
+      equivalence (i1,i4)
+      data first/.true./
+      integer npr3(162)
+      common/ccom/rr(162)
+      data npr3/
+     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     + 0,0/
+      data mettab/
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
+     +   2,   2,   2,   2,   1,   1,   1,   1,   0,   0,
+     +  -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,
+     +  -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,
+     + -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,
+     + -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,
+     + -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,
+     + -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,
+     + -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,
+     + -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,
+     + -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,
+     + -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,
+     + -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,
+     + -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,
+     + -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,
+     + -84, -87, -86, -87, -88, -89, -89, -89, -88, -87,
+     + -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,
+     + -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,
+     + -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,
+     + -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,
+     + -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,
+     + -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,
+     + -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,
+     + -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,
+     + -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,
+     + -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,
+     + -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,
+     + -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,
+     +  -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,
+     +  -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,
+     +   2,   2,   2,   2,   3,   3,   3,   3,   3,   3,
+     +   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
+     +   4,   4,   4,   4,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
+     +   5,   5/
+      save
+
+      if(first) then
+         twopi=8*atan(1.d0)
+         dt=1.d0/375.d0                        !Sample interval
+         df=375.d0/256.d0
+         nsym=162
+         nbits=50+31
+         amp=20                                !### 32 ??? ###
+         ndelta=50
+         limit=20000
+         first=.false.
+      endif
+
+C  Should amp be adjusted according to signal strength?
+C  Compute soft symbols
+      k=0
+      nsps=256
+      fac2=0.001
+      w0=1.0
+      w1=1.0
+
+      do j=1,nsym
+         f0=(npr3(j)-1.5)*df
+         f1=(2+npr3(j)-1.5)*df
+         dphi0=twopi*dt*f0
+         dphi1=twopi*dt*f1
+         ws0=dcmplx(cos(dphi0),-sin(dphi0))
+         ws1=dcmplx(cos(dphi1),-sin(dphi1))
+         c0=0.
+         c1=0.
+         do i=1,nsps
+            k=k+1
+            w0=w0*ws0
+            w1=w1*ws1
+            c0=c0 + w0*c4(k)
+            c1=c1 + w1*c4(k)
+         enddo
+
+         sq0=fac2*(real(c0)**2 + aimag(c0)**2)
+         sq1=fac2*(real(c1)**2 + aimag(c1)**2)
+         rsym=amp*(sq1-sq0)
+!         write(55,3003) j,rsym,rr(j)
+! 3003    format(i5,3f10.3)
+!         rsym=rr(j)
+
+         r=rsym+128.
+         if(r.gt.255.0) r=255.0
+         if(r.lt.0.0) r=0.0
+         i4=nint(r)
+         symbol(j)=i1
+      enddo
+
+      call inter_mept(symbol,-1)                      !Remove interleaving
+      call fano232(symbol,nbits,mettab,ndelta,limit,
+     +     data1,ncycles,metric,nerr)
+      message='                      '
+      if(nerr.ge.0) call wqdecode(data1,message,ntype2)
+
+      return
+      end


Property changes on: trunk/decode162.f
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/decode24.f
===================================================================
--- trunk/decode24.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/decode24.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -5,9 +5,7 @@
 C  Decodes JT65 data, assuming that DT and DF have already been determined.
 
       real dat(npts)                        !Raw data
-      real s2(77,126)
-      real s3(64,63)
-      real ftrack(126)
+!      real s3(64,63)
       character decoded*22,deepmsg*22
 C XXX are these not shadowing the subroutine parameters? -db
       character mycall*12,hiscall*12,hisgrid*6

Modified: trunk/decode6m.f
===================================================================
--- trunk/decode6m.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/decode6m.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -121,6 +121,7 @@
             endif
             j0=j
             smax1=-1.e9
+            ipk=0 !Shut up compiler warning. -db
             do i=1,43                         !Pick max bin for 1st char
                if(s2db(i,j).gt.smax1) then
                   smax1=s2db(i,j)

Modified: trunk/decodecw.f
===================================================================
--- trunk/decodecw.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/decodecw.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -13,7 +13,7 @@
       real f1(300),f2(300)
       real x(65536)
       real y2(32)
-      real*8 dt,f0,phi,dhpi,twopi
+      real*8 dt,f0,phi,twopi
       complex c(NMAX),z,cx(0:32768)
       equivalence (x,cx)
 

Modified: trunk/demod64a.f
===================================================================
--- trunk/demod64a.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/demod64a.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -43,6 +43,8 @@
          enddo
 
          s2=-1.e30
+         i1=0 !Shut up compiler warnings. -db
+         i2=0 !Shut up compiler warnings. -db
          do i=1,64
             if(i.ne.i1 .and. signal(i,j).gt.s2) then
                s2=signal(i,j)

Modified: trunk/fivehz.F90
===================================================================
--- trunk/fivehz.F90	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/fivehz.F90	2008-07-04 14:44:52 UTC (rev 879)
@@ -16,7 +16,6 @@
 
   parameter (NTRING=64)
   real*8 tt1(0:NTRING-1)
-  real*8 tstart,tstop,t60
   logical first,txtime,filled
   integer ptt
   integer TxOKz

Modified: trunk/four2.f
===================================================================
--- trunk/four2.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/four2.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -142,6 +142,10 @@
 
       real*8 twopi,wstpr,wstpi,wr,wi,w2r,w2i,w3r,w3i,wtempr
 
+      w3i=0.
+      w2r=0.
+      w2i=0.
+      w3r=0.
       TWOPI=6.2831853072*FLOAT(ISIGN)
       IP0=2
       IP1=IP0*NPREV

Modified: trunk/ftpeak65.f
===================================================================
--- trunk/ftpeak65.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/ftpeak65.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -106,6 +106,8 @@
       jmax=0
       if(nafc.eq.1) jmax=25
       ssmax=0.
+      jpk=0 !Shut up compiler warnings. -db
+      ipk=0 !Shut up compiler warnings. -db
       do j=-jmax,jmax
          do i=-25,25
             ss=0.

Modified: trunk/gencw.f
===================================================================
--- trunk/gencw.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/gencw.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -4,7 +4,7 @@
 C  to an EME CW message.
 
       parameter (NMAX=150*11025)
-      character*22 msg,word12,word3,s1,s2,s3
+      character*22 msg,s1,s2,s3
       integer*2 iwave(NMAX)
       integer TRPeriod
       integer*1 idat(5000),idat1(460),idat2(200),idat3(200)

Modified: trunk/genwspr.f90
===================================================================
--- trunk/genwspr.f90	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/genwspr.f90	2008-07-04 14:44:52 UTC (rev 879)
@@ -1,108 +1,102 @@
-subroutine genwspr(message,samfacout,ntxdf,iwave,nwave,msgsent)
-
-!  Encode a WSPR message and generate the corresponding wavefile.
-
-  parameter (NMAX=120*12000)     !Max length of wave file
-  parameter (MAXSYM=176)
-  character*12 call1,call2
-  character*4 grid,grid2
-  character*22 message           !Message to be generated
-  integer*2 iwave(NMAX)          !Generated wave file
-  real*8 samfacout,fsample
-  integer*1 symbol(MAXSYM)
-  integer*1 data0(11),i1
-  integer npr3(162)
-  real pr3(162)
-  logical first,lbad1,lbad2
-  real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,tsymbol
-  character*22 msgsent           !Message sent
-  equivalence(i1,i4)
-  data npr3/                                    &amp;
-       1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0, &amp;
-       0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1, &amp;
-       0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1, &amp;
-       1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1, &amp;
-       0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0, &amp;
-       0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1, &amp;
-       0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1, &amp;
-       0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0, &amp;
-       0,0/
-
-  data first/.true./,idum/0/
-  save
-
-  nsym=162                               !Symbols per transmission
-  if(first) then
-     do i=1,nsym
-        pr3(i)=2*npr3(i)-1
-     enddo
-     pi=4.d0*atan(1.d0)
-     twopi=2.d0*pi
-     fsample=11025.d0
-     first=.false.
-  endif
-
-  call wqencode(message,ntype,data0)
-  nbytes=(50+31+7)/8
-  call encode232(data0,nbytes,symbol,MAXSYM)  !Convolutional encoding
-  call inter_mept(symbol,1)                   !Apply interleaving
-  call wqdecode(data0,msgsent,ntype2)
-
-  tsymbol=8192.d0/12000.d0
-  
-  dt=1.d0/fsample
-!  f0=1500 + ntxdf
-  f0=1270.46 + ntxdf
-  dfgen=12000.d0/8192.d0                     !1.4649 Hz
-  nsigs=1
-  snrdb=99.
-  if(snrdb.eq.10.0) nsigs=10
-  nwave=111*fsample
-  if(snrdb.le.10.0) nwave=NMAX
-
-  do isig=1,nsigs
-     if(nsigs.eq.1) snr=10.0**(0.05*(snrdb-1))   !Bandwidth correction?
-     fac=3000.0
-     if(snr.gt.1.0) fac=3000.0/snr
-     if(nsigs.eq.10) then
-        snr=10.0**(0.05*(-20-isig-1))
-        f0=1390 + 20*isig
-     endif
-!     t=-2.d0 - 0.1*(isig-1)
-     t=-0.2d0
-     phi=0.d0
-     j0=0
-
-     do i=1,nwave
-        t=t+dt
-        j=int(t/tsymbol) + 1                          !Symbol number
-        sig=0.
-        if(j.ge.1 .and. j.le.162) then
-           if(j.ne.j0) then
-              f=f0 + dfgen*(npr3(j)+2*symbol(j)-1.5)
-              j0=j
-              dphi=twopi*dt*f
-           endif
-           sig=0.9999
-        endif
-        phi=phi+dphi
-        if(snrdb.gt.50.0) then
-           n=32767.0*sin(phi)           !Normal transmission, signal only
-        else
-           if(isig.eq.1) then
-              n=fac*(gran(idum) + sig*snr*sin(phi))
-           else
-              n=iwave(i) + fac*sig*snr*sin(phi)
-           endif
-           if(n.gt.32767) n=32767
-           if(n.lt.-32767) n=-32767
-        endif
-        iwave(i)=n
-10      continue
-     enddo
-  enddo
-
-100 continue
-
-  return
-end subroutine genwspr
+subroutine genwspr(message,samfacout,ntxdf,iwave,nwave,msgsent)
+
+!  Encode a WSPR message and generate the corresponding wavefile.
+
+  parameter (NMAX=120*12000)     !Max length of wave file
+  parameter (MAXSYM=176)
+  character*22 message           !Message to be generated
+  integer*2 iwave(NMAX)          !Generated wave file
+  real*8 samfacout,fsample
+  integer*1 symbol(MAXSYM)
+  integer*1 data0(11),i1
+  integer npr3(162)
+  real pr3(162)
+  logical first
+  real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,tsymbol
+  character*22 msgsent           !Message sent
+  equivalence(i1,i4)
+  data npr3/                                    &amp;
+       1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0, &amp;
+       0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1, &amp;
+       0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1, &amp;
+       1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1, &amp;
+       0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0, &amp;
+       0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1, &amp;
+       0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1, &amp;
+       0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0, &amp;
+       0,0/
+
+  data first/.true./,idum/0/
+  save
+
+  nsym=162                               !Symbols per transmission
+  if(first) then
+     do i=1,nsym
+        pr3(i)=2*npr3(i)-1
+     enddo
+     pi=4.d0*atan(1.d0)
+     twopi=2.d0*pi
+     fsample=11025.d0
+     first=.false.
+  endif
+
+  call wqencode(message,ntype,data0)
+  nbytes=(50+31+7)/8
+  call encode232(data0,nbytes,symbol,MAXSYM)  !Convolutional encoding
+  call inter_mept(symbol,1)                   !Apply interleaving
+  call wqdecode(data0,msgsent,ntype2)
+
+  tsymbol=8192.d0/12000.d0
+  
+  dt=1.d0/fsample
+!  f0=1500 + ntxdf
+  f0=1270.46 + ntxdf
+  dfgen=12000.d0/8192.d0                     !1.4649 Hz
+  nsigs=1
+  snrdb=99.
+  if(snrdb.eq.10.0) nsigs=10
+  nwave=111*fsample
+  if(snrdb.le.10.0) nwave=NMAX
+
+  do isig=1,nsigs
+     if(nsigs.eq.1) snr=10.0**(0.05*(snrdb-1))   !Bandwidth correction?
+     fac=3000.0
+     if(snr.gt.1.0) fac=3000.0/snr
+     if(nsigs.eq.10) then
+        snr=10.0**(0.05*(-20-isig-1))
+        f0=1390 + 20*isig
+     endif
+!     t=-2.d0 - 0.1*(isig-1)
+     t=-0.2d0
+     phi=0.d0
+     j0=0
+
+     do i=1,nwave
+        t=t+dt
+        j=int(t/tsymbol) + 1                          !Symbol number
+        sig=0.
+        if(j.ge.1 .and. j.le.162) then
+           if(j.ne.j0) then
+              f=f0 + dfgen*(npr3(j)+2*symbol(j)-1.5)
+              j0=j
+              dphi=twopi*dt*f
+           endif
+           sig=0.9999
+        endif
+        phi=phi+dphi
+        if(snrdb.gt.50.0) then
+           n=32767.0*sin(phi)           !Normal transmission, signal only
+        else
+           if(isig.eq.1) then
+              n=fac*(gran(idum) + sig*snr*sin(phi))
+           else
+              n=iwave(i) + fac*sig*snr*sin(phi)
+           endif
+           if(n.gt.32767) n=32767
+           if(n.lt.-32767) n=-32767
+        endif
+        iwave(i)=n
+     enddo
+  enddo
+  return
+end subroutine genwspr


Property changes on: trunk/genwspr.f90
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/getfile.F90
===================================================================
--- trunk/getfile.F90	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/getfile.F90	2008-07-04 14:44:52 UTC (rev 879)
@@ -75,11 +75,15 @@
 
   ndiskdat=1
   mousebutton=0
-  go to 999
+  close(10)
+  return
 
+#ifdef CVF
 998 ierr=1001
 999 close(10)
-  return
+    return
+#endif
+
 end subroutine getfile
 
 subroutine check_endian

Modified: trunk/getsnr.f
===================================================================
--- trunk/getsnr.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/getsnr.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -2,6 +2,7 @@
 
       real x(nz)
 
+      ipk=0 !Shut up compiler warnings. -db
       smax=-1.e30
       do i=1,nz
          if(x(i).gt.smax) then

Modified: trunk/mept162a.f
===================================================================
--- trunk/mept162a.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/mept162a.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -1,101 +1,99 @@
-      subroutine mept162a(c2,jz,f0,cfile6,ndiag,minsync,mousedf,ndftol)
-
-C  Orchestrates the process of finding, synchronizing, and decoding 
-C  WSPR signals.
-
-      character*22 message
-      character*70 outfile
-      character*11 datetime
-      character*8 cfile6
-      logical first
-      real ps(-256:256)
-      real sstf(5,275)
-      real a(5)
-      complex c2(jz)
-      complex c2a(0:65535)
-      complex c3(45000),c4(45000)
-      data first/.true./
-      save
-
-C  Mix 1500 Hz +/- 100 Hz to baseband, and downsample by 1/32
-!      call mix162(id,npts,c2,jz,ps)
-
-      c2a(0:jz-1)=c2
-      c2a(jz:)=0.
-      nfft0=65536
-      nh0=nfft0/2
-      df0=375.0/nfft0
-      call fourt(c2a,65536,1,-1,1,0.0)
-      df2=128.0*df0
-      do k=-256,256
-         i=128*k
-         sq=0.
-         do n=-64,63
-            j=i+n
-            if(j.lt.0) j=j+nfft0
-            sq=sq + real(c2a(j))**2 + aimag(c2a(j))**2
-         enddo
-         ps(k)=1.e-8*sq
-      enddo
-
-C  Compute pixmap.dat
-!      call spec162(c2,jz)
-
-C  Look for sync patterns, get DF and DT
-      call sync162(c2,jz,ndftol,ps,sstf,kz)
-
-      do k=1,kz
-         snrsync=sstf(1,k)
-         snrx=sstf(2,k)
-         dtx=sstf(3,k)
-         dfx=sstf(4,k)
-         drift=sstf(5,k)
-         ndf=nint(f0-1270.46+dfx)
-!         write(*,3001) f0,dfx,ndf,mousedf,ndf-mousedf,ndftol
-! 3001    format(2f7.1,4i6)
-         if(abs(ndf-mousedf).gt.ndftol) go to 24
-         a(1)=-dfx
-         a(2)=-0.5*drift
-         a(3)=0.
-         call twkfreq(c2,c3,jz,a)                    !Remove drift
-
-         nsync=nint(snrsync)
-         nsnrx=nint(snrx)
-         if(nsnrx.lt.-33) nsnrx=-33
-         if(nsync.lt.0) nsync=0
-         message='                      '
-         if(nsync.ge.minsync .and. nsnrx.ge.-30) then      !### -31 dB limit?
-            dt=1.0/375
-            do idt=0,128
-               ii=(idt+1)/2
-               if(mod(idt,2).eq.1) ii=-ii
-               i1=nint((dtx+2.0)/dt) + ii !Start index for synced symbols
-               if(i1.ge.1) then
-                  c4(1:45000-i1+1)=c3(i1:45000)
-                  c4(jz-i1+2:)=0.
-               else
-                  c4(1:-i1+1)=0.
-                  c4(-i1+2:45000)=c3(1:45000+i1-1)
-               endif
-               call decode162(c4,jz,message,ncycles,metric,nerr)
-               if(message(1:6).ne.'      ') go to 23
-            enddo
-!            go to 24
- 23         width=0.
-!            call rect(c3,dtx,0.0,message,dfx2,width,pmax)
-            nf1=nint(-a(2))
-            if(ndiag.ne.0) then
-               write(11,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message,
-     +           ii,ncycles/81
-            else
-               write(11,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message
-            endif
-!            write(*,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message
- 1012       format(a6,i4,i4,f5.1,i6,i3,2x,a22,15x,i4,i6)
-            i1=index(message,' ')
-         endif
- 24      continue
-      enddo
-
-      return
-      end
+      subroutine mept162a(c2,jz,f0,cfile6,ndiag,minsync,mousedf,ndftol)
+
+C  Orchestrates the process of finding, synchronizing, and decoding 
+C  WSPR signals.
+
+      character*22 message
+      character*8 cfile6
+      logical first
+      real ps(-256:256)
+      real sstf(5,275)
+      real a(5)
+      complex c2(jz)
+      complex c2a(0:65535)
+      complex c3(45000),c4(45000)
+      data first/.true./
+      save
+
+C  Mix 1500 Hz +/- 100 Hz to baseband, and downsample by 1/32
+!      call mix162(id,npts,c2,jz,ps)
+
+      c2a(0:jz-1)=c2
+      c2a(jz:)=0.
+      nfft0=65536
+      nh0=nfft0/2
+      df0=375.0/nfft0
+      call fourt(c2a,65536,1,-1,1,0.0)
+      df2=128.0*df0
+      do k=-256,256
+         i=128*k
+         sq=0.
+         do n=-64,63
+            j=i+n
+            if(j.lt.0) j=j+nfft0
+            sq=sq + real(c2a(j))**2 + aimag(c2a(j))**2
+         enddo
+         ps(k)=1.e-8*sq
+      enddo
+
+C  Compute pixmap.dat
+!      call spec162(c2,jz)
+
+C  Look for sync patterns, get DF and DT
+      call sync162(c2,jz,ndftol,ps,sstf,kz)
+
+      do k=1,kz
+         snrsync=sstf(1,k)
+         snrx=sstf(2,k)
+         dtx=sstf(3,k)
+         dfx=sstf(4,k)
+         drift=sstf(5,k)
+         ndf=nint(f0-1270.46+dfx)
+!         write(*,3001) f0,dfx,ndf,mousedf,ndf-mousedf,ndftol
+! 3001    format(2f7.1,4i6)
+         if(abs(ndf-mousedf).gt.ndftol) go to 24
+         a(1)=-dfx
+         a(2)=-0.5*drift
+         a(3)=0.
+         call twkfreq(c2,c3,jz,a)                    !Remove drift
+
+         nsync=nint(snrsync)
+         nsnrx=nint(snrx)
+         if(nsnrx.lt.-33) nsnrx=-33
+         if(nsync.lt.0) nsync=0
+         message='                      '
+         if(nsync.ge.minsync .and. nsnrx.ge.-30) then      !### -31 dB limit?
+            dt=1.0/375
+            do idt=0,128
+               ii=(idt+1)/2
+               if(mod(idt,2).eq.1) ii=-ii
+               i1=nint((dtx+2.0)/dt) + ii !Start index for synced symbols
+               if(i1.ge.1) then
+                  c4(1:45000-i1+1)=c3(i1:45000)
+                  c4(jz-i1+2:)=0.
+               else
+                  c4(1:-i1+1)=0.
+                  c4(-i1+2:45000)=c3(1:45000+i1-1)
+               endif
+               call decode162(c4,jz,message,ncycles,metric,nerr)
+               if(message(1:6).ne.'      ') go to 23
+            enddo
+!            go to 24
+ 23         width=0.
+!            call rect(c3,dtx,0.0,message,dfx2,width,pmax)
+            nf1=nint(-a(2))
+            if(ndiag.ne.0) then
+               write(11,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message,
+     +           ii,ncycles/81
+            else
+               write(11,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message
+            endif
+!            write(*,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message
+ 1012       format(a6,i4,i4,f5.1,i6,i3,2x,a22,15x,i4,i6)
+            i1=index(message,' ')
+         endif
+ 24      continue
+      enddo
+
+      return
+      end


Property changes on: trunk/mept162a.f
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/pack50.f
===================================================================
--- trunk/pack50.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/pack50.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -1,27 +1,27 @@
-      subroutine pack50(n1,n2,dat)
-
-      integer*1 dat(11),i1
-      equivalence (i1,i4)
-
-      i4=iand(ishft(n1,-20),255)                !8 bits
-      dat(1)=i1
-      i4=iand(ishft(n1,-12),255)                 !8 bits
-      dat(2)=i1
-      i4=iand(ishft(n1, -4),255)                 !8 bits
-      dat(3)=i1
-      i4=16*iand(n1,15)+iand(ishft(n2,-18),15)   !4+4 bits
-      dat(4)=i1
-      i4=iand(ishft(n2,-10),255)                 !8 bits
-      dat(5)=i1
-      i4=iand(ishft(n2, -2),255)                 !8 bits
-      dat(6)=i1
-      i4=64*iand(n2,3)                           !2 bits
-      dat(7)=i1
-      dat(8)=0
-      dat(8)=0
-      dat(10)=0
-      dat(11)=0
-
-      return
-      end
-
+      subroutine pack50(n1,n2,dat)
+
+      integer*1 dat(11),i1
+      equivalence (i1,i4)
+
+      i4=iand(ishft(n1,-20),255)                !8 bits
+      dat(1)=i1
+      i4=iand(ishft(n1,-12),255)                 !8 bits
+      dat(2)=i1
+      i4=iand(ishft(n1, -4),255)                 !8 bits
+      dat(3)=i1
+      i4=16*iand(n1,15)+iand(ishft(n2,-18),15)   !4+4 bits
+      dat(4)=i1
+      i4=iand(ishft(n2,-10),255)                 !8 bits
+      dat(5)=i1
+      i4=iand(ishft(n2, -2),255)                 !8 bits
+      dat(6)=i1
+      i4=64*iand(n2,3)                           !2 bits
+      dat(7)=i1
+      dat(8)=0
+      dat(9)=0
+      dat(10)=0
+      dat(11)=0
+
+      return
+      end
+


Property changes on: trunk/pack50.f
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/ping.f
===================================================================
--- trunk/ping.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/ping.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -13,7 +13,8 @@
         snrlim=10.0**(0.1*slim) - 1.0
         sdown=10.0*log10(0.25*snrlim+1.0)
 
-        i0=0 !Shut up compiler warnings -db
+        i0=0 !Shut up compiler warnings. -db
+        tstart=0.0 !Shut up compiler warnings. -db
         do i=2,nz
            if(s(i).ge.slim .and. .not.inside) then
               i0=i

Modified: trunk/stdecode.f
===================================================================
--- trunk/stdecode.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/stdecode.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -25,6 +25,7 @@
 
       ia=(LTone*NBaud-DFTolerance)/df - 5.0
       ib=((LTone+3)*NBaud+DFTolerance)/df - 4.0
+      ipk=0 !Shut up compiler warnings. -db
       do j=1,nz
          smax=0.
          do i=ia,ib                      !Get the spectral peak
@@ -78,6 +79,7 @@
 
 C  Now check for redundant detections.  (Not sure, now, why I chose
 C  the time span 0.11 s.)
+            peak0=0.0 !Shut up compiler warnings. -db
             if(tstart-ts0.gt.0.11) then
                peak0=0.                 !If time diff&gt;0.11s, start fresh
             else

Modified: trunk/sync162.f
===================================================================
--- trunk/sync162.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/sync162.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -1,200 +1,199 @@
-      subroutine sync162(c2,jz,ndftol,ps,sstf,kz)
-
-C  Find MEPT_JT sync signals, with best-fit DT and DF.  
-
-      complex c2(jz)
-      parameter (NFFT=512)             !Length of FFTs
-      parameter (NH=NFFT/2)            !Length of power spectra
-      parameter (NSMAX=351)            !Number of half-symbol steps
-      parameter (NF0=136,NF1=10)
-      parameter (LAGMAX=26)
-      real psavg(-NH:NH)               !Average spectrum of whole record
-      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
-      real ps(-NH:NH)
-      real psmo(-NH:NH)
-      real freq(-NH:NH)
-      real p1(-NH:NH)
-      real drift(-NH:NH)
-      real dtx(-NH:NH)
-      integer keep0(-NH:NH)
-      integer keep(-NH:NH)
-      real a(5)
-      real sstf(5,275)
-      character*22 message
-      real tmp(275)
-      integer npr3(162)
-      real pr3(162)
-      data npr3/
-     +  1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     +  0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     +  0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     +  1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     +  0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     +  0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     +  0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     +  0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     +  0,0/
-      save
-
-      nsym=162
-      do i=1,nsym
-         pr3(i)=2*npr3(i)-1
-      enddo
-
-C  Do FFTs of twice symbol length, stepped by half symbols.  
-      nq=NFFT/4
-      nsteps=jz/nq - 1
-      df=375.0/nfft
-      dt=1.0/375.0
-      call zero(psavg,NFFT+1)
-
-C  Compute power spectrum for each step, and get average
-      do j=1,nsteps
-         k=(j-1)*nq + 1
-         call ps162(c2(k),s2(-NH,j))
-         call add(psavg,s2(-NH,j),psavg,NFFT)
-      enddo
-
-! Normalize and subtract baseline from psavg.
-      call pctile(psavg(-136),tmp,273,35,base)
-      psavg=psavg/base - 1.0
-      base=base/351.0
-      s2=s2/base - 1.0
-
-! Boxcar-smooth the average spectrum over the WSPR signal bandwidth.
-      do i=-NH+3,NH-3
-         psmo(i)=0.
-         do k=-3,3
-            psmo(i)=psmo(i)+ps(i+k)
-         enddo
-         psmo(i)=psmo(i)/7.0
-      enddo
-
-! Mark potential suspects for WSPR signals.  
-! (Keep only the best one within a surrounding range of +/- 8 bins.)
-
-      plimit=0.                      !### Are the plimit values OK? ###
-      do i=-NF0,NF0
-         keep0(i)=0
-         keep(i)=0
-         ia=i-4
-         ib=i+4
-         pmax=-1.e30
-         do ii=ia,ib
-            if(psmo(ii).gt.pmax) then
-               ipk=ii
-               pmax=psmo(ii)
-            endif
-         enddo
-         if(ipk.eq.i .and. pmax.ge.plimit) then
-            keep0(i)=1
-! Kill all smaller peaks leading up to this maximum.
-            do ii=ia,i-1
-               keep0(ii)=0
-            enddo
-         endif
-      enddo
-
-! Now mark the bins +/- 1 from each one already marked.
-      do i=-NF0+1,NF0-1
-         if(keep0(i).eq.1) then
-            keep(i-1)=1
-            keep(i)=1
-            keep(i+1)=1
-         endif
-      enddo
-
-! Now do the main search over DT, DF, and drift.  (Do CCFs in all marked
-! frequency bins and over a range of reasonable fdot values and lags.)
-      p1=0.
-      do i=-NF0,NF0
-         if(keep(i).eq.0) go to 10
-         smax=0.
-         do k=-NF1,NF1
-            if(abs(k).ne.1) then
-               do lag=0,LAGMAX
-                  sum=0.
-                  n=lag-1
-                  do j=1,162
-                     n=n+2
-                     ii=i + nint(k*(j-81)/162.0)
-                     x=max(s2(ii-1,n),s2(ii+3,n)) - 
-     +                    max(s2(ii-3,n),s2(ii+1,n))
-                     sum=sum + x*pr3(j)
-                  enddo
-                  if(sum.gt.smax) then
-                     kpk=k
-                     lagpk=lag
-                     smax=sum
-                  endif
-               enddo
-            endif
-         enddo
-
-! Save the CCF value, frequency, drift rate, and DT.
-         p1(i)=smax
-         freq(i)=df*i
-         drift(i)=df*kpk
-         dtx(i)=128.0*dt*lagpk
- 10      continue
-      enddo
-
-! Eliminate potential duplicates and peaks smaller than plimit.
-      keep=0
-      plimit=10.0*plimit                             !### ??? ###
-      do i=-NF0,NF0
-         ia=max(-NF0,i-8)
-         ib=min(NF0,i+8)
-         pmax=-1.e30
-         do ii=ia,ib
-            if(p1(ii).gt.pmax) then
-               ipk=ii
-               pmax=p1(ii)
-            endif
-         enddo
-         if(ipk.eq.i .and. pmax.ge.plimit) then
-            keep(i)=1
-            do ii=ia,i-1
-               keep(ii)=0
-            enddo
-         endif
-      enddo
-
-! Compress the candidate list, saving only the potentially important ones.
-! Recalibrate sync indicator p1 on a dB scale.  
-! (NB: p1 sould be compared with snrx!)
-      k=0
-      do i=-NF0,NF0
-         if(keep(i).ne.0) then
-            x=10.0*log10(p1(i)) - 22       !### ??? ###
-            if(x.ge.0.5) then
-               k=k+1
-               p1(k)=x
-               freq(k)=freq(i)
-               drift(k)=drift(i)
-               dtx(k)=dtx(i) - 2.0
-            endif
-         endif
-      enddo
-      kz=k
-
-      do k=1,kz
-         a(1)=-freq(k) + 1.4648   !### Why is this offset necessary? ###
-         a(2)=-0.5*drift(k)
-         a(3)=0.
-         lagpk=nint((dtx(k)+2)/(128*dt))
-         lag1=max(-200,8*lagpk-16)
-         lag2=min(200,8*lagpk+16)
-         ccf=-fchisq(c2,jz,375.0,a,lag1,lag2,ccfbest,dtbest)
-         ipk=nint(freq(k)/df)
-         snrx=db(max(psavg(ipk),0.0001)) - 26.5         !Empirical
-         sstf(1,k)=p1(k)
-         sstf(2,k)=snrx
-         sstf(3,k)=dtbest-2.0
-         sstf(4,k)=freq(k)
-         sstf(5,k)=drift(k)
-      enddo
-      
-      return
-      end
-
+      subroutine sync162(c2,jz,ndftol,ps,sstf,kz)
+
+C  Find MEPT_JT sync signals, with best-fit DT and DF.  
+
+      complex c2(jz)
+      parameter (NFFT=512)             !Length of FFTs
+      parameter (NH=NFFT/2)            !Length of power spectra
+      parameter (NSMAX=351)            !Number of half-symbol steps
+      parameter (NF0=136,NF1=10)
+      parameter (LAGMAX=26)
+      real psavg(-NH:NH)               !Average spectrum of whole record
+      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
+      real ps(-NH:NH)
+      real psmo(-NH:NH)
+      real freq(-NH:NH)
+      real p1(-NH:NH)
+      real drift(-NH:NH)
+      real dtx(-NH:NH)
+      integer keep0(-NH:NH)
+      integer keep(-NH:NH)
+      real a(5)
+      real sstf(5,275)
+      real tmp(275)
+      integer npr3(162)
+      real pr3(162)
+      data npr3/
+     +  1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
+     +  0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
+     +  0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
+     +  1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
+     +  0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
+     +  0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
+     +  0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
+     +  0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
+     +  0,0/
+      save
+
+      nsym=162
+      do i=1,nsym
+         pr3(i)=2*npr3(i)-1
+      enddo
+
+C  Do FFTs of twice symbol length, stepped by half symbols.  
+      nq=NFFT/4
+      nsteps=jz/nq - 1
+      df=375.0/nfft
+      dt=1.0/375.0
+      call zero(psavg,NFFT+1)
+
+C  Compute power spectrum for each step, and get average
+      do j=1,nsteps
+         k=(j-1)*nq + 1
+         call ps162(c2(k),s2(-NH,j))
+         call add(psavg,s2(-NH,j),psavg,NFFT)
+      enddo
+
+! Normalize and subtract baseline from psavg.
+      call pctile(psavg(-136),tmp,273,35,base)
+      psavg=psavg/base - 1.0
+      base=base/351.0
+      s2=s2/base - 1.0
+
+! Boxcar-smooth the average spectrum over the WSPR signal bandwidth.
+      do i=-NH+3,NH-3
+         psmo(i)=0.
+         do k=-3,3
+            psmo(i)=psmo(i)+ps(i+k)
+         enddo
+         psmo(i)=psmo(i)/7.0
+      enddo
+
+! Mark potential suspects for WSPR signals.  
+! (Keep only the best one within a surrounding range of +/- 8 bins.)
+
+      plimit=0.                      !### Are the plimit values OK? ###
+      do i=-NF0,NF0
+         keep0(i)=0
+         keep(i)=0
+         ia=i-4
+         ib=i+4
+         pmax=-1.e30
+         do ii=ia,ib
+            if(psmo(ii).gt.pmax) then
+               ipk=ii
+               pmax=psmo(ii)
+            endif
+         enddo
+         if(ipk.eq.i .and. pmax.ge.plimit) then
+            keep0(i)=1
+! Kill all smaller peaks leading up to this maximum.
+            do ii=ia,i-1
+               keep0(ii)=0
+            enddo
+         endif
+      enddo
+
+! Now mark the bins +/- 1 from each one already marked.
+      do i=-NF0+1,NF0-1
+         if(keep0(i).eq.1) then
+            keep(i-1)=1
+            keep(i)=1
+            keep(i+1)=1
+         endif
+      enddo
+
+! Now do the main search over DT, DF, and drift.  (Do CCFs in all marked
+! frequency bins and over a range of reasonable fdot values and lags.)
+      p1=0.
+      do i=-NF0,NF0
+         if(keep(i).eq.0) go to 10
+         smax=0.
+         do k=-NF1,NF1
+            if(abs(k).ne.1) then
+               do lag=0,LAGMAX
+                  sum=0.
+                  n=lag-1
+                  do j=1,162
+                     n=n+2
+                     ii=i + nint(k*(j-81)/162.0)
+                     x=max(s2(ii-1,n),s2(ii+3,n)) - 
+     +                    max(s2(ii-3,n),s2(ii+1,n))
+                     sum=sum + x*pr3(j)
+                  enddo
+                  if(sum.gt.smax) then
+                     kpk=k
+                     lagpk=lag
+                     smax=sum
+                  endif
+               enddo
+            endif
+         enddo
+
+! Save the CCF value, frequency, drift rate, and DT.
+         p1(i)=smax
+         freq(i)=df*i
+         drift(i)=df*kpk
+         dtx(i)=128.0*dt*lagpk
+ 10      continue
+      enddo
+
+! Eliminate potential duplicates and peaks smaller than plimit.
+      keep=0
+      plimit=10.0*plimit                             !### ??? ###
+      do i=-NF0,NF0
+         ia=max(-NF0,i-8)
+         ib=min(NF0,i+8)
+         pmax=-1.e30
+         do ii=ia,ib
+            if(p1(ii).gt.pmax) then
+               ipk=ii
+               pmax=p1(ii)
+            endif
+         enddo
+         if(ipk.eq.i .and. pmax.ge.plimit) then
+            keep(i)=1
+            do ii=ia,i-1
+               keep(ii)=0
+            enddo
+         endif
+      enddo
+
+! Compress the candidate list, saving only the potentially important ones.
+! Recalibrate sync indicator p1 on a dB scale.  
+! (NB: p1 sould be compared with snrx!)
+      k=0
+      do i=-NF0,NF0
+         if(keep(i).ne.0) then
+            x=10.0*log10(p1(i)) - 22       !### ??? ###
+            if(x.ge.0.5) then
+               k=k+1
+               p1(k)=x
+               freq(k)=freq(i)
+               drift(k)=drift(i)
+               dtx(k)=dtx(i) - 2.0
+            endif
+         endif
+      enddo
+      kz=k
+
+      do k=1,kz
+         a(1)=-freq(k) + 1.4648   !### Why is this offset necessary? ###
+         a(2)=-0.5*drift(k)
+         a(3)=0.
+         lagpk=nint((dtx(k)+2)/(128*dt))
+         lag1=max(-200,8*lagpk-16)
+         lag2=min(200,8*lagpk+16)
+         ccf=-fchisq(c2,jz,375.0,a,lag1,lag2,ccfbest,dtbest)
+         ipk=nint(freq(k)/df)
+         snrx=db(max(psavg(ipk),0.0001)) - 26.5         !Empirical
+         sstf(1,k)=p1(k)
+         sstf(2,k)=snrx
+         sstf(3,k)=dtbest-2.0
+         sstf(4,k)=freq(k)
+         sstf(5,k)=drift(k)
+      enddo
+      
+      return
+      end
+


Property changes on: trunk/sync162.f
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/sync64.f
===================================================================
--- trunk/sync64.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/sync64.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -1,135 +1,134 @@
-      subroutine sync64(dat,jz,DFTolerance,NFreeze,MouseDF,
-     +  mode64,dtx,dfx,snrx,snrsync,ccfblue,ccfred1,flip,width)
-
-C  Synchronizes JT64 data, finding the best-fit DT and DF.  
-C  NB: at this stage, submodes ABC are processed in the same way.
-
-      parameter (NP2=30*11025)         !Size of data array
-      parameter (NFFTMAX=4096)         !Max length of FFTs
-      parameter (NHMAX=NFFTMAX/2)      !Max length of power spectra
-      parameter (NSMAX=160)            !Max number of half-symbol steps
-      integer DFTolerance              !Range of DF search
-      real dat(jz)
-      real psavg(NHMAX)                !Average spectrum of whole record
-      real s2(NHMAX,NSMAX)             !2d spectrum, stepped by half-symbols
-      real ccfblue(-5:540)             !CCF with pseudorandom sequence
-
-C  The value 450 is empirical:
-      real ccfred(-450:450)            !Peak of ccfblue, as function of freq
-      real ccfred1(-224:224)           !Peak of ccfblue, as function of freq
-      real ccf64(-224:224)
-      real tmp(450)
-      integer ic6(6)
-      integer isync(63)
-      data ic6/0,1,4,3,5,2/,idum/-1/
-      save
-
-C  Do FFTs of symbol length, stepped by half symbols.  Note that we have
-C  already downsampled the data by factor of 2.
-      nsym=63
-      nfft=4096
-      nsteps=2*jz/nfft - 1
-      nh=nfft/2
-      df=0.5*11025.0/nfft
-! Set up the JT64 sync pattern
-      isync=-1
-      do n=1,3
-         i0=11
-         if(n.eq.2) i0=28
-         if(n.eq.3) i0=46
-         do i=1,6
-            isync(i0+i)=ic6(i) + 6*(n-1)
-         enddo
-      enddo
-
-C  Compute power spectrum for each step and get average
-      call zero(psavg,nh)
-      do j=1,nsteps
-         k=(j-1)*nh + 1
-         call limit(dat(k),nfft)
-         call ps(dat(k),nfft,s2(1,j))
-         if(mode64.eq.4) call smooth(s2(1,j),nh)
-         call add(psavg,s2(1,j),psavg,nh)
-      enddo
-
-!      call flat1(psavg,s2,nh,nsteps,NHMAX,NSMAX)        !Flatten the spectra
-!      do i=1,nh
-!         write(42,4001) i*df,psavg(i)
-! 4001    format(2f10.3)
-!      enddo
-
-C  Find the best frequency channel for CCF
-      famin=3.
-      fbmax=2700.
-
-      fa=famin
-      fb=fbmax
-      if(NFreeze.eq.1) then
-         fa=max(famin,1270.46+MouseDF-DFTolerance)
-         fb=min(fbmax,1270.46+MouseDF+DFTolerance)
-      else
-         fa=max(famin,1270.46+MouseDF-600)
-         fb=min(fbmax,1270.46+MouseDF+600)
-      endif
-      ia=fa/df
-      ib=fb/df
-      i0=nint(1270.46/df)
-      syncbest=-1.e30
-      call zero(ccfred,745)
-      nsync=18
-
-C### Code from here to (almost) end of sync65 was deleted.  Must replace
-C### with code modified for JT64.
-
-      do i=ia,ib
-         do lag=-20,20
-            sum=0.
-            do j=1,nsym
-               if(isync(j).ge.0) then
-                  j0=2*j -1 + lag
-                  if(j0.ge.1 .and. j0.le.nsteps) then
-                     sum=sum + s2(2*isync(j)+i,j0)
-                  endif
-               endif
-            enddo
-            ccf64(lag)=sum/nsync
-            if(ccf64(lag).gt.syncbest) then
-               ipk=i
-               syncbest=ccf64(lag)
-            endif
-         enddo
-      enddo
-
-! Once more, at the best frequency
-      i=ipk
-      syncbest=-1.e30
-      rewind 41
-
-      dtstep=0.37151927
-      do lag=-20,20
-         sum=0.
-         do j=1,nsym
-            if(isync(j).ge.0) then
-               j0=2*j - 1 + lag
-               if(j0.ge.1 .and. j0.le.nsteps) then
-                  sum=sum + s2(2*isync(j)+i,j0)
-               endif
-            endif
-         enddo
-         ccf64(lag)=sum/nsync
-            if(ccf64(lag).gt.syncbest) then
-               lagpk=lag
-               syncbest=ccf64(lag)
-            endif
-         write(41,3001) lag,dtstep*lag,ccf64(lag)
- 3001    format(i5,2f10.3)
-         ccfred1(lag)=ccf64(lag)
-      enddo
-
-      dtbest=dtstep*lagpk
-      write(*,3002) syncbest,dtbest,(ipk-i0)*df
- 3002 format('Sync:',f6.1,'  DT:',f6.1,'   DF:',f6.1)
-
-      return
-      end
-
+      subroutine sync64(dat,jz,DFTolerance,NFreeze,MouseDF,
+     +  mode64,dtx,dfx,snrx,snrsync,ccfblue,ccfred1,flip,width)
+
+C  Synchronizes JT64 data, finding the best-fit DT and DF.  
+C  NB: at this stage, submodes ABC are processed in the same way.
+
+      parameter (NP2=30*11025)         !Size of data array
+      parameter (NFFTMAX=4096)         !Max length of FFTs
+      parameter (NHMAX=NFFTMAX/2)      !Max length of power spectra
+      parameter (NSMAX=160)            !Max number of half-symbol steps
+      integer DFTolerance              !Range of DF search
+      real dat(jz)
+      real psavg(NHMAX)                !Average spectrum of whole record
+      real s2(NHMAX,NSMAX)             !2d spectrum, stepped by half-symbols
+      real ccfblue(-5:540)             !CCF with pseudorandom sequence
+
+C  The value 450 is empirical:
+      real ccfred(-450:450)            !Peak of ccfblue, as function of freq
+      real ccfred1(-224:224)           !Peak of ccfblue, as function of freq
+      real ccf64(-224:224)
+      integer ic6(6)
+      integer isync(63)
+      data ic6/0,1,4,3,5,2/,idum/-1/
+      save
+
+C  Do FFTs of symbol length, stepped by half symbols.  Note that we have
+C  already downsampled the data by factor of 2.
+      nsym=63
+      nfft=4096
+      nsteps=2*jz/nfft - 1
+      nh=nfft/2
+      df=0.5*11025.0/nfft
+! Set up the JT64 sync pattern
+      isync=-1
+      do n=1,3
+         i0=11
+         if(n.eq.2) i0=28
+         if(n.eq.3) i0=46
+         do i=1,6
+            isync(i0+i)=ic6(i) + 6*(n-1)
+         enddo
+      enddo
+
+C  Compute power spectrum for each step and get average
+      call zero(psavg,nh)
+      do j=1,nsteps
+         k=(j-1)*nh + 1
+         call limit(dat(k),nfft)
+         call ps(dat(k),nfft,s2(1,j))
+         if(mode64.eq.4) call smooth(s2(1,j),nh)
+         call add(psavg,s2(1,j),psavg,nh)
+      enddo
+
+!      call flat1(psavg,s2,nh,nsteps,NHMAX,NSMAX)        !Flatten the spectra
+!      do i=1,nh
+!         write(42,4001) i*df,psavg(i)
+! 4001    format(2f10.3)
+!      enddo
+
+C  Find the best frequency channel for CCF
+      famin=3.
+      fbmax=2700.
+
+      fa=famin
+      fb=fbmax
+      if(NFreeze.eq.1) then
+         fa=max(famin,1270.46+MouseDF-DFTolerance)
+         fb=min(fbmax,1270.46+MouseDF+DFTolerance)
+      else
+         fa=max(famin,1270.46+MouseDF-600)
+         fb=min(fbmax,1270.46+MouseDF+600)
+      endif
+      ia=fa/df
+      ib=fb/df
+      i0=nint(1270.46/df)
+      syncbest=-1.e30
+      call zero(ccfred,745)
+      nsync=18
+
+C### Code from here to (almost) end of sync65 was deleted.  Must replace
+C### with code modified for JT64.
+
+      do i=ia,ib
+         do lag=-20,20
+            sum=0.
+            do j=1,nsym
+               if(isync(j).ge.0) then
+                  j0=2*j -1 + lag
+                  if(j0.ge.1 .and. j0.le.nsteps) then
+                     sum=sum + s2(2*isync(j)+i,j0)
+                  endif
+               endif
+            enddo
+            ccf64(lag)=sum/nsync
+            if(ccf64(lag).gt.syncbest) then
+               ipk=i
+               syncbest=ccf64(lag)
+            endif
+         enddo
+      enddo
+
+! Once more, at the best frequency
+      i=ipk
+      syncbest=-1.e30
+      rewind 41
+
+      dtstep=0.37151927
+      do lag=-20,20
+         sum=0.
+         do j=1,nsym
+            if(isync(j).ge.0) then
+               j0=2*j - 1 + lag
+               if(j0.ge.1 .and. j0.le.nsteps) then
+                  sum=sum + s2(2*isync(j)+i,j0)
+               endif
+            endif
+         enddo
+         ccf64(lag)=sum/nsync
+            if(ccf64(lag).gt.syncbest) then
+               lagpk=lag
+               syncbest=ccf64(lag)
+            endif
+         write(41,3001) lag,dtstep*lag,ccf64(lag)
+ 3001    format(i5,2f10.3)
+         ccfred1(lag)=ccf64(lag)
+      enddo
+
+      dtbest=dtstep*lagpk
+      write(*,3002) syncbest,dtbest,(ipk-i0)*df
+ 3002 format('Sync:',f6.1,'  DT:',f6.1,'   DF:',f6.1)
+
+      return
+      end
+


Property changes on: trunk/sync64.f
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/syncf1.f
===================================================================
--- trunk/syncf1.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/syncf1.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -58,6 +58,7 @@
       dftol=min(DFTolerance,25)
       if(nfreeze.eq.1) dftol=DFTolerance
 C  Find improved value for f0
+      ipk=0 !Shut up compiler warning -db
       smax=0.
       ia=(f0-dftol)/df
       ib=(f0+dftol)/df + 0.999

Modified: trunk/wqencode.f90
===================================================================
--- trunk/wqencode.f90	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/wqencode.f90	2008-07-04 14:44:52 UTC (rev 879)
@@ -1,344 +1,343 @@
-subroutine wqencode(msg,ntype,data0)
-
-!  Parse and encode a WSPR message.
-
-  parameter (MASK15=32767)
-  character*22 msg
-  character*12 call1,call2,callsign
-  character*4 grid
-  character*3 cdbm
-  character*9 name
-  character ccur*4,cxp*2
-  logical lbad1,lbad2
-  integer*1 data0(11)
-  integer nu(0:9)
-  data nu/0,-1,1,0,-1,2,1,0,-1,1/
-
-  read(msg,1001,end=1,err=1) ng,n1
-1001 format(z4,z7)
-  ntype=62
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)             !Pack 8 bits per byte, add tail
-  go to 900
-
-1  if(msg(1:6).eq.'73 DE ') go to 80
-  if(index(msg,' W ').gt.0 .and. index(msg,' DBD ').gt.0) go to 90
-  if(msg(1:4).eq.'QRZ ') go to 100
-  if(msg(1:8).eq.'PSE QSY ') go to 110
-  if(msg(1:3).eq.'WX ') go to 120
-
-! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
-  i1=index(msg,' ')
-  if(i1.lt.4 .or. i1.gt.7) go to 10
-  call1=msg(:i1-1)
-  grid=msg(i1+1:i1+4)
-  call packcall(call1,n1,lbad1)
-  call packgrid(grid,ng,lbad2)
-  if(lbad1 .or. lbad2) go to 10
-  ndbm=0
-  read(msg(i1+5:),*,err=10,end=800) ndbm
-  if(ndbm.lt.0 .or. ndbm.gt.60) go to 800
-  ndbm=ndbm+nu(mod(ndbm,10))
-  n2=128*ng + (ndbm+64)
-  call pack50(n1,n2,data0)
-  ntype=ndbm
-  go to 900
-
-! &quot;BestDX&quot; automated WSPR reply (type 1)
-10 if(i1.ne.5 .or. msg(5:8).ne.' DE ') go to 20
-  grid=msg(1:4)
-  call packgrid(grid,ng,lbad2)
-  if(lbad2) go to 800
-  call1=msg(9:)
-  call packcall(call1,n1,lbad1)
-  if(lbad1) go to 800
-  ntype=1
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)             !Pack 8 bits per byte, add tail
-  go to 900
-
-! CQ (msg #1; types 2, 4, 5)
-20  if(msg(1:3).ne.'CQ ') go to 30
-  if(index(msg,'/').le.0) then
-     i2=index(msg(4:),' ')
-     call1=msg(4:i2+3)
-     grid=msg(i2+4:)
-     call packcall(call1,n1,lbad1)
-     if(lbad1) go to 30
-     call packgrid(grid,ng,lbad2)
-     if(lbad2) go to 30
-     ntype=2
-     n2=128*ng + (ntype+64)
-     call pack50(n1,n2,data0)
-  else
-     ntype=4                                     ! or 5
-     call1=msg(4:)
-     call packpfx(call1,n1,ng,nadd)
-     ntype=ntype+nadd
-     n2=128*ng + ntype + 64
-     call pack50(n1,n2,data0)
-  endif
-  go to 900
-
-! Reply to CQ (msg #2; types 6,8,9,11)
-30 if(msg(1:1).ne.'&lt;' .and. msg(1:3).ne.'DE ') go to 40
-  if(index(msg,' RRR ').gt.0) go to 50
-  if(msg(1:1).eq.'&lt;') then
-     ntype=6
-     i1=index(msg,'&gt;')
-     call1=msg(2:i1-1)
-     read(msg(i1+1:),*,err=31,end=31) k,muf,ccur,cxp
-     go to 130
-31   call2=msg(i1+2:)
-     call hash(call1,i1-2,ih)
-     call packcall(call2,n1,lbad1)
-     n2=128*ih + (ntype+64)
-     call pack50(n1,n2,data0)
-  else
-     i1=index(msg(4:),' ')
-     call1=msg(4:i1+2)
-     if(index(msg,'/').le.0) then
-        ntype=8
-        ih=0
-        call packcall(call1,n1,lbad1)
-        grid=msg(i1+4:i1+7)
-        call packgrid(grid,ng,lbad2)
-        n2=128*ng + (ntype+64)
-        call pack50(n1,n2,data0)
-     else
-        ntype=9                                   ! or 11
-        call1=msg(4:)
-        call packpfx(call1,n1,ng,nadd)
-        ntype=ntype + 2*nadd
-        n2=128*ng + ntype + 64
-        call pack50(n1,n2,data0)
-     endif
-  endif
-  go to 900
-
-! Call(s) + report (msg #3; types -1 to -27)
-! Call(s) + R + report (msg #4; types -28 to -54)
-40 if(index(msg,' RRR').gt.0) go to 50
-  i1=index(msg,'&lt;')
-  if(i1.gt.0 .and. (i1.lt.5 .or. i1.gt.8)) go to 50
-  i2=index(msg,'/')
-  if(i2.gt.0 .and.i2.le.4) then
-     ntype=-10                                   ! -10 to -27
-     i0=index(msg,' ')
-     call1=msg(:i0-1)
-     call packpfx(call1,n1,ng,nadd)
-     ntype=ntype - 9*nadd
-     i2=index(msg,' ')
-     i3=index(msg,' R ')
-     if(i3.gt.0) i2=i2+2                            !-28 to -36
-     read(msg(i2+2:i2+2),*) nrpt
-     ntype=ntype - (nrpt-1)
-     if(i3.gt.0) ntype=ntype-27
-     n2=128*ng + ntype + 64
-     call pack50(n1,n2,data0)
-     go to 900
-  else if(i1.eq.0) then
-     go to 50
-  endif
-  call1=msg(:i1-2)                               !-1 to -9
-  i2=index(msg,'&gt;')
-  call2=msg(i1+1:i2-1)
-  call hash(call2,i2-i1-1,ih)
-  i3=index(msg,' R ')
-  if(i3.gt.0) i2=i2+2                            !-28 to -36
-  read(msg(i2+3:i2+3),*,end=42,err=42) nrpt
-  go to 43
-42 nrpt=1
-43 ntype=-nrpt
-  if(i3.gt.0) ntype=-(nrpt+27)
-  call packcall(call1,n1,lbad1)
-  n2=128*ih + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-50 i0=index(msg,'&lt;')
-  if(i0.le.0 .and. msg(1:3).ne.'DE ') go to 60
-  i3=index(msg,' RRR')
-  if(i3.le.0) go to 60
-! Call or calls and RRR (msg#5; type2 12,14,15,16)
-  i0=index(msg,'&lt;')
-  if(i0.eq.1) then
-     if(index(msg,'/').le.0) then
-        ntype=14
-        i1=index(msg,'&gt;')
-        call1=msg(2:i1-1)
-        call2=msg(i1+2:)
-        i2=index(call2,' ')
-        call2=call2(:i2-1)
-        call packcall(call2,n1,lbad1)
-        call hash(call1,i1-2,ih)
-        n2=128*ih + (ntype+64)
-        call pack50(n1,n2,data0)
-     else
-        stop '0002'
-     endif
-  else if(i0.ge.5 .and. i0.le.8) then
-     if(index(msg,'/').le.0) then
-        ntype=12
-        i1=index(msg,'&gt;')
-        call1=msg(:i0-2)
-        call2=msg(i0+1:i1-1)
-        call packcall(call1,n1,lbad1)
-        call hash(call2,i1-i0-1,ih)
-        n2=128*ih + (ntype+64)
-        call pack50(n1,n2,data0)
-     else
-        stop '0002'
-     endif
-  else
-     i1=index(msg(4:),' ')
-     call1=msg(4:i1+2)
-     if(index(msg,'/').le.0) then
-        ntype=9
-        grid=msg(i1+4:i1+7)
-     else
-        ntype=15                                   ! or 16
-        call1=msg(4:)
-        i0=index(call1,' ')
-        call1=call1(:i0-1)
-        call packpfx(call1,n1,ng,nadd)
-        ntype=ntype+nadd
-        n2=128*ng + ntype + 64
-        call pack50(n1,n2,data0)
-     endif
-  endif
-  go to 900
-
-! TNX &lt;name&gt; 73 GL (msg #6; type 18 ...)
-60 if(msg(1:4).ne.'TNX ') go to 70
-  ntype=18
-  n1=0
-  i2=index(msg(5:),' ')
-  call packname(msg(5:i2+4),i2-1,n1,ng)
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! TNX name 73 GL (msg #6; type -56 ...)
-70 if(msg(1:3).ne.'OP ') go to 80
-  ntype=-56
-  n1=0
-  i2=index(msg(4:),' ')
-  call packname(msg(4:i2+3),i2-1,n1,ng)
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! 73 DE call grid (msg #6; type 19)
-80 if(msg(1:6).ne.'73 DE ') go to 90
-  ntype=19
-  i1=index(msg(7:),' ')
-  call1=msg(7:)
-  if(index(call1,'/').le.0) then
-     i1=index(call1,' ')
-     grid=call1(i1+1:)
-     call1=call1(:i1-1)
-     call packcall(call1,n1,lbad1)
-     call packgrid(grid,ng,lbad2)
-     if(lbad1 .or. lbad2) go to 800
-     n2=128*ng + (ntype+64)
-     call pack50(n1,n2,data0)
-     go to 900
-  else
-     ntype=21                                   ! or 22
-     call packpfx(call1,n1,ng,nadd)
-     ntype=ntype + nadd
-     n2=128*ng + ntype + 64
-     call pack50(n1,n2,data0)
-     go to 900
-  endif
-
-! [pwr] W [gain] DBD [73 GL] (msg #6; types 24, 25)
-90  if(index(msg,' W ').le.0) go to 140
-  ntype=25
-  if(index(msg,' DBD 73 GL').gt.0) ntype=24
-  i1=index(msg,' ')
-  read(msg(:i1-1),*,err=800) watts
-  if(watts.ge.1.0) nwatts=watts
-  if(watts.lt.1.0) nwatts=3000 + nint(1000.*watts)
-  if(index(msg,'DIPOLE').gt.0) then
-     ndbd=30000
-  else if(index(msg,'VERTICAL').gt.0) then
-     ndbd=30001
-  else
-     i2=index(msg(i1+3:),' ')
-     read(msg(i1+3:i1+i2+1),*) ndbd
-  endif
-  n1=nwatts
-  ng=ndbd + 32
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! QRZ call (msg #3; type 26)
-100 call1=msg(5:)
-  call packcall(call1,n1,lbad1)
-  if(lbad1) go to 800
-  ntype=26
-  n2=ntype+64
-  call pack50(n1,n2,data0)
-  go to 900
-
-! PSE QSY [nnn] KHZ (msg #6; type 28)
-110 ntype=28
-  read(msg(9:),*) n1
-  n2=ntype+64
-  call pack50(n1,n2,data0)
-  go to 900
-
-! WX wx temp C|F wind (msg #6; type 29)
-120 ntype=29
-  if(index(msg,' SUNNY ').gt.0) then
-     i1=10
-     n1=10000
-  else if(index(msg,' CLOUDY ').gt.0) then
-     i1=11
-     n1=20000
-  else if(index(msg,' RAIN ').gt.0) then
-     i1=9
-     n1=30000
-  else if(index(msg,' SNOW ').gt.0) then
-     i1=9
-     n1=40000
-  endif
-  read(msg(i1:),*) ntemp
-  ntemp=ntemp+100
-  i1=index(msg,' C ')
-  if(i1.gt.0) ntemp=ntemp+1000
-  n1=n1+ntemp
-  if(index(msg,' CALM').gt.0) ng=1
-  if(index(msg,' BREEZES').gt.0) ng=2
-  if(index(msg,' WINDY').gt.0) ng=3
-  if(index(msg,' DRY').gt.0) ng=4
-  if(index(msg,' HUMID').gt.0) ng=5
-
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! Solar/geomagnetic/ionospheric data
-130 ntype=63
-  call packprop(k,muf,ccur,cxp,n1)
-  call hash(call1,i1-2,ih)
-  n2=128*ih + ntype + 64 
-  call pack50(n1,n2,data0)
-  go to 900
-
-! Plain text
-140  ntype=-57
-  call packtext2(msg(:8),n1,ng)
-  n2=128*ng + ntype + 64
-  call pack50(n1,n2,data0)
-  go to 900
-
-800 continue
-! print*,'Error in structure of Tx message'
-
-900 continue
-  return
-end subroutine wqencode
+subroutine wqencode(msg,ntype,data0)
+
+!  Parse and encode a WSPR message.
+
+  parameter (MASK15=32767)
+  character*22 msg
+  character*12 call1,call2
+  character*4 grid
+!  character*9 name
+  character ccur*4,cxp*2
+  logical lbad1,lbad2
+  integer*1 data0(11)
+  integer nu(0:9)
+  data nu/0,-1,1,0,-1,2,1,0,-1,1/
+
+  read(msg,1001,end=1,err=1) ng,n1
+1001 format(z4,z7)
+  ntype=62
+  n2=128*ng + (ntype+64)
+  call pack50(n1,n2,data0)             !Pack 8 bits per byte, add tail
+  go to 900
+
+1  if(msg(1:6).eq.'73 DE ') go to 80
+  if(index(msg,' W ').gt.0 .and. index(msg,' DBD ').gt.0) go to 90
+  if(msg(1:4).eq.'QRZ ') go to 100
+  if(msg(1:8).eq.'PSE QSY ') go to 110
+  if(msg(1:3).eq.'WX ') go to 120
+
+! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
+  i1=index(msg,' ')
+  if(i1.lt.4 .or. i1.gt.7) go to 10
+  call1=msg(:i1-1)
+  grid=msg(i1+1:i1+4)
+  call packcall(call1,n1,lbad1)
+  call packgrid(grid,ng,lbad2)
+  if(lbad1 .or. lbad2) go to 10
+  ndbm=0
+  read(msg(i1+5:),*,err=10,end=800) ndbm
+  if(ndbm.lt.0 .or. ndbm.gt.60) go to 800
+  ndbm=ndbm+nu(mod(ndbm,10))
+  n2=128*ng + (ndbm+64)
+  call pack50(n1,n2,data0)
+  ntype=ndbm
+  go to 900
+
+! &quot;BestDX&quot; automated WSPR reply (type 1)
+10 if(i1.ne.5 .or. msg(5:8).ne.' DE ') go to 20
+  grid=msg(1:4)
+  call packgrid(grid,ng,lbad2)
+  if(lbad2) go to 800
+  call1=msg(9:)
+  call packcall(call1,n1,lbad1)
+  if(lbad1) go to 800
+  ntype=1
+  n2=128*ng + (ntype+64)
+  call pack50(n1,n2,data0)             !Pack 8 bits per byte, add tail
+  go to 900
+
+! CQ (msg #1; types 2, 4, 5)
+20  if(msg(1:3).ne.'CQ ') go to 30
+  if(index(msg,'/').le.0) then
+     i2=index(msg(4:),' ')
+     call1=msg(4:i2+3)
+     grid=msg(i2+4:)
+     call packcall(call1,n1,lbad1)
+     if(lbad1) go to 30
+     call packgrid(grid,ng,lbad2)
+     if(lbad2) go to 30
+     ntype=2
+     n2=128*ng + (ntype+64)
+     call pack50(n1,n2,data0)
+  else
+     ntype=4                                     ! or 5
+     call1=msg(4:)
+     call packpfx(call1,n1,ng,nadd)
+     ntype=ntype+nadd
+     n2=128*ng + ntype + 64
+     call pack50(n1,n2,data0)
+  endif
+  go to 900
+
+! Reply to CQ (msg #2; types 6,8,9,11)
+30 if(msg(1:1).ne.'&lt;' .and. msg(1:3).ne.'DE ') go to 40
+  if(index(msg,' RRR ').gt.0) go to 50
+  if(msg(1:1).eq.'&lt;') then
+     ntype=6
+     i1=index(msg,'&gt;')
+     call1=msg(2:i1-1)
+     read(msg(i1+1:),*,err=31,end=31) k,muf,ccur,cxp
+     go to 130
+31   call2=msg(i1+2:)
+     call hash(call1,i1-2,ih)
+     call packcall(call2,n1,lbad1)
+     n2=128*ih + (ntype+64)
+     call pack50(n1,n2,data0)
+  else
+     i1=index(msg(4:),' ')
+     call1=msg(4:i1+2)
+     if(index(msg,'/').le.0) then
+        ntype=8
+        ih=0
+        call packcall(call1,n1,lbad1)
+        grid=msg(i1+4:i1+7)
+        call packgrid(grid,ng,lbad2)
+        n2=128*ng + (ntype+64)
+        call pack50(n1,n2,data0)
+     else
+        ntype=9                                   ! or 11
+        call1=msg(4:)
+        call packpfx(call1,n1,ng,nadd)
+        ntype=ntype + 2*nadd
+        n2=128*ng + ntype + 64
+        call pack50(n1,n2,data0)
+     endif
+  endif
+  go to 900
+
+! Call(s) + report (msg #3; types -1 to -27)
+! Call(s) + R + report (msg #4; types -28 to -54)
+40 if(index(msg,' RRR').gt.0) go to 50
+  i1=index(msg,'&lt;')
+  if(i1.gt.0 .and. (i1.lt.5 .or. i1.gt.8)) go to 50
+  i2=index(msg,'/')
+  if(i2.gt.0 .and.i2.le.4) then
+     ntype=-10                                   ! -10 to -27
+     i0=index(msg,' ')
+     call1=msg(:i0-1)
+     call packpfx(call1,n1,ng,nadd)
+     ntype=ntype - 9*nadd
+     i2=index(msg,' ')
+     i3=index(msg,' R ')
+     if(i3.gt.0) i2=i2+2                            !-28 to -36
+     read(msg(i2+2:i2+2),*) nrpt
+     ntype=ntype - (nrpt-1)
+     if(i3.gt.0) ntype=ntype-27
+     n2=128*ng + ntype + 64
+     call pack50(n1,n2,data0)
+     go to 900
+  else if(i1.eq.0) then
+     go to 50
+  endif
+  call1=msg(:i1-2)                               !-1 to -9
+  i2=index(msg,'&gt;')
+  call2=msg(i1+1:i2-1)
+  call hash(call2,i2-i1-1,ih)
+  i3=index(msg,' R ')
+  if(i3.gt.0) i2=i2+2                            !-28 to -36
+  read(msg(i2+3:i2+3),*,end=42,err=42) nrpt
+  go to 43
+42 nrpt=1
+43 ntype=-nrpt
+  if(i3.gt.0) ntype=-(nrpt+27)
+  call packcall(call1,n1,lbad1)
+  n2=128*ih + (ntype+64)
+  call pack50(n1,n2,data0)
+  go to 900
+
+50 i0=index(msg,'&lt;')
+  if(i0.le.0 .and. msg(1:3).ne.'DE ') go to 60
+  i3=index(msg,' RRR')
+  if(i3.le.0) go to 60
+! Call or calls and RRR (msg#5; type2 12,14,15,16)
+  i0=index(msg,'&lt;')
+  if(i0.eq.1) then
+     if(index(msg,'/').le.0) then
+        ntype=14
+        i1=index(msg,'&gt;')
+        call1=msg(2:i1-1)
+        call2=msg(i1+2:)
+        i2=index(call2,' ')
+        call2=call2(:i2-1)
+        call packcall(call2,n1,lbad1)
+        call hash(call1,i1-2,ih)
+        n2=128*ih + (ntype+64)
+        call pack50(n1,n2,data0)
+     else
+        stop '0002'
+     endif
+  else if(i0.ge.5 .and. i0.le.8) then
+     if(index(msg,'/').le.0) then
+        ntype=12
+        i1=index(msg,'&gt;')
+        call1=msg(:i0-2)
+        call2=msg(i0+1:i1-1)
+        call packcall(call1,n1,lbad1)
+        call hash(call2,i1-i0-1,ih)
+        n2=128*ih + (ntype+64)
+        call pack50(n1,n2,data0)
+     else
+        stop '0002'
+     endif
+  else
+     i1=index(msg(4:),' ')
+     call1=msg(4:i1+2)
+     if(index(msg,'/').le.0) then
+        ntype=9
+        grid=msg(i1+4:i1+7)
+     else
+        ntype=15                                   ! or 16
+        call1=msg(4:)
+        i0=index(call1,' ')
+        call1=call1(:i0-1)
+        call packpfx(call1,n1,ng,nadd)
+        ntype=ntype+nadd
+        n2=128*ng + ntype + 64
+        call pack50(n1,n2,data0)
+     endif
+  endif
+  go to 900
+
+! TNX &lt;name&gt; 73 GL (msg #6; type 18 ...)
+60 if(msg(1:4).ne.'TNX ') go to 70
+  ntype=18
+  n1=0
+  i2=index(msg(5:),' ')
+  call packname(msg(5:i2+4),i2-1,n1,ng)
+  n2=128*ng + (ntype+64)
+  call pack50(n1,n2,data0)
+  go to 900
+
+! TNX name 73 GL (msg #6; type -56 ...)
+70 if(msg(1:3).ne.'OP ') go to 80
+  ntype=-56
+  n1=0
+  i2=index(msg(4:),' ')
+  call packname(msg(4:i2+3),i2-1,n1,ng)
+  n2=128*ng + (ntype+64)
+  call pack50(n1,n2,data0)
+  go to 900
+
+! 73 DE call grid (msg #6; type 19)
+80 if(msg(1:6).ne.'73 DE ') go to 90
+  ntype=19
+  i1=index(msg(7:),' ')
+  call1=msg(7:)
+  if(index(call1,'/').le.0) then
+     i1=index(call1,' ')
+     grid=call1(i1+1:)
+     call1=call1(:i1-1)
+     call packcall(call1,n1,lbad1)
+     call packgrid(grid,ng,lbad2)
+     if(lbad1 .or. lbad2) go to 800
+     n2=128*ng + (ntype+64)
+     call pack50(n1,n2,data0)
+     go to 900
+  else
+     ntype=21                                   ! or 22
+     call packpfx(call1,n1,ng,nadd)
+     ntype=ntype + nadd
+     n2=128*ng + ntype + 64
+     call pack50(n1,n2,data0)
+     go to 900
+  endif
+
+! [pwr] W [gain] DBD [73 GL] (msg #6; types 24, 25)
+90  if(index(msg,' W ').le.0) go to 140
+  ntype=25
+  if(index(msg,' DBD 73 GL').gt.0) ntype=24
+  i1=index(msg,' ')
+  read(msg(:i1-1),*,err=800) watts
+  if(watts.ge.1.0) nwatts=watts
+  if(watts.lt.1.0) nwatts=3000 + nint(1000.*watts)
+  if(index(msg,'DIPOLE').gt.0) then
+     ndbd=30000
+  else if(index(msg,'VERTICAL').gt.0) then
+     ndbd=30001
+  else
+     i2=index(msg(i1+3:),' ')
+     read(msg(i1+3:i1+i2+1),*) ndbd
+  endif
+  n1=nwatts
+  ng=ndbd + 32
+  n2=128*ng + (ntype+64)
+  call pack50(n1,n2,data0)
+  go to 900
+
+! QRZ call (msg #3; type 26)
+100 call1=msg(5:)
+  call packcall(call1,n1,lbad1)
+  if(lbad1) go to 800
+  ntype=26
+  n2=ntype+64
+  call pack50(n1,n2,data0)
+  go to 900
+
+! PSE QSY [nnn] KHZ (msg #6; type 28)
+110 ntype=28
+  read(msg(9:),*) n1
+  n2=ntype+64
+  call pack50(n1,n2,data0)
+  go to 900
+
+! WX wx temp C|F wind (msg #6; type 29)
+120 ntype=29
+  if(index(msg,' SUNNY ').gt.0) then
+     i1=10
+     n1=10000
+  else if(index(msg,' CLOUDY ').gt.0) then
+     i1=11
+     n1=20000
+  else if(index(msg,' RAIN ').gt.0) then
+     i1=9
+     n1=30000
+  else if(index(msg,' SNOW ').gt.0) then
+     i1=9
+     n1=40000
+  endif
+  read(msg(i1:),*) ntemp
+  ntemp=ntemp+100
+  i1=index(msg,' C ')
+  if(i1.gt.0) ntemp=ntemp+1000
+  n1=n1+ntemp
+  if(index(msg,' CALM').gt.0) ng=1
+  if(index(msg,' BREEZES').gt.0) ng=2
+  if(index(msg,' WINDY').gt.0) ng=3
+  if(index(msg,' DRY').gt.0) ng=4
+  if(index(msg,' HUMID').gt.0) ng=5
+
+  n2=128*ng + (ntype+64)
+  call pack50(n1,n2,data0)
+  go to 900
+
+! Solar/geomagnetic/ionospheric data
+130 ntype=63
+  call packprop(k,muf,ccur,cxp,n1)
+  call hash(call1,i1-2,ih)
+  n2=128*ih + ntype + 64 
+  call pack50(n1,n2,data0)
+  go to 900
+
+! Plain text
+140  ntype=-57
+  call packtext2(msg(:8),n1,ng)
+  n2=128*ng + ntype + 64
+  call pack50(n1,n2,data0)
+  go to 900
+
+800 continue
+! print*,'Error in structure of Tx message'
+
+900 continue
+  return
+end subroutine wqencode


Property changes on: trunk/wqencode.f90
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/wsjt64.f
===================================================================
--- trunk/wsjt64.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/wsjt64.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -1,113 +1,113 @@
-      subroutine wsjt64(dat,npts,cfile6,NClearAve,MinSigdB,
-     +  DFTolerance,NFreeze,NAFC,mode64,Nseg,MouseDF,NAgain,
-     +  ndepth,nchallenge,neme,idf,idfsh,mycall,hiscall,hisgrid,
-     +  lumsg,lcum,nspecial,ndf,nstest,dfsh,
-     +  snrsh,NSyncOK,ccfblue,ccfred,ndiag,nwsh)
-
-C  Orchestrates the process of decoding JT64 messages, using data that
-C  have been 2x downsampled.  The search for shorthand messages has
-C  already been done.
-
-      real dat(npts)                        !Raw data
-      integer DFTolerance
-      logical first
-      logical lcum
-      character decoded*22,cfile6*6,special*5,cooo*3
-      character*22 avemsg1,avemsg2,deepmsg
-      character*67 line,ave1,ave2
-      character*1 csync,c1
-      character*12 mycall
-      character*12 hiscall
-      character*6 hisgrid
-      real ccfblue(-5:540),ccfred(-224:224)
-      integer itf(2,9)
-      include 'avecom.h'
-      data first/.true./,ns10/0/,ns20/0/
-      data itf/0,0, 1,0, -1,0, 0,-1, 0,1, 1,-1, 1,1, -1,-1, -1,1/
-      save
-
-      if(first) then
-         nsave=0
-         first=.false.
-         ave1=' '
-         ave2=' '
-      endif
-
-      naggressive=0
-      if(ndepth.ge.2) naggressive=1
-      nq1=3
-      nq2=6
-      if(naggressive.eq.1) nq1=1
-
-      if(NClearAve.ne.0) then
-         nsave=0                        !Clear the averaging accumulators
-         ns10=0
-         ns20=0
-         ave1=' '
-         ave2=' '
-      endif
-      if(MinSigdB.eq.99 .or. MinSigdB.eq.-99) then
-         ns10=0                         !For Include/Exclude ?
-         ns20=0
-      endif
-
-C  Attempt to synchronize: look for sync tone, get DF and DT.
-      call sync64(dat,npts,DFTolerance,NFreeze,MouseDF,
-     +    mode64,dtx,dfx,snrx,snrsync,ccfblue,ccfred,flip,width)
-      csync=' '
-      decoded='                      '
-      deepmsg='                      '
-      special='     '
-      cooo='   '
-      ncount=-1             !Flag for RS decode of current record
-      ncount1=-1            !Flag for RS Decode of ave1
-      ncount2=-1            !Flag for RS Decode of ave2
-      NSyncOK=0
-      nqual1=0
-      nqual2=0
-
-      if(nsave.lt.MAXAVE .and. (NAgain.eq.0 .or. NClearAve.eq.1)) 
-     +  nsave=nsave+1
-      if(nsave.le.0) go to 900          !Prevent bounds error
-
-      nflag(nsave)=0                    !Clear the &quot;good sync&quot; flag
-      iseg(nsave)=Nseg                  !Set the RX segment to 1 or 2
-      nsync=nint(snrsync-3.0)
-      nsnr=nint(snrx)
-      if(nsnr.lt.-30 .or. nsync.lt.0) nsync=0
-      nsnrlim=-32
-
-C  Good Sync takes precedence over a shorthand message:
-      if(nsync.ge.MinSigdB .and. nsnr.ge.nsnrlim .and.
-     +   nsync.ge.nstest) nstest=0
-
-      if(nstest.gt.0) then
-         dfx=dfsh
-         nsync=nstest
-         nsnr=snrsh
-         dtx=1.
-         ccfblue(-5)=-999.0
-         if(nspecial.eq.1) special='ATT  '
-         if(nspecial.eq.2) special='RO   '
-         if(nspecial.eq.3) special='RRR  '
-         if(nspecial.eq.4) special='73   '
-         NSyncOK=1              !Mark this RX file as good (for &quot;Save Decoded&quot;)
-         if(NFreeze.eq.0 .or. DFTolerance.ge.200) special(5:5)='?'
-         width=nwsh
-         idf=idfsh
-         go to 200
-      endif
-
-      if(nsync.lt.MinSigdB .or. nsnr.lt.nsnrlim) go to 200
-
-C  If we get here, we have achieved sync!
-
-C### From here onward, code from wsjt65.f was deleted.  Must restore
-C### and modify.
-
- 200  continue
-
- 900  continue
-
-      return
-      end
+      subroutine wsjt64(dat,npts,cfile6,NClearAve,MinSigdB,
+     +  DFTolerance,NFreeze,NAFC,mode64,Nseg,MouseDF,NAgain,
+     +  ndepth,nchallenge,neme,idf,idfsh,mycall,hiscall,hisgrid,
+     +  lumsg,lcum,nspecial,ndf,nstest,dfsh,
+     +  snrsh,NSyncOK,ccfblue,ccfred,ndiag,nwsh)
+
+C  Orchestrates the process of decoding JT64 messages, using data that
+C  have been 2x downsampled.  The search for shorthand messages has
+C  already been done.
+
+      real dat(npts)                        !Raw data
+      integer DFTolerance
+      logical first
+      logical lcum
+      character decoded*22,cfile6*6,special*5,cooo*3
+      character*22 deepmsg
+      character*67 line,ave1,ave2
+      character*1 csync
+      character*12 mycall
+      character*12 hiscall
+      character*6 hisgrid
+      real ccfblue(-5:540),ccfred(-224:224)
+      integer itf(2,9)
+      include 'avecom.h'
+      data first/.true./,ns10/0/,ns20/0/
+      data itf/0,0, 1,0, -1,0, 0,-1, 0,1, 1,-1, 1,1, -1,-1, -1,1/
+      save
+
+      if(first) then
+         nsave=0
+         first=.false.
+         ave1=' '
+         ave2=' '
+      endif
+
+      naggressive=0
+      if(ndepth.ge.2) naggressive=1
+      nq1=3
+      nq2=6
+      if(naggressive.eq.1) nq1=1
+
+      if(NClearAve.ne.0) then
+         nsave=0                        !Clear the averaging accumulators
+         ns10=0
+         ns20=0
+         ave1=' '
+         ave2=' '
+      endif
+      if(MinSigdB.eq.99 .or. MinSigdB.eq.-99) then
+         ns10=0                         !For Include/Exclude ?
+         ns20=0
+      endif
+
+C  Attempt to synchronize: look for sync tone, get DF and DT.
+      call sync64(dat,npts,DFTolerance,NFreeze,MouseDF,
+     +    mode64,dtx,dfx,snrx,snrsync,ccfblue,ccfred,flip,width)
+      csync=' '
+      decoded='                      '
+      deepmsg='                      '
+      special='     '
+      cooo='   '
+      ncount=-1             !Flag for RS decode of current record
+      ncount1=-1            !Flag for RS Decode of ave1
+      ncount2=-1            !Flag for RS Decode of ave2
+      NSyncOK=0
+      nqual1=0
+      nqual2=0
+
+      if(nsave.lt.MAXAVE .and. (NAgain.eq.0 .or. NClearAve.eq.1)) 
+     +  nsave=nsave+1
+      if(nsave.le.0) go to 900          !Prevent bounds error
+
+      nflag(nsave)=0                    !Clear the &quot;good sync&quot; flag
+      iseg(nsave)=Nseg                  !Set the RX segment to 1 or 2
+      nsync=nint(snrsync-3.0)
+      nsnr=nint(snrx)
+      if(nsnr.lt.-30 .or. nsync.lt.0) nsync=0
+      nsnrlim=-32
+
+C  Good Sync takes precedence over a shorthand message:
+      if(nsync.ge.MinSigdB .and. nsnr.ge.nsnrlim .and.
+     +   nsync.ge.nstest) nstest=0
+
+      if(nstest.gt.0) then
+         dfx=dfsh
+         nsync=nstest
+         nsnr=snrsh
+         dtx=1.
+         ccfblue(-5)=-999.0
+         if(nspecial.eq.1) special='ATT  '
+         if(nspecial.eq.2) special='RO   '
+         if(nspecial.eq.3) special='RRR  '
+         if(nspecial.eq.4) special='73   '
+         NSyncOK=1              !Mark this RX file as good (for &quot;Save Decoded&quot;)
+         if(NFreeze.eq.0 .or. DFTolerance.ge.200) special(5:5)='?'
+         width=nwsh
+         idf=idfsh
+         go to 200
+      endif
+
+      if(nsync.lt.MinSigdB .or. nsnr.lt.nsnrlim) go to 200
+
+C  If we get here, we have achieved sync!
+
+C### From here onward, code from wsjt65.f was deleted.  Must restore
+C### and modify.
+
+ 200  continue
+
+ 900  continue
+
+      return
+      end


Property changes on: trunk/wsjt64.f
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/xfft2.f
===================================================================
--- trunk/xfft2.f	2008-07-04 13:36:33 UTC (rev 878)
+++ trunk/xfft2.f	2008-07-04 14:44:52 UTC (rev 879)
@@ -73,6 +73,12 @@
   149 MMAX = 2
   150 IF (MMAX-NH) 151,174,174
   151 LMAX = MAX0(4,MMAX/2)
+      WR=0  !Shut up compiler warnings. -db
+      WI=0  !Shut up compiler warnings. -db
+      W2I=0 !Shut up compiler warnings. -db
+      W2R=0 !Shut up compiler warnings. -db
+      W3I=0 !Shut up compiler warnings. -db
+      W3R=0 !Shut up compiler warnings. -db
       DO 173 L = 2,LMAX,4
           M = L
           IF (MMAX-2) 156,156,152


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000566.html">[WSJT-SVN] r878 - trunk
</A></li>
	<LI>Next message: <A HREF="000567.html">[WSJT-SVN] r880 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#568">[ date ]</a>
              <a href="thread.html#568">[ thread ]</a>
              <a href="subject.html#568">[ subject ]</a>
              <a href="author.html#568">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
