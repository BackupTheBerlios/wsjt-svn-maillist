<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r2230 - in trunk: . WsjtMod
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2230%20-%20in%20trunk%3A%20.%20WsjtMod&In-Reply-To=%3C20101026134617.36D6A480CA4%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001921.html">
   <LINK REL="Next"  HREF="001923.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r2230 - in trunk: . WsjtMod</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r2230%20-%20in%20trunk%3A%20.%20WsjtMod&In-Reply-To=%3C20101026134617.36D6A480CA4%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r2230 - in trunk: . WsjtMod">k1jt at mail.berlios.de
       </A><BR>
    <I>Tue Oct 26 15:46:16 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001921.html">[WSJT-SVN] r2229 - wsjt7a
</A></li>
        <LI>Next message: <A HREF="001923.html">[WSJT-SVN] r2231 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1922">[ date ]</a>
              <a href="thread.html#1922">[ thread ]</a>
              <a href="subject.html#1922">[ subject ]</a>
              <a href="author.html#1922">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2010-10-26 15:46:16 +0200 (Tue, 26 Oct 2010)
New Revision: 2230

Added:
   trunk/abc441.f90
   trunk/align28.f90
   trunk/alignmsg.f90
   trunk/analytic.f90
   trunk/astro.f
   trunk/astro0.f90
   trunk/audio_init.f90
   trunk/avecho.f90
   trunk/chk441.f90
   trunk/decdiana.f90
   trunk/decode1.f90
   trunk/decode3.f90
   trunk/decodems.f90
   trunk/deep65.f90
   trunk/diana.f90
   trunk/echogen.f90
   trunk/fivehz.f90
   trunk/foldms.f90
   trunk/four2a.f90
   trunk/four2b.f90
   trunk/ftn_init.f90
   trunk/gen441.f90
   trunk/gendiana.f90
   trunk/geniscat.f90
   trunk/genms.f90
   trunk/get_fname.f90
   trunk/getfile.f90
   trunk/gran.f90
   trunk/hipass.f90
   trunk/iscat.f90
   trunk/jtms.f90
   trunk/len441.f90
   trunk/lenms.f90
   trunk/makepings.f90
   trunk/match.f90
   trunk/msdf.f90
   trunk/ping441.f90
   trunk/savedata.f90
   trunk/searchms.f90
   trunk/setupms.f90
   trunk/smo.f90
   trunk/specdiana.f90
   trunk/syncdiana.f90
   trunk/syncms.f90
   trunk/t72.f90
   trunk/t73.f90
   trunk/t74.f90
   trunk/techo.f90
   trunk/thnix_stub.f90
   trunk/tm2.f90
   trunk/tmoonsub.c
   trunk/tweak1.f90
   trunk/wsjt.jpg
   trunk/wsjt1.f90
   trunk/wsjt7a.txt
   trunk/wsjtgen.f90
Removed:
   trunk/DEB/
   trunk/WSJT592.iss
   trunk/abc441.F90
   trunk/astro.F
   trunk/astro0.F90
   trunk/audio_init.F90
   trunk/blanker.f90
   trunk/ccf2.f
   trunk/decode1.F90
   trunk/decode162.f
   trunk/decode3.F90
   trunk/decode6m.f
   trunk/deep65.F
   trunk/fano232.f
   trunk/fchisq.f
   trunk/filbig2.F
   trunk/fivehz.F90
   trunk/four2a.f
   trunk/ftn_init.F90
   trunk/gen64.f90
   trunk/gen6m.f
   trunk/genwspr.f90
   trunk/get_fname.F90
   trunk/getfile.F90
   trunk/hash.f90
   trunk/inter_mept.f
   trunk/mept162a.f
   trunk/pack50.f
   trunk/packname.f90
   trunk/packprop.f90
   trunk/packtext2.f90
   trunk/ps162.f
   trunk/runqqq.F90
   trunk/savedata.F90
   trunk/sync162.f
   trunk/sync64.f
   trunk/twkfreq.f
   trunk/unpack50.f
   trunk/unpackname.f90
   trunk/unpackprop.f90
   trunk/unpacktext2.f90
   trunk/wqdecode.f90
   trunk/wqencode.f90
   trunk/wsjt1.F
   trunk/wsjt64.f
   trunk/wsjtgen.F90
   trunk/wsjtwspr.f90
Modified:
   trunk/
   trunk/CALL3.TXT
   trunk/Makefile.MinGW
   trunk/Makefile.in
   trunk/WsjtMod/astro.py
   trunk/WsjtMod/options.py
   trunk/WsjtMod/specjt.py
   trunk/Wsjt_Howto_MacOSX_10.6.html
   trunk/decode2.f90
   trunk/decode24.f
   trunk/extract.f
   trunk/ftn_quit.f90
   trunk/gcom2.f90
   trunk/gcom4.f90
   trunk/gen24.f
   trunk/gen65.f
   trunk/genmet.f
   trunk/horizspec.f90
   trunk/interleave24.f
   trunk/jtaudio.c
   trunk/longx.f
   trunk/mtdecode.f
   trunk/packgrid.f
   trunk/packmsg.f
   trunk/pix2d.f90
   trunk/pix2d65.f90
   trunk/ps24.f
   trunk/ptt.c
   trunk/rfile2.f
   trunk/spec.f90
   trunk/sun.f
   trunk/sync24.f
   trunk/unpackpfx.f90
   trunk/wsjt.py
   trunk/wsjt24.f
   trunk/wsjt65.f
   trunk/xcor.f
   trunk/xcor24.f
Log:
Merged WSJT 9.02 changes from wsjt7a into trunk.



Property changes on: trunk
___________________________________________________________________
Added: svn:mergeinfo
   + /wsjt7a:1948-2228

Modified: trunk/CALL3.TXT
===================================================================
--- trunk/CALL3.TXT	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/CALL3.TXT	2010-10-26 13:46:16 UTC (rev 2230)
@@ -5,6 +5,7 @@
 2I0BIW,IO64PF,,,MI3IYA,,Yaesu ft-847,06/07
 2M0EXD,IO88FO,,,,,,04/04
 3B9C,MH10QG,EME,,,,,01/03
+3D2LR,RH92,EME,,
 3DA0HL,KG53MS,EME,,EXPEDITION,,,03/07
 3V8BB,JM56ER,EME,,,,,06/02
 3V8SS,JM55GX,EME,,Expedition,,144: 16JXX and 1kw,12/05
@@ -1414,6 +1415,7 @@
 G3NAQ,IO91HL,,,,,50: 400W 3el - 4: 100W 2el - 144: 400W 17el - 70: 250W 21el,08/05
 G3UTS,IO94CU,,,,,144: 400W  9el M2  BF981,02/04
 G3WCS,IO83RH,,,,,144: TS430S HB Transverter  HB Amp 2x4CX250B 20el DJ9BV  70: 100W 4el   50: 100W 4el,01/05
+G3WDG,IO92rg,EME,,
 G3WZT,IO90UX,EME,,,,IC756PRO  50: 7el 400W - TS2000 144: 2x12el 400W - 432: 1x19el 50W,03/07
 G3YNN,JO00EU,,,,,50:  2-5W 5el - 144: FT736 100W 14el - 432: FT736 25W 11el,05/04
 G3YYD,IO91TR,,,,,FT1000MP Transverter 4CX400 400w to 3wl yagi at 22m AGL,04/05
@@ -2311,6 +2313,7 @@
 K5BYS,EM13,,,,,,01/03
 K5CBL,EM15,,,,,,01/03
 K5CFM,EM15,,,,,,01/03
+K5CM,EM25,,,
 K5CPZ,EM15,,,,,,01/03
 K5CZD,EM32VN,EME,,,,144: 2x 13el 375W,05/06
 K5DNL,EM15LJ,EME,,,,50: 7el  144: 2x  17el 400W,04/07
@@ -2430,6 +2433,7 @@
 K9CT,EN50BQ,EME,,,,IC7800  IC756 ProII  Demi xvtr  LunarLink  4x18 XXX  Demi LNA,09/07
 K9DMW,EN52UI,,,NT9E,,756PROII(6m)  910H(144/432),09/07
 K9DQ,EN62AS,,,,,,08/06
+K9DRO,EN54fn,,,
 K9DTB,EM89,,,,,,01/90
 K9DX,EN52XC,EME,,,,144: 8x 19el  Amp. 8877,09/06
 K9EA,EN94CB,,,,,,09/01
@@ -2670,6 +2674,7 @@
 KD5QWO,EM15AJ,,,,,Yaesu ft-847,01/04
 KD5XB,DM84,,,,,,12/06
 KD7ETC,DM54AH,,,,,,01/04
+KD7YZ,EM88,,,
 KD9KX,EN42,,,,,,01/03
 KE0MO,EN41,,,,,,01/03
 KE0UQ,EM29,,,,,,01/03
@@ -2781,6 +2786,7 @@
 KR8L,DN43AL,,,,,,01/03
 KS0F,EM48SL,,,,,,01/97
 KT4HA,FM15BH,,,,,,01/03
+KT4KB,EM93,,,
 KT8O,EN71KI,,,,,,04/08
 KT8U,EN80OR,,,,,,01/03
 KU0KU,EM28QV,,,,,,01/03
@@ -3053,6 +3059,7 @@
 N1GMV,FM05TU,,,,,,01/04
 N1GOD,FN41VQ,,,,,,01/03
 N1HOQ,FN41TP,EME,,,,144: 12el 400W,11/06
+N1IW,EN75ve,,,
 N1JEZ,FN34IM,,,,,FT736 FT847 FT920 FT290 DSP10 ACOM1006,05/07
 N1KI,EM75WX,EME,,WB4KMH,,144: 4x 12el 1500W  -  432: 2x 9wl 1000W,04/07
 N1KTM,FN41SR,,,,,144: 1kw- 2x2M9,01/97
@@ -3279,6 +3286,7 @@
 N9SU,EN62BI,EME,,,,2x 3wl  400W,02/09
 N9TZL,EN52SH,,,,,,01/03
 N9UDO,EN53DL,,,,,,01/03
+N9UM,EN52wg,,,
 N9UUR,EN63,,,,,,01/03
 N9VSV,EN63,,,,,,01/03
 N9WWR,EN62CS,,,,,,01/03
@@ -4546,6 +4554,7 @@
 UN7TQ,MN52VV,EME,,,,,09/98
 UN8AG,LN53PH,,,ex UL7AAX,,,07/96
 UN8BA,MO51RD,EME,,,,,01/92
+UN9L,MO13tf,EME,,
 UP7QP,MN83FD,,,,,,10/08
 UR3CTB,KN59RS,,,,,IC-820H  40W dk7zb 10 el LNA Gafest,09/07
 UR3EE,KN88DC,EME,,,,,11/02
@@ -4842,6 +4851,7 @@
 W0KFG,DN96OT,,,,,,09/01
 W0KJY,DN71,EME,,,,,09/01
 W0KRX,EN34LM,,,,,,01/03
+W0KT,EN21,,,
 W0LD,DM78,,,,,144: 1KW 2x16el,04/01
 W0LER,EN35IE,,,,,,01/01
 W0LGQ,EN21DJ,,,EX N0EKT,,,05/07
@@ -4953,6 +4963,7 @@
 W4ABC,EL87PT,,,,,50: 100W  7el qubical quad,01/01
 W4AD,FM18IP,EME,,ex K4HWG,,,07/01
 W4AME,EM75FG,,,,,,01/03
+W4AS,EL95to,,,
 W4CHA,EL88QA,,,ex WA4CHA,,50: 150W 9el M2 - 144: 1-5KW 2M18xxx - 432: 500W 424B - 1296: 110W 45el - 2304: 5W 45el - 10G: 2W 10ft,01/01
 W4CN,EM17JP,,,,,,09/01
 W4ET,EM56TP,,,,,,01/04

Modified: trunk/Makefile.MinGW
===================================================================
--- trunk/Makefile.MinGW	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/Makefile.MinGW	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,13 +1,24 @@
 # Makefile for Windows
-# !include &lt;dfinc.mak&gt;   #Some definitions for Compaq Visual Fortran
 CC = /mingw/bin/gcc
 FC = /mingw/bin/g95
 
-# FFLAGS = -O2
+FFLAGS = -O2 -fbounds-check -Wall -Wno-precision-loss
 CFLAGS = -I. -fbounds-check
 
-all:    JT65code.exe WSJT7.EXE
+# Default rules
+%.o: %.c
+	${CC} ${CFLAGS} -c $&lt;
+%.o: %.f
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.f90
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F90
+	${FC} ${FFLAGS} -c $&lt;
 
+all:    WSJT9.EXE
+
 OBJS1 = JT65code.o nchar.o grid2deg.o packmsg.o packtext.o \
 	packcall.o packgrid.o unpackmsg.o unpacktext.o \
 	unpackcall.o unpackgrid.o deg2grid.o \
@@ -22,50 +33,62 @@
 OBJS2C   = init_rs.o encode_rs.o decode_rs.o jtaudio.o fano.o \
 	tab.o nhash.o
 
+OBJS4	= t74.o analytic.o four2b.o iscat.o db.o pctile.o \
+	sort.o ssort.o
+
+t74:	$(OBJS4)
+	$(FC) -o t74 $(OBJS4) libfftw3f_win.a
+
+OBJS5	= techo.o analytic.o four2b.o db.o
+
+techo.exe: $(OBJS5)
+	$(FC) -o techo.exe $(OBJS5) libfftw3f_win.a
+
 F2PYONLY = ftn_init ftn_quit audio_init spec getfile azdist0 astro0 chkt0
 
-SRCS2F90 = a2d.f90 abc441.f90 astro0.f90 audio_init.f90 azdist0.f90 \
-	blanker.f90 decode1.f90 decode2.f90 decode3.f90 ftn_init.f90 \
+SRCS2F90 = wsjt1.f90 a2d.f90 abc441.f90 astro0.f90 audio_init.f90 azdist0.f90 \
+	decode1.f90 decode2.f90 decode3.f90 ftn_init.f90 \
 	ftn_quit.f90 get_fname.f90 getfile.F90 horizspec.f90 hscroll.f90 \
-	pix2d.f90 pix2d65.f90 rfile.f90 savedata.f90 spec.f90 \
-	wsjtgen.f90 runqqq.f90 fivehz.f90 chkt0.f90 \
-	genwspr.f90 wqencode.f90 wqdecode.f90 packpfx.f90 unpackpfx.f90 \
-	packname.f90 unpackname.f90 packtext2.f90 unpacktext2.f90 \
-	packprop.f90 unpackprop.f90 hash.f90 wsjtwspr.f90 gen64.f90 \
-	thnix.f90
+	pix2d.f90 pix2d65.f90 rfile.f90 savedata.f90 spec.f90 match.f90 \
+	wsjtgen.f90 fivehz.f90 chkt0.f90 deep65.f90 makepings.f90 \
+	packpfx.f90 unpackpfx.f90 genms.f90 decodems.f90 setupms.f90 gran.f90 \
+	thnix.f90 tweak1.f90 smo.f90 analytic.f90 geniscat.f90 \
+	iscat.f90 four2a.f90 hipass.f90 msdf.f90 syncms.f90 lenms.f90 \
+	jtms.f90 foldms.f90 avecho.f90 echogen.f90 alignmsg.f90 \
+	chk441.f90 gen441.f90 tm2.f90 gendiana.f90 diana.f90 \
+	specdiana.f90 syncdiana.f90 decdiana.f90
 
-SRCS2F77 = wsjt1.f avesp2.f bzap.f spec441.f spec2d.f mtdecode.f \
+
+SRCS2F77 = avesp2.f bzap.f spec441.f spec2d.f mtdecode.f \
 	stdecode.f indexx.f s2shape.f flat2.f gen65.f gen24.f entail.f \
 	genmet.f wsjt24.f sync24.f ps24.f xcor24.f decode24.f\
-	chkmsg.f gen6m.f interleave24.f \
-	gentone.f syncf0.f syncf1.f synct.f decode6m.f avemsg6m.f \
+	chkmsg.f interleave24.f astro.f extract.f \
+	gentone.f syncf0.f syncf1.f synct.f avemsg6m.f \
 	set.f flatten.f db.f pctile.f sort.f ssort.f ps.f smooth.f ping.f \
 	longx.f peakup.f sync.f detect.f avemsg65.f decode65.f demod64a.f \
-	encode65.f extract.f chkhist.f flat1.f four2a.f gencw.f \
+	encode65.f chkhist.f flat1.f gencw.f \
 	gencwid.f msgtype.f getpfx1.f \
 	getpfx2.f getsnr.f graycode.f grid2k.f interleave63.f k2grid.f \
-	limit.f lpf1.f deep65.f morse.f nchar.f packcall.f packgrid.f \
+	limit.f lpf1.f morse.f nchar.f packcall.f packgrid.f \
 	packmsg.f packtext.f setup65.f short65.f slope.f spec2d65.f \
 	sync65.f unpackcall.f unpackgrid.f unpackmsg.f unpacktext.f \
-	xcor.f xfft.f xfft2.f wsjt65.f astro.f azdist.f coord.f dcoord.f \
+	xcor.f xfft.f xfft2.f wsjt65.f azdist.f coord.f dcoord.f \
 	deg2grid.f dot.f ftsky.f geocentric.f GeoDist.f grid2deg.f \
 	moon2.f MoonDop.f sun.f toxyz.f pfxdump.f \
 	ftpeak65.f fil651.f fil652.f fil653.f symsync65.f \
-	rfile2.f encode232.f inter_mept.f pack50.f unpack50.f \
-	filbig2.F mept162a.f twkfreq.f sync162.f decode162.f \
-	ps162.f fchisq.f fano232.f ccf2.f wsjt64.f sync64.f
+	rfile2.f 
 
+SRCS2C   = resample.c ptt.c igray.c wrapkarn.c start_threads.c \
+	cutil.c fthread.c tmoonsub.c
 
-SRCS2C   = resample.c ptt.c igray.c wrapkarn.c start_threads.c \
-	cutil.c fthread.c
-WSJT7.EXE: WsjtMod/Audio.pyd wsjt.spec
+WSJT9.EXE: WsjtMod/Audio.pyd wsjt.spec
 	c:/python25/python c:/python25/pyinstaller-1.3/Build.py wsjt.spec
-	mv wsjt.exe WSJT7.EXE
+	mv wsjt.exe WSJT9.EXE
 
 WsjtMod/Audio.pyd: $(OBJS2C) $(SRCS2F90) $(SRCS2F77) $(SRCS2C) 
 	c:/python25/python c:/python25/scripts/f2py.py -c -I. \
 	--quiet --fcompiler=g95 \
-	--opt=&quot;-cpp&quot; \
+	--opt=&quot;-cpp -fbounds-check&quot; \
 	--compiler=mingw32 \
 	$(OBJS2C) libportaudio.a libfftw3f_win.a libsamplerate.a \
 	libpthreadGC2.a -lwinmm -m Audio \
@@ -91,4 +114,4 @@
 .PHONY : clean
 
 clean:
-	rm -f *.o JT65code.exe wsjt7.exe WsjtMod/Audio.pyd
+	rm -f *.o JT65code.exe wsjt9.exe WsjtMod/Audio.pyd

Modified: trunk/Makefile.in
===================================================================
--- trunk/Makefile.in	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/Makefile.in	2010-10-26 13:46:16 UTC (rev 2230)
@@ -19,16 +19,18 @@
 
 Audio:	WsjtMod/Audio.so
 
-# The default rules
-.c.o:
-	${CC} ${CPPFLAGS} ${CFLAGS} -c -o ${&lt;:.c=.o} $&lt;
+# Default rules
+%.o: %.c
+	${CC} ${CFLAGS} -c $&lt;
+%.o: %.f
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.f90
+	${FC} ${FFLAGS} -c $&lt;
+%.o: %.F90
+	${FC} ${FFLAGS} -c $&lt;
 
-.f.o:
-	${FC} ${CPPFLAGS} ${FFLAGS} -c -o ${&lt;:.f=.o} $&lt;
-
-.F90.o:
-	${FC} ${CPPFLAGS} ${FFLAGS} -c -o ${&lt;:.F90=.o} $&lt;
-
 OS=@OS@
 FC=@FC@
 FCV=@FCV@
@@ -48,17 +50,32 @@
 	igray.o init_rs_int.o encode_rs_int.o decode_rs_int.o \
 	wrapkarn.o cutil.o
 
+OBJS4	= t74.o diana.o analytic.o four2a.o db.o pctile.o \
+	sort.o ssort.o thnix_stub.o tweak1.o smooth.o smo.o
+
+t74:	$(OBJS4)
+	$(FC) -o t74 $(OBJS4) -lfftw3f
+
+
+OBJS5 = t72.o analytic.o four2a.o smooth.o pctile.o db.o \
+	thnix_stub.o sort.o ssort.o gen441.o abc441.o ping441.o \
+	indexx.o ping.o smo.o tweak1.o enc441.o dec441.o \
+	token.o msgtrim.o
+
 F2PYONLY = ftn_init ftn_quit audio_init spec getfile azdist0 astro0 chkt0
 
-SRCS2F90 = abc441.F90 astro0.F90 audio_init.F90 azdist0.f90 \
-	blanker.f90 decode1.F90 decode2.f90 decode3.F90 ftn_init.F90 \
-	ftn_quit.f90 get_fname.F90 getfile.F90 horizspec.f90 hscroll.f90 \
-	pix2d.f90 pix2d65.f90 rfile.f90 savedata.F90 spec.f90 \
-	wsjtgen.F90 runqqq.F90 fivehz.F90 chkt0.f90 \
-	genwspr.f90 wqencode.f90 wqdecode.f90 packpfx.f90 unpackpfx.f90 \
-	packname.f90 unpackname.f90 packtext2.f90 unpacktext2.f90 \
-	packprop.f90 unpackprop.f90 hash.f90 wsjtwspr.f90 gen64.f90 \
-	thnix.f90
+SRCS2F90 = abc441.f90 astro0.f90 audio_init.f90 azdist0.f90 \
+	decode1.f90 decode2.f90 decode3.f90 ftn_init.f90 \
+	ftn_quit.f90 get_fname.f90 getfile.f90 horizspec.f90 hscroll.f90 \
+	pix2d.f90 pix2d65.f90 rfile.f90 savedata.f90 spec.f90 match.f90 \
+	wsjtgen.f90 fivehz.f90 chkt0.f90 gran.f90 makepings.f90 \
+	packpfx.f90 unpackpfx.f90 genms.f90 decodems.f90 setupms.f90 \
+	thnix.f90 tweak1.f90 smo.f90 analytic.f90 \
+	geniscat.f90 iscat.f90 four2a.f90 hipass.f90 \
+	msdf.f90 syncms.f90 lenms.f90 jtms.f90 foldms.f90 avecho.f90 \
+	echogen.f90 alignmsg.f90 chk441.f90 gen441.f90 tm2.f90 \
+	gendiana.f90 diana.f90 specdiana.f90 syncdiana.f90 \
+	decdiana.f90
 
 OBJS2F90 = ${SRCS2F90:.f90=.o}
 
@@ -68,11 +85,11 @@
         avesp2.f bzap.f spec441.f spec2d.f mtdecode.f stdecode.f \
         indexx.f s2shape.f flat2.f gen65.f gen24.f entail.f genmet.f \
 	wsjt24.f sync24.f ps24.f xcor24.f decode24.f \
-	chkmsg.f gen6m.f gentone.f interleave24.f \
-        syncf0.f syncf1.f synct.f decode6m.f avemsg6m.f \
+	chkmsg.f gentone.f interleave24.f \
+        syncf0.f syncf1.f synct.f avemsg6m.f \
         set.f flatten.f db.f pctile.f sort.f ssort.f ps.f smooth.f \
         ping.f longx.f peakup.f sync.f detect.f avemsg65.f decode65.f \
-        demod64a.f encode65.f extract.f chkhist.f flat1.f four2a.f \
+        demod64a.f encode65.f extract.f chkhist.f flat1.f \
         gencw.f gencwid.f msgtype.f \
 	getpfx1.f getpfx2.f getsnr.f graycode.f grid2k.f \
         interleave63.f k2grid.f limit.f lpf1.f morse.f \
@@ -80,25 +97,26 @@
         short65.f slope.f spec2d65.f sync65.f unpackcall.f \
         unpackgrid.f unpackmsg.f unpacktext.f xcor.f xfft.f xfft2.f wsjt65.f \
 	ftpeak65.f fil651.f fil652.f fil653.f symsync65.f \
-	rfile2.f encode232.f inter_mept.f pack50.f unpack50.f \
-	filbig2.F mept162a.f twkfreq.f sync162.f decode162.f \
-	ps162.f fchisq.f fano232.f ccf2.f wsjt64.f sync64.f 
+	rfile2.f encode232.f 
 
 OBJS2F77 = ${SRCS2F77:.f=.o} deep65.o
 
 SRCS2C	= init_rs.c encode_rs.c decode_rs.c fano.c tab.c nhash.c \
-	cutil.c fthread.c
+	cutil.c fthread.c tmoonsub.c
 OBJS2C  = ${SRCS2C:.c=.o}
 
 SRCS3C	= ptt_unix.c igray.c wrapkarn.c
 OBJS3C  = ${SRCS3C:.c=.o}
 AUDIOSRCS =	a2d.f90 jtaudio.c start_threads.c resample.c
 
-all:	WsjtMod/Audio.so wsjt7 JT65code
+all:	WsjtMod/Audio.so wsjt9 JT65code
 
 JT65code: $(OBJS1)
 	$(FC) -o JT65code $(OBJS1)
 
+t72:	$(OBJS5)
+	$(FC) -o t72 $(OBJS5) -lfftw3f
+
 build:	WsjtMod/Audio.so
 
 WsjtMod/Audio.so: $(OBJS2C) $(OBJS3C) $(OBJS2F77) $(SRCS2F90) $(AUDIOSRCS)
@@ -111,15 +129,15 @@
 	${SRCS3C} ${AUDIOSRCS}
 	${MV} Audio.so WsjtMod
 
-wsjt7:  WsjtMod/Audio.so wsjt7.spec
-	python /home/joe/temp/pyinstaller-1.3/Build.py wsjt7.spec
+wsjt9:  WsjtMod/Audio.so wsjt9.spec
+	python /home/joe/temp/pyinstaller-1.3/Build.py wsjt9.spec
 
-wsjt7.spec: wsjt7.py WsjtMod/astro.py WsjtMod/g.py WsjtMod/options.py \
+wsjt9.spec: wsjt9.py WsjtMod/astro.py WsjtMod/g.py WsjtMod/options.py \
 	WsjtMod/palettes.py WsjtMod/smeter.py WsjtMod/specjt.py
 	python /home/joe/temp/pyinstaller-1.3/Makespec.py --icon wsjt.ico \
-	--tk --onefile wsjt7.py
-wsjt7.py: wsjt.py
-	cp wsjt.py wsjt7.py
+	--tk --onefile wsjt9.py
+wsjt9.py: wsjt.py
+	cp wsjt.py wsjt9.py
 
 init_rs_int.o: init_rs.c
 	$(CC) $(CFLAGS) -c -DBIGSYM=1 -o init_rs_int.o init_rs.c
@@ -144,21 +162,20 @@
 	WsjtMod/options.py WsjtMod/palettes.py WsjtMod/PmwBlt.py \
 	WsjtMod/PmwColor.py WsjtMod/Pmw.py WsjtMod/smeter.py \
 	WsjtMod/specjt.py WsjtMod/astro.py DEB/DEBIAN/control \
-	wsjtrc DEB/WSJT/wsjt
+	wsjtrc
 
 	cp wsjt.py wsjtrc CALL3.TXT dmet_10_-1_3.dat \
 	dmet_20_-2_2.dat kvasd.dat KVASD_g95 TSKY.DAT \
-	UpdateHistory.txt wsjt.ico WSJT_Quick_Reference.pdf \
-	WSJT_User_600.pdf WSPR_mode.pdf DEB/WSJT
+	wsjt.ico wsjt.jpg WSJT_Quick_Reference.pdf WSJT_User_600.pdf DEB/WSJT9
 
-	cp WsjtMod/Audio.so DEB/WSJT/WsjtMod
-	cp WsjtMod/*.py DEB/WSJT/WsjtMod
+	cp WsjtMod/Audio.so DEB/WSJT9/WsjtMod
+	cp WsjtMod/*.py DEB/WSJT9/WsjtMod
 	dpkg-deb --build DEB wsjt_ver_rev_i386.deb
 
 .PHONY : clean
 clean:
-	${RM} -f *.o *.pyc *.so *~ JT65code wsjt7 WsjtMod/*.pyc WsjtMod/*.pyc \
-		WsjtMod/*.so wsjt7.py wsjt7.spec
+	${RM} -f *.o *.pyc *.so *~ JT65code wsjt9 WsjtMod/*.pyc WsjtMod/*.pyc \
+		WsjtMod/*.so wsjt9.py wsjt9.spec
 	${RM} -rf build/
 
 distclean: clean

Deleted: trunk/WSJT592.iss
===================================================================
--- trunk/WSJT592.iss	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/WSJT592.iss	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,24 +0,0 @@
-[Setup]
-AppName=WSJT
-AppVerName=WSJT Version 5.9.2 r77
-AppCopyright=Copyright (C) 2001-2005 by Joe Taylor, K1JT
-DefaultDirName={pf}\WSJT6
-DefaultGroupName=WSJT6
-
-[Files]
-Source: &quot;c:\k1jt\svn\wsjt\release-5.9.2\WSJT6.EXE&quot;;         DestDir: &quot;{app}&quot;
-Source: &quot;c:\k1jt\svn\wsjt\release-5.9.2\README_592.TXT&quot;;    DestDir: &quot;{app}&quot;
-Source: &quot;c:\k1jt\svn\wsjt\release-5.9.2\CALL3.TXT&quot;;         DestDir: &quot;{app}&quot;; Flags: onlyifdoesntexist
-Source: &quot;c:\k1jt\svn\wsjt\release-5.9.2\wsjt.ico&quot;;          DestDir: &quot;{app}&quot;; Flags: onlyifdoesntexist
-Source: &quot;c:\k1jt\svn\wsjt\release-5.9.2\TSKY.DAT&quot;;          DestDir: &quot;{app}&quot;; Flags: onlyifdoesntexist
-Source: &quot;c:\k1jt\svn\wsjt\release-5.9.2\libsamplerate.dll&quot;; DestDir: &quot;{app}&quot;; Flags: onlyifdoesntexist
-Source: &quot;c:\k1jt\svn\wsjt\release-5.9.2\kvasd.exe&quot;;         DestDir: &quot;{app}&quot;;
-Source: &quot;c:\k1jt\svn\wsjt\release-5.9.2\wsjtrc.win&quot;;        DestDir: &quot;{app}&quot;;
-Source: &quot;c:\k1jt\svn\wsjt\release-5.9.2\Tutorial_592.txt&quot;;  DestDir: &quot;{app}&quot;;
-Source: &quot;c:\k1jt\python\wsjt\rxwav\samples\W8WN_010809_110400.WAV&quot;;  DestDir: &quot;{app}\RxWav\Samples\&quot;; Flags: onlyifdoesntexist
-
-[Icons]
-Name: &quot;{group}\WSJT6&quot;;        Filename: &quot;{app}\WSJT6.EXE&quot;; WorkingDir: {app}
-Name: &quot;{userdesktop}\WSJT6&quot;;  Filename: &quot;{app}\WSJT6.EXE&quot;; WorkingDir: {app}
-
-

Modified: trunk/WsjtMod/astro.py
===================================================================
--- trunk/WsjtMod/astro.py	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/WsjtMod/astro.py	2010-10-26 13:46:16 UTC (rev 2230)
@@ -26,9 +26,11 @@
     t3= &quot;Moon/DX: %6.2f  %6.2f\n&quot; % (g.AzMoonB,g.ElMoonB)
     t4= &quot;Sun:     %6.2f  %6.2f\n&quot; % (g.AzSun,g.ElSun)
     t4a=&quot;Source:  %6.2f  %6.2f\n\n&quot; % (g.AzAux,g.ElAux)
-    t5= &quot;        Doppler   df/dt\n&quot;
-    t6= &quot;DX:     %7d %7.2f\n&quot; % (g.ndop,g.dfdt)
-    t7= &quot;Self:   %7d %7.2f\n\n&quot; % (g.ndop00,g.dfdt0)
+    t5= &quot;             DX    Self\n&quot;
+    t6= &quot;Dop:    %7d %7d\n&quot; % (g.ndop,g.ndop00)
+    t7= &quot;df/dt:  %7.2f %7.2f\n&quot; % (g.dfdt,g.dfdt0)
+    t7aa=&quot;Spread: %7.1f %7.1f\n&quot; % (g.w2,g.w1)
+    t7ab=&quot;w50:    %7.1f %7.1f\n\n&quot; % (g.w502,g.w501)
     t7a=&quot;            RA      DEC\n&quot;
     irah=int(g.RAMoon)
     iram=int(60.0*(g.RAMoon-irah))
@@ -36,12 +38,14 @@
     irah=int(g.RaAux)
     iram=int(60.0*(g.RaAux-irah))
     t7c=&quot;Source:   %2.2d:%2.2d  %6.2f\n\n&quot; % (irah,iram,g.DecAux)
-    t8= &quot;Freq: %4d  Tsky:%6d\n&quot; % (g.nfreq,g.ntsky)
+    t8= &quot;Freq:%5d  Tsky:%6d\n&quot; % (g.nfreq,g.ntsky)
     if g.nfreq==2: t8=&quot;Freq:  1.8 Tsky:%6d\n&quot; % (g.ntsky)
     if g.nfreq==4: t8=&quot;Freq:  3.5 Tsky:%6d\n&quot; % (g.ntsky)
     t9= &quot;MNR: %5.1f  Dgrd:%6.1f\n&quot; % (g.MaxNR,g.Dgrd)
-    t10=&quot;DPol: %4d  SD:%8.2f\n&quot; % (g.poloffset,g.sd)
-    t=t1+t2+t3+t4+t4a+t5+t6+t7+t7a+t7b+t7c+t8+t9+t10
+    t10=&quot;DPol: %4d  SD:%8.2f\n\n&quot; % (g.poloffset,g.sd)
+    t11=&quot;LST (h):  %6.3f\n&quot; % (g.xlst,)
+
+    t=t1+t2+t3+t4+t4a+t5+t6+t7+t7aa+t7ab+t7a+t7b+t7c+t8+t9+t10+t11
     lab1.configure(text=t)
     g.astro_geom=root.geometry()
     frame.after(1000,update)

Modified: trunk/WsjtMod/options.py
===================================================================
--- trunk/WsjtMod/options.py	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/WsjtMod/options.py	2010-10-26 13:46:16 UTC (rev 2230)
@@ -43,28 +43,40 @@
 auxra=StringVar()
 auxdec=StringVar()
 azeldir=StringVar()
-myname=StringVar()
-hisname=StringVar()
-wx=StringVar()
+##necho=IntVar()
+##dlatency=DoubleVar()
+ntc=IntVar()
+fRIT=IntVar()
+dither=IntVar()
 temp=StringVar()
 wind=StringVar()
 pwr=StringVar()
 ant=StringVar()
-wxlist=(&quot;CLEAR&quot;,&quot;CLOUDY&quot;)
+mytag=IntVar()
+histag=IntVar()
+genmsg=IntVar()
 
+ntc.set(1)
+
+def resetgen():
+    defaults()
+    genmsg.set(1)
+
 def defaults():
-#    if g.mode==&quot;FSK441&quot; or g.mode==&quot;JT6M&quot;:
+    t=''
+    if mytag.get()==1: t=' %S'
+    if histag.get()==1: t=' %H'
     if (ireport.get()==0 and iregion.get()==0):
         tx1.delete(0,END)
         tx1.insert(0,'%T %M')
         tx2.delete(0,END)
-        tx2.insert(0,'%T %R %M %R%R')
+        tx2.insert(0,'%T %M %R')
         tx3.delete(0,END)
-        tx3.insert(0,'R%R')
+        tx3.insert(0,'R%R'+t)
         tx4.delete(0,END)
-        tx4.insert(0,'RRR')
+        tx4.insert(0,'RRR'+t)
         tx5.delete(0,END)
-        tx5.insert(0,'73')
+        tx5.insert(0,'73'+t)
         tx6.delete(0,END)
         tx6.insert(0,'CQ %M')
     elif (ireport.get()==1 and iregion.get()==0):
@@ -73,14 +85,14 @@
         tx2.delete(0,END)
         tx2.insert(0,'%T %M %G')
         tx3.delete(0,END)
-        tx3.insert(0,'RR %G')
+        tx3.insert(0,'RR %G'+t)
         tx4.delete(0,END)
-        tx4.insert(0,'RRR')
+        tx4.insert(0,'RRR'+t)
         tx5.delete(0,END)
-        tx5.insert(0,'73')
+        tx5.insert(0,'73'+t)
         tx6.delete(0,END)
         tx6.insert(0,'CQ %M')
-        
+
     elif (ireport.get()==0 and iregion.get()==1):
         tx1.delete(0,END)
         tx1.insert(0,'%T %M')
@@ -109,23 +121,14 @@
         tx6.delete(0,END)
         tx6.insert(0,'CQ %M')
 
-#------------------------------------------------------ set_wx
-def set_wx(event=NONE):
-    print 'hello'
-    wxdialog=Pmw.ComboBoxDialog(root, title=&quot;Wx options&quot;,
-        buttons=('OK','cancel'),defaultbutton='OK',
-        scrolledlist_items=tx6list,listbox_width=9)
-    wxdialog.geometry(msgpos())
-    if g.Win32: wxdialog.iconbitmap(&quot;wsjt.ico&quot;)
-    wxdialog.tkraise()
-    t=wxdialog.activate()
-    if t=='OK':
-        t=wxdialog.get()
-        wx_entry.delete(0,END)
-        wx_entry.insert(0,t)
+#------------------------------------------------------ setMyTag
+def setMyTag(event=NONE):
+    if(mytag.get()==1): histag.set(0)
 
+#------------------------------------------------------ setHisTag
+def setHisTag(event=NONE):
+    if(histag.get()==1): mytag.set(0)
 
-
 mycall=Pmw.EntryField(g1.interior(),labelpos=W,label_text='My Call:',
         value='K1JT',entry_textvariable=MyCall,entry_width=12)
 mygrid=Pmw.EntryField(g1.interior(),labelpos=W,label_text='Grid Locator:',
@@ -154,7 +157,17 @@
 
 Pmw.alignlabels(widgets)
 mycall.component('entry').focus_set()
-f1=Frame(g1.interior(),width=100,height=20)
+
+f0=Frame(g1.interior(),width=100,height=15)
+ndtr=IntVar()
+Label(f0,text='PTT line:  ').pack(side=LEFT)
+rb7=Radiobutton(f0,text='DTR',value=1,variable=ndtr)
+rb8=Radiobutton(f0,text='RTS',value=0,variable=ndtr)
+rb7.pack(anchor=W,side=LEFT,padx=2,pady=2)
+rb8.pack(anchor=W,side=LEFT,padx=2,pady=2)
+f0.pack()
+
+f1=Frame(g1.interior(),width=100,height=15)
 mileskm=IntVar()
 Label(f1,text='Distance unit:').pack(side=LEFT)
 rb5=Radiobutton(f1,text='mi',value=0,variable=mileskm)
@@ -163,27 +176,34 @@
 rb6.pack(anchor=W,side=LEFT,padx=2,pady=2)
 f1.pack()
 
-g2=Pmw.Group(root,tag_text=&quot;FSK441/JT6M message templates&quot;)
+g2=Pmw.Group(root,tag_text=&quot;Message templates for FSK441, ISCAT&quot;)
 f2=Frame(g2.interior(),width=100,height=20)
 f2a=Frame(f2,width=50,height=20,bd=2,relief=GROOVE)
-f2a.pack(side=LEFT,padx=6,pady=6)
+f2a.pack(side=LEFT,padx=6,pady=6,fill=Y)
 f2b=Frame(f2,width=50,height=20,bd=2,relief=GROOVE)
 f2b.pack(side=LEFT,padx=6,pady=6)
+iregion=IntVar()
+rb4=Radiobutton(f2a,text='EU',value=1,variable=iregion)
+rb4.pack(anchor=W,side=LEFT,padx=2,pady=2)
+rb3=Radiobutton(f2a,text='NA',value=0,variable=iregion)
+rb3.pack(anchor=W,side=LEFT,padx=2,pady=2)
 
 ireport=IntVar()
-rb1=Radiobutton(f2a,text='Report',value=0,variable=ireport)
-rb2=Radiobutton(f2a,text='Grid',value=1,variable=ireport)
-rb1.pack(anchor=W,side=LEFT,padx=2,pady=2)
-rb2.pack(anchor=W,side=LEFT,padx=2,pady=2)
+rb1=Radiobutton(f2b,text='Report',value=0,variable=ireport)
+rb2=Radiobutton(f2b,text='Grid',value=1,variable=ireport)
+rb1.grid(column=0,row=0)
+rb2.grid(column=1,row=0)
+cb1=Checkbutton(f2b,text='My tag',variable=mytag,command=setMyTag)
+cb1.grid(column=0,row=2)
+cb2=Checkbutton(f2b,text='His tag',variable=histag,command=setHisTag)
+cb2.grid(column=1,row=2)
 
-iregion=IntVar()
-rb3=Radiobutton(f2b,text='NA',value=0,variable=iregion)
-rb4=Radiobutton(f2b,text='EU',value=1,variable=iregion)
-rb3.pack(anchor=W,side=LEFT,padx=2,pady=2)
-rb4.pack(anchor=W,side=LEFT,padx=2,pady=2)
 f2.pack()
 
-Button(g2.interior(),text=&quot;Reset defaults&quot;,command=defaults).pack(padx=6,pady=6)
+f3=Frame(g2.interior(),width=100,height=20)
+Button(f3,text=&quot;   Reset   &quot;,command=defaults).pack(side=LEFT,padx=6,pady=6)
+Button(f3,text=&quot;Reset and Gen Msgs&quot;,command=resetgen).pack(side=LEFT,padx=6,pady=6)
+f3.pack()
 
 tx1=Pmw.EntryField(g2.interior(),labelpos=W,label_text='Tx 1:',
                    entry_textvariable=Template1)
@@ -212,18 +232,23 @@
     entry_width=9,entry_textvariable=auxdec)
 azeldir_entry=Pmw.EntryField(g3.interior(),labelpos=W,label_text='AzElDir:',
     entry_width=9,value=g.appdir,entry_textvariable=azeldir)
-myname_entry=Pmw.EntryField(g3.interior(),labelpos=W,label_text='MyName:',
-    entry_width=9,entry_textvariable=myname)
+ntc_entry=Pmw.EntryField(g3.interior(),labelpos=W,label_text='Echo Avg (m):',
+    entry_width=9,entry_textvariable=ntc)
+##necho_entry=Pmw.EntryField(g3.interior(),labelpos=W,label_text='Echo waveform:',
+##    entry_width=9,entry_textvariable=necho)
+fRIT_entry=Pmw.EntryField(g3.interior(),labelpos=W,label_text='RIT (Hz):',
+    entry_width=9,entry_textvariable=fRIT)
+dither_entry=Pmw.EntryField(g3.interior(),labelpos=W,label_text='Dither (Hz):',
+    entry_width=9,entry_textvariable=dither)
+##dlatency_entry=Pmw.EntryField(g3.interior(),labelpos=W,label_text='Latency (s):',
+##    entry_width=9,entry_textvariable=dlatency)
 
-widgets = (temp_prefix,aux_ra,aux_dec,azeldir_entry,myname_entry)
+widgets = (temp_prefix,aux_ra,aux_dec,azeldir_entry,ntc_entry, \
+           fRIT_entry,dither_entry)
 for widget in widgets:
     widget.pack(padx=10,pady=2)
-hipriority=Checkbutton(g3.interior(),text='High Priority',justify=RIGHT,
-                       variable=HighPri)
-hipriority.pack(padx=10,pady=2,side=BOTTOM)
 Pmw.alignlabels(widgets)
 
-
 g1.pack(side=LEFT,fill=BOTH,expand=1,padx=6,pady=6)
 g2.pack(side=LEFT,fill=BOTH,expand=1,padx=6,pady=6)
 g3.pack(side=LEFT,fill=BOTH,expand=1,padx=6,pady=6)

Modified: trunk/WsjtMod/specjt.py
===================================================================
--- trunk/WsjtMod/specjt.py	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/WsjtMod/specjt.py	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,7 +1,6 @@
 #---------------------------------------------------- SpecJT
 # 2.2.08 Soundcontrol extended for Vista  DL3LST
 from Tkinter import *
-from tkMessageBox import showwarning
 import time
 import os
 import Pmw
@@ -10,6 +9,8 @@
 import g
 import string
 import cPickle
+import tkMessageBox
+
 try:
     from numpy.oldnumeric import zeros, multiarray
 #    print &quot;specjt importing from numpy&quot;
@@ -105,34 +106,26 @@
 def rx_volume():
     for path in string.split(os.environ[&quot;PATH&quot;], os.pathsep):
         file = os.path.join(path, &quot;sndvol32&quot;) + &quot;.exe&quot;
-        try:
-            return os.spawnv(os.P_NOWAIT, file, (file,) + (&quot; -r&quot;,))
-        except os.error:
-            pass
+        if os.path.exists(file):
+            os.spawnv(os.P_NOWAIT, file, (file,) + (&quot; -r&quot;,))
+            return
+    t=&quot;WSJT cannot access mixer input control\non this platform.  Please invoke &quot; + \
+       &quot;system\nmixer directly.&quot;
+    tkMessageBox.showwarning(message=t)
 
-# Vista soundcontrol has no parameter to select the inputlevel !!   3LST
-# so we have no solution to call it
-    raise os.error, &quot;Cannot find &quot;+file
-
 #--------------------------------------------------- tx_volume  ..extended for Vista
 def tx_volume():
     for path in string.split(os.environ[&quot;PATH&quot;], os.pathsep):
+        print path
         file = os.path.join(path, &quot;sndvol32&quot;) + &quot;.exe&quot;
-        try:
-            return os.spawnv(os.P_NOWAIT, file, (file,))
-        except os.error:
-            pass
-
-#Vista soundcontrol is now sndvol.exe and we try to open it           3LST
-    for path in string.split(os.environ[&quot;PATH&quot;], os.pathsep):
+        if os.path.exists(file):
+            os.spawnv(os.P_NOWAIT, file, (file,))
+            return
         file = os.path.join(path, &quot;sndvol&quot;) + &quot;.exe&quot;
-        try:
-            return os.spawnv(os.P_NOWAIT, file, (file,))
-        except os.error:
-            pass
+        if os.path.exists(file):
+            os.spawnv(os.P_NOWAIT, file, (file,))
+            return
 
-    raise os.error, &quot;Cannot find &quot;+file
-
 #---------------------------------------------------- fdf_change
 # Readout of graphical cursor location
 def fdf_change(event):
@@ -140,7 +133,6 @@
         g.DFreq=df*(event.x-288.7) + fmid - 1500
         if nfr.get()==2: g.DFreq=2*df*(event.x-375.5) + fmid - 1270.5
         g.Freq=g.DFreq+1270.46
-        if g.mode==&quot;WSPR&quot;: g.DFreq=g.DFreq+1270.46-1500.0
         t=&quot;Freq: %5d    DF: %5d  (Hz)&quot; % (int(g.Freq),int(g.DFreq))
     else:
         g.PingTime=0.04*event.x
@@ -153,15 +145,13 @@
 
 #---------------------------------------------------- set_freezedf
 def set_freezedf(event):
-    if g.mode[:4]=='JT65' or g.mode[:3]=='JT2' or \
-       g.mode[:3]=='JT4' or g.mode==&quot;WSPR&quot; or g.mode[:4]=='JT64':
+    if g.mode[:4]=='JT65' or g.mode[:3]=='JT4' or g.mode=='Diana':
         n=int(df*(event.x-288.7) + fmid - 1500)
         if nfr.get()==2: n=int(2*df*(event.x-375.5) + fmid - 1270.5)
 #        if n&lt;-600: n=-600
 #        if n&gt;600:  n=600
         if n&lt;-1270: n=-1270
         if n&gt;3800: n=3800
-        if g.mode==&quot;WSPR&quot;: n=n+1270-1500
         Audio.gcom2.mousedf=n
     else:
         decode_request(event)
@@ -181,22 +171,19 @@
         if g.mode[4:5]=='B': fstep=2*fstep
         if g.mode[4:5]=='C': fstep=4*fstep
 
-
 # Mark sync tone and top JT65 tone (green) and shorthand tones (red)
         if(frange==2000):
             dx=288.7 + (1500-fmid)/df
-            if g.mode[:4]==&quot;JT65&quot; or g.mode[:3]==&quot;JT2&quot; or \
-               g.mode[:3]==&quot;JT4&quot; or g.mode==&quot;WSPR&quot; or g.mode[:4]=='JT64':
+            if g.mode[:4]==&quot;JT65&quot; or g.mode[:3]==&quot;JT4&quot; or g.mode=='Diana':
                 color='green'
                 n=1
-                if g.mode[:4]==&quot;JT65&quot; or g.mode[:4]=='JT64':
+                if g.mode[:4]==&quot;JT65&quot;:
                     n=5
                     x1=(Audio.gcom2.mousedf + 6.6*fstep)/df + dx
                     c.create_line(x1-0.5,25,x1-0.5,12,fill=color)
                     c.create_line(x1+0.5,25,x1+0.5,12,fill=color)
                 for i in range(n):
                     mdf=Audio.gcom2.mousedf
-                    if g.mode==&quot;WSPR&quot;: mdf=mdf-1270+1500
                     x1=(mdf + i*fstep)/df + dx
                     j=12
                     if i&gt;0: j=15
@@ -205,18 +192,16 @@
                     color='red'
         if(frange==4000):
             dx=375 + (1270.5-fmid)/(2*df)
-            if g.mode[:4]==&quot;JT65&quot; or g.mode[:3]==&quot;JT2&quot; or \
-               g.mode[:3]==&quot;JT4&quot; or g.mode==&quot;WSPR&quot; or g.mode[:4]=='JT64':
+            if g.mode[:4]==&quot;JT65&quot; or g.mode[:3]==&quot;JT4&quot; or g.mode=='Diana':
                 color='green'
                 n=1
-                if g.mode[:4]==&quot;JT65&quot; or g.mode[:4]=='JT64':
+                if g.mode[:4]==&quot;JT65&quot;:
                     n=5
                     x1=(Audio.gcom2.mousedf + 6.6*fstep)/(2*df) + dx
                     c.create_line(x1-0.5,25,x1-0.5,12,fill=color)
                     c.create_line(x1+0.5,25,x1+0.5,12,fill=color)
                 for i in range(n):
                     mdf=Audio.gcom2.mousedf
-                    if g.mode==&quot;WSPR&quot;: mdf=mdf-1270+1500
                     x1=(mdf + i*fstep)/(2*df) + dx
                     j=12
                     if i&gt;0: j=15
@@ -255,18 +240,9 @@
 def set_frange():
     nfr.set(3-nfr.get())
 
-#---------------------------------------------------- freq_center
-##def freq_center(event):
-### Move clicked location to center of frequency scale
-##    global fmid,frange
-##    n=100*int(0.01*df*(event.x-375))
-##    fmid = fmid + n
-##    if fmid&lt;1000: fmid=1000
-##    if fmid&gt;1700: fmid=1700
-
 #---------------------------------------------------- decode_request
 def decode_request(event):
-    if (g.mode=='FSK441' or g.mode=='JT6M') and nspeed0.get()&gt;5:
+    if (g.mode=='FSK441' or g.mode=='JTMS') and nspeed0.get()&gt;5:
 # If decoder is busy or we are not monitoring, ignore request
         if Audio.gcom2.ndecoding==0 and Audio.gcom2.monitoring:
             Audio.gcom2.mousebutton=event.num       #Left=1, Right=3
@@ -276,10 +252,18 @@
             else:
                 Audio.gcom2.ndecoding=3             #Mouse pick, bottom half
 
+    elif g.mode=='ISCAT' and nspeed0.get()&gt;5 and \
+          Audio.gcom2.ndecoding==0 and Audio.gcom2.monitoring:
+        Audio.gcom2.mousebutton=event.num       #Left=1, Right=3
+        Audio.gcom2.npingtime=int(40*event.x)   #Time (ms) of selected ping
+        if event.y &lt;= 150:
+            Audio.gcom2.ndecoding=2             #Mouse pick, top half
+        else:
+            Audio.gcom2.ndecoding=3             #Mouse pick, bottom half
+
 #---------------------------------------------------- freeze_decode
 def freeze_decode(event):
-    if (g.mode[:4]=='JT65' or g.mode[:3]=='JT2' or
-        g.mode[:3]=='JT4' or g.mode==&quot;WSPR&quot; or g.mode[:4]=='JT64') \
+    if (g.mode[:4]=='JT65' or g.mode[:3]=='JT4' or g.mode=='Diana') \
        and nspeed0.get()&lt;6:
 # If decoder is busy or we are not monitoring, ignore request
         if Audio.gcom2.ndecoding==0 or Audio.gcom2.monitoring==0:
@@ -302,7 +286,7 @@
         root_geom=root.geometry()
         g.rms=Audio.gcom1.rms
         if isec==0: nscroll=0
-        if isec==59 and (g.mode!='WSPR' or utc[4]%2==1): newMinute=1
+        if isec==59: newMinute=1
 
     if g.showspecjt==1:
         showspecjt()
@@ -348,7 +332,7 @@
         if Audio.gcom2.monitoring:
             if minsep.get() and newMinute:
                 draw.line((0,0,749,0),fill=128)     #Draw the minute separator
-            if nscroll == 13 and (g.mode!='WSPR' or utc[4]%2==0):
+            if nscroll == 13:
                 draw.text((5,2),t0[0:5],fill=253)   #Insert time label
         else:
             if minsep.get():
@@ -371,8 +355,8 @@
         newMinute=0
 
     if (Audio.gcom2.mousedf != mousedf0 or Audio.gcom2.dftolerance != tol0) \
-            and (g.mode[:4]=='JT65' or g.mode[:3]=='JT2' or \
-                 g.mode[:3]=='JT4' or g.mode==&quot;WSPR&quot; or g.mode[:4]=='JT64'):
+            and (g.mode[:4]=='JT65' or g.mode[:3]=='JT4' \
+            or g.mode=='Diana'):
         df_mark()
         
 # The following int() calls are to ensure that the values copied to
@@ -386,11 +370,12 @@
         nfreeze0=int(Audio.gcom2.nfreeze)
 
     if g.mode!=mode0:
-        if (g.mode[:4]==&quot;JT65&quot; or g.mode[:3]==&quot;JT2&quot; or \
-            g.mode[:3]==&quot;JT4&quot; or g.mode==&quot;WSPR&quot; or g.mode[:4]=='JT64') \
+        if (g.mode[:4]==&quot;JT65&quot; or g.mode[:3]==&quot;JT4&quot; or g.mode=='Diana') \
            and nspeed0.get()&gt;5: nspeed0.set(3)
-        if g.mode==&quot;FSK441&quot; and nspeed0.get()&lt;6: nspeed0.set(6)
-        if g.mode==&quot;JT6M&quot; and nspeed0.get()&lt;6: nspeed0.set(6)
+        if g.mode==&quot;FSK441&quot; and nspeed0.get()&lt;6: nspeed0.set(7)
+        if g.mode==&quot;JTMS&quot; and nspeed0.get()&lt;6: nspeed0.set(7)
+        if g.mode==&quot;ISCAT&quot; and nspeed0.get()&lt;6: nspeed0.set(7)
+        if g.mode==&quot;Echo&quot; and nspeed0.get()&gt;5: nspeed0.set(3)
         draw_axis()
         mode0=g.mode
 
@@ -418,10 +403,7 @@
 def draw_axis():
     xmid=fmid
     if naxis.get():
-        if g.mode=='WSPR':
-            xmid=xmid-1500
-        else:
-            xmid=xmid-1270.46
+        xmid=xmid-1270.46
     c.delete(ALL)
     if nspeed0.get()&lt;6:
 # Draw the frequency or DF tick marks
@@ -449,8 +431,7 @@
                     c.create_text(x,y,text=str(ix))
                 c.create_line(i,25,i,j,fill='black')
                 
-        if g.mode[:4]==&quot;JT65&quot; or g.mode[:3]==&quot;JT2&quot; or \
-           g.mode[:3]==&quot;JT4&quot; or g.mode==&quot;WSPR&quot; or g.mode[:4]=='JT64':
+        if g.mode[:4]==&quot;JT65&quot; or g.mode[:3]==&quot;JT4&quot; or g.mode=='Diana':
             dx=288.7 + (1500-fmid)/df
             dff=df
             if frange==4000:
@@ -462,7 +443,6 @@
             else:
                 tol=Audio.gcom2.dftolerance
                 mdf=Audio.gcom2.mousedf
-                if g.mode==&quot;WSPR&quot;: mdf=mdf-1270+1500
                 x1=(mdf-tol)/dff + dx
                 x2=(mdf+tol)/dff + dx
             c.create_line(x1,25,x2,25,fill='green',width=2)
@@ -535,6 +515,7 @@
 setupmenu.palettes.add_radiobutton(label='AFMHot',command=pal_AFMHot,
             value=5,variable=npal)
 setupmenu.add_cascade(label = 'Palette',menu=setupmenu.palettes)
+setupmenu.add_checkbutton(label='Logarithmic scale',variable=logmap)
 
 if (sys.platform == 'darwin'):
    mbar.add_cascade(label=&quot;Options&quot;, menu=setupmenu)
@@ -567,7 +548,7 @@
     if i==6: t=&quot;H1&quot;
     if i==7: t=&quot;H2&quot;
     Radiobutton(sbar,text=t,value=i,variable=nspeed0).pack(side=RIGHT)
-nspeed0.set(6)
+nspeed0.set(7)
 lab2=Label(sbar,text='Speed: ',bd=0)
 lab2.pack(side=RIGHT)
 #------------------------------------------------- Graphics frame
@@ -577,14 +558,11 @@
 Widget.bind(c,&quot;&lt;Shift-Button-1&gt;&quot;,freq_range)
 Widget.bind(c,&quot;&lt;Shift-Button-2&gt;&quot;,freq_range)
 Widget.bind(c,&quot;&lt;Shift-Button-3&gt;&quot;,freq_range)
-#Widget.bind(c,&quot;&lt;Control-Button-1&gt;&quot;,freq_center)
-
 graph1=Canvas(iframe1, bg='black', width=750, height=300,bd=0,cursor='crosshair')
 graph1.pack(side=TOP)
 Widget.bind(graph1,&quot;&lt;Motion&gt;&quot;,fdf_change)
-#Widget.bind(graph1,&quot;&lt;Button-1&gt;&quot;,decode_request)
-Widget.bind(graph1,&quot;&lt;Button-3&gt;&quot;,decode_request)
 Widget.bind(graph1,&quot;&lt;Button-1&gt;&quot;,set_freezedf)
+Widget.bind(graph1,&quot;&lt;Button-3&gt;&quot;,decode_request)
 Widget.bind(graph1,&quot;&lt;Double-Button-1&gt;&quot;,freeze_decode)
 iframe1.pack(expand=1, fill=X)
 

Modified: trunk/Wsjt_Howto_MacOSX_10.6.html
===================================================================
--- trunk/Wsjt_Howto_MacOSX_10.6.html	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/Wsjt_Howto_MacOSX_10.6.html	2010-10-26 13:46:16 UTC (rev 2230)
@@ -18,7 +18,7 @@
 &lt;b&gt;Step 1. &lt;/b&gt;You need to install the Mac Developer Tool - Xcode.   Visit 
 &lt;a href=&quot;<A HREF="http://developer.apple.com/support/mac/tools">http://developer.apple.com/support/mac/tools</A>&quot;&gt;<A HREF="http://developer.apple.com/support/mac/tools&lt;/a">http://developer.apple.com/support/mac/tools&lt;/a</A>&gt;  and create a (free) ADC account
 then visit the Developer Tools in the downloads section and get the latest release
-of Xcode Developer Tools.  This must be the version for Snow Leopard and will  3.2.1 or later.  You will need  Fortran.&lt;br&gt;&lt;br&gt;
+of Xcode Developer Tools.  This must be the version for Snow Leopard and will  3.2.3 or later.  You will need  Fortran.&lt;br&gt;&lt;br&gt;
 &lt;b&gt;Step 2. &lt;/b&gt;There are several versions that are available but I recommend 
 &lt;a href=&quot;<A HREF="http://r.research.att.com/tools">http://r.research.att.com/tools</A>&quot;&gt;<A HREF="http://r.research.att.com/tools&lt;/a">http://r.research.att.com/tools&lt;/a</A>&gt;.   At the time of writing the latest version is
 gfortran-4.2-5646.pkg for Snow Leopard.   Download this and install.&lt;br&gt; &lt;br&gt;
@@ -66,6 +66,7 @@
 and download libsamplerate-0.1.7.tar.gz.  Untar this file and then remove the CC and LDFLAGS parameters: &lt;br&gt;
 unsetenv CC&lt;br&gt;
 unsetenv LDFLAGS&lt;br&gt;
+setenv CFLAGS &quot;-arch i386&quot;&lt;br&gt;
 cd libsamplerate-0.1.7&lt;br&gt;configure&lt;br&gt;make&lt;br&gt;sudo make install &lt;br&gt;&lt;br&gt;
 &lt;em&gt;portaudio&lt;/em&gt; Change back to the Installation directory and visit &lt;a href=&quot;<A HREF="http://www.portaudio.com/archives/">http://www.portaudio.com/archives/</A>&quot;&gt;<A HREF="http://www.portaudio.com/archives/&lt;/a">http://www.portaudio.com/archives/&lt;/a</A>&gt; 
 and download pa_snapshot_v19.tar.gz which is the version I use.   There is another v19 issue at <A HREF="http://www.portaudio.com/download.html">http://www.portaudio.com/download.html</A> but I havn't tested this. Untar this file and then:&lt;br&gt; 

Deleted: trunk/abc441.F90
===================================================================
--- trunk/abc441.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/abc441.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,29 +0,0 @@
-subroutine abc441(msg,nmsg,itone,ndits)
-
-  character msg*28
-  integer itone(84)
-  integer lookup(0:91)
-  character cc*43
-  data cc/' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ.,?/#$'/
-  data lookup/13, 15, 17, 46, 47, 45, 44, 12, 11, 14, &amp;
-               1,  2,  3,  4,  5,  6,  7,  8,  9, 10, &amp;
-              16, 48, 18, 19, 20, 21, 22, 23, 24, 25, &amp;
-              26, 27, 15, 29, 30, 14, 16, 42, 46, 35, &amp;
-              36, 37, 21,  0, 11, 41, 10, 13, 43,  1, &amp;
-               2,  3,  4,  5,  6,  7,  8,  9, 49, 56, &amp;
-              52, 55, 54, 12, 63, 17, 18, 19, 20, 44, &amp;
-              22, 23, 24, 25, 26, 27, 28, 29, 30, 31, &amp;
-              32, 33, 34, 35, 36, 37, 38, 39, 40, 41, &amp;
-              45, 63/
-
-  do i=1,nmsg
-     n=ichar(msg(i:i))
-     if(n.lt.0 .or. n.gt.91) n=32 !Replace illegal char with blank 
-     n=lookup(n)
-     itone(3*i-2)=n/16 + 1
-     itone(3*i-1)=mod(n/4,4) + 1
-     itone(3*i)=mod(n,4) + 1
-  enddo
-  ndits=3*nmsg
-  return
-end subroutine abc441

Copied: trunk/abc441.f90 (from rev 2228, wsjt7a/abc441.f90)
===================================================================
--- trunk/abc441.f90	                        (rev 0)
+++ trunk/abc441.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,29 @@
+subroutine abc441(msg,nmsg,itone,ndits)
+
+  character msg*28
+  integer itone(84)
+  integer lookup(0:91)
+  character cc*43
+  data cc/' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ.,?/#$'/
+  data lookup/13, 15, 17, 46, 47, 45, 44, 12, 11, 14, &amp;
+               1,  2,  3,  4,  5,  6,  7,  8,  9, 10, &amp;
+              16, 48, 18, 19, 20, 21, 22, 23, 24, 25, &amp;
+              26, 27, 15, 47, 30, 14, 16, 42, 46, 35, &amp;
+              36, 37, 21,  0, 11, 41, 10, 13, 43,  1, &amp;
+               2,  3,  4,  5,  6,  7,  8,  9, 49, 56, &amp;
+              52, 55, 54, 12, 63, 17, 18, 19, 20, 44, &amp;
+              22, 23, 24, 25, 26, 27, 28, 29, 30, 31, &amp;
+              32, 33, 34, 35, 36, 37, 38, 39, 40, 41, &amp;
+              45, 63/
+
+  do i=1,nmsg
+     j=ichar(msg(i:i))
+     if(j.lt.0 .or. j.gt.91) j=32 !Replace illegal char with blank 
+     n=lookup(j)
+     itone(3*i-2)=n/16 + 1
+     itone(3*i-1)=mod(n/4,4) + 1
+     itone(3*i)=mod(n,4) + 1
+  enddo
+  ndits=3*nmsg
+  return
+end subroutine abc441

Copied: trunk/align28.f90 (from rev 2228, wsjt7a/align28.f90)
===================================================================
--- trunk/align28.f90	                        (rev 0)
+++ trunk/align28.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,38 @@
+subroutine align28(word0,nmin,msg,msglen,idone)
+
+  character*(*) word0
+  character*28 msg,word
+
+  word=word0//' '
+  idone=0
+
+! Test for two (or more) &lt;space&gt; characters
+  if(word(1:2).eq.'  ' .and. len(word).eq.2) then
+     i2=index(msg,'  ')
+     if((i2.ge.1.and.i2.lt.msglen) .or.                                 &amp;
+          (msg(1:1).eq.' '.and.msg(msglen:msglen).eq.' ')) then
+        if(i2.eq.1) msg=msg(i2+2:msglen)           !Align on EOM
+        if(i2.ge.2) msg=msg(i2+2:msglen)//msg(1:i2-1)
+        idone=1
+     endif
+
+! Align on single &lt;space&gt; (as last resort)
+  else if(word(1:1).eq.' ' .and. len(word).eq.1) then
+     i3=index(msg,' ')
+     if(i3.ge.1 .and. i3.lt.msglen) msg=msg(i3+1:msglen)//msg(1:i3)
+     if(i3.eq.msglen) msg=msg(1:msglen)
+     msg=msg(1:msglen)//msg(1:msglen)
+     idone=1
+
+! Align on specified word
+  else
+     call match(word,msg(1:msglen),nstart,nmatch)
+     if(nmatch.ge.nmin) then
+        if(nstart.eq.1) msg=msg(nstart:msglen)
+        if(nstart.gt.1) msg=msg(nstart:msglen)//msg(1:nstart-1)
+        idone=1
+     endif
+  endif
+
+  return
+end subroutine align28

Copied: trunk/alignmsg.f90 (from rev 2228, wsjt7a/alignmsg.f90)
===================================================================
--- trunk/alignmsg.f90	                        (rev 0)
+++ trunk/alignmsg.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,38 @@
+subroutine alignmsg(word0,nmin,msg,msglen,idone)
+
+  character*(*) word0
+  character*29 msg,word
+
+  word=word0//' '
+  idone=0
+
+! Test for two (or more) &lt;space&gt; characters
+  if(word(1:2).eq.'  ' .and. len(word).eq.2) then
+     i2=index(msg,'  ')
+     if((i2.ge.1.and.i2.lt.msglen) .or.                                 &amp;
+          (msg(1:1).eq.' '.and.msg(msglen:msglen).eq.' ')) then
+        if(i2.eq.1) msg=msg(i2+2:msglen)           !Align on EOM
+        if(i2.ge.2) msg=msg(i2+2:msglen)//msg(1:i2-1)
+        idone=1
+     endif
+
+! Align on single &lt;space&gt; (as last resort)
+  else if(word(1:1).eq.' ' .and. len(word).eq.1) then
+     i3=index(msg,' ')
+     if(i3.ge.1 .and. i3.lt.msglen) msg=msg(i3+1:msglen)//msg(1:i3)
+     if(i3.eq.msglen) msg=msg(1:msglen)
+     msg=msg(1:msglen)//msg(1:msglen)
+     idone=1
+
+! Align on specified word
+  else
+     call match(word,msg(1:msglen),nstart,nmatch)
+     if(nmatch.ge.nmin) then
+        if(nstart.eq.1) msg=msg(nstart:msglen)
+        if(nstart.gt.1) msg=msg(nstart:msglen)//msg(1:nstart-1)
+        idone=1
+     endif
+  endif
+
+  return
+end subroutine alignmsg

Copied: trunk/analytic.f90 (from rev 2228, wsjt7a/analytic.f90)
===================================================================
--- trunk/analytic.f90	                        (rev 0)
+++ trunk/analytic.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,27 @@
+subroutine analytic(d,npts,nfft1,s,c)
+
+! Convert real data to a complex (&quot;analytic&quot;) signal
+
+  parameter (NMAX=512*1024)
+  real d(npts)
+  real s(NMAX)
+  complex c(NMAX)
+
+  nh=nfft1/2
+  fac=2.0/nfft1
+  do i=1,npts
+     c(i)=fac*d(i)
+  enddo
+  c(npts+1:nfft1)=0.
+  call four2a(c,nfft1,1,-1,1)
+
+  do i=1,nh
+     s(i)=real(c(i))**2 + aimag(c(i))**2
+  enddo
+
+  c(1)=0.5*c(1)
+  c(nh+2:nfft1)=0.
+  call four2a(c,nfft1,1,1,1)
+
+  return
+end subroutine analytic

Deleted: trunk/astro.F
===================================================================
--- trunk/astro.F	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/astro.F	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,88 +0,0 @@
-      subroutine astro(nyear,month,nday,uth,nfreq,Mygrid,
-     +     NStation,mode,MoonDX,AzSun,ElSun,AzMoon,ElMoon0,
-     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
-     +     poloffset,xnr,auxra,auxdec,azaux,elaux)
-
-C  Computes astronomical quantities for display in JT65, CW, and EME Echo mode.
-C  NB: may want to smooth the Tsky map to 10 degrees or so.
-
-      character*6 MyGrid,HisGrid
-      logical ltsky
-      real LST
-      real lat,lon
-      real ldeg
-      integer*2 nsky
-      common/sky/ nsky(360,180)
-      common/echo/xdop(2),techo,ElMoon,mjd
-      data rad/57.2957795/
-      save
-
-      ltsky=nsky(1,1).eq.192
-
-      call grid2deg(MyGrid,elon,lat)
-      lon=-elon
-      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
-     +    AzSun,ElSun,mjd)
-
-      freq=nfreq*1.e6
-      if(nfreq.eq.2) freq=1.8e6
-      if(nfreq.eq.4) freq=3.5e6
-
-      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
-     +  LST,HA,AzMoon,ElMoon,ldeg,bdeg,vr,dist)
-
-C  Compute spatial polarization offset
-      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
-     +     cos(AzMoon/rad)*sin(ElMoon/rad)
-      yy=cos(lat/rad)*sin(AzMoon/rad)
-      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
-      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
-
-      techo=2.0 * dist/2.99792458e5                 !Echo delay time
-      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
-      t408=ftsky(ldeg,bdeg)                         !Read sky map
-      tsky=t408*(408.0/nfreq)**2.6                  !Tsky for obs freq
-      if(ltsky.and.(tsky.lt.3.0)) tsky=3.0          !Minimum = 3 Kelvin
-
-      xdop(NStation)=doppler
-      if(NStation.eq.2) then
-         HisGrid=MyGrid
-         go to 900
-      endif
-
-      doppler00=2.0*xdop(1)
-      if(mode.eq.2 .or. mode.eq.5) doppler=xdop(1)+xdop(2)
-      if(mode.eq.3) doppler=2.0*xdop(1)
-      dBMoon=-40.0*log10(dist/356903.)
-      sd=16.23*370152.0/dist
-
-!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
-!     +    (mode.eq.2 .or. mode.eq.5)) then
-      if(NStation.eq.1 .and. MoonDX.ne.0) then
-         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
-         if(poloffset.gt.90.0) poloffset=poloffset-180.0
-         x1=abs(cos(2*poloffset/rad))
-         if(x1.lt.0.056234) x1=0.056234
-         xnr=-20.0*log10(x1)
-         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'Z') xnr=0
-      endif
-
-      tr=80.0                              !Good preamp
-      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
-      tsysmin=tskymin+tr
-      tsys=tsky+tr
-      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
- 900  ElMoon0=Elmoon
-      ntsky=nint(tsky)
-
-      auxHA = 15.0*(LST-auxra)                       !HA in degrees
-      pi=3.14159265
-      pio2=0.5*pi
-      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
-     +  auxdec/rad,azaux,elaux)
-      AzAux=azaux*rad
-      ElAux=ElAux*rad
-
-      return
-
-      end

Copied: trunk/astro.f (from rev 2228, wsjt7a/astro.f)
===================================================================
--- trunk/astro.f	                        (rev 0)
+++ trunk/astro.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,88 @@
+      subroutine astro(nyear,month,nday,uth,nfreq,Mygrid,
+     +     NStation,mode,MoonDX,AzSun,ElSun,AzMoon,ElMoon0,
+     +     ntsky,doppler00,doppler,dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,
+     +     poloffset,xnr,auxra,auxdec,azaux,elaux,day,lon,lat,LST)
+
+C  Computes astronomical quantities for display in JT65, CW, and EME Echo mode.
+C  NB: may want to smooth the Tsky map to 10 degrees or so.
+
+      character*6 MyGrid,HisGrid
+      logical ltsky
+      real LST
+      real lat,lon
+      real ldeg
+      integer*2 nsky
+      common/sky/ nsky(360,180)
+      common/echo/xdop(2),techo,ElMoon,mjd
+      data rad/57.2957795/
+      save
+
+      ltsky=nsky(1,1).eq.192
+
+      call grid2deg(MyGrid,elon,lat)
+      lon=-elon
+      call sun(nyear,month,nday,uth,lon,lat,RASun,DecSun,LST,
+     +    AzSun,ElSun,mjd,day)
+
+      freq=nfreq*1.e6
+      if(nfreq.eq.2) freq=1.8e6
+      if(nfreq.eq.4) freq=3.5e6
+
+      call MoonDop(nyear,month,nday,uth,lon,lat,RAMoon,DecMoon,
+     +  LST,HA,AzMoon,ElMoon,ldeg,bdeg,vr,dist)
+
+C  Compute spatial polarization offset
+      xx=sin(lat/rad)*cos(ElMoon/rad) - cos(lat/rad)*
+     +     cos(AzMoon/rad)*sin(ElMoon/rad)
+      yy=cos(lat/rad)*sin(AzMoon/rad)
+      if(NStation.eq.1) poloffset1=rad*atan2(yy,xx)
+      if(NStation.eq.2) poloffset2=rad*atan2(yy,xx)
+
+      techo=2.0 * dist/2.99792458e5                 !Echo delay time
+      doppler=-freq*vr/2.99792458e5                 !One-way Doppler
+      t408=ftsky(ldeg,bdeg)                         !Read sky map
+      tsky=t408*(408.0/nfreq)**2.6                  !Tsky for obs freq
+      if(ltsky.and.(tsky.lt.3.0)) tsky=3.0          !Minimum = 3 Kelvin
+
+      xdop(NStation)=doppler
+      if(NStation.eq.2) then
+         HisGrid=MyGrid
+         go to 900
+      endif
+
+      doppler00=2.0*xdop(1)
+      if(mode.eq.2 .or. mode.eq.5) doppler=xdop(1)+xdop(2)
+      if(mode.eq.3) doppler=2.0*xdop(1)
+      dBMoon=-40.0*log10(dist/356903.)
+      sd=16.23*370152.0/dist
+
+!      if(NStation.eq.1 .and. MoonDX.ne.0 .and. 
+!     +    (mode.eq.2 .or. mode.eq.5)) then
+      if(NStation.eq.1 .and. MoonDX.ne.0) then
+         poloffset=mod(poloffset2-poloffset1+720.0,180.0)
+         if(poloffset.gt.90.0) poloffset=poloffset-180.0
+         x1=abs(cos(2*poloffset/rad))
+         if(x1.lt.0.056234) x1=0.056234
+         xnr=-20.0*log10(x1)
+         if(HisGrid(1:1).lt.'A' .or. HisGrid(1:1).gt.'Z') xnr=0
+      endif
+
+      tr=80.0                              !Good preamp
+      tskymin=13.0*(408.0/nfreq)**2.6      !Cold sky temperature
+      tsysmin=tskymin+tr
+      tsys=tsky+tr
+      dgrd=-10.0*log10(tsys/tsysmin) + dbMoon
+ 900  ElMoon0=Elmoon
+      ntsky=nint(tsky)
+
+      auxHA = 15.0*(LST-auxra)                       !HA in degrees
+      pi=3.14159265
+      pio2=0.5*pi
+      call coord(pi,pio2-lat/rad,0.0,lat/rad,auxha*pi/180.0,
+     +  auxdec/rad,azaux,elaux)
+      AzAux=azaux*rad
+      ElAux=ElAux*rad
+
+      return
+
+      end

Deleted: trunk/astro0.F90
===================================================================
--- trunk/astro0.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/astro0.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,125 +0,0 @@
-subroutine astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
-     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
-     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
-     RaAux8,DecAux8,AzAux8,ElAux8)
-
-!f2py threadsafe
-!f2py intent(in) nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec
-!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8
-
-  character grid*6
-  character*9 cauxra,cauxdec
-  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,AzAux8,ElAux8
-  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0,dt
-  real*8 sd8,poloffset8
-  include 'gcom2.f90'
-  data uth8z/0.d0/,imin0/-99/
-  save
-
-  call cs_lock('astro0a')
-  auxra=0.
-  i=index(cauxra,':')
-  if(i.eq.0) then
-     read(cauxra,*,err=1,end=1) auxra
-  else
-     read(cauxra(1:i-1),*,err=1,end=1) ih
-     read(cauxra(i+1:i+2),*,err=1,end=1) im
-     read(cauxra(i+4:i+5),*,err=1,end=1) is
-     auxra=ih + im/60.0 + is/3600.0
-  endif
-1 auxdec=0.
-  i=index(cauxdec,':')
-  if(i.eq.0) then
-     read(cauxdec,*,err=2,end=2) auxdec
-  else
-     read(cauxdec(1:i-1),*,err=2,end=2) id
-     read(cauxdec(i+1:i+2),*,err=2,end=2) im
-     read(cauxdec(i+4:i+5),*,err=2,end=2) is
-     auxdec=id + im/60.0 + is/3600.0
-  endif
-
-2 nmode=1
-  if(mode(1:4).eq.'JT65') then
-     nmode=2
-     if(mode(5:5).eq.'A') mode65=1
-     if(mode(5:5).eq.'B') mode65=2
-     if(mode(5:5).eq.'C') mode65=4
-  endif
-  if(mode(1:4).eq.'Echo') nmode=3
-  if(mode(1:4).eq.'JT6M') nmode=4
-  if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:3).eq.'JT2') nmode=6
-  if(mode(1:3).eq.'JT4') nmode=7
-  if(mode(1:4).eq.'WSPR') nmode=8
-  if(mode(1:4).eq.'JT64') nmode=9
-  uth=uth8
-  call cs_unlock
-
-  call astro(nyear,month,nday,uth,nfreq,hisgrid,2,nmode,1,    &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
-  AzMoonB8=AzMoon
-  ElMoonB8=ElMoon
-  call astro(nyear,month,nday,uth,nfreq,grid,1,nmode,1,       &amp;
-       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
-       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
-       AzAux,ElAux)
-
-  RaAux8=auxra
-  DecAux8=auxdec
-  AzSun8=AzSun
-  ElSun8=ElSun
-  AzMoon8=AzMoon
-  ElMoon8=ElMoon
-  dbMoon8=dbMoon
-  RAMoon8=RAMoon/15.0
-  DecMoon8=DecMoon
-  HA8=HA
-  Dgrd8=Dgrd
-  sd8=sd
-  poloffset8=poloffset
-  xnr8=xnr
-  AzAux8=AzAux
-  ElAux8=ElAux
-  ndop=nint(doppler)
-  ndop00=nint(doppler00)
-
-  if(uth8z.eq.0.d0) then
-     uth8z=uth8-1.d0/3600.d0
-     dopplerz=doppler
-     doppler00z=doppler00
-  endif
-     
-  dt=60.0*(uth8-uth8z)
-  if(dt.le.0) dt=1.d0/60.d0
-  dfdt=(doppler-dopplerz)/dt
-  dfdt0=(doppler00-doppler00z)/dt
-  uth8z=uth8
-  dopplerz=doppler
-  doppler00z=doppler00
-
-  imin=60*uth8
-  isec=3600*uth8
-
-  if(isec.ne.isec0 .and. ndecoding.eq.0) then
-     call cs_lock('astro0b')
-     ih=uth8
-     im=mod(imin,60)
-     is=mod(isec,60)
-     rewind 14
-     write(14,1010,err=800) ih,im,is,AzMoon,ElMoon,                          &amp;
-        ih,im,is,AzSun,ElSun,                                        &amp;
-        ih,im,is,AzAux,ElAux,                                        &amp;
-        nfreq,doppler,dfdt,doppler00,dfdt0
-1010 format(i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Moon'/        &amp;
-            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Sun'/         &amp;
-            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Source'/      &amp;
-            i5,',',f8.1,',',f8.2,',',f8.1,',',f8.2,',Doppler')
-     rewind 14
-800  isec0=isec
-     call cs_unlock
-  endif
-
-  return
-end subroutine astro0

Copied: trunk/astro0.f90 (from rev 2228, wsjt7a/astro0.f90)
===================================================================
--- trunk/astro0.f90	                        (rev 0)
+++ trunk/astro0.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,157 @@
+subroutine astro0(nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec,       &amp;
+     AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,  &amp;
+     dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,  &amp;
+     RaAux8,DecAux8,AzAux8,ElAux8,width1,width2,w501,w502,xlst8)
+
+!f2py threadsafe
+!f2py intent(in) nyear,month,nday,uth8,nfreq,grid,cauxra,cauxdec
+!f2py intent(out) AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,ntsky,ndop,ndop00,dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,sd8,poloffset8,xnr8,dfdt,dfdt0,RaAux8,DecAux8,AzAux8,ElAux8,width1,width2,w501,w502,xlst8
+
+  parameter (DEGS=57.2957795130823d0)
+  character grid*6
+  character*9 cauxra,cauxdec
+  real*8 AzSun8,ElSun8,AzMoon8,ElMoon8,AzMoonB8,ElMoonB8,AzAux8,ElAux8
+  real*8 dbMoon8,RAMoon8,DecMoon8,HA8,Dgrd8,xnr8,dfdt,dfdt0,dt
+  real*8 sd8,poloffset8,day8,width1,width2,w501,w502,xlst8
+  include 'gcom2.f90'
+  data uth8z/0.d0/,imin0/-99/
+  save
+
+  call cs_lock('astro0a')
+  auxra=0.
+  i=index(cauxra,':')
+  if(i.eq.0) then
+     read(cauxra,*,err=1,end=1) auxra
+  else
+     read(cauxra(1:i-1),*,err=1,end=1) ih
+     read(cauxra(i+1:i+2),*,err=1,end=1) im
+     read(cauxra(i+4:i+5),*,err=1,end=1) is
+     auxra=ih + im/60.0 + is/3600.0
+  endif
+1 auxdec=0.
+  i=index(cauxdec,':')
+  if(i.eq.0) then
+     read(cauxdec,*,err=2,end=2) auxdec
+  else
+     read(cauxdec(1:i-1),*,err=2,end=2) id
+     read(cauxdec(i+1:i+2),*,err=2,end=2) im
+     read(cauxdec(i+4:i+5),*,err=2,end=2) is
+     auxdec=abs(id) + im/60.0 + is/3600.0
+     if(cauxdec(1:1).eq.'-') auxdec=-auxdec
+  endif
+
+2 nmode=1
+  if(mode(1:4).eq.'JT65') then
+     nmode=2
+     if(mode(5:5).eq.'A') mode65=1
+     if(mode(5:5).eq.'B') mode65=2
+     if(mode(5:5).eq.'C') mode65=4
+  endif
+  if(mode(1:4).eq.'Echo') nmode=3
+  if(mode(1:2).eq.'CW') nmode=5
+  if(mode(1:3).eq.'JT4') nmode=7
+  if(mode(1:4).eq.'JTMS') nmode=8
+  if(mode(1:5).eq.'ISCAT') nmode=9
+
+  uth=uth8
+  call cs_unlock
+
+  call astro(nyear,month,nday,uth,nfreq,hisgrid,2,nmode,1,    &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
+       AzAux,ElAux,day,xlon2,xlat2,xlst)
+  AzMoonB8=AzMoon
+  ElMoonB8=ElMoon
+  call astro(nyear,month,nday,uth,nfreq,grid,1,nmode,1,       &amp;
+       AzSun,ElSun,AzMoon,ElMoon,ntsky,doppler00,doppler,            &amp;
+       dbMoon,RAMoon,DecMoon,HA,Dgrd,sd,poloffset,xnr,auxra,auxdec,  &amp;
+       AzAux,ElAux,day,xlon1,xlat1,xlst)
+
+  day8=day
+  xlst8=xlst
+  call tm2(day8,xlat1,xlon1,xl1,b1)
+  call tm2(day8,xlat2,xlon2,xl2,b2)
+  call tm2(day8+1.d0/1440.0,xlat1,xlon1,xl1a,b1a)
+  call tm2(day8+1.d0/1440.0,xlat2,xlon2,xl2a,b2a)
+  fghz=0.001*nfreq
+  dldt1=DEGS*(xl1a-xl1)
+  dbdt1=DEGS*(b1a-b1)
+  dldt2=DEGS*(xl2a-xl2)
+  dbdt2=DEGS*(b2a-b2)
+  rate1=2.0*sqrt(dldt1**2 + dbdt1**2)
+  width1=0.5*6741*fghz*rate1
+  rate2=sqrt((dldt1+dldt2)**2 + (dbdt1+dbdt2)**2)
+  width2=0.5*6741*fghz*rate2
+
+  fbend=0.7
+  a2=0.0045*log(fghz/fbend)/log(1.05)
+  if(fghz.lt.fbend) a2=0.0
+  f50=0.19 * (fghz/fbend)**a2
+  if(f50.gt.1.0) f50=1.0
+  w501=f50*width1
+  w502=f50*width2
+
+  RaAux8=auxra
+  DecAux8=auxdec
+  AzSun8=AzSun
+  ElSun8=ElSun
+  AzMoon8=AzMoon
+  ElMoon8=ElMoon
+  dbMoon8=dbMoon
+  RAMoon8=RAMoon/15.0
+  DecMoon8=DecMoon
+  HA8=HA
+  Dgrd8=Dgrd
+  sd8=sd
+  poloffset8=poloffset
+  xnr8=xnr
+  AzAux8=AzAux
+  ElAux8=ElAux
+  ndop=nint(doppler)
+  ndop00=nint(doppler00)
+
+  if(uth8z.eq.0.d0) then
+     uth8z=uth8-1.d0/3600.d0
+     dopplerz=doppler
+     doppler00z=doppler00
+  endif
+     
+  dt=60.0*(uth8-uth8z)
+  if(dt.le.0) dt=1.d0/60.d0
+  dfdt=(doppler-dopplerz)/dt
+  dfdt0=(doppler00-doppler00z)/dt
+  uth8z=uth8
+  dopplerz=doppler
+  doppler00z=doppler00
+
+  imin=60*uth8
+  isec=3600*uth8
+
+  if(isec.ne.isec0 .and. ndecoding.eq.0) then
+     call cs_lock('astro0b')
+     ih=uth8
+     im=mod(imin,60)
+     is=mod(isec,60)
+     do i=80,1,-1
+        if(AzElDir(i:i).ne.' ') goto 700
+     enddo
+700  jz=i
+     open(14,file=AzElDir(:jz)//'/azel.dat',status='unknown',err=930)
+     write(14,1010,err=800) ih,im,is,AzMoon,ElMoon,                  &amp;
+        ih,im,is,AzSun,ElSun,                                        &amp;
+        ih,im,is,AzAux,ElAux,                                        &amp;
+        nfreq,doppler,dfdt,doppler00,dfdt0
+1010 format(i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Moon'/        &amp;
+            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Sun'/         &amp;
+            i2.2,':',i2.2,':',i2.2,',',f5.1,',',f5.1,',Source'/      &amp;
+            i5,',',f8.1,',',f8.2,',',f8.1,',',f8.2,',Doppler')
+     close(14)
+800  isec0=isec
+     call cs_unlock
+  endif
+  return
+
+930 print*,'Error opening azel.dat'
+  stop
+
+end subroutine astro0

Deleted: trunk/audio_init.F90
===================================================================
--- trunk/audio_init.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/audio_init.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,78 +0,0 @@
-subroutine audio_init(ndin,ndout)
-!f2py threadsafe
-
-#ifdef CVF
-  use dfmt
-  integer Thread1,Thread2,ABOVE_NORMAL_PRIORITY_CLASS
-  parameter (ABOVE_NORMAL_PRIORITY_CLASS=32768)
-  external a2d,decode1
-#endif
-  integer start_threads
-
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  nmode=1
-  if(mode(1:4).eq.'JT65') then
-     nmode=2
-     if(mode(5:5).eq.'A') mode65=1
-     if(mode(5:5).eq.'B') mode65=2
-     if(mode(5:5).eq.'C') mode65=4
-  endif
-  if(mode(1:4).eq.'Echo') nmode=3
-  if(mode(1:4).eq.'JT6M') nmode=4
-  if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:3).eq.'JT2') nmode=6
-  if(mode(1:3).eq.'JT4') nmode=7
-  if(mode(1:4).eq.'WSPR') nmode=8
-  if(mode(1:4).eq.'JT64') nmode=9
-
-  ndevin=ndin
-  ndevout=ndout
-  TxOK=0
-  Transmitting=0
-  nfsample=11025
-  nspb=1024
-  nbufs=2048
-  nmax=nbufs*nspb
-  nwave=60*nfsample
-  ngo=1
-  f0=800.0
-  do i=1,nwave
-     iwave(i)=nint(32767.0*sin(6.283185307*i*f0/nfsample))
-  enddo
-
-#ifdef CVF
-!  Priority classes (for processes):
-!     IDLE_PRIORITY_CLASS               64
-!     NORMAL_PRIORITY_CLASS             32
-!     HIGH_PRIORITY_CLASS              128
-
-!  Priority definitions (for threads):
-!     THREAD_PRIORITY_IDLE             -15
-!     THREAD_PRIORITY_LOWEST            -2
-!     THREAD_PRIORITY_BELOW_NORMAL      -1
-!     THREAD_PRIORITY_NORMAL             0
-!     THREAD_PRIORITY_ABOVE_NORMAL       1
-!     THREAD_PRIORITY_HIGHEST            2
-!     THREAD_PRIORITY_TIME_CRITICAL     15
-
-  npri=NORMAL_PRIORITY_CLASS
-  if(nhighpri.ne.0) npri=ABOVE_NORMAL_PRIORITY_CLASS
-  m0=SetPriorityClass(GetCurrentProcess(),npri)
-
-! Start a thread for doing A/D and D/A with sound card.
-  Thread1=CreateThread(0,0,a2d,0,CREATE_SUSPENDED,id1)
-  m1=SetThreadPriority(Thread1,THREAD_PRIORITY_ABOVE_NORMAL)
-  m2=ResumeThread(Thread1)
-
-! Start a thread for background decoding.
-  Thread2=CreateThread(0,0,decode1,0,CREATE_SUSPENDED,id2)
-  m3=SetThreadPriority(Thread2,THREAD_PRIORITY_BELOW_NORMAL)
-  m4=ResumeThread(Thread2)
-#else
-  ierr=start_threads()
-#endif
-
-  return
-end subroutine audio_init

Copied: trunk/audio_init.f90 (from rev 2228, wsjt7a/audio_init.f90)
===================================================================
--- trunk/audio_init.f90	                        (rev 0)
+++ trunk/audio_init.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,40 @@
+subroutine audio_init(ndin,ndout)
+!f2py threadsafe
+
+  integer start_threads
+
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+
+  nmode=1
+  if(mode(1:4).eq.'JT65') then
+     nmode=2
+     if(mode(5:5).eq.'A') mode65=1
+     if(mode(5:5).eq.'B') mode65=2
+     if(mode(5:5).eq.'C') mode65=4
+  endif
+  if(mode(1:4).eq.'Echo') nmode=3
+  if(mode(1:2).eq.'CW') nmode=5
+  if(mode(1:3).eq.'JT4') nmode=7
+  if(mode(1:4).eq.'JTMS') nmode=8
+  if(mode(1:5).eq.'ISCAT') nmode=9
+
+  ndevin=ndin
+  ndevout=ndout
+  TxOK=0
+  Transmitting=0
+  nfsample=11025
+  nspb=1024
+  nbufs=2048
+  nmax=nbufs*nspb
+  nwave=60*nfsample
+  ngo=1
+  f0=800.0
+  do i=1,nwave
+     iwave(i)=nint(32767.0*sin(6.283185307*i*f0/nfsample))
+  enddo
+
+  ierr=start_threads()
+
+  return
+end subroutine audio_init

Copied: trunk/avecho.f90 (from rev 2228, wsjt7a/avecho.f90)
===================================================================
--- trunk/avecho.f90	                        (rev 0)
+++ trunk/avecho.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,142 @@
+subroutine avecho(fname,ntime,y1,ibuf0,ntc,necho,nfrit,ndither,      &amp;
+     dlatency,nsave,f1,nsum,nclearave,ss1,ss2)
+
+  parameter (NBSIZE=1024*2048)
+  character*24 fname
+  integer*2 y1(NBSIZE)                   !Buffer for Rx data
+  real d(28672)                          !Real audio data
+  real s1(600)      !Avg spectrum relative to initial Doppler echo freq
+  real s2(600)      !Avg spectrum with Dither and changing Doppler removed
+  real ss1(-224:224)
+  real ss2(-224:224)
+  real tmp(600)
+  integer nsum      !Number of integrations
+  real dop0         !Doppler shift for initial integration (Hz)
+  real doppler      !Doppler shift for current integration (Hz)
+  real s(8192)
+  real x(32770)
+  complex c(0:16384)
+  equivalence (x,c)
+  common/echo/xdop(2),techo,ElMoon,mjd
+  save s1,s2,dop0
+
+  if(ibuf0.lt.1) print*,'IBUF0:',ibuf0
+  sq=0.
+  k=2048*(ibuf0-1)  
+  do i=1,14*2048
+     k=k+1
+     if(k.gt.NBSIZE) k=k-NBSIZE
+     d(i)=y1(k)
+     sq=sq + d(i)*d(i)
+  enddo
+
+  sigdB=db(sq/(14*2048)) - 58.5
+  if(sigdB.lt.-99.0) sigdB=-99.0
+
+  if(nclearave.ne.0) nsum=0
+  nclearave=0
+  if(nsum.eq.0) then
+     dop0=2.0*xdop(1)       !Remember the initial Doppler
+     s1=0.
+     s2=0.
+  endif
+
+  doppler=2.0*xdop(1)
+!  if(nsave.ne.0) write(26) fname,ntime,dop0,doppler,d(1:28672)
+
+  dt=1.0/11025.0
+  df=11025.0/32768.0
+  istart=1
+  nz=14*2048 + 1 - istart
+  x(1:28672)=d(istart:istart+28671)
+  x(28673:)=0.0
+  call xfft(x,32768)
+
+  fac=1.e-9
+  do i=1,8192
+     s(i)=fac * (real(c(i))**2 + aimag(c(i))**2)
+  enddo
+
+  fnominal=1500.0           !Nominal audio frequency w/o doppler or dither
+  ia=nint((fnominal+dop0-nfrit)/df)
+  ib=nint((f1+doppler-nfrit)/df)
+  if(ia.lt.600 .or. ib.lt.600) go to 900
+  if(ia.gt.7590 .or. ib.gt.7590) go to 900
+
+  nsum=nsum+1
+  u=1.0/nsum
+  if(ntc.lt.1) ntc=1
+  if(nsum.gt.10*ntc) u=1.0/(10*ntc)
+  do i=1,600
+     s1(i)=(1.0-u)*s1(i) + u*s(ia+i-300)  !Center at initial doppler freq
+     s2(i)=(1.0-u)*s2(i) + u*s(ib+i-300)  !Center at expected echo freq
+     j=i-300
+     if(abs(j).le.224) then
+        ss1(j)=s1(i)
+        ss2(j)=s2(i)
+     endif
+  enddo
+  if(nsave.ne.0) then
+     call cs_lock('avecho')
+     open(25,file=fname,status='unknown')
+     do i=1,600
+        write(25,3001) (i-300)*df,s1(i),s2(i)
+3001    format(f10.3,2f12.3)
+     enddo
+     call flush(25)
+     close(25)
+     call cs_unlock
+  endif
+
+  call pctile(s2,tmp,600,50,x0)
+  call pctile(s2,tmp,600,84,x1)
+  rms=x1-x0
+  peak=-1.e30
+  do i=1,600
+     if(s2(i).gt.peak) then
+        peak=s2(i)
+        ipk=i
+     endif
+  enddo
+
+  s2half=0.5*(peak-x0) + x0
+
+  ia=ipk
+  ib=ipk
+  do i=1,100
+     if((ipk-i).lt.1) go to 11
+     ia=ipk-i
+     if(s2(ia).le.s2half) goto 11
+  enddo
+11 do i=1,100
+     if((ipk+i).gt.600) go to 21
+     ib=ipk+i
+     if(s2(ib).le.s2half) goto 21
+  enddo
+21 width=df*(ib-ia-1)
+
+  exchsig=-99.
+  if(x0.gt.0.0) echosig=10.0*log10(peak/x0 - 1.0) - 35.7
+  echodop=df*(ipk-300)
+  snr=0.
+  if(rms.gt.0.0) snr=(peak-x0)/rms
+
+  NQual=(snr-2.5)/2.5
+  if(nsum.lt.12)  NQual=(snr-3)/3
+  if(nsum.lt.8)   NQual=(snr-3)/4
+  if(nsum.lt.4)   NQual=(snr-4)/5
+  if(nsum.lt.2)   NQual=0
+  if(NQual.lt.0)  NQual=0
+  if(NQual.gt.10) NQual=10
+
+  call cs_lock('avecho')
+  rewind 11
+  write(11,1010) nsum,sigdB,echosig,echodop,width,NQual
+1010 format(i4,f6.1,f7.1,f8.1,f6.1,i4)
+  write(21,1010) nsum,sigdB,echosig,echodop,width,NQual
+  call flush(11)
+  call flush(21)
+  call cs_unlock
+
+900 return
+end subroutine avecho

Deleted: trunk/blanker.f90
===================================================================
--- trunk/blanker.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/blanker.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,18 +0,0 @@
-subroutine blanker(d2d,jz)
-
-  integer*2 d2d(jz)
-
-  avg=700.
-  threshold=5.0
-  do i=1,jz
-     xmag=abs(d2d(i))
-     xmed=0.75*xmed + 0.25*d2d(i)
-     avg=0.999*avg + 0.001*xmag
-     if(xmag.gt.threshold*avg) then
-!        d2d(i)=nint(xmed)
-        d2d(i)=0
-     endif
-  enddo
-
-  return
-end subroutine blanker

Deleted: trunk/ccf2.f
===================================================================
--- trunk/ccf2.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/ccf2.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,64 +0,0 @@
-      subroutine ccf2(ss,nz,lag1,lag2,ccfbest,lagpk)
-
-      parameter (LAGMAX=200)
-      real ss(nz)
-      real ccf(-LAGMAX:LAGMAX)
-      real pr(162)
-      logical first
-
-C  The WSPR pseudo-random sync pattern:
-      integer npr(162)
-      data npr/
-     +       1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     +       0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     +       0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     +       1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     +       0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     +       0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     +       0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     +       0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     +       0,0/
-      data first/.true./
-      save first,pr,nsym
-
-      if(first) then
-         nsym=162
-         do i=1,nsym
-            pr(i)=2*npr(i)-1
-         enddo
-      endif
-
-      ccfbest=0.
-
-      do lag=lag1,lag2
-         x=0.
-         do i=1,nsym
-            j=16*i + lag
-            if(j.ge.1 .and. j.le.nz) x=x+ss(j)*pr(i)
-         enddo
-         ccf(lag)=x
-         if(x.gt.ccfbest) then
-            ccfbest=x
-            lagpk=lag
-         endif
-      enddo
-
-      sum=0.
-      nsum=0
-      do i=lag1,lag2
-         if(abs(i-lagpk).gt.16) then
-            sum=sum+ccf(i)
-            nsum=nsum+1
-         endif
-      enddo
-      ave=sum/nsum
-
-      sq=0.
-      do i=lag1,lag2
-         if(abs(i-lagpk).gt.16) sq=sq + (ccf(i)-ave)**2
-      enddo
-      rms=sqrt(sq/(nsum-1))
-      ccfbest=(ccfbest-ave)/rms
-
-      return
-      end

Copied: trunk/chk441.f90 (from rev 2228, wsjt7a/chk441.f90)
===================================================================
--- trunk/chk441.f90	                        (rev 0)
+++ trunk/chk441.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,109 @@
+subroutine chk441(dat,jz,tstart,width,nfreeze,mousedf,             &amp;
+     dftolerance,pick,nok)
+
+! Experimental FSK441 decoder
+
+  parameter (NMAX=512*1024)
+  parameter (MAXFFT=8192)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  logical pick
+  complex cdat(NMAX)                      !Analytic form of signal
+  character frag*28,frag0*29              !Message fragment to be matched
+  complex cfrag(2100)                     !Complex waveform of message fragment
+  complex z
+  integer itone(84)                       !Generated tones for msg fragment
+  real s(NMAX)
+  real ccf(-6000:6000)
+  integer dftolerance
+  common/scratch/work(NMAX)
+  save frag0,cfrag,ndits
+
+  frag=' '
+  if(frag.ne.frag0) then
+     do i=28,1,-1                          !Get length of message fragment
+        if(frag(i:i).ne.' ') go to 10
+     enddo
+10   nfrag=i
+     if(nfrag.eq.0) nfrag=1
+     call abc441(frag,nfrag,itone,ndits)
+     call gen441(itone,ndits,cfrag)        !Generate complex waveform
+     frag0=frag
+  endif
+
+  ccf0=3.0
+  sb0=0.75
+  if(pick) then
+     ccf0=2.1
+     sb0=0.60
+  endif
+
+
+  nsps=25                                  !Initialize variables
+  nsam=nsps*ndits
+  dt=1.0/11025.0
+  i0=(tstart-0.02)/dt
+  if(i0.lt.1) i0=1
+  npts=nint((width+0.02)/dt)+1
+  npts=min(npts,jz+1-i0)
+  npts=min(npts,22050)                     !Max ping length 2 s
+  xn=log(float(npts))/log(2.0)
+  n=xn
+  if(xn-n .gt.0.001) n=n+1
+  nfft1=2**n
+  df1=11025.0/nfft1
+  nok=0
+  sbest=0.
+
+  call analytic(dat(i0),npts,nfft1,s,cdat)    !Convert to analytic signal
+
+!  call len441(cdat,npts,lenacf,nacf)          !Do ACF to find message length
+
+  ia=nint(dftolerance/df1)
+  i0=0
+  if(nfreeze.ne.0) i0=nint(mousedf/df1)
+  ccfmax=0.
+  do i=-ia,ia                                 !Find DF
+     ccf(i)=s(i0+i+nint(882.0/df1)) + s(i0+i+nint(1323.0/df1)) +        &amp;
+          s(i0+i+nint(1764.0/df1)) + s(i0+i+nint(2205.0/df1))
+  enddo
+  ccf(:-ia-1)=0.
+  ccf(ia+1:)=0.
+  nadd=2*nint(5.0/df1)+1
+  call smo(ccf(-ia),2*ia+1,work,nadd)         !Smooth CCF by nadd
+
+  do i=-ia,ia                                 !Find max of smoothed CCF
+     if(ccf(i).gt.ccfmax) then
+        ccfmax=ccf(i)
+        ipk=i0+i
+        dfx=ipk*df1
+     endif
+  enddo
+
+  ic=min(nint(220/df1),ia)                    !Baseline range +/- 220 Hz
+  call pctile(ccf(ipk-ic),work,2*ic+1,50,base)
+  ccfmax=ccfmax/base
+  if(ccfmax.lt.ccf0) go to 800                !Reject non-FSK441 signals
+
+! We seem to have an FSK441 ping, and we know DF; now find DT.
+  call tweak1(cdat,npts,-dfx,cdat)            !Mix to standard frequency
+
+! Look for best match to &quot;frag&quot;, find its DT
+  do i=1,npts-nsam
+     z=0.
+     a=0.
+     do j=1,nsam
+        a=a + abs(cdat(j+i-1))
+        z=z + cdat(j+i-1)*cfrag(j)
+     enddo
+     ss=abs(z)/a
+!     ss=abs(z)
+     if(ss.gt.sbest) then
+        sbest=ss
+     endif
+  enddo
+  if(sbest.lt.sb0) go to 800            !Skip if not decodable FSK441 data
+  nok=1
+
+800 continue
+  return
+end subroutine chk441

Copied: trunk/decdiana.f90 (from rev 2228, wsjt7a/decdiana.f90)
===================================================================
--- trunk/decdiana.f90	                        (rev 0)
+++ trunk/decdiana.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,80 @@
+subroutine decdiana(s0,jsym,ipk,jpk,msglen,msg,nsnr)
+
+  parameter (NSZ=646)
+  real s0(1024,NSZ)
+  real fs1(0:41,28)
+  real tmp(1176)
+  real tmp2(1176)
+  character msg*28
+  character c42*42
+  data c42/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ /.?+-'/
+
+  nblk=24
+  fs1=0.
+  k=0
+  n=0
+  do j=jpk,jpk+4*125,4                !Fold from s0 into fs1, modulo msglen
+     k=k+1
+     if(mod(k-1,nblk)+1.gt.6) then    !Use only message symbols
+        n=n+1
+        m=mod(n-1,msglen)+1
+        iblk=(j-jpk)/(4*nblk)         !iblk runs from 0 to 4
+        ioffset=7*iblk
+        do i=0,41
+           ii=i+ioffset
+           if(ii.ge.42) ii=ii-42
+           fs1(i,m)=fs1(i,m) + s0(ipk+2*ii,j)
+        enddo
+     endif
+  enddo
+
+  k=0
+  do j=1,msglen
+     do i=0,41
+        k=k+1
+        tmp(k)=fs1(i,j)
+     enddo
+  enddo
+  kz=k
+  call pctile(tmp,tmp2,kz,47,base)
+  fs1=fs1/base - 1.0
+
+  msg='                            '
+  worst=9999.
+  sum1=0.
+  sum2=0.
+  do m=1,msglen                           !Read out message contents
+     smax=0.
+     do i=0,41
+        if(fs1(i,m).gt.smax) then         !Find highest peak
+           smax=fs1(i,m)
+           ipk3=i
+        endif
+     enddo
+     sum1=sum1+smax
+
+     smax2=0.
+     do i=0,41
+        if(fs1(i,m).gt.smax2 .and. i.ne.ipk3) then  !Find 2nd highest peak
+           smax2=fs1(i,m)
+        endif
+     enddo
+     sum2=sum2+smax2
+     rr=smax1/smax2                       !Reliability indicator
+     if(rr.lt.worst) worst=rr
+     msg(m:m)=c42(ipk3+1:ipk3+1)          !Insert decoded char in msg
+  enddo
+  
+  ave1=sum1/msglen                        !Average signal
+  ave2=sum2/msglen                        !Average second-best
+  averel=sum1/sum2                        !Average reliability indicator
+
+  snrx=db(ave1) - 26.7 + 1.0              !Last number is empirical
+  nsnr=nint(snrx)
+  if(nsnr.le.-27) then
+     nsnr=-27
+     msg=' '
+  endif
+
+  return
+end subroutine decdiana

Deleted: trunk/decode1.F90
===================================================================
--- trunk/decode1.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/decode1.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,90 +0,0 @@
-subroutine decode1(iarg)
-
-! Get data and parameters from gcom, then call the decoders when needed.
-! This routine runs in a background thread and will never return.
-
-#ifdef CVF
-  use dflib
-#endif
-
-  character sending0*28,mode0*6,cshort*11
-  integer sendingsh0
-  integer*8 mtx
-  
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  include 'gcom4.f90'
-  common/mtxcom/mtx,ltrace,mtxstate,csub0
-
-  data sending0/'                      '/
-
-  ntr0=iarg                                    !Silence compiler warning
-  ntr0=ntr
-  ns0=999999
-  sendingsh0=-3
-
-10 ltrace=ndebug
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or. mode(1:3).eq.'JT4'  &amp;
-       .or. mode(1:2).eq.'CW' .or. mode(1:4).eq.'WSPR' .or.               &amp;
-       mode(1:4).eq.'JT64') then
-     if(rxdone) then
-        call savedata
-        newdat2=1
-        rxdone=.false.
-     endif
-  else
-     if(ntr.ne.ntr0 .and. monitoring.gt.0) then
-        if(ntr.ne.TxFirst .or. (lauto.eq.0)) call savedata
-        ntr0=ntr
-     endif
-  endif
-
-  if(ndecoding.gt.0) then
-     ndecdone=0
-     call decode2
-     ndecdone=1
-     if(mousebutton.eq.0) ndecoding0=ndecoding
-     ndecoding=0
-  endif
-
-  if(ns0.lt.0) then
-     rewind 21
-     ns0=999999
-  endif
-  n=Tsec
-  if(n.lt.ns0 .and. utcdate(1:1).eq.'2') then
-     call cs_lock('decode1a')
-     write(21,1001) utcdate(:11)
-1001 format(/'UTC Date: ',a11/'---------------------')
-     call flushqqq(21)
-     call cs_unlock
-     ns0=n
-  endif
-
-  if(transmitting.eq.1 .and. (sending.ne.sending0 .or.       &amp;
-       sendingsh.ne.sendingsh0 .or. mode.ne.mode0)) then
-     ih=n/3600
-     im=mod(n/60,60)
-     is=mod(n,60)
-     cshort='           '
-     if(sendingsh.eq.1) cshort='(Shorthand)'
-     call cs_lock('decode1b')
-     write(21,1010) ih,im,is,mode,sending,cshort
-1010 format(3i2.2,'  Transmitting: ',a6,2x,a28,2x,a11)
-     call flushqqq(21)
-     call cs_unlock
-     sending0=sending
-     sendingsh0=sendingsh
-     mode0=mode
-  endif
-       
-#ifdef CVF
-  call sleepqq(100)
-#else
-  call usleep(100*1000)
-#endif
-
-  go to 10
-
-end subroutine decode1

Copied: trunk/decode1.f90 (from rev 2228, wsjt7a/decode1.f90)
===================================================================
--- trunk/decode1.f90	                        (rev 0)
+++ trunk/decode1.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,94 @@
+subroutine decode1(iarg)
+
+! Get data and parameters from gcom, then call the decoders when needed.
+! This routine runs in a background thread and will never return.
+
+  character sending0*28,mode0*6,cshort*11
+  character fnamex*24
+  integer sendingsh0
+  integer*8 mtx
+  
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  include 'gcom4.f90'
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+
+  data sending0/'                      '/
+
+  ntr0=iarg                                    !Silence compiler warning
+  ntr0=ntr
+  ns0=999999
+  sendingsh0=-3
+
+10 ltrace=ndebug
+
+  if(mode(1:4).eq.'Echo' .and. ndecoding.eq.1) then
+     nt=ntime/86400
+     nt=86400*nt + tbuf(ibuf0)
+     call get_fname(mycall,iyr,imo,ida,nt,lauto,fnamex)
+     i1=index(fnamex,'.WAV')
+     fnamex=fnamex(1:i1-3)//'.eco'
+     call avecho(fnamex,ntime,y1,ibuf0,ntc,necho,nfrit,ndither,dlatency,   &amp;
+          nsave,fecho,nsumecho,nclearave,ss1,ss2)
+     ndecoding=0
+     ndecdone=1
+  endif
+
+  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4'                &amp;
+       .or. mode(1:2).eq.'CW') then
+     if(rxdone) then
+        call savedata
+        newdat2=1
+        rxdone=.false.
+     endif
+  else
+     if(ntr.ne.ntr0 .and. monitoring.gt.0) then
+        if(ntr.ne.TxFirst .or. (lauto.eq.0)) call savedata
+        ntr0=ntr
+     endif
+  endif
+
+  if(ndecoding.gt.0) then
+     ndecdone=0
+     call decode2
+     ndecdone=1
+     if(mousebutton.eq.0) ndecoding0=ndecoding
+     ndecoding=0
+  endif
+
+  if(ns0.lt.0) then
+     rewind 21
+     ns0=999999
+  endif
+  n=Tsec
+  if(n.lt.ns0 .and. utcdate(1:1).eq.'2') then
+     call cs_lock('decode1a')
+     write(21,1001) utcdate(:11)
+1001 format(/'UTC Date: ',a11/'---------------------')
+     call flush(21)
+     call cs_unlock
+     ns0=n
+  endif
+
+  if(transmitting.eq.1 .and. (sending.ne.sending0 .or.       &amp;
+       sendingsh.ne.sendingsh0 .or. mode.ne.mode0)) then
+     ih=n/3600
+     im=mod(n/60,60)
+     is=mod(n,60)
+     cshort='           '
+     if(sendingsh.eq.1) cshort='(Shorthand)'
+     call cs_lock('decode1b')
+     write(21,1010) ih,im,is,mode,sending,cshort
+1010 format(3i2.2,'  Transmitting: ',a6,2x,a28,2x,a11)
+     call flush(21)
+     call cs_unlock
+     sending0=sending
+     sendingsh0=sendingsh
+     mode0=mode
+  endif
+       
+  call usleep(100*1000)
+  go to 10
+
+end subroutine decode1

Deleted: trunk/decode162.f
===================================================================
--- trunk/decode162.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/decode162.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,137 +0,0 @@
-      subroutine decode162(c4,npts,ndwspr,message,ncycles,metric,nerr)
-
-C  Decode MEPT_JT data, assuming that DT and DF have already been determined.
-
-      complex c4(npts)
-      character*22 message
-      real*8 dt,df,twopi,f0,f1,dphi0,dphi1
-      complex*16 c0,c1
-      complex*16 w0,w1,ws0,ws1
-      integer*1 symbol(162)
-      integer*1 data1(11)
-      integer amp
-      integer mettab(0:255,0:1)
-      integer npr3(162)
-      common/ccom/rr(162)
-      data npr3/
-     + 1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     + 0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     + 0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     + 1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     + 0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     + 0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     + 0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     + 0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     + 0,0/
-      data mettab/
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
-     +   2,   2,   2,   2,   1,   1,   1,   1,   0,   0,
-     +  -1,  -1,  -1,  -2,  -2,  -3,  -4,  -4,  -5,  -6,
-     +  -7,  -7,  -8,  -9, -10, -11, -12, -12, -13, -14,
-     + -15, -16, -17, -17, -18, -19, -20, -21, -22, -22,
-     + -23, -24, -25, -26, -26, -27, -28, -29, -30, -30,
-     + -31, -32, -33, -33, -34, -35, -36, -36, -37, -38,
-     + -38, -39, -40, -41, -41, -42, -43, -43, -44, -45,
-     + -45, -46, -47, -47, -48, -49, -49, -50, -51, -51,
-     + -52, -53, -53, -54, -54, -55, -56, -56, -57, -57,
-     + -58, -59, -59, -60, -60, -61, -62, -62, -62, -63,
-     + -64, -64, -65, -65, -66, -67, -67, -67, -68, -69,
-     + -69, -70, -70, -71, -72, -72, -72, -72, -73, -74,
-     + -75, -75, -75, -77, -76, -76, -78, -78, -80, -81,
-     + -80, -79, -83, -82, -81, -82, -82, -83, -84, -84,
-     + -84, -87, -86, -87, -88, -89, -89, -89, -88, -87,
-     + -86, -87, -84, -84, -84, -83, -82, -82, -81, -82,
-     + -83, -79, -80, -81, -80, -78, -78, -76, -76, -77,
-     + -75, -75, -75, -74, -73, -72, -72, -72, -72, -71,
-     + -70, -70, -69, -69, -68, -67, -67, -67, -66, -65,
-     + -65, -64, -64, -63, -62, -62, -62, -61, -60, -60,
-     + -59, -59, -58, -57, -57, -56, -56, -55, -54, -54,
-     + -53, -53, -52, -51, -51, -50, -49, -49, -48, -47,
-     + -47, -46, -45, -45, -44, -43, -43, -42, -41, -41,
-     + -40, -39, -38, -38, -37, -36, -36, -35, -34, -33,
-     + -33, -32, -31, -30, -30, -29, -28, -27, -26, -26,
-     + -25, -24, -23, -22, -22, -21, -20, -19, -18, -17,
-     + -17, -16, -15, -14, -13, -12, -12, -11, -10,  -9,
-     +  -8,  -7,  -7,  -6,  -5,  -4,  -4,  -3,  -2,  -2,
-     +  -1,  -1,  -1,   0,   0,   1,   1,   1,   1,   2,
-     +   2,   2,   2,   2,   3,   3,   3,   3,   3,   3,
-     +   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
-     +   4,   4,   4,   4,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
-     +   5,   5/
-
-      twopi=8*atan(1.d0)
-      dt=1.d0/375.d0            !Sample interval
-      df=375.d0/256.d0
-      nsym=162
-      nbits=50+31
-      amp=20                    !### 32 ??? ###
-      ndelta=50
-
-      limit=20000
-      if(ndwspr.eq.0) limit=10000
-C  Should amp be adjusted according to signal strength?
-C  Compute soft symbols
-      k=0
-      nsps=256
-      fac2=0.001
-      w0=1.0
-      w1=1.0
-
-      do j=1,nsym
-         f0=(npr3(j)-1.5)*df
-         f1=(2+npr3(j)-1.5)*df
-         dphi0=twopi*dt*f0
-         dphi1=twopi*dt*f1
-         ws0=dcmplx(cos(dphi0),-sin(dphi0))
-         ws1=dcmplx(cos(dphi1),-sin(dphi1))
-         c0=0.
-         c1=0.
-         do i=1,nsps
-            k=k+1
-            w0=w0*ws0
-            w1=w1*ws1
-            c0=c0 + w0*c4(k)
-            c1=c1 + w1*c4(k)
-         enddo
-
-         sq0=fac2*(real(c0)**2 + aimag(c0)**2)
-         sq1=fac2*(real(c1)**2 + aimag(c1)**2)
-         rsym=amp*(sq1-sq0)
-!         write(55,3003) j,rsym,rr(j)
-! 3003    format(i5,3f10.3)
-!         rsym=rr(j)
-
-         r=rsym+128.
-         if(r.gt.255.0) r=255.0
-         if(r.lt.0.0) r=0.0
-         i4=nint(r)
-         if(i4.gt.127) i4=i4-256
-         symbol(j)=i4
-      enddo
-
-      call inter_mept(symbol,-1)                      !Remove interleaving
-      call fano232(symbol,nbits,mettab,ndelta,limit,
-     +     data1,ncycles,metric,nerr)
-      message='                      '
-      if(nerr.ge.0) call wqdecode(data1,message,ntype2)
-
-      return
-      end

Modified: trunk/decode2.f90
===================================================================
--- trunk/decode2.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/decode2.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -19,13 +19,7 @@
 !    5       d2a   Mouse pick, main window
 
   lenpick=22050                !Length of FSK441 mouse-picked region
-  if(mode(1:4).eq.'JT6M') then
-     lenpick=4*11025
-     if(mousebutton.eq.3) lenpick=10*11025
-  endif
-
   istart=1.0 + 11025*0.001*npingtime - lenpick/2
-  if(mode(1:4).eq.'JT6M') istart=istart+11025
   if(istart.lt.2) istart=2
   if(ndecoding.eq.1) then
 ! Normal decoding at end of Rx period (or at t=53s in JT65)
@@ -34,6 +28,10 @@
   else if(ndecoding.eq.2) then
 
 ! Mouse pick, top half of waterfall
+     if(mode(1:5).eq.'ISCAT' .and. MouseButton.eq.3) then
+        lenpick=istart
+        istart=1
+     endif
 ! The following is empirical:
      k=2048*ibuf0 + istart - 11025*mod(tbuf(ibuf0),dble(trperiod)) -3850
      if(k.le.0)      k=k+NRxMax
@@ -51,6 +49,10 @@
   else if(ndecoding.eq.3) then
 
 !Mouse pick, bottom half of waterfall
+     if(mode(1:5).eq.'ISCAT' .and. MouseButton.eq.3) then
+        lenpick=istart
+        istart=1
+     endif
      ib0=ibuf0-161
      if(lauto.eq.1 .and. mute.eq.0 .and. transmitting.eq.1) ib0=ibuf0-323
      if(ib0.lt.1) ib0=ib0+1024
@@ -75,25 +77,31 @@
         jzz=lenpick
 
 !  This is a major kludge:
-        if(mode(1:4).eq.'JT6M') then          
-           jzz=4*11025
-           if(mousebutton.eq.3) jzz=10*11025
-        else
-           istart=istart + 3300 - jzz/2
-        endif
+        istart=istart + 3300 - jzz/2
 
         if(istart.lt.2) istart=2
         if(istart+jzz.gt.jzc) istart=jzc-jzz
      endif
-     if(mode(1:4).eq.'WSPR') newdat2=1
-     call decode3(d2c(istart),jzz,istart,filename)
+     if(mode(1:5).eq.'ISCAT' .and. MouseButton.eq.3) then
+        lenpick=istart
+        istart=1
+        call decode3(d2c,lenpick,istart,filename)
+     else
+        call decode3(d2c(istart),jzz,istart,filename)
+     endif
 
   else if(ndecoding.eq.5) then
 ! Mouse pick, main window (but not from recorded file)
      istart=istart - 1512
      if(istart.lt.2) istart=2
      if(istart+lenpick.gt.jza) istart=jza-lenpick
-     call decode3(d2a(istart),lenpick,istart,fnamea)
+     if(mode(1:5).eq.'ISCAT' .and. MouseButton.eq.3) then
+        lenpick=istart
+        istart=2
+        call decode3(d2a,lenpick,istart,fnamea)
+     else
+        call decode3(d2a(istart),lenpick,istart,fnamea)
+     endif
   endif
   fnameb=fnamea
 

Modified: trunk/decode24.f
===================================================================
--- trunk/decode24.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/decode24.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,11 +1,12 @@
       subroutine decode24(dat,npts,dtx,dfx,flip,mode,mode4,
-     +  decoded,ncount,deepmsg,qual)
+     +  decoded,ncount,deepmsg,qual,submode)
 
 C  Decodes JT65 data, assuming that DT and DF have already been determined.
 
       real dat(npts)                        !Raw data
       character decoded*22,deepmsg*22
       character*72 c72
+      character submode*1
       real*8 dt,df,phi,f0,dphi,twopi,phi1,dphi1
       complex*16 cz,cz1,c0,c1
       integer*1 symbol(207)
@@ -53,85 +54,6 @@
       phi1=0.d0
       ang0=0.
 
-      if(mode.eq.6) then                   !JT2
-         nhmax=0
-         do idf=-20,20,2
-            c0=amp
-            k=istart
-            phi=0.d0
-            nh=0
-            do j=1,nsym+1
-               if(flip.gt.0.0) then
-                  f0=1270.46 + dfx + npr2(j)*df
-               else
-                  f0=1270.46 + dfx + (1-npr2(j))*df
-               endif
-               f0=f0 + 0.1*idf
-               dphi=twopi*dt*f0
-               c1=0.
-               do i=1,1260
-                  k=k+1
-                  phi=phi+dphi
-                  cz=dcmplx(cos(phi),-sin(phi))
-                  if(k.le.npts) c1=c1 + dat(k)*cz
-               enddo
-               rsym=amp*(real(c1)*real(c0) + aimag(c1)*aimag(c0))
-               ang=atan2(aimag(c1),real(c1))
-               ndang=nint(57.1957795131d0*(ang-ang0))
-               ang0=ang
-               if(ndang.le.-180) ndang=ndang+360
-               if(ndang.gt.180) ndang=ndang-360
-               if(ndang.lt.-90) ndang=ndang+180
-               if(ndang.gt. 90) ndang=ndang-180
-               if(rsym.ge.0.05 .and. abs(ndang).lt.20)nh=nh+1
-            enddo
-            if(nh.gt.nhmax) then
-               nhmax=nh
-               idfbest=idf
-            endif
-         enddo
-
-         c0=0
-         k=istart
-         phi=0.d0
-         do j=1,nsym+1
-            if(flip.gt.0.0) then
-               f0=1270.46 + dfx + npr2(j)*df
-            else
-               f0=1270.46 + dfx + (1-npr2(j))*df
-            endif
-            f0=f0 + 0.1*idfbest
-            dphi=twopi*dt*f0
-            c1=0.
-            do i=1,1260
-               k=k+1
-               phi=phi+dphi
-               cz=dcmplx(cos(phi),-sin(phi))
-               if(k.le.npts) c1=c1 + dat(k)*cz
-            enddo
-            c1=fac*c1
-            rsym=amp*(real(c1)*real(c0) + aimag(c1)*aimag(c0))
-
-C  NB: It may be possible to track phase.  In that case, remove the 
-C  average phase and then use:
-!            rsym=amp*real(c1)*real(c0)
-
-            ang=atan2(aimag(c1),real(c1))
-            ndang=nint(57.1957795131d0*(ang-ang0))
-            if(ndang.le.-180) ndang=ndang+360
-            if(ndang.gt.180) ndang=ndang-360
-            c0=c1
-            r=rsym+128.
-            if(r.gt.255.0) r=255.0
-            if(r.lt.0.0) r=0.0
-            i4=nint(r)
-            if(i4.gt.127) i4=i4-256
-            if(j.ge.1) symbol(j)=i4
-            ang0=ang
-         enddo
-         go to 50
-      endif
-
 ! JT4 mode
       ich=0
  40   ich=ich+1
@@ -183,29 +105,15 @@
          if(j.ge.1) symbol(j)=i4
       enddo
 
- 50   nbits=72+31
+      nbits=72+31
       delta=100
       limit=100000
       ncycles=0
       call interleave24(symbol(2),-1)         !Remove the interleaving
 
-C  This is a kludge:
-      iters=1
-      if(mode.eq.6) iters=2
-      do iter=1,iters
-         if(iter.eq.2) then
-            do i=2,207
-               i4=symbol(i)
-               if(i4.lt.0) i4=i4+256
-               i4=255-i4
-               if(i4.gt.127) i4=i4-256
-               symbol(i)=i4
-            enddo
-         endif
-         ncount=fano(metric,ncycles,data1,symbol(2),nbits,mettab,
-     +        delta,limit)
-         if(ncount.ge.0) go to 100
-      enddo
+      ncount=fano(metric,ncycles,data1,symbol(2),nbits,mettab,
+     +     delta,limit)
+      if(ncount.ge.0) go to 100
       if(mode.eq.7 .and. nchips.lt.mode4) go to 40
 
  100  do i=1,9
@@ -221,7 +129,11 @@
       call cs_unlock
 
       decoded='                      '
-      if(ncount.ge.0) call unpackmsg(data4,decoded)
+      submode=' '
+      if(ncount.ge.0) then
+         call unpackmsg(data4,decoded)
+         submode=char(ichar('A')+ich-1)
+      endif
       if(decoded(1:6).eq.'000AAA') then
          decoded='***WRONG MODE?***'
          ncount=-1

Deleted: trunk/decode3.F90
===================================================================
--- trunk/decode3.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/decode3.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,107 +0,0 @@
-subroutine decode3(d2,jz,istart,filename)
-
-#ifdef CVF
-  use dfport
-#endif
-
-  integer*2 d2(jz),d2d(125*11025)
-  character*24 filename
-  character FileID*40
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  
-  if(ichar(filename(1:1)).eq.0) go to 999
-    
-  FileID=filename
-  decodedfile=filename
-  lumsg=11
-  nqrn=nclip+5
-  nmode=1
-  if(mode(1:4).eq.'JT65') then
-     nmode=2
-     if(mode(5:5).eq.'A') mode65=1
-     if(mode(5:5).eq.'B') mode65=2
-     if(mode(5:5).eq.'C') mode65=4
-  endif
-  if(mode(1:4).eq.'Echo') nmode=3
-  if(mode(1:4).eq.'JT6M') nmode=4
-  if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:3).eq.'JT2') nmode=6
-  if(mode(1:3).eq.'JT4') nmode=7
-  if(mode(1:4).eq.'WSPR') nmode=8
-  if(mode(1:4).eq.'JT64') nmode=9
-
-  sum=0.
-  do i=1,jz
-     sum=sum+d2(i)
-  enddo
-  nave=nint(sum/jz)
-  do i=1,jz
-     d2(i)=d2(i)-nave
-     d2d(i)=d2(i)
-  enddo
-
-  if(nblank.ne.0) call blanker(d2d,jz)
-
-  nseg=1
-  if(mode(1:4).eq.'JT65' .or. nmode.ge.6) then
-     i=index(FileID,'.')-3
-     if(FileID(i:i).eq.'1'.or.FileID(i:i).eq.'3'.or.FileID(i:i).eq.'5'  &amp;
-          .or.FileID(i:i).eq.'7'.or.FileID(i:i).eq.'9') nseg=2
-  endif
-
-  open(23,file=appdir(:lenappdir)//'/CALL3.TXT',status='unknown')
-  if(nadd5.eq.1) then
-!  Insert 5 s of zeroes at start of data.
-     nzero=5*11025
-     do i=jz,nzero+1,-1
-        d2d(i)=d2d(i-nzero)
-     enddo
-     do i=1,nzero
-        d2d(i)=0
-     enddo
-     jz=min(60*11025,jz+nzero)
-  endif
-  call wsjt1(d2d,jz,istart,samfacin,FileID,ndepth,                     &amp;
-       MinSigdB,NQRN,DFTolerance,MouseButton,NClearAve,nforce,         &amp;
-       nMode,NFreeze,NAFC,NZap,mode65,mode4,idf,ntdecode,              &amp;
-       MyCall,HisCall,HisGrid,neme,ntx2,s2,                            &amp;
-       ps0,npkept,lumsg,basevb,rmspower,nslim2,psavg,ccf,Nseg,         &amp;
-       MouseDF,NAgain,LDecoded,nspecial,ndf,ss1,ss2)
-  nforce=0
-  ntx2=0
-  close(23)
-  if(basevb.le.-98.0) go to 999
-
-! See whether this file should be saved or erased from disk
-  if(nsave.eq.1 .and. ldecoded) filetokilla=''
-  if(nsave.eq.3 .or. (nsave.eq.2 .and. lauto.eq.1)) then
-     filetokilla=''
-     filetokillb=''
-  endif
-  if(nsavelast.eq.1) filetokillb=''
-  nsavelast=0
-  ierr=unlink(filetokillb)
-  
-  nclearave=0
-  nagain=0
-  if(mode(1:4).eq.'JT65' .or. nmode.ge.6) then
-     call pix2d65(d2d,jz)
-  else if(mode.eq.'FSK441') then
-     nz=s2(1,1)
-     call pix2d(d2d,jz,mousebutton,MouseDF,NFreeze,mode,s2,64,nz,b)
-  else if(mode(1:4).eq.'JT6M' .and. mousebutton.eq.0) then
-     nz=s2(1,1)
-     call pix2d(d2d,jz,mousebutton,MouseDF,NFreeze,mode,s2,64,nz,b)
-  endif
-
-! Compute red and magenta cutves for small plot area, FSK441/JT6M only
-  if(mode.eq.'FSK441' .or. mode.eq.'JT6M') then
-     do i=1,128
-        if(mode.eq.'FSK441' .and. ps0(i).gt.0.0) ps0(i)=10.0*log10(ps0(i))
-        if(psavg(i).gt.0.0) psavg(i)=10.0*log10(psavg(i))
-     enddo
-  endif
-
-999 return
-end subroutine decode3

Copied: trunk/decode3.f90 (from rev 2228, wsjt7a/decode3.f90)
===================================================================
--- trunk/decode3.f90	                        (rev 0)
+++ trunk/decode3.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,101 @@
+subroutine decode3(d2,jz,istart,filename)
+
+  integer*2 d2(jz),d2d(125*11025)
+  character*24 filename
+  character FileID*40
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+
+  if(ichar(filename(1:1)).eq.0) go to 999
+    
+  FileID=filename
+  decodedfile=filename
+  lumsg=11
+  nmode=1
+  if(mode(1:4).eq.'JT65') then
+     nmode=2
+     if(mode(5:5).eq.'A') mode65=1
+     if(mode(5:5).eq.'B') mode65=2
+     if(mode(5:5).eq.'C') mode65=4
+  endif
+  if(mode(1:4).eq.'Echo') nmode=3
+  if(mode(1:2).eq.'CW') nmode=5
+  if(mode(1:3).eq.'JT4') nmode=7
+  if(mode(1:4).eq.'JTMS') nmode=8
+  if(mode(1:5).eq.'ISCAT') nmode=9
+  if(mode(1:5).eq.'Diana') nmode=10
+  sum=0.
+  do i=1,jz
+     sum=sum+d2(i)
+  enddo
+  nave=nint(sum/jz)
+  do i=1,jz
+     d2(i)=d2(i)-nave
+     d2d(i)=d2(i)
+  enddo
+
+  nseg=1
+  if(mode(1:4).eq.'JT65' .or. nmode.ge.6) then
+     i=index(FileID,'.')-3
+     if(FileID(i:i).eq.'1'.or.FileID(i:i).eq.'3'.or.FileID(i:i).eq.'5'  &amp;
+          .or.FileID(i:i).eq.'7'.or.FileID(i:i).eq.'9') nseg=2
+  endif
+
+  open(23,file=appdir(:lenappdir)//'/CALL3.TXT',status='unknown')
+  if(nadd5.eq.1) then
+!  Insert 5 s of zeroes at start of data.
+     nzero=5*11025
+     do i=jz,nzero+1,-1
+        d2d(i)=d2d(i-nzero)
+     enddo
+     do i=1,nzero
+        d2d(i)=0
+     enddo
+     jz=min(60*11025,jz+nzero)
+  endif
+  mb0=mousebutton
+  call wsjt1(d2d,jz,istart,samfacin,FileID,ndepth,                     &amp;
+       MinSigdB,DFTolerance,MouseButton,NClearAve,nforce,         &amp;
+       nMode,NFreeze,NAFC,NZap,mode65,mode4,idf,ntdecode,              &amp;
+       MyCall,HisCall,HisGrid,neme,ntx2,s2,                            &amp;
+       ps0,npkept,lumsg,basevb,rmspower,nslim2,psavg,ccf,Nseg,         &amp;
+       MouseDF,NAgain,LDecoded,nspecial,ndf,ss1,ss2)
+  nforce=0
+  ntx2=0
+  close(23)
+  if(basevb.le.-98.0) go to 999
+
+! See whether this file should be saved or erased from disk
+  if(nsave.eq.1 .and. ldecoded) filetokilla=''
+  if(nsave.eq.3 .or. (nsave.eq.2 .and. lauto.eq.1)) then
+     filetokilla=''
+     filetokillb=''
+  endif
+  if(nsavelast.eq.1) filetokillb=''
+  nsavelast=0
+  ierr=unlink(filetokillb)
+  
+  nclearave=0
+  nagain=0
+  if(mode(1:4).eq.'JT65' .or. mode(1:5).eq.'Diana') then
+     call pix2d65(d2d,jz)
+  else if(mode.eq.'FSK441' .or. mode(1:4).eq.'JTMS') then
+     nz=s2(1,1)
+     if(nz.gt.0) call pix2d(d2d,jz,mousebutton,MouseDF,NFreeze,mode,   &amp;
+          s2,64,nz,b)
+  else if(mode(1:5).eq.'ISCAT' .and. mb0.le.1) then
+     nz=s2(1,1)
+     if(nz.gt.0) call pix2d(d2d,jz,mousebutton,MouseDF,NFreeze,mode,   &amp;
+          s2,64,nz,b)
+  endif
+
+! Compute red and magenta cutves for small plot area, FSK441/JTMS only
+  if(mode.eq.'FSK441' .or. mode.eq.'JTMS') then
+     do i=1,128
+        if(ps0(i).gt.0.0) ps0(i)=10.0*log10(ps0(i))
+        if(psavg(i).gt.0.0) psavg(i)=10.0*log10(psavg(i))
+     enddo
+  endif
+
+999 return
+end subroutine decode3

Deleted: trunk/decode6m.f
===================================================================
--- trunk/decode6m.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/decode6m.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,166 +0,0 @@
-      subroutine decode6m(data,jz,cfile6,MinSigdB,istart,
-     +  NFixLen,lcum,f0,lumsg,npkept,yellow)
-
-C  Decode a JT6M message.  Data must start at the beginning of a 
-C  sync symbol; sync frequency is assumed to be f0.
-
-C      parameter (NMAX=30*11025)
-C There must be a better way of doing this 
-C NMAX is overruled in lfp1 to be 1024*1024 which is called from here -db
-C
-      parameter (NMAX=1024*1024)
-      real data(jz)              !Raw data
-      real s2db(0:43,646)        !Spectra of symbols
-c      real s2(128,646)
-      real syncsig(646)
-      real yellow(216)
-      real ref(0:43)
-      logical lcum
-      character*43 pua
-      character*48 msg
-      character*6 cfile6
-      real*8 dpha,twopi
-      complex*16 z,dz
-      complex zz
-      complex ct(0:511)
-      complex c
-      common/hcom/c(NMAX)
-      data pua/'0123456789., /#?$ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
-      data offset/20.6/
-
-      ps(zz)=real(zz)**2 + aimag(zz)**2          !Power spectrum function
-
-C  Convert data to baseband (complex result) using quadrature LO.
-      twopi=8*atan(1.d0)
-      dpha=twopi*f0/11025.d0
-      dz=cmplx(cos(dpha),-sin(dpha))
-      z=1.d0/dz
-      do i=1,jz
-         z=z*dz
-         c(i)=data(i)*z
-      enddo
-
-C  Get spectrum for each symbol.
-C  NB: for decoding pings, could do FFTs first for sync intervals only, 
-C  and then for data symbols only where the sync amplitude is above 
-C  threshold.  However, for the average message we want all FFTs computed.
-
-      call zero(ref,44)
-
-      nz=jz/512 - 1
-      fac=1.0/512.0
-      do j=1,nz        
-         i0=512*(j-1) + 1
-          do i=0,511
-            ct(i)=fac*c(i0+i)
-         enddo
-         call four2a(ct,512,1,-1,1)
-
-C  Save PS for each symbol
-         do i=0,127
-            xps=ps(ct(i))
-            if(i.le.43) s2db(i,j)=xps
-c            s2(i+1,j)=xps
-         enddo
-         if(mod(j,3).eq.1) call add(ref,s2db(0,j),ref,44) !Accumulate ref spec
-      enddo
-
-C  Return sync-tone amplitudes for plotting.
-      iz=nz/3 -1
-      do i=1,iz
-         j=3*i-2
-         yellow(i)=s2db(0,j)-0.5*(s2db(0,j+1)+s2db(0,j+2))
-      enddo
-      yellow(216)=iz
-
-      fac=3.0/nz
-      do i=0,43                               !Normalize the ref spectrum
-         ref(i)=fac*ref(i)
-      enddo
-      ref(0)=ref(2)                           !Sync bin uses bin 2 as ref
-
-      do j=1,nz                               !Compute strength of sync
-         m=mod(j-1,3)                         !signal at each j.
-         ja=j-m-3
-         jb=ja+3
-         if(ja.lt.1) ja=ja+3
-         if(jb.gt.nz) jb=jb-3
-         syncsig(j)=0.5*(s2db(0,ja)+s2db(0,jb))/ref(0)
-         syncsig(j)=db(syncsig(j)) - offset
-         do i=0,43                            !Normalize s2db
-            s2db(i,j)=s2db(i,j)/ref(i)
-         enddo
-      enddo
-
-C  Decode any message of 2 or more consecutive characters bracketed by
-C  sync-tones above a threshold.
-C  Use hard-decoding (i.e., pick max bin).
-
-      nslim=MinSigdB                       !Signal limit for decoding
-      ndf0=nint(f0-1076.77)                !Freq offset DF, in Hz
-      n=0                                  !Number of decoded characters
-      j0=0
-      sbest=-1.e9
-      do j=2,nz-1,3
-         if(syncsig(j).ge.float(nslim)) then
-
-C  Is it time to write out the results?
-            if((n.eq.48) .or. (j.ne.j0+3 .and. j0.ne.0)) then
-               nsig=nint(sbest)
-               width=(512./11025.)*(1.5*n+1.0)
-               if(nsig.ge.nslim) then
-                  npkept=npkept+1
-                  call cs_lock('decode6m')
-                  write(lumsg,1010) cfile6,tping,width,
-     +            nsig,ndf0,(msg(k:k),k=1,n)
-                  if(lcum) write(21,1010) cfile6,tping,width,
-     +              nsig,ndf0,(msg(k:k),k=1,n)
- 1010             format(a6,2f5.1,i4,i5,6x,48a1)       !### 6x was 7x ###
-                  call cs_unlock
-               endif
-               n=0
-               sbest=-1.e9
-            endif
-            j0=j
-            smax1=-1.e9
-            ipk=0 !Shut up compiler warning. -db
-            do i=1,43                         !Pick max bin for 1st char
-               if(s2db(i,j).gt.smax1) then
-                  smax1=s2db(i,j)
-                  ipk=i
-               endif
-            enddo
-            n=n+1
-            if(n.eq.1) tping=j*512./11025. + (istart-1)/11025.0 !Start of ping
-            msg(n:n)=pua(ipk:ipk)                        !Decoded character
-
-            smax2=-1.e9
-            do i=1,43
-               if(s2db(i,j+1).gt.smax2) then
-                  smax2=s2db(i,j+1)
-                  ipk=i
-               endif
-            enddo
-            n=n+1
-            msg(n:n)=pua(ipk:ipk)
-            sig0=10.0**(0.1*(syncsig(j)+offset))
-            sig=db(0.5*sig0 + 0.25*(smax1+smax2))-offset
-            sbest=max(sbest,sig)
-         endif
-      enddo
-
-      nsig=nint(sbest)
-      width=(512./11025.)*(1.5*n+1.0)
-      if(n.ne.0 .and. nsig.ge.nslim) then
-         npkept=npkept+1
-         write(lumsg,1010) cfile6,tping,
-     +     width,nsig,ndf0,(msg(k:k),k=1,n)
-         if(lcum) write(21,1010) cfile6,tping,
-     +     width,nsig,ndf0,(msg(k:k),k=1,n)
-      endif
-
-C  Decode average message for the whole record.
-      call avemsg6m(s2db,nz,nslim,NFixLen,cfile6,lcum,f0,lumsg,npkept)
-
-      return
-      end

Copied: trunk/decodems.f90 (from rev 2228, wsjt7a/decodems.f90)
===================================================================
--- trunk/decodems.f90	                        (rev 0)
+++ trunk/decodems.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,39 @@
+subroutine decodems(cdat,npts,cw,i1,nchar,s2,msg)
+
+! DF snd sync have been established, now decode the message
+
+  complex cdat(npts)
+  complex cw(56,0:63)                  !Complex waveforms for codewords
+  real s2(0:63,400)
+  character msg*400
+  complex z,zmax
+  character cc*64
+!                    1         2         3         4         5         6
+!          0123456789012345678901234567890123456789012345678901234567890123
+  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ./?-                 _     @'/
+
+  msg=' '
+  do j=1,nchar                         !Find best match for each character
+     ia=i1 + (j-1)*56
+     smax=0.
+     do k=0,40
+        kk=k
+        if(k.eq.40) kk=57
+        z=0.
+        do i=1,56
+           z=z + cdat(ia+i)*conjg(cw(i,kk))
+        enddo
+        ss=abs(z)
+        s2(k,j)=ss
+        if(ss.gt.smax) then
+           smax=ss
+           zmax=z
+           kpk=kk
+        endif
+     enddo
+     msg(j:j)=cc(kpk+1:kpk+1)
+     if(kpk.eq.57) msg(j:j)=' '
+  enddo
+
+  return
+end subroutine decodems

Deleted: trunk/deep65.F
===================================================================
--- trunk/deep65.F	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/deep65.F	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,176 +0,0 @@
-      subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,
-     +  hisgrid,decoded,qual)
-
-      parameter (MAXCALLS=7000,MAXRPT=63)
-      real s3(64,63)
-      character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
-      character*12 mycall,hiscall
-      character*22 decoded
-      character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
-      character*15 callgrid(MAXCALLS)
-      character*180 line
-      character*4 rpt(MAXRPT)
-      integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
-!      character*1 cflag
-      character*36 cc
-      integer dgen(12)
-      common/tmp8/ mcode(63)
-      common/tmp9/ mrs(63),mrs2(63)
-      data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
-#ifdef CVF
-C  This prevents some optimizations that break this subroutine.
-      volatile p1,p2,bias
-#endif
-
-      data neme0/-99/
-      data rpt/'-01','-02','-03','-04','-05',
-     +         '-06','-07','-08','-09','-10',
-     +         '-11','-12','-13','-14','-15',
-     +         '-16','-17','-18','-19','-20',
-     +         '-21','-22','-23','-24','-25',
-     +         '-26','-27','-28','-29','-30',
-     +         'R-01','R-02','R-03','R-04','R-05',
-     +         'R-06','R-07','R-08','R-09','R-10',
-     +         'R-11','R-12','R-13','R-14','R-15',
-     +         'R-16','R-17','R-18','R-19','R-20',
-     +         'R-21','R-22','R-23','R-24','R-25',
-     +         'R-26','R-27','R-28','R-29','R-30',
-     +         'RO','RRR','73'/
-      data iseed/1000000001/,dgen(1)/999/
-      save
-
-      call cs_lock('deep65')
-      rewind 23
-      k=0
-      icall=0
-      do n=1,MAXCALLS
-         if(n.eq.1) then
-            callsign=hiscall
-            do i=4,12
-               if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
-            enddo
-            grid=hisgrid(1:4)
-            if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
-            if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
-         else
-            read(23,1002,end=20) line
- 1002       format (A80)
-            if(line(1:4).eq.'ZZZZ') go to 20
-            if(line(1:2).eq.'//') go to 10
-            i1=index(line,',')
-            if(i1.lt.4) go to 10
-            i2=index(line(i1+1:),',')
-            if(i2.lt.5) go to 10
-            i2=i2+i1
-            i3=index(line(i2+1:),',')
-            if(i3.lt.1) i3=index(line(i2+1:),' ')
-            i3=i2+i3
-            callsign=line(1:i1-1)
-            grid=line(i1+1:i2-1)
-            ceme=line(i2+1:i3-1)
-            if(callsign.eq.hiscall .and. grid.eq.hisgrid(1:4)) go to 10
-            if(neme.eq.1 .and. ceme.ne.'EME') go to 10
-         endif
-
-         icall=icall+1
-         j1=index(mycall,' ') - 1
-         if(j1.le.-1) j1=12
-         if(j1.lt.3) j1=6
-         j2=index(callsign,' ') - 1
-         if(j2.le.-1) j2=12
-         if(j2.lt.3) j2=6
-         j3=index(mycall,'/')
-         j4=index(callsign,'/')
-         callgrid(icall)=callsign(1:j2)
-
-         mz=1
-         if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.
-     +      flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
-C  Test for messages with MyCall + HisCall + report
-         do m=1,mz
-            if(m.gt.1) grid=rpt(m-1)
-            if(j3.lt.1 .and.j4.lt.1) 
-     +         callgrid(icall)=callsign(1:j2)//' '//grid
-            message=mycall(1:j1)//' '//callgrid(icall)
-            k=k+1
-            testmsg(k)=message
-            call encode65(message,ncode(1,k))
-C  Insert CQ message unless sync=OOO (flip=-1).
-            if(m.eq.1 .and. flip.gt.0.0) then
-               message='CQ '//callgrid(icall)
-               k=k+1
-               testmsg(k)=message
-               call encode65(message,ncode(1,k))
-            endif
-         enddo
- 10      continue
-      enddo
- 20   ntot=k
-      call cs_unlock
-      neme0=neme
-
-      ref0=0.
-      do j=1,63
-         ref0=ref0 + s3(mrs(j),j)
-      enddo
-
-      p1=0.
-      p2=0.
-      do k=1,ntot
-         sum=0.
-         ref=ref0
-         do j=1,63
-            i=ncode(j,k)+1
-            sum=sum + s3(i,j)
-            if(i.eq.mrs(j)) then
-               ref=ref - s3(i,j) + s3(mrs2(j),j)
-            endif
-         enddo
-         p=sum/ref
-         if(p.gt.p2) then
-            if(p.gt.p1) then
-               p2=p1
-!               ip2=ip1
-               p1=p
-               ip1=k
-            else
-               p2=p
-!               ip2=k
-            endif
-         endif
-      enddo
-
-      if(mode65.eq.1) bias=max(1.12*p2,0.335)
-      if(mode65.eq.2) bias=max(1.08*p2,0.405)
-      if(mode65.ge.4) bias=max(1.04*p2,0.505)
-      qual=100.0*(p1-bias)
-      if(qual.lt.0.0) qual=0.0
-      decoded='                      '
-      c=' '
-
-      if(qual.gt.1.0) then
-         if(ip1.le.ntot) then
-            if(qual.lt.6.0) c='?'
-            decoded=testmsg(ip1)
-            do j=1,63
-               mcode(j)=ncode(j,ip1)+1
-            enddo
-         else
-            i=ip1-ntot-1
-            i1=i/(36**3)
-            i2=(i - i1*36**3)/(36**2)
-            i3=(i - i1*36**3 - i2*36**2)/36
-            i4=mod(i,36)
-            decoded=cc(i1+1:i1+1)//cc(i2+1:i2+1)//cc(i3+1:i3+1)//
-     +           cc(i4+1:i4+1)//'                  '
-         endif
-
-      endif
-      decoded(22:22)=c
-
-C  Neutralize the SM2CEW foolishness
-      call packmsg(decoded,dgen)
-      call unpackmsg(dgen,decoded)
-
-      return
-      end

Copied: trunk/deep65.f90 (from rev 2228, wsjt7a/deep65.f90)
===================================================================
--- trunk/deep65.f90	                        (rev 0)
+++ trunk/deep65.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,171 @@
+subroutine deep65(s3,mode65,neme,flip,mycall,hiscall,                  &amp;
+     hisgrid,decoded,qual)
+
+  parameter (MAXCALLS=7000,MAXRPT=63)
+  real s3(64,63)
+  character callsign*12,grid*4,message*22,hisgrid*6,c*1,ceme*3
+  character*12 mycall,hiscall
+  character*22 decoded
+  character*22 testmsg(2*MAXCALLS + 2 + MAXRPT)
+  character*15 callgrid(MAXCALLS)
+  character*180 line
+  character*4 rpt(MAXRPT)
+  integer ncode(63,2*MAXCALLS + 2 + MAXRPT)
+  character*36 cc
+  integer dgen(12)
+  common/tmp8/ mcode(63)
+  common/tmp9/ mrs(63),mrs2(63)
+  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
+
+  data neme0/-99/
+  data rpt/'-01','-02','-03','-04','-05',                      &amp;
+              '-06','-07','-08','-09','-10',                   &amp;
+              '-11','-12','-13','-14','-15',                   &amp;
+              '-16','-17','-18','-19','-20',                   &amp;
+              '-21','-22','-23','-24','-25',                   &amp;
+              '-26','-27','-28','-29','-30',                   &amp;
+              'R-01','R-02','R-03','R-04','R-05',              &amp;
+              'R-06','R-07','R-08','R-09','R-10',              &amp;
+              'R-11','R-12','R-13','R-14','R-15',              &amp;
+              'R-16','R-17','R-18','R-19','R-20',              &amp;
+              'R-21','R-22','R-23','R-24','R-25',              &amp;
+              'R-26','R-27','R-28','R-29','R-30',              &amp;
+              'RO','RRR','73'/
+  data iseed/1000000001/,dgen(1)/999/
+  save
+
+  call cs_lock('deep65')
+  rewind 23
+  k=0
+  icall=0
+  do n=1,MAXCALLS
+     if(n.eq.1) then
+        callsign=hiscall
+        do i=4,12
+           if(ichar(callsign(i:i)).eq.0) callsign(i:i)=' '
+        enddo
+        grid=hisgrid(1:4)
+        if(ichar(grid(3:3)).eq.0) grid(3:3)=' '
+        if(ichar(grid(4:4)).eq.0) grid(4:4)=' '
+     else
+        read(23,1002,end=20) line
+1002    format (A80)
+        if(line(1:4).eq.'ZZZZ') go to 20
+        if(line(1:2).eq.'//') go to 10
+        i1=index(line,',')
+        if(i1.lt.4) go to 10
+        i2=index(line(i1+1:),',')
+        if(i2.lt.5) go to 10
+        i2=i2+i1
+        i3=index(line(i2+1:),',')
+        if(i3.lt.1) i3=index(line(i2+1:),' ')
+        i3=i2+i3
+        callsign=line(1:i1-1)
+        grid=line(i1+1:i2-1)
+        ceme=line(i2+1:i3-1)
+        if(callsign.eq.hiscall .and. grid.eq.hisgrid(1:4)) go to 10
+        if(neme.eq.1 .and. ceme.ne.'EME') go to 10
+     endif
+
+     icall=icall+1
+     j1=index(mycall,' ') - 1
+     if(j1.le.-1) j1=12
+     if(j1.lt.3) j1=6
+     j2=index(callsign,' ') - 1
+     if(j2.le.-1) j2=12
+     if(j2.lt.3) j2=6
+     j3=index(mycall,'/')
+     j4=index(callsign,'/')
+     callgrid(icall)=callsign(1:j2)
+
+     mz=1
+     if(n.eq.1 .and. j3.lt.1 .and. j4.lt.1 .and.                        &amp;
+          flip.gt.0.0 .and. callsign(1:6).ne.'      ') mz=MAXRPT+1
+! Test for messages with MyCall + HisCall + report
+     do m=1,mz
+        if(m.gt.1) grid=rpt(m-1)
+        if(j3.lt.1 .and.j4.lt.1)                                        &amp;
+             callgrid(icall)=callsign(1:j2)//' '//grid
+        message=mycall(1:j1)//' '//callgrid(icall)
+        k=k+1
+        testmsg(k)=message
+        call encode65(message,ncode(1,k))
+! Insert CQ message unless sync=OOO (flip=-1).
+        if(m.eq.1 .and. flip.gt.0.0) then
+           message='CQ '//callgrid(icall)
+           k=k+1
+           testmsg(k)=message
+           call encode65(message,ncode(1,k))
+        endif
+     enddo
+10   continue
+  enddo
+20 ntot=k
+  call cs_unlock
+  neme0=neme
+
+  ref0=0.
+  do j=1,63
+     ref0=ref0 + s3(mrs(j),j)
+  enddo
+
+  p1=0.
+  p2=0.
+  do k=1,ntot
+     sum=0.
+     ref=ref0
+     do j=1,63
+        i=ncode(j,k)+1
+        sum=sum + s3(i,j)
+        if(i.eq.mrs(j)) then
+           ref=ref - s3(i,j) + s3(mrs2(j),j)
+        endif
+     enddo
+     p=sum/ref
+     if(p.gt.p2) then
+        if(p.gt.p1) then
+           p2=p1
+!               ip2=ip1
+           p1=p
+           ip1=k
+        else
+           p2=p
+!               ip2=k
+        endif
+     endif
+  enddo
+  
+  if(mode65.eq.1) bias=max(1.12*p2,0.335)
+  if(mode65.eq.2) bias=max(1.08*p2,0.405)
+  if(mode65.ge.4) bias=max(1.04*p2,0.505)
+  qual=100.0*(p1-bias)
+  if(qual.lt.0.0) qual=0.0
+  decoded='                      '
+  c=' '
+
+  if(qual.gt.1.0) then
+     if(ip1.le.ntot) then
+        if(qual.lt.6.0) c='?'
+        decoded=testmsg(ip1)
+        do j=1,63
+           mcode(j)=ncode(j,ip1)+1
+        enddo
+     else
+        i=ip1-ntot-1
+        i1=i/(36**3)
+        i2=(i - i1*36**3)/(36**2)
+        i3=(i - i1*36**3 - i2*36**2)/36
+        i4=mod(i,36)
+        decoded=cc(i1+1:i1+1)//cc(i2+1:i2+1)//cc(i3+1:i3+1)//        &amp;
+             cc(i4+1:i4+1)//'                  '
+     endif
+     
+  endif
+  decoded(22:22)=c
+
+! Neutralize the SM2CEW foolishness
+  call packmsg(decoded,dgen)
+  call unpackmsg(dgen,decoded)
+
+  return
+end subroutine deep65

Copied: trunk/diana.f90 (from rev 2228, wsjt7a/diana.f90)
===================================================================
--- trunk/diana.f90	                        (rev 0)
+++ trunk/diana.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,47 @@
+subroutine diana(dat,npts,cfile6,MinSigdB,DFTolerance,NFreeze,       &amp;
+     MouseDF,ccfblue,ccfred)
+
+! Decode a Diana signal
+
+  parameter (NMAX=512*1024)
+  parameter (NSZ=646)                     !Quarter-symbols in 30 s
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  character cfile6*6                      !File time
+  character c42*42
+  character msg*28
+  real s0(1024,NSZ)
+  real fs0(1024,96)                       !Folded-for-sync symbol spectra
+  real ccfblue(-5:540)
+  real ccfred(-224:224)
+  integer dftolerance
+  data nsps/2048/,nsync/4/,nlen/2/,ndat/18/
+
+  nsym=npts/nsps                      !Total symbol intervals in file
+  nblk=nsync+nlen+ndat                !Frame size
+  nfft=4096
+  nq=nfft/4
+  df=11025.0/nfft
+  kstep=nsps/4
+
+  call specdiana(dat,npts,s0,jsym,fs0)   !Get symbol spectra, fold for sync
+
+  call syncdiana(fs0,kstep,nfreeze,mousedf,dftolerance,syncx,     &amp;
+     ipk,jpk,dfx,dtx,msglen,ccfblue,ccfred)     !Get sync: DF, DT, msglen
+  
+  msg=' '
+  nsnr=-25
+  jsync=syncx
+  if(jsync.ge.MinSigdB .and. msglen.gt.0) call decdiana(s0,jsym,ipk,jpk,  &amp;
+       msglen,msg,nsnr)                               !Decode message
+  jdf=nint(dfx)
+  nwidth=0
+
+  call cs_lock('iscat')
+!  write(*,1020) cfile6,jsync,nsnr,dtx,jdf,nwidth,msg
+  write(11,1020) cfile6,jsync,nsnr,dtx,jdf,nwidth,msg
+  write(21,1020) cfile6,jsync,nsnr,dtx,jdf,nwidth,msg
+1020 format(a6,i3,i5,f5.1,i5,i3,7x,a28)
+  call cs_unlock
+
+  return
+end subroutine diana

Copied: trunk/echogen.f90 (from rev 2228, wsjt7a/echogen.f90)
===================================================================
--- trunk/echogen.f90	                        (rev 0)
+++ trunk/echogen.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,50 @@
+subroutine echogen(mode_echo,dither,iwave,nwave,f1)
+
+  parameter (NMAX=44100)            !Length of wave file, 4.0 seconds
+  real dither                       !Amount to dither f1
+  integer*2 iwave(NMAX)             !Wave file to be generated
+  integer nwave                     !Length of wave file
+  real f1                           !Generated audio frequency
+  real*8 dt,pha,dpha,twopi,f,df
+  integer ic27(27)
+  data ic27/1,3,7,15,2,5,11,23,18,8,17,6,13,27,26,24,20,12,25,22,   &amp;
+       16,4,9,19,10,21,14/
+
+  twopi=8*atan(1.d0)
+  dt=1.d0/11025.d0
+  df=11025.d0/890.d0
+
+  if(mode_echo.ne.0) then
+     pha=0.d0
+     k=0
+     do j=1,27
+        f=1500.d0 + (ic27(j)-14)*df
+        dpha=twopi*f*dt
+        do i=1,890
+           pha=pha+dpha
+           k=k+1
+           iwave(k)=nint(32767.0*sin(pha))
+        enddo
+     enddo
+     do i=1,20
+        pha=pha+dpha
+        k=k+1
+        iwave(k)=nint(32767.0*sin(pha))
+        if(abs(iwave(k)).lt.3000) go to 10
+     enddo
+10   iwave(k+1:)=0
+     f1=1500.0
+  else
+     call random_number(r)
+     f1=1500 + dither*(r-0.5)          !Define the TX frequency
+     dpha=twopi*dt*f1
+     pha=0.
+     do i=1,NMAX
+        pha=pha+dpha
+        iwave(i)=nint(32767.0*sin(pha))
+     enddo
+  endif
+  nwave=NMAX
+
+  return
+end subroutine echogen

Modified: trunk/extract.f
===================================================================
--- trunk/extract.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/extract.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -5,6 +5,7 @@
       character decoded*22
       integer era(51),dat4(12),indx(64)
       integer mrsym(63),mr2sym(63),mrprob(63),mr2prob(63)
+      integer system
       logical first
       common/extcom/ntdecode
       data first/.true./,nsec1/0/
@@ -52,10 +53,10 @@
          call cs_lock('extract')
          write(22,rec=1) nsec1,xlambda,maxe,naddsynd,
      +        mrsym,mrprob,mr2sym,mr2prob
-         call flushqqq(22)
+         call flush(22)
          call cs_unlock
 
-         call runqqq('kvasd.exe','-q',iret)
+         iret=system('KVASD_g95 -q &gt;devnull')
 
          call cs_lock('extract')
          if(iret.ne.0) then

Deleted: trunk/fano232.f
===================================================================
--- trunk/fano232.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/fano232.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,159 +0,0 @@
-      subroutine fano232(symbol,nbits,mettab,ndelta,maxcycles,
-     +   dat,ncycles,metric,ierr)
-
-C  Sequential decoder for K=32, r=1/2 convolutional code using 
-C  the Fano algorithm.  Translated from C routine for same purpose
-C  written by Phil Karn, KA9Q.
-
-      parameter (MAXBITS=103)
-      parameter (MAXDAT=(MAXBITS+7)/8)
-      integer*1 symbol(0:2*MAXBITS-1)
-      integer*1 dat(MAXDAT)               !Decoded user data, 8 bits per byte
-      integer*1 i1
-      integer mettab(0:255,0:1)           !Metric table
-
-C  These were the &quot;node&quot; structure in Karn's C code:
-      integer nstate(0:MAXBITS-1)      !Encoder state of next node
-      integer gamma(0:MAXBITS-1)       !Cumulative metric to this node
-      integer metrics(0:3,0:MAXBITS-1) !Metrics indexed by all possible Tx syms
-      integer tm(0:1,0:MAXBITS-1)      !Sorted metrics for current hypotheses
-      integer ii(0:MAXBITS-1)          !Current branch being tested
-
-      logical noback
-      equivalence(i1,i4)
-      include 'conv232.f'
-
-      ntail=nbits-31
-
-C  Compute all possible branch metrics for each symbol pair.
-C  This is the only place we actually look at the raw input symbols
-      i4a=0
-      i4b=0
-      do np=0,nbits-1
-         j=2*np
-         i4a=symbol(j)
-         i4b=symbol(j+1)
-         if (i4a.lt.0) i4a=i4a+256
-         if (i4b.lt.0) i4b=i4b+256
-         metrics(0,np) = mettab(i4a,0) + mettab(i4b,0)
-         metrics(1,np) = mettab(i4a,0) + mettab(i4b,1)
-         metrics(2,np) = mettab(i4a,1) + mettab(i4b,0)
-         metrics(3,np) = mettab(i4a,1) + mettab(i4b,1)
-      enddo
-
-      np=0
-      nstate(np)=0
-
-C  Compute and sort branch metrics from the root node
-      n=iand(nstate(np),npoly1)
-      n=ieor(n,ishft(n,-16))
-      lsym=partab(iand(ieor(n,ishft(n,-8)),255))
-      n=iand(nstate(np),npoly2)
-      n=ieor(n,ishft(n,-16))
-      lsym=lsym+lsym+partab(iand(ieor(n,ishft(n,-8)),255))
-      m0=metrics(lsym,np)
-      m1=metrics(ieor(3,lsym),np)
-      if(m0.gt.m1) then
-         tm(0,np)=m0                      !0-branch has better metric
-         tm(1,np)=m1
-      else
-         tm(0,np)=m1                      !1-branch is better
-         tm(1,np)=m0
-         nstate(np)=nstate(np) + 1        !Set low bit
-      endif
-
-C  Start with best branch
-      ii(np)=0
-      gamma(np)=0
-      nt=0
-
-C  Start the Fano decoder
-      do i=1,nbits*maxcycles
-C  Look forward
-         ngamma=gamma(np) + tm(ii(np),np)
-         if(ngamma.ge.nt) then
-
-C  Node is acceptable.  If first time visiting this node, tighten threshold:
-            if(gamma(np).lt.(nt+ndelta)) nt=nt + 
-     +                            ndelta * ((ngamma-nt)/ndelta)
-
-C  Move forward
-            gamma(np+1)=ngamma
-            nstate(np+1)=ishft(nstate(np),1)
-            np=np+1
-            if(np.eq.nbits-1) go to 100     !We're done!
-
-            n=iand(nstate(np),npoly1)
-            n=ieor(n,ishft(n,-16))
-            lsym=partab(iand(ieor(n,ishft(n,-8)),255))
-            n=iand(nstate(np),npoly2)
-            n=ieor(n,ishft(n,-16))
-            lsym=lsym+lsym+partab(iand(ieor(n,ishft(n,-8)),255))
-            
-            if(np.ge.ntail) then
-               tm(0,np)=metrics(lsym,np)      !We're in the tail, all zeros
-            else
-               m0=metrics(lsym,np)
-               m1=metrics(ieor(3,lsym),np)
-               if(m0.gt.m1) then
-                  tm(0,np)=m0                 !0-branch has better metric
-                  tm(1,np)=m1
-               else
-                  tm(0,np)=m1                 !1-branch is better
-                  tm(1,np)=m0
-                  nstate(np)=nstate(np) + 1   !Set low bit
-               endif
-            endif
-
-            ii(np)=0                          !Start with best branch
-            go to 99
-         endif
-
-C  Threshold violated, can't go forward
- 10      noback=.false.
-         if(np.eq.0) noback=.true.
-         if(np.gt.0) then
-            if(gamma(np-1).lt.nt) noback=.true.
-         endif
-
-         if(noback) then
-C  Can't back up, either.  Relax threshold and look forward again 
-C  to a better branch.
-            nt=nt-ndelta
-            if(ii(np).ne.0) then
-               ii(np)=0
-               nstate(np)=ieor(nstate(np),1)
-            endif
-            go to 99
-         endif
-
-C  Back up
-         np=np-1
-         if(np.lt.ntail .and. ii(np).ne.1) then
-C  Search the next best branch
-            ii(np)=ii(np)+1
-            nstate(np)=ieor(nstate(np),1)
-            go to 99
-         endif
-         go to 10
- 99      continue
-      enddo
-      i=nbits*maxcycles
-
- 100  metric=gamma(np)                       !Final path metric
-
-C  Copy decoded data to user's buffer
-      nbytes=(nbits+7)/8
-      np=7
-      do j=1,nbytes-1
-         i4=nstate(np)
-         dat(j)=i1
-         np=np+8
-      enddo
-      dat(nbytes)=0
-      ncycles=i+1
-      ierr=0
-      if(i.ge.maxcycles*nbits) ierr=-1
-
-      return
-      end

Deleted: trunk/fchisq.f
===================================================================
--- trunk/fchisq.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/fchisq.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,101 +0,0 @@
-      real function fchisq(cx,npts,fsample,a,lag1,lag2,ccfmax,dtmax)
-
-      parameter (NMAX=120*375)
-      complex cx(npts)
-      real a(5)
-      complex*16 w1,ws1
-      complex*16 w2,ws2
-      complex*16 w3,ws3
-      complex*16 w4,ws4
-      complex*16 cs1(0:NMAX)
-      complex*16 cs2(0:NMAX)
-      complex*16 cs3(0:NMAX)
-      complex*16 cs4(0:NMAX)
-      complex z1,z2,z3,z4
-      real*8 twopi,baud,p2
-!      real ss(2812)
-      real ss(5624)
-
-      twopi=8.d0*atan(1.d0)
-      baud=12000.d0/8192
-
-C  Mix and integrate four channels
-      cs1(0)=0.
-      cs2(0)=0.
-      cs3(0)=0.
-      cs4(0)=0.
-      w1=1.0
-      w2=1.0
-      w3=1.0
-      w4=1.0
-      ws1=1.0
-      ws2=1.0
-      ws3=1.0
-      ws4=1.0
-      x0=0.5*(npts+1)           !Middle sample
-      s=2.0/npts
-      dt=1.0/fsample
-      do i=1,npts
-         x=s*(i-x0)             !x runs from -1 to +1
-         if(mod(i,100).eq.1) then
-            p2=1.5*x*x - 0.5
-!           p3=2.5*(x**3) - 1.5*x
-!           p4=4.375*(x**4) - 3.75*(x**2) + 0.375
-            dphi1=twopi*dt*(a(1) + x*a(2) + p2*a(3) - 1.5*baud)
-            dphi2=twopi*dt*(a(1) + x*a(2) + p2*a(3) - 0.5*baud)
-            dphi3=twopi*dt*(a(1) + x*a(2) + p2*a(3) + 0.5*baud)
-            dphi4=twopi*dt*(a(1) + x*a(2) + p2*a(3) + 1.5*baud)
-            ws1=cmplx(cos(dphi1),sin(dphi1))
-            ws2=cmplx(cos(dphi2),sin(dphi2))
-            ws3=cmplx(cos(dphi3),sin(dphi3))
-            ws4=cmplx(cos(dphi4),sin(dphi4))
-         endif
-         w1=w1*ws1
-         w2=w2*ws2
-         w3=w3*ws3
-         w4=w4*ws4
-         cs1(i)=cs1(i-1) + w1*cx(i)
-         cs2(i)=cs2(i-1) + w2*cx(i)
-         cs3(i)=cs3(i-1) + w3*cx(i)
-         cs4(i)=cs4(i-1) + w4*cx(i)
-      enddo
-
-C  Compute full-symbol powers at 1/16-symbol steps.
-      nsps=nint(fsample/baud)                  !Samples per symbol
-      ndiv=16                                  !Steps per symbol
-      nout=ndiv*npts/nsps                      !Total steps
-      dtstep=1.0/(ndiv*baud)                   !Time per output step
-      fac=1.e-5
-
-      ss=0.
-      do i=1,nout
-         j=i*nsps/ndiv
-         k=j - nsps
-         ss(i)=0.
-         if(k.ge.1) then
-            z1=cs1(j)-cs1(k)
-            z2=cs2(j)-cs2(k)
-            z3=cs3(j)-cs3(k)
-            z4=cs4(j)-cs4(k)
-
-            p1=real(z1)**2 + aimag(z1)**2
-            p2=real(z2)**2 + aimag(z2)**2
-            p3=real(z3)**2 + aimag(z3)**2
-            p4=real(z4)**2 + aimag(z4)**2
-
-!            ss(i)=fac*(max(p2,p4) - max(p1,p3))
-            ss(i)=fac*((p2+p4) - (p1+p3))
-         endif
-      enddo
-
-      ccfmax=0.
-      call ccf2(ss,nout,lag1,lag2,ccf,lagpk)
-      if(ccf.gt.ccfmax) then
-         ccfmax=ccf
-         dtmax=lagpk*dtstep
-      endif
-! Reverse sign (and offset!) because we will be minimizing fchisq
-      fchisq=-ccfmax + 100.0
-
-      return
-      end

Deleted: trunk/filbig2.F
===================================================================
--- trunk/filbig2.F	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/filbig2.F	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,141 +0,0 @@
-      subroutine filbig2(dat,nmax,f0,newdat2,c4a,n4)
-
-C  Filter and downsample real data for one polarization, stored
-C  in array dat(nmax).  Output is downsampled from 11025 (or 12000?) Hz
-C  to 375 Hz; the low-pass filter has f_cutoff = 100 Hz, f_stop = 187.5 Hz, 
-C  ripple=0.1 dB, Atten=50 dB.
-
-      parameter (NFFT1=1323000,NFFT2=45000)
-      real dat(nmax)                             !Input data
-      complex ca(NFFT1)                          !FFTs of input
-      complex c4a(NFFT2)                         !Output data
-      complex c4(NFFT2)
-      real*8 df
-C Impulse response of filter (one side)
-      real halfpulse(4)
-!Filter (complex; imag = 0)
-      complex cfilt(NFFT2)                       
-      real rfilt(NFFT2)                          !Filter (real)
-      integer plan1,plan3,plan5
-      logical first
-      include 'fftw3.f'
-      common/filcom/ca,c4
-      equivalence (rfilt,cfilt)
-      data first/.true./
-      data halfpulse/0.758314821007,0.205883390004,-0.123207383552,
-     +     0.045847258328/
-      save
-
-      if(nmax.lt.0) go to 900
-      if(first) then
-         npatience=FFTW_ESTIMATE
-!         npatience=FFTW_MEASURE
-C  Plan the FFTs just once
-#ifdef CVF
-         call sfftw_plan_dft_1d_(plan1,NFFT1,ca,ca,
-     +        FFTW_FORWARD,npatience)                      !BACK
-         call sfftw_plan_dft_1d_(plan3,NFFT2,c4,c4,
-     +        FFTW_BACKWARD,npatience)                     !FOR
-         call sfftw_plan_dft_1d_(plan5,NFFT2,cfilt,cfilt,
-     +        FFTW_FORWARD,npatience)                      !BACK
-#else
-         call sfftw_plan_dft_1d(plan1,NFFT1,ca,ca,
-     +        FFTW_FORWARD,npatience)                      !BACK
-         call sfftw_plan_dft_1d(plan3,NFFT2,c4,c4,
-     +        FFTW_BACKWARD,npatience)                     !FOR
-         call sfftw_plan_dft_1d(plan5,NFFT2,cfilt,cfilt,
-     +        FFTW_FORWARD,npatience)                      !BACK
-#endif
-
-C  Convert impulse response to filter function
-         do i=1,NFFT2
-            cfilt(i)=0.
-         enddo
-         fac=1.0/NFFT1                          !### Scale here, if needed
-         cfilt(1)=fac*halfpulse(1)
-         do i=2,4
-            cfilt(i)=fac*halfpulse(i)
-            cfilt(NFFT2+2-i)=fac*halfpulse(i)
-         enddo
-#ifdef CVF
-         call sfftw_execute_(plan5)
-#else
-         call sfftw_execute(plan5)
-#endif
-         base=cfilt(NFFT2/2+1)
-         do i=1,NFFT2
-            rfilt(i)=real(cfilt(i))-base
-         enddo
-
-         df=11025.d0/NFFT1
-         first=.false.
-      endif
-
-C  When new data comes along, we need to compute a new &quot;big FFT&quot;
-C  If we just have a new f0, continue with the existing ca.
-
-      if(newdat2.ne.0) then
-         nz=min(nmax,NFFT1)
-         do i=1,nz
-            ca(i)=dat(i)
-         enddo
-         if(nmax.lt.NFFT1) then
-            do i=nmax+1,NFFT1
-               ca(i)=0.
-            enddo
-         endif
-#ifdef CVF
-         call sfftw_execute_(plan1)
-#else
-         call sfftw_execute(plan1)
-#endif
-         newdat2=0
-      endif
-
-C  NB: f0 is the frequency at which we want our filter centered.
-C      i0 is the bin number in ca and cb closest to f0.
-
-      i0=nint(f0/df) + 1
-      nh=NFFT2/2
-      do i=1,nh                                !Copy data into c4 and
-         j=i0+i-1                              !apply the filter function
-         c4(i)=rfilt(i)*ca(j)
-      enddo
-      do i=nh+1,NFFT2
-         j=i0+i-1-NFFT2
-         if(j.lt.1) j=j+NFFT1                  !### $$$ ###
-         c4(i)=rfilt(i)*ca(j)
-      enddo
-      n4=min(int(nmax*375.0/11025.0),NFFT2)
-
-C  Do the short reverse transform, to go back to time domain.
-#ifdef CVF
-      call sfftw_execute_(plan3)
-#else
-      call sfftw_execute(plan3)
-#endif
-
-      do i=1,NFFT2                             !Copy data into c4a
-         c4a(i)=c4(i)
-      enddo
-
-      go to 999
-
- 900  if(plan1.ne.0) then
-!         print*,'Destroying FFTW plans'
-#ifdef CVF
-         call sfftw_destroy_plan_(plan1)
-         call sfftw_destroy_plan_(plan3)
-         call sfftw_destroy_plan_(plan5)
-#else
-         call sfftw_destroy_plan(plan1)
-         call sfftw_destroy_plan(plan3)
-         call sfftw_destroy_plan(plan5)
-#endif
-         plan1=0
-         plan3=0
-         plan5=0
-      endif
-
- 999  return
-      end

Deleted: trunk/fivehz.F90
===================================================================
--- trunk/fivehz.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/fivehz.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,279 +0,0 @@
-subroutine fivehz
-
-!  Called at interrupt level from the PortAudio callback routine.
-!  For nspb=2048 the callback rate is nfsample/nspb = 5.38 Hz.
-!  Thus, we should be able to control the timing of T/R sequence events
-!  here to within about 0.2 s.
-
-!  Do not do anything very time consuming in this routine!!
-!  Disk I/O is a bad idea.  Writing to stdout (for diagnostic purposes)
-!  seems to be OK.
-
-#ifdef CVF
-  use dflib
-  use dfport
-#else
-  integer time
-#endif
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,txtime,filled
-  integer ptt
-  integer TxOKz
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  data first/.true./,nc0/1/,nc1/1/,nsec0/-99/
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     rxdelay=0.2
-     txdelay=0.4
-     tlatency=1.0
-     first=.false.
-     iptt=0
-     ntr0=-99
-     rxdone=.false.
-     ibuf00=-99
-     ncall=-1
-     u=0.05d0
-     fsample=11025.d0
-     mfsample=110250
-     filled=.false.
-  endif
-
-  if(txdelay.lt.0.2d0) txdelay=0.2d0
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-!  if(ncall.ge.10 .and. mod(ncall,2).eq.1) then
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample=nint(10.d0*fsample)
-     endif
-  endif
-
-  if(trperiod.le.0) trperiod=30
-  tx1=0.0                              !Time to start a TX sequence
-  tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or.                   &amp;
-       mode(1:3).eq.'JT4' .or. mode(1:4).eq.'JT64') then
-     if(nwave.lt.126*4096) nwave=126*4096
-     tx2=txdelay + nwave/11025.0
-     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
-  else if(mode(1:4).eq.'WSPR') then
-     tx2=txdelay + nwave/11025.0
-     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
-  endif
-
-  if(TxFirst.eq.0) then
-     tx1=tx1+trperiod
-     tx2=tx2+trperiod
-  endif
-
-  t=mod(Tsec,2.d0*trperiod)
-  txtime = t.ge.tx1 .and. t.lt.tx2
-
-! If we're transmitting, freeze the input buffer pointers where they were.
-  receiving=1
-  if(((txtime .and. (lauto.eq.1)) .or. TxOK.eq.1 .or. transmitting.eq.1) &amp; 
-       .and. (mute.eq.0)) then
-     receiving=0
-     ibuf=ibuf000
-     iwrite=iwrite000
-  endif
-  ibuf000=ibuf
-  iwrite000=iwrite
-  nsec=Tsec
-  ntr=mod(nsec/trperiod,2)             !ntr=0 in 1st sequence, 1 in 2nd
-
-  if(ntr.ne.ntr0) then
-     ibuf0=ibuf                        !Start of new sequence, save ibuf
-!     if(mode(1:4).ne.'JT65') then
-!        ibuf0=ibuf0+3                  !So we don't copy our own Tx
-!        if(ibuf0.gt.1024) ibuf0=ibuf0-1024
-!     endif
-     ntime=time()                      !Save start time
-     if(mantx.eq.1 .and. iptt.eq.1) then
-        mantx=0
-        TxOK=0
-     endif
-  endif
-
-! Switch PTT line and TxOK appropriately
-  if(lauto.eq.1) then
-     if(txtime .and. iptt.eq.0 .and.          &amp;
-          mute.eq.0) i1=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(.not.txtime .or. mute.eq.1) TxOK=0               !Lower TxOK
-  else
-     if(mantx.eq.1 .and. iptt.eq.0 .and.      &amp;
-          mute.eq.0) i2=ptt(nport,pttport,1,iptt)        !Raise PTT
-     if(mantx.eq.0 .or. mute.eq.1) TxOK=0                !Lower TxOK
-  endif
-
-! Calculate Tx waveform as needed
-  if((iptt.eq.1 .and. iptt0.eq.0) .or. nrestart.eq.1) then
-     call wsjtgen
-     nrestart=0
-  endif
-
-! If PTT was just raised, start a countdown for raising TxOK:
-  nc1a=txdelay/0.18576
-  if(nc1a.lt.2) nc1a=2
-  if(iptt.eq.1 .and. iptt0.eq.0) nc1=-nc1a-1
-  if(nc1.le.0) nc1=nc1+1
-  if(nc1.eq.0) TxOK=1                               ! We are transmitting
-
-! If TxOK was just lowered, start a countdown for lowering PTT:
-  nc0a=(tlatency+txdelay)/0.18576
-  if(nc0a.lt.5) nc0a=5
-  if(TxOK.eq.0 .and. TxOKz.eq.1 .and. iptt.eq.1) nc0=-nc0a-1
-  if(nc0.le.0) nc0=nc0+1
-  if(nc0.eq.0) i3=ptt(nport,pttport,0,iptt)
-
-  if(iptt.eq.0 .and.TxOK.eq.0) then
-     sending=&quot;                      &quot;
-     sendingsh=0
-  endif
-
-  nbufs=i1+i2+i3                             !Silence g95 warning
-  nbufs=ibuf-ibuf0
-  if(nbufs.lt.0) nbufs=nbufs+1024
-  tdata=nbufs*2048.0/11025.0
-
-  if((mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or. mode(1:3).eq.'JT4' &amp;
-       .or. mode(1:2).eq.'CW' .or. mode(1:4).eq.'WSPR' .or.               &amp;
-       mode(1:4).eq.'JT64') .and. monitoring.eq.1 &amp;
-       .and. tdata.gt.float(ntdecode) .and. ibuf0.ne.ibuf00) then
-     rxdone=.true.
-     ibuf00=ibuf0
-  endif
-
-! Diagnostic timing information:
-!  t60=mod(tsec,60.d0)
-!  if(TxOK.ne.TxOKz) then
-!     if(TxOK.eq.1) write(*,1101) 'D2:',t
-!1101 format(a3,f8.1,i8)
-!     if(TxOK.eq.0) then
-!        tstop=tsec
-!        write(*,1101) 'D3:',t,nc0a
-!     endif
-!  endif
-!  if(iptt.ne.iptt0) then
-!     if(iptt.eq.1) then
-!        tstart=tsec
-!        write(*,1101) 'D1:',t,nc1a
-!     endif
-!     if(iptt.eq.0) write(*,1101) 'D4:',t
-!  endif
-
-  iptt0=iptt
-  TxOKz=TxOK
-  ntr0=ntr
-
-  return
-end subroutine fivehz
-
-subroutine fivehztx
-
-!  Called at interrupt level from the PortAudio output callback.
-
-#ifdef CVF
-  use dflib
-  use dfport
-#endif
-
-  parameter (NTRING=64)
-  real*8 tt1(0:NTRING-1)
-  logical first,filled
-  real*8 fs,fsample,tt,u
-  include 'gcom1.f90'
-  data first/.true./
-  save
-
-  n1=time()
-  n2=mod(n1,86400)
-  tt=n1-n2+tsec-0.1d0*ndsec
-
-  if(first) then
-     first=.false.
-     ncall=-1
-     fsample=11025.d0
-     u=0.05d0
-     mfsample2=110250
-     filled=.false.
-  endif
-
-! Measure average sampling frequency over a recent interval
-  ncall=ncall+1
-  if(ncall.eq.9) then
-     ntt0=0
-     ntt1=0
-     tt1(ntt1)=tt
-  endif
-  if(ncall.ge.10) then
-     ntt1=iand(ntt1+1,NTRING-1)
-     tt1(ntt1)=tt
-     if(ntt1.eq.NTRING-1) filled=.true.
-     if(filled) ntt0=iand(ntt1+1,NTRING-1)
-     if(mod(ncall,2).eq.1) then
-        nd=ntt1-ntt0
-        if(nd.lt.0) nd=nd+NTRING
-        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
-        fsample=u*fs + (1.d0-u)*fsample
-        mfsample2=nint(10.d0*fsample)
-     endif
-  endif
-
-  return
-end subroutine fivehztx
-
-subroutine addnoise(n)
-  integer*2 n
-  real*8 txsnrdb0
-  include 'gcom1.f90'
-  data idum/0/
-  save
-
-  if(txsnrdb.gt.40.0) return
-  if(txsnrdb.ne.txsnrdb0) then
-     snr=10.0**(0.05*(txsnrdb-1))
-     fac=3000.0
-     if(snr.gt.1.0) fac=3000.0/snr
-     txsnrdb0=txsnrdb
-  endif
-  i=fac*(gran(idum) + n*snr/32768.0)
-  if(i&gt;32767) i=32767;
-  if(i&lt;-32767) i=-32767;
-  n=i
-
-  return
-end subroutine addnoise
-
-real function gran(idum)
-  real r(12)
-  if(idum.lt.0) then
-     call random_seed
-     idum=0
-  endif
-  call random_number(r)
-  gran=sum(r)-6.0
-end function gran

Copied: trunk/fivehz.f90 (from rev 2228, wsjt7a/fivehz.f90)
===================================================================
--- trunk/fivehz.f90	                        (rev 0)
+++ trunk/fivehz.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,310 @@
+subroutine fivehz
+
+!  Called at interrupt level from the PortAudio callback routine.
+!  For nspb=2048 the callback rate is nfsample/nspb = 5.38 Hz.
+!  Thus, we should be able to control the timing of T/R sequence events
+!  here to within about 0.2 s.
+
+!  Do not do anything very time consuming in this routine!!
+!  Disk I/O is a bad idea.  Writing to stdout (for diagnostic purposes)
+!  seems to be OK.
+
+  integer time
+
+  parameter (NTRING=64)
+  real*8 tt1(0:NTRING-1)
+  logical first,txtime,filled
+  integer ptt
+  integer TxOKz
+  real*8 fs,fsample,tt,u
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  data first/.true./,nc0/1/,nc1/1/,nsec0/-99/
+  save
+
+  n1=time()
+  n2=mod(n1,86400)
+  tt=n1-n2+tsec-0.1d0*ndsec
+
+  if(first) then
+     rxdelay=0.2
+     txdelay=0.4
+     tlatency=1.0
+     first=.false.
+     iptt=0
+     ntr0=-99
+     rxdone=.false.
+     ibuf00=-99
+     ncall=-1
+     u=0.05d0
+     fsample=11025.d0
+     mfsample=110250
+     filled=.false.
+     techo=2.5
+  endif
+
+  if(txdelay.lt.0.2d0) txdelay=0.2d0
+
+! Measure average sampling frequency over a recent interval
+  ncall=ncall+1
+  if(ncall.eq.9) then
+     ntt0=0
+     ntt1=0
+     tt1(ntt1)=tt
+  endif
+!  if(ncall.ge.10 .and. mod(ncall,2).eq.1) then
+  if(ncall.ge.10) then
+     ntt1=iand(ntt1+1,NTRING-1)
+     tt1(ntt1)=tt
+     if(ntt1.eq.NTRING-1) filled=.true.
+     if(filled) ntt0=iand(ntt1+1,NTRING-1)
+     if(mod(ncall,2).eq.1) then
+        nd=ntt1-ntt0
+        if(nd.lt.0) nd=nd+NTRING
+        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
+        fsample=u*fs + (1.d0-u)*fsample
+        mfsample=nint(10.d0*fsample)
+     endif
+  endif
+
+! Echo mode
+  if(mode(1:4).ne.'Echo') n3=0
+  if(mode(1:4).eq.'Echo') then
+     s6=mod(tsec,6.d0)
+     if(lauto.eq.0 .and. (n3.le.0 .or. n3.ge.6)) go to 10
+
+! When s6 has wrapped back to zero, start a new cycle
+     if(s6.lt.s6z) then
+        TxOK=0                              !Lower TxOK
+        i1=ptt(nport,pttport,1,ndtr,iptt)   !Raise PTT
+        call wsjtgen                        !Generate the waveform
+        t1a=s6
+        n3=1
+!        if(ndebug.gt.0) write(*,3001) n3,s6,0.0,' Raise PTT'
+!3001    format(i1,2f7.2,10x,a)
+        go to 10
+     endif
+
+     if(n3.eq.1 .and. s6.gt.s6z) then
+        TxOK=1
+        t2a=s6                              !Save start time of Tx audio
+        n3=2
+!        if(ndebug.gt.0) write(*,3001) n3,s6,s6-t1a,' Start Tx audio'
+        go to 10
+     endif
+
+     if(n3.eq.2 .and. s6.gt.2.6) then
+        TxOK=0                              !Stop Tx audio
+        t3a=s6
+        n3=3
+!        if(ndebug.gt.0) write(*,3001) n3,s6,s6-t2a,' Stop Tx audio'
+        go to 10
+     endif
+
+!     if(n3.eq.3 .and. s6.gt.s6z) then
+     if(n3.eq.3 .and. s6.gt.3.2) then
+        i1=ptt(nport,pttport,0,ndtr,iptt)        !Lower PTT
+        t4a=s6
+        n3=4
+!        if(ndebug.gt.0) write(*,3001) n3,s6,s6-t3a,' Lower PTT'
+        go to 10
+     endif
+
+     if(n3.eq.4 .and. s6.ge.t2a+techo) then
+        t2az=t2a
+        f1z=f1
+        ibuf0=ibuf
+        t5a=s6
+        n3=5
+!        if(ndebug.gt.0) write(*,3002) n3,s6,s6-t4a,ibuf0,' Start Rx'
+!3002    format(i1,2f7.2,i8,2x,a)
+        go to 10
+     endif
+
+     if(n3.eq.5 .and. s6.gt.t5a+2.1) then
+        ndecoding=1
+        t6a=s6
+        n3=6
+!        if(ndebug.gt.0) write(*,3002) n3,s6,s6-t5a,ibuf,' Stop Rx'
+!        if(ndebug.gt.0) write(*,*)
+        go to 10
+     endif
+
+10   s6z=s6
+     go to 900
+  endif
+!End of Echo mode
+
+  if(trperiod.le.0) trperiod=30
+  tx1=0.0                              !Time to start a TX sequence
+  tx2=trperiod-(tlatency+txdelay)      !Time to turn TX off
+  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4') then
+     if(nwave.lt.126*4096) nwave=126*4096
+     tx2=txdelay + nwave/11025.0
+     if(tx2.gt.(trperiod-2.0)) tx2=trperiod-tlatency-1.0
+  endif
+
+  if(TxFirst.eq.0 .and. ntxboth.eq.0) then
+     tx1=tx1+trperiod
+     tx2=tx2+trperiod
+  endif
+
+  t=mod(Tsec,2.d0*trperiod)
+  if(ntxboth.eq.0) then
+     txtime = t.ge.tx1 .and. t.lt.tx2
+  else
+     txtime = (t.ge.tx1 .and. t.lt.tx2) .or.                     &amp;
+          (t.ge.tx1+trperiod .and. t.lt.tx2+trperiod)
+  endif
+
+! If we're transmitting, freeze the input buffer pointers where they were.
+  receiving=1
+  if(((txtime .and. (lauto.eq.1)) .or. TxOK.eq.1 .or. transmitting.eq.1) &amp; 
+       .and. (mute.eq.0)) then
+     receiving=0
+     ibuf=ibuf000
+     iwrite=iwrite000
+  endif
+  ibuf000=ibuf
+  iwrite000=iwrite
+  nsec=Tsec
+  ntr=mod(nsec/trperiod,2)             !ntr=0 in 1st sequence, 1 in 2nd
+
+  if(ntr.ne.ntr0) then
+     ibuf0=ibuf                        !Start of new sequence, save ibuf
+!     if(mode(1:4).ne.'JT65') then
+!        ibuf0=ibuf0+3                  !So we don't copy our own Tx
+!        if(ibuf0.gt.1024) ibuf0=ibuf0-1024
+!     endif
+     ntime=time()                      !Save start time
+     if(mantx.eq.1 .and. iptt.eq.1) then
+        mantx=0
+        TxOK=0
+     endif
+  endif
+
+! Switch PTT line and TxOK appropriately
+  if(lauto.eq.1) then
+     if(txtime .and. iptt.eq.0 .and.          &amp;
+          mute.eq.0) i1=ptt(nport,pttport,1,ndtr,iptt)        !Raise PTT
+     if(.not.txtime .or. mute.eq.1) TxOK=0                    !Lower TxOK
+  else
+     if(mantx.eq.1 .and. iptt.eq.0 .and.      &amp;
+          mute.eq.0) i2=ptt(nport,pttport,1,ndtr,iptt)        !Raise PTT
+     if(mantx.eq.0 .or. mute.eq.1) TxOK=0                     !Lower TxOK
+  endif
+
+! Calculate Tx waveform as needed
+  if((iptt.eq.1 .and. iptt0.eq.0) .or. nrestart.eq.1) then
+     call wsjtgen
+     nrestart=0
+  endif
+
+! If PTT was just raised, start a countdown for raising TxOK:
+  nc1a=txdelay/0.18576
+  if(nc1a.lt.2) nc1a=2
+  if(iptt.eq.1 .and. iptt0.eq.0) nc1=-nc1a-1
+  if(nc1.le.0) nc1=nc1+1
+  if(nc1.eq.0) TxOK=1                               ! We are transmitting
+
+! If TxOK was just lowered, start a countdown for lowering PTT:
+  nc0a=(tlatency+txdelay)/0.18576
+  if(nc0a.lt.5) nc0a=5
+  if(TxOK.eq.0 .and. TxOKz.eq.1 .and. iptt.eq.1) nc0=-nc0a-1
+  if(nc0.le.0) nc0=nc0+1
+  if(nc0.eq.0) i3=ptt(nport,pttport,0,ndtr,iptt)
+
+  if(iptt.eq.0 .and.TxOK.eq.0) then
+     sending=&quot;                      &quot;
+     sendingsh=0
+  endif
+
+  nbufs=i1+i2+i3                             !Silence g95 warning
+  nbufs=ibuf-ibuf0
+  if(nbufs.lt.0) nbufs=nbufs+1024
+  tdata=nbufs*2048.0/11025.0
+
+  if((mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4'                      &amp;
+       .or. mode(1:2).eq.'CW') .and. monitoring.eq.1                   &amp;
+       .and. tdata.gt.float(ntdecode) .and. ibuf0.ne.ibuf00) then
+     rxdone=.true.
+     ibuf00=ibuf0
+  endif
+
+  iptt0=iptt
+  TxOKz=TxOK
+  ntr0=ntr
+
+900 return
+end subroutine fivehz
+
+subroutine fivehztx
+
+!  Called at interrupt level from the PortAudio output callback.
+
+  parameter (NTRING=64)
+  real*8 tt1(0:NTRING-1)
+  logical first,filled
+  real*8 fs,fsample,tt,u
+  include 'gcom1.f90'
+  data first/.true./
+  save
+
+  n1=time()
+  n2=mod(n1,86400)
+  tt=n1-n2+tsec-0.1d0*ndsec
+
+  if(first) then
+     first=.false.
+     ncall=-1
+     fsample=11025.d0
+     u=0.05d0
+     mfsample2=110250
+     filled=.false.
+  endif
+
+! Measure average sampling frequency over a recent interval
+  ncall=ncall+1
+  if(ncall.eq.9) then
+     ntt0=0
+     ntt1=0
+     tt1(ntt1)=tt
+  endif
+  if(ncall.ge.10) then
+     ntt1=iand(ntt1+1,NTRING-1)
+     tt1(ntt1)=tt
+     if(ntt1.eq.NTRING-1) filled=.true.
+     if(filled) ntt0=iand(ntt1+1,NTRING-1)
+     if(mod(ncall,2).eq.1) then
+        nd=ntt1-ntt0
+        if(nd.lt.0) nd=nd+NTRING
+        fs=nd*2048.d0/(tt1(ntt1)-tt1(ntt0))
+        fsample=u*fs + (1.d0-u)*fsample
+        mfsample2=nint(10.d0*fsample)
+     endif
+  endif
+
+  return
+end subroutine fivehztx
+
+subroutine addnoise(n)
+  integer*2 n
+  real*8 txsnrdb0
+  include 'gcom1.f90'
+  data idum/0/
+  save
+
+  if(txsnrdb.gt.40.0) return
+  if(txsnrdb.ne.txsnrdb0) then
+     snr=10.0**(0.05*(txsnrdb-1))
+     fac=3000.0
+     if(snr.gt.1.0) fac=3000.0/snr
+     txsnrdb0=txsnrdb
+  endif
+  i=fac*(gran(idum) + n*snr/32768.0)
+  if(i&gt;32767) i=32767;
+  if(i&lt;-32767) i=-32767;
+  n=i
+
+  return
+end subroutine addnoise

Copied: trunk/foldms.f90 (from rev 2228, wsjt7a/foldms.f90)
===================================================================
--- trunk/foldms.f90	                        (rev 0)
+++ trunk/foldms.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,50 @@
+subroutine foldms(s2,msglen,nchar,mycall,msg,msg29)
+
+! Fold the 2-d &quot;goodness of fit&quot; array s2 modulo message length, 
+! then decode the folded message.
+
+  real s2(0:63,400)
+  real fs2(0:63,29)
+  integer nfs2(29)
+  character mycall*12
+  character msg*400,msg29*29
+  character cc*64
+!                    1         2         3         4         5         6
+!          0123456789012345678901234567890123456789012345678901234567890123
+  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ./?-                 _     @'/
+
+  fs2=0.
+  nfs2=0
+  do j=1,nchar                           !Fold s2 into fs2, modulo msglen
+     jj=mod(j-1,msglen)+1
+     nfs2(jj)=nfs2(jj)+1
+     do i=0,40
+        fs2(i,jj)=fs2(i,jj) + s2(i,j)
+     enddo
+  enddo
+
+  msg=' '
+  do j=1,msglen
+     smax=0.
+     do k=0,40
+        if(fs2(k,j).gt.smax) then
+           smax=fs2(k,j)
+           kpk=k
+        endif
+     enddo
+     if(kpk.eq.40) kpk=57
+     msg(j:j)=cc(kpk+1:kpk+1)
+     if(kpk.eq.57) msg(j:j)=' '
+  enddo
+
+  msg29=msg(1:msglen)
+
+  call alignmsg('  ',2,msg29,msglen,idone)
+  if(idone.eq.0) call alignmsg('CQ',  3,msg29,msglen,idone)
+  if(idone.eq.0) call alignmsg('QRZ', 3,msg29,msglen,idone)
+  if(idone.eq.0) call alignmsg(mycall,4,msg29,msglen,idone)
+  if(idone.eq.0) call alignmsg(' ',   1,msg29,msglen,idone)
+  msg29=adjustl(msg29)
+
+  return
+end subroutine foldms

Deleted: trunk/four2a.f
===================================================================
--- trunk/four2a.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/four2a.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,95 +0,0 @@
-      subroutine four2a(a,nfft,ndim,isign,iform)
-
-C     IFORM = 1, 0 or -1, as data is
-C     complex, real, or the first half of a complex array.  Transform
-C     values are returned in array DATA.  They are complex, real, or
-C     the first half of a complex array, as IFORM = 1, -1 or 0.
-
-C     The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
-C     by ... will be returned in the same array, now considered to
-C     be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
-C     IFORM = 0 or -1, N(1) must be even, and enough room must be
-C     reserved.  The missing values may be obtained by complex conjuga-
-C     tion.  
-
-C     The reverse transformation of a half complex array dimensioned
-C     N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
-C     to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
-C     The transform will be real and returned to the input array.
-
-      parameter (NPMAX=100)
-      parameter (NSMALL=16384)
-      complex a(nfft)
-      complex aa(NSMALL)
-      integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
-      real*8 plan(NPMAX)             !Actually should be i*8, but no matter
-      data nplan/0/
-      include 'fftw3.f'
-      save plan,nplan,nn,ns,nf,nl
-
-      if(nfft.lt.0) go to 999
-
-      nloc=loc(a)
-      do i=1,nplan
-         if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.
-     +      iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
-      enddo
-      if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
-      nplan=nplan+1
-      i=nplan
-      nn(i)=nfft
-      ns(i)=isign
-      nf(i)=iform
-      nl(i)=nloc
-
-C  Planning: FFTW_ESTIMATE, FFTW_ESTIMATE_PATIENT, FFTW_MEASURE, 
-C            FFTW_PATIENT,  FFTW_EXHAUSTIVE
-      npatience=1
-      nflags=FFTW_ESTIMATE
-      if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
-      if(npatience.eq.2) nflags=FFTW_MEASURE
-      if(npatience.eq.3) nflags=FFTW_PATIENT
-      if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
-      if(nfft.le.NSMALL) then
-         jz=nfft
-         if(iform.eq.0) jz=nfft/2
-         do j=1,jz
-            aa(j)=a(j)
-         enddo
-      endif
-!      call sleep_msec(0)
-      if(isign.eq.-1 .and. iform.eq.1) then
-         call sfftw_plan_dft_1d_(plan(i),nfft,a,a,
-     +        FFTW_FORWARD,nflags)
-      else if(isign.eq.1 .and. iform.eq.1) then
-         call sfftw_plan_dft_1d_(plan(i),nfft,a,a,
-     +        FFTW_BACKWARD,nflags)
-      else if(isign.eq.-1 .and. iform.eq.0) then
-         call sfftw_plan_dft_r2c_1d_(plan(i),nfft,a,a,nflags)
-      else if(isign.eq.1 .and. iform.eq.-1) then
-         call sfftw_plan_dft_c2r_1d_(plan(i),nfft,a,a,nflags)
-      else
-         stop 'Unsupported request in four2a'
-      endif
-!      call sleep_msec(0)
-      i=nplan
-      if(nfft.le.NSMALL) then
-         jz=nfft
-         if(iform.eq.0) jz=nfft/2
-         do j=1,jz
-            a(j)=aa(j)
-         enddo
-      endif
-
- 10   continue
-!      call sleep_msec(0)
-      call sfftw_execute_(plan(i))
-!      call sleep_msec(0)
-      return
-
- 999  do i=1,nplan
-         call sfftw_destroy_plan_(plan(i))
-      enddo
-
-      return
-      end

Copied: trunk/four2a.f90 (from rev 2228, wsjt7a/four2a.f90)
===================================================================
--- trunk/four2a.f90	                        (rev 0)
+++ trunk/four2a.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,101 @@
+subroutine four2a(a,nfft,ndim,isign,iform)
+
+! IFORM = 1, 0 or -1, as data is
+! complex, real, or the first half of a complex array.  Transform
+! values are returned in array DATA.  They are complex, real, or
+! the first half of a complex array, as IFORM = 1, -1 or 0.
+
+! The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
+! by ... will be returned in the same array, now considered to
+! be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
+! IFORM = 0 or -1, N(1) must be even, and enough room must be
+! reserved.  The missing values may be obtained by complex conjugation.  
+
+! The reverse transformation of a half complex array dimensioned
+! N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
+! to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
+! The transform will be real and returned to the input array.
+
+  parameter (NPMAX=200)
+  parameter (NSMALL=16384)
+  complex a(nfft)
+  complex aa(NSMALL)
+  integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
+  integer*8 plan(NPMAX)             !Actually should be i*8, but no matter
+  data nplan/0/
+  include 'fftw3.f'
+  save plan,nplan,nn,ns,nf,nl
+
+  if(nfft.lt.0 .or. ndim.lt.1) go to 999
+
+  nloc=loc(a)
+  do i=1,nplan
+     if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.                     &amp;
+          iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
+  enddo
+  if(nplan.ge.NPMAX) go to 999
+  nplan=nplan+1
+  i=nplan
+  nn(i)=nfft
+  ns(i)=isign
+  nf(i)=iform
+  nl(i)=nloc
+
+! Planning: FFTW_ESTIMATE, FFTW_ESTIMATE_PATIENT, FFTW_MEASURE, 
+!            FFTW_PATIENT,  FFTW_EXHAUSTIVE
+  npatience=1
+  nflags=FFTW_ESTIMATE
+  if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
+  if(npatience.eq.2) nflags=FFTW_MEASURE
+  if(npatience.eq.3) nflags=FFTW_PATIENT
+  if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
+  call cs_lock('four2a')
+
+  if(nfft.le.NSMALL) then
+     jz=nfft
+     if(iform.eq.0) jz=nfft/2
+     do j=1,jz
+        aa(j)=a(j)
+     enddo
+  endif
+
+  if(isign.eq.-1 .and. iform.eq.1) then
+     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_FORWARD,nflags)
+  else if(isign.eq.1 .and. iform.eq.1) then
+     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_BACKWARD,nflags)
+  else if(isign.eq.-1 .and. iform.eq.0) then
+     call sfftw_plan_dft_r2c_1d(plan(i),nfft,a,a,nflags)
+  else if(isign.eq.1 .and. iform.eq.-1) then
+     call sfftw_plan_dft_c2r_1d(plan(i),nfft,a,a,nflags)
+  else
+     stop 'Unsupported request in four2a'
+  endif
+  i=nplan
+  if(nfft.le.NSMALL) then
+     jz=nfft
+     if(iform.eq.0) jz=nfft/2
+     do j=1,jz
+        a(j)=aa(j)
+     enddo
+  endif
+
+10 continue
+  call sfftw_execute(plan(i))
+  call cs_unlock
+  return
+
+999 do i=1,nplan
+     call sfftw_destroy_plan(plan(i))
+  enddo
+  if(ndim.lt.0 .or. nplan.ge.NPMAX) then
+     open(24,file='FFT_plans.txt',status='unknown')
+     do i=1,nplan
+        write(24,1999) i,nn(i),ns(i),nf(i),nl(i)
+1999    format(5i10,2x)
+     enddo
+     call flush(24)
+     if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
+  endif
+
+  return
+end subroutine four2a

Copied: trunk/four2b.f90 (from rev 2228, wsjt7a/four2b.f90)
===================================================================
--- trunk/four2b.f90	                        (rev 0)
+++ trunk/four2b.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,93 @@
+subroutine four2a(a,nfft,ndim,isign,iform)
+
+! IFORM = 1, 0 or -1, as data is
+! complex, real, or the first half of a complex array.  Transform
+! values are returned in array DATA.  They are complex, real, or
+! the first half of a complex array, as IFORM = 1, -1 or 0.
+
+! The transform of a real array (IFORM = 0) dimensioned N(1) by N(2)
+! by ... will be returned in the same array, now considered to
+! be complex of dimensions N(1)/2+1 by N(2) by ....  Note that if
+! IFORM = 0 or -1, N(1) must be even, and enough room must be
+! reserved.  The missing values may be obtained by complex conjuga-
+! tion.  
+
+! The reverse transformation of a half complex array dimensioned
+! N(1)/2+1 by N(2) by ..., is accomplished by setting IFORM
+! to -1.  In the N array, N(1) must be the true N(1), not N(1)/2+1.
+! The transform will be real and returned to the input array.
+
+  parameter (NPMAX=100)
+  parameter (NSMALL=16384)
+  complex a(nfft)
+  complex aa(NSMALL)
+  integer nn(NPMAX),ns(NPMAX),nf(NPMAX),nl(NPMAX)
+  real*8 plan(NPMAX)             !Actually should be i*8, but no matter
+  data nplan/0/
+  include 'fftw3.f'
+  save plan,nplan,nn,ns,nf,nl
+
+  if(nfft.lt.0) go to 999
+
+  nloc=loc(a)
+  do i=1,nplan
+     if(nfft.eq.nn(i) .and. isign.eq.ns(i) .and.                         &amp;
+          iform.eq.nf(i) .and. nloc.eq.nl(i)) go to 10
+  enddo
+  if(nplan.ge.NPMAX) stop 'Too many FFTW plans requested.'
+  nplan=nplan+1
+  i=nplan
+  nn(i)=nfft
+  ns(i)=isign
+  nf(i)=iform
+  nl(i)=nloc
+
+! Planning: FFTW_ESTIMATE, FFTW_ESTIMATE_PATIENT, FFTW_MEASURE, 
+!           FFTW_PATIENT,  FFTW_EXHAUSTIVE
+  npatience=1
+  nflags=FFTW_ESTIMATE
+  if(npatience.eq.1) nflags=FFTW_ESTIMATE_PATIENT
+  if(npatience.eq.2) nflags=FFTW_MEASURE
+  if(npatience.eq.3) nflags=FFTW_PATIENT
+  if(npatience.eq.4) nflags=FFTW_EXHAUSTIVE
+  if(nfft.le.NSMALL) then
+     jz=nfft
+     if(iform.eq.0) jz=nfft/2
+     do j=1,jz
+        aa(j)=a(j)
+     enddo
+  endif
+!      call sleep_msec(0)
+  if(isign.eq.-1 .and. iform.eq.1) then
+     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_FORWARD,nflags)
+  else if(isign.eq.1 .and. iform.eq.1) then
+     call sfftw_plan_dft_1d(plan(i),nfft,a,a,FFTW_BACKWARD,nflags)
+  else if(isign.eq.-1 .and. iform.eq.0) then
+     call sfftw_plan_dft_r2c_1d(plan(i),nfft,a,a,nflags)
+  else if(isign.eq.1 .and. iform.eq.-1) then
+     call sfftw_plan_dft_c2r_1d(plan(i),nfft,a,a,nflags)
+  else
+     stop 'Unsupported request in four2a'
+  endif
+!      call sleep_msec(0)
+  i=nplan
+  if(nfft.le.NSMALL) then
+     jz=nfft
+     if(iform.eq.0) jz=nfft/2
+     do j=1,jz
+        a(j)=aa(j)
+     enddo
+  endif
+
+10 continue
+!      call sleep_msec(0)
+  call sfftw_execute(plan(i))
+!      call sleep_msec(0)
+  return
+
+999 do i=1,nplan
+     call sfftw_destroy_plan(plan(i))
+  enddo
+
+  return
+end subroutine four2a

Deleted: trunk/ftn_init.F90
===================================================================
--- trunk/ftn_init.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/ftn_init.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,130 +0,0 @@
-! Fortran logical units used in WSJT6
-!
-!   10  wave files read from disk
-!   11  decoded.txt
-!   12  decoded.ave
-!   13  tsky.dat
-!   14  azel.dat
-!   15  debug.txt
-!   16  c:/wsjt.reg 
-!   17  wave files written to disk
-!   18  test file to be transmitted (wsjtgen.f90)
-!   19  dmet_* files
-!   20  prefixes.txt
-!   21  ALL.TXT
-!   22  kvasd.dat
-!   23  CALL3.TXT
-
-!------------------------------------------------ ftn_init
-subroutine ftn_init
-!f2py threadsafe
-
-  character*1 fname*80
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  include 'gcom4.f90'
-  character*12 csub0
-  integer*8 mtx
-  integer*2 nsky
-  common/sky/ nsky(360,180)
-  common/mtxcom/mtx,ltrace,mtxstate,csub0
-
-  call cs_init
-  call cs_lock('ftn_init')
-  i=ptt(nport,pttport,0,iptt)                       !Clear the PTT line
-  addpfx='    '
-
-  do i=80,1,-1
-     if(AppDir(i:i).ne.' ') goto 1
-  enddo
-1 iz=i
-  lenappdir=iz
-  call pfxdump(appdir(:iz)//'/prefixes.txt')
-
-#ifdef CVF
-  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
-       share='denynone',err=910)
-#else
-  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
-       err=910)
-#endif
-  endfile 11
-
-#ifdef CVF
-  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
-       share='denynone',err=920)
-#else
-  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
-       err=920)
-#endif
-  endfile 12
-
-#ifdef CVF
-  open(14,file=appdir(:iz)//'/azel.dat',status='unknown',                 &amp;
-       share='denynone',err=930)
-#else
-  open(14,file=appdir(:iz)//'/azel.dat',status='unknown',                 &amp;
-       err=930)
-#endif
-
-#ifdef CVF
-  open(15,file=appdir(:iz)//'/debug.txt',status='unknown',                 &amp;
-       share='denynone',err=940)
-#else
-  open(15,file=appdir(:iz)//'/debug.txt',status='unknown',                 &amp;
-       err=940)
-#endif
-
-#ifdef CVF
-  open(21,file=appdir(:iz)//'/ALL.TXT',status='unknown',                   &amp;
-       access='append',share='denynone',err=950)
-#else
-  open(21,file=appdir(:iz)//'/ALL.TXT',status='unknown',                   &amp;
-       position='append',err=950)
-#endif
-
-#ifdef CVF
-  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
-       status='unknown',share='denynone')
-#else
-  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
-       status='unknown')
-#endif
-
-  call zero(nsky,180*180)
-  fname=appdir(:iz)//'/TSKY.DAT'
-#ifdef CVF
-  open(13,file=fname,status='old',form='binary',err=10)
-  read(13) nsky
-  close(13)
-#else
-  call rfile2(fname,nsky,129600,nr)
-  if(nr.ne.129600) go to 10
-  nsky4=nsky(1,1)
-  if (iabs(nsky4).gt.500) then
-     write(*,1000)
-1000 format('Converting TSKY.DAT')
-     do i=1,360
-        do j=1,180
-           nsky(i,j) = iswap_short(nsky(i,j))
-        enddo
-     enddo
-  endif
-#endif
-
-10 call cs_unlock
-  return
-
-910 print*,'Error opening DECODED.TXT'
-  stop
-920 print*,'Error opening DECODED.AVE'
-  stop
-930 print*,'Error opening azel.dat'
-  stop
-940 print*,'Error opening DEBUG.TXT'
-  stop
-950 print*,'Error opening ALL.TXT'
-  stop
-
-end subroutine ftn_init

Copied: trunk/ftn_init.f90 (from rev 2228, wsjt7a/ftn_init.f90)
===================================================================
--- trunk/ftn_init.f90	                        (rev 0)
+++ trunk/ftn_init.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,93 @@
+! Fortran logical units used in WSJT6
+!
+!   10  wave files read from disk
+!   11  decoded.txt
+!   12  decoded.ave
+!   13  tsky.dat
+!   14  azel.dat
+!   15  debug.txt
+!   16  c:/wsjt.reg 
+!   17  wave files written to disk
+!   18  test file to be transmitted (wsjtgen.f90)
+!   19  dmet_* files
+!   20  prefixes.txt
+!   21  ALL.TXT
+!   22  kvasd.dat
+!   23  CALL3.TXT
+!   24  FFT_plans.txt
+!   25  *.eco
+
+!------------------------------------------------ ftn_init
+subroutine ftn_init
+!f2py threadsafe
+
+  character*1 fname*80
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  include 'gcom4.f90'
+  character*12 csub0
+  integer*8 mtx
+  integer*2 nsky
+  common/sky/ nsky(360,180)
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+
+  call cs_init
+  call cs_lock('ftn_init')
+  i=ptt(nport,pttport,0,1,iptt)                       !Clear DTR line
+  i=ptt(nport,pttport,0,0,iptt)                       !Clear RTS line
+  addpfx='    '
+
+  do i=80,1,-1
+     if(AppDir(i:i).ne.' ') goto 1
+  enddo
+1 iz=i
+  lenappdir=iz
+  call pfxdump(appdir(:iz)//'/prefixes.txt')
+
+  open(11,file=appdir(:iz)//'/decoded.txt',status='unknown',               &amp;
+       err=910)
+  endfile 11
+
+  open(12,file=appdir(:iz)//'/decoded.ave',status='unknown',               &amp;
+       err=920)
+  endfile 12
+
+  open(15,file=appdir(:iz)//'/debug.txt',status='unknown',                 &amp;
+       err=940)
+
+  open(21,file=appdir(:iz)//'/ALL.TXT',status='unknown',                   &amp;
+       position='append',err=950)
+
+  open(22,file=appdir(:iz)//'/kvasd.dat',access='direct',recl=1024,        &amp;
+       status='unknown')
+
+  call zero(nsky,180*180)
+  fname=appdir(:iz)//'/TSKY.DAT'
+
+  call rfile2(fname,nsky,129600,nr)
+  if(nr.ne.129600) go to 10
+  nsky4=nsky(1,1)
+  if (iabs(nsky4).gt.500) then
+     write(*,1000)
+1000 format('Converting TSKY.DAT')
+     do i=1,360
+        do j=1,180
+           nsky(i,j) = iswap_short(nsky(i,j))
+        enddo
+     enddo
+  endif
+
+10 call cs_unlock
+  return
+
+910 print*,'Error opening DECODED.TXT'
+  stop
+920 print*,'Error opening DECODED.AVE'
+  stop
+940 print*,'Error opening DEBUG.TXT'
+  stop
+950 print*,'Error opening ALL.TXT'
+  stop
+
+end subroutine ftn_init

Modified: trunk/ftn_quit.f90
===================================================================
--- trunk/ftn_quit.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/ftn_quit.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,7 +1,6 @@
 subroutine ftn_quit
 !f2py threadsafe
-  call four2a(a,-1,1,1,1)
-  call filbig2(dat,-1,f0,newdat2,c4a,n4)
+  call four2a(a,-1,-1,1,1)
   call cs_destroy
   return
 end subroutine ftn_quit

Modified: trunk/gcom2.f90
===================================================================
--- trunk/gcom2.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/gcom2.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,12 +1,14 @@
 ! Variable             Purpose                              Set in Thread
 !-------------------------------------------------------------------------
-real ps0               !Spectrum of best ping, FSK441/JT6m      Decoder
+real ps0               !Spectrum of best ping, FSK441/JTMS      Decoder
 real psavg             !Average spectrum                        Decoder
 real s2                !2d spectrum for horizontal waterfall    GUI
 real ccf               !CCF in time (blue curve)                Decoder
 real green             !Data for green line                     GUI
 integer ngreen         !Length of green                         GUI
 real dgain             !Digital audio gain setting              GUI
+real dlatency          !Differential Tx/Rx latency              GUI
+real fecho             !Audio tone for echo test                Decoder
 integer iter           !(why is this here??)
 integer iyr            !UTC from python                         GUI
 integer imo            !UTC from python                         GUI
@@ -14,14 +16,19 @@
 integer ndecoding      !Decoder status (see decode2.f90)     GUI,Decoder
 integer ndecoding0     !Status on previous decode            GUI,Decoder
 integer mousebutton    !Which button was clicked?               GUI
-integer nhighpri       !Run at &quot;Above Normal&quot; priority?         GUI
 integer ndecdone       !Is decoder finished?                 GUI,Decoder
 integer npingtime      !Time in file of mouse-selected ping  GUI,Decoder
+integer ntc            !Time constand for echo averaging (m)    GUI
+integer necho          !0 for CW, 1 for 27x27 Costas            GUI
+integer nfrit          !RIT setting for Echo mode (Hz)          GUI
+integer ndither        !Dither range for Echo mode (Hz)         GUI
+integer nsumecho       !Number of echo transmissions avgd       GUI
 integer ierr           !(why is this here?)
 integer lauto          !Are we in Auto mode?                    GUI
 integer mantx          !Manual transmission requested?       GUI,SoundIn
 integer nrestart       !True if transmission should restart  GUI,SoundIn
 integer ntr            !Are we in 2nd sequence?                 SoundIn
+integer ntxboth        !Transmit both sequqnces?                GUI
 integer nmsg           !Length of Tx message                    SoundIn
 integer nsave          !Which files to save?                    GUI
 integer nadd5          !Prepend 5 sec of 0's before decoding?   GUI 
@@ -33,25 +40,23 @@
 integer nsavecum       !(why is this here?)
 integer minsigdb       !Decoder threshold setting               GUI
 integer nclearave      !Set to 1 to clear JT65 avg         GUI,Decoder
-integer newdat2        !Set to 1 when new WSPR data           Decoder
 integer nfreeze        !Is Freeze checked?                      GUI
 integer nafc           !Is AFC checked?                         GUI
 integer nmode          !Which WSJT mode?                   GUI,Decoder
 integer mode65         !JT65 sub-mode (A/B/C ==&gt; 1/2/4) GUI,SoundIn,Decoder
 integer mode4          !JT4 sub-mode (A-G)              GUI,SoundIn,Decoder
-integer nclip          !Clipping level                          GUI
 integer ndebug         !Write debugging info?                   GUI
-integer nblank         !Is NB checked?                          GUI
 integer nfmid          !Center frequency of main display        GUI
 integer nforce         !Force decoding of questionable data  GUI,Decoder
 integer nfrange        !Frequency range of main display         GUI
 integer nport          !Requested COM port number               GUI
+integer ndtr           !DTR=1, RTS=0                            GUI
 integer mousedf        !Mouse-selected freq offset, DF          GUI
 integer neme           !EME calls only in deep search?          GUI
 integer nsked          !Sked mode for deep search?              GUI
 integer naggressive    !Is &quot;Aggressive decoding&quot; checked?       GUI
 integer ntx2           !Is &quot;No shorthands if Tx1&quot; checked?      GUI
-integer nslim2         !2nd Decoder threshold for FSK441. JT6M  GUI
+integer nslim2         !2nd Decoder threshold for FSK441        GUI
 integer nagain         !Decode same file again?                 GUI
 integer nsavelast      !Save last file?                         GUI
 integer ntxdf          !Tx frequency offset                     GUI
@@ -75,7 +80,6 @@
 integer ntxreq         !Tx msg# requested                       GUI
 integer ntxnow         !Tx msg# being sent now                  GUI
 integer ndepth         !Requested &quot;depth&quot; of JT65 decoding      GUI
-integer ndwspr         !Requested &quot;depth&quot; of WSPR decoding      GUI
 integer nspecial       !JT65 shorthand msg#: RO=2 RRR=3 73=4    Decoder
 integer ndf            !Measured DF in Hz                       Decoder
 real ss1               !Magenta curve for JT65 shorthand msg    Decoder
@@ -98,18 +102,19 @@
 character*80 pttport
 character*22 t0msg
 
-parameter (ND2MAX=120*12000)
+parameter (ND2MAX=120*11025)
 common/gcom2/ps0(431),psavg(450),s2(64,3100),ccf(-5:540),             &amp;
-     green(500),ngreen,dgain,iter,iyr,imo,ida,                        &amp;
-     ndecoding,ndecoding0,mousebutton,nhighpri,                       &amp;
-     ndecdone,npingtime,ierr,lauto,mantx,nrestart,ntr,nmsg,nsave,nadd5, &amp;
-     dftolerance,LDecoded,rxdone,monitoring,nzap,nsavecum,minsigdb,   &amp;
-     nclearave,newdat2,nfreeze,nafc,nmode,mode65,mode4,nclip,ndebug,  &amp;
-     nblank,nport,   &amp;
-     mousedf,neme,nsked,naggressive,ntx2,nslim2,nagain,nsavelast,ntxdf, &amp;
+     green(500),ngreen,dgain,dlatency,fecho,iter,iyr,imo,ida,         &amp;
+     ndecoding,ndecoding0,mousebutton,ntc,necho,nfrit,ndither,        &amp;
+     nsumecho,ndecdone,npingtime,ierr,lauto,mantx,nrestart,ntr,       &amp;
+     ntxboth,nmsg,                                                    &amp;
+     nsave,nadd5,dftolerance,LDecoded,rxdone,monitoring,nzap,         &amp;
+     nsavecum,minsigdb,nclearave,newdat2,nfreeze,nafc,nmode,mode65,   &amp;
+     mode4,ndebug,nport,ndtr,mousedf,                                 &amp;
+     neme,nsked,naggressive,ntx2,nslim2,nagain,nsavelast,ntxdf,       &amp;
      shok,sendingsh,d2a(ND2MAX),d2b(ND2MAX),b(60000),jza,jzb,ntime,   &amp;
      idinterval,msmax,lenappdir,idf,ndiskdat,nfsam,nlines,nflat,      &amp;
-     ntdecode,ntxreq,ntxnow,nchallenge,ndepth,ndwspr,nspecial,ndf,    &amp;
+     ntdecode,ntxreq,ntxnow,nchallenge,ndepth,nspecial,ndf,           &amp;
      nfmid,nforce,nfrange,ss1(-224:224),ss2(-224:224),                &amp;
      mycall,hiscall,hisgrid,txmsg,sending,mode,fname0,fnamea,         &amp;
      fnameb,decodedfile,AppDir,AzElDir,filetokilla,filetokillb,       &amp;

Modified: trunk/gcom4.f90
===================================================================
--- trunk/gcom4.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/gcom4.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -5,7 +5,7 @@
 integer jzc            !Length of data available in d2c          GUI
 character filename*24  !Name of wave file read from disk         GUI
 
-parameter (ND2CMAX=120*12000)
+parameter (ND2CMAX=120*11025)
 common/gcom4/addpfx,d2c(ND2CMAX),jzc,filename
 
 !### volatile /gcom4/

Modified: trunk/gen24.f
===================================================================
--- trunk/gen24.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/gen24.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,13 +1,12 @@
-      subroutine gen24(message,mode,mode4,samfac,ntxdf,ndebug,
-     +    iwave,nwave,sendingsh,msgsent,nmsg)
+      subroutine gen24(message,mode4,samfac,ntxdf,iwave,nwave,
+     +  sendingsh,msgsent,nmsg)
 
-C  Encodes a JT2 or JT4 message into a wavefile.
+C  Encode a JT4 message into a wavefile.
 
       parameter (NMAX=60*11025)     !Max length of wave file
       character*22 message          !Message to be generated
       character*22 msgsent          !Message as it will be received
       character*3 cok               !'   ' or 'OOO'
-      character*6 mode
       real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,samfac,tsymbol
       integer*2 iwave(NMAX)         !Generated wave file
       integer sendingsh
@@ -38,16 +37,8 @@
       symbol(1)=0                            !Reference phase
       sendingsh=0
       if(iand(dgen(10),8).ne.0) sendingsh=-1 !Plain text flag
-      call interleave24(symbol(2),1)         !Apply JT2/JT4 interleaving
+      call interleave24(symbol(2),1)         !Apply JT4 interleaving
 
-      if(ndebug.ne.0) then
-         rewind 51
-         do i=1,nsym
-            write(51,3001) i,symbol(i),npr2(i),npr2(i)+2*symbol(i)
- 3001       format(4i5)
-         enddo
-      endif
-
 C  Set up necessary constants
       tsymbol=2520.d0/11025.d0
       dt=1.d0/(samfac*11025.d0)
@@ -58,39 +49,19 @@
       j0=0
       ndata=(nsym*11025.d0*samfac*tsymbol)/2
       ndata=2*ndata
-      if(mode(1:3).eq.'JT2') then                 !JT2 mode
-         ss=1.0
-         s=0.0
-         u=0.04
-         do i=1,ndata
-            t=t+dt
-            j=int(t/tsymbol) + 1                  !Symbol number, 1-207
-            if(j.ne.j0) then
-               f=f0 + npr2(j)*dfgen
-               if(flip.lt.0.0) f=f0 + (1-npr2(j))*dfgen
-               dphi=twopi*dt*f
-               if(symbol(j).gt.0) ss=-ss
-               j0=j
-            endif
-            phi=phi+dphi
-            s=s + u*(ss-s)
-            iwave(i)=32767.0 * s * sin(phi)
-         enddo
-      else                                        !JT4x mode
-         do i=1,ndata
-            t=t+dt
-            j=int(t/tsymbol) + 1                  !Symbol number, 1-207
-            if(j.ne.j0) then
-               f=f0 + (npr2(j)+2*symbol(j)-1.5) * dfgen * mode4
-               if(flip.lt.0.0) 
-     +              f=f0+((1-npr2(j))+2*symbol(j)-1.5)*dfgen*mode4
-               dphi=twopi*dt*f
-               j0=j
-            endif
-            phi=phi+dphi
-            iwave(i)=32767.0*sin(phi)
-         enddo
-      endif
+      do i=1,ndata
+         t=t+dt
+         j=int(t/tsymbol) + 1   !Symbol number, 1-207
+         if(j.ne.j0) then
+            f=f0 + (npr2(j)+2*symbol(j)-1.5) * dfgen * mode4
+            if(flip.lt.0.0) 
+     +           f=f0+((1-npr2(j))+2*symbol(j)-1.5)*dfgen*mode4
+            dphi=twopi*dt*f
+            j0=j
+         endif
+         phi=phi+dphi
+         iwave(i)=32767.0*sin(phi)
+      enddo
 
       do j=1,5512                !Put another 0.5 sec of silence at end
          i=i+1

Copied: trunk/gen441.f90 (from rev 2228, wsjt7a/gen441.f90)
===================================================================
--- trunk/gen441.f90	                        (rev 0)
+++ trunk/gen441.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,24 @@
+subroutine gen441(itone,ndits,cfrag)
+
+  integer itone(84)
+  complex cfrag(2100)
+
+! Generate iwave
+  twopi=8*atan(1.0)
+  dt=1.0/11025.0
+  k=0
+  NSPD=25
+  df=11025.0/NSPD
+  pha=0.
+  do m=1,ndits
+     freq=(itone(m)+1)*df
+     dpha=twopi*freq*dt
+     do i=1,NSPD
+        k=k+1
+        pha=pha+dpha
+        cfrag(k)=cmplx(cos(pha),-sin(pha))
+     enddo
+  enddo
+
+  return
+end subroutine gen441

Deleted: trunk/gen64.f90
===================================================================
--- trunk/gen64.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/gen64.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,103 +0,0 @@
-subroutine gen64(message,mode64,samfac,ntxdf,iwave,nwave,  &amp;
-     sendingsh,msgsent,nmsg)
-
-! Encodes a JT64 message into a wavefile.
-
-  parameter (NMAX=60*11025)     !Max length of wave file
-  character*22 message          !Message to be generated
-  character*22 msgsent          !Message as it will be received
-  real*8 t,dt,phi,f,f0,dfgen,dphi,twopi,samfac,tsymbol
-  integer*2 iwave(NMAX)  !Generated wave file
-  integer sent(63)
-  integer sendingsh
-  integer ic6(6)
-  integer isync(63)
-  data ic6/0,1,4,3,5,2/,idum/-1/
-  data twopi/6.283185307d0/
-  save
-
-! Set up the JT64 sync pattern
-! Insert the 6x6 Costas array 3 times at low-frequency edge.
-  isync=-1
-  do n=1,3
-     i0=0
-     if(n.eq.2) i0=28
-     if(n.eq.3) i0=57
-     do i=1,6
-        isync(i0+i)=ic6(i)
-     enddo
-  enddo
-
-  nspecial=0
-  if(nspecial.eq.0) then
-!         call wqencode(message,ntype,data0)
-
-! Must do rs_init for RS(45,9)
-!         call rs_encode(dgen,sent)
-
-! Temporary: correct sync plus random data
-     do i=1,63
-        if(isync(i).lt.0) then
-           call random_number(x)
-           sent(i)=63.99999*x
-        else
-           sent(i)=isync(i)
-        endif
-     enddo
-
-     tsymbol=8192.d0/11025.d0
-     nsym=63                            !Symbols per transmission
-  else
-     tsymbol=16384.d0/11025.d0
-     nsym=32
-     sendingsh=1                         !Flag for shorthand message
-  endif
-
-! Set up necessary constants
-  dt=1.0/(samfac*11025.0)
-  f0=118*11025.d0/1024 + ntxdf
-  dfgen=mode64*11025.0/4096.0
-  t=0.d0
-  phi=0.d0
-  k=0
-  j0=0
-  ndata=(nsym*11025.d0*samfac*tsymbol)/2
-  ndata=2*ndata
-  do i=1,ndata
-     t=t+dt
-     j=int(t/tsymbol) + 1                    !Symbol number, 1-63
-     if(j.ne.j0) then
-        f=f0
-        if(nspecial.ne.0) f=f0+10*nspecial*dfgen
-        if(nspecial.eq.0) then
-           k=k+1
-           f=f0+(sent(k))*dfgen
-        endif
-        dphi=twopi*dt*f
-        j0=j
-     endif
-     phi=phi+dphi
-     iwave(i)=32767.0*sin(phi)
-  enddo
-
-  do j=1,5512                !Put another 0.5 sec of silence at end
-     i=i+1
-     iwave(i)=0
-  enddo
-  nwave=i
-!      call unpackmsg(dgen,msgsent)
-!      if(flip.lt.0.0) then
-!         do i=22,1,-1
-!            if(msgsent(i:i).ne.' ') goto 10
-!         enddo
-! 10      msgsent=msgsent(1:i)//' OOO'
-!      endif
-  msgsent=message
-  do i=22,1,-1
-     if(msgsent(i:i).ne.' ') goto 20
-  enddo
-20 nmsg=i
-
-  return
-end subroutine gen64
-

Modified: trunk/gen65.f
===================================================================
--- trunk/gen65.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/gen65.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,4 +1,4 @@
-      subroutine gen65(message,mode65,samfac,ntxdf,ndebug,iwave,nwave,
+      subroutine gen65(message,mode65,samfac,ntxdf,iwave,nwave,
      +  sendingsh,msgsent,nmsg)
 
 C  Encodes a JT65 message into a wavefile.
@@ -29,11 +29,6 @@
          call rs_encode(dgen,sent)
          call interleave63(sent,1)           !Apply interleaving
          call graycode(sent,63,1)            !Apply Gray code
-         if(ndebug.ne.0) then
-            rewind 51
-            write(51,1050) sent
- 1050       format('Channel symbols, including FEC:'/(i5,20i3))
-         endif
          tsymbol=4096.d0/11025.d0
          nsym=126                            !Symbols per transmission
       else

Deleted: trunk/gen6m.f
===================================================================
--- trunk/gen6m.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/gen6m.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,49 +0,0 @@
-      subroutine gen6m(msg,samfac,iwave,nwave)
-
-C  Encodes a message into a wavefile for transmitting JT6M signals.
-
-      parameter (NMAX=21504)     !NMAX=28*512*3/2: number of waveform samples
-      character*28 msg           !Message to be generated
-      real*8 samfac
-      real*4 x(NMAX)             !Data for wavefile
-      integer*2 iwave(NMAX)      !Generated wave file
-      integer*4 imsg(28)
-
-      do i=27,1,-1                           !Get message length
-         if(msg(i:i).ne.' ') go to 10
-      enddo
-      i=1
- 10   nmsg=i+1
-      if(mod(nmsg,2).eq.1) nmsg=nmsg+1       !Make it even
-
-      nwave=nmsg*512*3/2
-      do m=1,nmsg                            !Get character code numbers
-         ic=m
-         n=ichar(msg(ic:ic))
-C  Calculate i in range 0-42:
-         if(n.ge.ichar('0') .and. n.le.ichar('9')) i=n-ichar('0')
-         if(msg(ic:ic).eq.'.') i=10
-         if(msg(ic:ic).eq.',') i=11
-         if(msg(ic:ic).eq.' ') i=12
-         if(msg(ic:ic).eq.'/') i=13
-         if(msg(ic:ic).eq.'#') i=14
-         if(msg(ic:ic).eq.'?') i=15
-         if(msg(ic:ic).eq.'$') i=16
-         if(n.ge.ichar('a') .and. n.le.ichar('z')) i=n-ichar('a')+17
-         if(n.ge.ichar('A') .and. n.le.ichar('Z')) i=n-ichar('A')+17
-         imsg(m)=i
-      enddo
-
-      k=1
-      do i=1,nmsg,2
-         call gentone(x(k),-1,k,samfac)               !Generate a sync tone
-         call gentone(x(k),imsg(i),k,samfac)          !First character
-         call gentone(x(k),imsg(i+1),k,samfac)        !Second character
-      enddo
-
-      do i=1,nwave
-         iwave(i)=nint(32767.0*x(i))
-      enddo
-
-      return
-      end

Copied: trunk/gendiana.f90 (from rev 2228, wsjt7a/gendiana.f90)
===================================================================
--- trunk/gendiana.f90	                        (rev 0)
+++ trunk/gendiana.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,66 @@
+subroutine gendiana(msg,msglen,samfac,iwave,nwave,msgsent,sendingsh)
+
+! Generate waveform for Diana mode.
+
+  parameter (NMAX=30*11025,NSZ=126,NSPS=2048)
+  character msg*28,msgsent*28
+  integer*2 iwave(NMAX)
+  integer imsg(28)
+  integer itone(NSZ)
+  character c42*42
+  real*8 twopi,dt,f0,f,df,pha,dpha,samfac
+  integer isync(4)                              !Sync pattern
+  integer sendingsh
+  data isync/8,16,32,24/
+  data nsync/4/,nlen/2/,ndat/18/
+  data c42/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ /.?+-'/
+
+  twopi=8.d0*atan(1.d0)
+  df=11025.d0/NSPS                     !5.383 Hz
+  dt=1.d0/(samfac*11025.d0)
+  f0=236*df                            !1270.46 Hz
+  nsym=126                             !Total symbols in whole transmission
+
+  nblk=nsync+nlen+ndat
+  k=0
+  kk=1
+  do i=1,msglen                        !Define tone sequence for user message
+     imsg(i)=index(c42,msg(i:i))-1     !Get character index from c42
+     if(imsg(i).lt.0) imsg(i)=36       !Default char is &lt;space&gt;
+  enddo
+
+  do i=1,nsym
+     j=mod(i-1,nblk)+1
+     if(j.le.nsync) then
+        itone(i)=isync(j)
+     else if(j.gt.nsync .and. j.le.nsync+nlen) then
+        itone(i)=msglen
+        if(j.ge.nsync+2) then
+           n=msglen + 5*(j-nsync-1)
+           if(n.gt.41) n=n-42
+           itone(i)=n
+        endif
+     else
+        k=k+1
+        kk=mod(k-1,msglen)+1
+        irpt=(i-1)/nblk
+        itone(i)=mod(imsg(kk) + 7*irpt,42)
+     endif
+  enddo
+  msgsent=msg
+
+  k=0
+  pha=0.
+  do m=1,nsym                                    !Generate iwave
+     f=f0 + itone(m)*df
+     dpha=twopi*f*dt
+     do i=1,NSPS
+        k=k+1
+        pha=pha+dpha
+        iwave(k)=nint(32767.0*sin(pha))
+     enddo
+  enddo
+  nwave=k
+
+  return
+end subroutine gendiana

Copied: trunk/geniscat.f90 (from rev 2228, wsjt7a/geniscat.f90)
===================================================================
--- trunk/geniscat.f90	                        (rev 0)
+++ trunk/geniscat.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,68 @@
+subroutine geniscat(msg,nmsg,samfac,iwave,nwave,msgsent)
+
+! Generate an ISCAT_2 waveform.
+
+  parameter (NMAX=30*11025,NSZ=1291,NSPS=256)
+  character msg*28,msgsent*28
+  integer*2 iwave(NMAX)
+  integer imsg(30)
+  integer itone(NSZ)
+  character c*42
+  real*8 twopi,dt,f0,f,df,pha,dpha,samfac
+  integer icos(4)
+  data icos/0,1,3,2/
+  data nsync/4/,nlen/2/,ndat/18/
+  data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ /.?@-'/
+
+  twopi=8.d0*atan(1.d0)
+  df=11025.d0/NSPS
+  dt=1.0/(samfac*11025.0)
+  f0=13*df
+  nsym=NMAX/NSPS
+
+  nblk=nsync+nlen+ndat
+  msglen=nmsg+1
+  k=0
+  kk=1
+  imsg(1)=40
+  do i=1,nmsg                                 !Define the tone sequence
+     imsg(i+1)=36
+     do j=1,42
+        if(msg(i:i).eq.c(j:j)) imsg(i+1)=j-1
+     enddo
+  enddo
+
+  do i=1,nsym                                 !Total symbols in 30 s 
+     j=mod(i-1,nblk)+1
+     if(j.le.nsync) then
+        itone(i)=icos(j)
+     else if(j.gt.nsync .and. j.le.nsync+nlen) then
+        itone(i)=msglen
+        if(j.ge.nsync+2) then
+           n=msglen + 5*(j-nsync-1)
+           if(n.gt.41) n=n-42
+           itone(i)=n
+        endif
+     else
+        k=k+1
+        kk=mod(k-1,msglen)+1
+        itone(i)=imsg(kk)
+     endif
+  enddo
+  msgsent=msg
+
+  k=0
+  pha=0.
+  do m=1,nsym                                    !Generate iwave
+     f=f0 + itone(m)*df
+     dpha=twopi*f*dt
+     do i=1,NSPS
+        k=k+1
+        pha=pha+dpha
+        iwave(k)=nint(32767.0*sin(pha))
+     enddo
+  enddo
+  nwave=k
+
+  return
+end subroutine geniscat

Modified: trunk/genmet.f
===================================================================
--- trunk/genmet.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/genmet.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -10,10 +10,7 @@
       call cs_lock('genmet')
       bias=0.5
       scale=10
-      if(mode.eq.6) then       !JT2, DBPSK
-         open(19,file='dmet_20_-2_2.dat',status='old')
-         scale=20
-      else if(mode.eq.7) then  !Non-coherent 2FSK
+      if(mode.eq.7) then  !Non-coherent 2FSK
          open(19,file='dmet_10_-1_3.dat',status='old')
       else
          print*,'Unsupported mode:',mode,' in genmet.'

Copied: trunk/genms.f90 (from rev 2228, wsjt7a/genms.f90)
===================================================================
--- trunk/genms.f90	                        (rev 0)
+++ trunk/genms.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,92 @@
+subroutine genms(msg28,samfac,iwave,cwave,isrch,nwave)
+
+! Generate a JTMS wavefile.
+
+  parameter (NMAX=30*11025)     !Max length of wave file
+  integer*2 iwave(NMAX)         !Generated wave file
+  complex cwave(NMAX)           !Alternative for searchms
+  character*28 msg28            !User message
+  character*29 msg
+  character cc*64
+  integer sent(203)
+  real*8 dt,phi,f,f0,dfgen,dphi,twopi,foffset,samfac
+  integer np(9)
+  data np/5,7,9,11,13,17,19,23,29/  !Permissible message lengths
+!                   1         2         3         4         5         6
+!          0123456789012345678901234567890123456789012345678901234567890123
+  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ./?-                 _     @'/
+
+  msg=msg28//' '                               !Extend to 29 characters
+  do i=28,1,-1                                 !Find user's message length
+     if(msg(i:i).ne.' ') go to 1
+  enddo
+1 iz=i+1                                       !Add one for space at EOM
+  msglen=iz
+  if(isrch.ne.0) go to 3
+  do i=1,9
+     if(np(i).ge.iz) go to 2
+  enddo
+  i=8
+2 msglen=np(i)
+
+! Convert message to a bit sequence, 7 bits per character (6 + even parity)
+3  sent=0
+  k=0
+  do j=1,msglen
+     if(msg(j:j).eq.' ') then
+        i=58
+        go to 5
+     else
+        do i=1,64
+           if(msg(j:j).eq.cc(i:i)) go to 5
+        enddo
+     endif
+5    m=0
+     do n=5,0,-1                            !Each character gets 6 bits
+        k=k+1
+        sent(k)=iand(1,ishft(i-1,-n))
+        m=m+sent(k)
+     enddo
+     k=k+1
+     sent(k)=iand(m,1)                      !Insert parity bit
+  enddo
+  nsym=k
+
+ ! Set up necessary constants
+  twopi=8.d0*atan(1.d0)
+  nsps=8
+  dt=1.d0/(samfac*11025.d0)
+  f0=11025.d0/nsps                               ! 1575.0 Hz
+  dfgen=0.5d0*f0                                 !  787.5 Hz
+  foffset=1500.d0 - f0
+  t=0.d0
+  k=0
+  phi=0.d0
+  nrpt=NMAX/(nsym*nsps)
+  if(isrch.ne.0) nrpt=1
+
+  do irpt=1,nrpt
+     do j=1,nsym
+        if(sent(j).eq.1) then
+           f=f0 + 0.5d0*dfgen + foffset
+        else
+           f=f0 - 0.5d0*dfgen + foffset
+        endif
+        dphi=twopi*f*dt
+        do i=1,nsps
+           k=k+1
+           phi=phi+dphi
+           if(isrch.eq.0) then
+              iwave(k)=nint(32767.0*sin(phi))
+           else
+              cwave(k)=cmplx(cos(phi),sin(phi))
+           endif
+        enddo
+     enddo
+  enddo
+
+  if(isrch.eq.0) iwave(k+1:)=0
+  nwave=k
+
+  return
+end subroutine genms

Deleted: trunk/genwspr.f90
===================================================================
--- trunk/genwspr.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/genwspr.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,101 +0,0 @@
-subroutine genwspr(message,samfacout,ntxdf,iwave,nwave,nbad,msgsent)
-
-!  Encode a WSPR message and generate the corresponding wavefile.
-
-  parameter (NMAX=120*12000)     !Max length of wave file
-  parameter (MAXSYM=176)
-  character*22 message           !Message to be generated
-  integer*2 iwave(NMAX)          !Generated wave file
-  real*8 samfacout,fsample
-  integer*1 symbol(MAXSYM)
-  integer*1 data0(11)
-  integer npr3(162)
-  logical first
-  real*8 t,dt,phi,f,f0,dfgen,dphi,pi,twopi,tsymbol
-  character*22 msgsent           !Message sent
-  data npr3/                                    &amp;
-       1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0, &amp;
-       0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1, &amp;
-       0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1, &amp;
-       1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1, &amp;
-       0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0, &amp;
-       0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1, &amp;
-       0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1, &amp;
-       0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0, &amp;
-       0,0/
-
-  data first/.true./,idum/0/
-  save
-
-  if(first) then
-     pi=4.d0*atan(1.d0)
-     twopi=2.d0*pi
-     fsample=11025.d0
-     first=.false.
-  endif
-
-  call wqencode(message,ntype,data0)
-  nbytes=(50+31+7)/8
-  call encode232(data0,nbytes,symbol,MAXSYM)  !Convolutional encoding
-  call inter_mept(symbol,1)                   !Apply interleaving
-  call wqdecode(data0,msgsent,ntype2)
-  nbad=0
-  if(ntype2.ne.ntype .or. msgsent.ne.message) nbad=-1
-  if(ntype2.eq.ntype .and. index(msgsent,'&lt;...&gt;').gt.0) then
-     nbad=0
-     msgsent=message
-  endif
-
-  tsymbol=8192.d0/12000.d0
-  
-  dt=1.d0/(fsample*samfacout)
-  f0=1500 + ntxdf
-  dfgen=12000.d0/8192.d0                     !1.4649 Hz
-  nsigs=1
-  snrdb=99.
-  if(snrdb.eq.10.0) nsigs=10
-  nwave=111*fsample
-  if(snrdb.le.10.0) nwave=NMAX
-
-  do isig=1,nsigs
-     if(nsigs.eq.1) snr=10.0**(0.05*(snrdb-1))   !Bandwidth correction?
-     fac=3000.0
-     if(snr.gt.1.0) fac=3000.0/snr
-     if(nsigs.eq.10) then
-        snr=10.0**(0.05*(-20-isig-1))
-        f0=1390 + 20*isig
-     endif
-!     t=-2.d0 - 0.1*(isig-1)
-     t=-0.2d0
-     phi=0.d0
-     j0=0
-
-     do i=1,nwave
-        t=t+dt
-        j=int(t/tsymbol) + 1                          !Symbol number
-        sig=0.
-        if(j.ge.1 .and. j.le.162) then
-           if(j.ne.j0) then
-              f=f0 + dfgen*(npr3(j)+2*symbol(j)-1.5)
-              j0=j
-              dphi=twopi*dt*f
-           endif
-           sig=0.9999
-        endif
-        phi=phi+dphi
-        if(snrdb.gt.50.0) then
-           n=32767.0*sin(phi)           !Normal transmission, signal only
-        else
-           if(isig.eq.1) then
-              n=fac*(gran(idum) + sig*snr*sin(phi))
-           else
-              n=iwave(i) + fac*sig*snr*sin(phi)
-           endif
-           if(n.gt.32767) n=32767
-           if(n.lt.-32767) n=-32767
-        endif
-        iwave(i)=n
-     enddo
-  enddo
-  return
-end subroutine genwspr

Deleted: trunk/get_fname.F90
===================================================================
--- trunk/get_fname.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/get_fname.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,23 +0,0 @@
-subroutine get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname)
-
-  character hiscall*12,fname*24,tag*7
-  integer ntime
-
-  nsec=mod(ntime,86400)
-  ihr=nsec/3600
-  imin=mod(nsec/60,60)
-  isec=mod(nsec,60)
-  call cs_lock('get_fname')
-  write(fname,1000) iyr-2000,imo,ida,ihr,imin,isec
-1000 format('_',3i2.2,'_',3i2.2,'.WAV')
-  call cs_unlock
-  tag=hiscall(1:7)
-  i=index(hiscall,'/')
-  if(i.ge.5) tag=hiscall(1:i-1)
-  if(i.ge.2.and.i.le.4) tag=hiscall(i+1:)
-  if(hiscall(1:1).eq.' ' .or. lauto.eq.0) tag='Mon'
-  i=index(tag,' ')
-  fname=tag(1:i-1)//fname
-  
-  return
-end subroutine get_fname

Copied: trunk/get_fname.f90 (from rev 2228, wsjt7a/get_fname.f90)
===================================================================
--- trunk/get_fname.f90	                        (rev 0)
+++ trunk/get_fname.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,23 @@
+subroutine get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname)
+
+  character hiscall*12,fname*24,tag*7
+  integer ntime
+
+  nsec=mod(ntime,86400)
+  ihr=nsec/3600
+  imin=mod(nsec/60,60)
+  isec=mod(nsec,60)
+  call cs_lock('get_fname')
+  write(fname,1000) iyr-2000,imo,ida,ihr,imin,isec
+1000 format('_',3i2.2,'_',3i2.2,'.WAV')
+  call cs_unlock
+  tag=hiscall(1:7)
+  i=index(hiscall,'/')
+  if(i.ge.5) tag=hiscall(1:i-1)
+  if(i.ge.2.and.i.le.4) tag=hiscall(i+1:)
+  if(hiscall(1:1).eq.' ' .or. lauto.eq.0) tag='Mon'
+  i=index(tag,' ')
+  fname=tag(1:i-1)//fname
+  
+  return
+end subroutine get_fname

Deleted: trunk/getfile.F90
===================================================================
--- trunk/getfile.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/getfile.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,144 +0,0 @@
-subroutine getfile(fname,len)
-!f2py threadsafe
-
-#ifdef CVF
-  use dflib
-#endif
-
-  parameter (NDMAX=120*11025)
-  character*(*) fname
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom4.f90'
-
-
-  integer*1 d1(NDMAX)
-  integer*1 hdr(44)
-  integer*2 d2(NDMAX)
-  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-  character*4 ariff,awave,afmt,adata
-  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
-     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
-  equivalence (ariff,hdr),(d1,d2)
-
-1 if(ndecoding.eq.0) go to 2
-#ifdef CVF
-  call sleepqq(100)
-#else
-  call usleep(100*1000)
-#endif
-
-  go to 1
-
-2 do i=len,1,-1
-     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
-  enddo
-  i=0
-10 filename=fname(i+1:)
-  ierr=0
-
-  call cs_lock('getfile')
-#ifdef CVF
-  open(10,file=fname,form='binary',status='old',err=997)
-  read(10,end=997) hdr
-#else
-  call rfile2(fname,hdr,44+2*NDMAX,nr)
-#endif
-
-  call check_endian
-  if(nbitsam2.eq.8) then
-     if(ndata.gt.NDMAX) ndata=NDMAX
-
-#ifdef CVF
-     call rfile(10,d1,ndata,ierr)
-     if(ierr.ne.0) go to 998
-#endif
-
-     do i=1,ndata
-        n4=d1(i)
-        if (n4.lt.0) n4=256+n4
-        d2c(i)=250*(n4-128)
-     enddo
-     jzc=ndata
-
-  else if(nbitsam2.eq.16) then
-     if(ndata.gt.2*NDMAX) ndata=2*NDMAX
-#ifdef CVF
-     call rfile(10,d2c,ndata,ierr)
-     jzc=ndata/2
-     if(ierr.ne.0) go to 998
-#else
-     jzc=ndata/2
-     do i=1,jzc
-        d2c(i)=d2(i)
-     enddo
-#endif
-  endif
-
-  ndiskdat=1
-  mousebutton=0
-  close(10)
-  go to 999
-
-#ifdef CVF
-997 ierr=1001
-998 close(10)
-#endif
-
-999 call cs_unlock
-  return
-
-end subroutine getfile
-
-subroutine check_endian
-
-  parameter (NDMAX=120*11025)
-
-  integer*1 d1(NDMAX)
-  integer*1 hdr(44)
-  integer*2 d2(NDMAX)
-  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-  integer*2 iswap_short
-  character*4 ariff,awave,afmt,adata
-  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
-     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
-  equivalence (ariff,hdr),(d1,d2)
-
-  if (nfmt2.eq.1) return             ! correct endianess for this CPU
-  write(*,1000)
-1000 format('Converting file to big-endian',i10)
-  lenfile = iswap_int(lenfile)
-  lenfmt = iswap_int(lenfmt)
-  nfmt2 = iswap_short(nfmt2)
-  nchan2 = iswap_short(nchan2)
-  nsamrate = iswap_int(nsamrate)
-  nbytesec = iswap_int(nbytesec)
-  nbytesam2 = iswap_short(nbytesam2)
-  nbitsam2 = iswap_short(nbitsam2)
-  ndata = iswap_int(ndata)
-  if (nbitsam2.eq.8) return           ! header converted.   Data are bytes
-
-  do i=1,ndata/2
-    d2(i) = iswap_short(d2(i))
-  enddo
-
-
-  return
-end subroutine check_endian
-
-integer function iswap_int(idat)
-
-  itemp1 = ior(ishft(idat,24), iand(ishft(idat,8), z'00ff0000'))
-  itemp0 = ior(iand(ishft(idat,-8), z'0000ff00'), iand(ishft(idat,-24),z'000000ff'))
-  iswap_int = ior(itemp1,itemp0)
-  
-end function iswap_int
-
-integer*2 function iswap_short(idat)
-
-  integer*2 idat,m2
-  data m2/255/
-
-  iswap_short = ior(ishft(idat,8), iand(ishft(idat,-8), m2))
-
-end function iswap_short

Copied: trunk/getfile.f90 (from rev 2228, wsjt7a/getfile.f90)
===================================================================
--- trunk/getfile.f90	                        (rev 0)
+++ trunk/getfile.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,112 @@
+subroutine getfile(fname,len)
+!f2py threadsafe
+
+  parameter (NDMAX=120*11025)
+  character*(*) fname
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom4.f90'
+
+
+  integer*1 d1(NDMAX)
+  integer*1 hdr(44)
+  integer*2 d2(NDMAX)
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
+  equivalence (ariff,hdr),(d1,d2)
+
+1 if(ndecoding.eq.0) go to 2
+  call usleep(100*1000)
+
+  go to 1
+
+2 do i=len,1,-1
+     if(fname(i:i).eq.'/' .or. fname(i:i).eq.'\\') go to 10
+  enddo
+  i=0
+10 filename=fname(i+1:)
+  ierr=0
+
+  call cs_lock('getfile')
+  call rfile2(fname,hdr,44+2*NDMAX,nr)
+
+  call check_endian
+  if(nbitsam2.eq.8) then
+     if(ndata.gt.NDMAX) ndata=NDMAX
+
+     do i=1,ndata
+        n4=d1(i)
+        if (n4.lt.0) n4=256+n4
+        d2c(i)=250*(n4-128)
+     enddo
+     jzc=ndata
+
+  else if(nbitsam2.eq.16) then
+     if(ndata.gt.2*NDMAX) ndata=2*NDMAX
+     jzc=ndata/2
+     do i=1,jzc
+        d2c(i)=d2(i)
+     enddo
+  endif
+
+  ndiskdat=1
+  mousebutton=0
+  close(10)
+  call cs_unlock
+
+  return
+end subroutine getfile
+
+subroutine check_endian
+
+  parameter (NDMAX=120*11025)
+
+  integer*1 d1(NDMAX)
+  integer*1 hdr(44)
+  integer*2 d2(NDMAX)
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  integer*2 iswap_short
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,d2
+  equivalence (ariff,hdr),(d1,d2)
+
+  if (nfmt2.eq.1) return             ! correct endianess for this CPU
+!  write(*,1000)
+!1000 format('Converting file to big-endian',i10)
+  lenfile = iswap_int(lenfile)
+  lenfmt = iswap_int(lenfmt)
+  nfmt2 = iswap_short(nfmt2)
+  nchan2 = iswap_short(nchan2)
+  nsamrate = iswap_int(nsamrate)
+  nbytesec = iswap_int(nbytesec)
+  nbytesam2 = iswap_short(nbytesam2)
+  nbitsam2 = iswap_short(nbitsam2)
+  ndata = iswap_int(ndata)
+  if (nbitsam2.eq.8) return           ! header converted.   Data are bytes
+
+  do i=1,ndata/2
+    d2(i) = iswap_short(d2(i))
+  enddo
+
+  return
+end subroutine check_endian
+
+integer function iswap_int(idat)
+
+  itemp1 = ior(ishft(idat,24), iand(ishft(idat,8), z'00ff0000'))
+  itemp0 = ior(iand(ishft(idat,-8), z'0000ff00'), iand(ishft(idat,-24),z'000000ff'))
+  iswap_int = ior(itemp1,itemp0)
+  
+end function iswap_int
+
+integer*2 function iswap_short(idat)
+
+  integer*2 idat,m2
+  data m2/255/
+
+  iswap_short = ior(ishft(idat,8), iand(ishft(idat,-8), m2))
+
+end function iswap_short

Copied: trunk/gran.f90 (from rev 2228, wsjt7a/gran.f90)
===================================================================
--- trunk/gran.f90	                        (rev 0)
+++ trunk/gran.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,9 @@
+real function gran(idum)
+  real r(12)
+  if(idum.lt.0) then
+     call random_seed
+     idum=0
+  endif
+  call random_number(r)
+  gran=sum(r)-6.0
+end function gran

Deleted: trunk/hash.f90
===================================================================
--- trunk/hash.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/hash.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,15 +0,0 @@
-subroutine hash(string,len,ihash)
-
-  parameter (MASK15=32767)
-  character*(*) string
-  integer*1 ic(12)
-
-     do i=1,len
-        ic(i)=ichar(string(i:i))
-     enddo
-     i=nhash(ic,len,146)
-     ihash=iand(i,MASK15)
-
-!     print*,'C',ihash,len,string
-  return
-end subroutine hash

Copied: trunk/hipass.f90 (from rev 2228, wsjt7a/hipass.f90)
===================================================================
--- trunk/hipass.f90	                        (rev 0)
+++ trunk/hipass.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,23 @@
+subroutine hipass(y,npts,nwidth)
+
+!  Hipass filter for time-domain data.  Removes an RC-type running 
+!  mean (time constant nwidth) from array y(1:npts).  
+
+  real y(npts)
+
+  c1=1.0/nwidth
+  c2=1.0-c1
+  s=0.
+  do i=1,nwidth                      !Get initial average
+     s=s+y(i)
+  enddo
+  ave=c1*s
+
+  do i=1,npts                        !Do the filtering
+     y0=y(i)
+     y(i)=y0-ave                     !Remove the mean
+     ave=c1*y0 + c2*ave              !Update the mean
+  enddo
+
+return
+end subroutine hipass

Modified: trunk/horizspec.f90
===================================================================
--- trunk/horizspec.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/horizspec.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -48,7 +48,7 @@
      enddo
      if(nx.eq.7 .or. nx.eq.378 .or. nx.eq.750) then
 ! Put in yellow ticks at the standard tone frequencies for FSK441, or
-! at the sync-tone frequency for JT65, JT6M.
+! at the sync-tone frequency for JT65.
         do i=nx-4,nx
            if(mode.eq.'FSK441') then
               do n=2,5
@@ -58,9 +58,6 @@
            else if(mode(1:4).eq.'JT65') then
               j=121-nint(1270.46/df)
               a(i,j)=254
-           else if(mode.eq.'JT6M') then
-              j=121-nint(1076.66/df)
-              a(i,j)=254
            endif
         enddo
      endif

Deleted: trunk/inter_mept.f
===================================================================
--- trunk/inter_mept.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/inter_mept.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,47 +0,0 @@
-      subroutine inter_mept(id,ndir)
-
-C  Interleave (ndir=1) or de-interleave (ndir=-1) the array id.
-
-      integer*1 id(0:161),itmp(0:161)
-      integer j0(0:161)
-      character*8 c0,c1
-      logical first
-      data first/.true./
-      save
-
-      if(first) then
-         k=-1
-         do i=0,255
-            m=i
-            n=iand(m,1)
-            n=2*n + iand(m/2,1)
-            n=2*n + iand(m/4,1)
-            n=2*n + iand(m/8,1)
-            n=2*n + iand(m/16,1)
-            n=2*n + iand(m/32,1)
-            n=2*n + iand(m/64,1)
-            n=2*n + iand(m/128,1)
-            if(n.le.161) then
-               k=k+1
-               j0(k)=n
-            endif
-         enddo
-         first=.false.
-      endif
-
-      if(ndir.eq.1) then
-         do i=0,161
-            itmp(j0(i))=id(i)
-         enddo
-      else
-         do i=0,161
-            itmp(i)=id(j0(i))
-         enddo
-      endif
-
-      do i=0,161
-         id(i)=itmp(i)
-      enddo
-
-      return
-      end

Modified: trunk/interleave24.f
===================================================================
--- trunk/interleave24.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/interleave24.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,7 +1,6 @@
       subroutine interleave24(id,ndir)
       integer*1 id(0:205),itmp(0:205)
       integer j0(0:205)
-      character*8 c0,c1
       logical first
       data first/.true./
       save first,j0

Copied: trunk/iscat.f90 (from rev 2228, wsjt7a/iscat.f90)
===================================================================
--- trunk/iscat.f90	                        (rev 0)
+++ trunk/iscat.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,222 @@
+subroutine iscat(dat,npts,cfile6,MinSigdB,DFTolerance,NFreeze,MouseDF,ccf,psavg)
+
+! Decode an ISCAT_2 signal
+
+  parameter (NMAX=512*1024)
+  parameter (NSZ=4*1400)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  character cfile6*6                      !File time
+  character c42*42
+  character msg*28,msg1*28
+  real x(NSZ),x2(NSZ)
+  complex c(0:512)
+  real s0(128,NSZ)
+  real fs0(128,108)                       !108 = 96 + 3*4
+  real fs1(0:41,30)
+  real savg(128)
+  real b(128)
+  real ccf(-5:540)
+  real psavg(450)         !Average spectrum of the whole file
+  integer dftolerance
+  integer icos(4)
+  equivalence (x,c)
+  data icos/0,1,3,2/
+  data nsps/256/,nsync/4/,nlen/2/,ndat/18/
+  data c42/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ /.?@-'/
+  
+  nsym=npts/nsps
+  nblk=nsync+nlen+ndat
+  nfft=512                             !FFTs at twice the symbol length
+  kstep=nsps/4                         !Step by 1/4 symbol
+  nh=nfft/2
+  nq=nfft/4
+  df=11025.0/nfft
+  fac=1.0/1000.0                      !Somewhat arbitrary
+  savg=0.
+
+  ia=1-kstep
+  do j=1,4*nsym
+     ia=ia+kstep
+     ib=ia+nsps-1
+     if(ib.gt.npts) go to 10
+     x(1:nsps)=fac*dat(ia:ib)
+     x(nsps+1:nfft)=0.
+     call four2a(x,nfft,1,-1,0)
+     do i=1,nq
+        s0(i,j)=real(c(i))**2 + aimag(c(i))**2
+        savg(i)=savg(i) + s0(i,j)
+     enddo
+  enddo
+
+10 jsym=j-1
+
+  savg=savg/jsym
+  do i=1,nq
+     x(1:jsym)=s0(i,1:jsym)
+     call pctile(x,x2,jsym,30,b(i))
+  enddo
+  b(1:10)=b(11)
+  do i=1,nq/2
+     psavg(i)=2*db(savg(2*i)) + 10.0
+  enddo
+
+  do j=1,jsym
+     s0(1:nq,j)=s0(1:nq,j)/b(1:nq)
+  enddo
+
+  fs0=0.
+  jb=(jsym-4*nblk+1)/4
+  jb=4*jb
+  do j=1,jb                                  !Fold s0 modulo 4*nblk into fs0
+     k=mod(j-1,4*nblk)+1
+     fs0(1:nq,k)=fs0(1:nq,k) + s0(1:nq,j)
+  enddo
+
+  do j=1,12
+     fs0(1:nq,96+j)=fs0(1:nq,j)
+  enddo
+
+  i0=2*13
+  smax=0.
+  ipk=1
+  jpk=1
+  ia=-400/df
+  ib=400/df
+  if(nfreeze.eq.1) then
+     ia=(mousedf-dftolerance)/df
+     ib=(mousedf+dftolerance)/df
+  endif
+  if(i0+ia.lt.1) ia=1-i0
+  if(i0+ib+3.gt.128) ib=128-3-i0
+
+  do j=0,4*nblk-1                            !Find sync pattern, lags 0-95
+     do i=ia,ib
+        ss=0.
+        do n=1,4
+           k=j+4*n-3
+           if(k.gt.4*nblk) k=k-4*nblk
+           ss=ss + fs0(i0+i+2*icos(n),k)
+        enddo
+        if(ss.gt.smax) then
+           smax=ss
+           ipk=i0+i                          !Frequency offset, DF
+           jpk=j+1                           !Time offset, DT
+        endif
+     enddo
+  enddo
+
+  ref=fs0(ipk+2,jpk) + fs0(ipk+4,jpk) + fs0(ipk+6,jpk)  +        &amp;
+      fs0(ipk,jpk+4) + fs0(ipk+4,jpk+4) + fs0(ipk+6,jpk+4) +     &amp;
+      fs0(ipk,jpk+8) + fs0(ipk+2,jpk+8) + fs0(ipk+4,jpk+8) +     &amp;
+      fs0(ipk,jpk+12) + fs0(ipk+2,jpk+12) + fs0(ipk+6,jpk+12)
+  ref=ref/3.0
+
+  kk=0
+  do j=0,4*nblk-1
+     ss=0.
+     do n=1,4
+        k=j+4*n-3
+        if(k.gt.4*nblk) k=k-4*nblk
+        ss=ss + fs0(ipk+2*icos(n),k)
+     enddo
+     kk=kk+1
+     ccf(kk)=ss/ref
+  enddo
+
+  tping=jpk*kstep/11025.0
+  xsync=smax/ref
+  nsig=nint(db(smax/ref - 1.0) -15.0)
+  if(nsig.lt.-20) nsig=-20
+  ndf0=nint((ipk-i0) * 11025.0/nfft)
+  if(nsig.lt.MinSigdB) go to 800
+
+  if(ipk.gt.100 .or. jpk.gt.96) then
+     print*,'ipk:',ipk,'   jpk:',jpk
+     go to 900
+  endif
+  smax=0.
+  ja=jpk+16
+  if(ja.gt.4*nblk) ja=ja-4*nblk
+  jb=jpk+20
+  if(jb.gt.4*nblk) jb=jb-4*nblk
+  do i=ipk,ipk+60,2                         !Find User's message length
+     ss=fs0(i,ja) + fs0(i+10,jb)
+     if(ss.gt.smax) then
+        smax=ss
+        ipk2=i
+     endif
+  enddo
+
+  msglen=(ipk2-ipk)/2
+  if(msglen.lt.1 .or. msglen.gt.28) msglen=2         !### tests only ###
+  fs1=0.
+  jb=(jsym-4*nblk+1)/4
+  jb=4*jb
+  k=0
+  n=0
+  do j=jpk,jsym,4                         !Fold information symbols into fs1
+     k=k+1
+     if(mod(k-1,nblk)+1.gt.6) then
+        n=n+1
+        m=mod(n-1,msglen)+1
+        do i=0,41
+           fs1(i,m)=fs1(i,m) + s0(ipk+2*i,j)
+        enddo
+     endif
+  enddo
+
+! Read out the message:
+  msg1='                            '
+  mpk=0
+  worst=9999.
+  sum=0.
+  do m=1,msglen
+     smax=0.
+     smax2=0.
+     do i=0,41
+        if(fs1(i,m).gt.smax) then
+           smax=fs1(i,m)
+           ipk3=i
+        endif
+     enddo
+     do i=0,41
+        if(fs1(i,m).gt.smax2 .and. i.ne.ipk3) smax2=fs1(i,m)
+     enddo
+     rr=smax/smax2
+     sum=sum + rr
+     if(rr.lt.worst) worst=rr
+     if(ipk3.eq.40) mpk=m
+     msg1(m:m)=c42(ipk3+1:ipk3+1)
+  enddo
+
+  avg=sum/msglen
+  if(mpk.eq.1) then
+     msg=msg1(2:)
+  else if(mpk.lt.msglen) then
+     msg=msg1(mpk+1:msglen)//msg1(1:mpk-1)
+  else
+     msg=msg1(1:msglen-1)
+  endif
+
+800 continue
+  if(nsig.lt.MinSigdB) then
+     msglen=0
+     worst=1.
+     avg=1.
+  endif
+  nworst=10.0*(worst-1.0)
+  navg=10.0*(avg-1.0)
+  if(nworst.gt.10) nworst=10
+  if(navg.gt.10) navg=10
+  xsync=xsync-0.3
+  isync=xsync
+  if(navg.le.0) msg=' '
+
+  call cs_lock('iscat')
+  write(11,1020) cfile6,nsig,ndf0,msg        !,msglen,nworst,navg
+  write(21,1020) cfile6,nsig,ndf0,msg        !,msglen,nworst,navg
+1020 format(a6,i5,i5,6x,a28,i4,2i3)
+  call cs_unlock
+
+900 return
+end subroutine iscat

Modified: trunk/jtaudio.c
===================================================================
--- trunk/jtaudio.c	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/jtaudio.c	2010-10-26 13:46:16 UTC (rev 2230)
@@ -156,8 +156,14 @@
     n=nsec/(*data-&gt;trperiod);
     //    ic = (int)(stime - *data-&gt;trperiod*n) * data-&gt;nfs/framesPerBuffer;
     //    ic = framesPerBuffer*ic;
-    ic = (int)(stime - *data-&gt;trperiod*n) * data-&gt;nfs;
-    ic = ic % *data-&gt;nwave;
+
+    if(*data-&gt;nmode == 3)  {
+      ic = 0;
+    }
+    else  {
+      ic = (int)(stime - *data-&gt;trperiod*n) * data-&gt;nfs;
+      ic = ic % *data-&gt;nwave;
+    }
   }
 
   TxOKz=*data-&gt;TxOK;
@@ -172,7 +178,8 @@
       ic++;
 
       if(ic &gt;= *data-&gt;nwave) {
-        if((*data-&gt;nmode != 1) &amp;&amp; (*data-&gt;nmode != 4)) {
+	/*             FSK441               JT6M                 JT41  */
+        if((*data-&gt;nmode != 1) &amp;&amp; (*data-&gt;nmode != 4) &amp;&amp; (*data-&gt;nmode != 9)) {
           *data-&gt;TxOK = 0;
           ic--;
         } else {
@@ -240,7 +247,7 @@
   inputParameters.device = ndevice_in;
   inputParameters.channelCount = 2;
   inputParameters.sampleFormat = paInt16;
-  inputParameters.suggestedLatency = 1.0;
+  inputParameters.suggestedLatency = 0.2;
   inputParameters.hostApiSpecificStreamInfo = NULL;
 
 // Test if this configuration actually works, so we do not run into an ugly assertion
@@ -275,7 +282,7 @@
   outputParameters.device = ndevice_out;
   outputParameters.channelCount = 2;
   outputParameters.sampleFormat = paInt16;
-  outputParameters.suggestedLatency = 1.0;
+  outputParameters.suggestedLatency = 0.2;
   outputParameters.hostApiSpecificStreamInfo = NULL;
 
 // Test if this configuration actually works, so we do not run into an ugly assertion

Copied: trunk/jtms.f90 (from rev 2228, wsjt7a/jtms.f90)
===================================================================
--- trunk/jtms.f90	                        (rev 0)
+++ trunk/jtms.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,89 @@
+subroutine jtms(dat,npts,cfile6,t2,mswidth,ndb,nrpt,Nfreeze,       &amp;
+     DFTolerance,MouseDF,pick,mycall,hiscall)
+
+! Decode a JTMS ping
+
+  parameter (NZ=30*11025)
+  real dat(npts)                        !Raw data
+  complex cdat(NZ)                      !Analytic form of signal
+  character*6 cfile6                    !FileID
+  integer DFTolerance
+  logical pick
+  character*12 mycall,hiscall
+  real s(NZ)                            !Power spectrum
+  real s2(0:63,400)
+  real r(60000)
+  complex cw(56,0:63)                   !Complex waveforms for all codewords
+  complex cwb(56)                       !Complex waveform for &lt;space&gt;
+  logical first
+  character msg*400,msg29*29
+  character*90 line
+  common/ccom/nline,tping(100),line(100)
+  data first/.true./
+  save first,cw,cwb
+  save cdat                             !Fix its address, for four2
+
+  if(first) call setupms(cw,cwb)        !Calculate waveforms for codewords
+  first=.false.
+
+  nsps=8                                !Samples per symbol
+  f0=1155.46875                         !Nominal frequency for bit=0
+  n=log(float(npts))/log(2.0) + 1.0
+  nfft1=2**n                            !FFT length
+  call analytic(dat,npts,nfft1,s,cdat)  !Convert to analytic signal
+
+  call msdf(cdat,npts,t2,nfft1,f0,nfreeze,mousedf,dftolerance,     &amp;
+       dfx,snrsq2)                      !Get DF
+
+  sq2lim=7.0
+  if(pick) sq2lim=5.0
+  if(snrsq2.lt.sq2lim) go to 900           !Reject non-JTMS signals
+
+  call tweak1(cdat,npts,-dfx,cdat)      !Mix to standard frequency
+
+! DF is known, now establish character sync.
+
+  call syncms(cdat,npts,cwb,r,i1)       !Get character sync
+
+  call lenms(r,npts,msglen)             !Find message length
+
+  s2=0.
+  nchar=(npts-55-i1)/56
+  if(nchar.gt.400) nchar=400
+
+  call decodems(cdat,npts,cw,i1,nchar,s2,msg)   !Decode the message
+
+!  ia=1
+!  if(nchar.ge.40) ia=min(nchar/3,nchar-28)    
+!  ib=min(ia+28,nchar)                   !Can better limits ia, ib be found?
+!  print*,'A',ia,ib,nchar
+!  print*,msg(1:nchar)
+!  msg29=adjustl(msg(ia:ib))
+  msg=adjustl(msg)
+  ib=min(nchar,45)
+  ndf=nint(dfx)
+  nchk=max(20,nint(1.5*msglen))
+
+  if(msglen.eq.0 .or. nchar.lt.nchk .or. pick) then
+     if(nline.le.99) nline=nline+1
+     tping(nline)=t2
+     call cs_lock('decodems')
+     write(line(nline),1110) cfile6,t2,mswidth,ndb,nrpt,ndf,msg(1:45)
+1110 format(a6,f5.1,i5,i3,1x,i2.2,i5,5x,a45)
+     call cs_unlock
+  endif
+
+  if(msglen.gt.0 .and. nchar.ge.nchk) then
+     call foldms(s2,msglen,nchar,mycall,msg,msg29)   !Decode folded message
+     if(nline.le.99) nline=nline+1
+     tping(nline)=t2
+     call cs_lock('decodems')
+     write(line(nline),1120) cfile6,t2,mswidth,ndb,nrpt,ndf,msg29
+1120 format(a6,f5.1,i5,i3,1x,i2.2,i5,5x,a29,11x,'*')
+     call cs_unlock
+   endif
+
+900 continue
+
+  return
+end subroutine jtms

Copied: trunk/len441.f90 (from rev 2228, wsjt7a/len441.f90)
===================================================================
--- trunk/len441.f90	                        (rev 0)
+++ trunk/len441.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,65 @@
+subroutine len441(cdat,npts,msglen,nacf)
+
+! Determine length of the user message in a JTMS ping.
+
+  complex cdat(npts)
+  real acf(2250)
+  real acf2(2250)
+  real tmp(2250)
+
+  msglen=0                              !Use ACF to find msg length
+  acf=0.
+  acf2=0.
+  ja=151
+  jb=min(75*28,npts-225)
+  do j=ja,jb
+     z=0.
+     do i=1,npts-j
+        z=z + cdat(i)*conjg(cdat(i+j))
+     enddo
+     acf(j)=abs(z)/(npts-j)
+  enddo
+
+!  rewind 53
+  jstep=50
+  smax=0.
+  do j=ja+jstep,jb-jstep
+
+! Find local base level; update every 10 bins.
+     if(mod(j-ja-jstep,10).eq.0) then
+        call pctile(acf(j-jstep),tmp,2*jstep+1,45,base)
+     endif
+     acf2(j)=acf(j)/base - 1.0
+     if(acf2(j).gt.smax) then
+        smax=acf2(j)
+        jpk=j
+     endif
+!     write(53,5001) j,j/75.0,acf2(j)
+!5001 format(i8,2f12.3)
+  enddo
+!  call flush(53)
+  
+  np=nint(jpk/75.0)
+  chk=(jpk/75.0)/np
+
+  smax2=0.
+  do m=4,2,-1
+     if(mod(np,m).eq.0) then
+        i0=nint(np*75.0/m)
+        smax2=0.
+        do i=-10,10
+           if(acf2(i0+i).gt.smax2) smax2=acf2(i0+i)
+        enddo
+        if(smax2/smax.gt.0.6) go to 10
+     endif
+  enddo
+  m=1
+10 msglen=np/m
+  nacf=smax-4.0
+  if(nacf.lt.0) nacf=0
+  if(nacf.gt.10) nacf=10
+  if(chk.lt.0.99 .or. chk.gt.1.01 .or. nacf.le.0) msglen=0
+!  print*,np,msglen,nacf,chk,smax,smax2
+
+  return
+end subroutine len441

Copied: trunk/lenms.f90 (from rev 2228, wsjt7a/lenms.f90)
===================================================================
--- trunk/lenms.f90	                        (rev 0)
+++ trunk/lenms.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,56 @@
+subroutine lenms(r,npts,msglen)
+
+! Determine length of the user message in a JTMS ping.
+
+  real r(60000)
+  real acf(1624)
+  integer np(9)
+  data np/5,7,9,11,13,17,19,23,29/      !Permissible message lengths
+  save acf                              !Why necessary?  (But don't remove!)
+
+  msglen=0                              !Use ACF to find msg length
+  if(npts.ge.8*56) then
+     r=r-sum(r(1:npts))/npts
+     acfmax=0.
+     acf0=dot_product(r(1:npts),r(1:npts))
+     kz=min(nint(0.75*npts),29*56)
+     do k=8,kz
+        fac=float(npts)/(npts-k)
+        acf(k)=fac*dot_product(r(1:npts),r(1+k:npts+k))/acf0
+     enddo
+     call hipass(acf(8),kz-7,50)
+
+     do k=8,kz                          !Find acfmax, kpk
+        if(acf(k).gt.acfmax) then
+           acfmax=acf(k)
+           kpk=k
+        endif
+     enddo
+
+     sumsq=0.
+     n=0
+     do k=8,kz                          !Find rms, skipping around kpk
+        if(abs(k-kpk).gt.10) then
+           sumsq=sumsq+acf(k)**2
+           n=n+1
+        endif
+     enddo
+     rms=sqrt(sumsq/n)
+     acf=acf/rms                        !Normalize the acf
+
+     amax2=0.
+     acflim=3.5
+     do i=1,9
+        k=56*np(i)                      !Check only the permitted lengths
+        if(k.gt.kz) go to 10
+        if(acf(k).gt.acflim .and. acf(k).gt.amax2) then  
+           amax2=acf(k)                 !Save best value &gt;3.5 sigma
+           msglen=np(i)                 !Save message length
+           kpk2=k
+        endif
+     enddo
+10   continue
+  endif
+
+  return
+end subroutine lenms

Modified: trunk/longx.f
===================================================================
--- trunk/longx.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/longx.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -19,14 +19,14 @@
       character msg*40
       character c*48
       common/acom/a1,a2,a3,a4
-      data c/' 123456789.,?/# $ABCD FGHIJKLMNOPQRSTUVWXY 0EZ  '/
+      data c/' 123456789.,?/# $ABCD FGHIJKLMNOPQRSTUVWXY 0EZ*!'/
       data wgt/1.0,4.0,6.0,4.0,1.0/
 
-      kpk=0 !shut up compiler warnings -db
+      kpk=0                                !Silence compiler warning
       do i=1,NDMAX
         dit(i)=0
       enddo
-      NSPD=25                                !Change if FSK110 is implemented
+      NSPD=25                              !Change if FSK110 is implemented
       LTone=2
       NBaud=11025/NSPD
       npts=min(NMAX,npts0)

Copied: trunk/makepings.f90 (from rev 2228, wsjt7a/makepings.f90)
===================================================================
--- trunk/makepings.f90	                        (rev 0)
+++ trunk/makepings.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,28 @@
+subroutine makepings(iwave,nwave)
+
+  integer*2 iwave(nwave)
+  real*8 t
+
+  iping0=-999
+  dt=1.0/11025.0
+  do i=1,nwave
+     iping=i/(3*11025)
+     if(iping.ne.iping0) then
+        ip=mod(iping,3)
+        w=0.015*(4-ip)
+        ig=(iping-1)/3
+        amp=sqrt((3.0-ig)/3.0)
+        t0=dt*(iping+0.5)*(3*11025)
+        iping0=iping
+     endif
+     t=(i*dt-t0)/w
+     if(t.lt.0.d0 .and. t.lt.10.0) then
+        fac=0.
+     else
+        fac=2.718*t*dexp(-t)
+     endif
+     iwave(i)=nint(fac*amp*iwave(i))
+  enddo
+
+  return
+end subroutine makepings

Copied: trunk/match.f90 (from rev 2228, wsjt7a/match.f90)
===================================================================
--- trunk/match.f90	                        (rev 0)
+++ trunk/match.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,28 @@
+subroutine match(s1,s2,nstart,nmatch)
+
+  character*(*) s1,s2
+  character s1a*29
+
+  nstart=-1
+  nmatch=0
+  n1=len_trim(s1)+1
+  n2=len(s2)
+  s1a=s1//' '
+  if(n2.ge.n1) then
+     do j=1,n2
+        n=0
+        do i=1,n1
+           k=j+i-1
+           if(k.gt.n2) k=k-n2
+           if(s2(k:k).eq.s1a(i:i)) n=n+1
+        enddo
+        if(n.gt.nmatch) then
+           nmatch=n
+           nstart=j
+        endif
+     enddo
+  endif
+
+  return
+end subroutine match
+        

Deleted: trunk/mept162a.f
===================================================================
--- trunk/mept162a.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/mept162a.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,106 +0,0 @@
-      subroutine mept162a(c2,jz,f0,cfile6,ndiag,minsync,mousedf,ndftol,
-     +    ndwspr,ccfblue,ccfred)
-
-C  Orchestrates the process of finding, synchronizing, and decoding 
-C  WSPR signals.
-
-      character*22 message
-      character*8 cfile6
-      real ccfblue(-5:540)
-      real ccfred(-224:224)
-      logical first
-      real ps(-256:256)
-      real sstf(5,275)
-      real a(5)
-      complex c2(jz)
-      complex c2a(0:65535)
-      complex c3(45000),c4(45000)
-      data first/.true./
-      save
-
-C  Mix 1500 Hz +/- 100 Hz to baseband, and downsample by 1/32
-!      call mix162(id,npts,c2,jz,ps)
-      c2a(0:jz-1)=c2
-      c2a(jz:)=0.
-      nfft0=65536
-      call four2a(c2a,65536,1,-1,1)
-      do k=-256,256
-         i=128*k
-         sq=0.
-         do n=-64,63
-            j=i+n
-            if(j.lt.0) j=j+nfft0
-            sq=sq + real(c2a(j))**2 + aimag(c2a(j))**2
-         enddo
-         ps(k)=1.e-8*sq
-      enddo
-
-C  Compute pixmap.dat
-!      call spec162(c2,jz)
-
-C  Look for sync patterns, get DF and DT
-      call sync162(c2,jz,mousedf,ndftol,ccfblue,ccfred,ps,sstf,kz)
-
-      idtmax=64
-      idtstep=1
-      if(ndwspr.eq.0) then
-         idtstep=8
-      endif
-      do k=1,kz
-         snrsync=sstf(1,k)
-         snrx=sstf(2,k)
-         dtx=sstf(3,k)
-         dfx=sstf(4,k)
-         drift=sstf(5,k)
-         ndf=nint(f0-1500.0+dfx)
-         a(1)=-dfx
-         a(2)=-0.5*drift
-         a(3)=0.
-         call twkfreq(c2,c3,jz,a)                    !Remove drift
-
-         nsync=nint(snrsync-4.0)
-         nsnrx=nint(snrx)
-         if(nsnrx.lt.-33) nsnrx=-33
-         if(nsync.lt.0) nsync=0
-         message='                      '
-         if(nsync.ge.minsync .and. nsnrx.ge.-30) then      !### -31 dB limit?
-            dt=1.0/375
-            do idt=0,idtmax,idtstep
-               do isign=-1,1,2
-                  ii=idt*isign
-                  i1=nint((dtx+2.0)/dt) + ii !Start index for synced symbols
-                  if(i1.ge.1) then
-                     c4(1:jz-i1+1)=c3(i1:jz)
-                     c4(jz-i1+2:)=0.
-                  else
-                     c4(:-i1+1)=0.
-                     jzz=min(jz,45000)
-                     c4(-i1+2:jzz)=c3(1:i1+jzz-1)
-                     if(jzz.lt.45000) c4(jzz:45000)=0.
-                  endif
-                  call decode162(c4,45000,ndwspr,message,ncycles,metric,
-     +                           nerr)
-                  if(message(1:6).ne.'      ' .and.
-     +               message(1:6).ne.'000AAA') go to 23
-               enddo
-            enddo
-
- 23         nf1=nint(-a(2))
-            if(ndiag.ne.0) then
-               call cs_lock('mept162a')
-               write(11,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message,
-     +              ii,ncycles/81
-               write(21,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message,
-     +              ii,ncycles/81
-            else
-               write(11,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message
-               write(21,1012) cfile6,nsync,nsnrx,dtx,ndf,nf1,message
-            endif
- 1012       format(a6,i4,i4,f5.1,i6,i3,2x,a22,15x,i4,i6)
-            i1=index(message,' ')
-            call cs_unlock
-         endif
-      enddo
-
-      return
-      end

Copied: trunk/msdf.f90 (from rev 2228, wsjt7a/msdf.f90)
===================================================================
--- trunk/msdf.f90	                        (rev 0)
+++ trunk/msdf.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,73 @@
+subroutine msdf(cdat,npts,t2,nfft1,f0,nfreeze,mousedf,dftolerance,dfx,snrsq2)
+
+! Determine DF for a JTMS signal.  Also find ferr, a measure of
+! frequency differerence between 1st and 2nd harmonic.  
+! (Should be 0.000)
+
+  parameter (NZ=32768)
+  complex cdat(npts)
+  integer dftolerance
+  real sq(NZ)
+  real ccf(-2600:2600)                  !Correct limits?
+  real tmp(NZ)
+  complex c(NZ)
+  data nsps/8/
+  save c
+
+  df1=11025.0/nfft1
+  nh=nfft1/2
+  fac=1.0/(nfft1**2)
+
+  do i=1,npts
+     c(i)=fac*cdat(i)**2
+  enddo
+  c(npts+1:nfft1)=0.
+  call four2a(c,nfft1,1,-1,1)
+
+! In the &quot;doubled-frequencies&quot; spectrum of squared cdat:
+  fa=2.0*(f0-400)
+  fb=2.0*(f0+400)
+  j0=nint(2.0*f0/df1)
+  ja=nint(fa/df1)
+  jb=nint(fb/df1)
+  jd=nfft1/nsps
+
+  do j=1,nh+1
+     sq(j)=real(c(j))**2 + aimag(c(j))**2
+  enddo
+
+  ccf=0.
+  do j=ja,jb
+     ccf(j-j0-1)=sq(j)+sq(j+jd)
+  enddo
+
+  call pctile(ccf(ja-j0-1),tmp,jb-ja+1,50,base)
+  ccf=ccf/base
+
+  if(NFreeze.gt.0) then
+     fa=2.0*(f0+MouseDF-DFtolerance)
+     fb=2.0*(f0+MouseDF+DFtolerance)
+  endif  
+  ja=nint(fa/df1)
+  jb=nint(fb/df1)
+
+!  rewind 51
+  smax=0.
+  do j=ja,jb
+     k=j-j0-1
+     if(ccf(k).gt.smax) then
+        smax=ccf(k)
+        jpk=j
+     endif
+     f=0.5*k*df1
+!     write(51,3002) f,ccf(k)
+!3002 format(2f12.3)
+  enddo
+!  call flush(51)
+
+  fpk=(jpk-1)*df1  
+  dfx=0.5*fpk-f0
+  snrsq2=smax
+
+  return
+end subroutine msdf

Modified: trunk/mtdecode.f
===================================================================
--- trunk/mtdecode.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/mtdecode.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,14 +1,14 @@
-      subroutine mtdecode(dat,jz,nz,MinSigdB,MinWidth,
-     +    NQRN,DFTolerance,istart,pick,cfile6,ps0)
+      subroutine mtdecode(dat,jz,nz,MinSigdB,MinWidth,NFreeze,
+     +   DFTolerance,MouseDF,istart,pick,cfile6,mycall,hiscall,
+     +   mode,ps0)
 
 C  Decode Multi-Tone FSK441 mesages.
 
       real dat(jz)                !Raw audio data
-      integer NQRN
       integer DFTolerance
       logical pick
-      character*6 cfile6,cf*1
-
+      character*6 cfile6
+      character*12 mycall,hiscall
       real sigdb(3100)             !Detected signal in dB, sampled at 20 ms
       real work(3100)
       integer indx(3100)
@@ -59,7 +59,6 @@
          enddo
       endif
 !##################################################################
-
       call smooth(sigdb,nz)
 
 C  Remove baseline and one dB for good measure.
@@ -72,12 +71,12 @@
 
 C  If this is a &quot;mouse pick&quot; and no ping was found, force a pseudo-ping 
 C  at center of data.
-        if(pick.and.nping.eq.0) then
-           if(nping.le.99) nping=nping+1
-           pingdat(1,nping)=0.5*jz*dt
-           pingdat(2,nping)=0.16
-           pingdat(3,nping)=1.0
-        endif
+      if(pick.and.nping.eq.0) then
+         if(nping.le.99) nping=nping+1
+         pingdat(1,nping)=0.5*jz*dt
+         pingdat(2,nping)=0.16
+         pingdat(3,nping)=1.0
+      endif
 
       bigpeak=0.
       do iping=1,nping
@@ -98,9 +97,6 @@
          msg=' '
          call longx(dat(jj),jjz,ps,DFTolerance,noffset,msg,
      +     msglen,bauderr)
-         qrnlimit=4.4*1.5**(5.0-NQRN)
-         if(NQRN.eq.0) qrnlimit=99.
-         if(msglen.eq.0) go to 100
 
 C  Assemble a signal report:
          nwidth=0
@@ -111,17 +107,26 @@
          if(peak.ge.11.0) nstrength=7
          if(peak.ge.17.0) nstrength=8
          if(peak.ge.23.0) nstrength=9
+         npeak=peak
+         nrpt=10*nwidth + nstrength
+         t2=tstart + dt*(istart-1)
 
-!         if(peak.gt.5.0 .and.mswidth.ge.100) then
-!            call specsq(dat(jj),jjz,DFTolerance,0,noffset2)
-!            noffset=noffset2
-!         endif
+         if(mode.eq.8) then
+            jjzz=min(jjz,2*11025)       !Max data size 2 s 
+            call jtms(dat(jj),jjzz,cfile6,t2,mswidth,int(peak),
+     +           nrpt,nfreeze,DFTolerance,MouseDF,pick,mycall,hiscall)
+            go to 100
+         endif
 
+         call chk441(dat,jz,tstart,width,nfreeze,mousedf,
+     +               dftolerance,pick,nok)
+         if(msglen.eq.0 .or. nok.eq.0) go to 100
+
 C  Discard this ping if DF outside tolerance limits or bauderr too big.
 C  (However, if the ping was mouse-picked, proceed anyway.)
 
-         if(.not.pick .and. ((noffset.lt.nf1 .or. noffset.gt.nf2) .or.
-     +      (abs(bauderr).gt.qrnlimit))) goto 100
+         if(.not.pick .and. ((noffset.lt.nf1 .or. 
+     +       noffset.gt.nf2))) goto 100
 
 C  If it's the best ping yet, save the spectrum:
          if(peak.gt.bigpeak) then
@@ -130,17 +135,16 @@
                ps0(i)=ps(i)
             enddo
          endif
-   
-         tstart=tstart + dt*(istart-1)
-         cf=' '
+
          if(nline.le.99) nline=nline+1
-         tping(nline)=tstart
+         tping(nline)=t2
+
          call cs_lock('mtdecode')
-         write(line(nline),1050) cfile6,tstart,mswidth,int(peak),
-     +        nwidth,nstrength,noffset,msg3,msg,cf
- 1050    format(a6,f5.1,i5,i3,1x,2i1,i5,1x,a3,1x,a40,1x,a1)
+         write(line(nline),1050) cfile6,t2,mswidth,int(peak),
+     +        nrpt,noffset,msg3,msg
+ 1050    format(a6,f5.1,i5,i3,1x,i2.2,i5,1x,a3,1x,a40)
          call cs_unlock
- 100  continue
+ 100     continue
       enddo
 
       return

Deleted: trunk/pack50.f
===================================================================
--- trunk/pack50.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/pack50.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,26 +0,0 @@
-      subroutine pack50(n1,n2,dat)
-
-      integer*1 dat(11),i1
-
-      i1=iand(ishft(n1,-20),255)                !8 bits
-      dat(1)=i1
-      i1=iand(ishft(n1,-12),255)                 !8 bits
-      dat(2)=i1
-      i1=iand(ishft(n1, -4),255)                 !8 bits
-      dat(3)=i1
-      i1=16*iand(n1,15)+iand(ishft(n2,-18),15)   !4+4 bits
-      dat(4)=i1
-      i1=iand(ishft(n2,-10),255)                 !8 bits
-      dat(5)=i1
-      i1=iand(ishft(n2, -2),255)                 !8 bits
-      dat(6)=i1
-      i1=64*iand(n2,3)                           !2 bits
-      dat(7)=i1
-      dat(8)=0
-      dat(9)=0
-      dat(10)=0
-      dat(11)=0
-
-      return
-      end
-

Modified: trunk/packgrid.f
===================================================================
--- trunk/packgrid.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/packgrid.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -9,12 +9,20 @@
 
 C  Test for numerical signal report, etc.
       if(grid(1:1).eq.'-') then
-         n=10*(ichar(grid(2:2))-48) + ichar(grid(3:3)) - 48
- 1       ng=NGBASE+1+n
+         if(grid(3:3).ne.' ') then
+            n=10*(ichar(grid(2:2))-48) + ichar(grid(3:3)) - 48
+         else
+            n=ichar(grid(2:2))-48
+         endif
+         ng=NGBASE+1+n
          go to 100
       else if(grid(1:2).eq.'R-') then
-         n=10*(ichar(grid(3:3))-48) + ichar(grid(4:4)) - 48
- 2       if(n.eq.0) go to 90
+         if(grid(4:4).ne.' ') then
+            n=10*(ichar(grid(3:3))-48) + ichar(grid(4:4)) - 48
+         else
+            n=ichar(grid(3:3))-48
+         endif
+         if(n.eq.0) go to 90
          ng=NGBASE+31+n
          go to 100
       else if(grid(1:2).eq.'RO') then

Modified: trunk/packmsg.f
===================================================================
--- trunk/packmsg.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/packmsg.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -58,7 +58,7 @@
       k=max(k1,k2)
       if(k.gt.0) then
          call k2grid(k,grid6)
-         c3=grid6(1:4) !XXX explicitly truncate this -db
+         c3=grid6(1:4)                     !Explicitly truncate to 4 chars
       endif
       call packgrid(c3,ng,text3)
       if((.not.text1) .and. (.not.text2) .and. (.not.text3)) go to 20

Deleted: trunk/packname.f90
===================================================================
--- trunk/packname.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/packname.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,23 +0,0 @@
-subroutine packname(name,len,n1,n2)
-
-  character*9 name
-  real*8 dn
-
-  dn=0
-  do i=1,len
-     n=ichar(name(i:i))
-     if(n.ge.97 .and. n.le.122) n=n-32
-     dn=27*dn + n-64
-  enddo
-  if(len.lt.9) then
-     do i=len+1,9
-        dn=27*dn
-     enddo
-  endif
-
-  n2=mod(dn,32768.d0)
-  dn=dn/32768.d0
-  n1=dn
-
-  return
-end subroutine packname

Deleted: trunk/packprop.f90
===================================================================
--- trunk/packprop.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/packprop.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,36 +0,0 @@
-subroutine packprop(k,muf,ccur,cxp,n1)
-
-! Pack propagation indicators into a 21-bit number.
-
-! k      k-index, 0-9; 10=&quot;N/A&quot;
-! muf    muf, 2-60 MHz; 0=N/A, 1=&quot;none&quot;, 61=&quot;&gt;60 MHz&quot;
-! ccur   up to two current events, each indicated by single
-!        or double letter.
-! cxp    zero or one expected event, indicated by single or
-!        double letter
-
-  character ccur*4,cxp*2
-
-  j=ichar(ccur(1:1))-64
-  if(j.lt.0) j=0
-  n1=j
-  do i=2,4
-     if(ccur(i:i).eq.' ') go to 10
-     if(ccur(i:i).eq.ccur(i-1:i-1)) then
-        n1=n1+26
-     else
-        j=ichar(ccur(i:i))-64
-        if(j.lt.0) j=0
-        n1=53*n1 + j
-     endif
-  enddo
-
-10 j=ichar(cxp(1:1))-64
-  if(j.lt.0) j=0
-  if(cxp(2:2).eq.cxp(1:1)) j=j+26
-  n1=53*n1 + j
-  n1=11*n1 + k
-  n1=62*n1 + muf
-
-  return
-end subroutine packprop

Deleted: trunk/packtext2.f90
===================================================================
--- trunk/packtext2.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/packtext2.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,22 +0,0 @@
-subroutine packtext2(msg,n1,ng)
-
-  character*8 msg
-  real*8 dn
-  character*41 c
-  data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +./?'/
-
-  dn=0.
-  do i=1,8
-     do j=1,41
-        if(msg(i:i).eq.c(j:j)) go to 10
-     enddo
-     j=37
-10   j=j-1                                !Codes should start at zero
-     dn=41.d0*dn + j
-  enddo
-
-  ng=mod(dn,32768.d0)
-  n1=(dn-ng)/32768.d0
-
-  return
-end subroutine packtext2

Copied: trunk/ping441.f90 (from rev 2228, wsjt7a/ping441.f90)
===================================================================
--- trunk/ping441.f90	                        (rev 0)
+++ trunk/ping441.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,62 @@
+subroutine ping441(dat,jz,nz,MinSigdB,MinWidth,pick,pingdat,nping)
+
+! Decode Multi-Tone FSK441 mesages.
+
+  real dat(jz)                !Raw audio data
+  logical pick
+
+  real sigdb(3100)             !Detected signal in dB, sampled at 20 ms
+  real work(3100)
+  integer indx(3100)
+  real pingdat(3,100)
+
+  slim=MinSigdB
+  wmin=0.001*MinWidth * (19.95/20.0)
+  dt=1.0/11025.0
+
+! Find signal power at suitable intervals to search for pings.
+  istep=221
+  dtbuf=istep/11025.
+  do n=1,nz
+     s=0.
+     ib=n*istep
+     ia=ib-istep+1
+     do i=ia,ib
+        s=s+dat(i)**2
+     enddo
+     sigdb(n)=s/istep
+  enddo
+
+!#####################################################################
+  if(.not.pick) then
+! Remove initial transient from sigdb
+     call indexx(nz,sigdb,indx)
+     imax=0
+     do i=1,50
+        if(indx(i).gt.50) go to 10
+        imax=max(imax,indx(i))
+     enddo
+10   do i=1,50
+        if(indx(nz+1-i).gt.50) go to 20
+        imax=max(imax,indx(nz+1-i))
+     enddo
+20   imax=imax+6            !Safety margin
+     base1=sigdb(indx(nz/2))
+     do i=1,imax
+        sigdb(i)=base1
+     enddo
+  endif
+!##################################################################
+
+  call smooth(sigdb,nz)
+
+! Remove baseline and one dB for good measure.
+  call pctile (sigdb,work,nz,50,base1)
+  do i=1,nz
+     sigdb(i)=dB(sigdb(i)/base1) - 1.0
+  enddo
+
+  call ping(sigdb,nz,dtbuf,slim,wmin,pingdat,nping)
+
+  return
+end subroutine ping441

Modified: trunk/pix2d.f90
===================================================================
--- trunk/pix2d.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/pix2d.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -102,27 +102,10 @@
               b((ich-1)*500+j+495)=254
            enddo
         enddo
-     else if(mode.eq.'JT6M') then
-! Insert yellow tick marks at frequencies of the JT6M sync tone
-        f=1076.66
-        ich=60-nint(f/43.066)     !Why 58 for FSK441, above?
-        do j=1,5
-           b((ich-1)*500+j+2)=254
-           b((ich-1)*500+j+248)=254
-           b((ich-1)*500+j+495)=254
-        enddo
-! Insert green tick at frequency indicated by MouseDF
-        if(NFreeze.gt.0) then
-           f=1076.66+mousedf
-           ich=60-nint(f/43.066)     !Why 58 for FSK441, above?
-           do j=1,7
-              b((ich-1)*500+j+2)=255
-           enddo
-        endif
      endif
 
 ! Mark the best ping with a red tick
-     if(tbest.gt.0.0) then
+     if(tbest.gt.0.0 .and.tbest.lt.29.5) then
         nx=tbest/0.060 + 1
         do j=110,120
            b((j-1)*500+nx0)=0

Modified: trunk/pix2d65.f90
===================================================================
--- trunk/pix2d65.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/pix2d65.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -11,7 +11,6 @@
   enddo
   nave=nint(sum/jz)
   nadd=nint(53.0*11025.0/500.0)
-  if(mode(1:4).eq.'WSPR') nadd=nint(114.0*11025.0/500.0)
   ngreen=min(jz/nadd,500)
   k=0
   do i=1,ngreen

Deleted: trunk/ps162.f
===================================================================
--- trunk/ps162.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/ps162.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,27 +0,0 @@
-      subroutine ps162(c2,s)
-
-      parameter (NFFT=512,NH=256)
-      complex c2(0:NFFT)
-      real s(-NH:NH)
-!      real work(2*NMAX)
-      complex c(0:NFFT)
-
-      do i=0,NH-1
-         c(i)=c2(i)
-      enddo
-      do i=nh,nfft-1
-         c(i)=0.
-      enddo
-
-      call four2a(c,nfft,1,-1,1)
-
-      fac=1.0/nfft
-      do i=0,NFFT-1
-         j=i
-         if(j.gt.NH) j=j-NFFT
-         s(j)=fac*(real(c(i))**2 + aimag(c(i))**2)
-      enddo
-      s(-NH)=s(-NH+1)
-
-      return
-      end

Modified: trunk/ps24.f
===================================================================
--- trunk/ps24.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/ps24.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -5,7 +5,6 @@
       real dat(nfft)
       real dat2(NMAX)
       real s(NHMAX)
-      real work(2*NMAX)
       complex c(0:NMAX)
       equivalence(dat2,c)
 

Modified: trunk/ptt.c
===================================================================
--- trunk/ptt.c	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/ptt.c	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,7 +1,7 @@
 #include &lt;windows.h&gt;
 #include &lt;stdio.h&gt;
 
-int ptt_(int *nport, char *unused, int *ntx, int *iptt)
+int ptt_(int *nport, char *unused, int *ntx, int *ndtr, int *iptt)
 {
   static HANDLE hFile;
   static int open=0, nhold=0;
@@ -35,15 +35,19 @@
   }
 
   if(*ntx &amp;&amp; open) {
-    EscapeCommFunction(hFile,3);
-    EscapeCommFunction(hFile,5);
+    if(*ndtr) 
+      EscapeCommFunction(hFile,5);              //set DTR
+    else
+      EscapeCommFunction(hFile,3);              //set RTS
     *iptt=1;
   }
 
   else {
-    EscapeCommFunction(hFile,4);
-    EscapeCommFunction(hFile,6);
-    EscapeCommFunction(hFile,9);
+    if(*ndtr) 
+      EscapeCommFunction(hFile,6);              //clear DTR
+    else
+      EscapeCommFunction(hFile,4);              //clear RTS
+    EscapeCommFunction(hFile,9);              //clear BREAK
     if(nhold==0)  {
       i00=CloseHandle(hFile);
       open=0;

Modified: trunk/rfile2.f
===================================================================
--- trunk/rfile2.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/rfile2.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,6 +1,6 @@
       subroutine rfile2(fname,buf,n,nr)
 
-C  Write a wave file to disk.
+C  Read a wave file.
 
       integer RMODE
       parameter(RMODE=0)
@@ -18,6 +18,7 @@
       enddo
 
  10   fname=fname(1:iz)//char(0)
+
       fd=open(fname,RMODE)                  !Open file for reading
       nr=read(fd,buf,n)
       i=close(fd)

Deleted: trunk/runqqq.F90
===================================================================
--- trunk/runqqq.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/runqqq.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,41 +0,0 @@
-subroutine runqqq(fname,cmnd,iret)
-
-#ifdef CVF
-  use dflib
-#endif
-  integer system
-
-  character*(*) fname,cmnd
-
-  iret=ichar(fname(1:1)) + ichar(cmnd(1:1))    !Silence compiler warning
-#ifdef CVF
-  iret=runqq(fname,cmnd)
-#else
-  iret=system('KVASD_g95 -q &gt; dev_null')
-#endif
-
-  return
-end subroutine runqqq
-
-subroutine flushqqq(lu)
-
-#ifdef CVF
-  use dfport
-#endif
-
-  call flush(lu)
-
-  return
-end subroutine flushqqq
-
-subroutine sleepqqq(n)
-#ifdef CVF
-  use dflib
-      call sleepqq(n)
-#else
-      call usleep(n*1000)
-#endif
-
-  return
-
-end subroutine sleepqqq

Deleted: trunk/savedata.F90
===================================================================
--- trunk/savedata.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/savedata.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,162 +0,0 @@
-subroutine savedata
-
-#ifdef CVF
-  use dfport
-#endif
-
-  integer*1 n4
-  integer*2 iswap_short
-  character fname*24,longname*80
-  data ibuf0z/1/
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-  include 'gcom3.f90'
-  equivalence (nfmt2,n4)
-  save
-
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or. mode(1:3).eq.'JT4'   &amp;
-       .or. mode(1:2).eq.'CW' .or. mode(1:4).eq.'WSPR' .or.                &amp;
-       mode(1:4).eq.'JT64') then
-     call get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname0)
-     ibuf1=ibuf0
-     ibuf2=ibuf
-     go to 1
-  else
-     call get_fname(hiscall,iyr,imo,ida,ntime-trperiod,lauto,fname0)
-  endif
-
-  if(ibuf0.eq.ibuf0z) go to 999         !Startup condition, do not save
-  if(ntrbuf(ibuf0z).eq.1) go to 999     !We were transmitting, do not save
-
-! Get buffer pointers, then copy completed Rx sequence from y1 to d2a:
-  ibuf1=ibuf0z
-  ibuf2=ibuf0-1
-1 jza=2048*(ibuf2-ibuf1)
-  if(jza.lt.0) jza=jza+NRxMax
-  if(jza.lt.110250) go to 999           !Don't save files less than 10 s
-  if(jza.gt.120*11025) go to 999         !Don't save if something's fishy
-  k=2048*(ibuf1-1)
-  if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT2' .and. mode(1:3).ne.'JT4'   &amp;
-       .and. mode(1:4).ne.'WSPR' .and. mode(1:2).ne.'CW' .and.               &amp;
-       mode(1:4).ne.'JT64') k=k+3*2048
-  if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT2' .and. mode(1:3).ne.'JT4'   &amp;
-       .and. mode(1:4).ne.'WSPR' .and. mode(1:2).ne.'CW' .and.               &amp;
-       mode(1:4).ne.'JT64' .and. jza.gt.30*11025) then
-     k=k + (jza-30*11025)
-     if(k.gt.NRxMax) k=k-NRxMax
-     jza=30*11025
-  endif
-
-! Check timestamps of buffers used for this data
-  msbig=0
-  i=k/2048
-  if(msmax.eq.0) i=i+1
-  nz=jza/2048
-  if(msmax.eq.0) then
-     i=i+1
-     nz=nz-1
-  endif
-  do n=1,nz
-     i=i+1
-     if(i.gt.1024) i=i-1024
-     i0=i-1
-     if(i0.lt.1) i0=i0+1024
-     dtt=tbuf(i)-tbuf(i0)
-     ms=0
-     if(dtt.gt.0.d0 .and. dtt.lt.80000.0) ms=1000.d0*dtt
-     msbig=max(ms,msbig)
-  enddo
-
-  if(ndebug.gt.0 .and. msbig.gt.msmax .and. msbig.gt.330) then
-     call cs_lock('savedata')
-     write(*,1020) msbig
-1020 format('Warning: interrupt service interval',i11,' ms.')
-     call cs_unlock
-  endif
-  msmax=max(msbig,msmax)
-
-  do i=1,jza
-     k=k+1
-     if(k.gt.NRxMax) k=k-NRxMax
-     xx=dgain*y1(k)
-     xx=min(32767.0,max(-32767.0,xx))
-     d2a(i)=nint(xx)
-  enddo
-  fnamea=fname0
-
-  npingtime=0
-  fname=fnamea                   !Save filename for output to disk
-  nagain=0
-  ndecoding=1                    !Request decoding
-  
-! Generate file name and write data to file
-!    if(nsave.ge.2 .and. ichar(fname(1:1)).ne.0) then
-  if(ichar(fname(1:1)).ne.0) then
-
-! Generate header for wavefile:
-     ariff='RIFF'
-     awave='WAVE'
-     afmt='fmt '
-     adata='data'
-     lenfmt=16
-     nfmt2=1
-     nchan2=1
-     nsamrate=11025
-     nbytesam2=2
-     nbytesec=nchan2*nsamrate*nbytesam2
-     nbitsam2=16
-     ndata=2*jza
-     nbytes=ndata+44
-     nchunk=nbytes-8
-     
-     do i=80,1,-1
-        if(appdir(i:i).ne.' ') go to 10
-     enddo
-10   longname=AppDir(1:i)//'/RxWav/'//fname
-
-
-     call cs_lock('savedata')
-#ifdef CVF
-     open(17,file=longname,status='unknown',form='binary',err=20)
-     write(17) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
-          nbytesec,nbytesam2,nbitsam2,adata,ndata,(d2a(j),j=1,jza)
-     close(17)
-#else
-     open(17,file=longname,status='unknown',form='unformatted',      &amp;
-          access='direct',recl=nbytes,err=20)
-     if (n4.ne.nfmt2) then
-       nchunk = iswap_int(nchunk)
-       lenfmt = iswap_int(lenfmt)
-       nfmt2 = iswap_short(nfmt2)
-       nchan2 = iswap_short(nchan2)
-       nsamrate = iswap_int(nsamrate)
-       nbytesec = iswap_int(nbytesec)
-       nbytesam2 = iswap_short(nbytesam2)
-       nbitsam2 = iswap_short(nbitsam2)
-       ndata = iswap_int(ndata)
-       write(17,rec=1) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
-            nbytesec,nbytesam2,nbitsam2,adata,ndata,(iswap_short(d2a(j)),j=1,jza)
-     else
-       write(17,rec=1) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
-            nbytesec,nbytesam2,nbitsam2,adata,ndata,(d2a(j),j=1,jza)
-     endif
-     close(17)     
-#endif
-     filetokillb=filetokilla
-     filetokilla=longname
-     go to 30
-20   print*,'Error opening Fortran unit 17.'
-     print*,longname
-30   continue
-     call cs_unlock
-  endif
-
-999 if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT2' .and. mode(1:3).ne.'JT2' &amp;
-         .and. mode(1:3).ne.'JT4' .and. mode(1:2).ne.'CW' .and.              &amp;
-         mode(1:4).ne.'JT64') then
-     ibuf0z=ibuf0
-     call get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname0)
-  endif
-
-  return
-end subroutine savedata

Copied: trunk/savedata.f90 (from rev 2228, wsjt7a/savedata.f90)
===================================================================
--- trunk/savedata.f90	                        (rev 0)
+++ trunk/savedata.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,148 @@
+subroutine savedata
+
+  integer*1 n4
+  integer*2 iswap_short
+  character fname*24,longname*80
+  data ibuf0z/1/
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+  include 'gcom3.f90'
+  equivalence (nfmt2,n4)
+  save
+
+  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4'                    &amp;
+       .or. mode(1:2).eq.'CW') then
+     call get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname0)
+     ibuf1=ibuf0
+     ibuf2=ibuf
+     go to 1
+  else
+     call get_fname(hiscall,iyr,imo,ida,ntime-trperiod,lauto,fname0)
+  endif
+
+  if(ibuf0.eq.ibuf0z) go to 999         !Startup condition, do not save
+  if(ntrbuf(ibuf0z).eq.1) go to 999     !We were transmitting, do not save
+
+! Get buffer pointers, then copy completed Rx sequence from y1 to d2a:
+  ibuf1=ibuf0z
+  ibuf2=ibuf0-1
+1 jza=2048*(ibuf2-ibuf1)
+  if(jza.lt.0) jza=jza+NRxMax
+  if(jza.lt.110250) go to 999           !Don't save files less than 10 s
+  if(jza.gt.120*11025) go to 999         !Don't save if something's fishy
+  k=2048*(ibuf1-1)
+  if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT4'                   &amp;
+       .and. mode(1:2).ne.'CW') k=k+3*2048
+  if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT4'                   &amp;
+       .and. mode(1:2).ne.'CW' .and. jza.gt.30*11025) then
+     k=k + (jza-30*11025)
+     if(k.gt.NRxMax) k=k-NRxMax
+     jza=30*11025
+  endif
+
+! Check timestamps of buffers used for this data
+  msbig=0
+  i=k/2048
+  if(msmax.eq.0) i=i+1
+  nz=jza/2048
+  if(msmax.eq.0) then
+     i=i+1
+     nz=nz-1
+  endif
+  do n=1,nz
+     i=i+1
+     if(i.gt.1024) i=i-1024
+     i0=i-1
+     if(i0.lt.1) i0=i0+1024
+     dtt=tbuf(i)-tbuf(i0)
+     ms=0
+     if(dtt.gt.0.d0 .and. dtt.lt.80000.0) ms=1000.d0*dtt
+     msbig=max(ms,msbig)
+  enddo
+
+  if(ndebug.gt.0 .and. msbig.gt.msmax .and. msbig.gt.330) then
+     call cs_lock('savedata')
+     write(*,1020) msbig
+1020 format('Warning: interrupt service interval',i11,' ms.')
+     call cs_unlock
+  endif
+  msmax=max(msbig,msmax)
+
+  do i=1,jza
+     k=k+1
+     if(k.gt.NRxMax) k=k-NRxMax
+     xx=dgain*y1(k)
+     xx=min(32767.0,max(-32767.0,xx))
+     d2a(i)=nint(xx)
+  enddo
+  fnamea=fname0
+
+  npingtime=0
+  fname=fnamea                   !Save filename for output to disk
+  nagain=0
+  ndecoding=1                    !Request decoding
+  
+! Generate file name and write data to file
+!    if(nsave.ge.2 .and. ichar(fname(1:1)).ne.0) then
+  if(ichar(fname(1:1)).ne.0) then
+
+! Generate header for wavefile:
+     ariff='RIFF'
+     awave='WAVE'
+     afmt='fmt '
+     adata='data'
+     lenfmt=16
+     nfmt2=1
+     nchan2=1
+     nsamrate=11025
+     nbytesam2=2
+     nbytesec=nchan2*nsamrate*nbytesam2
+     nbitsam2=16
+     ndata=2*jza
+     nbytes=ndata+44
+     nchunk=nbytes-8
+     
+     do i=80,1,-1
+        if(appdir(i:i).ne.' ') go to 10
+     enddo
+10   longname=AppDir(1:i)//'/RxWav/'//fname
+
+
+     call cs_lock('savedata')
+     open(17,file=longname,status='unknown',form='unformatted',      &amp;
+          access='direct',recl=nbytes,err=20)
+     if (n4.ne.nfmt2) then
+       nchunk = iswap_int(nchunk)
+       lenfmt = iswap_int(lenfmt)
+       nfmt2 = iswap_short(nfmt2)
+       nchan2 = iswap_short(nchan2)
+       nsamrate = iswap_int(nsamrate)
+       nbytesec = iswap_int(nbytesec)
+       nbytesam2 = iswap_short(nbytesam2)
+       nbitsam2 = iswap_short(nbitsam2)
+       ndata = iswap_int(ndata)
+       write(17,rec=1) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
+            nbytesec,nbytesam2,nbitsam2,adata,ndata,(iswap_short(d2a(j)),j=1,jza)
+     else
+       write(17,rec=1) ariff,nchunk,awave,afmt,lenfmt,nfmt2,nchan2,nsamrate, &amp;
+            nbytesec,nbytesam2,nbitsam2,adata,ndata,(d2a(j),j=1,jza)
+     endif
+     close(17)     
+
+     filetokillb=filetokilla
+     filetokilla=longname
+     go to 30
+20   print*,'Error opening Fortran unit 17.'
+     print*,longname
+30   continue
+     call cs_unlock
+  endif
+
+999 if(mode(1:4).ne.'JT65' .and. mode(1:3).ne.'JT4'                    &amp;
+         .and. mode(1:2).ne.'CW') then
+     ibuf0z=ibuf0
+     call get_fname(hiscall,iyr,imo,ida,ntime,lauto,fname0)
+  endif
+
+  return
+end subroutine savedata

Copied: trunk/searchms.f90 (from rev 2228, wsjt7a/searchms.f90)
===================================================================
--- trunk/searchms.f90	                        (rev 0)
+++ trunk/searchms.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,35 @@
+subroutine searchms(cdat,npts,msg,ndi,rmax)
+
+  parameter (NMAX=30*11025)     !Max length of wave file
+  complex cdat(npts)
+  complex cwave(NMAX)
+  character*28 msg            !User message
+
+  call genms(msg,1.d0,iwave,cwave,1,kz)
+
+  r=0.
+  rmax=0.
+  do i1=1,npts-kz
+     z=0.
+     ss=0.
+     do i=1,kz
+        ss=ss + abs(cdat(i+i1-1))
+        z=z + cdat(i+i1-1)*conjg(cwave(i))
+     enddo
+     r=abs(z)/ss
+!     write(53,3001) i1,r,abs(z)
+!3001 format(i8,2f12.3)
+     if(r.gt.rmax) then
+        rmax=r
+        i1pk=i1
+     endif
+  enddo     
+
+  nch=i1pk/56.0
+  ndi=i1pk - 56*nch
+  if(ndi.gt.8) ndi=ndi-56
+!  print*,'Z',i1pk,ndi,msg
+!  call flush(53)
+
+  return
+end subroutine searchms

Copied: trunk/setupms.f90 (from rev 2228, wsjt7a/setupms.f90)
===================================================================
--- trunk/setupms.f90	                        (rev 0)
+++ trunk/setupms.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,51 @@
+subroutine setupms(cw,cwb)
+
+! Calculate the JTMS character waveforms.
+
+  complex cw(56,0:63)
+  complex cwb(56)
+  integer nb(7)
+!  real*8 twopi,dt,f0,f1
+  character cc*64
+!                   1         2         3         4         5         6
+!          0123456789012345678901234567890123456789012345678901234567890123
+  data cc/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ./?-                 _     @'/
+
+  nsps=8
+  twopi=8*atan(1.d0)
+  dt=1.d0/11025.d0                     !Sample interval
+  f0=1155.46875d0
+  f1=1844.53125d0
+  dphi0=twopi*dt*f0
+  dphi1=twopi*dt*f1
+
+  do i=0,63
+     k=0
+     m=0
+     do n=5,0,-1                          !Each character gets 6+1 bits
+        k=k+1
+        nb(k)=iand(1,ishft(i,-n))
+        m=m+nb(k)
+     enddo
+     k=k+1
+     nb(k)=iand(m,1)                      !Insert parity bit
+
+     phi=0.
+     j=0
+     do k=1,7                             !Generate the waveform
+        if(nb(k).eq.0) then
+           dphi=dphi0
+        else
+           dphi=dphi1
+        endif
+        do ii=1,nsps
+           j=j+1
+           phi=phi+dphi
+           cw(j,i)=cmplx(cos(phi),sin(phi))
+        enddo
+     enddo
+  enddo
+  cwb=cw(1:56,57)
+
+  return
+end subroutine setupms

Copied: trunk/smo.f90 (from rev 2228, wsjt7a/smo.f90)
===================================================================
--- trunk/smo.f90	                        (rev 0)
+++ trunk/smo.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,23 @@
+subroutine smo(x,npts,y,nadd)
+
+  real x(npts)
+  real y(npts)
+
+  nh=nadd/2
+  do i=1+nh,npts-nh
+     sum=0.
+     do j=-nh,nh
+        sum=sum + x(i+j)
+     enddo
+     y(i)=sum
+  enddo
+  y(:nh)=0.
+  y(npts-nh+1:)=0.
+
+  fac=1.0/nadd
+  do i=1,npts
+     x(i)=fac*y(i)
+  enddo
+
+  return
+end subroutine smo

Modified: trunk/spec.f90
===================================================================
--- trunk/spec.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/spec.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -55,12 +55,10 @@
   nmode=1
   if(mode(1:4).eq.'JT65') nmode=2
   if(mode(1:4).eq.'Echo') nmode=3
-  if(mode(1:4).eq.'JT6M') nmode=4
   if(mode(1:2).eq.'CW') nmode=5
-  if(mode(1:3).eq.'JT2') nmode=6
   if(mode(1:3).eq.'JT4') nmode=7
-  if(mode(1:4).eq.'WSPR') nmode=8
-  if(mode(1:4).eq.'JT64') nmode=9
+  if(mode(1:4).eq.'JTMS') nmode=8
+  if(mode(1:5).eq.'ISCAT') nmode=9
 
   nlines=0
   newdat=0
@@ -88,7 +86,7 @@
      kread=kread+istep                       !Update pointer
   else
 ! Real-time data
-     dgain=2.0*10.0**(0.005*ngain)
+     dgain=2.0*10.0**(0.015*ngain)
      k=iread
      do i=1,nfft
         k=k+1
@@ -196,7 +194,7 @@
 
 !  Compute pixel values 
   iz=750
-  logmap=0
+!  logmap=0
   if(brightness.ne.b0 .or. contrast.ne.c0 .or. logmap.ne.logmap0 .or.    &amp;
           nspeed.ne.nspeed0 .or. nlines.gt.1) then
      iz=225000

Copied: trunk/specdiana.f90 (from rev 2228, wsjt7a/specdiana.f90)
===================================================================
--- trunk/specdiana.f90	                        (rev 0)
+++ trunk/specdiana.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,56 @@
+subroutine specdiana(dat,npts,s0,jsym,fs0)
+
+  parameter (NSZ=646)
+  real dat(npts)                          !Raw signal, 30 s at 11025 sps
+  real x(4096),x2(4096)
+  complex c(0:4096)
+  real s0(1024,NSZ)                       !Symbol spectra at 1/4-symbol steps
+  real fs0(1024,96)                       !Folded-for-sync spectra
+  real b(1024)
+  equivalence (x,c)
+
+  nsps=2048
+  nblk=24
+  nsym=npts/nsps                      !Total symbol intervals in file
+  nfft=4096                           !Do FFTs at twice the symbol length
+  kstep=nsps/4                        !Step by 1/4 symbol
+  nq=nfft/4
+  fac=1.0/1000.0                      !Somewhat arbitrary
+
+  ia=1-kstep
+  do j=1,4*nsym                       !Compute symbol spectra
+     ia=ia+kstep
+     ib=ia+nsps-1
+     if(ib.gt.npts) go to 10
+     x(1:nsps)=fac*dat(ia:ib)
+     x(nsps+1:nfft)=0.
+     call four2a(x,nfft,1,-1,0)
+     do i=1,nq
+        s0(i,j)=real(c(i))**2 + aimag(c(i))**2
+     enddo
+  enddo
+
+10 jsym=j-1
+
+  do i=1,nq                           !Find baseline
+     x(1:jsym)=s0(i,1:jsym)
+     call pctile(x,x2,jsym,30,b(i))
+  enddo
+  b(1:10)=b(11)
+  nadd=51
+  call smo(b,nq,x2,nadd)              !Smooth the baseline
+
+  do j=1,jsym                         !Normalize the spectra
+     s0(1:nq,j)=s0(1:nq,j)/b(1:nq)
+  enddo
+
+  fs0=0.
+  jb=(jsym-4*nblk+1)/4
+  jb=4*jb
+  do j=1,jb                           !Fold s0 into fs0, modulo 4*nblk
+     k=mod(j-1,4*nblk)+1
+     fs0(1:nq,k)=fs0(1:nq,k) + s0(1:nq,j)
+  enddo
+
+  return
+end subroutine specdiana

Modified: trunk/sun.f
===================================================================
--- trunk/sun.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/sun.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,4 +1,4 @@
-      subroutine sun(y,m,DD,UT,lon,lat,RA,Dec,LST,Az,El,mjd)
+      subroutine sun(y,m,DD,UT,lon,lat,RA,Dec,LST,Az,El,mjd,day)
 
       implicit none
 
@@ -35,6 +35,7 @@
       real xhor,yhor,zhor
       real Az,El
 
+      real day
       real rad
       data rad/57.2957795/
 
@@ -81,6 +82,7 @@
       zhor = xx*cos(lat/rad) + zz*sin(lat/rad)
       Az = mod(rad*atan2(yhor,xhor) + 180.0 + 360.0,360.0)
       El = rad*asin(zhor)
+      day=d-1.5
 
       return
       end

Deleted: trunk/sync162.f
===================================================================
--- trunk/sync162.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/sync162.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,211 +0,0 @@
-      subroutine sync162(c2,jz,mousedf,ndftol,ccfblue,ccfred,ps,sstf,kz)
-
-C  Find WSPR sync signals, with best-fit DT and DF.  
-
-      complex c2(jz)
-      parameter (NFFT=512)             !Length of FFTs
-      parameter (NH=NFFT/2)            !Length of power spectra
-      parameter (NSMAX=351)            !Number of half-symbol steps
-      parameter (NF0=136,NF1=10)
-      parameter (LAGMAX=26)
-      real ccfblue(-5:540)
-      real ccfred(-224:224)
-      real psavg(-NH:NH)               !Average spectrum of whole record
-      real s2(-NH:NH,NSMAX)            !2d spectrum, stepped by half-symbols
-      real ps(-NH:NH)
-      real psmo(-NH:NH)
-      real freq(-NH:NH)
-      real p1(-NH:NH)
-      real drift(-NH:NH)
-      real dtx(-NH:NH)
-      integer keep0(-NH:NH)
-      integer keep(-NH:NH)
-      real a(5)
-      real sstf(5,275)
-      real tmp(275)
-      integer npr3(162)
-      real pr3(162)
-      data npr3/
-     +  1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,
-     +  0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,
-     +  0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,
-     +  1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,
-     +  0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,1,0,
-     +  0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,
-     +  0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,1,
-     +  0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,
-     +  0,0/
-      save
-
-      call zero(ccfblue,546)
-      call zero(ccfred,449)
-      nsym=162
-      do i=1,nsym
-         pr3(i)=2*npr3(i)-1
-      enddo
-      if(ndftol.eq.-999) go to 999            !Silence compiler warning
-
-C  Do FFTs of twice symbol length, stepped by half symbols.  
-      nq=NFFT/4
-      nsteps=jz/nq - 1
-      df=375.0/NFFT
-      dt=1.0/375.0
-      call zero(psavg,NFFT+1)
-
-C  Compute power spectrum for each step, and get average
-      do j=1,nsteps
-         k=(j-1)*nq + 1
-         call ps162(c2(k),s2(-NH,j))
-         call add(psavg,s2(-NH,j),psavg,NFFT)
-      enddo
-
-! Normalize and subtract baseline from psavg.
-      call pctile(psavg(-136),tmp,273,35,base)
-      psavg=psavg/base - 1.0
-      base=base/351.0
-      s2=s2/base - 1.0
-
-! Boxcar-smooth the average spectrum over the WSPR signal bandwidth.
-      do i=-NH+3,NH-3
-         psmo(i)=0.
-         do k=-3,3
-            psmo(i)=psmo(i)+ps(i+k)
-         enddo
-         psmo(i)=psmo(i)/7.0
-      enddo
-
-! Mark potential suspects for WSPR signals.  
-! (Keep only the best one within a surrounding range of +/- 8 bins.)
-
-      plimit=0.                      !### Are the plimit values OK? ###
-      i0=0
-      nfa=i0-nint(ndftol/df)
-      nfb=i0+nint(ndftol/df)
-!      do i=-NF0,NF0
-      do i=nfa,nfb
-         keep0(i)=0
-         keep(i)=0
-         ia=i-4
-         ib=i+4
-         pmax=-1.e30
-         do ii=ia,ib
-            if(psmo(ii).gt.pmax) then
-               ipk=ii
-               pmax=psmo(ii)
-            endif
-         enddo
-         if(ipk.eq.i .and. pmax.ge.plimit) then
-            keep0(i)=1
-! Kill all smaller peaks leading up to this maximum.
-            do ii=ia,i-1
-               keep0(ii)=0
-            enddo
-         endif
-      enddo
-
-! Now mark the bins +/- 1 from each one already marked.
-      do i=nfa+1,nfb-1
-         if(keep0(i).eq.1) then
-            keep(i-1)=1
-            keep(i)=1
-            keep(i+1)=1
-         endif
-      enddo
-
-! Now do the main search over DT, DF, and drift.  (Do CCFs in all marked
-! frequency bins and over a range of reasonable fdot values and lags.)
-      i00=nint(mousedf/df)
-      p1=0.
-      do i=nfa,nfb
-         if(keep(i).eq.0) go to 10
-         smax=0.
-         do k=-NF1,NF1
-            if(abs(k).ne.1) then
-               do lag=0,LAGMAX
-                  sum=0.
-                  n=lag-1
-                  do j=1,162
-                     n=n+2
-                     ii=i + nint(k*(j-81)/162.0)
-                     x=max(s2(ii-1,n),s2(ii+3,n)) - 
-     +                    max(s2(ii-3,n),s2(ii+1,n))
-                     sum=sum + x*pr3(j)
-                  enddo
-                  if(sum.gt.smax) then
-                     kpk=k
-                     lagpk=lag
-                     smax=sum
-                  endif
-               enddo
-            endif
-         enddo
-
-! Save the CCF value, frequency, drift rate, and DT.
-         p1(i)=smax
-         freq(i)=df*i
-         drift(i)=df*kpk
-         dtx(i)=128.0*dt*lagpk
-         spk=db(smax)-22.0
-         if(spk.gt.0.0 .and. abs(i+i00).le.224) ccfred(i+i00)=0.25*spk
- 10      continue
-      enddo
-
-! Eliminate potential duplicates and peaks smaller than plimit.
-      keep=0
-      plimit=10.0*plimit                             !### ??? ###
-      do i=nfa,nfb
-         ia=max(nfa,i-8)
-         ib=min(nfb,i+8)
-         pmax=-1.e30
-         do ii=ia,ib
-            if(p1(ii).gt.pmax) then
-               ipk=ii
-               pmax=p1(ii)
-            endif
-         enddo
-         if(ipk.eq.i .and. pmax.ge.plimit) then
-            keep(i)=1
-            do ii=ia,i-1
-               keep(ii)=0
-            enddo
-         endif
-      enddo
-
-! Compress the candidate list, saving only the potentially important ones.
-! Recalibrate sync indicator p1 on a dB scale.  
-! (NB: p1 sould be compared with snrx!)
-      k=0
-      do i=nfa,nfb
-         if(keep(i).ne.0) then
-            x=db(p1(i)) - 22       !### ??? ###
-            if(x.ge.0.5) then
-               k=k+1
-               p1(k)=x
-               freq(k)=freq(i)
-               drift(k)=drift(i)
-               dtx(k)=dtx(i) - 2.0
-            endif
-         endif
-      enddo
-      kz=k
-
-      do k=1,kz
-         a(1)=-freq(k) + 1.4648   !### Why is this offset necessary? ###
-         a(2)=-0.5*drift(k)
-         a(3)=0.
-         lagpk=nint((dtx(k)+2)/(128*dt))
-         lag1=-200
-         lag2=200
-         ccf=-fchisq(c2,jz,375.0,a,lag1,lag2,ccfbest,dtbest)
-         ipk=nint(freq(k)/df)
-         snrx=db(max(psavg(ipk),0.0001)) - 26.5         !Empirical
-         sstf(1,k)=ccfbest
-         sstf(2,k)=snrx
-         sstf(3,k)=dtbest-2.0
-         sstf(4,k)=freq(k)
-         sstf(5,k)=drift(k)
-      enddo
-      
- 999  return
-      end
-

Modified: trunk/sync24.f
===================================================================
--- trunk/sync24.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/sync24.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,7 +1,7 @@
       subroutine sync24(dat,jz,DFTolerance,NFreeze,MouseDF,
      +  mode,mode4,dtx,dfx,snrx,snrsync,ccfblue,ccfred1,flip,width)
 
-C  Synchronizes JT2 and JT4 data, finding the best-fit DT and DF.  
+C  Synchronizes JT4 data, finding the best-fit DT and DF.  
 
       parameter (NFFTMAX=2520)         !Max length of FFTs
       parameter (NHMAX=NFFTMAX/2)      !Max length of power spectra
@@ -67,7 +67,7 @@
 
       call zero(ccfred,901)
       do i=ia,ib
-         call xcor24(s2,i,nsteps,nsym,lag1,lag2,mode,mode4,
+         call xcor24(s2,i,nsteps,nsym,lag1,lag2,mode4,
      +        ccfblue,ccf0,lagpk0,flip)
          j=i-i0
          if(mode.eq.7) j=j + 3*mode4
@@ -111,7 +111,7 @@
       if(mode.eq.7) dfx=dfx + 3*mode4*df
 
 C  Peak up in time, at best whole-channel frequency
-      call xcor24(s2,ipk,nsteps,nsym,lag1,lag2,mode,mode4,
+      call xcor24(s2,ipk,nsteps,nsym,lag1,lag2,mode4,
      +  ccfblue,ccfmax,lagpk,flip)
       xlag=lagpk
       if(lagpk.gt.lag1 .and. lagpk.lt.lag2) then

Deleted: trunk/sync64.f
===================================================================
--- trunk/sync64.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/sync64.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,148 +0,0 @@
-      subroutine sync64(dat,jz,DFTolerance,NFreeze,MouseDF,
-     +  mode64,dtx,dfx,snrx,snrsync,ccfblue,ccfred1,flip,width)
-
-C  Synchronizes JT64 data, finding the best-fit DT and DF.  
-C  NB: at this stage, submodes ABC are processed in the same way.
-
-      parameter (NP2=30*11025)         !Size of data array
-      parameter (NFFTMAX=4096)         !Max length of FFTs
-      parameter (NHMAX=NFFTMAX/2)      !Max length of power spectra
-      parameter (NSMAX=160)            !Max number of half-symbol steps
-      integer DFTolerance              !Range of DF search
-      real dat(jz)
-      real psavg(NHMAX)                !Average spectrum of whole record
-      real s2(NHMAX,NSMAX)             !2d spectrum, stepped by half-symbols
-      real ccfblue(-5:540)             !CCF with pseudorandom sequence
-
-C  The value 450 is empirical:
-      real ccfred1(-224:224)           !Peak of ccfblue, as function of freq
-      real ccf64(-224:224)
-      integer ic6(6)
-      integer isync(63)
-      data ic6/0,1,4,3,5,2/,idum/-1/
-      save
-
-C  Do FFTs of symbol length, stepped by half symbols.  Note that we have
-C  already downsampled the data by factor of 2.
-      nsym=63
-      nfft=4096
-      nsteps=2*jz/nfft - 1
-      nh=nfft/2
-      df=0.5*11025.0/nfft
-! Set up the JT64 sync pattern
-      isync=-1
-      do n=1,3
-         i0=0
-         if(n.eq.2) i0=28
-         if(n.eq.3) i0=57
-         do i=1,6
-            isync(i0+i)=ic6(i)
-         enddo
-      enddo
-      nsync=18
-
-C  Compute power spectrum for each step and get average
-      call zero(psavg,nh)
-      do j=1,nsteps
-         k=(j-1)*nh + 1
-         call limit(dat(k),nfft)
-         call ps(dat(k),nfft,s2(1,j))
-         if(mode64.eq.4) call smooth(s2(1,j),nh)
-         call add(psavg,s2(1,j),psavg,nh)
-      enddo
-
-!      call flat1(psavg,s2,nh,nsteps,NHMAX,NSMAX)        !Flatten the spectra
-!      do i=1,nh
-!         write(42,4001) i*df,psavg(i)
-! 4001    format(2f10.3)
-!      enddo
-
-C  Find the best frequency channel for CCF
-      famin=3.
-      fbmax=2700.
-
-      fa=famin
-      fb=fbmax
-      if(NFreeze.eq.1) then
-         fa=max(famin,1270.46+MouseDF-DFTolerance)
-         fb=min(fbmax,1270.46+MouseDF+DFTolerance)
-      else
-         fa=max(famin,1270.46+MouseDF-600)
-         fb=min(fbmax,1270.46+MouseDF+600)
-      endif
-      ia=fa/df
-      ib=fb/df
-      i0=nint(1270.46/df)
-      syncbest=-1.e30
-      call zero(ccfred1,449)
-
-C### Following code probably needs work!
-      ss=0.
-      nss=0
-      do i=ia,ib
-         smax=-1.e30
-         do lag=-20,20
-            sum=0.
-            do j=1,nsym
-               if(isync(j).ge.0) then
-                  j0=2*j -1 + lag
-                  if(j0.ge.1 .and. j0.le.nsteps) then
-                     sum=sum + s2(2*isync(j)+i,j0)
-                  endif
-               endif
-            enddo
-            ccf64(lag)=sum/nsync
-            if(ccf64(lag).gt.smax) smax=ccf64(lag)
-         enddo
-         j=i-i0
-         if(abs(j).le.224) then
-            ccfred1(i-i0)=smax
-            ss=ss+smax
-            nss=nss+1
-         endif
-         if(smax.gt.syncbest) then
-            syncbest=smax
-            ipk=i
-         endif
-      enddo
-      ave=ss/nss
-      syncbest=syncbest-ave
-      do j=-224,224
-         if(ccfred1(j).ne.0.0) ccfred1(j)=0.2*(ccfred1(j)-ave)
-      enddo
-
-! Once more, at the best frequency
-      i=ipk
-      syncbest=-1.e30
-      rewind 41
-
-      dtstep=0.37151927
-      do lag=-20,20
-         sum=0.
-         do j=1,nsym
-            if(isync(j).ge.0) then
-               j0=2*j - 1 + lag
-               if(j0.ge.1 .and. j0.le.nsteps) then
-                  sum=sum + s2(2*isync(j)+i,j0)
-               endif
-            endif
-         enddo
-         ccf64(lag)=sum/nsync
-            if(ccf64(lag).gt.syncbest) then
-               lagpk=lag
-               syncbest=ccf64(lag)
-            endif
-!         write(41,3001) lag,dtstep*lag,ccf64(lag)
-! 3001    format(i5,2f10.3)
-         ccfblue(lag+15)=ccf64(lag)
-      enddo
-
-      snrsync=syncbest
-      snrx=-30
-      if(syncbest.gt.2.0) snrx=db(syncbest) - 34.0
-      dtx=dtstep*lagpk
-      dfx=(ipk-i0)*df
-
-      return
-      end
-

Copied: trunk/syncdiana.f90 (from rev 2228, wsjt7a/syncdiana.f90)
===================================================================
--- trunk/syncdiana.f90	                        (rev 0)
+++ trunk/syncdiana.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,92 @@
+subroutine syncdiana(fs0,kstep,nfreeze,mousedf,dftolerance,syncx,     &amp;
+     ipk,jpk,dfx,dtx,msglen,ccfblue,ccfred)
+
+  real fs0(1024,96)                       !Folded-for-sync spectra
+  real ccfblue(-5:540)
+  real ccfred(-224:224)
+  integer dftolerance
+  integer isync(4)
+  data isync/8,16,32,24/
+
+  df=11025.0/4096.0
+  nblk=24
+  i0=2*236
+  smax=0.
+  ipk=9999
+  jpk=9999
+
+  ia=-600.0/df
+  ib=600.0/df
+  if(nfreeze.eq.1) then
+     ia=(mousedf-dftolerance)/df
+     ib=(mousedf+dftolerance)/df
+  endif
+
+  do i=ia,ib                          !Search over DF range
+     sm1=0.
+     do j=0,4*nblk-1                  !Find sync pattern, lags 0-95
+        ss=0.
+        do n=1,4                      !Sum the four sync tones
+           k=j+4*n-3
+           if(k.gt.4*nblk) k=k-4*nblk
+           ss=ss + fs0(i0+i+2*isync(n),k)
+        enddo
+        if(ss.gt.sm1) then
+           sm1=ss
+           jpk1=j+1
+        endif
+        if(abs(i).le.224) ccfred(i)=sm1
+     enddo
+     if(sm1.gt.smax) then
+        smax=sm1
+        ipk=i0+i                   !Frequency offset, DF
+        jpk=jpk1
+     endif
+  enddo
+
+  dfx=(ipk-i0)*df
+  dtx=jpk*kstep/11025.0 - 1.4
+
+  ref=fs0(ipk+2,jpk) + fs0(ipk+4,jpk) + fs0(ipk+6,jpk)
+  j=jpk+4
+  if(j.gt.96) j=j-96
+  ref=ref + fs0(ipk,j) + fs0(ipk+4,j) + fs0(ipk+6,j)
+  j=jpk+8
+  if(j.gt.96) j=j-96
+  ref=ref + fs0(ipk,j) + fs0(ipk+2,j) + fs0(ipk+4,j)
+  j=jpk+12
+  if(j.gt.96) j=j-96
+  ref=ref + fs0(ipk,j) + fs0(ipk+2,j) + fs0(ipk+6,j)
+
+  ref=ref/3.0                         !Reference level near (DF,DT)
+  ccfred=0.5*ccfred/ref - 1.0
+  syncx=smax/ref - 1.0
+
+  kk=0
+  do j=0,4*nblk-1                     !Compute ccfblue
+     ss=0.
+     do n=1,4
+        k=j+4*n-3
+        if(k.gt.4*nblk) k=k-4*nblk
+        ss=ss + fs0(ipk+2*isync(n),k)
+     enddo
+     jj=mod(j+80,96) - 5
+     ccfblue(jj)=0.5*(ss/ref - 1.0)
+  enddo
+
+  smax=0.
+  ja=jpk+16
+  if(ja.gt.4*nblk) ja=ja-4*nblk
+  jb=jpk+20
+  if(jb.gt.4*nblk) jb=jb-4*nblk
+  do i=ipk+2,ipk+56,2                         !Find User's message length
+     ss=fs0(i,ja) + fs0(i+10,jb)
+     if(ss.gt.smax) then
+        smax=ss
+        ipk2=i
+     endif
+  enddo
+  msglen=(ipk2-ipk)/2
+
+  return
+end subroutine syncdiana

Copied: trunk/syncms.f90 (from rev 2228, wsjt7a/syncms.f90)
===================================================================
--- trunk/syncms.f90	                        (rev 0)
+++ trunk/syncms.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,36 @@
+subroutine syncms(cdat,npts,cwb,r,i1)
+
+! Establish character sync within a JTMS ping.
+
+  complex cdat(npts)                    !Analytic signal
+  complex cwb(56)                       !Complex waveform for 'space'
+  real r(60000)
+  real tmp(60000)
+  integer hist(56),hmax(1)
+  complex z
+
+  r=0.
+  jz=npts-55
+  do j=1,jz
+     z=0.
+     ss=0.
+     do i=1,56
+        ss=ss + abs(cdat(i+j-1))          !Total power
+        z=z + cdat(i+j-1)*conjg(cwb(i))   !Signal matching &lt;space&gt;
+     enddo
+     r(j)=abs(z)/ss                       !Goodness-of-fit to &lt;space&gt;
+  enddo
+
+  ncut=99.0*float(jz-10)/float(jz)
+  call pctile(r,tmp,jz,ncut,rlim)
+  hist=0
+  do j=1,jz
+     k=mod(j-1,56)+1
+     if(r(j).gt.rlim) hist(k)=hist(k)+1
+  enddo
+
+  hmax=maxloc(hist)
+  i1=hmax(1)
+
+  return
+end subroutine syncms

Copied: trunk/t72.f90 (from rev 2228, wsjt7a/t72.f90)
===================================================================
--- trunk/t72.f90	                        (rev 0)
+++ trunk/t72.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,72 @@
+program t72
+
+! Tests experimental FSK441 decoder
+
+  parameter (NMAX=512*1024)
+  parameter (MAXFFT=8192)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  character arg*12                        !Command-line argument
+  character cfile6*6                      !File time
+  character frag*28                       !Message fragment to be matched
+  character infile*40
+  integer dftolerance
+  logical pick
+  real pingdat(3,100)                     !Detected pings
+  character c*48
+  common/scratch/work(NMAX)
+  data c/' 123456789.,?/# $ABCD FGHIJKLMNOPQRSTUVWXY 0EZ*!'/
+
+  nargs=iargc()
+  if(nargs.ne.3) then
+     print*,'Usage: t72 infile nrec frag'
+     go to 999
+  endif
+  call getarg(1,infile)
+  call getarg(2,arg)
+  read(arg,*) nrec
+  call getarg(3,frag)
+  open(72,file=infile,form='unformatted',status='old')
+
+! Initialize variables
+  minsigdb=2
+  minwidth=40
+  dftolerance=400
+  pick=.false.
+  nsps=25
+  nsam=nsps*ndits
+  xn=log(float(nsam))/log(2.0)
+  n=xn
+  if(xn-n .gt.0.001) n=n+1
+  cfile6='441++'
+
+  do irec=1,nrec
+     read(72,end=999) jz,nz,cfile6,(dat(j),j=1,jz)
+     if(irec.ne.nrec .and. nrec.ne.999) go to 900
+
+     call ping441(dat,jz,nz,MinSigdB,MinWidth,pick,pingdat,nping)   !Find pings
+
+     do iping=1,nping                        !Process each ping
+        tstart=pingdat(1,iping)
+        width=pingdat(2,iping)
+        peak=pingdat(3,iping)
+        npeak=peak
+!  Assemble a signal report:
+        nwidth=0
+        if(width.ge.0.04) nwidth=1     !These might depend on NSPD
+        if(width.ge.0.12) nwidth=2
+        if(width.gt.1.00) nwidth=3
+        nstrength=6
+        if(peak.ge.11.0) nstrength=7
+        if(peak.ge.17.0) nstrength=8
+        if(peak.ge.23.0) nstrength=9
+        nrpt=10*nwidth + nstrength
+
+        t2=tstart
+        call pp441(dat,jz,cfile6,tstart,t2,width,npeak,nrpt,           &amp;
+             dftolerance,frag,1)
+     enddo
+
+900  continue
+  enddo
+
+999 end program t72

Copied: trunk/t73.f90 (from rev 2228, wsjt7a/t73.f90)
===================================================================
--- trunk/t73.f90	                        (rev 0)
+++ trunk/t73.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,139 @@
+program t73
+
+! Tests experimental JT6M decoder
+
+  parameter (NMAX=512*1024)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  complex cdat(NMAX)                      !Analytic form of signal
+  complex z
+  character arg*12                        !Command-line argument
+  character cfile6*6                      !File time
+  character frag*28                       !Message fragment to be matched
+!  character msg*40
+!  complex cfrag(2100)                     !Complex waveform of message fragment
+  real s(NMAX)
+  real sym(646)
+  real fsym(0:2)
+  real ccf(-20000:20000)
+  integer dftolerance
+  real*8 twopi8,dt8,f08
+  common/scratch/work(NMAX)
+
+  nargs=iargc()
+  if(nargs.ne.2) then
+     print*,'Usage: t73 nfile frag'
+     go to 999
+  endif
+  call getarg(1,arg)
+  read(arg,*) nfile
+  call getarg(2,frag)
+  open(73,file='dat.73',form='unformatted',status='old')
+
+  do i=28,1,-1                          !Get length of fragment
+     if(frag(i:i).ne.' ') go to 10
+  enddo
+10 nfrag=i
+
+  nsps=512
+  twopi8=8.d0*atan(1.d0)
+  dt8=1.d0/11025.d0
+  f08=50*11025.d0/nsps
+  f0=f08
+  dftolerance=40
+  ipk=0
+  
+  do ifile=1,nfile
+     read(73,end=999) jz,nz,cfile6,(dat(j),j=1,jz)
+     if(ifile.ne.nfile .and. nfile.ne.999) go to 900
+
+!     do i=1,jz
+!        j=(i-1)/512
+!        dat(i)=0.
+!        if(mod(j,3).eq.1) dat(i)=sin(twopi8*i*dt8*f08)
+!     enddo
+
+     npts=jz
+     xn=log(float(npts))/log(2.0)
+     n=xn
+     if(xn-n .gt.0.001) n=n+1
+     nfft1=2**n
+     nh1=nfft1/2
+     nq1=nfft1/4
+     df1=11025.0/nfft1
+     ia=nint(11025.0/(3.0*nsps*df1))
+     ib=nint(dftolerance/df1)
+     i0=nint(f0/df1)
+
+     call analytic(dat,npts,nfft1,s,cdat)        !Convert to analytic signal
+
+     do i=-ib,ib
+        ccf(i)=0.46*s(i0+i) + 0.27*(s(i0+i-ia)+s(i0+i+ia))
+     enddo
+
+     nadd=nint(1.0/df1)
+     call smo(ccf(-ib),2*ib+1,work,nadd)
+
+     ccfmax=0.
+     do i=-ib,ib
+        if(ccf(i).gt.ccfmax) then
+           ccfmax=ccf(i)
+           ipk=i
+        endif
+        freq=i*df1
+        write(13,3001) i,freq,1000.0*ccf(i)
+3001    format(i8,2f12.3)
+     enddo
+
+     dfx=ipk*df1
+
+! DF is known, now find symbol sync.
+     call tweak1(cdat,npts,-f0-dfx,cdat)
+
+     nrpt=npts/1536-1
+     ymax=0.
+     jpk=0
+     do j=0,1535
+        y=0.
+        do n=0,nrpt-1
+           k=n*1536 + j
+           z=0.
+           do i=1,512
+              k=k+1
+              z=z+cdat(k)
+           enddo
+           y=y + abs(z)
+        enddo
+        write(14,3002) j,y
+3002    format(i8,f12.3)
+        if(y.gt.ymax) then
+           ymax=y
+           i1=j
+        endif
+     enddo
+
+! OK, we have DF and starting sample, i1.  Compute symbol amplitudes.
+        nsym=(npts-i1+1)/(3*512)
+        nsym=3*nsym
+        fsym=0.
+        k=i1-1
+        do j=1,nsym
+           z=0.
+           do i=1,512
+              k=k+1
+              z=z+cdat(k)
+           enddo
+           sym(j)=abs(z)
+           i=mod(j-1,3)
+           fsym(i)=fsym(i)+sym(j)
+           write(16,3005) j,sym(j)
+3005       format(i4,f12.3)
+        enddo
+        fsmin=min(fsym(0),fsym(1),fsym(2))
+        print*,fsym/fsmin
+
+     print*,ifile,f0,dfx,jpk
+
+900  continue
+  enddo
+
+999 end program t73

Copied: trunk/t74.f90 (from rev 2228, wsjt7a/t74.f90)
===================================================================
--- trunk/t74.f90	                        (rev 0)
+++ trunk/t74.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,38 @@
+program t74
+
+! Tests experimental Diana decoder
+
+  parameter (NMAX=512*1024)
+  real dat(NMAX)                          !Raw signal, 30 s at 11025 sps
+  character arg*12                        !Command-line argument
+  character cfile6*6                      !File time
+  character msg*28
+  character*40 infile
+  real ccfblue(-5:540)                        !blue line
+  integer dftolerance
+
+  nargs=iargc()
+  if(nargs.ne.2) then
+     print*,'Usage: t74 infile nrec'
+     go to 999
+  endif
+  call getarg(1,infile)
+  call getarg(2,arg)
+  read(arg,*) nrec
+  open(74,file=infile,form='unformatted',status='old')
+
+  MinSigdB=0
+  DFTolerance=400
+  NFreeze=1
+  MouseDF=0
+
+  do irec=1,nrec
+     read(74,end=999) jz,cfile6,(dat(j),j=1,jz)
+     if(irec.ne.nrec .and. nrec.ne.999) go to 900
+
+     call diana(dat,jz,cfile6,MinSigdB,DFTolerance,NFreeze,      &amp;
+          MouseDF,ccfblue,ccfred)
+900  continue
+  enddo
+
+999 end program t74

Copied: trunk/techo.f90 (from rev 2228, wsjt7a/techo.f90)
===================================================================
--- trunk/techo.f90	                        (rev 0)
+++ trunk/techo.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,102 @@
+program techo
+
+  parameter (NDZ=28672)
+  parameter (NSYNC=24030)
+  parameter (LAGMAX=NDZ-NSYNC)
+  parameter (NFFT=32768,NH=NFFT/2)
+
+  real d(NDZ)
+  complex cd(NFFT)
+  complex c(NFFT)
+  complex csync(NSYNC)
+  real s(NH)
+  real s2(NFFT)
+  character infile*40,arg*12
+  character*24 fname
+  real*8 dt,pha,dpha,twopi,f,df
+  integer ic27(27)
+  data ic27/1,3,7,15,2,5,11,23,18,8,17,6,13,27,26,24,20,12,25,22,   &amp;
+       16,4,9,19,10,21,14/
+
+  nargs=iargc()
+  if(nargs.ne.3) then
+     print*,'Usage: techo &lt;infile&gt; nrec nw'
+     go to 999
+  endif
+
+  call getarg(1,infile)
+  call getarg(2,arg)
+  read(arg,*) nrec
+  call getarg(3,arg)
+  read(arg,*) nw
+
+  twopi=8*atan(1.d0)
+  dt=1.d0/11025.d0
+  df=11025.d0/890.d0
+
+  pha=0.d0
+  f=1500.d0
+  k=0
+  do j=1,27
+     if(nw.ne.0) f=1500.d0 + (ic27(j)-14)*df
+     dpha=twopi*f*dt
+     do i=1,890
+        pha=pha+dpha
+        k=k+1
+        csync(k)=cmplx(cos(pha),-sin(pha))
+     enddo
+  enddo
+
+  open(26,file=infile,form='unformatted',status='old')
+
+  npts=NDZ
+  df1=11025.0/NFFT
+  fac=1.e-4
+
+  do irec=1,999
+     read(26,end=999) fname,ntime,dop0,doppler,d
+     if(irec.lt.nrec) cycle
+     if(irec.gt.nrec) go to 999
+     print*,fname,ntime,dop0,doppler,irec,nrec
+     d=fac+d
+     call analytic(d,npts,NFFT,s,cd)
+     cd(NDZ+1:)=0.
+
+     sbest=0.
+     do lag=0,LAGMAX,10
+        do i=1,NSYNC
+           c(i)=fac*cd(i+lag)*csync(i)
+        enddo
+        c(NSYNC+1:)=0.
+        call four2a(c,NFFT,1,-1,1)
+        smax=0.
+        do i=1,NFFT
+           s2(i)=real(c(i))**2 + aimag(c(i))**2
+           if(s2(i).gt.smax) then
+              smax=s2(i)
+              ipk=i
+           endif
+        enddo
+        write(14,3002) lag,smax
+3002    format(i6,e15.3)
+        if(smax.gt.sbest) then
+           sbest=smax
+           ibest=ipk
+           lagbest=lag
+           rewind 13
+           do i=1,NFFT
+              f=(i-1)*df1
+              if(i.gt.NFFT/2) f=(i-NFFT-1)*df1
+              if(abs(f).lt.200.0) write(13,3001) f,s2(i),db(s2(i))
+3001          format(3f12.3)
+           enddo
+        endif
+     enddo
+  call flush(13)
+  call flush(14)
+  fbest=(ibest-1)*df1
+  if(ibest.gt.NH+1)   fbest=(ibest-1-NFFT)*df1
+  print*,lagbest,fbest,sbest
+  enddo
+
+999 end program techo

Copied: trunk/thnix_stub.f90 (from rev 2228, wsjt7a/thnix_stub.f90)
===================================================================
--- trunk/thnix_stub.f90	                        (rev 0)
+++ trunk/thnix_stub.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,58 @@
+subroutine cs_init
+  character*12 csub0
+  integer*8 mtx
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+  ltrace=0
+  mtxstate=0
+  csub0='**unlocked**'
+!  call fthread_mutex_init(mtx)
+  return
+end subroutine cs_init
+
+subroutine cs_destroy
+  character*12 csub0
+  integer*8 mtx
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+!  call fthread_mutex_destroy(mtx)
+  return
+end subroutine cs_destroy
+
+subroutine th_create(sub)
+!  call fthread_create(sub,id)
+  return
+end subroutine th_create
+
+subroutine th_exit
+!  call fthread_exit
+  return
+end subroutine th_exit
+
+subroutine cs_lock(csub)
+  character*(*) csub
+  character*12 csub0
+  integer fthread_mutex_lock,fthread_mutex_trylock
+  integer*8 mtx
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+!  n=fthread_mutex_trylock(mtx)
+  if(n.ne.0) then
+! Another thread has already locked the mutex
+!     n=fthread_mutex_lock(mtx)
+     iz=index(csub0,' ')
+     if(ltrace.ge.1) print*,'&quot;',csub,'&quot; requested mutex when &quot;',   &amp;
+          csub0(:iz-1),'&quot; owned it.'
+  endif
+  mtxstate=1
+  csub0=csub
+  if(ltrace.ge.3) print*,'Mutex locked by ',csub
+  return
+end subroutine cs_lock
+
+subroutine cs_unlock
+  character*12 csub0
+  integer*8 mtx
+  common/mtxcom/mtx,ltrace,mtxstate,csub0
+  if(ltrace.ge.3) print*,'Mutex unlocked,',ltrace,mtx,mtxstate,csub0
+  mtxstate=0
+!  call fthread_mutex_unlock(mtx)
+  return
+end subroutine cs_unlock

Copied: trunk/tm2.f90 (from rev 2228, wsjt7a/tm2.f90)
===================================================================
--- trunk/tm2.f90	                        (rev 0)
+++ trunk/tm2.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,14 @@
+subroutine tm2(day,xlat4,xlon4,xl4,b4)
+
+  implicit real*8 (a-h,o-z)
+  parameter (RADS=0.0174532925199433d0)
+
+  real*4 day4,xlat4,xlon4,xl4,b4
+
+  glat=xlat4*RADS
+  glong=xlon4*RADS
+  call tmoonsub(day,glat,glong,el,rv,xl,b,pax)
+  xl4=xl
+  b4=b
+
+end subroutine tm2

Copied: trunk/tmoonsub.c (from rev 2228, wsjt7a/tmoonsub.c)
===================================================================
--- trunk/tmoonsub.c	                        (rev 0)
+++ trunk/tmoonsub.c	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,514 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+#define RADS 0.0174532925199433
+#define DEGS 57.2957795130823
+#define TPI 6.28318530717959
+#define PI 3.1415927
+
+/* ratio of     earth radius to astronomical unit */
+#define ER_OVER_AU 0.0000426352325194252
+
+/* all prototypes here */
+
+double getcoord(int coord);
+void getargs(int argc, char *argv[], int *y, int *m, double *tz, double *glong, double *glat);
+double range(double y);
+double rangerad(double y);
+double days(int y, int m, int dn, double hour);
+double days_(int *y, int *m, int *dn, double *hour);
+void moonpos(double, double *, double *, double *);
+void sunpos(double , double *, double *, double *);
+double moontransit(int y, int m, int d, double timezone, double glat, double glong, int *nt);
+double atan22(double y, double x);
+double epsilon(double d);
+void equatorial(double d, double *lon, double *lat, double *r);
+void ecliptic(double d, double *lon, double *lat, double *r);
+double gst(double d);
+void topo(double lst, double glat, double *alp, double *dec, double *r);
+double alt(double glat, double ha, double dec);
+void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p);
+void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill);
+int daysinmonth(int y, int m);
+int isleap(int y);
+void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
+   double *mrv, double *l, double *b, double *paxis);
+
+static const char
+*usage = &quot;  Usage: tmoon date[yyyymm] timz[+/-h.hh] long[+/-dddmm] lat[+/-ddmm]\n&quot;
+            &quot;example: tmoon 200009 0 -00155 5230\n&quot;;
+
+/*
+  getargs() gets the arguments from the command line, does some basic error
+  checking, and converts arguments into numerical form. Arguments are passed
+  back in pointers. Error messages print to stderr so re-direction of output
+  to file won't leave users blind. Error checking prints list of all errors
+  in a command line before quitting.
+*/
+void getargs(int argc, char *argv[], int *y, int *m, double *tz,
+             double *glong, double *glat) {
+
+  int date, latitude, longitude;
+  int mflag = 0, yflag = 0, longflag = 0, latflag = 0, tzflag = 0;
+  int longminflag = 0, latminflag = 0, dflag = 0;
+
+  /* if not right number of arguments, then print example command line */
+
+  if (argc !=5) {
+    fprintf(stderr, usage);
+    exit(EXIT_FAILURE);
+  }
+
+  date = atoi(argv[1]);
+  *y = date / 100;
+  *m = date - *y * 100;
+  *tz = (double) atof(argv[2]);
+  longitude = atoi(argv[3]);
+  latitude = atoi(argv[4]);
+  *glong = RADS * getcoord(longitude);
+  *glat = RADS * getcoord(latitude);
+
+  /* set a flag for each error found */
+
+  if (*m &gt; 12 || *m &lt; 1) mflag = 1;
+  if (*y &gt; 2500) yflag = 1;
+  if (date &lt; 150001) dflag = 1;
+  if (fabs((float) *glong) &gt; 180 * RADS) longflag = 1;
+  if (abs(longitude) % 100 &gt; 59) longminflag = 1;
+  if (fabs((float) *glat) &gt; 90 * RADS) latflag = 1;
+  if (abs(latitude) % 100 &gt; 59) latminflag = 1;
+  if (fabs((float) *tz) &gt; 12) tzflag = 1;
+
+  /* print all the errors found */
+  
+  if (dflag == 1) {
+    fprintf(stderr, &quot;date: dates must be in form yyyymm, gregorian, and later than 1500 AD\n&quot;);
+  }
+  if (yflag == 1) {
+    fprintf(stderr, &quot;date: too far in future - accurate from 1500 to 2500\n&quot;);
+  }
+  if (mflag == 1) {
+    fprintf(stderr, &quot;date: month must be in range 0 to 12, eg - August 2000 is entered as 200008\n&quot;);
+  }
+  if (tzflag == 1) {
+    fprintf(stderr, &quot;timz: must be in range +/- 12 hours, eg -6 for Chicago\n&quot;);
+  }
+  if (longflag == 1) {
+    fprintf(stderr, &quot;long: must be in range +/- 180 degrees\n&quot;);
+  }
+  if (longminflag == 1) {
+    fprintf(stderr, &quot;long: last two digits are arcmin - max 59\n&quot;);
+  }
+  if (latflag == 1) {
+    fprintf(stderr, &quot; lat: must be in range +/- 90 degrees\n&quot;);
+  }
+  if (latminflag == 1) {
+    fprintf(stderr, &quot; lat: last two digits are arcmin - max 59\n&quot;);
+  }
+
+  /* quits if one or more flags set */
+
+  if (dflag + mflag + yflag + longflag + latflag + tzflag + longminflag + latminflag &gt; 0) {
+    exit(EXIT_FAILURE);
+  }
+  
+}
+
+/*
+   returns coordinates in decimal degrees given the
+   coord as a ddmm value stored in an integer.
+*/
+double getcoord(int coord) {
+  int west = 1;
+  double glg, deg;
+  if (coord &lt; 0) west = -1;
+  glg = fabs((double) coord/100);
+  deg = floor(glg);
+  glg = west* (deg + (glg - deg)*100 / 60);
+  return(glg);
+}
+
+/*
+  days() takes the year, month, day in the month and decimal hours
+  in the day and returns the number of days since J2000.0.
+  Assumes Gregorian calendar.
+*/
+double days(int y, int m, int d, double h) {
+  int a, b;
+  double day;
+  
+  /*
+    The lines below work from 1900 march to feb 2100
+    a = 367 * y - 7 * (y + (m + 9) / 12) / 4 + 275 * m / 9 + d;
+    day = (double)a - 730531.5 + hour / 24;
+  */
+
+  /*  These lines work for any Gregorian date since 0 AD */
+  if (m ==1 || m==2) {
+    m +=12;
+    y -= 1;
+  }
+  a = y / 100;
+  b = 2 - a + a/4;
+  day = floor(365.25*(y + 4716)) + floor(30.6001*(m + 1))
+    + d + b - 1524.5 - 2451545 + h/24;
+  return(day);
+}
+double days_(int *y0, int *m0, int *d0, double *h0) 
+{
+  return days(*y0,*m0,*d0,*h0);
+}
+
+/*
+Returns 1 if y a leap year, and 0 otherwise, according
+to the Gregorian calendar
+*/
+int isleap(int y) {
+  int a = 0;
+  if(y % 4 == 0) a = 1;
+  if(y % 100 == 0) a = 0;
+  if(y % 400 == 0) a = 1;
+  return(a);
+}
+
+/*
+Given the year and the month, function returns the
+number of days in the month. Valid for Gregorian
+calendar.
+*/
+int daysinmonth(int y, int m) {
+  int b = 31;
+  if(m == 2) {
+    if(isleap(y) == 1) b= 29;
+    else b = 28;
+  }
+  if(m == 4 || m == 6 || m == 9 || m == 11) b = 30;
+  return(b);
+}
+
+/*
+moonpos() takes days from J2000.0 and returns ecliptic coordinates
+of moon in the pointers. Note call by reference.
+This function is within a couple of arcminutes most of the time,
+and is truncated from the Meeus Ch45 series, themselves truncations of
+ELP-2000. Returns moon distance in earth radii.
+Terms have been written out explicitly rather than using the
+table based method as only a small number of terms is
+retained.
+*/
+void moonpos(double d, double *lambda, double *beta, double *rvec) {
+  double dl, dB, dR, L, D, M, M1, F, e, lm, bm, rm, t;
+
+  t = d / 36525;
+
+  L = range(218.3164591  + 481267.88134236  * t) * RADS;
+  D = range(297.8502042  + 445267.1115168  * t) * RADS;
+  M = range(357.5291092  + 35999.0502909  * t) * RADS;
+  M1 = range(134.9634114  + 477198.8676313  * t - .008997 * t * t) * RADS;
+  F = range(93.27209929999999  + 483202.0175273  * t - .0034029*t*t)*RADS;
+  e = 1 - .002516 * t;
+
+  dl =      6288774 * sin(M1);
+  dl +=     1274027 * sin(2 * D - M1);
+  dl +=      658314 * sin(2 * D);
+  dl +=      213618 * sin(2 * M1);
+  dl -=  e * 185116 * sin(M);
+  dl -=      114332 * sin(2 * F) ;
+  dl +=       58793 * sin(2 * D - 2 * M1);
+  dl +=   e * 57066 * sin(2 * D - M - M1) ;
+  dl +=       53322 * sin(2 * D + M1);
+  dl +=   e * 45758 * sin(2 * D - M);
+  dl -=   e * 40923 * sin(M - M1);
+  dl -=       34720 * sin(D) ;
+  dl -=   e * 30383 * sin(M + M1) ;
+  dl +=       15327 * sin(2 * D - 2 * F) ;
+  dl -=       12528 * sin(M1 + 2 * F);
+  dl +=       10980 * sin(M1 - 2 * F);
+  lm = rangerad(L + dl / 1000000 * RADS);
+
+  dB =   5128122 * sin(F);
+  dB +=   280602 * sin(M1 + F);
+  dB +=   277693 * sin(M1 - F);
+  dB +=   173237 * sin(2 * D - F);
+  dB +=    55413 * sin(2 * D - M1 + F);
+  dB +=    46271 * sin(2 * D - M1 - F);
+  dB +=    32573 * sin(2 * D + F);
+  dB +=    17198 * sin(2 * M1 + F);
+  dB +=     9266 * sin(2 * D + M1 - F);
+  dB +=     8822 * sin(2 * M1 - F);
+  dB += e * 8216 * sin(2 * D - M - F);
+  dB +=     4324 * sin(2 * D - 2 * M1 - F);
+  bm = dB / 1000000 * RADS;
+
+  dR =    -20905355 * cos(M1);
+  dR -=     3699111 * cos(2 * D - M1);
+  dR -=     2955968 * cos(2 * D);
+  dR -=      569925 * cos(2 * M1);
+  dR +=   e * 48888 * cos(M);
+  dR -=        3149 * cos(2 * F);
+  dR +=      246158 * cos(2 * D - 2 * M1);
+  dR -=  e * 152138 * cos(2 * D - M - M1) ;
+  dR -=      170733 * cos(2 * D + M1);
+  dR -=  e * 204586 * cos(2 * D - M);
+  dR -=  e * 129620 * cos(M - M1);
+  dR +=      108743 * cos(D);
+  dR +=  e * 104755 * cos(M + M1);
+  dR +=       79661 * cos(M1 - 2 * F);
+  rm = 385000.56  + dR / 1000;
+
+  *lambda = lm;
+  *beta = bm;
+  /* distance to Moon must be in Earth radii */
+  *rvec = rm / 6378.14;
+}
+
+/*
+topomoon() takes the local siderial time, the geographical
+latitude of the observer, and pointers to the geocentric
+equatorial coordinates. The function overwrites the geocentric
+coordinates with topocentric coordinates on a simple spherical
+earth model (no polar flattening). Expects Moon-Earth distance in
+Earth radii.    Formulas scavenged from Astronomical Almanac 'low
+precision formulae for Moon position' page D46.
+*/
+
+void topo(double lst, double glat, double *alp, double *dec, double *r) {
+  double x, y, z, r1;
+  x = *r * cos(*dec) * cos(*alp) - cos(glat) * cos(lst);
+  y = *r * cos(*dec) * sin(*alp) - cos(glat) * sin(lst);
+  z = *r * sin(*dec)  - sin(glat);
+  r1 = sqrt(x*x + y*y + z*z);
+  *alp = atan22(y, x);
+  *dec = asin(z / r1);
+  *r = r1;
+}
+
+/*
+moontransit() takes date, the time zone and geographic longitude
+of observer and returns the time (decimal hours) of lunar transit
+on that day if there is one, and sets the notransit flag if there
+isn't. See Explanatory Supplement to Astronomical Almanac
+section 9.32 and 9.31 for the method.
+*/
+
+double moontransit(int y, int m, int d, double tz, double glat, double glong, int *notransit) {
+  double hm, ht, ht1, lon, lat, rv, dnew, lst;
+  int itcount;
+
+  ht1 = 180 * RADS;
+  ht = 0;
+  itcount = 0;
+  *notransit = 0;
+  do {
+    ht = ht1;
+    itcount++;
+    dnew = days(y, m, d, ht * DEGS/15) - tz/24;
+    lst = gst(dnew) + glong;
+    /* find the topocentric Moon ra (hence hour angle) and dec */
+    moonpos(dnew, &amp;lon, &amp;lat, &amp;rv);
+    equatorial(dnew, &amp;lon, &amp;lat, &amp;rv);
+    topo(lst, glat, &amp;lon, &amp;lat, &amp;rv);
+    hm = rangerad(lst -  lon);
+    ht1 = rangerad(ht - hm);
+    /* if no convergence, then no transit on that day */
+    if (itcount &gt; 30) {
+      *notransit = 1;
+      break;
+    }
+  }
+  while (fabs(ht - ht1) &gt; 0.04 * RADS);
+  return(ht1);
+}
+
+/*
+  Calculates the selenographic coordinates of either the sub Earth point
+  (optical libration) or the sub-solar point (selen. coords of centre of
+  bright hemisphere).  Based on Meeus chapter 51 but neglects physical
+  libration and nutation, with some simplification of the formulas.
+*/
+void libration(double day, double lambda, double beta, double alpha, double *l, double *b, double *p) {
+  double i, f, omega, w, y, x, a, t, eps;
+  t = day / 36525;
+  i = 1.54242 * RADS;
+  eps = epsilon(day);
+  f = range(93.2720993 + 483202.0175273 * t - .0034029 * t * t) * RADS;
+  omega = range(125.044555 - 1934.1361849 * t + .0020762 * t * t) * RADS;
+  w = lambda - omega;
+  y = sin(w) * cos(beta) * cos(i) - sin(beta) * sin(i);
+  x = cos(w) * cos(beta);
+  a = atan22(y, x);
+  *l = a - f;
+
+  /*  kludge to catch cases of 'round the back' angles  */
+  if (*l &lt; -90 * RADS) *l += TPI;
+  if (*l &gt; 90 * RADS)  *l -= TPI;
+  *b = asin(-sin(w) * cos(beta) * sin(i) - sin(beta) * cos(i));
+
+  /*  pa pole axis - not used for Sun stuff */
+  x = sin(i) * sin(omega);
+  y = sin(i) * cos(omega) * cos(eps) - cos(i) * sin(eps);
+  w = atan22(x, y);
+  *p = rangerad(asin(sqrt(x*x + y*y) * cos(alpha - w) / cos(*b)));
+}
+
+/*
+  Takes: days since J2000.0, eq coords Moon, ratio of moon to sun distance,
+  eq coords Sun
+  Returns: position angle of bright limb wrt NCP, percentage illumination
+  of Sun
+*/
+void illumination(double day, double lra, double ldec, double dr, double sra, double sdec, double *pabl, double *ill) {
+  double x, y, phi, i;
+  y = cos(sdec) * sin(sra - lra);
+  x = sin(sdec) * cos(ldec) - cos(sdec) * sin(ldec) * cos (sra - lra);
+  *pabl = atan22(y, x);
+  phi = acos(sin(sdec) * sin(ldec) + cos(sdec) * cos(ldec) * cos(sra-lra));
+  i = atan22(sin(phi) , (dr - cos(phi)));
+  *ill = 0.5*(1 + cos(i));
+}
+
+/*
+sunpos() takes days from J2000.0 and returns ecliptic longitude
+of Sun in the pointers. Latitude is zero at this level of precision,
+but pointer left in for consistency in number of arguments.
+This function is within 0.01 degree (1 arcmin) almost all the time
+for a century either side of J2000.0. This is from the 'low precision
+fomulas for the Sun' from C24 of Astronomical Alamanac
+*/
+void sunpos(double d, double *lambda, double *beta, double *rvec) {
+  double L, g, ls, bs, rs;
+
+  L = range(280.461 + .9856474 * d) * RADS;
+  g = range(357.528 + .9856003 * d) * RADS;
+  ls = L + (1.915 * sin(g) + .02 * sin(2 * g)) * RADS;
+  bs = 0;
+  rs = 1.00014 - .01671 * cos(g) - .00014 * cos(2 * g);
+  *lambda = ls;
+  *beta = bs;
+  *rvec = rs;
+}
+
+/*
+this routine returns the altitude given the days since J2000.0
+the hour angle and declination of the object and the latitude
+of the observer. Used to find the Sun's altitude to put a letter
+code on the transit time, and to find the Moon's altitude at
+transit just to make sure that the Moon is visible.
+*/
+double alt(double glat, double ha, double dec) {
+  return(asin(sin(dec) * sin(glat) + cos(dec) * cos(glat) * cos(ha)));
+}
+
+/* returns an angle in degrees in the range 0 to 360 */
+double range(double x) {
+  double a, b;
+  b = x / 360;
+  a = 360 * (b - floor(b));
+  if (a &lt; 0)
+    a = 360 + a;
+  return(a);
+}
+
+/* returns an angle in rads in the range 0 to two pi */
+double rangerad(double x) {
+  double a, b;
+  b = x / TPI;
+  a = TPI * (b - floor(b));
+  if (a &lt; 0)
+    a = TPI + a;
+  return(a);
+}
+
+/*
+gets the atan2 function returning angles in the right
+order and  range
+*/
+double atan22(double y, double x) {
+  double a;
+
+  a = atan2(y, x);
+  if (a &lt; 0) a += TPI;
+  return(a);
+}
+
+/*
+returns mean obliquity of ecliptic in radians given days since
+J2000.0.
+*/
+double epsilon(double d) {
+  double t = d/ 36525;
+  return((23.4392911111111 - (t* (46.8150 + 0.00059*t)/3600)) *RADS);
+}
+
+/*
+replaces ecliptic coordinates with equatorial coordinates
+note: call by reference destroys original values
+R is unchanged.
+*/
+void equatorial(double d, double *lon, double *lat, double *r) {
+  double  eps, ceps, seps, l, b;
+
+  l = *lon;
+  b = * lat;
+  eps = epsilon(d);
+  ceps = cos(eps);
+  seps = sin(eps);
+  *lon = atan22(sin(l)*ceps - tan(b)*seps, cos(l));
+  *lat = asin(sin(b)*ceps + cos(b)*seps*sin(l));
+}
+
+/*
+replaces equatorial coordinates with ecliptic ones. Inverse
+of above, but used to find topocentric ecliptic coords.
+*/
+void ecliptic(double d, double *lon, double *lat, double *r) {
+  double  eps, ceps, seps, alp, dec;
+  alp = *lon;
+  dec = *lat;
+  eps = epsilon(d);
+  ceps = cos(eps);
+  seps = sin(eps);
+  *lon = atan22(sin(alp)*ceps + tan(dec)*seps, cos(alp));
+  *lat = asin(sin(dec)*ceps - cos(dec)*seps*sin(alp));
+}
+
+/*
+returns the siderial time at greenwich meridian as
+an angle in radians given the days since J2000.0
+*/
+double gst( double d) {
+  double t = d / 36525;
+  double theta;
+  theta = range(280.46061837 + 360.98564736629 * d + 0.000387933 * t * t);
+  return(theta * RADS);
+}
+
+void tmoonsub_(double *day, double *glat, double *glong, double *moonalt, 
+   double *mrv, double *l, double *b, double *paxis)
+{
+  double mlambda, mbeta;
+  double malpha, mdelta;
+  double lst, mhr;
+  double tlambda, tbeta, trv;
+
+  lst = gst(*day) + *glong;
+      
+  /* find Moon topocentric coordinates for libration calculations */
+
+  moonpos(*day, &amp;mlambda, &amp;mbeta, mrv);
+  malpha = mlambda;
+  mdelta = mbeta;
+  equatorial(*day, &amp;malpha, &amp;mdelta, mrv);
+  topo(lst, *glat, &amp;malpha, &amp;mdelta, mrv);
+  mhr = rangerad(lst - malpha);
+  *moonalt = alt(*glat, mhr, mdelta);
+      
+  /* Optical libration and Position angle of the Pole */
+
+  tlambda = malpha;
+  tbeta = mdelta;
+  trv = *mrv;
+  ecliptic(*day, &amp;tlambda, &amp;tbeta, &amp;trv);
+  libration(*day, tlambda, tbeta, malpha,  l, b, paxis);
+}

Copied: trunk/tweak1.f90 (from rev 2228, wsjt7a/tweak1.f90)
===================================================================
--- trunk/tweak1.f90	                        (rev 0)
+++ trunk/tweak1.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,24 @@
+subroutine tweak1(ca,jz,f0,cb)
+
+! Shift frequency of analytic signal ca, with output to cb
+
+  complex ca(jz),cb(jz)
+  real*8 twopi
+  complex*16 w,wstep
+  data twopi/0.d0/
+  save twopi
+
+  if(twopi.eq.0.d0) twopi=8.d0*atan(1.d0)
+  w=1.d0
+  dphi=twopi*f0/11025.d0
+  wstep=cmplx(cos(dphi),sin(dphi))
+  x0=0.5*(jz+1)
+  s=2.0/jz
+  do i=1,jz
+     x=s*(i-x0)
+     w=w*wstep
+     cb(i)=w*ca(i)
+  enddo
+
+  return
+end subroutine tweak1

Deleted: trunk/twkfreq.f
===================================================================
--- trunk/twkfreq.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/twkfreq.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,31 +0,0 @@
-      subroutine twkfreq(ca,cb,jz,a)
-
-C  Apply AFC corrections to ca, returning corrected data in cb
-
-      complex ca(jz),cb(jz)
-      real a(5)
-      real*8 twopi
-      complex*16 w,wstep
-      data twopi/0.d0/
-      save twopi
-
-      if(twopi.eq.0.d0) twopi=8.d0*atan(1.d0)
-      w=1.d0
-      wstep=1.d0
-      x0=0.5*(jz+1)
-      s=2.0/jz
-      do i=1,jz
-         x=s*(i-x0)
-         if(mod(i,100).eq.1) then
-            p2=1.5*x*x - 0.5
-!            p3=2.5*(x**3) - 1.5*x
-!            p4=4.375*(x**4) - 3.75*(x**2) + 0.375
-            dphi=(a(1) + x*a(2) + p2*a(3)) * (twopi/375.0)
-            wstep=cmplx(cos(dphi),sin(dphi))
-         endif
-         w=w*wstep
-         cb(i)=w*ca(i)
-      enddo
-
-      return
-      end

Deleted: trunk/unpack50.f
===================================================================
--- trunk/unpack50.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/unpack50.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,30 +0,0 @@
-      subroutine unpack50(dat,n1,n2)
-
-      integer*1 dat(11)
-
-      i=dat(1)
-      i4=iand(i,255)
-      n1=ishft(i4,20)
-      i=dat(2)
-      i4=iand(i,255)
-      n1=n1 + ishft(i4,12)
-      i=dat(3)
-      i4=iand(i,255)
-      n1=n1 + ishft(i4,4)
-      i=dat(4)
-      i4=iand(i,255)
-      n1=n1 + iand(ishft(i4,-4),15)
-      n2=ishft(iand(i4,15),18)
-      i=dat(5)
-      i4=iand(i,255)
-      n2=n2 + ishft(i4,10)
-      i=dat(6)
-      i4=iand(i,255)
-      n2=n2 + ishft(i4,2)
-      i=dat(7)
-      i4=iand(i,255)
-      n2=n2 + iand(ishft(i4,-6),3)
-
-      return
-      end
-

Deleted: trunk/unpackname.f90
===================================================================
--- trunk/unpackname.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/unpackname.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,20 +0,0 @@
-subroutine unpackname(n1,n2,name,len)
-
-  character*9 name
-  real*8 dn
-
-  dn=32768.d0*n1 + n2
-  len=0
-  do i=9,1,-1
-     j=mod(dn,27.d0)
-     if(j.ge.1) then
-        name(i:i)=char(64+j)
-        len=len+1
-     else
-        name(i:i)=' '
-     endif
-     dn=dn/27.d0
-  enddo
-
-  return
-end subroutine unpackname

Modified: trunk/unpackpfx.f90
===================================================================
--- trunk/unpackpfx.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/unpackpfx.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,35 +1,35 @@
-subroutine unpackpfx(ng,call1)
-
-  character*12 call1
-  character*3 pfx
-
-  if(ng.lt.60000) then
-! Add-on prefix of 1 to 3 characters
-     n=ng
-     do i=3,1,-1
-        nc=mod(n,37)
-        if(nc.ge.0 .and. nc.le.9) then
-           pfx(i:i)=char(nc+48)
-        else if(nc.ge.10 .and. nc.le.35) then
-           pfx(i:i)=char(nc+55)
-        else
-           pfx(i:i)=' '
-        endif
-        n=n/37
-     enddo
-     call1=pfx//'/'//call1
-     if(call1(1:1).eq.' ') call1=call1(2:)
-     if(call1(1:1).eq.' ') call1=call1(2:)
-  else
-! Add-on suffix, one character
-     i1=index(call1,' ')
-     nc=ng-60000
-     if(nc.ge.0 .and. nc.le.9) then
-        call1=call1(:i1-1)//'/'//char(nc+48)
-     else if(nc.ge.10 .and. nc.le.35) then
-        call1=call1(:i1-1)//'/'//char(nc+55)
-     endif
-  endif
-
-  return
-end subroutine unpackpfx
+subroutine unpackpfx(ng,call1)
+
+  character*12 call1
+  character*3 pfx
+
+  if(ng.lt.60000) then
+! Add-on prefix of 1 to 3 characters
+     n=ng
+     do i=3,1,-1
+        nc=mod(n,37)
+        if(nc.ge.0 .and. nc.le.9) then
+           pfx(i:i)=char(nc+48)
+        else if(nc.ge.10 .and. nc.le.35) then
+           pfx(i:i)=char(nc+55)
+        else
+           pfx(i:i)=' '
+        endif
+        n=n/37
+     enddo
+     call1=pfx//'/'//call1
+     if(call1(1:1).eq.' ') call1=call1(2:)
+     if(call1(1:1).eq.' ') call1=call1(2:)
+  else
+! Add-on suffix, one character
+     i1=index(call1,' ')
+     nc=ng-60000
+     if(nc.ge.0 .and. nc.le.9) then
+        call1=call1(:i1-1)//'/'//char(nc+48)
+     else if(nc.ge.10 .and. nc.le.35) then
+        call1=call1(:i1-1)//'/'//char(nc+55)
+     endif
+  endif
+
+  return
+end subroutine unpackpfx


Property changes on: trunk/unpackpfx.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Deleted: trunk/unpackprop.f90
===================================================================
--- trunk/unpackprop.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/unpackprop.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,28 +0,0 @@
-subroutine unpackprop(n1,k,muf,ccur,cxp)
-
-  character ccur*4,cxp*2
-
-  muf=mod(n1,62)
-  n1=n1/62
-
-  k=mod(n1,11)
-  n1=n1/11
-
-  j=mod(n1,53)
-  n1=n1/53
-  if(j.eq.0) cxp='*'
-  if(j.ge.1 .and. j.le.26) cxp=char(64+j)
-  if(j.gt.26) cxp=char(64+j-26)//char(64+j-26)
-
-  j=mod(n1,53)
-  n1=n1/53
-  if(j.eq.0) ccur(2:2)='*'
-  if(j.ge.1 .and. j.le.26) ccur(2:2)=char(64+j)
-  if(j.gt.26) ccur(2:3)=char(64+j-26)//char(64+j-26)
-  j=n1
-  if(j.eq.0) ccur(1:1)='*'
-  if(j.ge.1 .and. j.le.26) ccur(1:1)=char(64+j)
-  if(j.gt.26) ccur=char(64+j-26)//char(64+j-26)//ccur(2:3)
-
-  return
-end subroutine unpackprop

Deleted: trunk/unpacktext2.f90
===================================================================
--- trunk/unpacktext2.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/unpacktext2.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,17 +0,0 @@
-subroutine unpacktext2(n1,ng,msg)
-
-  character*22 msg
-  real*8 dn
-  character*41 c
-  data c/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +./?'/
-
-  msg='                      '
-  dn=32768.d0*n1 + ng
-  do i=8,1,-1
-     j=mod(dn,41.d0)
-     msg(i:i)=c(j+1:j+1)
-     dn=dn/41.d0
-  enddo
-
-  return
-end subroutine unpacktext2

Deleted: trunk/wqdecode.f90
===================================================================
--- trunk/wqdecode.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/wqdecode.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,312 +0,0 @@
-subroutine wqdecode(data0,message,ntype)
-
-  parameter (N15=32768)
-  integer*1 data0(11)
-  character*22 message
-  character*12 callsign
-  character*3 cdbm,cf
-  character*2 crpt
-  character*4 grid
-  character*9 name
-  character*36 fmt
-  character*6 cwx(4)
-  character*7 cwind(5)
-  character ccur*4,cxp*2
-  logical first
-  character*12 dcall(0:N15-1)
-  data first/.true./
-  data cwx/'CLEAR','CLOUDY','RAIN','SNOW'/
-  data cwind/'CALM','BREEZES','WINDY','DRY','HUMID'/
-  save first,dcall
-
-  call cs_lock('wqdecode')
-  if(first) then
-     dcall='            '
-     first=.false.
-  endif
-
-  message='                      '
-  call unpack50(data0,n1,n2)
-  call unpackcall(n1,callsign)
-  i1=index(callsign,' ')
-  call unpackgrid(n2/128,grid)
-  ntype=iand(n2,127) -64
-
-! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
-  nu=mod(ntype,10)
-  if(ntype.ge.0 .and. ntype.le.60 .and. (nu.eq.0 .or. nu.eq.3 .or.   &amp;
-       nu.eq.7)) then
-     write(cdbm,'(i3)'),ntype
-     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-     message=callsign(1:i1)//grid//' '//cdbm
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1)
-
-! &quot;Best DX&quot; WSPR response (type 1)
-  else if(ntype.eq.1) then
-     message=grid//' DE '//callsign
-
-! CQ (msg 3; types 2,4,5)
-  else if(ntype.eq.2) then
-     message='CQ '//callsign(:i1)//grid
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1)
-  else if(ntype.eq.4 .or. ntype.eq.5) then
-     ng=n2/128 + 32768*(ntype-4)
-     call unpackpfx(ng,callsign)
-     message='CQ '//callsign
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1)
-
-! Reply to CQ (msg #2; type 6)
-  else if(ntype.eq.6) then
-     ih=(n2-64-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '//callsign(:i1-1)
-     else
-        message='&lt;...&gt; '//callsign
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Reply to CQ (msg #2; type 8)
-  else if(ntype.eq.8) then
-     message='DE '//callsign(:i1)//grid
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Reply to CQ, DE pfx/call (msg #2; types 9, 11)
-  else if(ntype.eq.9 .or. ntype.eq.11) then
-     ng=n2/128 + 32768*(ntype-9)/2
-     call unpackpfx(ng,callsign)
-     message='DE '//callsign
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and report (msg #3; types -1 to -9)
-  else if(ntype.le.-1 .and. ntype.ge.-9) then
-     write(crpt,1010) -ntype
-1010 format('S',i1)
-     ih=(n2-62-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; '//crpt
-     else
-        message=callsign(:i1)//'&lt;...&gt; '//crpt
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! pfx/call and report (msg #3; types -10 to -27)
-  else if(ntype.le.-10 .and. ntype.ge.-27) then
-     ng=n2/128
-     nrpt=-ntype-9
-     if(ntype.le.-19) then
-        ng=ng + 32768
-        nrpt=-ntype-18
-     endif
-     write(crpt,1010) nrpt
-     call unpackpfx(ng,callsign)
-     message=callsign//' '//crpt
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and R and report (msg #4; types -28 to -36)
-  else if(ntype.le.-28 .and. ntype.ge.-36) then
-     write(crpt,1010) -(ntype+27)
-     ih=(n2-64+28-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; '//'R '//crpt
-     else
-        message=callsign(:i1)//'&lt;...&gt; '//'R '//crpt
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! pfx/call R and report (msg #4; types -37 to -54)
-  else if(ntype.le.-37 .and. ntype.ge.-54) then
-     ng=n2/128
-     nrpt=-ntype-36
-     if(ntype.le.-46) then
-        ng=ng + 32768
-        nrpt=-ntype-45
-     endif
-     write(crpt,1010) nrpt
-     call unpackpfx(ng,callsign)
-     message=callsign//' R '//crpt
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and RRR (msg#5; type 12)
-  else if(ntype.eq.12) then
-     ih=(n2-64+28-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; RRR'
-     else
-        message=callsign(:i1)//'&lt;...&gt; RRR'
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and RRR (msg#5; type 14)
-  else if(ntype.eq.14) then
-     ih=(n2-64+28-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '//callsign(:i1)//'RRR'
-     else
-        message='&lt;...&gt; '//callsign(:i1)//' RRR'
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! DE pfx/call and RRR (msg#5; types 15, 16)
-  else if(ntype.eq.15 .or. ntype.eq.16) then
-     ng=n2/128 + 32768*(ntype-15)
-     call unpackpfx(ng,callsign)
-     message='DE '//callsign//' RRR'
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! TNX [name] 73 GL (msg #6; type 18)
-  else if(ntype.eq.18) then
-     ng=(n2-18-64)/128
-     call unpackname(n1,ng,name,len)
-     message='TNX '//name(:len)//' 73 GL'
-
-! OP [name] 73 GL (msg #6; type 18)
-  else if(ntype.eq.-56) then
-     ng=(n2+56-64)/128
-     call unpackname(n1,ng,name,len)
-     message='OP '//name(:len)//' 73 GL'
-
-! 73 DE [call] [grid] (msg #6; type 19)
-  else if(ntype.eq.19) then
-     ng=(n2-19-64)/128
-     message='73 DE '//callsign(:i1)//grid
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! 73 DE pfx/call (msg #6; type 21, 22)
-  else if(ntype.eq.21 .or. ntype.eq.22) then
-     ng=n2/128 + (ntype-21)*32768
-     call unpackpfx(ng,callsign)
-     i1=index(callsign,' ')
-     message='73 DE '//callsign
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! [power] W [gain] DBD 73 GL (msg#6; type 24, 25)
-  else if(ntype.eq.24 .or. ntype.eq.25) then
-     ng=(n2-24-64)/128 - 32
-     i1=1
-     if(n1.gt.0) i1=log10(float(n1)) + 1
-     i2=1
-     if(ng.ge.10) i2=2
-     if(ng.lt.0) i2=i2+1
-     if(n1.le.3000) then
-        if(ntype.eq.24) fmt=&quot;(i4,' W ',i2,' DBD 73 GL')&quot;
-        if(ntype.eq.25) fmt=&quot;(i4,' W ',i2,' DBD      ')&quot;
-        fmt(3:3)=char(48+i1)
-        fmt(12:12)=char(48+i2)
-        if(ng.le.100) then
-           write(message,fmt) n1,ng
-        else
-           if(ng.eq.30000) fmt=fmt(1:8)//&quot;DIPOLE')&quot;
-           if(ng.eq.30001) fmt=fmt(1:8)//&quot;VERTICAL')&quot;
-           write(message,fmt) n1
-        endif
-     else
-        mw=n1-3000
-        if(ntype.eq.24) fmt=&quot;('0.',i3.3,' W ',i2,' DBD 73 GL')&quot;
-        if(ntype.eq.25) fmt=&quot;('0.',i3.3,' W ',i2,' DBD      ')&quot;
-        fmt(19:19)=char(48+i2)
-        if(ng.le.100) then
-           write(message,fmt) mw,ng
-        else
-           if(ng.eq.30000) fmt=fmt(1:15)//&quot;DIPOLE')&quot;
-           if(ng.eq.30001) fmt=fmt(1:15)//&quot;VERTICAL')&quot;
-           write(message,fmt) n1
-        endif
-        if(index(message,'***').gt.0) go to 700
-     endif
-
-! QRZ call (msg #3; type 26)
-  else if(ntype.eq.26) then
-     ng=(n2-24-64)/128 - 32
-     message='QRZ '//callsign
-
-! PSE QSY [nnn] KHZ (msg #6; type 28)
-  else if(ntype.eq.28) then
-     if(n1.gt.0) i1=log10(float(n1)) + 1
-     fmt=&quot;('PSE QSY ',i2,' KHZ')&quot;
-     fmt(14:14)=char(48+i1)
-     write(message,fmt) n1        
-
-! WX wx temp C/F wind (msg #6; type 29)
-  else if(ntype.eq.29) then
-     nwx=n1/10000
-     ntemp=mod(n1,10000) - 100
-     cf=' F '
-     if(ntemp.gt.800) then
-        ntemp=ntemp-1000
-        cf=' C '
-     endif
-     write(message,1020) cwx(nwx),ntemp,cf,cwind(n2/128)
-1020 format('WX ',a6,i3,a3,a7)
-
-! Hexadecimal data (type 62)
-  else if(ntype.eq.62) then
-     ng=n2/128
-     write(message,'(z4.4,z7.7)') ng,n1
-     
-! Solar/geomagnetic/ionospheric data (type 63)
-  else if(ntype.eq.63) then
-     ih=(n2-64-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '
-     else
-        message='&lt;...&gt; '
-     endif
-     call unpackprop(n1,k,muf,ccur,cxp)
-     i2=index(message,'&gt;')
-     write(message(i2+1:),'(i3,i3)') k,muf
-     message=message(:i2+7)//ccur//' '//cxp
-     
-! [plain text] (msg #6; type -57)
-  else if(ntype.eq.-57) then
-     ng=n2/128
-     call unpacktext2(n1,ng,message)
-  else
-     go to 700
-  endif
-  go to 750
-
-!     message='&lt;Unknown message type&gt;'
-700 i1=index(callsign,' ')
-  if(i1.lt.1) i1=12
-  message=callsign(:i1)//' (BadMsg)'
-
-750 do i=1,22
-     if(ichar(message(i:i)).eq.0) message(i:i)=' '
-  enddo
-
-  do i=22,1,-1
-     if(message(i:i).ne.' ') go to 800
-  enddo
-800 i2=i
-  do n=1,20
-     i1=index(message(:i2),'  ')
-     if(i1.le.0) go to 900
-     message=message(1:i1)//message(i1+2:)
-     i2=i2-1
-  enddo
-
-900 call cs_unlock
-  return
-end subroutine wqdecode

Deleted: trunk/wqencode.f90
===================================================================
--- trunk/wqencode.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/wqencode.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,347 +0,0 @@
-subroutine wqencode(msg,ntype,data0)
-
-!  Parse and encode a WSPR message.
-
-  parameter (MASK15=32767)
-  character*22 msg
-  character*12 call1,call2
-  character*4 grid
-!  character*9 name
-  character ccur*4,cxp*2
-  logical lbad1,lbad2
-  integer*1 data0(11)
-  integer nu(0:9)
-  data nu/0,-1,1,0,-1,2,1,0,-1,1/
-
-  nwatts=0
-  i1=0
-  call cs_lock('wqencode')
-  read(msg,1001,end=1,err=1) ng,n1
-1001 format(z4,z7)
-  ntype=62
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)             !Pack 8 bits per byte, add tail
-  go to 900
-
-1  if(msg(1:6).eq.'73 DE ') go to 80
-  if(index(msg,' W ').gt.0 .and. index(msg,' DBD ').gt.0) go to 90
-  if(msg(1:4).eq.'QRZ ') go to 100
-  if(msg(1:8).eq.'PSE QSY ') go to 110
-  if(msg(1:3).eq.'WX ') go to 120
-
-! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
-  i1=index(msg,' ')
-  if(i1.lt.4 .or. i1.gt.7) go to 10
-  call1=msg(:i1-1)
-  grid=msg(i1+1:i1+4)
-  call packcall(call1,n1,lbad1)
-  call packgrid(grid,ng,lbad2)
-  if(lbad1 .or. lbad2) go to 10
-  ndbm=0
-  read(msg(i1+5:),*,err=10,end=800) ndbm
-  if(ndbm.lt.0 .or. ndbm.gt.60) go to 800
-  ndbm=ndbm+nu(mod(ndbm,10))
-  n2=128*ng + (ndbm+64)
-  call pack50(n1,n2,data0)
-  ntype=ndbm
-  go to 900
-
-! &quot;BestDX&quot; automated WSPR reply (type 1)
-10 if(i1.ne.5 .or. msg(5:8).ne.' DE ') go to 20
-  grid=msg(1:4)
-  call packgrid(grid,ng,lbad2)
-  if(lbad2) go to 800
-  call1=msg(9:)
-  call packcall(call1,n1,lbad1)
-  if(lbad1) go to 800
-  ntype=1
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)             !Pack 8 bits per byte, add tail
-  go to 900
-
-! CQ (msg #1; types 2, 4, 5)
-20  if(msg(1:3).ne.'CQ ') go to 30
-  if(index(msg,'/').le.0) then
-     i2=index(msg(4:),' ')
-     call1=msg(4:i2+3)
-     grid=msg(i2+4:)
-     call packcall(call1,n1,lbad1)
-     if(lbad1) go to 30
-     call packgrid(grid,ng,lbad2)
-     if(lbad2) go to 30
-     ntype=2
-     n2=128*ng + (ntype+64)
-     call pack50(n1,n2,data0)
-  else
-     ntype=4                                     ! or 5
-     call1=msg(4:)
-     call packpfx(call1,n1,ng,nadd)
-     ntype=ntype+nadd
-     n2=128*ng + ntype + 64
-     call pack50(n1,n2,data0)
-  endif
-  go to 900
-
-! Reply to CQ (msg #2; types 6,8,9,11)
-30 if(msg(1:1).ne.'&lt;' .and. msg(1:3).ne.'DE ') go to 40
-  if(index(msg,' RRR ').gt.0) go to 50
-  if(msg(1:1).eq.'&lt;') then
-     ntype=6
-     i1=index(msg,'&gt;')
-     call1=msg(2:i1-1)
-     read(msg(i1+1:),*,err=31,end=31) k,muf,ccur,cxp
-     go to 130
-31   call2=msg(i1+2:)
-     call hash(call1,i1-2,ih)
-     call packcall(call2,n1,lbad1)
-     n2=128*ih + (ntype+64)
-     call pack50(n1,n2,data0)
-  else
-     i1=index(msg(4:),' ')
-     call1=msg(4:i1+2)
-     if(index(msg,'/').le.0) then
-        ntype=8
-        ih=0
-        call packcall(call1,n1,lbad1)
-        grid=msg(i1+4:i1+7)
-        call packgrid(grid,ng,lbad2)
-        n2=128*ng + (ntype+64)
-        call pack50(n1,n2,data0)
-     else
-        ntype=9                                   ! or 11
-        call1=msg(4:)
-        call packpfx(call1,n1,ng,nadd)
-        ntype=ntype + 2*nadd
-        n2=128*ng + ntype + 64
-        call pack50(n1,n2,data0)
-     endif
-  endif
-  go to 900
-
-! Call(s) + report (msg #3; types -1 to -27)
-! Call(s) + R + report (msg #4; types -28 to -54)
-40 if(index(msg,' RRR').gt.0) go to 50
-  i1=index(msg,'&lt;')
-  if(i1.gt.0 .and. (i1.lt.5 .or. i1.gt.8)) go to 50
-  i2=index(msg,'/')
-  if(i2.gt.0 .and.i2.le.4) then
-     ntype=-10                                   ! -10 to -27
-     i0=index(msg,' ')
-     call1=msg(:i0-1)
-     call packpfx(call1,n1,ng,nadd)
-     ntype=ntype - 9*nadd
-     i2=index(msg,' ')
-     i3=index(msg,' R ')
-     if(i3.gt.0) i2=i2+2                            !-28 to -36
-     read(msg(i2+2:i2+2),*,end=800,err=800) nrpt
-     ntype=ntype - (nrpt-1)
-     if(i3.gt.0) ntype=ntype-27
-     n2=128*ng + ntype + 64
-     call pack50(n1,n2,data0)
-     go to 900
-  else if(i1.eq.0) then
-     go to 50
-  endif
-  call1=msg(:i1-2)                               !-1 to -9
-  i2=index(msg,'&gt;')
-  call2=msg(i1+1:i2-1)
-  call hash(call2,i2-i1-1,ih)
-  i3=index(msg,' R ')
-  if(i3.gt.0) i2=i2+2                            !-28 to -36
-  read(msg(i2+3:i2+3),*,end=42,err=42) nrpt
-  go to 43
-42 nrpt=1
-43 ntype=-nrpt
-  if(i3.gt.0) ntype=-(nrpt+27)
-  call packcall(call1,n1,lbad1)
-  n2=128*ih + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-50 i0=index(msg,'&lt;')
-  if(i0.le.0 .and. msg(1:3).ne.'DE ') go to 60
-  i3=index(msg,' RRR')
-  if(i3.le.0) go to 60
-! Call or calls and RRR (msg#5; type2 12,14,15,16)
-  i0=index(msg,'&lt;')
-  if(i0.eq.1) then
-     if(index(msg,'/').le.0) then
-        ntype=14
-        i1=index(msg,'&gt;')
-        call1=msg(2:i1-1)
-        call2=msg(i1+2:)
-        i2=index(call2,' ')
-        call2=call2(:i2-1)
-        call packcall(call2,n1,lbad1)
-        call hash(call1,i1-2,ih)
-        n2=128*ih + (ntype+64)
-        call pack50(n1,n2,data0)
-     else
-        stop '0002'
-     endif
-  else if(i0.ge.5 .and. i0.le.8) then
-     if(index(msg,'/').le.0) then
-        ntype=12
-        i1=index(msg,'&gt;')
-        call1=msg(:i0-2)
-        call2=msg(i0+1:i1-1)
-        call packcall(call1,n1,lbad1)
-        call hash(call2,i1-i0-1,ih)
-        n2=128*ih + (ntype+64)
-        call pack50(n1,n2,data0)
-     else
-        stop '0002'
-     endif
-  else
-     i1=index(msg(4:),' ')
-     call1=msg(4:i1+2)
-     if(index(msg,'/').le.0) then
-        ntype=9
-        grid=msg(i1+4:i1+7)
-     else
-        ntype=15                                   ! or 16
-        call1=msg(4:)
-        i0=index(call1,' ')
-        call1=call1(:i0-1)
-        call packpfx(call1,n1,ng,nadd)
-        ntype=ntype+nadd
-        n2=128*ng + ntype + 64
-        call pack50(n1,n2,data0)
-     endif
-  endif
-  go to 900
-
-! TNX &lt;name&gt; 73 GL (msg #6; type 18 ...)
-60 if(msg(1:4).ne.'TNX ') go to 70
-  ntype=18
-  n1=0
-  i2=index(msg(5:),' ')
-  call packname(msg(5:i2+4),i2-1,n1,ng)
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! TNX name 73 GL (msg #6; type -56 ...)
-70 if(msg(1:3).ne.'OP ') go to 80
-  ntype=-56
-  n1=0
-  i2=index(msg(4:),' ')
-  call packname(msg(4:i2+3),i2-1,n1,ng)
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! 73 DE call grid (msg #6; type 19)
-80 if(msg(1:6).ne.'73 DE ') go to 90
-  ntype=19
-  i1=index(msg(7:),' ')
-  call1=msg(7:)
-  if(index(call1,'/').le.0) then
-     i1=index(call1,' ')
-     grid=call1(i1+1:)
-     call1=call1(:i1-1)
-     call packcall(call1,n1,lbad1)
-     call packgrid(grid,ng,lbad2)
-     if(lbad1 .or. lbad2) go to 800
-     n2=128*ng + (ntype+64)
-     call pack50(n1,n2,data0)
-     go to 900
-  else
-     ntype=21                                   ! or 22
-     call packpfx(call1,n1,ng,nadd)
-     ntype=ntype + nadd
-     n2=128*ng + ntype + 64
-     call pack50(n1,n2,data0)
-     go to 900
-  endif
-
-! [pwr] W [gain] DBD [73 GL] (msg #6; types 24, 25)
-90  if(index(msg,' W ').le.0) go to 140
-  ntype=25
-  if(index(msg,' DBD 73 GL').gt.0) ntype=24
-  i1=index(msg,' ')
-  read(msg(:i1-1),*,end=800,err=800) watts
-  if(watts.ge.1.0) nwatts=watts
-  if(watts.lt.1.0) nwatts=3000 + nint(1000.*watts)
-  if(index(msg,'DIPOLE').gt.0) then
-     ndbd=30000
-  else if(index(msg,'VERTICAL').gt.0) then
-     ndbd=30001
-  else
-     i2=index(msg(i1+3:),' ')
-     read(msg(i1+3:i1+i2+1),*,end=800,err=800) ndbd
-  endif
-  n1=nwatts
-  ng=ndbd + 32
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-  go to 900
-
-! QRZ call (msg #3; type 26)
-100 call1=msg(5:)
-  call packcall(call1,n1,lbad1)
-  if(lbad1) go to 800
-  ntype=26
-  n2=ntype+64
-  call pack50(n1,n2,data0)
-  go to 900
-
-! PSE QSY [nnn] KHZ (msg #6; type 28)
-110 ntype=28
-  read(msg(9:),*,end=800,err=800) n1
-  n2=ntype+64
-  call pack50(n1,n2,data0)
-  go to 900
-
-! WX wx temp C|F wind (msg #6; type 29)
-120 ntype=29
-  if(index(msg,' CLEAR ').gt.0) then
-     i1=10
-     n1=10000
-  else if(index(msg,' CLOUDY ').gt.0) then
-     i1=11
-     n1=20000
-  else if(index(msg,' RAIN ').gt.0) then
-     i1=9
-     n1=30000
-  else if(index(msg,' SNOW ').gt.0) then
-     i1=9
-     n1=40000
-  endif
-  read(msg(i1:),*,err=800,end=800) ntemp
-  ntemp=ntemp+100
-  i1=index(msg,' C ')
-  if(i1.gt.0) ntemp=ntemp+1000
-  n1=n1+ntemp
-  if(index(msg,' CALM').gt.0) ng=1
-  if(index(msg,' BREEZES').gt.0) ng=2
-  if(index(msg,' WINDY').gt.0) ng=3
-  if(index(msg,' DRY').gt.0) ng=4
-  if(index(msg,' HUMID').gt.0) ng=5
-
-  n2=128*ng + (ntype+64)
-  call pack50(n1,n2,data0)
-
-  go to 900
-
-! Solar/geomagnetic/ionospheric data
-130 ntype=63
-  call packprop(k,muf,ccur,cxp,n1)
-  call hash(call1,i1-2,ih)
-  n2=128*ih + ntype + 64 
-  call pack50(n1,n2,data0)
-  go to 900
-
-140 continue
-
-! Plain text
-800 ntype=-57
-  call packtext2(msg(:8),n1,ng)
-  n2=128*ng + ntype + 64
-  call pack50(n1,n2,data0)
-  go to 900
-
-900 continue
-  call cs_unlock
-  return
-end subroutine wqencode

Copied: trunk/wsjt.jpg (from rev 2228, wsjt7a/wsjt.jpg)
===================================================================
(Binary files differ)

Modified: trunk/wsjt.py
===================================================================
--- trunk/wsjt.py	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/wsjt.py	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,5 +1,5 @@
 #!/usr/bin/env python
-#---------------------------------------------------------------------- WSJT
+#--------------------------------------------------------------------- WSJT
 # $Date$ $Revision$
 #
 from Tkinter import *
@@ -22,9 +22,11 @@
      colormapAFMHot, colormapgray1, colormapLinrad, Colormap2Palette
 from types import *
 import array
+import thread
+import webbrowser
 
 root = Tk()
-Version=&quot;7.07 r&quot; + &quot;$Rev$&quot;[6:-1]
+Version=&quot;9.02 r&quot; + &quot;$Rev$&quot;[6:-1]
 print &quot;******************************************************************&quot;
 print &quot;WSJT Version &quot; + Version + &quot;, by K1JT&quot;
 print &quot;Revision date: &quot; + \
@@ -54,11 +56,10 @@
 first=1
 g.appdir=appdir
 isync=0
-isync441=2
-isync6m=-10
+isync441=1
+isync_iscat=-20
 isync65=1
 isync_save=0
-iclip=0
 itol=5                                       #Default tol=400 Hz
 ntol=(10,25,50,100,200,400,600)              #List of available tolerances
 idsec=0
@@ -72,6 +73,7 @@
 hiscall=&quot;&quot;
 hisgrid=&quot;&quot;
 isec0=-99
+jtol=IntVar()
 k2txb=IntVar()
 kb8rq=IntVar()
 loopall=0
@@ -82,9 +84,7 @@
 nafc=IntVar()
 naz=0
 ndepth=IntVar()
-ndwspr=IntVar()
 nel=0
-nblank=IntVar()
 ncall=0
 ncwtrperiod=120
 ndmiles=0
@@ -94,10 +94,14 @@
 nfreeze=IntVar()
 nhotaz=0
 nhotabetter=0
+nmeas=0
+nmonitor=IntVar()
 nopen=0
-nosh441=IntVar()
+nshrx=IntVar()
 noshjt65=IntVar()
 noshjt65all=IntVar()
+nsync=IntVar()
+nzap=IntVar()
 qdecode=IntVar()
 setseq=IntVar()
 ShOK=IntVar()
@@ -107,6 +111,7 @@
 tx6alt=&quot;&quot;
 txsnrdb=99.
 TxFirst=IntVar()
+xypm=[]
 green=zeros(500,'f')
 im=Image.new('P',(500,120))
 im.putpalette(Colormap2Palette(colormapLinrad),&quot;RGB&quot;)
@@ -188,39 +193,13 @@
     tx5.insert(0,&quot;@1000&quot;)
     tx6.insert(0,&quot;@2000&quot;)
 
-#------------------------------------------------------ msg6list
-def msg6list(event=NONE):
-    if mode.get()=='WSPR':
-        t=&quot;OP name 73 GL&quot;
-        if options.myname.get()!=&quot;&quot;:
-            t1=options.myname.get().strip()
-            if t1!=&quot;name&quot;: t1=t1.upper()
-            t=&quot;OP &quot; + t1 + &quot; 73 GL&quot;
-        tx6list=(&quot;73 DE call grid&quot;, &quot;73 DE p/call&quot;, &quot;TNX name 73 GL&quot;,
-             t, &quot;pwr W gain dbd&quot;, &quot;pwr W gain dbd 73 GL&quot;,
-             &quot;pwr W DIPOLE&quot;, &quot;pwr W VERTICAL&quot;, &quot;PSE QSY freq KHZ&quot;,
-             &quot;WX wx temp F wind&quot;, &quot;WX wx temp C wind&quot;)
-        tx6dialog=Pmw.ComboBoxDialog(root, title=&quot;Message Tx6&quot;,
-            buttons=('OK','cancel'),defaultbutton='OK',
-            scrolledlist_items=tx6list,listbox_width=22)
-        tx6dialog.geometry(msgpos())
-        if g.Win32: tx6dialog.iconbitmap(&quot;wsjt.ico&quot;)
-        tx6dialog.tkraise()
-        t=tx6dialog.activate()
-        if t=='OK':
-            t=tx6dialog.get()
-            tx6.delete(0,99)
-            tx6.insert(0,t)
-
 #------------------------------------------------------ textsize
 def textsize():
     global textheight
     if textheight &lt;= 9:
         textheight=21
     else:
-        if mode.get()[:4]=='JT65' or mode.get()=='WSPR' or \
-               mode.get()[:3]=='JT2' or mode.get()[:3]=='JT4' \
-               or mode.get()[:4]=='JT64':
+        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4':
             textheight=7
         else:
             textheight=9
@@ -256,28 +235,45 @@
 def dbl_click_text(event):
     t=text.get('1.0',END)           #Entire contents of text box
     t1=text.get('1.0',CURRENT)      #Contents from start to mouse pointer
+    if mode.get()=='Diana':
+        report.delete(0,END)
+        report.insert(0,'OOO')
     dbl_click_call(t,t1,'OOO',event)
 
 #------------------------------------------------------ dbl_click3_text
 def dbl_click3_text(event):
-    if mode.get()[:4]=='JT65' or mode.get()=='WSPR' or \
-           mode.get()[:3]=='JT2' or mode.get()[:3]=='JT4' \
-           or mode.get()[:4]=='JT64':
+    if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4':
         t=text.get('1.0',END)           #Entire contents of text box
         t1=text.get('1.0',CURRENT)      #Contents from start to mouse pointer
         n=t1.rfind(&quot;\n&quot;)
         rpt=t1[n+12:n+15]
         if rpt[0:1] == &quot; &quot;: rpt=rpt[1:]
         if rpt[:1]=='-' and len(rpt)==2: rpt=rpt[0:1]+'0'+rpt[1:2]
-        if mode.get()=='WSPR' or mode.get()[:4]=='JT64':
-            i=int((int(rpt)+33)/3)
-            if i&lt;1: i=1
-            if i&gt;9: i=9
-            rpt=&quot;S%d&quot; % (i,)
-            report.delete(0,END)
-            report.insert(0,rpt)
         dbl_click_call(t,t1,rpt,event)
 
+    elif mode.get()[:5]=='ISCAT' or mode.get()=='Diana':
+        t=text.get('1.0',END)           #Entire contents of text box
+        t1=text.get('1.0',CURRENT)      #Contents from start to mouse pointer
+        n=t1.rfind(&quot;\n&quot;)
+        rpt=t1[n+9:n+12]
+        if mode.get()=='Diana':
+            rpt=t1[n+12:n+16]
+        if rpt[0:1] == &quot; &quot;: rpt=rpt[1:]
+        if rpt[:1]=='-' and len(rpt)==2: rpt=rpt[0:1]+'0'+rpt[1:2]
+        report.delete(0,END)
+        report.insert(0,rpt)
+        dbl_click_call(t,t1,rpt,event)
+
+    elif mode.get()=='FSK441' or mode.get()=='JTMS':
+        t=text.get('1.0',END)           #Entire contents of text box
+        t1=text.get('1.0',CURRENT)      #Contents from start to mouse pointer
+        n=t1.rfind(&quot;\n&quot;)
+        rpt=t1[n+21:n+23]
+        report.delete(0,END)
+        report.insert(0,rpt)
+        dbl_click_call(t,t1,rpt,event)
+
+
 #------------------------------------------------------ dbl_click_ave
 def dbl_click_ave(event):
     t=avetext.get('1.0',END)           #Entire contents of text box
@@ -303,8 +299,8 @@
         if setseq.get(): TxFirst.set((nsec/Audio.gcom1.trperiod)%2)
         lookup()
         GenStdMsgs()
-        if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-           mode.get()[:3]=='JT4') and rpt &lt;&gt; &quot;OOO&quot;:
+        if (mode.get()[:4]=='JT65' or \
+                mode.get()[:3]=='JT4') and rpt &lt;&gt; &quot;OOO&quot;:
             n=tx1.get().rfind(&quot; &quot;)
             t2=tx1.get()[0:n+1]
             tx2.delete(0,END)
@@ -315,8 +311,8 @@
             tx4.insert(0,t2+&quot;RRR&quot;)
             tx5.delete(0,END)
             tx5.insert(0,t2+&quot;73&quot;)
-        i3=t[:i1].strip().rfind(' ')+1
-        if t[i3:i1].strip() == 'CQ':
+
+        if t[i3:i1].find(' CQ ')&gt;=0:
             ntx.set(1)
         else:
             ntx.set(2)
@@ -531,9 +527,9 @@
             os.rename(&quot;CALL3.TXT&quot;,&quot;CALL3.OLD&quot;)
             os.rename(&quot;CALL3.TMP&quot;,&quot;CALL3.TXT&quot;)
 
-#------------------------------------------------------ clrrpt
-def clrrpt(event):
-    report.delete(0,END)
+#------------------------------------------------------ setrpt
+def setrpt(event):
+#    report.delete(0,END)
     report.focus_set()
 
 #-------------------------------------------------------- clrToRadio
@@ -586,22 +582,27 @@
         lab6.configure(bg=&quot;green&quot;)
         isync=isync441
         slabel=&quot;S      &quot;
+        f5b1.grid(column=0,row=0,padx=2,sticky='EW')
         lsync.configure(text=slabel+str(isync))
         iframe4b.pack_forget()
         textheight=9
         text.configure(height=textheight)
-        bclravg.configure(state=DISABLED)
-        binclude.configure(state=DISABLED)
-        bexclude.configure(state=DISABLED)
-        cbnb.configure(state=NORMAL)
-        cbzap.configure(state=NORMAL)
-        cbfreeze.configure(state=DISABLED)
-        cbafc.configure(state=DISABLED)
+        bclravg.pack_forget()
+        binclude.pack_forget()
+        bexclude.pack_forget()
+        cbfreeze.grid_forget()
+        cbafc.grid_forget()
+        lsync.grid(column=0,row=0,padx=8,sticky='EW')
+        ltol.grid(column=0,row=1,padx=8,sticky='EW')
+        cbzap.grid(column=1,row=0,padx=2,sticky='W')
+        nfreeze.set(0)
+        shrx.grid(column=1,row=1,sticky='W',padx=2)
+        shmsg.grid(column=1,row=0,sticky='W',padx=2)
+        report.grid(column=1,row=1,sticky='W',padx=7)
+        labreport.grid(column=0,row=1,sticky='E',padx=0)
         if ltxdf: toggletxdf()
-        btxdf.configure(state=DISABLED)
-        report.configure(state=NORMAL)
-        shmsg.configure(state=NORMAL)
         graph2.configure(bg='black')
+        btxdf.grid_forget()
         report.delete(0,END)
         report.insert(0,'26')
         itol=4
@@ -623,18 +624,25 @@
     text.configure(height=textheight)
     isync=isync65
     slabel=&quot;Sync   &quot;
+    f5b1.grid(column=0,row=0,padx=2,sticky='EW')
     lsync.configure(text=slabel+str(isync))
-    bclravg.configure(state=NORMAL)
-    binclude.configure(state=NORMAL)
-    bexclude.configure(state=NORMAL)
-    cbnb.configure(state=NORMAL)
-    cbzap.configure(state=NORMAL)
-    cbfreeze.configure(state=NORMAL)
-    cbafc.configure(state=NORMAL)
+    lsync.grid(column=0,row=0,padx=2,sticky='EW')
+    ltol.grid(column=0,row=1,padx=2,sticky='EW')
+    cbzap.grid(column=1,row=0,padx=2,sticky='W')
+    btxstop.pack_forget()
+    bclravg.pack(side=LEFT,expand=1,fill=X)
+    binclude.pack(side=LEFT,expand=1,fill=X)
+    bexclude.pack(side=LEFT,expand=1,fill=X)
+    btxstop.pack(side=LEFT,expand=1,fill=X)
+
+    cbfreeze.grid(column=0,row=2,padx=2,sticky='W')
+    cbafc.grid(column=1,row=1,padx=2,sticky='W')
     if ltxdf: toggletxdf()
-    btxdf.configure(state=NORMAL)
-    report.configure(state=DISABLED)
-    shmsg.configure(state=DISABLED)
+    btxdf.grid_forget()
+    shmsg.grid_forget()
+    shrx.grid_forget()
+    report.grid_forget()
+    labreport.grid_forget()
     graph2.configure(bg='#66FFFF')
     itol=4
     inctol()
@@ -648,9 +656,11 @@
 def ModeJT65A(event=NONE):
     if g.mode != &quot;JT65A&quot;:
         if lauto: toggleauto()
+        ModeJT65()
         mode.set(&quot;JT65A&quot;)
-        ModeJT65()
+        btxdf.grid(column=1,row=0,sticky='EW',padx=4)
 
+
 #------------------------------------------------------ ModeJT65B
 def ModeJT65B(event=NONE):
     if g.mode != &quot;JT65B&quot;:
@@ -665,112 +675,90 @@
         mode.set(&quot;JT65C&quot;)
         ModeJT65()
 
-#------------------------------------------------------ ModeJT64A
-def ModeJT64A(event=NONE):
-    if g.mode != &quot;JT64A&quot;:
+#------------------------------------------------------ ModeJTMS
+def ModeJTMS(event=NONE):
+    if g.mode != &quot;JTMS&quot;:
         if lauto: toggleauto()
-    ModeJT65()
-    mode.set(&quot;JT64A&quot;)
-    report.configure(state=NORMAL)
-    report.delete(0,END)
-    report.insert(0,'S1')
-
-#------------------------------------------------------ ModeJT6M
-def ModeJT6M(event=NONE):
-    global slabel,isync,isync6m,itol
-    if g.mode != &quot;JT6M&quot;:
+    ModeFSK441()
+    cbfreeze.grid(column=0,row=2,padx=4,sticky='W')
+    mode.set(&quot;JTMS&quot;)
+    
+#------------------------------------------------------ ModeISCAT
+def ModeISCAT(event=NONE):
+    global isync,isync_iscat
+    if g.mode != &quot;ISCAT&quot;:
         if lauto: toggleauto()
         cleartext()
         ModeFSK441()
-        lab2.configure(text='FileID            T      Width      dB        DF')
-        mode.set(&quot;JT6M&quot;)
-        isync=isync6m
+
+        mode.set(&quot;ISCAT&quot;)
+        lab2.configure(text='FileID      Avg dB        DF')
+        isync=isync_iscat
         lsync.configure(text=slabel+str(isync))
-        shmsg.configure(state=DISABLED)
-        cbnb.configure(state=NORMAL)
-        cbzap.configure(state=NORMAL)
-        cbfreeze.configure(state=NORMAL)
+        cbfreeze.grid(column=1,row=1,padx=2,sticky='W')
         itol=3
         ltol.configure(text='Tol    '+str(ntol[itol]))
         inctol()
-        nfreeze.set(1)
+        nfreeze.set(0)
+        report.delete(0,END)
+        report.insert(0,'-15')
+        shrx.grid_forget()
+        shmsg.grid_forget()
         ntx.set(1)
         Audio.gcom2.mousedf=0
         GenStdMsgs()
-        erase()
-        
+        erase()        
 
+#------------------------------------------------------ ModeDiana
+def ModeDiana(event=NONE):
+    global isync,isync_iscat
+    if g.mode != &quot;Diana&quot;:
+        if lauto: toggleauto()
+        ModeJT65()
+        Audio.gcom1.trperiod=30
+        mode.set(&quot;Diana&quot;)
+        isync=1
+        lsync.configure(text=slabel+str(isync))
+        report.delete(0,END)
+        report.insert(0,'-20')
+
 #------------------------------------------------------ ModeCW
 def ModeCW(event=NONE):
     if g.mode != &quot;CW&quot;:
         if lauto: toggleauto()
         cleartext()
+        ModeJT65B()
         mode.set(&quot;CW&quot;)
         Audio.gcom1.trperiod=ncwtrperiod
         iframe4b.pack_forget()
         text.configure(height=9)
-        bclravg.configure(state=DISABLED)
-        binclude.configure(state=DISABLED)
-        bexclude.configure(state=DISABLED)
-        cbfreeze.configure(state=DISABLED)
-        cbafc.configure(state=DISABLED)
+        cbfreeze.grid_forget()
+        cbafc.grid_forget()
+        lsync.grid_forget()
+        ltol.grid_forget()
+        cbzap.grid_forget()
+        f5b1.grid_forget()
         if ltxdf: toggletxdf()
-        btxdf.configure(state=DISABLED)
-        report.configure(state=NORMAL)
         ntx.set(1)
         GenStdMsgs()
         erase()
 
-#------------------------------------------------------ ModeWSPR
-def ModeWSPR():
-    global slabel,isync,isync65,textheight,itol
-    ModeJT65()
-    mode.set(&quot;WSPR&quot;)
-    if lauto: toggleauto()
-    cleartext()
-    lab2.configure(text='FileID      Sync     dB       DT          DF  Drift')
-    Audio.gcom1.trperiod=120
-    iframe4b.pack_forget()
-    text.configure(height=9)
-    bclravg.configure(state=DISABLED)
-    binclude.configure(state=DISABLED)
-    bexclude.configure(state=DISABLED)
-    cbafc.configure(state=DISABLED)
-    cbnb.configure(state=DISABLED)
-    cbzap.configure(state=DISABLED)
-    lclip.configure(state=DISABLED)
-    nfreeze.set(1)
-    nzap.set(0)
-    cbfreeze.configure(state=DISABLED)
-##    btxdf.configure(state=DISABLED)
-
-    if ltxdf: toggletxdf()
-    report.configure(state=NORMAL)
-    report.delete(0,END)
-    report.insert(0,'S1')
-    itol=2
-    inctol()
-    ntx.set(1)
-    GenStdMsgs()
-    erase()
-
-#------------------------------------------------------ ModeJT2
-def ModeJT2():
-    global slabel,isync,isync65,textheight,itol
-    ModeJT65()
-    mode.set(&quot;JT2&quot;)
-
 #------------------------------------------------------ ModeJT4
 def ModeJT4():
     global slabel,isync,isync65,textheight,itol
     ModeJT65()
+    bclravg.pack_forget()
+    binclude.pack_forget()
+    bexclude.pack_forget()
 
+
 #------------------------------------------------------ ModeJT4A
 def ModeJT4A():
     global slabel,isync,isync65,textheight,itol
     ModeJT4()
     mode.set(&quot;JT4A&quot;)
     Audio.gcom2.mode4=1
+    btxdf.grid(column=1,row=0,sticky='EW',padx=4)
 
 #------------------------------------------------------ ModeJT4B
 def ModeJT4B():
@@ -815,10 +803,24 @@
     Audio.gcom2.mode4=72
 
 #------------------------------------------------------ ModeEcho
-#def ModeEcho(event=NONE):
-#    mode.set(&quot;Echo&quot;)
-#    stub()
-    
+def ModeEcho(event=NONE):
+    ModeCW()
+    mode.set(&quot;Echo&quot;)
+    if lauto: toggleauto()
+    lab2.configure(text='     N      Level         Sig              DF         Width      Q')
+    Audio.gcom1.trperiod=6
+    tx1.delete(0,99)
+    tx2.delete(0,99)
+    tx3.delete(0,99)
+    tx4.delete(0,99)
+    tx5.delete(0,99)
+    tx6.delete(0,99)
+
+#------------------------------------------------------ ModeMeasure
+def ModeMeasure(event=NONE):
+    ModeEcho()
+    mode.set(&quot;Measure&quot;)
+
 #------------------------------------------------------ msgpos
 def msgpos():
     g=root_geom[root_geom.index(&quot;+&quot;):]
@@ -839,15 +841,15 @@
 WSJT is a weak signal communications program.  It supports
 these operating modes:
 
-  1. FSK441 - fast mode for meteor scatter
-  2. JT6M   - optimized for meteor and ionospheric scatter on 50 MHz
-  3. JT65   - for HF, EME, and troposcatter
-  4. CW     - 15 WPM Morse code, messages structured for EME
-  5. JT2    - for HF and EME
-  6. JT4    - for HF and EME
-  7. WSPR   - for HF and EME
+  1. FSK441 -  meteor scatter
+  2. ISCAT    -  for tropo- and iono-scatter, weak Es/F2 on 50 MHz
+                       (replaces JT6M)
+  3. JT65      -  for HF, EME, and troposcatter
+  4. JT4        -  HF, microwave beacons, 10 GHz EME and rainscatter
+  5. CW        -  15 WPM Morse code, messages structured for EME
+  6. Echo      -  EME Echo testing
 
-Copyright (c) 2001-2010 by Joseph H. Taylor, Jr., K1JT, with
+Copy (c) 2001-2010 by Joseph H. Taylor, Jr., K1JT, with
 contributions from additional authors.  WSJT is Open Source 
 software, licensed under the GNU General Public License (GPL).
 Source code and programming information may be found at 
@@ -869,7 +871,6 @@
 Shift+F1	List special mouse commands
 Ctrl+F1	About WSJT
 F2	Options
-Shift+F2   WSPR structured messages
 F3	Tx Mute
 F4	Clear &quot;To Radio&quot;
 Alt+F4      Exit program
@@ -877,31 +878,28 @@
 Shift+F5	Examples of minimal JT65 QSOs
 F6	Open next file in directory
 Shift+F6	Decode all wave files in directory
-F7	Set FSK441 mode
-Shift+F7	Set JT6M mode
-F8	Set JT65A mode
-Shift+F8	Set JT65B mode
-Ctrl+F8	Set JT65C mode
-Shift+Ctrl+F8 Set CW mode
+F9	Online Supplement to User's Guide
 F10	Show SpecJT
 Shift+F10  Show astronomical data
 F11	Decrement Freeze DF
 F12	Increment Freeze DF
 Alt+1 to Alt+6  Tx1 to Tx6
 Alt+A	Toggle Auto On/Off
+Alt+C	Clear average
 Alt+D	Decode
 Ctrl+D	Force Decode 
 Shift+Ctrl+D  Force Decode, no JT65 shorthands 
 Alt+E	Erase
 Alt+F	Toggle Freeze
-Alt+G	Generate Standard Messages
-Ctrl+G	Generate Alternate JT65 Messages
+Alt+G	Generate standard messages
+Ctrl+G	Generate alternate JT65/JT4 Messages
 Alt+I	Include
 Alt+L	Lookup
 Ctrl+L	Lookup, then Generate Standard Messages
 Alt+M	Monitor
 Alt+O	Tx Stop
 Alt+Q	Log QSO
+Alt+R	Enter report
 Alt+S	Stop Monitoring or Decoding
 Alt+V	Save Last
 Alt+X	Exclude
@@ -910,21 +908,6 @@
     Label(scwid,text=t,justify=LEFT).pack(padx=20)
     scwid.focus_set()
 
-#------------------------------------------------------ wspr_msgs
-def wspr_msgs(event=NONE):
-    scwid=Toplevel(root)
-    scwid.geometry(msgpos())
-    if g.Win32: scwid.iconbitmap(&quot;wsjt.ico&quot;)
-    t=&quot;&quot;&quot;
-Examples of &quot;partially canned&quot; message parameters
-
-wx:    CLEAR CLOUDY RAIN SNOW
-temp:  76 F    -5 C
-wind:  CALM BREEZES WINDY
-&quot;&quot;&quot;
-    Label(scwid,text=t,justify=LEFT).pack(padx=20)
-    scwid.focus_set()
-
 #------------------------------------------------------ mouse_commands
 def mouse_commands(event=NONE):
     scwid=Toplevel(root)
@@ -933,18 +916,18 @@
     t=&quot;&quot;&quot;
 Click on          Action
 --------------------------------------------------------
-Waterfall        FSK441/JT6M: click to decode ping
+Waterfall        FSK441, JTMS: click to decode region
                       JT65: Click to set DF for Freeze
                        Double-click to Freeze and Decode
 
-Main screen,     FSK441/JT6M: click to decode ping
+Main screen,     FSK441, JTMS, ISCAT: click to decode ping
 graphics area    JT65: Click to set DF for Freeze
                            Double-click to Freeze and Decode
 
 Main screen,     Double-click puts callsign in Tx messages
 text area           Right-double-click also sets Auto ON
 
-Sync, Clip,      Left/Right click to increase/decrease
+Sync, S,         Left/Right click to increase/decrease
 Tol, ...
 &quot;&quot;&quot;
     Label(scwid,text=t,justify=LEFT).pack(padx=20)
@@ -961,7 +944,7 @@
 information by other means (e.g., internet, telephone, ...) while the
 QSO is in progress!
 
-FSK441 or JT6M:   If you have received
+FSK441, JTMS, or ISCAT:   If you have received
     ... less than both calls from the other station, send both calls.
     ... both calls, send both calls and your signal report.
     ... both calls and signal report, send R and your report.
@@ -969,11 +952,11 @@
     ... RRR, the QSO is complete.  However, the other station may not
 know this, so it is conventional to send 73 to signify that you are done.
 
-(Outside of North America, the customary procedures for FSK441
-and JT6M may be slightly different.)
+(Outside of North America, the customary procedures may be slightly
+different.)
 
 
-JT65:   If you have received
+JT65, JT4:   If you have received
     ... less than both calls, send both calls and your grid locator.
     ... both calls, send both calls, your grid locator, and OOO.
     ... both calls and OOO, send RO.
@@ -994,7 +977,7 @@
     if g.Win32: screenf5s.iconbitmap(&quot;wsjt.ico&quot;)
     t=&quot;&quot;&quot;
 The following are recommended sequences for  minimal QSOs
-using the standard JT65 messages:
+using the standard JT65/JT4 messages:
 
 Station #1                            Station #2
 ----------------------------------------------------------
@@ -1014,6 +997,21 @@
 &quot;&quot;&quot;
     Label(screenf5s,text=t,justify=LEFT).pack(padx=20)
     screenf5s.focus_set()
+
+#------------------------------------------------------ usersguide
+def usersguide(event=NONE):
+    url='<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSJT_User_600.pdf">http://physics.princeton.edu/pulsar/K1JT/WSJT_User_600.pdf</A>'
+    thread.start_new_thread(browser,(url,))
+
+#------------------------------------------------------ wsjt9supp
+def wsjt9supp(event=NONE):
+    url='<A HREF="http://physics.princeton.edu/pulsar/K1JT/WSJT_9.0_Supplement.pdf">http://physics.princeton.edu/pulsar/K1JT/WSJT_9.0_Supplement.pdf</A>'
+    thread.start_new_thread(browser,(url,))
+
+#------------------------------------------------------- browser
+def browser(url):
+    webbrowser.open(url)
+
 #------------------------------------------------------ prefixes
 def prefixes(event=NONE):
     pfx=Toplevel(root)
@@ -1051,9 +1049,8 @@
         labHotAB.configure(text=&quot;&quot;,bg='gray85')
         labDist.configure(text=&quot;&quot;)
     else:
-        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-               mode.get()[:3]=='JT4' or mode.get()[:2]==&quot;CW&quot; or \
-               mode.get()=='WSPR' or mode.get()[:4]=='JT64':
+        if mode.get()[:4]=='JT65' or \
+               mode.get()[:3]=='JT4' or mode.get()[:2]==&quot;CW&quot;:
             labAz.configure(text=&quot;Az: %d&quot; % (naz,))
             labHotAB.configure(text=&quot;&quot;,bg='gray85')
         else:
@@ -1081,28 +1078,11 @@
         isync=isync-1
         lsync.configure(text=slabel+str(isync))
 
-#------------------------------------------------------ incclip
-def incclip(event):
-    global iclip
-    if iclip&lt;5:
-        iclip=iclip+1
-        if iclip==5: iclip=99
-        lclip.configure(text='Clip   '+str(iclip))
-
-#------------------------------------------------------ decclip
-def decclip(event):
-    global iclip
-    if iclip&gt;-5:
-        iclip=iclip-1
-        if iclip==98: iclip=4
-        lclip.configure(text='Clip   '+str(iclip))
-
 #------------------------------------------------------ inctol
 def inctol(event=NONE):
     global itol
     maxitol=5
-    if mode.get()[:4]=='JT65' or mode.get()[:4]=='JT64': maxitol=6
-    if mode.get()=='WSPR': maxitol=3
+    if mode.get()[:4]=='JT65': maxitol=6
     if itol&lt;maxitol: itol=itol+1
     ltol.configure(text='Tol    '+str(ntol[itol]))
 
@@ -1131,22 +1111,24 @@
     Audio.gcom1.ndsec=idsec
 
 #------------------------------------------------------ toggle_shift
-def toggle_shift(event):
-    Audio.gcom2.nadd5=1-Audio.gcom2.nadd5
-    if Audio.gcom2.nadd5:
-        bg='red'
-        lshift.configure(text='Shift 5.0',bg=bg)
-    else:
-        bg='white'
-        lshift.configure(text='Shift 0.0',bg=bg)
+##def toggle_shift(event):
+##    Audio.gcom2.nadd5=1-Audio.gcom2.nadd5
+##    if Audio.gcom2.nadd5:
+##        bg='red'
+##        lshift.configure(text='Shift 5.0',bg=bg)
+##    else:
+##        bg='white'
+##        lshift.configure(text='Shift 0.0',bg=bg)
 
 #------------------------------------------------------ inctrperiod
 def inctrperiod(event):
     global ncwtrperiod
-    if mode.get()[:2]==&quot;CW&quot;:
+    if mode.get()==&quot;CW&quot;:
         if ncwtrperiod==120: ncwtrperiod=150
         if ncwtrperiod==60:  ncwtrperiod=120
         Audio.gcom1.trperiod=ncwtrperiod
+    elif mode.get()==&quot;FSK441&quot; or mode.get()==&quot;JTMS&quot; or mode.get()==&quot;ISCAT&quot;:
+        if Audio.gcom1.trperiod==15: Audio.gcom1.trperiod=30
 
 #------------------------------------------------------ dectrperiod
 def dectrperiod(event):
@@ -1155,13 +1137,14 @@
         if ncwtrperiod==120: ncwtrperiod=60
         if ncwtrperiod==150: ncwtrperiod=120
         Audio.gcom1.trperiod=ncwtrperiod
+    elif mode.get()==&quot;FSK441&quot; or mode.get()==&quot;JTMS&quot; or mode.get()==&quot;ISCAT&quot;:
+        if Audio.gcom1.trperiod==30: Audio.gcom1.trperiod=15
 
 #------------------------------------------------------ erase
 def erase(event=NONE):
     graph1.delete(ALL)
     if mode.get()[:4]!=&quot;JT65&quot; and mode.get()[:2]!=&quot;CW&quot; and \
-            mode.get()!=&quot;WSPR&quot; and mode.get()[:3]!='JT2' and \
-            mode.get()[:3]!='JT4' and mode.get()[:4]!='JT64':
+            mode.get()[:3]!='JT4' and mode.get()!='Diana':
         graph2.delete(ALL)
     text.configure(state=NORMAL)
     text.delete('1.0',END)
@@ -1182,22 +1165,18 @@
     Audio.gcom2.nclearave=1
 
 #------------------------------------------------------ defaults
-def defaults():
-    global slabel,isync,iclip,itol,idsec
-    isync=1
-    if g.mode==&quot;FSK441&quot;: isync=2
-    iclip=0
-    lclip.configure(text='Clip   '+str(iclip))
-    itol=5
-    ltol.configure(text='Tol    '+str(ntol[itol]))
-    if g.mode==&quot;JT6M&quot;:
-        isync=-10
-        itol=4
-        ltol.configure(text='Tol    '+str(ntol[itol]))
-    if g.mode==&quot;WSPR&quot;:
-        itol=3
-        ltol.configure(text='Tol    '+str(ntol[itol]))
-    lsync.configure(text=slabel+str(isync))
+##def defaults():
+##    global slabel,isync,itol,idsec
+##    isync=1
+##    if g.mode==&quot;FSK441&quot; or g.mode==&quot;JTMS&quot;: isync=2
+##    itol=5
+##    ltol.configure(text='Tol    '+str(ntol[itol]))
+##    if g.mode==&quot;JT6M&quot; or g.mode==&quot;ISCAT&quot;:
+##        isync=-10
+##        if g.mode==&quot;ISCAT&quot;: isync=-20
+##        itol=4
+##        ltol.configure(text='Tol    '+str(ntol[itol]))
+##    lsync.configure(text=slabel+str(isync))
 
 #------------------------------------------------------ delwav
 def delwav():
@@ -1224,13 +1203,13 @@
     global lauto
     lauto=1-lauto
     Audio.gcom2.lauto=lauto
-    if lauto:
+    if lauto and mode.get()!='Echo':
         monitor()
     else:
         Audio.gcom1.txok=0
         Audio.gcom2.mantx=0
     if lauto==0: auto.configure(text='Auto is OFF',bg='gray85',relief=RAISED)
-    if lauto==1: auto.configure(text='Auto is ON',bg='red',relief=SOLID)
+    if lauto==1: auto.configure(text='Auto is  ON',bg='red',relief=SOLID)
     
 #------------------------------------------------------ toggletxdf
 def toggletxdf(event=NONE):
@@ -1238,54 +1217,54 @@
     ltxdf=1-ltxdf
     if ltxdf:
         Audio.gcom2.ntxdf=Audio.gcom2.mousedf
-        t=&quot;TxDF = %d&quot; % (int(Audio.gcom2.mousedf),)
+        t=&quot;  TxDF =%4d&quot; % (int(Audio.gcom2.mousedf),)
         btxdf.configure(text=t,bg='red',relief=SOLID)
     else:
         Audio.gcom2.ntxdf=0
-        btxdf.configure(text='TxDF = 0',bg='gray85',relief=RAISED)
+        t=&quot;  TxDF =%4d&quot; % 0
+        btxdf.configure(text=t,bg='gray85',relief=RAISED)
     if Audio.gcom1.transmitting:
         txstop()
 
 #----------------------------------------------------- dtdf_change
 # Readout of graphical cursor location
 def dtdf_change(event):
-    if mode.get()[:4]!='JT65' and mode.get()[:3]!='JT2' and \
-               mode.get()[:3]!='JT4' and mode.get()[:4]!='WSPR' \
-               and mode.get()[:4]!='JT64':
-        t=&quot;%.1f&quot; % (event.x*30.0/500.0,)
-        lab6.configure(text=t,bg='green')
-    else:
+    if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4' or mode.get()=='Diana':
         if event.y&lt;40 and Audio.gcom2.nspecial==0:
             lab1.configure(text='Time (s)',bg=&quot;#33FFFF&quot;)   #light blue
-            t=&quot;%.1f&quot; % (12.0*event.x/500.0-2.0,)
+            if mode.get()=='Diana':
+                t=&quot;%.1f&quot; % (4.458*event.x/500.0-0.6,)
+            else:
+                t=&quot;%.1f&quot; % (12.0*event.x/500.0-2.0,)
             lab6.configure(text=t,bg=&quot;#33FFFF&quot;)
         elif (event.y&gt;=40 and event.y&lt;95) or \
                  (event.y&lt;95 and Audio.gcom2.nspecial&gt;0):
             lab1.configure(text='DF (Hz)',bg='red')
             idf=Audio.gcom2.idf
-            if mode.get()[:4]=='WSPR':
-                t=&quot;%d&quot; % int(0.7324*(event.x-250.0))
-            else:
-                t=&quot;%d&quot; % int(idf+1200.0*event.x/500.0-600.0,)
+            t=&quot;%d&quot; % int(idf+1200.0*event.x/500.0-600.0,)
             lab6.configure(text=t,bg=&quot;red&quot;)
         else:
             lab1.configure(text='Time (s)',bg='green')
-            if mode.get()=='WSPR':
-                t=&quot;%.1f&quot; % (114.0*event.x/500.0,)
+            if mode.get()=='Diana':
+                t=&quot;%.1f&quot; % (event.x*30.0/500.0,)
             else:
                 t=&quot;%.1f&quot; % (53.0*event.x/500.0,)
             lab6.configure(text=t,bg=&quot;green&quot;)
+    elif mode.get()=='Echo':
+        lab1.configure(text='DF (Hz)',bg='red')
+##        t=&quot;%d&quot; % int((event.x-250),)
+        t=&quot;%d&quot; % int(0.3365*(event.x-250),)
+        lab6.configure(text=t,bg=&quot;red&quot;)
+    else:
+        t=&quot;%.1f&quot; % (event.x*30.0/500.0,)
+        lab6.configure(text=t,bg='green')
 
 #---------------------------------------------------- mouse_click_g1
 def mouse_click_g1(event):
     global nopen
     if not nopen:
-        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-               mode.get()[:3]=='JT4' or mode.get()[:4]=='JT64':
+        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4':
             Audio.gcom2.mousedf=int(Audio.gcom2.idf+(event.x-250)*2.4)
-        elif mode.get()=='WSPR':
-# Fix this: ??  (idf dependence?)
-            Audio.gcom2.mousedf=int(Audio.gcom2.idf+(event.x-250)*0.7324)
         else:
             if Audio.gcom2.ndecoding==0:              #If decoder is busy, ignore
                 Audio.gcom2.nagain=1
@@ -1299,9 +1278,8 @@
 
 #------------------------------------------------------ double-click_g1
 def double_click_g1(event):
-    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-        mode.get()[:3]=='JT4' or mode.get()=='WSPR' \
-        or mode.get()[:4]=='JT64') and Audio.gcom2.ndecoding==0:
+    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4') and \
+        Audio.gcom2.ndecoding==0:
         g.freeze_decode=1
     
 #------------------------------------------------------ mouse_up_g1
@@ -1321,7 +1299,7 @@
     n=5*int(Audio.gcom2.mousedf/5)
     if n==Audio.gcom2.mousedf: n=n-5
     Audio.gcom2.mousedf=n
-    
+
 #------------------------------------------------------ GenStdMsgs
 def GenStdMsgs(event=NONE):
     global altmsg,MyCall0,addpfx0,ToRadio0
@@ -1332,7 +1310,8 @@
     Audio.gcom2.hiscall=(ToRadio.get()+(' '*12))[:12]
     for m in (tx1, tx2, tx3, tx4, tx5, tx6):
         m.delete(0,99)
-    if mode.get()==&quot;FSK441&quot; or mode.get()==&quot;JT6M&quot;:
+    if mode.get()==&quot;FSK441&quot; or mode.get()==&quot;ISCAT&quot; or \
+       mode.get()=='JTMS' or mode.get()=='Diana':
         r=report.get()
         tx1.insert(0,setmsg(options.tx1.get(),r))
         tx2.insert(0,setmsg(options.tx2.get(),r))
@@ -1340,8 +1319,10 @@
         tx4.insert(0,setmsg(options.tx4.get(),r))
         tx5.insert(0,setmsg(options.tx5.get(),r))
         tx6.insert(0,setmsg(options.tx6.get(),r))
-    elif mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-               mode.get()[:3]=='JT4':
+        if tx3.get()=='ROOO':
+            tx3.delete(0,END)
+            tx3.insert(0,'RO')
+    elif mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4':
         if options.MyCall.get()!= MyCall0 or \
                options.addpfx.get()!= addpfx0 or ToRadio.get()!=ToRadio0:
             MyCall0=options.MyCall.get()
@@ -1384,48 +1365,6 @@
         tx4.insert(0,ToRadio.get() + &quot; &quot; + options.MyCall.get()+&quot; [RRR]&quot;)
         tx5.insert(0,ToRadio.get() + &quot; &quot; + options.MyCall.get()+&quot; [73]&quot;)
         tx6.insert(0,&quot;[CQ &quot; + options.MyCall.get() + &quot;]&quot;)
-    elif mode.get()==&quot;WSPR&quot; or mode.get()[:4]=='JT64':
-        if options.MyCall.get()!= MyCall0 or \
-               options.addpfx.get()!= addpfx0 or ToRadio.get()!=ToRadio0:
-            MyCall0=options.MyCall.get()
-            addpfx0=options.addpfx.get()
-            ToRadio0=ToRadio.get()
-            t0=(&quot;SM5BSZ &quot;+options.MyCall.get()).upper()
-            Audio.gcom2.t0msg=(t0+' '*22)[:22]
-            nplain,naddon,ndiff=Audio.chkt0()
-            if nplain==1:
-                MsgBox(&quot;Bad 'MyCall' or bad prefix/suffix?\nPlease check on Setup | Options screen.&quot;)
-                options1()
-            t0=(&quot;SM5BSZ &quot;+ToRadio0).upper()
-            Audio.gcom2.t0msg=(t0+' '*22)[:22]
-            nplain,naddon,ndiff=Audio.chkt0()
-            if nplain==1:
-                MsgBox(&quot;Bad callsign in 'To Radio'?\nPlease check.&quot;)
-            
-        t0=(&quot;&lt;&quot; + ToRadio.get() + &quot;&gt; &quot;+options.MyCall.get()).upper()
-        Audio.gcom2.t0msg=(t0+' '*22)[:22]
-##        nplain,naddon,ndiff=Audio.chkt0()
-##        if nplain==0 and naddon==0 and ndiff==0:
-##            t0=t0 + &quot; &quot;+options.MyGrid.get()[:4]
-        tx1.insert(0,t0.upper())
-        r=report.get()
-        t2=(ToRadio.get() + &quot; &lt;&quot;+options.MyCall.get() + &quot;&gt; &quot; + r).upper()
-        Audio.gcom2.t0msg=(t0+' '*22)[:22]
-        tx2.insert(0,t2)
-        t3=(ToRadio.get() + &quot; &lt;&quot;+options.MyCall.get() + &quot;&gt; R &quot; + r).upper()
-        tx3.insert(0,t3)
-        t4=(&quot;&lt;&quot; + ToRadio.get() + &quot;&gt; &quot; + options.MyCall.get() + &quot; RRR&quot;).upper()
-        tx4.insert(0,t4)
-        t5=(&quot;73 DE &quot;+options.MyCall.get()+ &quot; &quot;+options.MyGrid.get()[:4]).upper()
-        tx5.insert(0,t5)
-
-        t0=&quot;CQ &quot; + options.MyCall.get().upper()
-        Audio.gcom2.t0msg=(t0+' '*22)[:22]
-        nplain,naddon,ndiff=Audio.chkt0()
-        if nplain==0 and naddon==0 and ndiff==0:
-            t0=t0 + &quot; &quot;+options.MyGrid.get()[:4]
-        tx6.insert(0,t0.upper())
-        altmsg=0
     
 #------------------------------------------------------ GenAltMsgs
 def GenAltMsgs(event=NONE):
@@ -1435,7 +1374,7 @@
     ToRadio.insert(0,t)
     if k2txb.get()!=0: ntx.set(1)
     Audio.gcom2.hiscall=(ToRadio.get()+(' '*12))[:12]
-    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
+    if (mode.get()[:4]=='JT65' or mode.get()=='Diana' or \
         mode.get()[:3]=='JT4') and ToRadio.get().find(&quot;/&quot;) == -1 and \
                options.MyCall.get().find(&quot;/&quot;) == -1:
         for m in (tx1, tx2, tx3, tx4, tx5, tx6):
@@ -1452,6 +1391,20 @@
 #------------------------------------------------------ setmsg
 def setmsg(template,r):
     msg=&quot;&quot;
+    t=options.MyCall.get()
+    n=len(t)
+    MySuffix=t[n-3:]
+    n2=MySuffix.find('/')
+    if(n2&gt;=0): MySuffix=t[n-5:n-2]
+    if MySuffix[0:1].isdigit()or MySuffix[1:2].isdigit():
+        MySuffix=MySuffix[1:]
+    t=ToRadio.get()
+    n=len(t)
+    HisSuffix=t[n-3:]
+    n2=HisSuffix.find('/')
+    if(n2&gt;=0): HisSuffix=t[n-5:n-2]
+    if HisSuffix[0:1].isdigit()or HisSuffix[1:2].isdigit():
+        HisSuffix=HisSuffix[1:]
     npct=0
     for i in range(len(template)):
         if npct:
@@ -1460,6 +1413,8 @@
             if template[i]==&quot;R&quot;: msg=msg+r
             if template[i]==&quot;G&quot;: msg=msg+options.MyGrid.get()[:4]
             if template[i]==&quot;L&quot;: msg=msg+options.MyGrid.get()
+            if template[i]==&quot;S&quot;: msg=msg+MySuffix
+            if template[i]==&quot;H&quot;: msg=msg+HisSuffix
             npct=0
         else:
             npct=0
@@ -1468,13 +1423,55 @@
             else:
                 msg=msg+template[i]            
     return msg.upper()
-    
+
+#------------------------------------------------------ plot_echo
+def plot_echo():
+    &quot;Plot red and blue curves for Echo mode.&quot;
+    graph1.delete(ALL)
+    y1=[]
+    y2=[]
+    for i in range(446):        #Find ymax for magenta/orange curves
+        ss1=Audio.gcom2.ss1[i+1]
+        y1.append(ss1)
+        ss2=Audio.gcom2.ss2[i+1]
+        y2.append(ss2)
+    ymax=max(y1+y2)
+    yfac=0.5
+    if ymax&gt;80.0/yfac: yfac=80.0/ymax
+    xy1=[]
+    xy2=[]
+    fac=500.0/446.0
+    for i in range(446):        #Make xy list for magenta/orange curves
+        x=i*fac
+        ss1=Audio.gcom2.ss1[i+1]
+        n=int(90.0-yfac*ss1) + 20
+        xy1.append(x)
+        xy1.append(n)
+        ss2=Audio.gcom2.ss2[i+1]
+        n=int(90.0-yfac*ss2)
+        xy2.append(x)
+        xy2.append(n)
+    graph1.create_line(xy1,fill='#33FFFF')            #Light blue
+    graph1.create_line(xy2,fill=&quot;red&quot;)
+
+#------------------------------------------------------ plot_meas
+def plot_meas(nmeas,db):
+    global xypm
+    graph1.delete(ALL)
+    if nmeas&lt;2:
+        xypm=[]
+    xypm.append(nmeas)
+    n=int(60.0-3.0*db)
+    xypm.append(n)
+    if nmeas&gt;=2:
+        graph1.create_line(xypm,fill=&quot;green&quot;)
+
 #------------------------------------------------------ plot_large
 def plot_large():
     &quot;Plot the green, red, and blue curves.&quot;
+    ngreen=Audio.gcom2.ngreen
     graph1.delete(ALL)
     y=[]
-    ngreen=Audio.gcom2.ngreen
     if ngreen&gt;0:
         for i in range(ngreen):             #Find ymax for green curve
             green=Audio.gcom2.green[i]
@@ -1487,12 +1484,14 @@
         for i in range(ngreen):             #Make xy list for green curve
             green=Audio.gcom2.green[i]
             n=int(105.0-yfac*green)
-            xy.append(i)
+            if mode.get()=='Diana':
+                xy.append(2*i)
+            else:
+                xy.append(i)
             xy.append(n)
         graph1.create_line(xy,fill=&quot;green&quot;)
 
-        if Audio.gcom2.nspecial==0 or mode.get()[:3]=='JT2' or \
-                mode.get()[:3]=='JT4':
+        if Audio.gcom2.nspecial==0 or mode.get()[:3]=='JT4':
             y=[]
             for i in range(446):                #Find ymax for red curve
                 psavg=Audio.gcom2.psavg[i+1]
@@ -1504,10 +1503,8 @@
             fac=500.0/446.0
             for i in range(446):                #Make xy list for red curve
                 x=i*fac
-                if mode.get()[:3]=='JT2' or mode.get()[:3]=='JT4':
+                if mode.get()[:3]=='JT4':
                     x=i*500.0/548.571 + 47                      #empirical
-                if mode.get()[:4]=='WSPR':
-                    x=(i-224) + 250                #empirical
                 psavg=Audio.gcom2.psavg[i+1]
                 n=int(90.0-yfac*psavg)
                 xy.append(x)
@@ -1551,18 +1548,21 @@
 
         if Audio.gcom2.ccf[0] != -9999.0:
             y=[]
-            for i in range(65):             #Find ymax for blue curve
+            iz=65
+            if mode.get()=='Diana':
+                iz=96
+            fac=500.0/iz
+            for i in range(iz):             #Find ymax for blue curve
                 ccf=Audio.gcom2.ccf[i]
                 y.append(ccf)
             ymax=max(y)
             yfac=40.0
             if ymax&gt;55.0/yfac: yfac=55.0/ymax
             xy2=[]
-            fac=500.0/64.6
-            for i in range(65):             #Make xy list for blue curve
+            for i in range(iz):             #Make xy list for blue curve
                 x=(i+0.5)*fac
-                if mode.get()[:3]=='JT2' or mode.get()[:3]=='JT4':
-                    x=(i+0.5)*500.0/105.0 + 15     #15 is empirical
+                if mode.get()[:3]=='JT4':
+                    x=(i+0.5)*500.0/105.0 + 15      #15 is empirical
                 ccf=Audio.gcom2.ccf[i]
                 n=int(60.0-yfac*ccf)
                 xy2.append(x)
@@ -1584,7 +1584,7 @@
                 graph1.create_line([x,0,x,125-j2],fill=&quot;red&quot;)
 
 #------------------------------------------------------ plot_small
-def plot_small():        
+def plot_small():
     graph2.delete(ALL)
     xy=[]
     xy2=[]
@@ -1594,18 +1594,15 @@
         x=int(i*df*fac)
         xy.append(x)
         psavg=Audio.gcom2.psavg[i]
-        if mode.get()==&quot;JT6M&quot;: psavg=psavg + 27.959
         n=int(150.0-2*psavg)
         xy.append(n)
-        if mode.get()=='FSK441':    
+        if mode.get()=='FSK441' or mode.get()==&quot;JTMS&quot;:
             ps0=Audio.gcom2.ps0[i]
             n=int(150.0-2*ps0)
             xy2.append(x)
             xy2.append(n)
     graph2.create_line(xy,fill=&quot;magenta&quot;)
-    if mode.get()=='JT6M':
-        plot_yellow()
-    elif mode.get()=='FSK441':
+    if mode.get()=='FSK441' or mode.get()==&quot;JTMS&quot;:
         graph2.create_line(xy2,fill=&quot;red&quot;)
         for i in range(4):
             x=(i+2)*441*fac
@@ -1616,31 +1613,31 @@
         if i%2: ytop=115
         graph2.create_line([x,120,x,ytop],fill=&quot;white&quot;)
 
-#------------------------------------------------------ plot_yellow
-def plot_yellow():
-    nz=int(Audio.gcom2.ps0[215])
-    if nz&gt;10:
-        y=[]
-        for i in range(nz):             #Find ymax for yellow curve
-            n=Audio.gcom2.ps0[i]
-            y.append(n)
-        ymax=max(y)
-        fac=1.0
-        if ymax&gt;60: fac=60.0/ymax
-        xy2=[]
-        for i in range(nz):
-            x=int(2.34*i)
-            y=fac*Audio.gcom2.ps0[i] + 8
-            n=int(85.0-y)
-            xy2.append(x)
-            xy2.append(n)
-        graph1.create_line(xy2,fill=&quot;yellow&quot;)
+###------------------------------------------------------ plot_yellow
+##def plot_yellow():
+##    nz=int(Audio.gcom2.ps0[215])
+##    if nz&gt;10:
+##        y=[]
+##        for i in range(nz):             #Find ymax for yellow curve
+##            n=Audio.gcom2.ps0[i]
+##            y.append(n)
+##        ymax=max(y)
+##        fac=1.0
+##        if ymax&gt;60: fac=60.0/ymax
+##        xy2=[]
+##        for i in range(nz):
+##            x=int(2.34*i)
+##            y=fac*Audio.gcom2.ps0[i] + 8
+##            n=int(85.0-y)
+##            xy2.append(x)
+##            xy2.append(n)
+##        graph1.create_line(xy2,fill=&quot;yellow&quot;)
 
 #------------------------------------------------------ update
 def update():
     global root_geom,isec0,naz,nel,ndmiles,ndkm,nhotaz,nhotabetter,nopen, \
-           im,pim,cmap0,isync,isync441,isync6m,isync65,isync_save,idsec, \
-           first,itol,txsnrdb,tx6alt
+           im,pim,cmap0,isync,isync441,isync_iscat,isync65,       \
+           isync_save,idsec,first,itol,txsnrdb,tx6alt,nmeas
     
     utc=time.gmtime(time.time()+0.1*idsec)
     isec=utc[5]
@@ -1662,14 +1659,26 @@
             options.MyGrid.get().upper(),HisGrid.get().upper(),utchours)
         azdist()
         g.nfreq=nfreq.get()
+
+        if tx1.get()[0:2]=='GO' and mode.get()=='Echo':
+            try:
+                nmin=int(tx1.get()[3:5])
+            except:
+                nmin=10
+            if isec==0 and (utc[4]%nmin)==0 and lauto==0:
+                toggleauto()
+            if isec==4 and (utc[4]%nmin)==1 and lauto==1:
+                toggleauto()
+                Audio.gcom2.nsumecho=0
         
         if Audio.gcom2.ndecoding==0:
             g.AzSun,g.ElSun,g.AzMoon,g.ElMoon,g.AzMoonB,g.ElMoonB,g.ntsky, \
                 g.ndop,g.ndop00,g.dbMoon,g.RAMoon,g.DecMoon,g.HA8,g.Dgrd,  \
                 g.sd,g.poloffset,g.MaxNR,g.dfdt,g.dfdt0,g.RaAux,g.DecAux, \
-                g.AzAux,g.ElAux = Audio.astro0(utc[0],utc[1],utc[2],  \
-                utchours,nfreq.get(),options.MyGrid.get().upper(), \
-                    options.auxra.get()+(' '*9)[:9],     \
+                g.AzAux,g.ElAux,g.w1,g.w2,g.w501,g.w502,g.xlst = Audio.astro0( \
+                    utc[0],utc[1],utc[2],utchours,nfreq.get(),            \
+                    options.MyGrid.get().upper(),       \
+                    options.auxra.get()+(' '*9)[:9],    \
                     options.auxdec.get()+(' '*9)[:9])
 
             if len(HisGrid.get().strip())&lt;4:
@@ -1681,9 +1690,9 @@
             else:
                 Audio.gcom2.ntx2=0
 
-        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-               mode.get()[:3]=='JT4' or mode.get()[:2]=='CW' or \
-               mode.get()=='WSPR' or mode.get()[:4]=='JT64':
+        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4'\
+               or mode.get()[:2]=='CW' or mode.get()=='Echo' \
+               or mode.get()=='Diana' or mode.get()=='Measure':
             graph2.delete(ALL)
             graph2.create_text(80,13,anchor=CENTER,text=&quot;Moon&quot;,font=g2font)
             graph2.create_text(13,37,anchor=W, text=&quot;Az: %6.2f&quot; % g.AzMoon,font=g2font)
@@ -1691,9 +1700,20 @@
             graph2.create_text(13,85,anchor=W, text=&quot;Dop:%6d&quot; % g.ndop,font=g2font)
             graph2.create_text(13,109,anchor=W,text=&quot;Dgrd:%5.1f&quot; % g.Dgrd,font=g2font)
 
-    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-        mode.get()[:3]=='JT4' or mode.get()=='WSPR' \
-        or mode.get()[:4]=='JT64') and g.freeze_decode:
+        if mode.get()=='Measure' and Audio.gcom2.monitoring:
+            nmeas=nmeas+1
+            if nmeas&gt;500: nmeas=1
+            db=20.0*log10(g.rms/770.0+0.01)
+            t=&quot;%5d  %6.1f\n&quot; % (nmeas,db,)
+            text.configure(state=NORMAL)
+            text.insert(END,t)
+            text.see(END)
+            plot_meas(nmeas,db)
+        else:
+            nmeas=0
+
+    if (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4' \
+        or mode.get()=='Diana') and g.freeze_decode:
         itol=2
         ltol.configure(text='Tol    '+str(50))
         Audio.gcom2.dftolerance=50
@@ -1729,24 +1749,28 @@
             msg2.configure(bg='#FFFF00')
         elif mode.get()[:4]==&quot;JT65&quot;:
             msg2.configure(bg='#00FFFF')
-        elif mode.get()==&quot;JT6M&quot;:
-            msg2.configure(bg='#FF00FF')
         elif mode.get()==&quot;CW&quot;:
             msg2.configure(bg='#00FF00')
-        elif mode.get()==&quot;WSPR&quot;:
-            msg2.configure(bg='#FF8888')
-        elif mode.get()[:4]==&quot;JT64&quot;:
+        elif mode.get()[:5]==&quot;ISCAT&quot;:
             msg2.configure(bg='#CCFFFF')
-        elif mode.get()==&quot;JT2&quot;:
-            msg2.configure(bg='#8888FF')
+        elif mode.get()[:5]==&quot;Diana&quot;:
+            msg2.configure(bg='#CCFF00')
+        elif mode.get()[:4]==&quot;JTMS&quot;:
+            msg2.configure(bg='#CC4444')
         elif mode.get()[:3]==&quot;JT4&quot;:
             msg2.configure(bg='#88FF88')
-#        elif mode.get()==&quot;Echo&quot;:
-#            msg2.configure(bg='#FF0000')
+        elif mode.get()==&quot;Echo&quot;:
+            msg2.configure(bg='#FF0000')
+        elif mode.get()==&quot;Measure&quot;:
+            msg2.configure(bg='#FF8800')
         g.mode=mode.get()
-        if first: GenStdMsgs()
+        if first and mode.get()!='Echo': GenStdMsgs()
         first=0
 
+    if options.genmsg.get():
+        GenStdMsgs()
+        options.genmsg.set(0)
+
     samfac_in=Audio.gcom1.mfsample/110250.0
     samfac_out=Audio.gcom1.mfsample2/110250.0
     xin=1
@@ -1764,7 +1788,8 @@
         pass
 
     msg1.configure(text=&quot;%6.4f %6.4f&quot; % (samfac_in,samfac_out))
-    msg2.configure(text=mode.get())
+    t=mode.get()
+    msg2.configure(text=t)
     t=&quot;Freeze DF:%4d&quot; % (int(Audio.gcom2.mousedf),)
     if abs(int(Audio.gcom2.mousedf))&gt;600:
         msg3.configure(text=t,fg='black',bg='red')
@@ -1777,21 +1802,25 @@
         bdecode.configure(bg='#66FFFF',activebackground='#66FFFF')
         if (sys.platform == 'darwin'):
            bdecode.configure(text='*Decode*')
-    if mode.get()[:2]==&quot;CW&quot;:
-        msg5.configure(text=&quot;TR Period: %d s&quot; % (Audio.gcom1.trperiod,), \
-                       bg='white')
+    msg5.configure(text=&quot;T/R Period: %d s&quot; % (Audio.gcom1.trperiod,))
+    if mode.get()==&quot;CW&quot;: color='white'
+    elif mode.get()=='FSK441' or mode.get()=='JTMS' or mode.get()=='ISCAT':
+        if(Audio.gcom1.trperiod==15): color='yellow'
+        else: color='white'
     else:
-        msg5.configure(text=&quot;TR Period: %d s&quot; % (Audio.gcom1.trperiod,), \
-                       bg='gray85')
-    t=&quot;%d&quot; % (int(Audio.mtxcom.mtxstate),)
-    msg6.configure(text=t)
+        color='gray85'
+    msg5.configure(bg=color)
 
     tx1.configure(bg='white')
     tx2.configure(bg='white')
     tx3.configure(bg='white')
     tx4.configure(bg='white')
     tx5.configure(bg='white')
-    if len(tx5.get())&gt;13: tx5.configure(bg='pink')
+    if len(tx5.get())&gt;13 and \
+            (mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4'):
+        Audio.gcom2.t0msg=(tx5.get()+' '*22)[:22]
+        nplain,naddon,ndiff=Audio.chkt0()
+        if nplain==1: tx5.configure(bg='pink')
     tx6.configure(bg='white')
     if tx6.get()[:1]=='#':
         try:
@@ -1815,6 +1844,10 @@
     if Audio.gcom1.transmitting:
         nmsg=int(Audio.gcom2.nmsg)
         t=g.ftnstr(Audio.gcom2.sending)
+        if mode.get()=='Echo':
+            t='ECHO TEST'
+            nmsg=9
+            Audio.gcom2.ntxnow=0
         t=&quot;Txing:  &quot;+t[:nmsg]
         bgcolor='yellow'
         if Audio.gcom2.sendingsh==1:  bgcolor='#66FFFF'    #Shorthand (lt blue)
@@ -1826,7 +1859,7 @@
         elif Audio.gcom2.ntxnow==3: tx3.configure(bg=bgcolor)
         elif Audio.gcom2.ntxnow==4: tx4.configure(bg=bgcolor)
         elif Audio.gcom2.ntxnow==5: tx5.configure(bg=bgcolor)
-        else: tx6.configure(bg=bgcolor)
+        elif Audio.gcom2.ntxnow==6: tx6.configure(bg=bgcolor)
     else:
         bgcolor='green'
         t='Receiving'
@@ -1869,11 +1902,12 @@
             im.putpalette(g.palette)
             cmap0=g.cmap
 
-        if mode.get()[:4]=='JT65' or mode.get()[:3]=='JT2' or \
-                mode.get()[:3]=='JT4' or mode.get()=='WSPR' \
-                or mode.get()[:4]=='JT64':
+        if mode.get()=='Echo':
+            plot_echo()
+        elif mode.get()[:4]=='JT65' or mode.get()[:3]=='JT4' or \
+                 mode.get()=='Diana':
             plot_large()
-        else:    
+        else:
             im.putdata(Audio.gcom2.b)
             pim=ImageTk.PhotoImage(im)          #Convert Image to PhotoImage
             graph1.delete(ALL)
@@ -1888,8 +1922,8 @@
 # Save some parameters
     g.mode=mode.get()
     g.report=report.get()
-    if mode.get()=='FSK441': isync441=isync
-    elif mode.get()=='JT6M': isync6m=isync
+    if mode.get()=='FSK441' or mode.get()=='JTMS': isync441=isync
+    elif mode.get()==&quot;ISCAT&quot;: isync_iscat=isync
     elif mode.get()[:4]=='JT65': isync65=isync
     Audio.gcom1.txfirst=TxFirst.get()
     try:
@@ -1903,7 +1937,11 @@
 #    if Audio.gcom1.samfacin&gt;1.01: Audio.gcom1.samfacin=1.01
 # ... etc.
     Audio.gcom2.mycall=(options.MyCall.get()+(' '*12))[:12]
-    Audio.gcom2.hiscall=(ToRadio.get()+(' '*12))[:12]
+    try:
+        Audio.gcom2.hiscall=(ToRadio.get()+(' '*12))[:12]
+    except:
+        MsgBox(&quot;Bad callsign: &quot;+ToRadio.get()+&quot;.\nPlease re-enter.&quot;)
+        clrToRadio(None)
     Audio.gcom2.hisgrid=(HisGrid.get()+(' '*6))[:6]
     Audio.gcom4.addpfx=(options.addpfx.get().lstrip().upper()+(' '*8))[:8]
     Audio.gcom2.ntxreq=ntx.get()
@@ -1915,23 +1953,21 @@
     Audio.gcom2.nzap=nzap.get()
     Audio.gcom2.ndebug=ndebug.get()
     Audio.gcom2.minsigdb=isync
-    Audio.gcom2.nclip=iclip
-    Audio.gcom2.nblank=nblank.get()
     Audio.gcom2.nafc=nafc.get()
     Audio.gcom2.nfreeze=nfreeze.get()
     Audio.gcom2.dftolerance=ntol[itol]
     Audio.gcom2.neme=neme.get()
     Audio.gcom2.ndepth=ndepth.get()
-    Audio.gcom2.ndwspr=ndwspr.get()
+    Audio.gcom2.ndtr=options.ndtr.get()
     if mode.get()=='CW':
         Audio.gcom2.ntdecode=56
-    elif mode.get()=='WSPR':
-        Audio.gcom2.ntdecode=114
     else:
         if qdecode.get():
             Audio.gcom2.ntdecode=48
         else:
             Audio.gcom2.ntdecode=52
+##    if mode.get()=='Diana':
+##        Audio.gcom2.ntdecode=26
 
     try:
         Audio.gcom2.idinterval=options.IDinterval.get()
@@ -1940,7 +1976,8 @@
 #    Audio.gcom1.rxdelay=float('0'+options.RxDelay.get())
 #    Audio.gcom1.txdelay=float('0'+options.TxDelay.get())
     Audio.gcom2.nslim2=isync-4
-    if nosh441.get()==1 and mode.get()=='FSK441': Audio.gcom2.nslim2=99
+    if nshrx.get()==0 and (mode.get()=='FSK441' or mode.get()=='JTMS'):
+            Audio.gcom2.nslim2=99
     try:
         Audio.gcom2.nport=int(options.PttPort.get())
     except:
@@ -1948,6 +1985,23 @@
 
     Audio.gcom2.pttport=(options.PttPort.get() + (' '*80))[:80]
 
+    try:
+        Audio.gcom2.ntc=options.ntc.get()
+        if int(options.ntc.get()&lt;=0): Audio.gcom2.ntc=1
+        Audio.gcom2.nfrit=options.fRIT.get()
+        Audio.gcom2.ndither=options.dither.get()
+##        Audio.gcom2.necho=options.necho.get()
+##        Audio.gcom2.dlatency=options.dlatency.get()
+    except:
+        pass
+
+    if options.iregion.get():
+        options.cb1.configure(state=DISABLED)
+        options.cb2.configure(state=DISABLED)
+    else:
+        options.cb1.configure(state=NORMAL)
+        options.cb2.configure(state=NORMAL)
+
     if altmsg: tx6alt=tx6.get()    
 # Queue up the next update
     ldate.after(100,update)
@@ -2008,10 +2062,11 @@
 setupmenu.add_checkbutton(label = 'F4 sets Tx6',variable=kb8rq)
 setupmenu.add_checkbutton(label = 'Double-click on callsign sets TxFirst',
                           variable=setseq)
-setupmenu.add_checkbutton(label = 'GenStdMsgs sets Tx1',variable=k2txb)
+setupmenu.add_checkbutton(label = 'Gen Msgs sets Tx1',variable=k2txb)
 setupmenu.add_separator()
+setupmenu.add_checkbutton(label = 'Monitor ON at startup',variable=nmonitor)
+setupmenu.add_separator()
 setupmenu.add_checkbutton(label = 'Enable diagnostics',variable=ndebug)
-
 if (sys.platform == 'darwin'):
     mbar.add_cascade(label=&quot;Setup&quot;, menu=setupmenu)
 
@@ -2045,23 +2100,11 @@
 # Can use the following to retrieve the state:
 # state=modemenu.entrycget(0,&quot;state&quot;)
 
-if (sys.platform=='darwin') :
-    # accelerators break radiobutton behaviour in Darwin
-    modemenu.add_radiobutton(label = 'FSK441', variable=mode,command = ModeFSK441, state=NORMAL)
-    modemenu.add_radiobutton(label = 'JT6M', variable=mode, command = ModeJT6M)
-    modemenu.add_radiobutton(label = 'JT65A', variable=mode, command = ModeJT65A)
-    modemenu.add_radiobutton(label = 'JT65B', variable=mode, command = ModeJT65B)
-    modemenu.add_radiobutton(label = 'JT65C', variable=mode, command = ModeJT65C)
-    modemenu.add_radiobutton(label = 'CW', variable=mode, command = ModeCW)
-else:
-    modemenu.add_radiobutton(label = 'FSK441', variable=mode,command = ModeFSK441, state=NORMAL, accelerator='F7')
-    modemenu.add_radiobutton(label = 'JT6M', variable=mode, command = ModeJT6M,accelerator='Shift+F7')
-    modemenu.add_radiobutton(label = 'JT65A', variable=mode, command = ModeJT65A,accelerator='F8')
-    modemenu.add_radiobutton(label = 'JT65B', variable=mode, command = ModeJT65B,accelerator='Shift+F8')
-    modemenu.add_radiobutton(label = 'JT65C', variable=mode, command = ModeJT65C,accelerator='Ctrl+F8')
-    modemenu.add_radiobutton(label = 'CW', variable=mode, command = ModeCW,accelerator='Shift+Ctrl+F8')
-
-modemenu.add_radiobutton(label = 'JT2', variable=mode, command = ModeJT2)
+modemenu.add_radiobutton(label = 'FSK441', variable=mode,command = ModeFSK441, state=NORMAL)
+modemenu.add_radiobutton(label = 'ISCAT', variable=mode, command = ModeISCAT)
+modemenu.add_radiobutton(label = 'JT65A', variable=mode, command = ModeJT65A)
+modemenu.add_radiobutton(label = 'JT65B', variable=mode, command = ModeJT65B)
+modemenu.add_radiobutton(label = 'JT65C', variable=mode, command = ModeJT65C)
 modemenu.add_radiobutton(label = 'JT4A', variable=mode, command = ModeJT4A)
 modemenu.add_radiobutton(label = 'JT4B', variable=mode, command = ModeJT4B)
 modemenu.add_radiobutton(label = 'JT4C', variable=mode, command = ModeJT4C)
@@ -2069,11 +2112,24 @@
 modemenu.add_radiobutton(label = 'JT4E', variable=mode, command = ModeJT4E)
 modemenu.add_radiobutton(label = 'JT4F', variable=mode, command = ModeJT4F)
 modemenu.add_radiobutton(label = 'JT4G', variable=mode, command = ModeJT4G)
-modemenu.add_radiobutton(label = 'WSPR', variable=mode, command = ModeWSPR)
-modemenu.add_radiobutton(label = 'JT64A', variable=mode, command = ModeJT64A)
-#modemenu.add_radiobutton(label = 'Echo', variable=mode, command = ModeEcho,
-#                         state=DISABLED)
+modemenu.add_radiobutton(label = 'CW', variable=mode, command = ModeCW)
+modemenu.add_radiobutton(label = 'Echo', variable=mode, command = ModeEcho)
+modemenu.add_radiobutton(label = 'Measure', variable=mode, command = ModeMeasure)
 
+try:
+    f=open(appdir+'/experimental','r')
+    modemenu.add_separator()
+    modemenu.add_radiobutton(label = 'JTMS', variable=mode, command = ModeJTMS)
+    modemenu.add_radiobutton(label = 'Diana', variable=mode, command = ModeDiana)
+except:
+    pass
+
+try:
+    f=open(appdir+'/txboth','r')
+    Audio.gcom2.ntxboth=1
+except:
+    Audio.gcom2.ntxboth=0
+
 if (sys.platform == 'darwin'):
     mbar.add_cascade(label=&quot;Mode&quot;, menu=modemenu)
 
@@ -2085,8 +2141,8 @@
     decodebutton['menu'] = decodemenu
 else:    
     decodemenu = Menu(mbar, tearoff=use_tearoff)
-decodemenu.FSK441=Menu(decodemenu,tearoff=0)
-decodemenu.FSK441.add_checkbutton(label='No shorthands',variable=nosh441)
+##decodemenu.FSK441=Menu(decodemenu,tearoff=0)
+##decodemenu.FSK441.add_checkbutton(label='No shorthands',variable=nosh441)
 decodemenu.JT65=Menu(decodemenu,tearoff=0)
 decodemenu.JT65.add_checkbutton(label='Only EME calls in Deep Search',variable=neme)
 decodemenu.JT65.add_checkbutton(label='No Shorthand decodes',variable=noshjt65all)
@@ -2102,13 +2158,8 @@
 decodemenu.JT65.add_radiobutton(label ='Include Average in Aggressive Deep Search',
                                 variable=ndepth, value=3)
 
-decodemenu.WSPR=Menu(decodemenu,tearoff=0)
-decodemenu.WSPR.add_radiobutton(label='Quick decode',variable=ndwspr, value=0)
-decodemenu.WSPR.add_radiobutton(label='Deepest decode',variable=ndwspr, value=1)
-
-decodemenu.add_cascade(label = 'FSK441',menu=decodemenu.FSK441)
+##decodemenu.add_cascade(label = 'FSK441',menu=decodemenu.FSK441)
 decodemenu.add_cascade(label = 'JT65',menu=decodemenu.JT65)
-decodemenu.add_cascade(label = 'WSPR',menu=decodemenu.WSPR)
 
 if (sys.platform == 'darwin'):
     mbar.add_cascade(label=&quot;Decode&quot;, menu=decodemenu)
@@ -2150,6 +2201,7 @@
 bandmenu.add_radiobutton(label = '24', variable=nfreq,value=24)
 bandmenu.add_radiobutton(label = '28', variable=nfreq,value=28)
 bandmenu.add_radiobutton(label = '50', variable=nfreq,value=50)
+bandmenu.add_radiobutton(label = '70', variable=nfreq,value=70)
 bandmenu.add_radiobutton(label = '144', variable=nfreq,value=144)
 bandmenu.add_radiobutton(label = '222', variable=nfreq,value=222)
 bandmenu.add_radiobutton(label = '432', variable=nfreq,value=432)
@@ -2171,6 +2223,9 @@
    helpbutton['menu'] = helpmenu
 else:   
    helpmenu = Menu(mbar, tearoff=0)
+helpmenu.add('command',label=&quot;Online User's Guide&quot;,command=usersguide)
+helpmenu.add('command',label=&quot;Online WSJT9 Supplement&quot;, \
+             command=wsjt9supp,accelerator='F9')
 helpmenu.add('command', label = 'Keyboard shortcuts', command = shortcuts, \
              accelerator='F1')
 helpmenu.add('command', label = 'Special mouse commands', \
@@ -2235,7 +2290,6 @@
 root.bind_all('&lt;Shift-F1&gt;', mouse_commands)
 root.bind_all('&lt;Control-F1&gt;', about)
 root.bind_all('&lt;F2&gt;', options1)
-root.bind_all('&lt;Shift-F2&gt;',wspr_msgs)
 root.bind_all('&lt;F3&gt;', txmute)
 root.bind_all('&lt;F4&gt;', clrToRadio)
 root.bind_all('&lt;Alt-F4&gt;', quit)
@@ -2243,19 +2297,12 @@
 root.bind_all('&lt;Shift-F5&gt;', minimal_qso)
 root.bind_all('&lt;F6&gt;', opennext)
 root.bind_all('&lt;Shift-F6&gt;', decodeall)
-root.bind_all('&lt;F7&gt;', ModeFSK441)
-root.bind_all('&lt;F8&gt;', ModeJT65A)
-root.bind_all('&lt;Shift-F8&gt;', ModeJT65B)
-root.bind_all('&lt;Control-F8&gt;', ModeJT65C)
-root.bind_all('&lt;Shift-F7&gt;', ModeJT6M)
-root.bind_all('&lt;Shift-Control-F8&gt;', ModeCW)
-#root.bind_all('&lt;F9&gt;', ModeEcho)
+root.bind_all('&lt;F9&gt;', wsjt9supp)
 root.bind_all('&lt;F10&gt;', showspecjt)
 root.bind_all('&lt;Shift-F10&gt;', astro1)
 root.bind_all('&lt;F11&gt;', left_arrow)
 root.bind_all('&lt;F12&gt;', right_arrow)
 
-
 root.bind_all('&lt;Alt-Key-1&gt;',btx1)
 root.bind_all('&lt;Alt-Key-2&gt;',btx2)
 root.bind_all('&lt;Alt-Key-3&gt;',btx3)
@@ -2283,6 +2330,8 @@
 root.bind_all('&lt;Alt-I&gt;',decode_include)
 root.bind_all('&lt;Alt-l&gt;',lookup)
 root.bind_all('&lt;Alt-L&gt;',lookup)
+root.bind_all('&lt;Control-l&gt;',lookup_gen)
+root.bind_all('&lt;Control-L&gt;',lookup_gen)
 root.bind_all('&lt;Alt-m&gt;',monitor)
 root.bind_all('&lt;Alt-M&gt;',monitor)
 root.bind_all('&lt;Alt-o&gt;',txstop)
@@ -2291,8 +2340,8 @@
 root.bind_all('&lt;Control-O&gt;',openfile)
 root.bind_all('&lt;Alt-q&gt;',logqso)
 root.bind_all('&lt;Alt-Q&gt;',logqso)
-root.bind_all('&lt;Alt-r&gt;',clrrpt)
-root.bind_all('&lt;Alt-R&gt;',clrrpt)
+root.bind_all('&lt;Alt-r&gt;',setrpt)
+root.bind_all('&lt;Alt-R&gt;',setrpt)
 root.bind_all('&lt;Alt-s&gt;',stopmon)
 root.bind_all('&lt;Alt-S&gt;',stopmon)
 root.bind_all('&lt;Alt-v&gt;',savelast)
@@ -2301,8 +2350,6 @@
 root.bind_all('&lt;Alt-X&gt;',decode_exclude)
 root.bind_all('&lt;Alt-z&gt;',toggle_zap)
 root.bind_all('&lt;Alt-Z&gt;',toggle_zap)
-root.bind_all('&lt;Control-l&gt;',lookup_gen)
-root.bind_all('&lt;Control-L&gt;',lookup_gen)
 
 text.pack(side=LEFT, fill=X, padx=1)
 sb = Scrollbar(iframe4, orient=VERTICAL, command=text.yview)
@@ -2324,8 +2371,8 @@
                 padx=1,pady=1)
 bmonitor=Button(iframe4c, text='Monitor',underline=0,command=monitor,
                 padx=1,pady=1)
-bsavelast=Button(iframe4c, text='Save',underline=2,command=savelast,
-                padx=1,pady=1)
+##bsavelast=Button(iframe4c, text='Save',underline=2,command=savelast,
+##                padx=1,pady=1)
 bdecode=Button(iframe4c, text='Decode',underline=0,command=decode,
                 padx=1,pady=1)
 berase=Button(iframe4c, text='Erase',underline=0,command=erase,
@@ -2340,10 +2387,9 @@
                 padx=1,pady=1)
 
 blogqso.pack(side=LEFT,expand=1,fill=X)
-#bplay.pack(side=LEFT,expand=1,fill=X)
 bstop.pack(side=LEFT,expand=1,fill=X)
 bmonitor.pack(side=LEFT,expand=1,fill=X)
-bsavelast.pack(side=LEFT,expand=1,fill=X)
+##bsavelast.pack(side=LEFT,expand=1,fill=X)
 bdecode.pack(side=LEFT,expand=1,fill=X)
 berase.pack(side=LEFT,expand=1,fill=X)
 bclravg.pack(side=LEFT,expand=1,fill=X)
@@ -2359,7 +2405,7 @@
 f5a=Frame(iframe5,height=170,bd=2,relief=GROOVE)
 labToRadio=Label(f5a,text='To radio:', width=9, relief=FLAT)
 labToRadio.grid(column=0,row=0)
-ToRadio=Entry(f5a,width=9)
+ToRadio=Entry(f5a,width=12)
 ToRadio.insert(0,'W8WN')
 ToRadio.grid(column=1,row=0,pady=3)
 ToRadio.bind('&lt;Return&gt;',lookup)
@@ -2367,14 +2413,14 @@
 bLookup.grid(column=2,row=0,sticky='EW',padx=4)
 labGrid=Label(f5a,text='Grid:', width=9, relief=FLAT)
 labGrid.grid(column=0,row=1)
-HisGrid=Entry(f5a,width=9)
+HisGrid=Entry(f5a,width=12)
 HisGrid.grid(column=1,row=1,pady=1)
 bAdd=Button(f5a, text='Add',command=addtodb,padx=1,pady=1)
 bAdd.grid(column=2,row=1,sticky='EW',padx=4)
+labHotAB=Label(f5a,bg='#FFCCFF',text='HotA: 247')
+labHotAB.grid(column=0,row=2,sticky='EW',padx=4,pady=3)
 labAz=Label(f5a,text='Az 257  El 15',width=11)
 labAz.grid(column=1,row=2)
-labHotAB=Label(f5a,bg='#FFCCFF',text='HotA: 247')
-labHotAB.grid(column=0,row=2,sticky='EW',padx=4,pady=3)
 labDist=Label(f5a,text='16753 km')
 labDist.grid(column=2,row=2)
 
@@ -2382,114 +2428,124 @@
 ldate=Label(f5a, bg='black', fg='yellow', width=11, bd=4,
         text='2005 Apr 22\n01:23:45', relief=RIDGE,
         justify=CENTER, font=(font1,16))
-ldate.grid(column=0,columnspan=3,row=3,rowspan=2,pady=2)
+ldate.grid(column=0,columnspan=2,row=3,rowspan=2,padx=2,pady=2)
+
+ldsec=Label(f5a, bg='white', fg='black', text='Dsec  0.0', width=8, relief=RIDGE)
+ldsec.grid(column=2,row=4,ipadx=3,padx=2,pady=0)
+
 f5a.pack(side=LEFT,expand=1,fill=BOTH)
 
-#------------------------------------------------------ Receiving parameters
-f5b=Frame(iframe5,bd=2,relief=GROOVE)
-lsync=Label(f5b, bg='white', fg='black', text='Sync   1', width=8, relief=RIDGE)
-lsync.grid(column=0,row=0,padx=2,pady=1,sticky='EW')
+#------------------------------------------------------ Rx parameters
+f5b=Frame(iframe5,bd=0)
+f5b1=Frame(f5b,bd=2,relief=GROOVE)
+f5b1.grid(column=0,row=0,padx=2,sticky='EW')
+
+lsync=Label(f5b1, bg='white', fg='black', text='Sync   1', width=8, relief=RIDGE)
+lsync.grid(column=0,row=0,padx=2,sticky='EW')
 Widget.bind(lsync,'&lt;Button-1&gt;',incsync)
 Widget.bind(lsync,'&lt;Button-3&gt;',decsync)
-nzap=IntVar()
-cbzap=Checkbutton(f5b,text='Zap',underline=0,variable=nzap)
-cbzap.grid(column=1,row=0,padx=2,pady=1,sticky='W')
-cbnb=Checkbutton(f5b,text='NB',variable=nblank)
-cbnb.grid(column=1,row=1,padx=2,pady=1,sticky='W')
-cbfreeze=Checkbutton(f5b,text='Freeze',underline=0,variable=nfreeze)
-cbfreeze.grid(column=1,row=2,padx=2,sticky='W')
-cbafc=Checkbutton(f5b,text='AFC',variable=nafc)
-cbafc.grid(column=1,row=3,padx=2,pady=1,sticky='W')
-lclip=Label(f5b, bg='white', fg='black', text='Clip   0', width=8, relief=RIDGE)
-lclip.grid(column=0,row=1,padx=2,sticky='EW')
-Widget.bind(lclip,'&lt;Button-1&gt;',incclip)
-Widget.bind(lclip,'&lt;Button-3&gt;',decclip)
-ltol=Label(f5b, bg='white', fg='black', text='Tol    400', width=8, relief=RIDGE)
-ltol.grid(column=0,row=2,padx=2,pady=1,sticky='EW')
+cbzap=Checkbutton(f5b1,text='Zap',underline=0,variable=nzap)
+cbzap.grid(column=1,row=0,padx=2,sticky='W')
+shrx=Checkbutton(f5b1,text='Rx ST',variable=nshrx,command=restart2)
+shrx.grid(column=1,row=2,sticky='W',padx=2)
+cbfreeze=Checkbutton(f5b1,text='Freeze',underline=0,variable=nfreeze)
+cbfreeze.grid(column=0,row=2,padx=2,sticky='W')
+cbafc=Checkbutton(f5b1,text='AFC',variable=nafc)
+cbafc.grid(column=1,row=1,padx=2,sticky='W')
+##lspace=Label(f5b1, text='')
+##lspace.grid(column=0,row=5,padx=2,pady=5,sticky='W')
+ltol=Label(f5b1, bg='white', fg='black', text='Tol    400', width=8, relief=RIDGE)
+ltol.grid(column=0,row=1,padx=2,sticky='EW')
+##sbsync=Spinbox(f5b,from_=-20,to=10,bg='white',width=4,textvariable=nsync)
+##sbsync.grid(column=0,row=4)
+##nsync.set(1)
+##sbtol=Spinbox(f5b,values=(10,20,50,100,200,500,1000),bg='white', \
+##    width=4,textvariable=jtol)
+##sbtol.grid(column=0,row=5)
+##jtol.set(200)
 Widget.bind(ltol,'&lt;Button-1&gt;',inctol)
 Widget.bind(ltol,'&lt;Button-3&gt;',dectol)
-Button(f5b,text='Defaults',command=defaults,padx=1,pady=1).grid(column=0,
-                              row=3,sticky='EW')
-ldsec=Label(f5b, bg='white', fg='black', text='Dsec  0.0', width=8, relief=RIDGE)
-ldsec.grid(column=0,row=4,ipadx=3,padx=2,pady=5,sticky='EW')
-lshift=Label(f5b, bg='white', fg='black', text='Shift 0.0', width=8, relief=RIDGE)
-lshift.grid(column=1,row=4,ipadx=3,padx=2,pady=5,sticky='EW')
 Widget.bind(ldsec,'&lt;Button-1&gt;',incdsec)
 Widget.bind(ldsec,'&lt;Button-3&gt;',decdsec)
-Widget.bind(lshift,'&lt;Button-1&gt;',toggle_shift)
 
+#------------------------------------------------------ Tx parameters
+f5b2=Frame(f5b,bd=2,relief=GROOVE)
+f5b2.grid(column=0,row=1,padx=2,sticky='EW')
+txfirst=Checkbutton(f5b2,text='Tx First',justify=RIGHT,variable=TxFirst)
+txfirst.grid(column=0,row=0,sticky='W',padx=2)
+shmsg=Checkbutton(f5b2,text='Tx ST',justify=RIGHT,variable=ShOK,
+            command=restart2)
+shmsg.grid(column=1,row=0,sticky='W',padx=2)
+
+report=Entry(f5b2, width=4)
+report.insert(0,'26')
+report.grid(column=1,row=1,sticky='W',padx=7)
+report.bind('&lt;Double-Button-1&gt;',GenStdMsgs)
+labreport=Label(f5b2,text='Rpt:',width=4,underline=0)
+labreport.grid(column=0,row=1,sticky='E',padx=0)
+
+btxdf=Button(f5b2,text='  TxDF = 0  ',command=toggletxdf,padx=1,pady=1)
+btxdf.grid(column=1,row=0,sticky='EW',padx=2)
+
+f5b3=Frame(f5b,bd=2,relief=GROOVE)
+f5b3.grid(column=0,row=2,padx=2,sticky='EW')
+genmsg=Button(f5b3,text=' Gen Msgs ',underline=1,command=GenStdMsgs,
+            padx=1,pady=2)
+genmsg.grid(column=0,row=0,sticky='W',padx=2)
+auto=Button(f5b3,text='Auto is Off',underline=0,command=toggleauto,
+            padx=2,pady=2)
+auto.focus_set()
+auto.grid(column=1,row=0,sticky='EW',padx=2)
+
 f5b.pack(side=LEFT,expand=0,fill=BOTH)
 
 #------------------------------------------------------ Tx params and msgs
 f5c=Frame(iframe5,bd=2,relief=GROOVE)
-txfirst=Checkbutton(f5c,text='Tx First',justify=RIGHT,variable=TxFirst)
-f5c2=Frame(f5c,bd=0)
-labreport=Label(f5c2,text='Rpt',width=4)
-report=Entry(f5c2, width=4)
-report.insert(0,'26')
-labreport.pack(side=RIGHT,expand=1,fill=BOTH)
-report.pack(side=RIGHT,expand=1,fill=BOTH)
-shmsg=Checkbutton(f5c,text='Sh Msg',justify=RIGHT,variable=ShOK,
-            command=restart2)
-btxdf=Button(f5c,text='TxDF = 0',command=toggletxdf,
-            padx=1,pady=1)
-genmsg=Button(f5c,text='GenStdMsgs',underline=0,command=GenStdMsgs,
-            padx=1,pady=1)
-auto=Button(f5c,text='Auto is Off',underline=0,command=toggleauto,
-            padx=1,pady=1)
-auto.focus_set()
+##f5c2=Frame(f5c,bd=0)
+##f5c2.grid(column=0,row=1,sticky='W',padx=8)
 
-txfirst.grid(column=0,row=0,sticky='W',padx=4)
-f5c2.grid(column=0,row=1,sticky='W',padx=4)
-shmsg.grid(column=0,row=2,sticky='W',padx=4)
-btxdf.grid(column=0,row=3,sticky='EW',padx=4)
-genmsg.grid(column=0,row=4,sticky='W',padx=4)
-auto.grid(column=0,row=5,sticky='EW',padx=4)
-#txstop.grid(column=0,row=6,sticky='EW',padx=4)
-
 ntx=IntVar()
-tx1=Entry(f5c,width=24)
+tx1=Entry(f5c,width=32)
 rb1=Radiobutton(f5c,value=1,variable=ntx)
 b1=Button(f5c, text='Tx1',underline=2,command=btx1,padx=1,pady=1)
 tx1.grid(column=1,row=0)
 rb1.grid(column=2,row=0)
 b1.grid(column=3,row=0)
 
-tx2=Entry(f5c,width=24)
+tx2=Entry(f5c,width=32)
 rb2=Radiobutton(f5c,value=2,variable=ntx)
 b2=Button(f5c, text='Tx2',underline=2,command=btx2,padx=1,pady=1)
 tx2.grid(column=1,row=1)
 rb2.grid(column=2,row=1)
 b2.grid(column=3,row=1)
 
-tx3=Entry(f5c,width=24)
+tx3=Entry(f5c,width=32)
 rb3=Radiobutton(f5c,value=3,variable=ntx)
 b3=Button(f5c, text='Tx3',underline=2,command=btx3,padx=1,pady=1)
 tx3.grid(column=1,row=2)
 rb3.grid(column=2,row=2)
 b3.grid(column=3,row=2)
 
-tx4=Entry(f5c,width=24)
+tx4=Entry(f5c,width=32)
 rb4=Radiobutton(f5c,value=4,variable=ntx)
 b4=Button(f5c, text='Tx4',underline=2,command=btx4,padx=1,pady=1)
 tx4.grid(column=1,row=3)
 rb4.grid(column=2,row=3)
 b4.grid(column=3,row=3)
 
-tx5=Entry(f5c,width=24)
+tx5=Entry(f5c,width=32)
 rb5=Radiobutton(f5c,value=5,variable=ntx)
 b5=Button(f5c, text='Tx5',underline=2,command=btx5,padx=1,pady=1)
 tx5.grid(column=1,row=4)
 rb5.grid(column=2,row=4)
 b5.grid(column=3,row=4)
 
-tx6=Entry(f5c,width=24)
+tx6=Entry(f5c,width=32)
 rb6=Radiobutton(f5c,value=6,variable=ntx)
 b6=Button(f5c, text='Tx6',underline=2,command=btx6,padx=1,pady=1)
 tx6.grid(column=1,row=5)
 rb6.grid(column=2,row=5)
 b6.grid(column=3,row=5)
-Widget.bind(tx6,'&lt;Button-3&gt;',msg6list)
 
 f5c.pack(side=LEFT,fill=BOTH)
 iframe5.pack(expand=1, fill=X, padx=4)
@@ -2506,8 +2562,8 @@
 msg4.pack(side=LEFT, fill=X, padx=1)
 msg5=Message(iframe6, text='Message #5', width=300,relief=SUNKEN)
 msg5.pack(side=LEFT, fill=X, padx=1)
-msg6=Message(iframe6, text='', width=300,relief=SUNKEN)
-msg6.pack(side=LEFT, fill=X, padx=1)
+##msg6=Message(iframe6, text='', width=300,relief=SUNKEN)
+##msg6.pack(side=LEFT, fill=X, padx=1)
 Widget.bind(msg5,'&lt;Button-1&gt;',inctrperiod)
 Widget.bind(msg5,'&lt;Button-3&gt;',dectrperiod)
 msg7=Message(iframe6, text='                        ', width=300,relief=SUNKEN)
@@ -2521,7 +2577,6 @@
 isync=1
 ntx.set(1)
 ndepth.set(0)
-ndwspr.set(0)
 from WsjtMod import options
 options.defaults()
 ModeFSK441()
@@ -2558,18 +2613,20 @@
                 ModeJT65B()
             elif value=='JT65C':
                 ModeJT65C()
-            elif value=='JT6M':
-                ModeJT6M()
             elif value=='CW':
                 ModeCW()
-            elif value=='WSPR':
-                ModeWSPR()
-            elif value=='JT64A':
-                ModeJT64A()
-            elif value=='JT2':
-                ModeJT2()
+            elif value=='ISCAT':
+                ModeISCAT()
+            elif value=='Diana':
+                ModeDiana()
+            elif value=='JTMS':
+                ModeJTMS()
             elif value[:3]=='JT4':
                 ModeJT4()
+            elif value=='Echo':
+                ModeEcho()
+            elif value=='Measure':
+                ModeMeasure()
         elif key == 'MyCall': options.MyCall.set(value)
         elif key == 'MyGrid': options.MyGrid.set(value)
         elif key == 'HisCall':
@@ -2601,6 +2658,7 @@
                 Audio.gcom2.nport=0
             Audio.gcom2.pttport=(options.PttPort.get()+(' '*80))[:80]
         elif key == 'Mileskm': options.mileskm.set(value)
+        elif key == 'nDTR': options.ndtr.set(value)
         elif key == 'MsgStyle': options.ireport.set(value)
         elif key == 'Region': options.iregion.set(value)
         elif key == 'AudioIn':
@@ -2638,6 +2696,11 @@
 		os.stat(options.azeldir.get())
 	    except:
 		options.azeldir.set(os.getcwd())
+        elif key == 'Ntc': options.ntc.set(value)
+        elif key == 'fRIT': options.fRIT.set(value)
+        elif key == 'Dither': options.dither.set(value)
+##        elif key == 'Necho': options.necho.set(value)
+##        elif key == 'Dlatency': options.dlatency.set(value)
         elif key == 'MyName': options.myname.set(value)
         elif key == 'HighPri': options.HighPri.set(value)
         elif key == 'TxFirst': TxFirst.set(value)
@@ -2645,26 +2708,24 @@
         elif key == 'K2TXB': k2txb.set(value)
         elif key == 'SetSeq': setseq.set(value)
         elif key == 'Report':
-            report.delete(0,99)
+            report.delete(0,END)
             report.insert(0,value)
         elif key == 'ShOK': ShOK.set(value)
         elif key == 'Nsave': nsave.set(value)
         elif key == 'Band': nfreq.set(value)
         elif key == 'S441': isync441=int(value)
-        elif key == 'S6m': isync6m=int(value)
+        elif key == 'Siscat': isync_iscat=int(value)
         elif key == 'Sync': isync65=int(value)
-        elif key == 'Clip': iclip=int(value)
         elif key == 'Zap': nzap.set(value)
-        elif key == 'NB': nblank.set(value)
         elif key == 'NAFC': nafc.set(value)
-        elif key == 'NoSh441': nosh441.set(value)
+        elif key == 'nshrx': nshrx.set(value)
         elif key == 'NoShJT65all': noshjt65all.set(value)
         elif key == 'NoShJT65': noshjt65.set(value)
         elif key == 'QDecode': qdecode.set(value)
         elif key == 'NEME': neme.set(value)
         elif key == 'NDepth': ndepth.set(value)
-        elif key == 'Ndwspr': ndwspr.set(value)
         elif key == 'Debug': ndebug.set(value)
+        elif key == 'Monitor': nmonitor.set(value)
         elif key == 'HisCall':
             Audio.gcom2.hiscall=(value+' '*12)[:12]
             ToRadio.delete(0,99)
@@ -2681,8 +2742,8 @@
     print key,value
 
 g.mode=mode.get()
-if mode.get()=='FSK441': isync=isync441
-elif mode.get()=='JT6M': isync=isync6m
+if mode.get()=='FSK441' or mode.get()=='JTMS': isync=isync441
+elif mode.get()==&quot;ISCAT&quot;: isync=isync_iscat
 elif mode.get()[:4]=='JT65': isync=isync65
 elif mode.get()[:3]=='JT4':
     if mode.get()[3:4]=='A': Audio.gcom2.mode4=1
@@ -2694,15 +2755,17 @@
     if mode.get()[3:4]=='G': Audio.gcom2.mode4=72
 
 lsync.configure(text=slabel+str(isync))
-lclip.configure(text='Clip   '+str(iclip))
 Audio.gcom2.azeldir=(options.azeldir.get()+' '*80)[:80]
 Audio.gcom2.ndepth=ndepth.get()
-Audio.gcom2.ndwspr=ndwspr.get()
 Audio.gcom2.nhighpri=options.HighPri.get()
 Audio.gcom4.addpfx=(options.addpfx.get().lstrip()+(' '*8))[:8]
-stopmon()
+
+if nmonitor.get():
+    monitor()
+else:
+    stopmon()
 if g.Win32: root.iconbitmap(&quot;wsjt.ico&quot;)
-root.title('  WSJT 7     by K1JT')
+root.title('  WSJT 9.02     by K1JT')
 from WsjtMod import astro
 from WsjtMod import specjt
 
@@ -2727,6 +2790,7 @@
 f.write(&quot;IDinterval &quot; + str(options.IDinterval.get()) + &quot;\n&quot;)
 f.write(&quot;PttPort &quot; + str(options.PttPort.get()) + &quot;\n&quot;)
 f.write(&quot;Mileskm &quot; + str(options.mileskm.get()) + &quot;\n&quot;)
+f.write(&quot;nDTR &quot; + str(options.ndtr.get()) + &quot;\n&quot;)
 f.write(&quot;MsgStyle &quot; + str(options.ireport.get()) + &quot;\n&quot;)
 f.write(&quot;Region &quot; + str(options.iregion.get()) + &quot;\n&quot;)
 f.write(&quot;AudioIn &quot; + options.DevinName.get() + &quot;\n&quot;)
@@ -2747,9 +2811,11 @@
 f.write(&quot;AuxRA &quot; + options.auxra.get() + &quot;\n&quot;)
 f.write(&quot;AuxDEC &quot; + options.auxdec.get() + &quot;\n&quot;)
 f.write(&quot;AzElDir &quot; + str(options.azeldir.get()).replace(&quot; &quot;,&quot;#&quot;) + &quot;\n&quot;)
-if options.myname.get()==&quot;&quot;:
-    options.myname.set(&quot;name&quot;)
-f.write(&quot;MyName &quot; + options.myname.get() + &quot;\n&quot;)
+f.write(&quot;Ntc &quot; + str(options.ntc.get()) + &quot;\n&quot;)
+f.write(&quot;fRIT &quot; + str(options.fRIT.get()) + &quot;\n&quot;)
+f.write(&quot;Dither &quot; + str(options.dither.get()) + &quot;\n&quot;)
+##f.write(&quot;Necho &quot; + str(options.necho.get()) + &quot;\n&quot;)
+##f.write(&quot;Dlatency &quot; + str(options.dlatency.get()) + &quot;\n&quot;)
 f.write(&quot;HighPri &quot; + str(options.HighPri.get()) + &quot;\n&quot;)
 f.write(&quot;TxFirst &quot; + str(TxFirst.get()) + &quot;\n&quot;)
 f.write(&quot;KB8RQ &quot; + str(kb8rq.get()) + &quot;\n&quot;)
@@ -2760,24 +2826,23 @@
 f.write(&quot;Nsave &quot; + str(nsave.get()) + &quot;\n&quot;)
 f.write(&quot;Band &quot; + str(nfreq.get()) + &quot;\n&quot;)
 f.write(&quot;S441 &quot; + str(isync441) + &quot;\n&quot;)
-f.write(&quot;S6m &quot; + str(isync6m) + &quot;\n&quot;)
+f.write(&quot;Siscat &quot; + str(isync_iscat) + &quot;\n&quot;)
 f.write(&quot;Sync &quot; + str(isync65) + &quot;\n&quot;)
-f.write(&quot;Clip &quot; + str(iclip) + &quot;\n&quot;)
 f.write(&quot;Zap &quot; + str(nzap.get()) + &quot;\n&quot;)
-f.write(&quot;NB &quot; + str(nblank.get()) + &quot;\n&quot;)
 f.write(&quot;NAFC &quot; + str(nafc.get()) + &quot;\n&quot;)
-f.write(&quot;NoSh441 &quot; + str(nosh441.get()) + &quot;\n&quot;)
+f.write(&quot;nshrx &quot; + str(nshrx.get()) + &quot;\n&quot;)
 f.write(&quot;NoShJT65all &quot; + str(noshjt65all.get()) + &quot;\n&quot;)
 f.write(&quot;NoShJT65 &quot; + str(noshjt65.get()) + &quot;\n&quot;)
 f.write(&quot;QDecode &quot; + str(qdecode.get()) + &quot;\n&quot;)
 f.write(&quot;NEME &quot; + str(neme.get()) + &quot;\n&quot;)
 f.write(&quot;NDepth &quot; + str(ndepth.get()) + &quot;\n&quot;)
-f.write(&quot;Ndwspr &quot; + str(ndwspr.get()) + &quot;\n&quot;)
 f.write(&quot;Debug &quot; + str(ndebug.get()) + &quot;\n&quot;)
+f.write(&quot;Monitor &quot; + str(nmonitor.get()) + &quot;\n&quot;)
 #f.write(&quot;TRPeriod &quot; + str(Audio.gcom1.trperiod) + &quot;\n&quot;)
 mrudir2=mrudir.replace(&quot; &quot;,&quot;#&quot;)
 f.write(&quot;MRUDir &quot; + mrudir2 + &quot;\n&quot;)
-if g.astro_geom[:7]==&quot;200x200&quot;: g.astro_geom=&quot;316x373&quot; + g.astro_geom[7:]
+if g.astro_geom[:7]==&quot;200x200&quot;:
+    g.astro_geom=&quot;316x416&quot; + g.astro_geom[7:]
 f.write(&quot;AstroGeometry &quot; + g.astro_geom + &quot;\n&quot;)
 f.write(&quot;CWTRPeriod &quot; + str(ncwtrperiod) + &quot;\n&quot;)
 f.close()

Deleted: trunk/wsjt1.F
===================================================================
--- trunk/wsjt1.F	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/wsjt1.F	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,412 +0,0 @@
-        subroutine wsjt1(d,jz0,istart,samfacin,FileID,ndepth,
-     +    MinSigdB,NQRN,DFTolerance,MouseButton,NClearAve,nforce,
-     +    Mode,NFreeze,NAFC,NZap,mode65,mode4,idf,ntdecode0,
-     +    MyCall,HisCall,HisGrid,neme,ntx2,s2,
-     +    ps0,npkept,lumsg,basevb,rmspower,nslim2,psavg,ccf,Nseg,
-     +    MouseDF,NAgain,LDecoded,nspecial,ndf,ss1,ss2)
-
-!       lparameter (NP2=1024*1024)
-        parameter (NP2=120*12000)
-
-        integer*2 d(jz0)        !Buffer for raw one-byte data
-        integer istart          !Starting location in original d() array
-        character FileID*40     !Name of file being processed
-        integer MinSigdB        !Minimum ping strength, dB
-        integer NQRN            !QRN rejection parameter
-        integer DFTolerance     !Defines DF search range
-        integer NSyncOK         !Set to 1 if JT65 file synchronized OK
-        character*12 mycall
-        character*12 hiscall
-        character*6 hisgrid
-        real ps0(431)           !Spectrum of best ping
-        integer npkept          !Number of pings kept and decoded
-        integer lumsg           !Logical unit for decoded.txt
-        real basevb             !Baseline signal level, dB
-        integer nslim2          !Minimum strength for single-tone pings, dB
-        real psavg(450)         !Average spectrum of the whole file
-        integer Nseg            !First or second Tx sequence?
-        integer MouseDF         !Freeze position for DF
-        logical pick            !True if this is a mouse-picked ping
-        logical stbest          !True if the best decode was Single-Tone
-        logical STfound         !True if at least one ST decode
-        logical LDecoded        !True if anything was decoded
-        real s2(64,3100)        !2D spectral array
-        real ccf(-5:540)        !X-cor function in JT65 mode (blue line)
-        real red(512)
-        real ss1(-224:224)      !Magenta curve (for JT65 shorthands)
-        real ss2(-224:224)      !Orange curve (for JT65 shorthands)
-        real yellow(216)
-        real yellow0(216)
-        real fzap(200)
-        integer resample
-        real*8 samfacin,samratio
-        real dat2(NP2)
-        character msg3*3
-        character cfile6*6
-        logical lcum
-        integer indx(100)
-        character*90 line
-        common/avecom/dat(NP2),labdat,jza,modea
-        common/ccom/nline,tping(100),line(100)
-        common/limcom/ nslim2a
-        common/extcom/ntdecode
-        common/clipcom/ nclip
-        save
-
-        if(mode.eq.8) nzap=0
-        lcum=.true.
-        jz=jz0
-        ntdecode=ntdecode0
-        modea=Mode
-        nclip=NQRN-5
-        nslim2a=nclip
-        MinWidth=40                            !Minimum width of pings, ms
-        call zero(psavg,450)
-        rewind 11
-        rewind 12
-
-        do i=1,40
-           if(FileID(i:i).eq.'.') go to 3
-        enddo
-        i=4
- 3      ia=max(1,i-6)
-        cfile6=FileID(ia:i-1)
-
-        nline=0
-        ndiag=0
-! If file &quot;/wsjt.reg&quot; exists, set ndiag=1
-        open(16,file='/wsjt.reg',status='old',err=4)
-        ndiag=1
-        close(16)
-
- 4      if(mode.lt.8 .and. jz.gt.655360) jz=655360
-        if(mode.eq.4 .and. jz.gt.330750) jz=330750      !### Fix this!
-        if(mode.eq.8 .and. jz.gt.1323000) jz=1323000
-
-        sum=0.
-        do j=1,jz            !Convert raw data from i*2 to real, remove DC
-           dat(j)=0.1*d(j)
-           sum=sum + dat(j)
-        enddo
-        ave=sum/jz
-        samratio=1.d0/samfacin
-        if(samratio.eq.1.d0) then
-           do j=1,jz
-              dat(j)=dat(j)-ave
-           enddo
-        else
-           do j=1,jz
-              dat2(j)=dat(j)-ave
-           enddo
-C  Resample ntype: 0=best, 1=sinc_medium, 2=sinc_fast, 3=hold, 4=linear
-           ntype=2
-           ierr=resample(dat2,dat,samratio,jz,ntype)
-           if(ierr.ne.0) print*,'Resample error.',samratio
-        endif
-
-        if(ndiag.ne.0 .and. nclip.lt.0) then
-C  Intentionally degrade SNR by -nclip dB.
-           sq=0.
-           do i=1,jz
-              sq=sq + dat(i)**2
-           enddo
-           p0=sq/jz
-           p1=p0*10.0**(-0.1*nclip)
-           dnoise=sqrt(4*(p1-p0))
-           idum=-1
-           do i=1,jz
-              dat(i)=dat(i) + dnoise*gran(idum)
-           enddo
-        endif
-
-        if(mode.ne.2 .and. nzap.ne.0) then
-           nfrz=NFreeze
-           if(mode.eq.1) nfrz=0
-           if(jz.gt.100000) call avesp2(dat,jz,2,mode,nfrz,MouseDF,
-     +         DFTolerance,fzap)
-           nadd=1
-           call bzap(dat,jz,nadd,mode,fzap)
-        endif
-
-        sq=0.
-        do j=1,jz                  !Compute power level for whole array
-           sq=sq + dat(j)**2
-        enddo
-        avesq=sq/jz
-        basevb=dB(avesq) - 44    !Base power level to send back to GUI
-        if(avesq.eq.0) go to 900
-
-        nz=600
-        nstep=jz/nz
-        sq=0.
-        k=0
-        do j=1,nz
-           sum=0.
-           do n=1,nstep
-              k=k+1
-              sum=sum+dat(k)**2
-           enddo
-           sum=sum/nstep
-           sq=sq + (sum-avesq)**2
-        enddo
-        rmspower=sqrt(sq/nz)
-
-        pick=.false.
-        if(istart.gt.1) pick=.true. !This is a mouse-picked decoding
-        if(.not.pick .and. nforce.eq.0 .and. 
-     +     (basevb.lt.-15.0 .or. basevb.gt.20.0)) goto 900
-        nchan=64                   !Save 64 spectral channels
-        nstep=221                  !Set step size to ~20 ms
-        nz=jz/nstep - 1            !# of spectra to compute
-        if(.not.pick) then
-           MouseButton=0
-           jza=jz
-           labdat=labdat+1
-        endif
-        tbest=0.
-        NsyncOK=0
-
-!  If we're in JT65 mode, call the decode65 routines.
-        if(mode.eq.2) then
-!          if(rmspower.gt.34000.0) go to 900     !Reject very noisy data
-!  Check for a JT65 shorthand message
-           nstest=0
-           if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
-     +        DFTolerance,mode65,nspecial,nstest,dfsh,iderrsh,
-     +        idriftsh,snrsh,ss1,ss2,nwsh,idfsh)
-!  Lowpass filter and decimate by 2
-           call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
-           idf=mousedf-mousedf2
-           jz=jz2
-           nadd=1
-           fzap(1)=0.
-           if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
-     +       DFTolerance,fzap)
-       if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
-
-           i=index(MyCall,char(0))
-           if(i.le.0) i=index(MyCall,' ')
-           mycall=MyCall(1:i-1)//'            '
-           i=index(HisCall,char(0))
-           if(i.le.0) i=index(HisCall,' ')
-           hiscall=HisCall(1:i-1)//'            '
-
-!  Offset data by about 1 s.
-!           jztest=126*2048
-           jztest=11025*ntdecode/2 - 2755
-           if(jz.ge.jztest) call wsjt65(dat(4097),jz-4096,cfile6,
-     +        NClearAve,MinSigdB,DFTolerance,NFreeze,NAFC,mode65,Nseg,
-     +        MouseDF2,NAgain,ndepth,neme,idf,idfsh,
-     +        mycall,hiscall,hisgrid,lumsg,lcum,nspecial,ndf,
-     +        nstest,dfsh,snrsh,
-     +        NSyncOK,ccf,psavg,ndiag,nwsh)
-           goto 900
-        endif
-
-! If we're in JT6M mode, call the 6M decoding routines.
-        if(mode.eq.4) then
-           do i=1,jz                    !### Why is it level-sensitive?
-              dat(i)=dat(i)/25.0
-           enddo
-! For waterfall plot
-           call spec2d(dat,jz,nstep,s2,nchan,nz,psavg,sigma)
-           if(sigma.lt.0.0) basevb=-99.0
-           if(jz/11025.0.lt.3.9 .or. sigma.lt.0.0) go to 900
-
-           f0=1076.66
-           if(NFreeze.eq.1) f0=1076.66 + MouseDF
-           f00=f0
-           call syncf0(dat,jz,NFreeze,DFTolerance,jstart,f0,smax)
-           call synct(dat,jz,jstart,f0,smax)
-           call syncf1(dat,jz,jstart,f0,NFreeze,DFTolerance,smax,red)
-
-           do i=1,512
-              ccf(i-6)=dB(red(i))
-           enddo
-           df=11025./256.
-           do i=1,64
-              sum=0.
-              do k=8*i-7,8*i
-                 sum=sum+red(k)
-              enddo
-              psavg(i)=5.0*sum
-              fac=1.0
-              freq=i*df
-              if(freq.gt.2500.0) fac=((freq-2500.)/20.0)**(-1.0)
-              psavg(i)=fac*psavg(i)
-              psavg(i+64)=0.001
-           enddo
-
-           jz=jz-jstart+1
-           nslim=MinSigdB
-           NFixLen=0
-
-C  Call the decoder if DF is in range or Freeze is off.
-           if(NFreeze.eq.0 .or. 
-     +         abs(f0-f00).lt.float(DFTolerance)) then
-              call decode6m(dat(jstart),jz,cfile6,nslim,istart,
-     +            NFixLen,lcum,f0,lumsg,npkept,yellow)
-           endif
-
-           if(pick) then
-              do i=1,216
-                 ps0(i)=yellow0(i)
-              enddo
-           else
-              ps0(216)=yellow(216)
-              yellow0(216)=yellow(216)
-              do i=1,215
-                 ps0(i)=2*yellow(i)
-                 yellow0(i)=ps0(i)
-              enddo
-           endif
-           goto 800
-        endif
-
-        if(mode.eq.5) then
-!  We're in CW mode.
-!          call decodecw(dat,jz,cfile6,DFTolerance,NFreeze,
-!     +        MouseDF2,mycall,hiscall,hisgrid)
-           go to 900
-        endif
-
-!  If we're in JT2 or JT4 mode, call the decode24 routines.
-        if(mode.eq.6 .or. mode.eq.7) then
-!  Lowpass filter and decimate by 2
-           call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
-           idf=mousedf-mousedf2
-           jz=jz2
-           nadd=1
-           fzap(1)=0.
-           if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
-     +       DFTolerance,fzap)
-      if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
-
-           i=index(MyCall,char(0))
-           if(i.le.0) i=index(MyCall,' ')
-           mycall=MyCall(1:i-1)//'            '
-           i=index(HisCall,char(0))
-           if(i.le.0) i=index(HisCall,' ')
-           hiscall=HisCall(1:i-1)//'            '
-
-!  Offset data by about 1 s.
-           jztest=165000
-           if(jz.ge.jztest) call wsjt24(dat(4097),jz-4096,cfile6,
-     +        NClearAve,MinSigdB,DFTolerance,NFreeze,mode,mode4,
-     +        Nseg,MouseDF2,NAgain,idf,lumsg,lcum,nspecial,ndf,
-     +        NSyncOK,ccf,psavg,ndiag)
-           goto 900
-        endif
-
-!  If we're in WSPR mode, call the wspr routines.
-        if(mode.eq.8) then
-           i=index(MyCall,char(0))
-           if(i.le.0) i=index(MyCall,' ')
-           mycall=MyCall(1:i-1)//'            '
-           call wsjtwspr(dat,jz,cfile6,ndiag,ccf,psavg)
-           ccf(-5)=-9999.0
-           goto 900
-        endif
-
-!  JT64 mode:
-        if(mode.eq.9) then
-           mode64=1
-           nstest=0
-           if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,
-     +        DFTolerance,mode64,nspecial,nstest,dfsh,iderrsh,
-     +        idriftsh,snrsh,ss1,ss2,nwsh,idfsh)
-!  Lowpass filter and decimate by 2
-           call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
-           idf=mousedf-mousedf2
-           jz=jz2
-           nadd=1
-           fzap(1)=0.
-           if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,
-     +       DFTolerance,fzap)
-      if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
-
-           i=index(MyCall,char(0))
-           if(i.le.0) i=index(MyCall,' ')
-           mycall=MyCall(1:i-1)//'            '
-           i=index(HisCall,char(0))
-           if(i.le.0) i=index(HisCall,' ')
-           hiscall=HisCall(1:i-1)//'            '
-
-!  Offset data by about 1 s.
-!           jztest=126*2048
-           jztest=11025*ntdecode/2 - 2755
-           if(jz.ge.jztest) call wsjt64(dat(4097),jz-4096,cfile6,
-     +        NClearAve,MinSigdB,DFTolerance,NFreeze,NAFC,mode64,Nseg,
-     +        MouseDF2,NAgain,ndepth,nchallenge,neme,idf,idfsh,
-     +        mycall,hiscall,hisgrid,lumsg,lcum,nspecial,ndf,
-     +        nstest,dfsh,snrsh,
-     +        NSyncOK,ccf,psavg,ndiag,nwsh)
-           goto 900
-
-        endif
-
-!  We're in FSK441 mode. Compute the 2D spectrum.
-        df=11025.0/256.0            !FFT resolution ~43 Hz
-        dtbuf=nstep/11025.0
-        stlim=nslim2                !Single-tone threshold
-        call spec2d(dat,jz,nstep,s2,nchan,nz,psavg,sigma)
-        if(sigma.lt.0.0) basevb=-99.0
-        if(sigma.lt.0.0) go to 900
-        nline0=nline
-        STfound=.false.
-        npkept=0
-
-C  Look for single-tone messages
-        if((.not.pick) .or. MouseButton.eq.1) then
-           call stdecode(s2,nchan,nz,sigma,dtbuf,df,stlim,
-     +       DFTolerance,cfile6,pick,istart)
-        endif
-        if(nline.gt.nline0) STfound=.true.  !ST message(s) found
-
-C  Now the multi-tone decoding
-        call mtdecode(dat,jz,nz,MinSigdB,MinWidth,
-     +    NQRN,DFTolerance,istart,pick,cfile6,ps0)
-
-        npkept=nline             !Number of pings that were kept
-        smax=0.
-        stbest=.false.
-        if(npkept.gt.0) then
-           call indexx(npkept,tping,indx) !Merge the ST and MT decodes
-           do i=1,npkept
-              j=indx(i)
-              if(pick .and. STFound .and.
-     +          line(j)(29:31).eq.'   ') goto 10
-              call cs_lock('wsjt1')
-              write(lumsg,1050) line(j) !Write to decoded.txt
- 1050         format(a79)
-              if(lcum) write(21,1050) line(j) !Write to ALL.TXT
-              read(line(j),1060) sig,msg3
- 1060         format(16x,f3.0,9x,a3)
-              call cs_unlock
-              if(sig.gt.smax) then
-                 smax=sig
-                 tbest=tping(j)
-                 stbest = (msg3.ne.'   ')
-              endif
- 10        continue
-           enddo
-        endif
-
-        dt=1.0/11025.0                !Compute spectrum for pink curve
-        if(stbest) then
-           jj=nint(tbest/dt)
-           call spec441(dat(jj),1102,ps0,f0)
-        endif
-
- 800    continue
-        call s2shape(s2,nchan,nz,tbest)
-
- 900    LDecoded = ((NSyncOK.gt.0) .or. npkept.gt.0)
-        end file 11
-        call flushqqq(11)
-        call flushqqq(12)
-        call flushqqq(21)
-
-        return
-        end
-

Copied: trunk/wsjt1.f90 (from rev 2228, wsjt7a/wsjt1.f90)
===================================================================
--- trunk/wsjt1.f90	                        (rev 0)
+++ trunk/wsjt1.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,315 @@
+subroutine wsjt1(d,jz0,istart,samfacin,FileID,ndepth,              &amp;
+     MinSigdB,DFTolerance,MouseButton,NClearAve,nforce,            &amp;
+     Mode,NFreeze,NAFC,NZap,mode65,mode4,idf,ntdecode0,            &amp;
+     MyCall,HisCall,HisGrid,neme,ntx2,s2,                          &amp;
+     ps0,npkept,lumsg,basevb,rmspower,nslim2,psavg,ccf,Nseg,       &amp;
+     MouseDF,NAgain,LDecoded,nspecial,ndf,ss1,ss2)
+
+  parameter (NP2=120*11025)
+
+  integer*2 d(jz0)        !Buffer for raw one-byte data
+  integer istart          !Starting location in original d() array
+  character FileID*40     !Name of file being processed
+  integer MinSigdB        !Minimum ping strength, dB
+  integer DFTolerance     !Defines DF search range
+  integer NSyncOK         !Set to 1 if JT65 file synchronized OK
+  character*12 mycall
+  character*12 hiscall
+  character*6 hisgrid
+  real ps0(431)           !Spectrum of best ping
+  integer npkept          !Number of pings kept and decoded
+  integer lumsg           !Logical unit for decoded.txt
+  real basevb             !Baseline signal level, dB
+  integer nslim2          !Minimum strength for single-tone pings, dB
+  real psavg(450)         !Average spectrum of the whole file
+  integer Nseg            !First or second Tx sequence?
+  integer MouseDF         !Freeze position for DF
+  logical pick            !True if this is a mouse-picked ping
+  logical stbest          !True if the best decode was Single-Tone
+  logical STfound         !True if at least one ST decode
+  logical LDecoded        !True if anything was decoded
+  real s2(64,3100)        !2D spectral array
+  real ccf(-5:540)        !X-cor function in JT65 mode (blue line)
+  real red(512)
+  real ss1(-224:224)      !Magenta curve (for JT65 shorthands)
+  real ss2(-224:224)      !Orange curve (for JT65 shorthands)
+  real yellow(216)
+  real yellow0(216)
+  real fzap(200)
+  integer resample
+  real*8 samfacin,samratio
+  real dat2(NP2)
+  character msg3*3
+  character cfile6*6
+  logical lcum
+  integer indx(100)
+  character*90 line
+  common/avecom/dat(NP2),labdat,jza,modea
+  common/ccom/nline,tping(100),line(100)
+  common/limcom/ nslim2a
+  common/extcom/ntdecode
+  save
+
+  lcum=.true.
+  jz=jz0
+  ntdecode=ntdecode0
+  modea=Mode
+  nslim2a=0                                   !### Is this OK ??? ###
+  MinWidth=40                            !Minimum width of pings, ms
+  call zero(psavg,450)
+  rewind 11
+  rewind 12
+
+  do i=1,40
+     if(FileID(i:i).eq.'.') go to 3
+  enddo
+  i=4
+3 ia=max(1,i-6)
+  cfile6=FileID(ia:i-1)
+
+  nline=0
+  ndiag=0
+! If file &quot;/wsjt.reg&quot; exists, set ndiag=1
+  open(16,file='/wsjt.reg',status='old',err=4)
+  ndiag=1
+  close(16)
+
+4 if(mode.lt.8 .and. jz.gt.655360) jz=655360
+  if(mode.eq.4 .and. jz.gt.330750) jz=330750      !### Fix this!
+
+  sum=0.
+  do j=1,jz            !Convert raw data from i*2 to real, remove DC
+     dat(j)=0.1*d(j)
+     sum=sum + dat(j)
+  enddo
+  ave=sum/jz
+  samratio=1.d0/samfacin
+  if(samratio.eq.1.d0) then
+     do j=1,jz
+        dat(j)=dat(j)-ave
+     enddo
+  else
+     do j=1,jz
+        dat2(j)=dat(j)-ave
+     enddo
+! Resample ntype: 0=best, 1=sinc_medium, 2=sinc_fast, 3=hold, 4=linear
+     ntype=2
+     ierr=resample(dat2,dat,samratio,jz,ntype)
+     if(ierr.ne.0) print*,'Resample error.',samratio
+  endif
+
+!  if(ndiag.ne.0 .and. nclip.lt.0) then
+! Intentionally degrade SNR by -nclip dB.
+!     sq=0.
+!     do i=1,jz
+!        sq=sq + dat(i)**2
+!     enddo
+!     p0=sq/jz
+!     p1=p0*10.0**(-0.1*nclip)
+!     dnoise=sqrt(4*(p1-p0))
+!     idum=-1
+!     do i=1,jz
+!        dat(i)=dat(i) + dnoise*gran(idum)
+!     enddo
+!  endif
+
+  if(mode.ne.2 .and. nzap.ne.0) then
+     nfrz=NFreeze
+     if(mode.eq.1) nfrz=0
+     if(jz.gt.100000) call avesp2(dat,jz,2,mode,nfrz,MouseDF,         &amp;
+          DFTolerance,fzap)
+     nadd=1
+     call bzap(dat,jz,nadd,mode,fzap)
+  endif
+
+  sq=0.
+  do j=1,jz                  !Compute power level for whole array
+     sq=sq + dat(j)**2
+  enddo
+  avesq=sq/jz
+  basevb=dB(avesq) - 44    !Base power level to send back to GUI
+  if(avesq.eq.0) go to 900
+
+  nz=600
+  nstep=jz/nz
+  sq=0.
+  k=0
+  do j=1,nz
+     sum=0.
+     do n=1,nstep
+        k=k+1
+        sum=sum+dat(k)**2
+     enddo
+     sum=sum/nstep
+     sq=sq + (sum-avesq)**2
+  enddo
+  rmspower=sqrt(sq/nz)
+
+  pick=.false.
+  if(istart.gt.1) pick=.true. !This is a mouse-picked decoding
+  if(.not.pick .and. nforce.eq.0 .and.                                 &amp;
+          (basevb.lt.-15.0 .or. basevb.gt.20.0)) goto 900
+  nchan=64                   !Save 64 spectral channels
+  nstep=221                  !Set step size to ~20 ms
+  nz=jz/nstep - 1            !# of spectra to compute
+  if(.not.pick) then
+     MouseButton=0
+     jza=jz
+     labdat=labdat+1
+  endif
+  tbest=0.
+  NsyncOK=0
+
+! If we're in JT65 mode, call the decode65 routines.
+  if(mode.eq.2) then
+!          if(rmspower.gt.34000.0) go to 900     !Reject very noisy data
+! Check for a JT65 shorthand message
+     nstest=0
+     if(ntx2.ne.1) call short65(dat,jz,NFreeze,MouseDF,              &amp;
+          DFTolerance,mode65,nspecial,nstest,dfsh,iderrsh,           &amp;
+          idriftsh,snrsh,ss1,ss2,nwsh,idfsh)
+! Lowpass filter and decimate by 2
+     call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
+     idf=mousedf-mousedf2
+     jz=jz2
+     nadd=1
+     fzap(1)=0.
+     if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,    &amp;
+          DFTolerance,fzap)
+     if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
+
+     i=index(MyCall,char(0))
+     if(i.le.0) i=index(MyCall,' ')
+     mycall=MyCall(1:i-1)//'            '
+     i=index(HisCall,char(0))
+     if(i.le.0) i=index(HisCall,' ')
+     hiscall=HisCall(1:i-1)//'            '
+
+! Offset data by about 1 s.
+!           jztest=126*2048
+     jztest=11025*ntdecode/2 - 2755
+     if(jz.ge.jztest) call wsjt65(dat(4097),jz-4096,cfile6,              &amp;
+          NClearAve,MinSigdB,DFTolerance,NFreeze,NAFC,mode65,Nseg,       &amp;
+          MouseDF2,NAgain,ndepth,neme,idf,idfsh,                         &amp;
+          mycall,hiscall,hisgrid,lumsg,lcum,nspecial,ndf,                &amp;
+          nstest,dfsh,snrsh,NSyncOK,ccf,psavg,ndiag,nwsh)
+     goto 900
+  endif
+
+  if(mode.eq.5) then
+! We're in CW mode.
+!          call decodecw(dat,jz,cfile6,DFTolerance,NFreeze,
+!     +        MouseDF2,mycall,hiscall,hisgrid)
+     go to 900
+  endif
+
+! If we're in JT4 mode, call the decode24 routines.
+  if(mode.eq.7) then
+! Lowpass filter and decimate by 2
+     call lpf1(dat,jz,jz2,MouseDF,MouseDF2)
+     idf=mousedf-mousedf2
+     jz=jz2
+     nadd=1
+     fzap(1)=0.
+     if(nzap.eq.1) call avesp2(dat,jz,nadd,mode,NFreeze,MouseDF2,        &amp;
+          DFTolerance,fzap)
+     if(nzap.eq.1.and.nstest.eq.0) call bzap(dat,jz,nadd,mode,fzap)
+
+     i=index(MyCall,char(0))
+     if(i.le.0) i=index(MyCall,' ')
+     mycall=MyCall(1:i-1)//'            '
+     i=index(HisCall,char(0))
+     if(i.le.0) i=index(HisCall,' ')
+     hiscall=HisCall(1:i-1)//'            '
+
+! Offset data by about 1 s.
+     jztest=165000
+     if(jz.ge.jztest) call wsjt24(dat(4097),jz-4096,cfile6,             &amp;
+          NClearAve,MinSigdB,DFTolerance,NFreeze,mode,mode4,            &amp;
+          Nseg,MouseDF2,NAgain,idf,lumsg,lcum,nspecial,ndf,             &amp;
+          NSyncOK,ccf,psavg,ndiag)
+     goto 900
+  endif
+
+  if(mode.eq.9) then                             !ISCAT mode
+!     write(74) jz,cfile6,(dat(j),j=1,jz)
+     call spec2d(dat,jz,nstep,s2,nchan,nz,psavg,sigma)
+     if(jz.ge.11025) call iscat(dat,jz,cfile6,MinSigdB,DFTolerance,     &amp;
+          NFreeze,MouseDF,ccf,psavg)
+     psavg(65:)=0.
+     go to 800
+  endif
+
+  if(mode.eq.10) then
+!     write(74) jz,cfile6,(dat(j),j=1,jz)
+     jza=min(jz,11025*30)
+     call diana(dat,jza,cfile6,MinSigdB,DFTolerance,NFreeze,MouseDF,ccf,psavg)
+     go to 900
+  endif
+     
+
+! We're in FSK441 or JTMS mode. Compute the 2D spectrum.
+  df=11025.0/256.0            !FFT resolution ~43 Hz
+  dtbuf=nstep/11025.0
+  stlim=nslim2                !Single-tone threshold
+  call spec2d(dat,jz,nstep,s2,nchan,nz,psavg,sigma)
+  if(sigma.lt.0.0) basevb=-99.0
+  if(sigma.lt.0.0) go to 900
+  nline0=nline
+  STfound=.false.
+  npkept=0
+
+! Look for single-tone messages
+  if((.not.pick) .or. MouseButton.eq.1) then
+     call stdecode(s2,nchan,nz,sigma,dtbuf,df,stlim,                   &amp;
+          DFTolerance,cfile6,pick,istart)
+  endif
+  if(nline.gt.nline0) STfound=.true.  !ST message(s) found
+
+! Now the multi-tone decoding
+!        write(72) jz,nz,cfile6,(dat(j),j=1,jz)
+  call mtdecode(dat,jz,nz,MinSigdB,MinWidth,NFreeze,DFTolerance,       &amp;
+       MouseDF,istart,pick,cfile6,mycall,hiscall,mode,ps0)
+
+  npkept=nline             !Number of pings that were kept
+  smax=0.
+  stbest=.false.
+  if(npkept.gt.0) then
+     call indexx(npkept,tping,indx) !Merge the ST and MT decodes
+     do i=1,npkept
+        j=indx(i)
+        if(pick .and. STFound .and. line(j)(29:31).eq.'   ') goto 10
+        call cs_lock('wsjt1')
+        write(lumsg,1050) line(j) !Write to decoded.txt
+1050    format(a79)
+        if(lcum) write(21,1050) line(j) !Write to ALL.TXT
+        read(line(j),1060) sig,msg3
+1060    format(16x,f3.0,9x,a3)
+        call cs_unlock
+        if(sig.gt.smax) then
+           smax=sig
+           tbest=tping(j)
+           stbest = (msg3.ne.'   ')
+        endif
+10      continue
+     enddo
+  endif
+
+  dt=1.0/11025.0                !Compute spectrum for pink curve
+  if(stbest) then
+     jj=nint(tbest/dt)
+     call spec441(dat(jj),1102,ps0,f0)
+  endif
+
+800 continue
+  call s2shape(s2,nchan,nz,tbest)
+  
+900 LDecoded = ((NSyncOK.gt.0) .or. npkept.gt.0)
+  endfile 11
+  call flush(11)
+  call flush(12)
+  call flush(21)
+
+  return
+end subroutine wsjt1
+

Modified: trunk/wsjt24.f
===================================================================
--- trunk/wsjt24.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/wsjt24.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -2,7 +2,7 @@
      +  DFTolerance,NFreeze,mode,mode4,Nseg,MouseDF,NAgain,
      +  idf,lumsg,lcum,nspecial,ndf,NSyncOK,ccfblue,ccfred,ndiag)
 
-C  Orchestrates the process of decoding JT2 and JT4 messages, using 
+C  Orchestrates the process of decoding JT4 messages, using 
 C  data that have been 2x downsampled.  
 
       real dat(npts)                        !Raw data
@@ -11,11 +11,12 @@
       logical lcum
       character decoded*22,cfile6*6,special*5,cooo*3
       character*22 avemsg1,avemsg2,deepmsg
-      character*67 line,ave1,ave2
+      character*69 line,ave1,ave2
       character*1 csync,c1
       character*12 mycall
       character*12 hiscall
       character*6 hisgrid
+      character submode*1
       real ccfblue(-5:540),ccfred(-224:224)
       include 'avecom.h'
       data first/.true./,ns10/0/,ns20/0/
@@ -86,7 +87,8 @@
       endif
 
       call decode24(dat,npts,dtx,dfx,flip,mode,mode4,decoded,
-     +   ncount,deepmsg,qual)
+     +   ncount,deepmsg,qual,submode)
+
  200  kvqual=0
       if(ncount.ge.0) kvqual=1
       nqual=qual
@@ -104,15 +106,15 @@
       jdf=ndf+idf
 
       call cs_lock('wsjt24')
-      write(line,1010) cfile6,nsync,nsnr,dtx-1.0,jdf,
-     +    nint(width),csync,special,decoded(1:19),cooo,kvqual,nqual
- 1010 format(a6,i3,i5,f5.1,i5,i3,1x,a1,1x,a5,a19,1x,a3,i4,i4)
+      write(line,1010) cfile6,nsync,nsnr,dtx-1.0,jdf,nint(width),
+     +    csync,special,decoded(1:19),cooo,kvqual,nqual,submode
+ 1010 format(a6,i3,i5,f5.1,i5,i3,1x,a1,1x,a5,a19,1x,a3,i4,i4,1x,a1)
 
 C  Blank all end-of-line stuff if no decode
       if(line(31:40).eq.'          ') line=line(:30)
 
       if(lcum) write(21,1011) line
- 1011 format(a67)
+ 1011 format(a69)
 
 C  Write decoded msg unless this is an &quot;Exclude&quot; request:
       if(MinSigdB.lt.99) write(lumsg,1011) line
@@ -167,7 +169,7 @@
       if(ave2(31:40).eq.'          ') ave2=ave2(:30)
       write(12,1011) ave1
       write(12,1011) ave2
-      call flushqqq(12)
+      call flush(12)
  
       if(lumsg.ne.6) end file 11
       call cs_unlock

Deleted: trunk/wsjt64.f
===================================================================
--- trunk/wsjt64.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/wsjt64.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,123 +0,0 @@
-      subroutine wsjt64(dat,npts,cfile6,NClearAve,MinSigdB,
-     +  DFTolerance,NFreeze,NAFC,mode64,Nseg,MouseDF,NAgain,
-     +  ndepth,nchallenge,neme,idf,idfsh,mycall,hiscall,hisgrid,
-     +  lumsg,lcum,nspecial,ndf,nstest,dfsh,
-     +  snrsh,NSyncOK,ccfblue,ccfred,ndiag,nwsh)
-
-C  Orchestrates the process of decoding JT64 messages, using data that
-C  have been 2x downsampled.  The search for shorthand messages has
-C  already been done.
-
-      real dat(npts)                        !Raw data
-      integer DFTolerance
-      logical first
-      logical lcum
-      character decoded*22,cfile6*6,special*5,cooo*3
-      character*22 deepmsg
-      character*67 ave1,ave2
-      character*1 csync
-      character*12 mycall
-      character*12 hiscall
-      character*6 hisgrid
-      real ccfblue(-5:540),ccfred(-224:224)
-      integer itf(2,9)
-      include 'avecom.h'
-      data first/.true./,ns10/0/,ns20/0/
-      data itf/0,0, 1,0, -1,0, 0,-1, 0,1, 1,-1, 1,1, -1,-1, -1,1/
-      save
-
-      if(first) then
-         nsave=0
-         first=.false.
-         ave1=' '
-         ave2=' '
-      endif
-
-      nspecial=0
-      nstest=0
-      naggressive=0
-      if(ndepth.ge.2) naggressive=1
-      nq1=3
-      nq2=6
-      if(naggressive.eq.1) nq1=1
-
-      if(NClearAve.ne.0) then
-         nsave=0                        !Clear the averaging accumulators
-         ns10=0
-         ns20=0
-         ave1=' '
-         ave2=' '
-      endif
-      if(MinSigdB.eq.99 .or. MinSigdB.eq.-99) then
-         ns10=0                         !For Include/Exclude ?
-         ns20=0
-      endif
-
-C  Attempt to synchronize: look for sync tone, get DF and DT.
-      call sync64(dat,npts,DFTolerance,NFreeze,MouseDF,
-     +    mode64,dtx,dfx,snrx,snrsync,ccfblue,ccfred,flip,width)
-      nsync=nint(snrsync-2.0)
-      if(nsync.lt.0) nsync=0
-      nsnr=nint(snrx)
-      jdf=nint(dfx)
-      write(11,1010) cfile6,nsync,nsnr,dtx-1.0,jdf
- 1010 format(a6,i3,i5,f5.1,i5,i3,1x,a1,1x,a5,a19,1x,a3,i4,i4)
-      write(21,1010) cfile6,nsync,nsnr,dtx-1.0,jdf
-
-      csync=' '
-      decoded='                      '
-      deepmsg='                      '
-      special='     '
-      cooo='   '
-      ncount=-1             !Flag for RS decode of current record
-      ncount1=-1            !Flag for RS Decode of ave1
-      ncount2=-1            !Flag for RS Decode of ave2
-      NSyncOK=0
-      nqual1=0
-      nqual2=0
-
-      if(nsave.lt.MAXAVE .and. (NAgain.eq.0 .or. NClearAve.eq.1)) 
-     +  nsave=nsave+1
-      if(nsave.le.0) go to 900          !Prevent bounds error
-
-      nflag(nsave)=0                    !Clear the &quot;good sync&quot; flag
-      iseg(nsave)=Nseg                  !Set the RX segment to 1 or 2
-      nsync=nint(snrsync-3.0)
-      nsnr=nint(snrx)
-      if(nsnr.lt.-30 .or. nsync.lt.0) nsync=0
-      nsnrlim=-32
-
-C  Good Sync takes precedence over a shorthand message:
-      if(nsync.ge.MinSigdB .and. nsnr.ge.nsnrlim .and.
-     +   nsync.ge.nstest) nstest=0
-
-      if(nstest.gt.0) then
-         dfx=dfsh
-         nsync=nstest
-         nsnr=snrsh
-         dtx=1.
-         ccfblue(-5)=-999.0
-         if(nspecial.eq.1) special='ATT  '
-         if(nspecial.eq.2) special='RO   '
-         if(nspecial.eq.3) special='RRR  '
-         if(nspecial.eq.4) special='73   '
-         NSyncOK=1              !Mark this RX file as good (for &quot;Save Decoded&quot;)
-         if(NFreeze.eq.0 .or. DFTolerance.ge.200) special(5:5)='?'
-         width=nwsh
-         idf=idfsh
-         go to 200
-      endif
-
-      if(nsync.lt.MinSigdB .or. nsnr.lt.nsnrlim) go to 200
-
-C  If we get here, we have achieved sync!
-
-C### From here onward, code from wsjt65.f was deleted.  Must restore
-C### and modify.
-
- 200  continue
-
- 900  continue
-
-      return
-      end

Modified: trunk/wsjt65.f
===================================================================
--- trunk/wsjt65.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/wsjt65.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -209,10 +209,10 @@
       call cs_lock('wsjt65')
       write(12,1011) ave1
       write(12,1011) ave2
-      call flushqqq(12)
+      call flush(12)
       if(lumsg.ne.6) end file 11
       call cs_unlock
-
+ 
  900  continue
 
       return

Copied: trunk/wsjt7a.txt (from rev 2228, wsjt7a/wsjt7a.txt)
===================================================================
--- trunk/wsjt7a.txt	                        (rev 0)
+++ trunk/wsjt7a.txt	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,34 @@
+	Temporary Supplement to WSJT User's Guide, version 7.1+
+	-------------------------------------------------------
+
+Version 7.1+ of WSJT is an experimental release designed to allow
+testing of two new modes:
+
+  JTMS_2  -- possible replacement for FSK441 (meteor scatter)
+  ISCAT_2 -- possible replacement for JT6M (ionoscatter, weak Es, F2)
+
+Despite the similarity in names, these modes are *not* the same as the
+modes JTMS and ISCAT offered for testing in WSJT8.  The &quot;_2&quot; versions
+use the same modulation methods but different coding.  They use
+free-text rather than structured messages.
+
+If JTMS_2 or ISCAT_2 remains part of a production release of WSJT, the
+&quot;_2&quot; portion of the mode name will eventually be dropped.  In the
+meantime, during the testing phase, the suffix should help to avoid
+confusion.
+
+
+
+The following table summarizes some parameters of the new modes in
+WSJT 7.1 and the comparable older modes.
+
+                      FSK441  JTMS_2            JT6M    ISCAT_2
+------------------------------------------------------------------
+T/R period (s)          30     30                30       30
+Modulation type       4-FSK   MSK*             44-FSK    41-FSK
+Keying rate (baud)     441   1378               21.5     43.1
+Characters/s           147    197               14.3     32.3
+Bandwidth (Hz)        1764   1378               947      1809
+
+*MSK stands for &quot;minimum shift keying&quot;, a technique that allows faster
+keying while minimizing bandwidth.

Deleted: trunk/wsjtgen.F90
===================================================================
--- trunk/wsjtgen.F90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/wsjtgen.F90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,266 +0,0 @@
-subroutine wsjtgen
-
-! Compute the waveform to be transmitted.  
-
-! Input:    txmsg        message to be transmitted, up to 28 characters
-!           samfacout    fsample_out/11025.d0
-
-! Output:   iwave        waveform data, i*2 format
-!           nwave        number of samples
-!           sendingsh    0=normal; 1=shorthand; -1=plain text; 2=test file
-
-  parameter (NMSGMAX=28)             !Max characters per message
-  parameter (NSPD=25)                !Samples per dit
-  parameter (NDPC=3)                 !Dits per character
-  parameter (NWMAX=150*12000)        !Max length of Tx waveform
-  parameter (NTONES=4)               !Number of FSK tones
-
-  integer   itone(84)
-  character msg*28,msgsent*22,idmsg*22
-  real*8 freq,pha,dpha,twopi,dt
-  character testfile*27,tfile2*80
-  logical lcwid
-  integer*2 icwid(110250),jwave(NWMAX)
-
-  integer*1 hdr(44)
-  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
-  character*4 ariff,awave,afmt,adata
-  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
-     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,jwave
-  equivalence (ariff,hdr)
-
-  data twopi/6.28318530718d0/
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  call cs_lock('wsjtgen')
-  fsample_out=11025.d0*samfacout
-  lcwid=.false.
-  if(idinterval.gt.0) then
-     n=(mod(int(tsec/60.d0),idinterval))
-     if(n.eq.(1-txfirst)) lcwid=.true.
-     if(idinterval.eq.1) lcwid=.true.
-  endif
-
-  msg=txmsg
-  ntxnow=ntxreq
-! Convert all letters to upper case
-  do i=1,28
-     if(msg(i:i).ge.'a' .and. msg(i:i).le.'z')                  &amp;
-          msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
-  enddo
-  txmsg=msg
-
-! Find message length
-  do i=NMSGMAX,1,-1
-     if(msg(i:i).ne.' ') go to 10
-  enddo
-  i=1
-10 nmsg=i
-  nmsg0=nmsg
-
-  if(msg(1:1).eq.'@') then
-     if(msg(2:2).eq.'/' .or. ichar(msg(2:2)).eq.92) then
-        txmsg=msg
-        testfile=msg(2:)
-#ifdef CVF
-        open(18,file=testfile,form='binary',status='old',err=12)
-        go to 14
-12      print*,'Cannot open test file ',msg(2:)
-        go to 999
-14      read(18) hdr
-        if(ndata.gt.NTxMax) ndata=NTxMax
-        call rfile(18,iwave,ndata,ierr)
-        close(18)
-        if(ierr.ne.0) print*,'Error reading test file ',msg(2:)
-
-#else
-        tfile2=testfile
-        call rfile2(tfile2,hdr,44+2*120*12000,nr)
-        if(nr.le.0) then
-           print*,'Error reading ',testfile
-           stop
-        endif
-        do i=1,ndata/2
-           iwave(i)=jwave(i)
-        enddo
-#endif
-        nwave=ndata/2
-        do i=nwave,NTXMAX
-           iwave(i)=0
-        enddo
-        sending=txmsg
-        sendingsh=2
-        go to 999
-     endif
-
-! Transmit a fixed tone at specified frequency
-     freq=1000.0
-     if(msg(2:2).eq.'A' .or. msg(2:2).eq.'a') freq=882
-     if(msg(2:2).eq.'B' .or. msg(2:2).eq.'b') freq=1323
-     if(msg(2:2).eq.'C' .or. msg(2:2).eq.'c') freq=1764
-     if(msg(2:2).eq.'D' .or. msg(2:2).eq.'d') freq=2205
-     if(freq.eq.1000.0) then
-        read(msg(2:),*,err=1) freq
-        goto 2
-1       txmsg='@1000'
-        nmsg=5
-        nmsg0=5
-     endif
-2    nwave=60*fsample_out
-     dpha=twopi*freq/fsample_out
-     do i=1,nwave
-        iwave(i)=32767.0*sin(i*dpha)
-     enddo
-     goto 900
-  endif
-
-  dt=1.d0/fsample_out
-  LTone=2
-
-  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT2' .or.                  &amp;
-       mode(1:3).eq.'JT4' .or. mode(1:4).eq.'WSPR' .or.                &amp;
-       mode(1:4).eq.'JT64') then
-
-     if(mode(1:4).eq.'JT65') then
-!  We're in JT65 mode.
-        if(mode(5:5).eq.'A') mode65=1
-        if(mode(5:5).eq.'B') mode65=2
-        if(mode(5:5).eq.'C') mode65=4
-        call gen65(msg,mode65,samfacout,ntxdf,ndebug,iwave,nwave,sendingsh,   &amp;
-             msgsent,nmsg0)
-     else if(mode(1:4).eq.'WSPR') then
-        call cs_unlock                            !genwspr calls cs_lock
-        call genwspr(msg,samfacout,ntxdf,iwave,nwave,sendingsh,msgsent)
-        call cs_lock('wsjtgen')
-     else if(mode(1:3).eq.'JT2' .or. mode(1:3).eq.'JT4' ) then
-        call gen24(msg,mode,mode4,samfacout,ntxdf,ndebug,iwave,nwave,      &amp;
-             sendingsh,msgsent,nmsg0)
-     else if(mode(1:4).eq.'JT64') then
-        mode64=1
-        call gen64(msg,mode64,samfacout,ntxdf,iwave,nwave,sendingsh,   &amp;
-             msgsent,nmsg0)
-     else
-        stop 'Unknown Tx mode requested.'
-     endif
-
-     if(lcwid) then
-!  Generate and insert the CW ID.
-        wpm=25.
-        freqcw=800.
-        idmsg=MyCall//'          '
-        call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
-        k=nwave
-        do i=1,ncwid
-           k=k+1
-           iwave(k)=icwid(i)
-        enddo
-        do i=1,2205                   !Add 0.2 s of silence
-           k=k+1
-           iwave(k)=0
-        enddo
-        nwave=k
-     endif
-
-     goto 900
-  endif
-
-  if(mode(1:4).eq.'Echo') then
-!  We're in Echo mode.
-!     dither=AmpA
-!     call echogen(dither,wavefile,nbytes,f1)
-!     AmpB=f1
-     goto 900
-  endif
-
-  if(mode(1:4).eq.'JT6M') then
-!  We're in JT6M mode.
-     call gen6m(msg,samfacout,iwave,nwave)
-     goto 900
-  endif
-
-  if(mode(1:2).eq.'CW') then
-!  We're in CW mode
-!     wpm=15.
-     wpm=17.
-     freqcw=800.
-     call gencw(msg,wpm,freqcw,samfacout,iwave,nwave)
-     goto 900
-  endif
-
-!  We're in FSK441 mode.
-  if(nmsg.lt.28) nmsg=nmsg+1          !Add trailing blank if nmsg &lt; 28
-
-!  Check for shorthand messages
-  sendingsh = 0
-  if(shok.eq.1 .and. nmsg.le.4) then
-     if (msg(1:3).eq.'R26') then
-        msg='++'
-        nmsg=2
-        sendingsh = 1
-     else if (msg(1:3).eq.'R27') then
-        msg='**'
-        nmsg=2
-        sendingsh = 1
-     else if (msg(1:3).eq.'RRR') then
-        msg='%%'
-        nmsg=2
-        sendingsh = 1
-     else if (msg(1:2).eq.'73') then
-        msg='@@'
-        nmsg=2
-        sendingsh = 1
-     endif
-  endif
-
-!  Encode the message
-  call abc441(msg,nmsg,itone,ndits)
-  ndata=ndits*nspd
-
-! Generate iwave
-  k=0
-  df=11025.0/NSPD
-  pha=0.
-  do m=1,ndits
-     freq=(LTone-1+itone(m))*df
-     dpha=twopi*freq*dt
-     do i=1,NSPD
-        k=k+1
-        pha=pha+dpha
-        iwave(k)=nint(32767.0*sin(pha))
-     enddo
-  enddo
-  nwave=k
-  
-900 sending=txmsg
-  if((mode(1:4).eq.'JT65' .or. mode(1:4).eq.'JT64' .or. &amp;
-       mode(1:4).eq.'WSPR') .and. sendingsh.ne.1) sending=msgsent
-  do i=NMSGMAX,1,-1
-     if(sending(i:i).ne.' '.and. ichar(sending(i:i)).ne.0) go to 910
-  enddo
-  i=1
-910 nmsg=i
-
-  if(lcwid .and. (mode.eq.'FSK441' .or. mode(1:4).eq.'JT6M')) then
-!  Generate and insert the CW ID.
-     wpm=25.
-     freqcw=440.
-     idmsg=MyCall//'          '
-     call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
-     k=0
-     do i=ncwid+1,int(trperiod*fsample_out)
-        k=k+1
-        if(k.gt.nwave) k=k-nwave
-        iwave(i)=iwave(k)
-     enddo
-     do i=1,ncwid
-        iwave(i)=icwid(i)
-     enddo
-     nwave=trperiod*fsample_out
-  endif
-
-999 continue
-  call cs_unlock
-  return
-end subroutine wsjtgen
-

Copied: trunk/wsjtgen.f90 (from rev 2228, wsjt7a/wsjtgen.f90)
===================================================================
--- trunk/wsjtgen.f90	                        (rev 0)
+++ trunk/wsjtgen.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -0,0 +1,264 @@
+subroutine wsjtgen
+
+! Compute the waveform to be transmitted.  
+
+! Input:    txmsg        message to be transmitted, up to 28 characters
+!           samfacout    fsample_out/11025.d0
+
+! Output:   iwave        waveform data, i*2 format
+!           nwave        number of samples
+!           sendingsh    0=normal; 1=shorthand; -1=plain text; 2=test file
+
+  parameter (NMSGMAX=28)             !Max characters per message
+  parameter (NSPD=25)                !Samples per dit
+  parameter (NDPC=3)                 !Dits per character
+  parameter (NWMAX=150*11025)        !Max length of Tx waveform
+  parameter (NTONES=4)               !Number of FSK tones
+
+  integer   itone(84)
+  character msg*28,msgsent*28,idmsg*22,msg22*22
+  real*8 freq,pha,dpha,twopi,dt
+  character testfile*27,tfile2*80
+  logical lcwid
+  integer*2 icwid(110250),jwave(NWMAX)
+
+  integer*1 hdr(44)
+  integer*2 nfmt2,nchan2,nbitsam2,nbytesam2
+  character*4 ariff,awave,afmt,adata
+  common/hdr/ariff,lenfile,awave,afmt,lenfmt,nfmt2,nchan2, &amp;
+     nsamrate,nbytesec,nbytesam2,nbitsam2,adata,ndata,jwave
+  equivalence (ariff,hdr)
+
+  data twopi/6.28318530718d0/
+  include 'gcom1.f90'
+  include 'gcom2.f90'
+
+  call cs_lock('wsjtgen')
+  fsample_out=11025.d0*samfacout
+  if(abs(samfacout-1.d0).gt.0.02d0) fsample_out=1.d0
+
+  if(mode(1:4).eq.'Echo') then
+     dither=ndither
+     call echogen(necho,dither,iwave,nwave,fecho)        !### Samfacout ???
+     goto 999
+  endif
+
+  lcwid=.false.
+  if(idinterval.gt.0) then
+     n=(mod(int(tsec/60.d0),idinterval))
+     if(n.eq.(1-txfirst)) lcwid=.true.
+     if(idinterval.eq.1) lcwid=.true.
+  endif
+
+  msg=txmsg
+  ntxnow=ntxreq
+! Convert all letters to upper case
+  do i=1,28
+     if(msg(i:i).ge.'a' .and. msg(i:i).le.'z')                  &amp;
+          msg(i:i)= char(ichar(msg(i:i))+ichar('A')-ichar('a'))
+  enddo
+  txmsg=msg
+
+! Find message length
+  do i=NMSGMAX,1,-1
+     if(msg(i:i).ne.' ') go to 10
+  enddo
+  i=1
+10 nmsg=i
+  nmsg0=nmsg
+
+  if(msg(1:1).eq.'@') then
+     if(msg(2:2).eq.'/' .or. ichar(msg(2:2)).eq.92) then
+        txmsg=msg
+        testfile=msg(2:)
+        tfile2=testfile
+        call rfile2(tfile2,hdr,44+2*120*11025,nr)
+        if(nr.le.0) then
+           print*,'Error reading ',testfile
+           stop
+        endif
+        do i=1,ndata/2
+           iwave(i)=jwave(i)
+        enddo
+
+        nwave=ndata/2
+        do i=nwave,NTXMAX
+           iwave(i)=0
+        enddo
+        sending=txmsg
+        sendingsh=2
+        go to 999
+     endif
+
+! Transmit a fixed tone at specified frequency
+     freq=1000.0
+     if(msg(2:2).eq.'A' .or. msg(2:2).eq.'a') freq=882
+     if(msg(2:2).eq.'B' .or. msg(2:2).eq.'b') freq=1323
+     if(msg(2:2).eq.'C' .or. msg(2:2).eq.'c') freq=1764
+     if(msg(2:2).eq.'D' .or. msg(2:2).eq.'d') freq=2205
+     if(freq.eq.1000.0) then
+        read(msg(2:),*,err=1) freq
+        goto 2
+1       txmsg='@1000'
+        nmsg=5
+        nmsg0=5
+     endif
+2    nwave=60*fsample_out
+     dpha=twopi*freq/fsample_out
+     do i=1,nwave
+        iwave(i)=32767.0*sin(i*dpha)
+     enddo
+     goto 900
+  endif
+
+  dt=1.d0/fsample_out
+  LTone=2
+
+  if(mode(1:4).eq.'JT65' .or. mode(1:3).eq.'JT4' .or.                &amp;
+       mode(1:5).eq. 'ISCAT' .or. mode(1:4).eq.'JTMS' .or.           &amp;
+       mode(1:5).eq. 'Diana') then
+     if(mode(1:4).eq.'JT65') then
+!  We're in JT65 mode.
+        if(mode(5:5).eq.'A') mode65=1
+        if(mode(5:5).eq.'B') mode65=2
+        if(mode(5:5).eq.'C') mode65=4
+        call gen65(msg,mode65,samfacout,ntxdf,iwave,nwave,sendingsh,   &amp;
+             msg22,nmsg0)
+        msgsent=msg22
+     else if(mode(1:5).eq.'ISCAT') then
+        call geniscat(msg,nmsg,samfacout,iwave,nwave,msgsent)
+        sendingsh=0
+        if(txsnrdb.gt.0.d0 .and. txsnrdb.lt.40.d0) call makepings(iwave,nwave)
+     else if(mode(1:4).eq.'JTMS') then
+        if(shok.eq.1 .and.                                                &amp;
+           (msg(1:4).eq.'R26 ' .or. msg(1:4).eq.'R27 ' .or.               &amp;
+                msg(1:4).eq.'RRR ' .or. msg(1:3).eq.'73 ')) go to 100
+        call genms(msg,samfacout,iwave,cwave,0,nwave)
+        if(txsnrdb.lt.40.d0) call makepings(iwave,nwave)
+        sendingsh=0
+        msgsent=msg
+     else if(mode(1:3).eq.'JT4' ) then
+        call gen24(msg,mode4,samfacout,ntxdf,iwave,nwave,                 &amp;
+             sendingsh,msg22,nmsg0)
+        msgsent=msg22
+     else if(mode(1:5).eq.'Diana') then
+        call gendiana(msg,nmsg,samfacout,iwave,nwave,msgsent,sendingsh)
+     else
+        stop 'Unknown Tx mode requested.'
+     endif
+
+     if(lcwid) then
+!  Generate and insert the CW ID.
+        wpm=25.
+        freqcw=800.
+        idmsg=MyCall//'          '
+        call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
+        k=nwave
+        do i=1,ncwid
+           k=k+1
+           iwave(k)=icwid(i)
+        enddo
+        do i=1,2205                   !Add 0.2 s of silence
+           k=k+1
+           iwave(k)=0
+        enddo
+        nwave=k
+     endif
+
+     goto 900
+  endif
+
+  if(mode(1:2).eq.'CW') then
+!  We're in CW mode
+!     wpm=15.
+     wpm=17.
+     freqcw=800.
+     call gencw(msg,wpm,freqcw,samfacout,iwave,nwave)
+     goto 900
+  endif
+
+!  We're in FSK441 mode.
+  if(nmsg.lt.28) nmsg=nmsg+1          !Add trailing blank if nmsg &lt; 28
+
+!  Check for shorthand messages
+100 sendingsh = 0
+  if(shok.eq.1) then
+     if (msg(1:4).eq.'R26 ') then
+        msg='++'
+        nmsg=2
+        sendingsh = 1
+     else if (msg(1:4).eq.'R27 ') then
+        msg='**'
+        nmsg=2
+        sendingsh = 1
+     else if (msg(1:4).eq.'RRR ') then
+        msg='%%'
+        nmsg=2
+        sendingsh = 1
+     else if (msg(1:3).eq.'73 ') then
+        msg='@@'
+        nmsg=2
+        sendingsh = 1
+     endif
+     if(sendingsh.eq.1) then
+        i1=index(txmsg,' ')
+        txmsg=txmsg(1:i1)
+     endif
+  endif
+
+! Encode the message
+  call abc441(msg,nmsg,itone,ndits)
+  ndata=ndits*nspd
+
+! Generate iwave
+  k=0
+  df=11025.0/NSPD
+  pha=0.
+  nrpt=30*11025/(NSPD*ndits)
+  do irpt=1,nrpt
+     do m=1,ndits
+        freq=(LTone-1+itone(m))*df
+        dpha=twopi*freq*dt
+        do i=1,NSPD
+           k=k+1
+           pha=pha+dpha
+           iwave(k)=nint(32767.0*sin(pha))
+        enddo
+     enddo
+  enddo
+  nwave=k
+
+  if(txsnrdb.lt.40.d0) call makepings(iwave,nwave)
+  
+900 sending=txmsg
+  if(mode(1:4).eq.'JT65' .and. sendingsh.ne.1) sending=msgsent
+  if(mode(1:3).eq.'JT4' .or. mode(1:5).eq.'ISCAT') sending=msgsent
+  do i=NMSGMAX,1,-1
+     if(sending(i:i).ne.' '.and. ichar(sending(i:i)).ne.0) go to 910
+  enddo
+  i=1
+910 nmsg=i
+
+  if(lcwid .and. (mode.eq.'FSK441' .or. mode(1:4).eq.'JTMS')) then
+!  Generate and insert the CW ID.
+     wpm=25.
+     freqcw=440.
+     idmsg=MyCall//'          '
+     call gencwid(idmsg,wpm,freqcw,samfacout,icwid,ncwid)
+     k=0
+     do i=ncwid+1,int(trperiod*fsample_out)
+        k=k+1
+        if(k.gt.nwave) k=k-nwave
+        iwave(i)=iwave(k)
+     enddo
+     do i=1,ncwid
+        iwave(i)=icwid(i)
+     enddo
+     nwave=trperiod*fsample_out
+  endif
+
+999 continue
+  call cs_unlock
+  return
+end subroutine wsjtgen
+

Deleted: trunk/wsjtwspr.f90
===================================================================
--- trunk/wsjtwspr.f90	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/wsjtwspr.f90	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,18 +0,0 @@
-subroutine wsjtwspr(dat,jz,cfile6,ndiag,ccfblue,ccfred)
-
-  real dat(jz)
-  real ccfblue(-5:540)
-  real ccfred(-224:224)
-  character cfile6*6
-  complex c2(45000)
-  include 'gcom1.f90'
-  include 'gcom2.f90'
-
-  f0=1500 + mousedf
-  if(nagain.eq.1) newdat2=0
-  if(nforce.eq.1) newdat2=1
-  call filbig2(dat,jz,f0,newdat2,c2,n4)
-  call mept162a(c2,n4,f0,cfile6,ndiag,minsigdb,mousedf,DFTolerance,ndwspr, &amp;
-       ccfblue,ccfred)
-  return
-end subroutine wsjtwspr

Modified: trunk/xcor.f
===================================================================
--- trunk/xcor.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/xcor.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -12,7 +12,6 @@
       real a(NSMAX),a2(NSMAX)
       real ccf(-5:540)
       include 'prcom.h'
-      common/clipcom/ nclip
       data lagmin/0/                              !Silence g77 warning
       save
 
@@ -25,30 +24,6 @@
          a(j)=s2(ii,j)
       enddo
 
-C  If requested, clip the spectrum that will be cross correlated.
-      nclip=0                               !Turn it off
-      if(nclip.gt.0) then
-         call pctile(a,a2,nsteps,50,base)
-         alow=a2(nint(nsteps*0.16))
-         ahigh=a2(nint(nsteps*0.84))
-         rms=min(base-alow,ahigh-base)
-         clip=4.0-nclip
-         atop=base+clip*rms
-         abot=base-clip*rms
-         do i=1,nsteps
-            if(nclip.lt.4) then
-               a(i)=min(a(i),atop)
-               a(i)=max(a(i),abot)
-            else
-               if(a(i).ge.base) then
-                  a(i)=1.0
-               else
-                  a(i)=-1.0
-               endif
-            endif
-         enddo 
-      endif
-
       ccfmax=0.
       ccfmin=0.
       do lag=lag1,lag2

Modified: trunk/xcor24.f
===================================================================
--- trunk/xcor24.f	2010-10-26 13:36:41 UTC (rev 2229)
+++ trunk/xcor24.f	2010-10-26 13:46:16 UTC (rev 2230)
@@ -1,4 +1,4 @@
-      subroutine xcor24(s2,ipk,nsteps,nsym,lag1,lag2,mode,mode4,
+      subroutine xcor24(s2,ipk,nsteps,nsym,lag1,lag2,mode4,
      +  ccf,ccf0,lagpk,flip)
 
 C  Computes ccf of a row of s2 and the pseudo-random array pr2.  Returns
@@ -14,7 +14,6 @@
       integer npr2(207)
       real pr2(207)
       logical first
-      common/clipcom/ nclip
       data lagmin/0/                    !Silence g77 warning
       data first/.true./
       data npr2/
@@ -35,34 +34,30 @@
       endif
 
       do j=1,nsteps
-         if(mode.eq.6) then
-            a(j)=s2(ipk+2,j) - s2(ipk,j)             !JT2
-         else                                        !JT4
-            n=2*mode4
-            if(mode4.eq.1) then
-               a(j)=max(s2(ipk+n,j),s2(ipk+3*n,j)) - 
-     +              max(s2(ipk  ,j),s2(ipk+2*n,j))
-            else
-               kz=mode4/2
-               ss0=0.
-               ss1=0.
-               ss2=0.
-               ss3=0.
-               wsum=0.
-               do k=-kz+1,kz-1
-                  w=float(kz-iabs(k))/mode4
-                  wsum=wsum+w
-                  if(ipk+k.lt.1 .or. ipk+3*n+k.gt.1260) then
-                     print*,'xcor24:',ipk,n,k
-                  else
-                     ss0=ss0 + w*s2(ipk    +k,j)
-                     ss1=ss1 + w*s2(ipk+  n+k,j)
-                     ss2=ss2 + w*s2(ipk+2*n+k,j)
-                     ss3=ss3 + w*s2(ipk+3*n+k,j)
-                  endif
-               enddo
-               a(j)=(max(ss1,ss3) - max(ss0,ss2))/sqrt(wsum)
-            endif
+         n=2*mode4
+         if(mode4.eq.1) then
+            a(j)=max(s2(ipk+n,j),s2(ipk+3*n,j)) - 
+     +           max(s2(ipk  ,j),s2(ipk+2*n,j))
+         else
+            kz=mode4/2
+            ss0=0.
+            ss1=0.
+            ss2=0.
+            ss3=0.
+            wsum=0.
+            do k=-kz+1,kz-1
+               w=float(kz-iabs(k))/mode4
+               wsum=wsum+w
+               if(ipk+k.lt.1 .or. ipk+3*n+k.gt.1260) then
+                  print*,'xcor24:',ipk,n,k
+               else
+                  ss0=ss0 + w*s2(ipk    +k,j)
+                  ss1=ss1 + w*s2(ipk+  n+k,j)
+                  ss2=ss2 + w*s2(ipk+2*n+k,j)
+                  ss3=ss3 + w*s2(ipk+3*n+k,j)
+               endif
+            enddo
+            a(j)=(max(ss1,ss3) - max(ss0,ss2))/sqrt(wsum)
          endif
       enddo
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001921.html">[WSJT-SVN] r2229 - wsjt7a
</A></li>
	<LI>Next message: <A HREF="001923.html">[WSJT-SVN] r2231 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1922">[ date ]</a>
              <a href="thread.html#1922">[ thread ]</a>
              <a href="subject.html#1922">[ subject ]</a>
              <a href="author.html#1922">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
