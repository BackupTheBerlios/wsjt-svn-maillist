<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r1288 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1288%20-%20trunk&In-Reply-To=%3C200907231947.n6NJlDsk023816%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000981.html">
   <LINK REL="Next"  HREF="000983.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r1288 - trunk</H1>
    <B>k1jt at mail.berlios.de</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r1288%20-%20trunk&In-Reply-To=%3C200907231947.n6NJlDsk023816%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r1288 - trunk">k1jt at mail.berlios.de
       </A><BR>
    <I>Thu Jul 23 21:47:13 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000981.html">[WSJT-SVN] r1287 - trunk
</A></li>
        <LI>Next message: <A HREF="000983.html">[WSJT-SVN] r1289 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#982">[ date ]</a>
              <a href="thread.html#982">[ thread ]</a>
              <a href="subject.html#982">[ subject ]</a>
              <a href="author.html#982">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: k1jt
Date: 2009-07-23 21:47:09 +0200 (Thu, 23 Jul 2009)
New Revision: 1288

Added:
   trunk/call_to.txt
   trunk/calledby.txt
Modified:
   trunk/inter_mept.f
   trunk/wqdecode.f90
Log:
Add two housekeeping files.


Added: trunk/call_to.txt
===================================================================
--- trunk/call_to.txt	2009-07-23 18:50:08 UTC (rev 1287)
+++ trunk/call_to.txt	2009-07-23 19:47:09 UTC (rev 1288)
@@ -0,0 +1,100 @@
+a2d.f90:       padevsub
+afc65.f:       peakup
+astro0.F90:    astro, cs_lock, cs_unlock
+astro.F:       grid2deg, coord, cs_lock, cs_unlock, MoonDop, rfile2, sun, zero
+avemsg65.f:    add, deep65, extract, zero
+avemsg6m.f:    add, cs_lock, cs_unlock, move, zero
+avesp2.f:      flatten, move, ps, zero
+azdist0.f90:   azdist, cs_lock, cs_unlock
+azdist.f:      geodist, grid2deg
+bzap.f:        four2a, xfft, zero
+chkt0.f90:     cs_lock, cs_unlock, packmsg, unpackmsg
+decode162.f:   fano232, inter_mept, wqdecode
+decode1.F90:   cs_lock, cs_unlock, decode2, flushqqq, savedata, sleepqq, usleep
+decode24.f:    cs_lock, cs_unlock, interleave24, genmet, unpackmsg
+decode2.f90:   decode3, get_fname
+decode3.F90:   pix2d65, pix2d, wsjt1, blanker
+decode65.f:    extract, move, spec2d65, deep65
+decode6m.f:    avemsg6m, cs_lock, cs_unlock, four2a, zero, add
+deep65.F:      cs_lock, cs_unlock, encode65, packmsg, unpackmsg
+encode65.f:    graycode, interleave63, packmsg, rs_encode
+extract.f:     demod64a, chkhist, cs_lock, cs_unlock, flushqqq, graycode,
+               indexx, interleave63, pctile, rs_decode, runqqq, unpackmsg
+fchisq.f:      ccf2
+filbig2.F:     sfftw_*
+fivehz.F90:    random_number, random_seed, wsjtgen
+flat1.f:       pctile
+flat2.f:       pctile
+flatten.f:     add, move, pctile, zero
+four2a.f:      sleep_msec, sfftw_*
+ftn_init.F90:  cs_init, cs_lock, cs_unlock, pfxdump
+ftn_quit.f90:  cs_destroy, filbig2, four2a
+ftpeak65.f:    fil651, fil652, fil653, fil653, symsync65
+gen24.f:       chkmsg, encode, entail, interleave24, packmsg, unpackmsg
+gen64.f90:     random_number
+gen65.f:       chkmsg, graycode, interleave63, packmsg, rs_encode, 
+               unpackmsg, setup65
+gen6m.f:       gentone
+gencw.f:       morse, msgtype
+gencwid.f:     morse
+genmet.f:      cs_lock, cs_unlock
+genwspr.f90:   encode232, inter_mept, wqdecode, wqencode
+getfile.F90:   check_endian, cs_lock, cs_unlock, rfile, rfile2, sleepqq, usleep
+get_fname.F90: cs_lock, cs_unlock
+grid2k.f:      grid2deg
+horizspec.f90: hscroll, xfft2
+indexx.f:      ssort
+interleave24.f:  cs_lock, cs_unlock
+interleave63.f:  move
+inter_mept.f:  cs_lock, cs_unloc
+k2grid.f:      deg2grid
+longx.f:       detect, peakup, sync
+lpf1.f:        four2a, xfft, zero
+mept162a.f:    cs_lock, cs_unlock, decode162, fourt, sync162, twkfreq
+moon2.f:       dcoord
+MoonDop.f:     dcoord, fromxyz, geocentric, moon2, toxyz
+mtdecode.f:    cs_lock, cs_unlock, indexx, longx, pctile, ping, 
+               smooth, spec441
+packgrid.f:    grid2deg
+packmsg.f:     packtext, getpfx1, k2grid, packcall, packgrid
+packpfx.f90:   packcall
+pctile.f:      sort
+ps162.f:       four2a
+ps24.f:        fourt
+ps.f:          xfft
+rfile.f90:     cs_lock, cs_unlock
+runqqq.F90:    flush, sleepqq, usleep
+savedata.F90:  cs_lock, cs_unlock, get_fname
+short65.f:     add, flat1, getsnr, ps, smooth, zero
+sort.f:        ssort
+spec2d65.f:    add, four2a, ftpeak65, move, zero
+spec2d.f:      indexx, move, pctile, set, xfft, zero
+spec441.f:     move, xfft, zero
+spec.f90:      cs_lock, cs_unlock, horizspec, hscroll, xfft2, flat2
+stdecode.f:    cs_lock, cs_unlock, peakup
+sync162.f:     add, pctile, ps162, zero
+sync24.f:      add, flat1, pctile, peakup, ps24, slope, xcor24, zero, 
+sync64.f:      add, limit, ps, zero, smooth
+sync65.f:      add, flat1, limit, pctile, peakup, ps, slope, xcor, zero, smooth
+syncf0.f:      add, move, xfft, zero
+syncf1.f:      add, move, smooth, xfft, zero
+sync.f:        xfft, zero
+unpackgrid.f:  deg2grid
+unpackmsg.f:   grid2k, unpackcall, unpacktext, getpfx2
+wqdecode.f90:  cs_unlock, cs_lock, hash, unpack50, unpackcall, unpackgrid, 
+               unpackname, unpackpfx, unpackprop, unpacktext2
+wqencode.f90:  hash, pack50, packcall, packgrid, packname, packpfx, 
+               packprop, packtext2
+wsjt1.F:       bzap, cs_lock, cs_unlock, decode6m, flushqqq, indexx, lpf1, 
+               mtdecode, s2shape, spec2d, spec441, stdecode, syncf0, syncf1, 
+               synct, wsjtwspr, zero, wsjt24, wsjt64, wsjt65, avesp2, 
+               short65, bzap, avesp2
+wsjt24.f:      cs_lock, cs_unlock, decode24, flushqqq, sync24, avemsg65
+wsjt64.f:      sync64
+wsjt65.f:      cs_lock, cs_unlock, decode65, flushqqq, setup65, sync65, 
+	       avemsg65
+wsjtgen.F90:   abc441, cs_lock, cs_unlock, gen24, gen64, gen65, gen6m, 
+               gencwid, gencw, genwspr, rfile, rfile2
+wsjtwspr.f90:  filbig2, mept162a
+xcor.f:        pctile
+xfft.f:        four2a

Added: trunk/calledby.txt
===================================================================
--- trunk/calledby.txt	2009-07-23 18:50:08 UTC (rev 1287)
+++ trunk/calledby.txt	2009-07-23 19:47:09 UTC (rev 1288)
@@ -0,0 +1,170 @@
+Name             Called by
+----------------------------------------------------------------------------
+a2d.f90          *start of thread*
+abc441.F90       wsjtgen.F90
+astro0.F90       *GUI*
+astro.F          astro0
+audio_init.F90   *GUI*
+avemsg65.f       wsjt65 (also wsjt24, temporary)
+avemsg6m.f       decode6m
+avesp2.f         wsjt1
+azdist0.f90      *GUI*
+azdist.f         azdist0
+blanker.f90      decode3
+bzap.f           wsjt1
+ccf2.f           fchisq
+chkhist.f        extract
+chkmsg.f         gen24, gen65
+chkt0.f90        *GUI*
+coord.f          astro
+cs_lock          astro0, astro, avemsg6m, azdist0, chkt0, decode1, decode24,
+                 decode6m, deep65, extract, ftn_init, genmet, getfile, 
+                 get_fname, interleave24, inter_mept, mept162a, mtdecode,
+                 rfile, savedata, spec, stdecode, wqdecode, wsjt1, wsjt24, 
+                 wsjt65, wsjtgen
+cs_unlock        astro0, astro, avemsg6m, azdist0, chkt0, decode1, decode24,
+                 decode6m, deep65, extract, ftn_init, genmet, getfile, 
+                 get_fname, interleave24, inter_mept, mept162a, mtdecode,
+                 rfile, savedata, spec, stdecode, wqdecode, wsjt1, wsjt24, 
+                 wsjt65, wsjtgen
+db.f             avemsg6m, decode6m, flatten, mtdecode, short65, sync162,
+                 sync24, sync64, sync65, pix2d65
+dcoord.f         moon2, MoonDop
+decode162.f      mept162a
+decode1.F90      *start of thread*
+decode24.f       wsjt24
+decode2.f90      decode1
+decode3.F90      decode2
+decode65.f       wsjt65
+decode6m.f       wsjt1
+deep65.F         avemsg65, decode65
+deg2grid.f       k2grid, unpackgrid
+demod64a.f       extract
+detect.f         longx
+dot.f            MoonDop
+encode232.f      genwspr
+encode65.f       deep65
+entail.f         gen24
+extract.f        avemsg65, decode65
+fano232.f        decode162
+fchisq.f         sync162
+fil651.f         ftpeak65
+fil652.f         ftpeak65
+fil653.f         ftpeak65
+filbig2.F        ftn_quit, wsjtwspr
+fivehz.F90       *interrupt service routine*
+flat1.f          short65, sync24, sync65
+flat2.f          spec
+flatten.f        avesp2
+four2a.f         bzap,decode6m, ftn_quit, lpf1, ps162, spec2d65, xfft
+fourt.f          mept162, ps24
+ftn_init.F90     *GUI*
+ftn_quit.f90     *GUI*
+ftpeak65.f       spec2d65
+ftsky.f          astro.F
+gen24.f          wsjtgen
+gen64.f90        wsjtgen
+gen65.f          wsjtgen
+gen6m.f          wsjtgen
+gencw.f          wsjtgen
+gencwid.f        wsjtgen
+genmet.f         decode24
+gentone.f        gen6m
+genwspr.f90      wsjtgen
+geocentric.f     MoonDop
+GeoDist.f        azdist
+getfile.F90      *GUI*
+get_fname.F90    decode2, savedata
+getpfx1.f        packmsg
+getpfx2.f        unpackmsg
+getsnr.f         short65
+graycode.f       encode65, extract, gen65
+grid2deg.f       astro, azdist, grid2k, packgrid
+grid2k.f         unpackmsg
+hash.f90         wqdecode, wqencode
+horizspec.f90    spec
+hscroll.f90      horizspec, spec
+indexx.f         extract, mtdecode, spec2d, wsjt1
+interleave24.f   decode24, gen24
+interleave63.f   encode65, extract, gen65
+inter_mept.f     decode162, genwspr
+k2grid.f         packmsg
+limit.f          sync64, sync65
+longx.f          mtdecode
+lpf1.f           wsjt1
+mept162a.f       wsjtwspr
+moon2.f          MoonDop
+MoonDop.f        astro
+morse.f          gencw, gencwid
+msgtype.f        gencw
+mtdecode.f       wsjt1
+nchar.f          packcall
+pack50.f         wqencode
+packcall.f       packmsg, packpfx, wqencode
+packgrid.f       packmsg, wqencode
+packmsg.f        chkt0/GUI, deep65, encode65, gen24, gen65
+packname.f90     wqencode
+packpfx.f90      wqencode
+packprop.f90     wqencode
+packtext2.f90    wqencode
+packtext.f       packmsg
+pctile.f         extract, flat1, flat2, flatten, mtdecode, spec2d,
+                 sync162, sync24, sync65, xcor
+peakup.f         longx, stdecode, sync24, sync65
+pfxdump.f        ftn_init/GUI
+ping.f           mtdecode
+pix2d65.f90      decode3
+pix2d.f90        decode3
+ps162.f          sync162
+ps24.f           sync24
+ps.f             avesp2, short65, sync64, sync65
+rfile2.f         astro, getfile, wsjtgen
+rfile.f90        getfile, wsjtgen
+runqqq.F90       extract
+s2shape.f        wsjt1
+savedata.F90     decode1
+set.f            gen65, spec2d, wsjt65
+setup65.f        gen65, wsjt65
+short65.f        wsjt1
+slope.f          sync24, sync66
+smooth.f         mtdecode, short65, sync24, sync64, sync65, syncf1
+sort.f           pctile
+spec2d65.f       decode65
+spec2d.f         wsjt1
+spec441.f        mtdecode, wsjt1
+spec.f90         *GUI*
+ssort.f          indexx, sort
+stdecode.f       wsjt1
+sun.f            astro
+symsync65.f      ftpeak65
+sync162.f        mept162a
+sync24.f         wsjt24
+sync64.f         wsjt64
+sync65.f         wsjt65
+sync.f           longx
+syncf0.f         wsjt1
+syncf1.f         wsjt1
+synct.f          wsjt1
+toxyz.f          MoonDop
+twkfreq.f        mept162a
+unpack50.f       wqdecode
+unpackcall.f     unpackmsg, wqdecode
+unpackgrid.f     wqdecode
+unpackmsg.f      chkt0/GUI, decode24, deep65, extract, gen24, gen64, gen65
+unpackname.f90   wqdecode
+unpackpfx.f90    wqdecode
+unpackprop.f90   unpackprop
+unpacktext2.f90  wqdecode
+unpacktext.f     unpackmsg, wqdecode
+wqdecode.f90     decode162, genwspr
+wqencode.f90     gen64, genwspr
+wsjt1.F          decode3
+wsjt24.f         wsjt1
+wsjt64.f         wsjt1
+wsjt65.f         wsjt1
+wsjtgen.F90      fivehz
+wsjtwspr.f90     wsjt1
+xcor24.f         sync24
+xcor.f           sync65
+xfft2.f          horizspec, spec
+xfft.f           bzap, lpf1, ps, spec2d, spec441, syncf0, syncf1, sync

Modified: trunk/inter_mept.f
===================================================================
--- trunk/inter_mept.f	2009-07-23 18:50:08 UTC (rev 1287)
+++ trunk/inter_mept.f	2009-07-23 19:47:09 UTC (rev 1288)
@@ -1,45 +1,45 @@
-      subroutine inter_mept(id,ndir)
-
-C  Interleave (ndir=1) or de-interleave (ndir=-1) the array id.
-
-      integer*1 id(0:161),itmp(0:161)
-      integer j0(0:161)
-      character*8 c0,c1
-      logical first
-      data first/.true./
-      save
-
-      if(first) then
-         call cs_lock('inter_mept')
-         k=-1
-         do i=0,255
-            write(c0,1001) i
- 1001       format(b8.8)
-            c1=c0(8:8)//c0(7:7)//c0(6:6)//c0(5:5)//c0(4:4)//c0(3:3)//
-     +         c0(2:2)//c0(1:1)
-            read(c1,1001) n
-            if(n.le.161) then
-               k=k+1
-               j0(k)=n
-            endif
-         enddo
-         call cs_unlock
-         first=.false.
-      endif
-
-      if(ndir.eq.1) then
-         do i=0,161
-            itmp(j0(i))=id(i)
-         enddo
-      else
-         do i=0,161
-            itmp(i)=id(j0(i))
-         enddo
-      endif
-
-      do i=0,161
-         id(i)=itmp(i)
-      enddo
-
-      return
-      end
+      subroutine inter_mept(id,ndir)
+
+C  Interleave (ndir=1) or de-interleave (ndir=-1) the array id.
+
+      integer*1 id(0:161),itmp(0:161)
+      integer j0(0:161)
+      character*8 c0,c1
+      logical first
+      data first/.true./
+      save
+
+      if(first) then
+         call cs_lock('inter_mept')
+         k=-1
+         do i=0,255
+            write(c0,1001) i
+ 1001       format(b8.8)
+            c1=c0(8:8)//c0(7:7)//c0(6:6)//c0(5:5)//c0(4:4)//c0(3:3)//
+     +         c0(2:2)//c0(1:1)
+            read(c1,1001) n
+            if(n.le.161) then
+               k=k+1
+               j0(k)=n
+            endif
+         enddo
+         call cs_unlock
+         first=.false.
+      endif
+
+      if(ndir.eq.1) then
+         do i=0,161
+            itmp(j0(i))=id(i)
+         enddo
+      else
+         do i=0,161
+            itmp(i)=id(j0(i))
+         enddo
+      endif
+
+      do i=0,161
+         id(i)=itmp(i)
+      enddo
+
+      return
+      end

Modified: trunk/wqdecode.f90
===================================================================
--- trunk/wqdecode.f90	2009-07-23 18:50:08 UTC (rev 1287)
+++ trunk/wqdecode.f90	2009-07-23 19:47:09 UTC (rev 1288)
@@ -1,312 +1,312 @@
-subroutine wqdecode(data0,message,ntype)
-
-  parameter (N15=32768)
-  integer*1 data0(11)
-  character*22 message
-  character*12 callsign
-  character*3 cdbm,cf
-  character*2 crpt
-  character*4 grid
-  character*9 name
-  character*36 fmt
-  character*6 cwx(4)
-  character*7 cwind(5)
-  character ccur*4,cxp*2
-  logical first
-  character*12 dcall(0:N15-1)
-  data first/.true./
-  data cwx/'CLEAR','CLOUDY','RAIN','SNOW'/
-  data cwind/'CALM','BREEZES','WINDY','DRY','HUMID'/
-  save first,dcall
-
-  call cs_lock('wqdecode')
-  if(first) then
-     dcall='            '
-     first=.false.
-  endif
-
-  message='                      '
-  call unpack50(data0,n1,n2)
-  call unpackcall(n1,callsign)
-  i1=index(callsign,' ')
-  call unpackgrid(n2/128,grid)
-  ntype=iand(n2,127) -64
-
-! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
-  nu=mod(ntype,10)
-  if(ntype.ge.0 .and. ntype.le.60 .and. (nu.eq.0 .or. nu.eq.3 .or.   &amp;
-       nu.eq.7)) then
-     write(cdbm,'(i3)'),ntype
-     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
-     message=callsign(1:i1)//grid//' '//cdbm
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1)
-
-! &quot;Best DX&quot; WSPR response (type 1)
-  else if(ntype.eq.1) then
-     message=grid//' DE '//callsign
-
-! CQ (msg 3; types 2,4,5)
-  else if(ntype.eq.2) then
-     message='CQ '//callsign(:i1)//grid
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1)
-  else if(ntype.eq.4 .or. ntype.eq.5) then
-     ng=n2/128 + 32768*(ntype-4)
-     call unpackpfx(ng,callsign)
-     message='CQ '//callsign
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1)
-
-! Reply to CQ (msg #2; type 6)
-  else if(ntype.eq.6) then
-     ih=(n2-64-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '//callsign(:i1-1)
-     else
-        message='&lt;...&gt; '//callsign
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Reply to CQ (msg #2; type 8)
-  else if(ntype.eq.8) then
-     message='DE '//callsign(:i1)//grid
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Reply to CQ, DE pfx/call (msg #2; types 9, 11)
-  else if(ntype.eq.9 .or. ntype.eq.11) then
-     ng=n2/128 + 32768*(ntype-9)/2
-     call unpackpfx(ng,callsign)
-     message='DE '//callsign
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and report (msg #3; types -1 to -9)
-  else if(ntype.le.-1 .and. ntype.ge.-9) then
-     write(crpt,1010) -ntype
-1010 format('S',i1)
-     ih=(n2-62-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; '//crpt
-     else
-        message=callsign(:i1)//'&lt;...&gt; '//crpt
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! pfx/call and report (msg #3; types -10 to -27)
-  else if(ntype.le.-10 .and. ntype.ge.-27) then
-     ng=n2/128
-     nrpt=-ntype-9
-     if(ntype.le.-19) then
-        ng=ng + 32768
-        nrpt=-ntype-18
-     endif
-     write(crpt,1010) nrpt
-     call unpackpfx(ng,callsign)
-     message=callsign//' '//crpt
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and R and report (msg #4; types -28 to -36)
-  else if(ntype.le.-28 .and. ntype.ge.-36) then
-     write(crpt,1010) -(ntype+27)
-     ih=(n2-64+28-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; '//'R '//crpt
-     else
-        message=callsign(:i1)//'&lt;...&gt; '//'R '//crpt
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! pfx/call R and report (msg #4; types -37 to -54)
-  else if(ntype.le.-37 .and. ntype.ge.-54) then
-     ng=n2/128
-     nrpt=-ntype-36
-     if(ntype.le.-46) then
-        ng=ng + 32768
-        nrpt=-ntype-45
-     endif
-     write(crpt,1010) nrpt
-     call unpackpfx(ng,callsign)
-     message=callsign//' R '//crpt
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and RRR (msg#5; type 12)
-  else if(ntype.eq.12) then
-     ih=(n2-64+28-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; RRR'
-     else
-        message=callsign(:i1)//'&lt;...&gt; RRR'
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! Calls and RRR (msg#5; type 14)
-  else if(ntype.eq.14) then
-     ih=(n2-64+28-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '//callsign(:i1)//'RRR'
-     else
-        message='&lt;...&gt; '//callsign(:i1)//' RRR'
-     endif
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! DE pfx/call and RRR (msg#5; types 15, 16)
-  else if(ntype.eq.15 .or. ntype.eq.16) then
-     ng=n2/128 + 32768*(ntype-15)
-     call unpackpfx(ng,callsign)
-     message='DE '//callsign//' RRR'
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! TNX [name] 73 GL (msg #6; type 18)
-  else if(ntype.eq.18) then
-     ng=(n2-18-64)/128
-     call unpackname(n1,ng,name,len)
-     message='TNX '//name(:len)//' 73 GL'
-
-! OP [name] 73 GL (msg #6; type 18)
-  else if(ntype.eq.-56) then
-     ng=(n2+56-64)/128
-     call unpackname(n1,ng,name,len)
-     message='OP '//name(:len)//' 73 GL'
-
-! 73 DE [call] [grid] (msg #6; type 19)
-  else if(ntype.eq.19) then
-     ng=(n2-19-64)/128
-     message='73 DE '//callsign(:i1)//grid
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! 73 DE pfx/call (msg #6; type 21, 22)
-  else if(ntype.eq.21 .or. ntype.eq.22) then
-     ng=n2/128 + (ntype-21)*32768
-     call unpackpfx(ng,callsign)
-     i1=index(callsign,' ')
-     message='73 DE '//callsign
-     call hash(callsign,i1-1,ih)
-     dcall(ih)=callsign(:i1-1)
-
-! [power] W [gain] DBD 73 GL (msg#6; type 24, 25)
-  else if(ntype.eq.24 .or. ntype.eq.25) then
-     ng=(n2-24-64)/128 - 32
-     i1=1
-     if(n1.gt.0) i1=log10(float(n1)) + 1
-     i2=1
-     if(ng.ge.10) i2=2
-     if(ng.lt.0) i2=i2+1
-     if(n1.le.3000) then
-        if(ntype.eq.24) fmt=&quot;(i4,' W ',i2,' DBD 73 GL')&quot;
-        if(ntype.eq.25) fmt=&quot;(i4,' W ',i2,' DBD      ')&quot;
-        fmt(3:3)=char(48+i1)
-        fmt(12:12)=char(48+i2)
-        if(ng.le.100) then
-           write(message,fmt) n1,ng
-        else
-           if(ng.eq.30000) fmt=fmt(1:8)//&quot;DIPOLE')&quot;
-           if(ng.eq.30001) fmt=fmt(1:8)//&quot;VERTICAL')&quot;
-           write(message,fmt) n1
-        endif
-     else
-        mw=n1-3000
-        if(ntype.eq.24) fmt=&quot;('0.',i3.3,' W ',i2,' DBD 73 GL')&quot;
-        if(ntype.eq.25) fmt=&quot;('0.',i3.3,' W ',i2,' DBD      ')&quot;
-        fmt(19:19)=char(48+i2)
-        if(ng.le.100) then
-           write(message,fmt) mw,ng
-        else
-           if(ng.eq.30000) fmt=fmt(1:15)//&quot;DIPOLE')&quot;
-           if(ng.eq.30001) fmt=fmt(1:15)//&quot;VERTICAL')&quot;
-           write(message,fmt) n1
-        endif
-        if(index(message,'***').gt.0) go to 700
-     endif
-
-! QRZ call (msg #3; type 26)
-  else if(ntype.eq.26) then
-     ng=(n2-24-64)/128 - 32
-     message='QRZ '//callsign
-
-! PSE QSY [nnn] KHZ (msg #6; type 28)
-  else if(ntype.eq.28) then
-     if(n1.gt.0) i1=log10(float(n1)) + 1
-     fmt=&quot;('PSE QSY ',i2,' KHZ')&quot;
-     fmt(14:14)=char(48+i1)
-     write(message,fmt) n1        
-
-! WX wx temp C/F wind (msg #6; type 29)
-  else if(ntype.eq.29) then
-     nwx=n1/10000
-     ntemp=mod(n1,10000) - 100
-     cf=' F '
-     if(ntemp.gt.800) then
-        ntemp=ntemp-1000
-        cf=' C '
-     endif
-     write(message,1020) cwx(nwx),ntemp,cf,cwind(n2/128)
-1020 format('WX ',a6,i3,a3,a7)
-
-! Hexadecimal data (type 62)
-  else if(ntype.eq.62) then
-     ng=n2/128
-     write(message,'(z4.4,z7.7)') ng,n1
-     
-! Solar/geomagnetic/ionospheric data (type 63)
-  else if(ntype.eq.63) then
-     ih=(n2-64-ntype)/128
-     if(dcall(ih)(1:1).ne.' ') then
-        i2=index(dcall(ih),' ')
-        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '
-     else
-        message='&lt;...&gt; '
-     endif
-     call unpackprop(n1,k,muf,ccur,cxp)
-     i2=index(message,'&gt;')
-     write(message(i2+1:),'(i3,i3)') k,muf
-     message=message(:i2+7)//ccur//' '//cxp
-     
-! [plain text] (msg #6; type -57)
-  else if(ntype.eq.-57) then
-     ng=n2/128
-     call unpacktext2(n1,ng,message)
-  else
-     go to 700
-  endif
-  go to 750
-
-!     message='&lt;Unknown message type&gt;'
-700 i1=index(callsign,' ')
-  if(i1.lt.1) i1=12
-  message=callsign(:i1)//' (BadMsg)'
-
-750 do i=1,22
-     if(ichar(message(i:i)).eq.0) message(i:i)=' '
-  enddo
-
-  do i=22,1,-1
-     if(message(i:i).ne.' ') go to 800
-  enddo
-800 i2=i
-  do n=1,20
-     i1=index(message(:i2),'  ')
-     if(i1.le.0) go to 900
-     message=message(1:i1)//message(i1+2:)
-     i2=i2-1
-  enddo
-
-900 call cs_unlock
-  return
-end subroutine wqdecode
+subroutine wqdecode(data0,message,ntype)
+
+  parameter (N15=32768)
+  integer*1 data0(11)
+  character*22 message
+  character*12 callsign
+  character*3 cdbm,cf
+  character*2 crpt
+  character*4 grid
+  character*9 name
+  character*36 fmt
+  character*6 cwx(4)
+  character*7 cwind(5)
+  character ccur*4,cxp*2
+  logical first
+  character*12 dcall(0:N15-1)
+  data first/.true./
+  data cwx/'CLEAR','CLOUDY','RAIN','SNOW'/
+  data cwind/'CALM','BREEZES','WINDY','DRY','HUMID'/
+  save first,dcall
+
+  call cs_lock('wqdecode')
+  if(first) then
+     dcall='            '
+     first=.false.
+  endif
+
+  message='                      '
+  call unpack50(data0,n1,n2)
+  call unpackcall(n1,callsign)
+  i1=index(callsign,' ')
+  call unpackgrid(n2/128,grid)
+  ntype=iand(n2,127) -64
+
+! Standard WSPR message (types 0 3 7 10 13 17 ... 60)
+  nu=mod(ntype,10)
+  if(ntype.ge.0 .and. ntype.le.60 .and. (nu.eq.0 .or. nu.eq.3 .or.   &amp;
+       nu.eq.7)) then
+     write(cdbm,'(i3)'),ntype
+     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+     if(cdbm(1:1).eq.' ') cdbm=cdbm(2:)
+     message=callsign(1:i1)//grid//' '//cdbm
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1)
+
+! &quot;Best DX&quot; WSPR response (type 1)
+  else if(ntype.eq.1) then
+     message=grid//' DE '//callsign
+
+! CQ (msg 3; types 2,4,5)
+  else if(ntype.eq.2) then
+     message='CQ '//callsign(:i1)//grid
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1)
+  else if(ntype.eq.4 .or. ntype.eq.5) then
+     ng=n2/128 + 32768*(ntype-4)
+     call unpackpfx(ng,callsign)
+     message='CQ '//callsign
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1)
+
+! Reply to CQ (msg #2; type 6)
+  else if(ntype.eq.6) then
+     ih=(n2-64-ntype)/128
+     if(dcall(ih)(1:1).ne.' ') then
+        i2=index(dcall(ih),' ')
+        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '//callsign(:i1-1)
+     else
+        message='&lt;...&gt; '//callsign
+     endif
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! Reply to CQ (msg #2; type 8)
+  else if(ntype.eq.8) then
+     message='DE '//callsign(:i1)//grid
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! Reply to CQ, DE pfx/call (msg #2; types 9, 11)
+  else if(ntype.eq.9 .or. ntype.eq.11) then
+     ng=n2/128 + 32768*(ntype-9)/2
+     call unpackpfx(ng,callsign)
+     message='DE '//callsign
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! Calls and report (msg #3; types -1 to -9)
+  else if(ntype.le.-1 .and. ntype.ge.-9) then
+     write(crpt,1010) -ntype
+1010 format('S',i1)
+     ih=(n2-62-ntype)/128
+     if(dcall(ih)(1:1).ne.' ') then
+        i2=index(dcall(ih),' ')
+        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; '//crpt
+     else
+        message=callsign(:i1)//'&lt;...&gt; '//crpt
+     endif
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! pfx/call and report (msg #3; types -10 to -27)
+  else if(ntype.le.-10 .and. ntype.ge.-27) then
+     ng=n2/128
+     nrpt=-ntype-9
+     if(ntype.le.-19) then
+        ng=ng + 32768
+        nrpt=-ntype-18
+     endif
+     write(crpt,1010) nrpt
+     call unpackpfx(ng,callsign)
+     message=callsign//' '//crpt
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! Calls and R and report (msg #4; types -28 to -36)
+  else if(ntype.le.-28 .and. ntype.ge.-36) then
+     write(crpt,1010) -(ntype+27)
+     ih=(n2-64+28-ntype)/128
+     if(dcall(ih)(1:1).ne.' ') then
+        i2=index(dcall(ih),' ')
+        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; '//'R '//crpt
+     else
+        message=callsign(:i1)//'&lt;...&gt; '//'R '//crpt
+     endif
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! pfx/call R and report (msg #4; types -37 to -54)
+  else if(ntype.le.-37 .and. ntype.ge.-54) then
+     ng=n2/128
+     nrpt=-ntype-36
+     if(ntype.le.-46) then
+        ng=ng + 32768
+        nrpt=-ntype-45
+     endif
+     write(crpt,1010) nrpt
+     call unpackpfx(ng,callsign)
+     message=callsign//' R '//crpt
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! Calls and RRR (msg#5; type 12)
+  else if(ntype.eq.12) then
+     ih=(n2-64+28-ntype)/128
+     if(dcall(ih)(1:1).ne.' ') then
+        i2=index(dcall(ih),' ')
+        message=callsign(:i1)//'&lt;'//dcall(ih)(:i2-1)//'&gt; RRR'
+     else
+        message=callsign(:i1)//'&lt;...&gt; RRR'
+     endif
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! Calls and RRR (msg#5; type 14)
+  else if(ntype.eq.14) then
+     ih=(n2-64+28-ntype)/128
+     if(dcall(ih)(1:1).ne.' ') then
+        i2=index(dcall(ih),' ')
+        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '//callsign(:i1)//'RRR'
+     else
+        message='&lt;...&gt; '//callsign(:i1)//' RRR'
+     endif
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! DE pfx/call and RRR (msg#5; types 15, 16)
+  else if(ntype.eq.15 .or. ntype.eq.16) then
+     ng=n2/128 + 32768*(ntype-15)
+     call unpackpfx(ng,callsign)
+     message='DE '//callsign//' RRR'
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! TNX [name] 73 GL (msg #6; type 18)
+  else if(ntype.eq.18) then
+     ng=(n2-18-64)/128
+     call unpackname(n1,ng,name,len)
+     message='TNX '//name(:len)//' 73 GL'
+
+! OP [name] 73 GL (msg #6; type 18)
+  else if(ntype.eq.-56) then
+     ng=(n2+56-64)/128
+     call unpackname(n1,ng,name,len)
+     message='OP '//name(:len)//' 73 GL'
+
+! 73 DE [call] [grid] (msg #6; type 19)
+  else if(ntype.eq.19) then
+     ng=(n2-19-64)/128
+     message='73 DE '//callsign(:i1)//grid
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! 73 DE pfx/call (msg #6; type 21, 22)
+  else if(ntype.eq.21 .or. ntype.eq.22) then
+     ng=n2/128 + (ntype-21)*32768
+     call unpackpfx(ng,callsign)
+     i1=index(callsign,' ')
+     message='73 DE '//callsign
+     call hash(callsign,i1-1,ih)
+     dcall(ih)=callsign(:i1-1)
+
+! [power] W [gain] DBD 73 GL (msg#6; type 24, 25)
+  else if(ntype.eq.24 .or. ntype.eq.25) then
+     ng=(n2-24-64)/128 - 32
+     i1=1
+     if(n1.gt.0) i1=log10(float(n1)) + 1
+     i2=1
+     if(ng.ge.10) i2=2
+     if(ng.lt.0) i2=i2+1
+     if(n1.le.3000) then
+        if(ntype.eq.24) fmt=&quot;(i4,' W ',i2,' DBD 73 GL')&quot;
+        if(ntype.eq.25) fmt=&quot;(i4,' W ',i2,' DBD      ')&quot;
+        fmt(3:3)=char(48+i1)
+        fmt(12:12)=char(48+i2)
+        if(ng.le.100) then
+           write(message,fmt) n1,ng
+        else
+           if(ng.eq.30000) fmt=fmt(1:8)//&quot;DIPOLE')&quot;
+           if(ng.eq.30001) fmt=fmt(1:8)//&quot;VERTICAL')&quot;
+           write(message,fmt) n1
+        endif
+     else
+        mw=n1-3000
+        if(ntype.eq.24) fmt=&quot;('0.',i3.3,' W ',i2,' DBD 73 GL')&quot;
+        if(ntype.eq.25) fmt=&quot;('0.',i3.3,' W ',i2,' DBD      ')&quot;
+        fmt(19:19)=char(48+i2)
+        if(ng.le.100) then
+           write(message,fmt) mw,ng
+        else
+           if(ng.eq.30000) fmt=fmt(1:15)//&quot;DIPOLE')&quot;
+           if(ng.eq.30001) fmt=fmt(1:15)//&quot;VERTICAL')&quot;
+           write(message,fmt) n1
+        endif
+        if(index(message,'***').gt.0) go to 700
+     endif
+
+! QRZ call (msg #3; type 26)
+  else if(ntype.eq.26) then
+     ng=(n2-24-64)/128 - 32
+     message='QRZ '//callsign
+
+! PSE QSY [nnn] KHZ (msg #6; type 28)
+  else if(ntype.eq.28) then
+     if(n1.gt.0) i1=log10(float(n1)) + 1
+     fmt=&quot;('PSE QSY ',i2,' KHZ')&quot;
+     fmt(14:14)=char(48+i1)
+     write(message,fmt) n1        
+
+! WX wx temp C/F wind (msg #6; type 29)
+  else if(ntype.eq.29) then
+     nwx=n1/10000
+     ntemp=mod(n1,10000) - 100
+     cf=' F '
+     if(ntemp.gt.800) then
+        ntemp=ntemp-1000
+        cf=' C '
+     endif
+     write(message,1020) cwx(nwx),ntemp,cf,cwind(n2/128)
+1020 format('WX ',a6,i3,a3,a7)
+
+! Hexadecimal data (type 62)
+  else if(ntype.eq.62) then
+     ng=n2/128
+     write(message,'(z4.4,z7.7)') ng,n1
+     
+! Solar/geomagnetic/ionospheric data (type 63)
+  else if(ntype.eq.63) then
+     ih=(n2-64-ntype)/128
+     if(dcall(ih)(1:1).ne.' ') then
+        i2=index(dcall(ih),' ')
+        message='&lt;'//dcall(ih)(:i2-1)//'&gt; '
+     else
+        message='&lt;...&gt; '
+     endif
+     call unpackprop(n1,k,muf,ccur,cxp)
+     i2=index(message,'&gt;')
+     write(message(i2+1:),'(i3,i3)') k,muf
+     message=message(:i2+7)//ccur//' '//cxp
+     
+! [plain text] (msg #6; type -57)
+  else if(ntype.eq.-57) then
+     ng=n2/128
+     call unpacktext2(n1,ng,message)
+  else
+     go to 700
+  endif
+  go to 750
+
+!     message='&lt;Unknown message type&gt;'
+700 i1=index(callsign,' ')
+  if(i1.lt.1) i1=12
+  message=callsign(:i1)//' (BadMsg)'
+
+750 do i=1,22
+     if(ichar(message(i:i)).eq.0) message(i:i)=' '
+  enddo
+
+  do i=22,1,-1
+     if(message(i:i).ne.' ') go to 800
+  enddo
+800 i2=i
+  do n=1,20
+     i1=index(message(:i2),'  ')
+     if(i1.le.0) go to 900
+     message=message(1:i1)//message(i1+2:)
+     i2=i2-1
+  enddo
+
+900 call cs_unlock
+  return
+end subroutine wqdecode


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000981.html">[WSJT-SVN] r1287 - trunk
</A></li>
	<LI>Next message: <A HREF="000983.html">[WSJT-SVN] r1289 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#982">[ date ]</a>
              <a href="thread.html#982">[ thread ]</a>
              <a href="subject.html#982">[ subject ]</a>
              <a href="author.html#982">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
