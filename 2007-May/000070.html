<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [WSJT-SVN] r385 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wsjt-svn/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r385%20-%20trunk&In-Reply-To=%3C200705081815.l48IFIav022972%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000069.html">
   <LINK REL="Next"  HREF="000071.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[WSJT-SVN] r385 - trunk</H1>
    <B>va3db at BerliOS</B> 
    <A HREF="mailto:wsjt-svn%40lists.berlios.de?Subject=Re%3A%20%5BWSJT-SVN%5D%20r385%20-%20trunk&In-Reply-To=%3C200705081815.l48IFIav022972%40sheep.berlios.de%3E"
       TITLE="[WSJT-SVN] r385 - trunk">va3db at mail.berlios.de
       </A><BR>
    <I>Tue May  8 20:15:18 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000069.html">[WSJT-SVN] r384 - trunk
</A></li>
        <LI>Next message: <A HREF="000071.html">[WSJT-SVN] r386 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70">[ date ]</a>
              <a href="thread.html#70">[ thread ]</a>
              <a href="subject.html#70">[ subject ]</a>
              <a href="author.html#70">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: va3db
Date: 2007-05-08 20:15:18 +0200 (Tue, 08 May 2007)
New Revision: 385

Removed:
   trunk/start_alsa.c
   trunk/start_oss.c
Modified:
   trunk/Makefile.in
   trunk/configure
   trunk/configure.ac
Log:
- Simplify configure and Makefile
- remove alsa and oss support
- build our provided portaudio-v19 if none supplied by user
  using --with-portaudio-include-dir= --with-portaudio-lib-dir=
- For now, build portaudio.a always with -pic, I realise this is not optimum



Modified: trunk/Makefile.in
===================================================================
--- trunk/Makefile.in	2007-05-05 20:37:59 UTC (rev 384)
+++ trunk/Makefile.in	2007-05-08 18:15:18 UTC (rev 385)
@@ -72,22 +72,8 @@
 SRCS2C	= init_rs.c encode_rs.c decode_rs.c
 OBJS2C  = ${SRCS2C:.c=.o}
 
-# ok, so far for now
-# Windows @AUDIO@ will be a2d.f90 jtaudio.c since it uses portaudio
-#            for *nix @AUDIO@ will also be a2d.f90, jtaudio.c
-#               and start_portaudio.c for systems using portaudio
-#            for *nix @AUDIO@ will be start_alsa.c for alsa
-#            for *nix @AUDIO@ will be start_oss.c for oss
-#
-# ptt_unix.c vs. ptt.c I'll sort out later. 
-# ditto for cutil.c (only used on *nix)
-# --db
-# jtaudio.c/start_threads.c mess will have to be sorted out later
-# to minimise #ifdef's 
-# --db
-# and mostly sorted
-# --db
-#
+# for unix @AUDIO@ will be a2d.f90, jtaudio.c start_portaudio.c
+
 SRCS3C	= ptt_unix.c igray.c wrapkarn.c cutil.c
 OBJS3C  = ${SRCS3C:.c=.o}
 AUDIOSRCS = @AUDIO@
@@ -97,14 +83,16 @@
 JT65code: $(OBJS1)
 	$(FC) -o JT65code $(OBJS1)
 
-portaudio:
+portaudio:	portaudio-v19/lib/.libs/libportaudio.a
+
 portaudio-v19/lib/.libs/libportaudio.a:
-	(cd portaudio-v19;./configure --with-jack=no)
+	(cd portaudio-v19;./configure --with-pic --with-jack=no)
 	(cd portaudio-v19;${MAKE})
 
+portaudio_clean:
+	(cd portaudio-v19;${MAKE} clean)
+
 wsjt6:	@LOCAL_PORTAUDIO@ Audio.so
-#	${PYTHON} c:\python23\installer\Build.py wsjt.spec
-#	${RM} wsjt6
 
 deep65.o: deep65.F
 	$(FC) -c -O0 -Wall -fPIC deep65.F
@@ -118,10 +106,7 @@
 	${SRCS3C} ${AUDIOSRCS}
 
 wsjt.spec: wsjt.py astro.py g.py options.py palettes.py smeter.py specjt.py
-#	${PYTHON} c:\python23\installer\makespec.py --icon wsjt.ico \
-#	--tk --onefile wsjt.py
 
-
 init_rs_int.o: init_rs.c
 	$(CC) $(CFLAGS) -c -DBIGSYM=1 -o init_rs_int.o init_rs.c
 encode_rs_int.o: encode_rs.c
@@ -130,7 +115,7 @@
 	$(CC) $(CFLAGS) -c -DBIGSYM=1 -o decode_rs_int.o decode_rs.c
 
 .PHONY : clean
-clean:
+clean:	@LOCAL_PORTAUDIO_CLEAN@
 	${RM} -f *.o *.pyc *.so *~ JT65code wsjt6
 
 distclean: clean

Modified: trunk/configure
===================================================================
--- trunk/configure	2007-05-05 20:37:59 UTC (rev 384)
+++ trunk/configure	2007-05-08 18:15:18 UTC (rev 385)
@@ -2,7 +2,7 @@
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.59 for wsjt 5.9.6.
 #
-# $Id: configure.ac 362 2007-03-02 20:05:24Z va3db $
+# $Id: configure.ac 382 2007-05-03 17:29:37Z va3db $
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
@@ -311,7 +311,7 @@
 # include &lt;unistd.h&gt;
 #endif&quot;
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT F77 FFLAGS ac_ct_F77 CPP EGREP SET_MAKE INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA RM CP MV LN SED AR LD TEST PYTHON F2PY G95 GFORTRAN OS CLOBBER FC_LIB_PATH FC AUDIO LOCAL_PORTAUDIO LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT F77 FFLAGS ac_ct_F77 CPP EGREP SET_MAKE INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA RM CP MV LN SED AR LD TEST PYTHON F2PY G95 GFORTRAN OS CLOBBER FC_LIB_PATH FC AUDIO LOCAL_PORTAUDIO LOCAL_PORTAUDIO_CLEAN LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -854,9 +854,6 @@
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
   --enable-clobber        Don't preserve old binaries on make install
   --enable-assert         Enable assert().
-  --enable-alsa           Force ALSA SOUNDCARD usage.
-  --enable-oss            Force OSS SOUND usage.
-  --enable-portaudio      Force PORTAUDIO SOUND usage.
   --enable-g95            Use G95 compiler if available.
   --enable-gfortran       Use gfortran compiler if available.
 
@@ -984,7 +981,7 @@
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 
-$Id: configure.ac 362 2007-03-02 20:05:24Z va3db $
+$Id: configure.ac 382 2007-05-03 17:29:37Z va3db $
 _ACEOF
   exit 0
 fi
@@ -2361,7 +2358,7 @@
 
 
 # Provide some information about the compiler.
-echo &quot;$as_me:2364:&quot; \
+echo &quot;$as_me:2361:&quot; \
      &quot;checking for Fortran 77 compiler version&quot; &gt;&amp;5
 ac_compiler=`set X $ac_compile; echo $2`
 { (eval echo &quot;$as_me:$LINENO: \&quot;$ac_compiler --version &lt;/dev/null &gt;&amp;5\&quot;&quot;) &gt;&amp;5
@@ -2508,7 +2505,7 @@
 
 CFLAGS=&quot;$OLD_CFLAGS&quot;
 
-CPPFLAGS=&quot;-I/usr/local/include -I/usr/include/alsa -I/usr/local/include/alsa ${CPPFLAGS}&quot;
+CPPFLAGS=&quot;-I/usr/local/include ${CPPFLAGS}&quot;
 LDFLAGS=&quot;-L/usr/local/lib ${LDFLAGS}&quot;
 LIBS=&quot; -lpthread ${LIBS}&quot;
 
@@ -6782,33 +6779,7 @@
 	HAS_PORTAUDIO=1
 fi
 
-# Check whether --enable-alsa or --disable-alsa was given.
-if test &quot;${enable_alsa+set}&quot; = set; then
-  enableval=&quot;$enable_alsa&quot;
-  alsa=$enableval
-else
-  alsa=no
-fi;
 
-
-# Check whether --enable-oss or --disable-oss was given.
-if test &quot;${enable_oss+set}&quot; = set; then
-  enableval=&quot;$enable_oss&quot;
-  oss=$enableval
-else
-  oss=no
-fi;
-
-
-# Check whether --enable-portaudio or --disable-portaudio was given.
-if test &quot;${enable_portaudio+set}&quot; = set; then
-  enableval=&quot;$enable_portaudio&quot;
-  portaudio=$enableval
-else
-  portaudio=no
-fi;
-
-
 # Check whether --enable-g95 or --disable-g95 was given.
 if test &quot;${enable_g95+set}&quot; = set; then
   enableval=&quot;$enable_g95&quot;
@@ -6871,48 +6842,23 @@
 
 
 
-
-if test &quot;$alsa&quot; != yes -a &quot;$oss&quot; != yes -a \
-	&quot;$portaudio&quot; != yes; then
-        if test $HAS_PORTAUDIO -eq 1; then
-		portaudio=yes;
-	elif test $HAS_ASOUNDLIB_H -eq 1; then
-		alsa=yes;
-	elif test $HAS_SOUNDCARD_H -eq 1; then
-		oss=yes;
-	fi
+if test $HAS_ASOUNDLIB_H -eq 1; then
+	CPPFLAGS=&quot;-I/usr/include/alsa -I/usr/local/include/alsa $(CPPFLAGS)&quot;
+	LDFLAGS=&quot;${ASOUNDLIBS} ${LDFLAGS}&quot;
 fi
 
 
-if test &quot;$alsa&quot; = yes; then
-	if test $HAS_ASOUNDLIB_H -eq 0; then
-		{ { echo &quot;$as_me:$LINENO: error: You need asoundlib.h to use --enable-alsa&quot; &gt;&amp;5
-echo &quot;$as_me: error: You need asoundlib.h to use --enable-alsa&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }
-	fi
+if test $HAS_PORTAUDIO -eq 0; then
+	portaudio_include_dir=&quot;portaudio-v19/include&quot;
+	LIBS=&quot;${LIBS} ${RTLIBS} -lsamplerate portaudio-v19/lib/.libs/libportaudio.a&quot;
+	LOCAL_PORTAUDIO=&quot;portaudio&quot;
+	LOCAL_PORTAUDIO_CLEAN=&quot;portaudio_clean&quot;
+else
+	LDFLAGS=&quot;-L${portaudio_lib_dir} ${LDFLAGS}&quot;
+	LIBS=&quot;${LIBS} ${RTLIBS} -lsamplerate -lportaudio&quot;
+	LOCAL_PORTAUDIO=&quot;&quot;
+	LOCAL_PORTAUDIO_CLEAN=&quot;&quot;
 fi
-
-if test &quot;$oss&quot; = yes; then
-	if test $HAS_SOUNDCARD_H -eq 0; then
-		{ { echo &quot;$as_me:$LINENO: error: You need soundcard.h to use --enable-oss&quot; &gt;&amp;5
-echo &quot;$as_me: error: You need soundcard.h to use --enable-oss&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }
-	fi
-fi
-
-if test &quot;$portaudio&quot; = yes; then
-	if test $HAS_PORTAUDIO -eq 0; then
-		echo &quot;&quot;
-		echo &quot;Using portaudio provided&quot;
-		echo &quot;&quot;
-		portaudio_include_dir=&quot;portaudio-v19/include&quot;
-		LIBS=&quot;${LIBS} ${RTLIBS} -lsamplerate portaudio-v19/lib/.libs/libportaudio.a&quot;
-		LOCAL_PORTAUDIO=&quot;portaudio&quot;
-	else
-		LDFLAGS=&quot;-L${portaudio_lib_dir} ${LDFLAGS}&quot;
-		LIBS=&quot;${LIBS} ${RTLIBS} -lsamplerate -lportaudio&quot;
-		LOCAL_PORTAUDIO=&quot;&quot;
-	fi
 	AUDIO=&quot;a2d.f90 jtaudio.c resample.c start_portaudio.c&quot;
 
 
@@ -6921,32 +6867,9 @@
 _ACEOF
 
 	CPPFLAGS=&quot;-I${portaudio_include_dir} ${CPPFLAGS}&quot;
-fi
 
 
-if test &quot;$alsa&quot; = yes; then
 
-cat &gt;&gt;confdefs.h &lt;&lt;\_ACEOF
-#define USE_ALSA 1
-_ACEOF
-
-	AUDIO=&quot;start_alsa.c&quot;
-
-	LIBS=&quot;${LIBS} -lasound&quot;
-fi
-
-if test &quot;$oss&quot; = yes; then
-
-cat &gt;&gt;confdefs.h &lt;&lt;\_ACEOF
-#define USE_OSS 1
-_ACEOF
-
-	AUDIO=&quot;start_oss.c&quot;
-
-fi
-
-
-
 if test $HAS_ASOUNDLIB_H -eq 1; then
 	cat &gt;&gt;confdefs.h &lt;&lt;\_ACEOF
 #define HAS_ASOUNDLIB_H 1
@@ -6982,7 +6905,6 @@
 
 fi
 
-
 if test &quot;$F2PY&quot; = &quot;&quot;; then
 	{ { echo &quot;$as_me:$LINENO: error: You are missing f2py&quot; &gt;&amp;5
 echo &quot;$as_me: error: You are missing f2py&quot; &gt;&amp;2;}
@@ -6998,7 +6920,9 @@
 
 LOCAL_PORTAUDIO=&quot;${LOCAL_PORTAUDIO}&quot;
 
+LOCAL_PORTAUDIO_CLEAN=&quot;${LOCAL_PORTAUDIO_CLEAN}&quot;
 
+
 cat &gt;confcache &lt;&lt;\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -7668,6 +7592,7 @@
 <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">s, at FC</A>@,$FC,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">s, at AUDIO</A>@,$AUDIO,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">s, at LOCAL_PORTAUDIO</A>@,$LOCAL_PORTAUDIO,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">+s, at LOCAL_PORTAUDIO_CLEAN</A>@,$LOCAL_PORTAUDIO_CLEAN,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">s, at LIBOBJS</A>@,$LIBOBJS,;t t
 <A HREF="https://lists.berlios.de/mailman/listinfo/wsjt-svn">s, at LTLIBOBJS</A>@,$LTLIBOBJS,;t t
 CEOF
@@ -7951,18 +7876,12 @@
 	echo &quot;Using gfortran as fortran compiler.&quot;;
 fi
 
-if test $portaudio == &quot;yes&quot;; then
-	echo &quot;Using portaudio.&quot;;
-fi
+echo
 
-if test $alsa == &quot;yes&quot;; then
-	echo &quot;Using alsa.&quot;;
+if test $HAS_PORTAUDIO -eq 0; then
+	echo &quot;Using built in portaudio distribution&quot;
 fi
 
-if test $oss == &quot;yes&quot;; then
-	echo &quot;Using oss.&quot;;
-fi
-
 echo
 echo &quot;Compiling $PACKAGE_NAME $PACKAGE_VERSION&quot;
 echo

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2007-05-05 20:37:59 UTC (rev 384)
+++ trunk/configure.ac	2007-05-08 18:15:18 UTC (rev 385)
@@ -20,7 +20,7 @@
 CFLAGS=&quot;$OLD_CFLAGS&quot;
 
 dnl Lets guess at some likely places for extra libs/includes XXX -db
-CPPFLAGS=&quot;-I/usr/local/include -I/usr/include/alsa -I/usr/local/include/alsa ${CPPFLAGS}&quot;
+CPPFLAGS=&quot;-I/usr/local/include ${CPPFLAGS}&quot;
 LDFLAGS=&quot;-L/usr/local/lib ${LDFLAGS}&quot;
 LIBS=&quot; -lpthread ${LIBS}&quot;
 
@@ -88,7 +88,6 @@
 AC_PATH_PROG(GFORTRAN, gfortran)
 dnl
 dnl FreeBSD currently installs gfortran as gfortran42
-dnl See <A HREF="http://gcc.gnu.org/fortran/">http://gcc.gnu.org/fortran/</A>
 dnl
 AC_PATH_PROG(GFORTRAN, gfortran42)
 AC_MSG_CHECKING([gfortran lib path])
@@ -236,27 +235,7 @@
 if test $HAS_PORTAUDIO_H -eq 1 -a $HAS_PORTAUDIO_LIB -eq 1; then
 	HAS_PORTAUDIO=1
 fi
-dnl alsa soundsupport
-dnl =================
 
-AC_ARG_ENABLE(alsa,
-AC_HELP_STRING([--enable-alsa],[Force ALSA SOUNDCARD usage.]),
-[alsa=$enableval] , [alsa=no])
-
-dnl oss soundsupport
-dnl ================
-
-AC_ARG_ENABLE(oss,
-AC_HELP_STRING([--enable-oss],[Force OSS SOUND usage.]),
-[oss=$enableval] , [oss=no])
-
-dnl portaudio soundsupport
-dnl ======================
-
-AC_ARG_ENABLE(portaudio,
-AC_HELP_STRING([--enable-portaudio],[Force PORTAUDIO SOUND usage.]),
-[portaudio=$enableval], [portaudio=no])
-
 dnl pick gfortran or g95
 dnl ====================
 
@@ -306,66 +285,31 @@
 dnl set defaults
 dnl ============
 
-
-if test &quot;$alsa&quot; != yes -a &quot;$oss&quot; != yes -a \
-	&quot;$portaudio&quot; != yes; then
-        if test $HAS_PORTAUDIO -eq 1; then
-		[portaudio=yes];
-	elif test $HAS_ASOUNDLIB_H -eq 1; then
-		[alsa=yes];
-	elif test $HAS_SOUNDCARD_H -eq 1; then
-		[oss=yes];
-	fi
+if test $HAS_ASOUNDLIB_H -eq 1; then
+	CPPFLAGS=&quot;-I/usr/include/alsa -I/usr/local/include/alsa $(CPPFLAGS)&quot;	
+	LDFLAGS=&quot;${ASOUNDLIBS} ${LDFLAGS}&quot;
 fi
 
 dnl =============
 dnl sanity tests.
 
-if test &quot;$alsa&quot; = yes; then
-	if test $HAS_ASOUNDLIB_H -eq 0; then
-		AC_MSG_ERROR([You need asoundlib.h to use --enable-alsa])
-	fi
+if test $HAS_PORTAUDIO -eq 0; then
+	portaudio_include_dir=&quot;portaudio-v19/include&quot;
+	LIBS=&quot;${LIBS} ${RTLIBS} -lsamplerate portaudio-v19/lib/.libs/libportaudio.a&quot;
+	LOCAL_PORTAUDIO=&quot;portaudio&quot;
+	LOCAL_PORTAUDIO_CLEAN=&quot;portaudio_clean&quot;
+else
+	LDFLAGS=&quot;-L${portaudio_lib_dir} ${LDFLAGS}&quot;
+	LIBS=&quot;${LIBS} ${RTLIBS} -lsamplerate -lportaudio&quot;
+	LOCAL_PORTAUDIO=&quot;&quot;
+	LOCAL_PORTAUDIO_CLEAN=&quot;&quot;
 fi
-
-if test &quot;$oss&quot; = yes; then
-	if test $HAS_SOUNDCARD_H -eq 0; then
-		AC_MSG_ERROR([You need soundcard.h to use --enable-oss])
-	fi
-fi
-
-if test &quot;$portaudio&quot; = yes; then
-	if test $HAS_PORTAUDIO -eq 0; then
-		echo &quot;&quot;
-		echo &quot;Using portaudio provided&quot;
-		echo &quot;&quot;
-		portaudio_include_dir=&quot;portaudio-v19/include&quot;
-		LIBS=&quot;${LIBS} ${RTLIBS} -lsamplerate portaudio-v19/lib/.libs/libportaudio.a&quot;
-		LOCAL_PORTAUDIO=&quot;portaudio&quot;
-	else
-		LDFLAGS=&quot;-L${portaudio_lib_dir} ${LDFLAGS}&quot;
-		LIBS=&quot;${LIBS} ${RTLIBS} -lsamplerate -lportaudio&quot;
-		LOCAL_PORTAUDIO=&quot;&quot;
-	fi
 	AC_SUBST(AUDIO, &quot;a2d.f90 jtaudio.c resample.c start_portaudio.c&quot;)
 	AC_DEFINE(USE_PORTAUDIO, 1, [Define if you want PORTAUDIO used.])
 	CPPFLAGS=&quot;-I${portaudio_include_dir} ${CPPFLAGS}&quot;
-fi
 
 dnl =====================
-dnl final audio selection
 
-if test &quot;$alsa&quot; = yes; then
-	AC_DEFINE(USE_ALSA, 1, [Define if you want ALSA used.])
-	AC_SUBST(AUDIO, &quot;start_alsa.c&quot;)
-	LIBS=&quot;${LIBS} -lasound&quot;
-fi
-
-if test &quot;$oss&quot; = yes; then
-	AC_DEFINE(USE_OSS, 1, [Define if you want OSS used.])
-	AC_SUBST(AUDIO, &quot;start_oss.c&quot;)
-fi
-
-
 dnl set conf flags
 dnl ==============
 
@@ -389,7 +333,6 @@
         AC_DEFINE(HAS_SAMPLERATE_H, 1, )
 fi
 
-
 if test &quot;$F2PY&quot; = &quot;&quot;; then
 	AC_MSG_ERROR([You are missing f2py])
 fi
@@ -400,6 +343,7 @@
 AC_SUBST(LIBS, &quot;${LIBS}&quot;)
 AC_SUBST(CFLAGS)
 AC_SUBST(LOCAL_PORTAUDIO,&quot;${LOCAL_PORTAUDIO}&quot;)
+AC_SUBST(LOCAL_PORTAUDIO_CLEAN,&quot;${LOCAL_PORTAUDIO_CLEAN}&quot;)
 
 AC_OUTPUT
 dnl AC_CONFIG_FILES(Makefile)
@@ -417,18 +361,12 @@
 	echo &quot;Using gfortran as fortran compiler.&quot;;
 fi
 
-if test $portaudio == &quot;yes&quot;; then
-	echo &quot;Using portaudio.&quot;;
-fi
+echo
 
-if test $alsa == &quot;yes&quot;; then
-	echo &quot;Using alsa.&quot;;
+if test $HAS_PORTAUDIO -eq 0; then
+	echo &quot;Using built in portaudio distribution&quot;
 fi
 
-if test $oss == &quot;yes&quot;; then
-	echo &quot;Using oss.&quot;;
-fi
-
 echo
 echo &quot;Compiling $PACKAGE_NAME $PACKAGE_VERSION&quot;
 echo

Deleted: trunk/start_alsa.c
===================================================================
--- trunk/start_alsa.c	2007-05-05 20:37:59 UTC (rev 384)
+++ trunk/start_alsa.c	2007-05-08 18:15:18 UTC (rev 385)
@@ -1,568 +0,0 @@
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;alsa/asoundlib.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;time.h&gt;
-#include &lt;sys/time.h&gt;
-#include &quot;fivehz.h&quot;
-
-#if 1
-#define ALSA_LOG
-#endif
-#if 0
-#define ALSA_LOG_BUFFERS
-#endif
-#if 0
-#define ALSA_PLAYBACK_LOG
-#define ALSA_CAPTURE_LOG
-#endif
-#define BUFFER_TIME               2000*1000
-
-
-typedef struct alsa_driver_s {
-	snd_pcm_t	*audio_fd;
-	int		 capabilities;
-	int		 open_mode;
-	int		 has_pause_resume;
-	int		 is_paused;
-	uint32_t		 output_sample_rate, input_sample_rate;
-	double		 sample_rate_factor;
-	uint32_t	 num_channels;
-	uint32_t	 bits_per_sample;
-	uint32_t	 bytes_per_frame;
-	uint32_t	 bytes_in_buffer;      /* number of bytes writen to audio hardware   */
-	int16_t		*app_buffer_y1;
-	int16_t		*app_buffer_y2;
-	int		*app_buffer_offset;
-	int		 app_buffer_length;
-	double		*Tsec;
-	double		*tbuf;
-	int		*ibuf;
-	int		*ndsec;
-	int		*tx_ok;
-	int		 tx_starting;
-	int		 tx_offset;
-	int		*tr_period;
-	int		*nwave;
-	int		*nmode;
-	int		*transmitting;
-
-	snd_pcm_uframes_t  buffer_size;
-	snd_pcm_uframes_t  period_size;
-	int32_t		 mmap; 
-} alsa_driver_t;
-
-alsa_driver_t alsa_driver_playback;
-alsa_driver_t alsa_driver_capture;
-void *alsa_capture_buffers[2];
-void *alsa_playback_buffers[2];
-
-static snd_output_t *jcd_out;
-
-/*
- * open the audio device for writing to
- */
-static int ao_alsa_open(alsa_driver_t *this_gen, int32_t *input_rate, snd_pcm_stream_t direction ) {
-  alsa_driver_t        *this = (alsa_driver_t *) this_gen;
-  char                 *pcm_device;
-  snd_pcm_hw_params_t  *params;
-  snd_pcm_sw_params_t  *swparams;
-  snd_pcm_access_mask_t *mask;
-  snd_pcm_uframes_t     period_size_min; 
-  snd_pcm_uframes_t     period_size_max; 
-  snd_pcm_uframes_t     buffer_size_min;
-  snd_pcm_uframes_t     buffer_size_max;
-  snd_pcm_format_t      format;
-  uint32_t              buffer_time=BUFFER_TIME;
-  snd_pcm_uframes_t     buffer_time_to_size;
-  int                   err, dir;
-  int                 open_mode=1; /* NONBLOCK */
-  /* int                   open_mode=0;  BLOCK */
-  uint32_t            rate=*input_rate;
-  this-&gt;input_sample_rate=*input_rate;
-
-  snd_pcm_hw_params_alloca(&amp;params);
-  snd_pcm_sw_params_alloca(&amp;swparams);
-  err = snd_output_stdio_attach(&amp;jcd_out, stdout, 0);
-  
-  this-&gt;num_channels = 2;
-  if (direction == SND_PCM_STREAM_PLAYBACK) {
-    pcm_device=&quot;plug:front&quot;;
-  } else {
-    pcm_device=&quot;default&quot;;
-  }
-
-#ifdef ALSA_LOG
-  printf(&quot;audio_alsa_out: Audio Device name = %s\n&quot;,pcm_device);
-  printf(&quot;audio_alsa_out: Number of channels = %d\n&quot;,this-&gt;num_channels);
-#endif
-
-  if (this-&gt;audio_fd) {
-    printf(&quot;audio_alsa_out:Already open...WHY!&quot;);
-    snd_pcm_close (this-&gt;audio_fd);
-    this-&gt;audio_fd = NULL;
-  }
-
-  this-&gt;bytes_in_buffer        = 0;
-  /*
-   * open audio device
-   */
-  err=snd_pcm_open(&amp;this-&gt;audio_fd, pcm_device, direction, open_mode);      
-  if(err &lt;0 ) {                                                           
-    printf (&quot;audio_alsa_out: snd_pcm_open() of %s failed: %s\n&quot;, pcm_device, snd_strerror(err));               
-    printf (&quot;audio_alsa_out: &gt;&gt;&gt; check if another program already uses PCM &lt;&lt;&lt;\n&quot;);
-    return 0;
-  }
-  /* printf (&quot;audio_alsa_out: snd_pcm_open() opened %s\n&quot;, pcm_device); */ 
-  /* We wanted non blocking open but now put it back to normal */
-  //snd_pcm_nonblock(this-&gt;audio_fd, 0);
-  snd_pcm_nonblock(this-&gt;audio_fd, 1);
-  /*
-   * configure audio device
-   */
-  err = snd_pcm_hw_params_any(this-&gt;audio_fd, params);
-  if (err &lt; 0) {
-    printf (&quot;audio_alsa_out: broken configuration for this PCM: no configurations available: %s\n&quot;,
-	     snd_strerror(err));
-    goto close;
-  }
-  /* set interleaved access */
-  if (this-&gt;mmap != 0) {
-    mask = alloca(snd_pcm_access_mask_sizeof());
-    snd_pcm_access_mask_none(mask);
-    snd_pcm_access_mask_set(mask, SND_PCM_ACCESS_MMAP_INTERLEAVED);
-    snd_pcm_access_mask_set(mask, SND_PCM_ACCESS_MMAP_NONINTERLEAVED);
-    snd_pcm_access_mask_set(mask, SND_PCM_ACCESS_MMAP_COMPLEX);
-    err = snd_pcm_hw_params_set_access_mask(this-&gt;audio_fd, params, mask);
-    if (err &lt; 0) {
-      printf ( &quot;audio_alsa_out: mmap not availiable, falling back to compatiblity mode\n&quot;);
-      this-&gt;mmap=0;
-      err = snd_pcm_hw_params_set_access(this-&gt;audio_fd, params,
-                                     SND_PCM_ACCESS_RW_NONINTERLEAVED);
-    }
-  } else {
-    err = snd_pcm_hw_params_set_access(this-&gt;audio_fd, params,
-                                     SND_PCM_ACCESS_RW_NONINTERLEAVED);
-  }
-      
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: access type not available: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-  /* set the sample format S16 */
-  /* ALSA automatically appends _LE or _BE depending on the CPU */
-  format = SND_PCM_FORMAT_S16;
-  err = snd_pcm_hw_params_set_format(this-&gt;audio_fd, params, format );
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: sample format non available: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-  /* set the number of channels */
-  err = snd_pcm_hw_params_set_channels(this-&gt;audio_fd, params, this-&gt;num_channels);
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: Cannot set number of channels to %d (err=%d:%s)\n&quot;, 
-	     this-&gt;num_channels, err, snd_strerror(err));
-    goto close;
-  }
-#if SND_LIB_VERSION &gt;= 0x010009
-  /* Restrict a configuration space to contain only real hardware rates */
-  err = snd_pcm_hw_params_set_rate_resample(this-&gt;audio_fd, params, 0);
-#endif
-  /* set the stream rate [Hz] */
-  dir=0;
-  err = snd_pcm_hw_params_set_rate_near(this-&gt;audio_fd, params, &amp;rate, &amp;dir);
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: rate not available: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-  this-&gt;output_sample_rate = (uint32_t)rate;
-  if (this-&gt;input_sample_rate != this-&gt;output_sample_rate) {
-    printf ( &quot;audio_alsa_out: audio rate : %d requested, %d provided by device/sec\n&quot;,
-	     this-&gt;input_sample_rate, this-&gt;output_sample_rate);
-  }
-  buffer_time_to_size = ( (uint64_t)buffer_time * rate) / 1000000;
-  err = snd_pcm_hw_params_get_buffer_size_min(params, &amp;buffer_size_min);
-  err = snd_pcm_hw_params_get_buffer_size_max(params, &amp;buffer_size_max);
-  dir=0;
-  err = snd_pcm_hw_params_get_period_size_min(params, &amp;period_size_min,&amp;dir);
-  dir=0;
-  err = snd_pcm_hw_params_get_period_size_max(params, &amp;period_size_max,&amp;dir);
-#ifdef ALSA_LOG_BUFFERS
-  printf(&quot;Buffer size range from %lu to %lu\n&quot;,buffer_size_min, buffer_size_max);
-  printf(&quot;Period size range from %lu to %lu\n&quot;,period_size_min, period_size_max);
-  printf(&quot;Buffer time size %lu\n&quot;,buffer_time_to_size);
-#endif
-  this-&gt;buffer_size = buffer_time_to_size;
-  if (buffer_size_max &lt; this-&gt;buffer_size)
-	this-&gt;buffer_size = buffer_size_max;
-  if (buffer_size_min &gt; this-&gt;buffer_size)
-	this-&gt;buffer_size = buffer_size_min;
-  this-&gt;period_size = this-&gt;buffer_size/8;
-  if (this-&gt;period_size &gt; 2048)
-	this-&gt;period_size = 2048;
-  this-&gt;buffer_size = this-&gt;period_size*8;
-#ifdef ALSA_LOG_BUFFERS
-  printf(&quot;To choose buffer_size = %ld\n&quot;,this-&gt;buffer_size);
-  printf(&quot;To choose period_size = %ld\n&quot;,this-&gt;period_size);
-#endif
-
-#if 0
-  /* Set period to buffer size ratios at 8 periods to 1 buffer */
-  dir=-1;
-  periods=8;
-  err = snd_pcm_hw_params_set_periods_near(this-&gt;audio_fd, params, &amp;periods ,&amp;dir);
-  if (err &lt; 0) {
-    xprintf (this-&gt;class-&gt;xine, XINE_VERBOSITY_DEBUG, 
-	     &quot;audio_alsa_out: unable to set any periods: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-  /* set the ring-buffer time [us] (large enough for x us|y samples ...) */
-  dir=0;
-  err = snd_pcm_hw_params_set_buffer_time_near(this-&gt;audio_fd, params, &amp;buffer_time, &amp;dir);
-  if (err &lt; 0) {
-    xprintf (this-&gt;class-&gt;xine, XINE_VERBOSITY_DEBUG, 
-	     &quot;audio_alsa_out: buffer time not available: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-#endif
-#if 1
-  /* set the period time [us] (interrupt every x us|y samples ...) */
-  dir=0;
-  err = snd_pcm_hw_params_set_period_size_near(this-&gt;audio_fd, params, &amp;(this-&gt;period_size), &amp;dir);
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: period time not available: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-#endif
-  dir=0;
-  err = snd_pcm_hw_params_get_period_size(params, &amp;(this-&gt;period_size), &amp;dir);
-
-  dir=0;
-  err = snd_pcm_hw_params_set_buffer_size_near(this-&gt;audio_fd, params, &amp;(this-&gt;buffer_size));
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: buffer time not available: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-  err = snd_pcm_hw_params_get_buffer_size(params, &amp;(this-&gt;buffer_size));
-#ifdef ALSA_LOG_BUFFERS
-  printf(&quot;was set period_size = %ld\n&quot;,this-&gt;period_size);
-  printf(&quot;was set buffer_size = %ld\n&quot;,this-&gt;buffer_size);
-#endif
-  if (2*this-&gt;period_size &gt; this-&gt;buffer_size) {
-    printf ( &quot;audio_alsa_out: buffer to small, could not use\n&quot;);
-    goto close;
-  }
-  
-  /* write the parameters to device */
-  err = snd_pcm_hw_params(this-&gt;audio_fd, params);
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: pcm hw_params failed: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-  /* Check for pause/resume support */
-  this-&gt;has_pause_resume = ( snd_pcm_hw_params_can_pause (params)
-			    &amp;&amp; snd_pcm_hw_params_can_resume (params) );
-  //  printf( &quot;audio_alsa_out:open pause_resume=%d\n&quot;, this-&gt;has_pause_resume);
-  this-&gt;sample_rate_factor = (double) this-&gt;output_sample_rate / (double) this-&gt;input_sample_rate;
-  this-&gt;bytes_per_frame = snd_pcm_frames_to_bytes (this-&gt;audio_fd, 1);
-  /*
-   * audio buffer size handling
-   */
-  /* Copy current parameters into swparams */
-  err = snd_pcm_sw_params_current(this-&gt;audio_fd, swparams);
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: Unable to determine current swparams: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-  /* align all transfers to 1 sample */
-  err = snd_pcm_sw_params_set_xfer_align(this-&gt;audio_fd, swparams, 1);
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: Unable to set transfer alignment: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-  /* allow the transfer when at least period_size samples can be processed */
-  err = snd_pcm_sw_params_set_avail_min(this-&gt;audio_fd, swparams, this-&gt;period_size);
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: Unable to set available min: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-  if (direction == SND_PCM_STREAM_PLAYBACK) {
-  	/* start the transfer when the buffer contains at least period_size samples */
-	err = snd_pcm_sw_params_set_start_threshold(this-&gt;audio_fd, swparams, this-&gt;buffer_size);
-  } else {
-	err = snd_pcm_sw_params_set_start_threshold(this-&gt;audio_fd, swparams, -1);
-  }
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: Unable to set start threshold: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-
-  if (direction == SND_PCM_STREAM_PLAYBACK) {
-        /* never stop the transfer, even on xruns */
-  	err = snd_pcm_sw_params_set_stop_threshold(this-&gt;audio_fd, swparams, this-&gt;buffer_size);
-  } else {
-  	err = snd_pcm_sw_params_set_stop_threshold(this-&gt;audio_fd, swparams, this-&gt;buffer_size);
-  }
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: Unable to set stop threshold: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-
-  /* Install swparams into current parameters */
-  err = snd_pcm_sw_params(this-&gt;audio_fd, swparams);
-  if (err &lt; 0) {
-    printf ( &quot;audio_alsa_out: Unable to set swparams: %s\n&quot;, snd_strerror(err));
-    goto close;
-  }
-#ifdef ALSA_LOG
-  snd_pcm_dump_setup(this-&gt;audio_fd, jcd_out); 
-  snd_pcm_sw_params_dump(swparams, jcd_out);
-#endif
-  
-  return this-&gt;output_sample_rate;
-
-close:
-  snd_pcm_close (this-&gt;audio_fd);
-  this-&gt;audio_fd=NULL;
-  return 0;
-}
-
-int16_t zero_buffer[65536];
-
-int playback_callback(alsa_driver_t *alsa_driver_playback) {
-	alsa_driver_t *this = alsa_driver_playback;
-	int result;
-	struct timeval tv;
-	double stime;
-	int nsec;
-	int i,n;
-	static int ic;
-	snd_pcm_sframes_t delay;	
-	static short int n2;
-	int16_t b0[2048];
-
-//	printf(&quot;playback callback\n&quot;);
-	snd_pcm_delay(this-&gt;audio_fd, &amp;delay);
-	gettimeofday(&amp;tv, NULL);
-	stime = (double) tv.tv_sec + ((double)tv.tv_usec / 1000000.0) +
-		*(this-&gt;ndsec) * 0.1;
-	//	stime = stime + ((double)delay / (double)(this-&gt;output_sample_rate));
-	*(this-&gt;Tsec) = stime;
-	//printf(&quot;PLAY:TIME, %lf, %ld, %ld, %d\n&quot;, stime, delay, this-&gt;output_sample_rate, *this-&gt;ndsec);
-	if(!(this-&gt;tx_starting) &amp;&amp; (*(this-&gt;tx_ok)) ) {
-		nsec = (int)stime;
-		n = nsec / *(this-&gt;tr_period);  
-		ic = (int)(stime - *(this-&gt;tr_period) * n) * this-&gt;output_sample_rate;
-		ic = ic % *(this-&gt;nwave);
-		this-&gt;tx_offset = ic;
-	}
-	this-&gt;tx_starting = *(this-&gt;tx_ok);
-	*(this-&gt;transmitting) = *(this-&gt;tx_ok);
-	if(*(this-&gt;tx_ok)) {
-	  /*
-		alsa_playback_buffers[0] = this-&gt;app_buffer_y1 + this-&gt;tx_offset;
-		alsa_playback_buffers[1] = this-&gt;app_buffer_y1 + this-&gt;tx_offset;
-	  */
-	  alsa_playback_buffers[0] = b0;
-	  alsa_playback_buffers[1] = b0;
-	  for(i=0; i&lt;this-&gt;period_size; i++) {
-	    n2=this-&gt;app_buffer_y1[ic];
-	    addnoise_(&amp;n2);
-	    b0[i]=n2;
-	    ic++;
-	    if(ic&gt;=*this-&gt;nwave) {
-	      if(*this-&gt;nmode==2) {
-		*this-&gt;tx_ok=0;
-		ic--;
-	      }
-	      else
-		ic = ic % *this-&gt;nwave;       //Wrap buffer pointer
-	    }
-	  }
-	} else {
-		alsa_playback_buffers[0] = zero_buffer;
-		alsa_playback_buffers[1] = zero_buffer;
-	}
-	result = snd_pcm_writen(this-&gt;audio_fd, alsa_playback_buffers, this-&gt;period_size);
-	this-&gt;tx_offset += this-&gt;period_size;
-	if (result != this-&gt;period_size) {
-		printf(&quot;Playback write failed. Expected %lu samples, sent only %d\n&quot;, this-&gt;period_size, result);
-#ifdef ALSA_PLAYBACK_LOG
-		snd_pcm_status_t *pcm_stat;
-		snd_pcm_status_alloca(&amp;pcm_stat);
-		snd_pcm_status(this-&gt;audio_fd, pcm_stat);
-		snd_pcm_status_dump(pcm_stat, jcd_out);
-#endif
-	}
-  	fivehztx_();                             //Call fortran routine
-	return result;
-}
-
-int capture_callback(alsa_driver_t *alsa_driver_capture) {
-	alsa_driver_t *this = alsa_driver_capture;
-	int result;
-	struct timeval tv;
-	double stime;
-	int ib;
-	snd_pcm_sframes_t delay;	
-#ifdef ALSA_CAPTURE_LOG
-	printf(&quot;capture callback %d samples\n&quot;, this-&gt;period_size);
-#endif
-#ifdef ALSA_CAPTURE_LOG
-	snd_pcm_status_t *pcm_stat;
-	snd_pcm_status_alloca(&amp;pcm_stat);
-	snd_pcm_status(this-&gt;audio_fd, pcm_stat);
-        snd_pcm_status_dump(pcm_stat, jcd_out);
-#endif
-	snd_pcm_delay(this-&gt;audio_fd, &amp;delay);
-	gettimeofday(&amp;tv, NULL);
-	stime = (double) tv.tv_sec + ((double)tv.tv_usec / 1000000.0) +
-		*(this-&gt;ndsec) * 0.1;
-	//	stime = stime - ((double)delay / (double)(this-&gt;output_sample_rate));
-	*(this-&gt;Tsec) = stime;
-	ib=*(this-&gt;ibuf);
-	this-&gt;tbuf[ib] = stime;
-	//printf(&quot;CAP:TIME, %d, %lf, %ld, %ld, %d\n&quot;,ib, stime, delay, this-&gt;output_sample_rate, *this-&gt;ndsec);
-	ib++;
-	if(ib&gt;=1024)
-		ib = 0;
-	*(this-&gt;ibuf) = ib;
-
-	alsa_capture_buffers[0]=this-&gt;app_buffer_y1 + *(this-&gt;app_buffer_offset);
-	alsa_capture_buffers[1]=this-&gt;app_buffer_y2 + *(this-&gt;app_buffer_offset);
-	result = snd_pcm_readn(this-&gt;audio_fd, alsa_capture_buffers, this-&gt;period_size);
-	*(this-&gt;app_buffer_offset) += this-&gt;period_size;
-	if ( *(this-&gt;app_buffer_offset) &gt;= this-&gt;app_buffer_length )
-		*(this-&gt;app_buffer_offset)=0;  /* FIXME: implement proper wrapping */
-#ifdef ALSA_CAPTURE_LOG
-	printf(&quot;result=%d\n&quot;,result);
-	snd_pcm_status(this-&gt;audio_fd, pcm_stat);
-        snd_pcm_status_dump(pcm_stat, jcd_out);
-#endif
-	fivehz_();                             //Call fortran routine
-	return result;
-}
-
-int playback_xrun(alsa_driver_t *alsa_driver_playback) {
-	alsa_driver_t *this = alsa_driver_playback;
-	snd_pcm_status_t *pcm_stat;
-	snd_pcm_status_alloca(&amp;pcm_stat);
-	printf(&quot;playback xrun\n&quot;);
-	snd_pcm_status(this-&gt;audio_fd, pcm_stat);
-        snd_pcm_status_dump(pcm_stat, jcd_out);
-	snd_pcm_prepare(this-&gt;audio_fd);
-	return 0;
-}
-
-int capture_xrun(alsa_driver_t *alsa_driver_capture) {
-	alsa_driver_t *this = alsa_driver_capture;
-	snd_pcm_status_t *pcm_stat;
-	snd_pcm_status_alloca(&amp;pcm_stat);
-	printf(&quot;capture xrun\n&quot;);
-	snd_pcm_status(this-&gt;audio_fd, pcm_stat);
-        snd_pcm_status_dump(pcm_stat, jcd_out);
-	return 0;
-}
-
-void ao_alsa_loop(void *iarg) {
-	int playback_nfds;
-	int capture_nfds;
-	struct pollfd *pfd;
-	int nfds;
-	int capture_index;
-	unsigned short playback_revents;
-	unsigned short capture_revents;
-	playback_nfds = snd_pcm_poll_descriptors_count (
-				alsa_driver_playback.audio_fd);
-	capture_nfds = snd_pcm_poll_descriptors_count (
-				alsa_driver_capture.audio_fd);
-	pfd = (struct pollfd *) malloc (sizeof (struct pollfd) * 
-		(playback_nfds + capture_nfds));
-	
-	nfds=0;	
-	snd_pcm_poll_descriptors (alsa_driver_playback.audio_fd,
-		&amp;pfd[0],
-		playback_nfds);
-	nfds += playback_nfds;
-	snd_pcm_poll_descriptors (alsa_driver_capture.audio_fd,
-		&amp;pfd[nfds],
-		capture_nfds);
-	capture_index = nfds;
-	nfds += capture_nfds;
-	while(1) {
-		if (poll (pfd, nfds, 200000) &lt; 0) {
-			printf(&quot;poll failed\n&quot;);
-			continue;
-		}
-		snd_pcm_poll_descriptors_revents(alsa_driver_playback.audio_fd, &amp;pfd[0], playback_nfds, &amp;playback_revents);
-		snd_pcm_poll_descriptors_revents(alsa_driver_capture.audio_fd, &amp;pfd[capture_index], capture_nfds, &amp;capture_revents);
-		//if ((playback_revents &amp; POLLERR) || ((capture_revents) &amp; POLLERR)) {
-		if (((capture_revents) &amp; POLLERR)) {
-			printf(&quot;pollerr\n&quot;);
-			capture_xrun(&amp;alsa_driver_capture);
-			return;
-		}
-		if (((playback_revents) &amp; POLLERR)) {
-			printf(&quot;pollerr\n&quot;);
-			playback_xrun(&amp;alsa_driver_capture);
-			return;
-		}
-		if (playback_revents &amp; POLLOUT) {
-			playback_callback(&amp;alsa_driver_playback);
-		}
-		if (capture_revents &amp; POLLIN) {
-			capture_callback(&amp;alsa_driver_capture);
-		}
-	}
-		
-	return;
-}
-
-void decode1_(void *iarg);
-
-int start_threads_(int *ndevin, int *ndevout, short y1[], short y2[],
-	int *nbuflen, int *iwrite, short iwave[],
-	int *nwave, int *nfsample, int *nsamperbuf,
-	int *TRPeriod, int *TxOK, int *ndebug,
-	int *Transmitting, double *Tsec, int *ngo, int *nmode,
-	double tbuf[], int *ibuf, int *ndsec)
-{
-  pthread_t thread1,thread2;
-  int iret1,iret2;
-  int iarg1 = 1;
-  //int32_t rate=11025;
-  int32_t rate=*nfsample;
-  alsa_driver_capture.app_buffer_y1 = y1;
-  alsa_driver_capture.app_buffer_y2 = y2;
-  alsa_driver_capture.app_buffer_offset = iwrite;
-  alsa_driver_capture.app_buffer_length = *nbuflen;
-  alsa_driver_capture.Tsec = Tsec;
-  alsa_driver_capture.tbuf = tbuf;
-  alsa_driver_capture.ibuf = ibuf;
-  alsa_driver_capture.ndsec = ndsec;
-  alsa_driver_playback.Tsec = Tsec;
-  alsa_driver_playback.app_buffer_y1 = iwave;
-  alsa_driver_playback.tx_ok = TxOK;
-  alsa_driver_playback.tr_period = TRPeriod;
-  alsa_driver_playback.nwave = nwave;
-  alsa_driver_playback.nmode = nmode;
-  alsa_driver_playback.transmitting = Transmitting;
-  alsa_driver_playback.ndsec = ndsec;
-  //  printf(&quot;start_threads: creating thread for decode1\n&quot;);
-  iret1 = pthread_create(&amp;thread1,NULL,(void*)&amp;decode1_,&amp;iarg1);
-/* Open audio card. */
-  printf(&quot;Using ALSA sound.\n&quot;);
-  ao_alsa_open(&amp;alsa_driver_playback, &amp;rate, SND_PCM_STREAM_PLAYBACK);
-  ao_alsa_open(&amp;alsa_driver_capture, &amp;rate, SND_PCM_STREAM_CAPTURE);
-
-/*
- * Start audio io thread
- */
-  iret2 = pthread_create(&amp;thread2, NULL, (void *)&amp;ao_alsa_loop, NULL);
-  snd_pcm_prepare(alsa_driver_capture.audio_fd);
-  snd_pcm_start(alsa_driver_capture.audio_fd);
-  snd_pcm_prepare(alsa_driver_playback.audio_fd);
-  //snd_pcm_start(alsa_driver_playback.audio_fd);
-  return 0;
-}

Deleted: trunk/start_oss.c
===================================================================
--- trunk/start_oss.c	2007-05-05 20:37:59 UTC (rev 384)
+++ trunk/start_oss.c	2007-05-08 18:15:18 UTC (rev 385)
@@ -1,306 +0,0 @@
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;time.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;sys/soundcard.h&gt;
-#include &lt;string.h&gt;
-
-#define AUDIOBUFSIZE	4096
-#define FRAMESPERBUFFER 1024
-#define TIMEOUT 1000L		/* select time out for audio device */
-
-/* XXX probably safer to use a local buffer due to the wsjt threaded nature. */
-static char rcv_buf[AUDIOBUFSIZE];	
-static char tx_buf[AUDIOBUFSIZE];
-
-#define MAXDSPNAME 16
-
-extern void decode1_(int *iarg);
-void oss_loop(int *iarg);
-
-/*
- * local state data referencing some gcom common fortran variables as well
- */
-static struct audio_data {
-  int fd_in;		/* Audio fd in; used only locally in this function  */
-  int fd_out;		/* Audio fd out; used only locally in this function */
-  double *Tsec;		/* Present time                       SoundIn,SoundOut */
-  double *tbuf;		/* Tsec at time of input callback          SoundIn  */
-  int *iwrite;		/* Write pointer to Rx ring buffer         SoundIn  */
-  int *ibuf;		/* Most recent input buffer#               SoundIn  */
-  int *TxOK;		/* OK to transmit?                         SoundIn  */
-  int *ndebug;		/* Write debugging info?                   GUI      */
-  int *ndsec;		/* Dsec in units of 0.1 s                  GUI      */
-  int *Transmitting;	/* Actually transmitting?                  SoundOut */
-  int *nwave;		/* Number of samples in iwave              SoundIn  */
-  int *nmode;		/* Which WSJT mode?                        GUI      */
-  int *trperiod;	/* Tx or Rx period in seconds              GUI      */
-  int nbuflen;
-  int nfs;
-  int16_t *y1;		/* Ring buffer for audio channel 0         SoundIn  */
-  int16_t *y2;		/* Ring buffer for audio channel 1         SoundIn  */
-  short  *iwave;
-}data;
-
-/*
- * start_threads()
- * inputs	- ndevin  device number for input
- *		- ndevout device number for output
- *		- y1 short int array for channel 0
- *		- y2 short int array for channel 1
- * 		- nmax
- *		- iwrite
- *		- iwave
- *		- nwave
- *		- rate 
- *		- NSPB
- *		- TRPeriod
- *		- TxOK
- *		- ndebug debug output or not?
- *		- Transmitting
- *		- Tsec
- *		- ngo
- *		- nmode
- *		- tbuf
- *		- ibuf
- *		- ndsec
- * output	- ?
- * side effects - Called from audio_init.f90 to start audio decode and
- *		  OSS thread.
- */
-
-int
-start_threads_(int *ndevin, int *ndevout, short y1[], short y2[],
-	       int *nbuflen, int *iwrite, short iwave[],
-	       int *nwave, int *nfsample, int *nsamperbuf,
-	       int *TRPeriod, int *TxOK, int *ndebug,
-	       int *Transmitting, double *Tsec, int *ngo, int *nmode,
-	       double tbuf[], int *ibuf, int *ndsec,
-	       char *PttPort, char *devin_name, char *devout_name)
-{
-  pthread_t thread1,thread2;
-  int iret1,iret2;
-  int iarg1 = 1,iarg2 = 2;
-  int32_t rate=*nfsample;
-  int samplesize;
-  int format;
-  int channels;
-  double dnfs;
-  int i;
-  char *p;
-
-  /* Remove space if present */
-  p = strchr(devin_name, ' ');
-  if(p != NULL)
-    *p = '\0';
-
-  p = strchr(devout_name, ' ');
-  if(p != NULL)
-    *p = '\0';
-
-  data.fd_in = open(devin_name, O_RDONLY, 0);
-
-  if(data.fd_in &lt; 0) { 
-	fprintf(stderr, &quot;Cannot open %s for input.\n&quot;, devin_name);
-	return (-1);
-  }
-
-  if (*devout_name == '\0') {
-    close(data.fd_in);
-    data.fd_in = open(devin_name, O_RDWR, 0);
-
-    if(data.fd_in &lt; 0) { 
-      fprintf(stderr, &quot;Cannot open %s for input.\n&quot;, devin_name);
-      return (-1);
-    }
-
-    data.fd_out = data.fd_in;
-    if(ioctl(data.fd_in, SNDCTL_DSP_SETDUPLEX, 0) &lt; 0) {
-      fprintf(stderr, &quot;Cannot use %s for full duplex.\n&quot;, devin_name);
-      return(-1);
-    }
-  } else {
-    data.fd_out = open(devout_name, O_WRONLY, 0);
-
-    if(data.fd_out &lt; 0) { 
-      fprintf(stderr, &quot;Cannot open %s for output.\n&quot;, devout_name);
-      return (-1);
-    }
-  }
-
-  data.Tsec = Tsec;
-  data.tbuf = tbuf;
-  data.iwrite = iwrite;
-  data.ibuf = ibuf;
-  data.TxOK = TxOK;
-  data.ndebug = ndebug;
-  data.ndsec = ndsec;
-  data.Transmitting = Transmitting;
-  data.y1 = y1;
-  data.y2 = y2;
-  data.nbuflen = *nbuflen;
-  data.nmode = nmode;
-  data.nwave = nwave;
-  data.iwave = iwave;
-  data.nfs = *nfsample;
-  data.trperiod = TRPeriod;
-
-  dnfs=(double)*nfsample;
-
-  channels = 2;
-  if(ioctl (data.fd_in, SNDCTL_DSP_CHANNELS, &amp;channels) == -1) {
-	fprintf (stderr, &quot;Unable to set 2 channels for input.\n&quot;);
-	return (-1);
-  }
-
-  if(channels != 2) {
-    fprintf (stderr, &quot;Unable to set 2 channels.\n&quot;);
-    return (-1);
-  }
-
-  format = AFMT_S16_NE;
-  if(ioctl (data.fd_in, SNDCTL_DSP_SETFMT, &amp;format) == -1) {
-	fprintf (stderr, &quot;Unable to set format for input.\n&quot;);
-	return (-1);
-  }
-
-  if(ioctl (data.fd_in, SNDCTL_DSP_SPEED, &amp;rate) == -1) {
-	fprintf (stderr, &quot;Unable to set rate for input\n&quot;);
-	return (-1);
-  }
-
-  printf(&quot;Audio OSS streams running normally.\n&quot;);
-  printf(&quot;******************************************************************\n&quot;);
-  printf(&quot;Opened %s for input.\n&quot;, devin_name);
-  if (*devout_name != '\0')
-    printf(&quot;Opened %s for output.\n&quot;, devout_name);
-  else
-    printf(&quot;Opened %s for output.\n&quot;, devin_name);
-  printf(&quot;Rate set = %d\n&quot;, rate);
-
-  //  printf(&quot;start_threads: creating thread for oss_loop\n&quot;);
-  iret1 = pthread_create(&amp;thread1, NULL,
-			 (void *(*)(void *))oss_loop, &amp;iarg1);
-  // printf(&quot;start_threads: creating thread for decode1_\n&quot;);
-  iret2 = pthread_create(&amp;thread2, NULL,
-			 (void *(*)(void *))decode1_,&amp;iarg2);
-}
-
-/*
- * oss_loop
- *
- * inputs	- int pointer NOT USED
- * output	- none
- * side effects	-
- */
-
-void
-oss_loop(int *iarg)
-{
-  fd_set readfds, writefds;
-  int nfds = 0;
-  struct timeval timeout = {0, 0};
-  struct timeval tv;
-  int nread;
-  unsigned int i;
-  static int n=0;
-  static int n2=0;
-  static int ia=0;
-  static int ib=0;
-  static int ic=0;
-  static int16_t *in;
-  static int16_t *wptr;
-  static int TxOKz=0;
-  static int ncall=0;
-  static int nsec=0;
-  static double stime;
-
-  for (;;) {
-    FD_ZERO(&amp;readfds );
-    FD_ZERO(&amp;writefds );
-    FD_SET(data.fd_in, &amp;readfds);
-    FD_SET(data.fd_out, &amp;writefds);
-
-    timeout.tv_usec = TIMEOUT;
-    if(select(FD_SETSIZE, &amp;readfds, &amp;writefds, NULL, &amp;timeout) &gt; 0) {
-      if(FD_ISSET(data.fd_in, &amp;readfds)) {
-	    nread = read (data.fd_in, rcv_buf, AUDIOBUFSIZE);
-	    if(nread &lt;= 0) {
-	      fprintf(stderr, &quot;Read error %d\n&quot;, nread);
-	      return;
-	    }
-	    if(nread == AUDIOBUFSIZE) {
-	      /* Get System time */
-	      gettimeofday(&amp;tv, NULL);
-	      stime = (double) tv.tv_sec + ((double)tv.tv_usec / 1000000.0) +
-		*(data.ndsec) * 0.1;
-	      *(data.Tsec) = stime;
-
-	      ncall++;
-
-	      /* increment buffer pointers only if data available */
-	      ia=*(data.iwrite);
-	      ib=*(data.ibuf);
-	      data.tbuf[ib-1] = stime;	/* convert to c index to store */
-	      ib++;
-	      if(ib&gt;FRAMESPERBUFFER)
-		ib=1; 
-	      *(data.ibuf) = ib;
-	      in = (int16_t *)rcv_buf;	/* XXX */
-	      for(i=0; i&lt;FRAMESPERBUFFER; i++) {
-		data.y1[ia] = (*in++);
-		data.y2[ia] = (*in++);
-		ia++;
-	      }
-
-	      if(ia &gt;= data.nbuflen)
-		ia=0;  //Wrap buffer pointer if necessary
-	      *(data.iwrite) = ia;            /* Save buffer pointer */
-	      fivehz_();                      /* Call fortran routine */
-	    }
-      }
-      if(FD_ISSET(data.fd_in, &amp;writefds)) {
-	/* Get System time */
-	gettimeofday(&amp;tv, NULL);
-	stime = (double) tv.tv_sec + ((double)tv.tv_usec / 1000000.0) +
-	  *(data.ndsec) * 0.1;
-	*(data.Tsec) = stime;
-
-	if(*(data.TxOK) &amp;&amp; (!TxOKz)) {
-	  nsec = (int)stime;
-	  n = nsec / *(data.trperiod);
-	  ic = (int)(stime - *(data.trperiod) * n) * data.nfs;
-	  ic = ic % *(data.nwave);
-	}
-
-	TxOKz = *(data.TxOK);
-	*(data.Transmitting) = *(data.TxOK);
-	wptr = (int16_t *)tx_buf;		/* XXX */
-	if(*(data.TxOK))  {
-	  for(i=0 ; i&lt;FRAMESPERBUFFER; i++)  {
-	    n2 = data.iwave[ic];
-	    addnoise_(&amp;n2);
-	    *wptr++ = n2;			/* left */
-	    *wptr++ = n2;			/* right */
-	    ic++;
-	    if(ic &gt;= *(data.nwave)) {
-	      ic = ic % *(data.nwave);	/* Wrap buffer pointer if necessary */
-	      if(*(data.nmode) == 2)
-		*(data.TxOK) = 0;
-	    }
-	  }
-	} else {
-	  memset(tx_buf, 0, AUDIOBUFSIZE);
-	}
-	if(write(data.fd_out, tx_buf, AUDIOBUFSIZE) &lt; 0) {
-	  fprintf(stderr, &quot;Can't write to soundcard.\n&quot;);
-	  return;
-	}
-	fivehztx_();                             /* Call fortran routine */
-      }
-    }
-  }
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000069.html">[WSJT-SVN] r384 - trunk
</A></li>
	<LI>Next message: <A HREF="000071.html">[WSJT-SVN] r386 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70">[ date ]</a>
              <a href="thread.html#70">[ thread ]</a>
              <a href="subject.html#70">[ subject ]</a>
              <a href="author.html#70">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wsjt-svn">More information about the wsjt-svn
mailing list</a><br>
</body></html>
